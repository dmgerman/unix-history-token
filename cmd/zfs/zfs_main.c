begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright 2012 Milan Jurik. All rights reserved.  * Copyright (c) 2012, Joyent, Inc. All rights reserved.  * Copyright (c) 2011-2012 Pawel Jakub Dawidek. All rights reserved.  * Copyright (c) 2013 Steven Hartland.  All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>.  * Copyright 2016 Nexenta Systems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<libnvpair.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/list.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<libzfs_core.h>
end_include

begin_include
include|#
directive|include
file|<zfs_prop.h>
end_include

begin_include
include|#
directive|include
file|<zfs_deleg.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<aclutils.h>
end_include

begin_include
include|#
directive|include
file|<directory.h>
end_include

begin_include
include|#
directive|include
file|<idmap.h>
end_include

begin_include
include|#
directive|include
file|"zfs_iter.h"
end_include

begin_include
include|#
directive|include
file|"zfs_util.h"
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_decl_stmt
name|libzfs_handle_t
modifier|*
name|g_zfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mnttab_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|history_str
index|[
name|HIS_MAX_RECORD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|log_history
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_userspace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_allow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unallow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_hold
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_holds
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_release
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_diff
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_bookmark
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Enable a reasonable set of defaults for libumem debugging on DEBUG builds.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|HELP_CLONE
block|,
name|HELP_CREATE
block|,
name|HELP_DESTROY
block|,
name|HELP_GET
block|,
name|HELP_INHERIT
block|,
name|HELP_UPGRADE
block|,
name|HELP_LIST
block|,
name|HELP_MOUNT
block|,
name|HELP_PROMOTE
block|,
name|HELP_RECEIVE
block|,
name|HELP_RENAME
block|,
name|HELP_ROLLBACK
block|,
name|HELP_SEND
block|,
name|HELP_SET
block|,
name|HELP_SHARE
block|,
name|HELP_SNAPSHOT
block|,
name|HELP_UNMOUNT
block|,
name|HELP_UNSHARE
block|,
name|HELP_ALLOW
block|,
name|HELP_UNALLOW
block|,
name|HELP_USERSPACE
block|,
name|HELP_GROUPSPACE
block|,
name|HELP_HOLD
block|,
name|HELP_HOLDS
block|,
name|HELP_RELEASE
block|,
name|HELP_DIFF
block|,
name|HELP_BOOKMARK
block|, }
name|zfs_help_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zfs_command
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
name|zfs_help_t
name|usage
decl_stmt|;
block|}
name|zfs_command_t
typedef|;
end_typedef

begin_comment
comment|/*  * Master command table.  Each ZFS command has a name, associated function, and  * usage message.  The usage messages need to be internationalized, so we have  * to have a function to return the usage message based on a command index.  *  * These commands are organized according to how they are displayed in the usage  * message.  An empty command (one with a NULL name) indicates an empty line in  * the generic usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|zfs_command_t
name|command_table
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|zfs_do_create
block|,
name|HELP_CREATE
block|}
block|,
block|{
literal|"destroy"
block|,
name|zfs_do_destroy
block|,
name|HELP_DESTROY
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"snapshot"
block|,
name|zfs_do_snapshot
block|,
name|HELP_SNAPSHOT
block|}
block|,
block|{
literal|"rollback"
block|,
name|zfs_do_rollback
block|,
name|HELP_ROLLBACK
block|}
block|,
block|{
literal|"clone"
block|,
name|zfs_do_clone
block|,
name|HELP_CLONE
block|}
block|,
block|{
literal|"promote"
block|,
name|zfs_do_promote
block|,
name|HELP_PROMOTE
block|}
block|,
block|{
literal|"rename"
block|,
name|zfs_do_rename
block|,
name|HELP_RENAME
block|}
block|,
block|{
literal|"bookmark"
block|,
name|zfs_do_bookmark
block|,
name|HELP_BOOKMARK
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"list"
block|,
name|zfs_do_list
block|,
name|HELP_LIST
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"set"
block|,
name|zfs_do_set
block|,
name|HELP_SET
block|}
block|,
block|{
literal|"get"
block|,
name|zfs_do_get
block|,
name|HELP_GET
block|}
block|,
block|{
literal|"inherit"
block|,
name|zfs_do_inherit
block|,
name|HELP_INHERIT
block|}
block|,
block|{
literal|"upgrade"
block|,
name|zfs_do_upgrade
block|,
name|HELP_UPGRADE
block|}
block|,
block|{
literal|"userspace"
block|,
name|zfs_do_userspace
block|,
name|HELP_USERSPACE
block|}
block|,
block|{
literal|"groupspace"
block|,
name|zfs_do_userspace
block|,
name|HELP_GROUPSPACE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"mount"
block|,
name|zfs_do_mount
block|,
name|HELP_MOUNT
block|}
block|,
block|{
literal|"unmount"
block|,
name|zfs_do_unmount
block|,
name|HELP_UNMOUNT
block|}
block|,
block|{
literal|"share"
block|,
name|zfs_do_share
block|,
name|HELP_SHARE
block|}
block|,
block|{
literal|"unshare"
block|,
name|zfs_do_unshare
block|,
name|HELP_UNSHARE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"send"
block|,
name|zfs_do_send
block|,
name|HELP_SEND
block|}
block|,
block|{
literal|"receive"
block|,
name|zfs_do_receive
block|,
name|HELP_RECEIVE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"allow"
block|,
name|zfs_do_allow
block|,
name|HELP_ALLOW
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"unallow"
block|,
name|zfs_do_unallow
block|,
name|HELP_UNALLOW
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"hold"
block|,
name|zfs_do_hold
block|,
name|HELP_HOLD
block|}
block|,
block|{
literal|"holds"
block|,
name|zfs_do_holds
block|,
name|HELP_HOLDS
block|}
block|,
block|{
literal|"release"
block|,
name|zfs_do_release
block|,
name|HELP_RELEASE
block|}
block|,
block|{
literal|"diff"
block|,
name|zfs_do_diff
block|,
name|HELP_DIFF
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOMMAND
value|(sizeof (command_table) / sizeof (command_table[0]))
end_define

begin_decl_stmt
name|zfs_command_t
modifier|*
name|current_command
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_usage
parameter_list|(
name|zfs_help_t
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|HELP_CLONE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tclone [-p] [-o property=value] ... "
literal|"<snapshot><filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CREATE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tcreate [-p] [-o property=value] ... "
literal|"<filesystem>\n"
literal|"\tcreate [-ps] [-b blocksize] [-o property=value] ... "
literal|"-V<size><volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DESTROY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdestroy [-fnpRrv]<filesystem|volume>\n"
literal|"\tdestroy [-dnpRrv] "
literal|"<filesystem|volume>@<snap>[%<snap>][,...]\n"
literal|"\tdestroy<filesystem|volume>#<bookmark>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tget [-rHp] [-d max] "
literal|"[-o \"all\" | field[,...]]\n"
literal|"\t    [-t type[,...]] [-s source[,...]]\n"
literal|"\t<\"all\" | property[,...]> "
literal|"[filesystem|volume|snapshot|bookmark] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_INHERIT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tinherit [-rS]<property> "
literal|"<filesystem|volume|snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UPGRADE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tupgrade [-v]\n"
literal|"\tupgrade [-r] [-V version]<-a | filesystem ...>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LIST
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlist [-Hp] [-r|-d max] [-o property[,...]] "
literal|"[-s property]...\n\t    [-S property]... [-t type[,...]] "
literal|"[filesystem|volume|snapshot] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_MOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tmount\n"
literal|"\tmount [-vO] [-o opts]<-a | filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_PROMOTE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tpromote<clone-filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RECEIVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treceive [-vnsFu]<filesystem|volume|"
literal|"snapshot>\n"
literal|"\treceive [-vnsFu] [-o origin=<snapshot>] [-d | -e] "
literal|"<filesystem>\n"
literal|"\treceive -A<filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RENAME
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trename [-f]<filesystem|volume|snapshot> "
literal|"<filesystem|volume|snapshot>\n"
literal|"\trename [-f] -p<filesystem|volume><filesystem|volume>\n"
literal|"\trename -r<snapshot><snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ROLLBACK
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trollback [-rRf]<snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SEND
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsend [-DnPpRvLe] [-[iI] snapshot] "
literal|"<snapshot>\n"
literal|"\tsend [-Le] [-i snapshot|bookmark] "
literal|"<filesystem|volume|snapshot>\n"
literal|"\tsend [-nvPe] -t<receive_resume_token>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tset<property=value> ... "
literal|"<filesystem|volume|snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tshare<-a | filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SNAPSHOT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsnapshot [-r] [-o property=value] ... "
literal|"<filesystem|volume>@<snap> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNMOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunmount [-f] "
literal|"<-a | filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNSHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunshare "
literal|"<-a | filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ALLOW
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tallow<filesystem|volume>\n"
literal|"\tallow [-ldug] "
literal|"<\"everyone\"|user|group>[,...]<perm|@setname>[,...]\n"
literal|"\t<filesystem|volume>\n"
literal|"\tallow [-ld] -e<perm|@setname>[,...] "
literal|"<filesystem|volume>\n"
literal|"\tallow -c<perm|@setname>[,...]<filesystem|volume>\n"
literal|"\tallow -s @setname<perm|@setname>[,...] "
literal|"<filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNALLOW
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunallow [-rldug] "
literal|"<\"everyone\"|user|group>[,...]\n"
literal|"\t    [<perm|@setname>[,...]]<filesystem|volume>\n"
literal|"\tunallow [-rld] -e [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
literal|"\tunallow [-r] -c [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
literal|"\tunallow [-r] -s @setname [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_USERSPACE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tuserspace [-Hinp] [-o field[,...]] "
literal|"[-s field] ...\n"
literal|"\t    [-S field] ... [-t type[,...]] "
literal|"<filesystem|snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GROUPSPACE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tgroupspace [-Hinp] [-o field[,...]] "
literal|"[-s field] ...\n"
literal|"\t    [-S field] ... [-t type[,...]] "
literal|"<filesystem|snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_HOLD
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\thold [-r]<tag><snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_HOLDS
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tholds [-r]<snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RELEASE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trelease [-r]<tag><snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DIFF
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdiff [-FHt]<snapshot> "
literal|"[snapshot|filesystem]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_BOOKMARK
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tbookmark<snapshot><bookmark>\n"
argument_list|)
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|nomem
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utility function to guarantee malloc() success.  */
end_comment

begin_function
name|void
modifier|*
name|safe_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|safe_strdup
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|dupstr
init|=
name|strdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|dupstr
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
name|dupstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback routine that will print out information for each of  * the properties.  */
end_comment

begin_function
specifier|static
name|int
name|usage_prop_cb
parameter_list|(
name|int
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|cb
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NO    "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"YES    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  YES   "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   NO   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZPROP_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage message.  If we're inside a command, display only the usage for  * that command.  Otherwise, iterate over the entire command table and display  * a complete usage message.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|boolean_t
name|show_properties
init|=
name|B_FALSE
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|current_command
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage: zfs command args ...\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"where 'command' is one of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nEach dataset is of the form: "
literal|"pool/[dataset/]*dataset[@name]\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|current_command
operator|->
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"inherit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|show_properties
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|show_properties
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe following properties are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%-14s %s  %s   %s\n\n"
argument_list|,
literal|"PROPERTY"
argument_list|,
literal|"EDIT"
argument_list|,
literal|"INHERIT"
argument_list|,
literal|"VALUES"
argument_list|)
expr_stmt|;
comment|/* Iterate over all properties */
operator|(
name|void
operator|)
name|zprop_iter
argument_list|(
name|usage_prop_cb
argument_list|,
name|fp
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
literal|"userused@..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NO       NO<size>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
literal|"groupused@..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NO       NO<size>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
literal|"userquota@..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"YES       NO<size> | none\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
literal|"groupquota@..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"YES       NO<size> | none\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
literal|"written@<snap>"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NO       NO<size>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nSizes are specified in bytes "
literal|"with standard units such as K, M, G, etc.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nUser-defined properties can "
literal|"be specified by using a name containing a colon (:).\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe {user|group}{used|quota}@ "
literal|"properties must be appended with\n"
literal|"a user or group specifier of one of these forms:\n"
literal|"    POSIX name      (eg: \"matt\")\n"
literal|"    POSIX id        (eg: \"126829\")\n"
literal|"    SMB name@domain (eg: \"matt@sun\")\n"
literal|"    SMB SID         (eg: \"S-1-234-567-89\")\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nFor the property list, run: %s\n"
argument_list|)
argument_list|,
literal|"zfs set|get"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nFor the delegated permission list, run: %s\n"
argument_list|)
argument_list|,
literal|"zfs allow|unallow"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See comments at end of main(). 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a property=value argument string and add it to the given nvlist.  * Modifies the argument inplace.  */
end_comment

begin_function
specifier|static
name|int
name|parseprop
parameter_list|(
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|char
modifier|*
name|propname
parameter_list|)
block|{
name|char
modifier|*
name|propval
decl_stmt|,
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing "
literal|"'=' for property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property '%s' "
literal|"specified multiple times\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_depth
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|depth
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|opt
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tmp
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s is not an integer\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Depth can not be negative.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
name|flags
operator||=
operator|(
name|ZFS_ITER_DEPTH_LIMIT
operator||
name|ZFS_ITER_RECURSE
operator|)
expr_stmt|;
return|return
operator|(
name|depth
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PROGRESS_DELAY
value|2
end_define

begin_comment
comment|/* seconds */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pt_reverse
init|=
literal|"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|pt_begin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pt_header
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|pt_shown
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|start_progress_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|pt_begin
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|PROGRESS_DELAY
expr_stmt|;
name|pt_shown
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_progress_header
parameter_list|(
name|char
modifier|*
name|header
parameter_list|)
block|{
name|assert
argument_list|(
name|pt_header
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pt_header
operator|=
name|safe_strdup
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt_shown
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|header
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_progress
parameter_list|(
name|char
modifier|*
name|update
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pt_shown
operator|&&
name|time
argument_list|(
name|NULL
argument_list|)
operator|>
name|pt_begin
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|update
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s%*.*s"
argument_list|,
name|pt_header
argument_list|,
name|update
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|pt_reverse
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pt_shown
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pt_shown
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|update
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s%*.*s"
argument_list|,
name|update
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|pt_reverse
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|finish_progress
parameter_list|(
name|char
modifier|*
name|done
parameter_list|)
block|{
if|if
condition|(
name|pt_shown
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|done
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pt_header
argument_list|)
expr_stmt|;
name|pt_header
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the dataset is mountable and should be automatically mounted.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|should_auto_mount
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|ZFS_PROP_CANMOUNT
argument_list|,
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
operator|==
name|ZFS_CANMOUNT_ON
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs clone [-p] [-o prop=value] ...<snap><fs | vol>  *  * Given an existing dataset, create a writable copy whose initial contents  * are the same as the source.  The newly created dataset maintains a  * dependency on the original; the original cannot be destroyed so long as  * the clone exists.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"o:p"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* open the source dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
condition|)
block|{
comment|/* 		 * Now create the ancestors of the target dataset.  If the 		 * target already exists and '-p' option was used we should not 		 * complain. 		 */
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* pass to libzfs */
name|ret
operator|=
name|zfs_clone
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|props
argument_list|)
expr_stmt|;
comment|/* create the mountpoint if necessary */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|clone
decl_stmt|;
name|clone
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the user doesn't want the dataset 			 * automatically mounted, then skip the mount/share 			 * step. 			 */
if|if
condition|(
name|should_auto_mount
argument_list|(
name|clone
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_mount
argument_list|(
name|clone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"clone "
literal|"successfully created, "
literal|"but not mounted\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_share
argument_list|(
name|clone
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"clone "
literal|"successfully created, "
literal|"but not shared\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|clone
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|ret
operator|)
return|;
name|usage
label|:
if|if
condition|(
name|zhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs create [-p] [-o prop=value] ... fs  * zfs create [-ps] [-b blocksize] [-o prop=value] ... -V vol size  *  * Create a new dataset.  This command can be used to create filesystems  * and volumes.  Snapshot creation is handled by 'zfs snapshot'.  * For volumes, the user must specify a size to be used.  *  * The '-s' flag applies only to volumes, and indicates that we should not try  * to set the reservation for this volume.  By default we set a reservation  * equal to the size for any volume.  For pools with SPA_VERSION>=  * SPA_VERSION_REFRESERVATION, we set a refreservation instead.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_type_t
name|type
init|=
name|ZFS_TYPE_FILESYSTEM
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|volsize
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|noreserve
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|bflag
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":V:b:so:p"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'V'
case|:
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|volsize
operator|=
name|intval
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bflag
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"block size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|,
name|optarg
argument_list|)
condition|)
goto|goto
name|error
goto|;
break|break;
case|case
literal|'s'
case|:
name|noreserve
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing size "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|bflag
operator|||
name|noreserve
operator|)
operator|&&
name|type
operator|!=
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'-s' and '-b' can only be "
literal|"used when creating a volume\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing %s argument\n"
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
operator|!
name|noreserve
condition|)
block|{
name|zpool_handle_t
modifier|*
name|zpool_handle
decl_stmt|;
name|nvlist_t
modifier|*
name|real_props
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|spa_version
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|zpool_handle
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|zpool_handle
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|spa_version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zpool_handle
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
operator|>=
name|SPA_VERSION_REFRESERVATION
condition|)
name|resv_prop
operator|=
name|ZFS_PROP_REFRESERVATION
expr_stmt|;
else|else
name|resv_prop
operator|=
name|ZFS_PROP_RESERVATION
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|real_props
operator|=
name|zfs_valid_proplist
argument_list|(
name|g_zfs
argument_list|,
name|type
argument_list|,
name|props
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|zpool_handle
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zpool_handle
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|zpool_close
argument_list|(
name|zpool_handle
argument_list|)
expr_stmt|;
name|volsize
operator|=
name|zvol_volsize_to_reservation
argument_list|(
name|volsize
argument_list|,
name|real_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|real_props
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
name|volsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|nomem
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * Now create the ancestors of target dataset.  If the target 		 * already exists and '-p' option was used we should not 		 * complain. 		 */
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* pass to libzfs */
if|if
condition|(
name|zfs_create
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mount and/or share the new filesystem as appropriate.  We provide a 	 * verbose error message to let the user know that their filesystem was 	 * in fact created, even if we failed to mount or share it. 	 * If the user doesn't want the dataset automatically mounted, 	 * then skip the mount/share step altogether. 	 */
if|if
condition|(
name|should_auto_mount
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem "
literal|"successfully created, but not mounted\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_share
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem "
literal|"successfully created, but not shared\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|error
label|:
if|if
condition|(
name|zhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|badusage
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs destroy [-rRf]<fs, vol>  * zfs destroy [-rRd]<snap>  *  *	-r	Recursively destroy all children  *	-R	Recursively destroy all dependents, including clones  *	-f	Force unmounting of any dependents  *	-d	If we can't destroy now, mark for deferred destruction  *  * Destroys the given dataset.  By default, it will unmount any filesystems,  * and refuse to destroy a dataset that has any dependents.  A dependent can  * either be a child, or a clone of a child.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|destroy_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|boolean_t
name|cb_force
decl_stmt|;
name|boolean_t
name|cb_recurse
decl_stmt|;
name|boolean_t
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_doclones
decl_stmt|;
name|zfs_handle_t
modifier|*
name|cb_target
decl_stmt|;
name|boolean_t
name|cb_defer_destroy
decl_stmt|;
name|boolean_t
name|cb_verbose
decl_stmt|;
name|boolean_t
name|cb_parsable
decl_stmt|;
name|boolean_t
name|cb_dryrun
decl_stmt|;
name|nvlist_t
modifier|*
name|cb_nvl
decl_stmt|;
name|nvlist_t
modifier|*
name|cb_batchedsnaps
decl_stmt|;
comment|/* first snap in contiguous run */
name|char
modifier|*
name|cb_firstsnap
decl_stmt|;
comment|/* previous snap in contiguous run */
name|char
modifier|*
name|cb_prevsnap
decl_stmt|;
name|int64_t
name|cb_snapused
decl_stmt|;
name|char
modifier|*
name|cb_snapspec
decl_stmt|;
name|char
modifier|*
name|cb_bookmark
decl_stmt|;
block|}
name|destroy_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Check for any dependents based on the '-r' or '-R' flags.  */
end_comment

begin_function
specifier|static
name|int
name|destroy_check_dependent
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
init|=
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tname
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|tname
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
comment|/* 		 * This is a direct descendant, not a clone somewhere else in 		 * the hierarchy. 		 */
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has children\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a clone.  We only want to report this if the '-r' 		 * wasn't specified, or the target is a snapshot. 		 */
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_recurse
operator|&&
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
name|ZFS_TYPE_SNAPSHOT
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has dependent clones\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
name|cbp
operator|->
name|cb_dryrun
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_verbose
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_parsable
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"destroy\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would destroy %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"will destroy %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Ignore pools (which we've already flagged as an error before getting 	 * here). 	 */
if|if
condition|(
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|cb_dryrun
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We batch up all contiguous snapshots (even of different 	 * filesystems) and destroy them with one ioctl.  We can't 	 * simply do all snap deletions and then all fs deletions, 	 * because we must delete a clone before its origin. 	 */
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|fnvlist_add_boolean
argument_list|(
name|cb
operator|->
name|cb_batchedsnaps
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|error
init|=
name|zfs_destroy_snaps_nvl
argument_list|(
name|g_zfs
argument_list|,
name|cb
operator|->
name|cb_batchedsnaps
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|fnvlist_free
argument_list|(
name|cb
operator|->
name|cb_batchedsnaps
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_batchedsnaps
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|cb
operator|->
name|cb_force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|zfs_destroy
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_defer_destroy
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_print_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cb
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|cb
operator|->
name|cb_nvl
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_firstsnap
operator|==
name|NULL
condition|)
name|cb
operator|->
name|cb_firstsnap
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_prevsnap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cb
operator|->
name|cb_prevsnap
argument_list|)
expr_stmt|;
comment|/* this snap continues the current range */
name|cb
operator|->
name|cb_prevsnap
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_firstsnap
operator|==
name|NULL
operator|||
name|cb
operator|->
name|cb_prevsnap
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_verbose
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_parsable
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"destroy\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would destroy %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"will destroy %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|cb_firstsnap
operator|!=
name|NULL
condition|)
block|{
comment|/* end of this range */
name|uint64_t
name|used
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|lzc_snaprange_space
argument_list|(
name|cb
operator|->
name|cb_firstsnap
argument_list|,
name|cb
operator|->
name|cb_prevsnap
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_snapused
operator|+=
name|used
expr_stmt|;
name|free
argument_list|(
name|cb
operator|->
name|cb_firstsnap
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_firstsnap
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|cb
operator|->
name|cb_prevsnap
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_prevsnap
operator|=
name|NULL
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_print_snapshots
parameter_list|(
name|zfs_handle_t
modifier|*
name|fs_zhp
parameter_list|,
name|destroy_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|cb
operator|->
name|cb_firstsnap
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cb
operator|->
name|cb_prevsnap
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_iter_snapshots_sorted
argument_list|(
name|fs_zhp
argument_list|,
name|destroy_print_cb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_firstsnap
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|used
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|lzc_snaprange_space
argument_list|(
name|cb
operator|->
name|cb_firstsnap
argument_list|,
name|cb
operator|->
name|cb_prevsnap
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
name|cb
operator|->
name|cb_snapused
operator|+=
name|used
expr_stmt|;
name|free
argument_list|(
name|cb
operator|->
name|cb_firstsnap
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_firstsnap
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|cb
operator|->
name|cb_prevsnap
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_prevsnap
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snapshot_to_nvl_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cb
init|=
name|arg
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check for clones. */
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_doclones
operator|&&
operator|!
name|cb
operator|->
name|cb_defer_destroy
condition|)
block|{
name|cb
operator|->
name|cb_target
operator|=
name|zhp
expr_stmt|;
name|cb
operator|->
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|err
operator|=
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|destroy_check_dependent
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_boolean
argument_list|(
name|cb
operator|->
name|cb_nvl
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
condition|)
name|nomem
argument_list|()
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gather_snapshots
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cb
init|=
name|arg
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|zfs_iter_snapspec
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_snapspec
argument_list|,
name|snapshot_to_nvl_cb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cb
operator|->
name|cb_verbose
condition|)
block|{
name|err
operator|=
name|destroy_print_snapshots
argument_list|(
name|zhp
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|cb_recurse
condition|)
name|err
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|gather_snapshots
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_clones
parameter_list|(
name|destroy_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|cb
operator|->
name|cb_nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|cb
operator|->
name|cb_nvl
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|boolean_t
name|defer
init|=
name|cb
operator|->
name|cb_defer_destroy
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 			 * We can't defer destroy non-snapshots, so set it to 			 * false while destroying the clones. 			 */
name|cb
operator|->
name|cb_defer_destroy
operator|=
name|B_FALSE
expr_stmt|;
name|err
operator|=
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_defer_destroy
operator|=
name|defer
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|destroy_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|,
modifier|*
name|pound
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|ZFS_TYPE_DATASET
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vpndfrR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|cb
operator|.
name|cb_verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_verbose
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_parsable
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|cb
operator|.
name|cb_dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|cb
operator|.
name|cb_defer_destroy
operator|=
name|B_TRUE
expr_stmt|;
name|type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|cb
operator|.
name|cb_force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|at
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|pound
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|!=
name|NULL
condition|)
block|{
comment|/* Build the list of snaps to destroy in cb_nvl. */
name|cb
operator|.
name|cb_nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
operator|*
name|at
operator|=
literal|'\0'
expr_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cb
operator|.
name|cb_snapspec
operator|=
name|at
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|gather_snapshots
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
operator|||
name|cb
operator|.
name|cb_error
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nvlist_empty
argument_list|(
name|cb
operator|.
name|cb_nvl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"could not find any "
literal|"snapshots to destroy; check snapshot names.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_verbose
condition|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|cb
operator|.
name|cb_snapused
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_parsable
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"reclaim\t%llu\n"
argument_list|,
name|cb
operator|.
name|cb_snapused
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|.
name|cb_dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would reclaim %s\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"will reclaim %s\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_dryrun
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|cb_doclones
condition|)
block|{
name|cb
operator|.
name|cb_batchedsnaps
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|err
operator|=
name|destroy_clones
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zfs_destroy_snaps_nvl
argument_list|(
name|g_zfs
argument_list|,
name|cb
operator|.
name|cb_batchedsnaps
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zfs_destroy_snaps_nvl
argument_list|(
name|g_zfs
argument_list|,
name|cb
operator|.
name|cb_nvl
argument_list|,
name|cb
operator|.
name|cb_defer_destroy
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pound
operator|!=
name|NULL
condition|)
block|{
name|int
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dryrun is not supported with bookmark\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_defer_destroy
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"defer destroy is not supported with bookmark\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recursive is not supported with bookmark\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_bookmark_exists
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bookmark '%s' "
literal|"does not exist.\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|nvl
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_destroy_bookmarks
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|g_zfs
argument_list|,
name|err
argument_list|,
literal|"cannot destroy bookmark"
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|cb
operator|.
name|cb_nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
comment|/* Open the given dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cb
operator|.
name|cb_target
operator|=
name|zhp
expr_stmt|;
comment|/* 		 * Perform an explicit check for pools before going any further. 		 */
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_recurse
operator|&&
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"operation does not apply to pools\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs destroy -r "
literal|"%s' to destroy all datasets in the pool\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zpool destroy %s' "
literal|"to destroy the pool itself\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Check for any dependents and/or clones. 		 */
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_doclones
operator|&&
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|destroy_check_dependent
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_error
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cb
operator|.
name|cb_batchedsnaps
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Do the real thing.  The callback will close the 		 * handle regardless of whether it succeeds or not. 		 */
name|err
operator|=
name|destroy_callback
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|zhp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zfs_destroy_snaps_nvl
argument_list|(
name|g_zfs
argument_list|,
name|cb
operator|.
name|cb_batchedsnaps
argument_list|,
name|cb
operator|.
name|cb_defer_destroy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|fnvlist_free
argument_list|(
name|cb
operator|.
name|cb_batchedsnaps
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|cb
operator|.
name|cb_nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|is_recvd_column
parameter_list|(
name|zprop_get_cbdata_t
modifier|*
name|cbp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zfs_get_column_t
name|col
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZFS_GET_NCOLS
operator|&&
operator|(
name|col
operator|=
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
operator|)
operator|!=
name|GET_COL_NONE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|col
operator|==
name|GET_COL_RECVD
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs get [-rHp] [-o all | field[,field]...] [-s source[,source]...]  *< all | property[,property]...>< fs | snap | vol> ...  *  *	-r	recurse over any child datasets  *	-H	scripted mode.  Headers are stripped, and fields are separated  *		by tabs instead of spaces.  *	-o	Set of fields to display.  One of "name,property,value,  *		received,source". Default is "name,property,value,source".  *		"all" is an alias for all five.  *	-s	Set of sources to allow.  One of  *		"local,default,inherited,received,temporary,none".  Default is  *		all six.  *	-p	Display values in parsable (literal) format.  *  *  Prints properties for the given datasets.  The user can control which  *  columns to display as well as which property types to allow.  */
end_comment

begin_comment
comment|/*  * Invoked to display the properties for a single dataset.  */
end_comment

begin_function
specifier|static
name|int
name|get_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|rbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|zprop_source_t
name|sourcetype
decl_stmt|;
name|char
name|source
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zprop_get_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|user_props
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|zprop_list_t
modifier|*
name|pl
init|=
name|cbp
operator|->
name|cb_proplist
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
modifier|*
name|sourceval
decl_stmt|;
name|boolean_t
name|received
init|=
name|is_recvd_column
argument_list|(
name|cbp
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
name|char
modifier|*
name|recvdval
init|=
name|NULL
decl_stmt|;
comment|/* 		 * Skip the special fake placeholder.  This will also skip over 		 * the name property when 'all' is specified. 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|pl
operator|==
name|cbp
operator|->
name|cb_proplist
condition|)
continue|continue;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|sourcetype
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"No such property '%s'\n"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|received
operator|&&
operator|(
name|zfs_prop_get_recvd
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|recvdval
operator|=
name|rbuf
expr_stmt|;
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|buf
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|,
name|recvdval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_prop_userquota
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
if|if
condition|(
name|zfs_prop_get_userquota
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|buf
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_prop_written
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
if|if
condition|(
name|zfs_prop_get_written
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|buf
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|user_props
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
name|strval
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|sourceval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sourceval
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sourceval
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_RECEIVED
expr_stmt|;
block|}
else|else
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_INHERITED
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|source
argument_list|,
name|sourceval
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|received
operator|&&
operator|(
name|zfs_prop_get_recvd
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|recvdval
operator|=
name|rbuf
expr_stmt|;
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|strval
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|,
name|recvdval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zprop_get_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|flags
init|=
name|ZFS_ITER_ARGS_CAN_BE_PATHS
decl_stmt|;
name|int
name|types
init|=
name|ZFS_TYPE_DATASET
operator||
name|ZFS_TYPE_BOOKMARK
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|fields
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|zprop_list_t
name|fake_name
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 	 * Set up default columns and sources. 	 */
name|cb
operator|.
name|cb_sources
operator|=
name|ZPROP_SRC_ALL
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|ZFS_TYPE_DATASET
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":d:o:s:rt:Hp"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|limit
operator|=
name|parse_depth
argument_list|(
name|optarg
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* 			 * Process the set of columns to display.  We zero out 			 * the structure to give us a blank slate. 			 */
name|bzero
argument_list|(
operator|&
name|cb
operator|.
name|cb_columns
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
operator|.
name|cb_columns
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|col_subopts
index|[]
init|=
block|{
literal|"name"
block|,
literal|"property"
block|,
literal|"value"
block|,
literal|"received"
block|,
literal|"source"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|ZFS_GET_NCOLS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too "
literal|"many fields given to -o "
literal|"option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|col_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_RECVD
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_RECVD_PROPS
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"\"all\" conflicts "
literal|"with specific fields "
literal|"given to -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_RECVD
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|4
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_RECVD_PROPS
expr_stmt|;
name|i
operator|=
name|ZFS_GET_NCOLS
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid column name "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|cb
operator|.
name|cb_sources
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|source_subopts
index|[]
init|=
block|{
literal|"local"
block|,
literal|"default"
block|,
literal|"inherited"
block|,
literal|"received"
block|,
literal|"temporary"
block|,
literal|"none"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|source_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_LOCAL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_INHERITED
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_RECEIVED
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_NONE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid source "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
name|types
operator|=
literal|0
expr_stmt|;
name|flags
operator|&=
operator|~
name|ZFS_ITER_PROP_LISTSNAPS
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|type_subopts
index|[]
init|=
block|{
literal|"filesystem"
block|,
literal|"volume"
block|,
literal|"snapshot"
block|,
literal|"bookmark"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|type_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|types
operator||=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|types
operator||=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|types
operator||=
name|ZFS_TYPE_BOOKMARK
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|types
operator|=
name|ZFS_TYPE_DATASET
operator||
name|ZFS_TYPE_BOOKMARK
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type '%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * As part of zfs_expand_proplist(), we keep track of the maximum column 	 * width for each property.  For the 'NAME' (and 'SOURCE') columns, we 	 * need to know the maximum name length.  However, the user likely did 	 * not specify 'name' as one of the properties to fetch, so we need to 	 * make sure we always include at least this property for 	 * print_get_headers() to work properly. 	 */
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|!=
name|NULL
condition|)
block|{
name|fake_name
operator|.
name|pl_prop
operator|=
name|ZFS_PROP_NAME
expr_stmt|;
name|fake_name
operator|.
name|pl_width
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|fake_name
operator|.
name|pl_next
operator|=
name|cb
operator|.
name|cb_proplist
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
operator|&
name|fake_name
expr_stmt|;
block|}
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
comment|/* run for each object */
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|types
argument_list|,
name|NULL
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|limit
argument_list|,
name|get_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|==
operator|&
name|fake_name
condition|)
name|zprop_free_list
argument_list|(
name|fake_name
operator|.
name|pl_next
argument_list|)
expr_stmt|;
else|else
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inherit [-rS]<property><fs|vol> ...  *  *	-r	Recurse over all children  *	-S	Revert to received value, if any  *  * For each dataset specified on the command line, inherit the given property  * from its parent.  Inheriting a property at the pool level will cause it to  * use the default value.  The '-r' flag will recurse over all children, and is  * useful for setting a property on a hierarchy-wide basis, regardless of any  * local modifications for each dataset.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|inherit_cbdata
block|{
specifier|const
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|boolean_t
name|cb_received
decl_stmt|;
block|}
name|inherit_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|inherit_recurse_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|inherit_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|cb
operator|->
name|cb_propname
argument_list|)
decl_stmt|;
comment|/* 	 * If we're doing it recursively, then ignore properties that 	 * are not valid for this type of dataset. 	 */
if|if
condition|(
name|prop
operator|!=
name|ZPROP_INVAL
operator|&&
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zfs_prop_inherit
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_propname
argument_list|,
name|cb
operator|->
name|cb_received
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inherit_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|inherit_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
return|return
operator|(
name|zfs_prop_inherit
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_propname
argument_list|,
name|cb
operator|->
name|cb_received
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|inherit_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|propname
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|boolean_t
name|received
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rS"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|received
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|propname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s property is read-only\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
operator|&&
operator|!
name|received
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' property cannot "
literal|"be inherited\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_RESERVATION
operator|||
name|prop
operator|==
name|ZFS_PROP_REFQUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_REFRESERVATION
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs set "
literal|"%s=none' to clear\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs "
literal|"inherit -S %s' to revert to received "
literal|"value\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|received
operator|&&
operator|(
name|prop
operator|==
name|ZFS_PROP_VOLSIZE
operator|||
name|prop
operator|==
name|ZFS_PROP_VERSION
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' property cannot "
literal|"be reverted to a received value\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_propname
operator|=
name|propname
expr_stmt|;
name|cb
operator|.
name|cb_received
operator|=
name|received
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
condition|)
block|{
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|inherit_recurse_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|inherit_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|upgrade_cbdata
block|{
name|uint64_t
name|cb_numupgraded
decl_stmt|;
name|uint64_t
name|cb_numsamegraded
decl_stmt|;
name|uint64_t
name|cb_numfailed
decl_stmt|;
name|uint64_t
name|cb_version
decl_stmt|;
name|boolean_t
name|cb_newer
decl_stmt|;
name|boolean_t
name|cb_foundone
decl_stmt|;
name|char
name|cb_lastfs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
block|}
name|upgrade_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|same_pool
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|len1
init|=
name|strcspn
argument_list|(
name|name
argument_list|,
literal|"/@"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhname
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strcspn
argument_list|(
name|zhname
argument_list|,
literal|"/@"
argument_list|)
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|zhname
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_list_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|version
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
decl_stmt|;
comment|/* list if it's old/new */
if|if
condition|(
operator|(
operator|!
name|cb
operator|->
name|cb_newer
operator|&&
name|version
operator|<
name|ZPL_VERSION
operator|)
operator|||
operator|(
name|cb
operator|->
name|cb_newer
operator|&&
name|version
operator|>
name|ZPL_VERSION
operator|)
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_newer
condition|)
block|{
name|str
operator|=
name|gettext
argument_list|(
literal|"The following filesystems are "
literal|"formatted using a newer software version and\n"
literal|"cannot be accessed on the current system.\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|gettext
argument_list|(
literal|"The following filesystems are "
literal|"out of date, and can be upgraded.  After being\n"
literal|"upgraded, these filesystems (and any 'zfs send' "
literal|"streams generated from\n"
literal|"subsequent snapshots) will no longer be "
literal|"accessible by older software versions.\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_foundone
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  FILESYSTEM\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"---  ------------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_foundone
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%2u   %s\n"
argument_list|,
name|version
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_set_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|version
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
decl_stmt|;
name|int
name|needed_spa_version
decl_stmt|;
name|int
name|spa_version
decl_stmt|;
if|if
condition|(
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|needed_spa_version
operator|=
name|zfs_spa_version_map
argument_list|(
name|cb
operator|->
name|cb_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed_spa_version
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|spa_version
operator|<
name|needed_spa_version
condition|)
block|{
comment|/* can't upgrade */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s: can not be "
literal|"upgraded; the pool version needs to first "
literal|"be upgraded\nto version %d\n\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|needed_spa_version
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* upgrade */
if|if
condition|(
name|version
operator|<
name|cb
operator|->
name|cb_version
condition|)
block|{
name|char
name|verstr
index|[
literal|16
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|verstr
argument_list|,
sizeof|sizeof
argument_list|(
name|verstr
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
name|cb
operator|->
name|cb_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_lastfs
index|[
literal|0
index|]
operator|&&
operator|!
name|same_pool
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_lastfs
argument_list|)
condition|)
block|{
comment|/* 			 * If they did "zfs upgrade -a", then we could 			 * be doing ioctls to different pools.  We need 			 * to log this history once to each pool, and bypass 			 * the normal history logging that happens in main(). 			 */
operator|(
name|void
operator|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
expr_stmt|;
name|log_history
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
literal|"version"
argument_list|,
name|verstr
argument_list|)
operator|==
literal|0
condition|)
name|cb
operator|->
name|cb_numupgraded
operator|++
expr_stmt|;
else|else
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
operator|->
name|cb_lastfs
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|>
name|cb
operator|->
name|cb_version
condition|)
block|{
comment|/* can't downgrade */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s: can not be downgraded; "
literal|"it is already at version %u\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|cb_numsamegraded
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs upgrade  * zfs upgrade -v  * zfs upgrade [-r] [-V<version>]<-a | filesystem>  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|all
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|showversions
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|upgrade_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|flags
init|=
name|ZFS_ITER_ARGS_CAN_BE_PATHS
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rvV:a"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|showversions
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|zfs_prop_string_to_index
argument_list|(
name|ZFS_PROP_VERSION
argument_list|,
name|optarg
argument_list|,
operator|&
name|cb
operator|.
name|cb_version
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid version %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|all
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|all
operator|&&
operator|!
name|argc
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
operator|)
operator||
name|cb
operator|.
name|cb_version
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|showversions
operator|&&
operator|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
operator|||
name|all
operator|||
name|cb
operator|.
name|cb_version
operator|||
name|argc
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|all
operator|||
name|argc
operator|)
operator|&&
operator|(
name|showversions
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|argc
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|showversions
condition|)
block|{
comment|/* Show info on available versions. */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following filesystem versions are "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  DESCRIPTION\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  -----------------------------------------"
literal|"---------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 1   Initial ZFS filesystem version\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 2   Enhanced directory entries\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 3   Case insensitive and filesystem "
literal|"user identifier (FUID)\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 4   userquota, groupquota "
literal|"properties\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 5   System attributes\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nFor more information on a particular "
literal|"version, including supported releases,\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"see the ZFS Administration Guide.\n\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|||
name|all
condition|)
block|{
comment|/* Upgrade filesystems */
if|if
condition|(
name|cb
operator|.
name|cb_version
operator|==
literal|0
condition|)
name|cb
operator|.
name|cb_version
operator|=
name|ZPL_VERSION
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|upgrade_set_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%llu filesystems upgraded\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_numupgraded
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_numsamegraded
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%llu filesystems already at "
literal|"this version\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_numsamegraded
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_numfailed
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* List old-version filesytems */
name|boolean_t
name|found
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"This system is currently running "
literal|"ZFS filesystem version %llu.\n\n"
argument_list|)
argument_list|,
name|ZPL_VERSION
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|upgrade_list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|found
operator|=
name|cb
operator|.
name|cb_foundone
expr_stmt|;
name|cb
operator|.
name|cb_foundone
operator|=
name|B_FALSE
expr_stmt|;
name|cb
operator|.
name|cb_newer
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|upgrade_list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_foundone
operator|&&
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All filesystems are "
literal|"formatted with the current version.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs userspace [-Hinp] [-o field[,...]] [-s field [-s field]...]  *               [-S field [-S field]...] [-t type[,...]] filesystem | snapshot  * zfs groupspace [-Hinp] [-o field[,...]] [-s field [-s field]...]  *                [-S field [-S field]...] [-t type[,...]] filesystem | snapshot  *  *	-H      Scripted mode; elide headers and separate columns by tabs.  *	-i	Translate SID to POSIX ID.  *	-n	Print numeric ID instead of user/group name.  *	-o      Control which fields to display.  *	-p	Use exact (parsable) numeric output.  *	-s      Specify sort columns, descending order.  *	-S      Specify sort columns, ascending order.  *	-t      Control which object types to display.  *  *	Displays space consumed by, and quotas on, each user in the specified  *	filesystem or snapshot.  */
end_comment

begin_comment
comment|/* us_field_types, us_field_hdr and us_field_names should be kept in sync */
end_comment

begin_enum
enum|enum
name|us_field_types
block|{
name|USFIELD_TYPE
block|,
name|USFIELD_NAME
block|,
name|USFIELD_USED
block|,
name|USFIELD_QUOTA
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|char
modifier|*
name|us_field_hdr
index|[]
init|=
block|{
literal|"TYPE"
block|,
literal|"NAME"
block|,
literal|"USED"
block|,
literal|"QUOTA"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|us_field_names
index|[]
init|=
block|{
literal|"type"
block|,
literal|"name"
block|,
literal|"used"
block|,
literal|"quota"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USFIELD_LAST
value|(sizeof (us_field_names) / sizeof (char *))
end_define

begin_define
define|#
directive|define
name|USTYPE_PSX_GRP
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|USTYPE_PSX_USR
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|USTYPE_SMB_GRP
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|USTYPE_SMB_USR
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|USTYPE_ALL
define|\
value|(USTYPE_PSX_GRP | USTYPE_PSX_USR | USTYPE_SMB_GRP | USTYPE_SMB_USR)
end_define

begin_decl_stmt
specifier|static
name|int
name|us_type_bits
index|[]
init|=
block|{
name|USTYPE_PSX_GRP
block|,
name|USTYPE_PSX_USR
block|,
name|USTYPE_SMB_GRP
block|,
name|USTYPE_SMB_USR
block|,
name|USTYPE_ALL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|us_type_names
index|[]
init|=
block|{
literal|"posixgroup"
block|,
literal|"posixuser"
block|,
literal|"smbgroup"
block|,
literal|"smbuser"
block|,
literal|"all"
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|us_node
block|{
name|nvlist_t
modifier|*
name|usn_nvl
decl_stmt|;
name|uu_avl_node_t
name|usn_avlnode
decl_stmt|;
name|uu_list_node_t
name|usn_listnode
decl_stmt|;
block|}
name|us_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|us_cbdata
block|{
name|nvlist_t
modifier|*
modifier|*
name|cb_nvlp
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|cb_avl_pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|cb_avl
decl_stmt|;
name|boolean_t
name|cb_numname
decl_stmt|;
name|boolean_t
name|cb_nicenum
decl_stmt|;
name|boolean_t
name|cb_sid2posix
decl_stmt|;
name|zfs_userquota_prop_t
name|cb_prop
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|cb_sortcol
decl_stmt|;
name|size_t
name|cb_width
index|[
name|USFIELD_LAST
index|]
decl_stmt|;
block|}
name|us_cbdata_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|boolean_t
name|us_populated
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|zfs_sort_column_t
modifier|*
name|si_sortcol
decl_stmt|;
name|boolean_t
name|si_numname
decl_stmt|;
block|}
name|us_sort_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|us_field_index
parameter_list|(
name|char
modifier|*
name|field
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USFIELD_LAST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
name|us_field_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|us_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|us_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|us_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
name|us_sort_info_t
modifier|*
name|si
init|=
operator|(
name|us_sort_info_t
operator|*
operator|)
name|unused
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|si
operator|->
name|si_sortcol
decl_stmt|;
name|boolean_t
name|numname
init|=
name|si
operator|->
name|si_numname
decl_stmt|;
name|nvlist_t
modifier|*
name|lnvl
init|=
name|l
operator|->
name|usn_nvl
decl_stmt|;
name|nvlist_t
modifier|*
name|rnvl
init|=
name|r
operator|->
name|usn_nvl
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|boolean_t
name|lvb
decl_stmt|,
name|rvb
decl_stmt|;
for|for
control|(
init|;
name|sortcol
operator|!=
name|NULL
condition|;
name|sortcol
operator|=
name|sortcol
operator|->
name|sc_next
control|)
block|{
name|char
modifier|*
name|lvstr
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|rvstr
init|=
literal|""
decl_stmt|;
name|uint32_t
name|lv32
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rv32
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lv64
init|=
literal|0
decl_stmt|;
name|uint64_t
name|rv64
init|=
literal|0
decl_stmt|;
name|zfs_prop_t
name|prop
init|=
name|sortcol
operator|->
name|sc_prop
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|reverse
init|=
name|sortcol
operator|->
name|sc_reverse
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_TYPE
case|:
name|propname
operator|=
literal|"type"
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint32
argument_list|(
name|lnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|lv32
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint32
argument_list|(
name|rnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|rv32
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv32
operator|!=
name|lv32
condition|)
name|rc
operator|=
operator|(
name|rv32
operator|<
name|lv32
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NAME
case|:
name|propname
operator|=
literal|"name"
expr_stmt|;
if|if
condition|(
name|numname
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|lnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|lv64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|rnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|rv64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv64
operator|!=
name|lv64
condition|)
name|rc
operator|=
operator|(
name|rv64
operator|<
name|lv64
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|lnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|lvstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|rnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|rvstr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|strcmp
argument_list|(
name|lvstr
argument_list|,
name|rvstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_USED
case|:
case|case
name|ZFS_PROP_QUOTA
case|:
if|if
condition|(
operator|!
name|us_populated
condition|)
break|break;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_USED
condition|)
name|propname
operator|=
literal|"used"
expr_stmt|;
else|else
name|propname
operator|=
literal|"quota"
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|lnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|lv64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|rnvl
argument_list|,
name|propname
argument_list|,
operator|&
name|rv64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv64
operator|!=
name|lv64
condition|)
name|rc
operator|=
operator|(
name|rv64
operator|<
name|lv64
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
operator|(
name|reverse
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|reverse
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * If entries still seem to be the same, check if they are of the same 	 * type (smbentity is added only if we are doing SID to POSIX ID 	 * translation where we can have duplicate type/name combinations). 	 */
if|if
condition|(
name|nvlist_lookup_boolean_value
argument_list|(
name|lnvl
argument_list|,
literal|"smbentity"
argument_list|,
operator|&
name|lvb
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_lookup_boolean_value
argument_list|(
name|rnvl
argument_list|,
literal|"smbentity"
argument_list|,
operator|&
name|rvb
argument_list|)
operator|==
literal|0
operator|&&
name|lvb
operator|!=
name|rvb
condition|)
return|return
operator|(
name|lvb
operator|<
name|rvb
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|us_type2str
parameter_list|(
name|unsigned
name|field_type
parameter_list|)
block|{
switch|switch
condition|(
name|field_type
condition|)
block|{
case|case
name|USTYPE_PSX_USR
case|:
return|return
operator|(
literal|"POSIX User"
operator|)
return|;
case|case
name|USTYPE_PSX_GRP
case|:
return|return
operator|(
literal|"POSIX Group"
operator|)
return|;
case|case
name|USTYPE_SMB_USR
case|:
return|return
operator|(
literal|"SMB User"
operator|)
return|;
case|case
name|USTYPE_SMB_GRP
case|:
return|return
operator|(
literal|"SMB Group"
operator|)
return|;
default|default:
return|return
operator|(
literal|"Undefined"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|userspace_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|uid_t
name|rid
parameter_list|,
name|uint64_t
name|space
parameter_list|)
block|{
name|us_cbdata_t
modifier|*
name|cb
init|=
operator|(
name|us_cbdata_t
operator|*
operator|)
name|arg
decl_stmt|;
name|zfs_userquota_prop_t
name|prop
init|=
name|cb
operator|->
name|cb_prop
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|propname
decl_stmt|;
name|char
name|sizebuf
index|[
literal|32
index|]
decl_stmt|;
name|us_node_t
modifier|*
name|node
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|avl_pool
init|=
name|cb
operator|->
name|cb_avl_pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|avl
init|=
name|cb
operator|->
name|cb_avl
decl_stmt|;
name|uu_avl_index_t
name|idx
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|us_node_t
modifier|*
name|n
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|cb
operator|->
name|cb_sortcol
decl_stmt|;
name|unsigned
name|type
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|typestr
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|size_t
name|typelen
decl_stmt|;
name|size_t
name|sizelen
decl_stmt|;
name|int
name|typeidx
decl_stmt|,
name|nameidx
decl_stmt|,
name|sizeidx
decl_stmt|;
name|us_sort_info_t
name|sortinfo
init|=
block|{
name|sortcol
block|,
name|cb
operator|->
name|cb_numname
block|}
decl_stmt|;
name|boolean_t
name|smbentity
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|node
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|us_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|usn_avlnode
argument_list|,
name|avl_pool
argument_list|)
expr_stmt|;
name|node
operator|->
name|usn_nvl
operator|=
name|props
expr_stmt|;
if|if
condition|(
name|domain
operator|!=
name|NULL
operator|&&
name|domain
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* SMB */
name|char
name|sid
index|[
name|MAXNAMELEN
operator|+
literal|32
index|]
decl_stmt|;
name|uid_t
name|id
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|flag
init|=
name|IDMAP_REQ_FLG_USE_CACHE
decl_stmt|;
name|smbentity
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sid
argument_list|,
sizeof|sizeof
argument_list|(
name|sid
argument_list|)
argument_list|,
literal|"%s-%u"
argument_list|,
name|domain
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_GROUPUSED
operator|||
name|prop
operator|==
name|ZFS_PROP_GROUPQUOTA
condition|)
block|{
name|type
operator|=
name|USTYPE_SMB_GRP
expr_stmt|;
name|err
operator|=
name|sid_to_id
argument_list|(
name|sid
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|USTYPE_SMB_USR
expr_stmt|;
name|err
operator|=
name|sid_to_id
argument_list|(
name|sid
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|rid
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_sid2posix
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|USTYPE_SMB_USR
condition|)
block|{
operator|(
name|void
operator|)
name|idmap_getwinnamebyuid
argument_list|(
name|rid
argument_list|,
name|flag
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|idmap_getwinnamebygid
argument_list|(
name|rid
argument_list|,
name|flag
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|sid
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cb
operator|->
name|cb_sid2posix
operator|||
name|domain
operator|==
name|NULL
operator|||
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* POSIX or -i */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_GROUPUSED
operator|||
name|prop
operator|==
name|ZFS_PROP_GROUPQUOTA
condition|)
block|{
name|type
operator|=
name|USTYPE_PSX_GRP
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_numname
condition|)
block|{
name|struct
name|group
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|getgrgid
argument_list|(
name|rid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|g
operator|->
name|gr_name
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|USTYPE_PSX_USR
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_numname
condition|)
block|{
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getpwuid
argument_list|(
name|rid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|->
name|pw_name
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Make sure that the type/name combination is unique when doing 	 * SID to POSIX ID translation (hence changing the type from SMB to 	 * POSIX). 	 */
if|if
condition|(
name|cb
operator|->
name|cb_sid2posix
operator|&&
name|nvlist_add_boolean_value
argument_list|(
name|props
argument_list|,
literal|"smbentity"
argument_list|,
name|smbentity
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* Calculate/update width of TYPE field */
name|typestr
operator|=
name|us_type2str
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typelen
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
name|typestr
argument_list|)
argument_list|)
expr_stmt|;
name|typeidx
operator|=
name|us_field_index
argument_list|(
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|typelen
operator|>
name|cb
operator|->
name|cb_width
index|[
name|typeidx
index|]
condition|)
name|cb
operator|->
name|cb_width
index|[
name|typeidx
index|]
operator|=
name|typelen
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint32
argument_list|(
name|props
argument_list|,
literal|"type"
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* Calculate/update width of NAME field */
if|if
condition|(
operator|(
name|cb
operator|->
name|cb_numname
operator|&&
name|cb
operator|->
name|cb_sid2posix
operator|)
operator|||
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
literal|"name"
argument_list|,
name|rid
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|namelen
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"%u"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
literal|"name"
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|nameidx
operator|=
name|us_field_index
argument_list|(
literal|"name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|cb
operator|->
name|cb_width
index|[
name|nameidx
index|]
condition|)
name|cb
operator|->
name|cb_width
index|[
name|nameidx
index|]
operator|=
name|namelen
expr_stmt|;
comment|/* 	 * Check if this type/name combination is in the list and update it; 	 * otherwise add new node to the list. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|uu_avl_find
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
operator|&
name|sortinfo
argument_list|,
operator|&
name|idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|uu_avl_insert
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|n
expr_stmt|;
name|props
operator|=
name|node
operator|->
name|usn_nvl
expr_stmt|;
block|}
comment|/* Calculate/update width of USED/QUOTA fields */
if|if
condition|(
name|cb
operator|->
name|cb_nicenum
condition|)
name|zfs_nicenum
argument_list|(
name|space
argument_list|,
name|sizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sizebuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sizebuf
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|sizelen
operator|=
name|strlen
argument_list|(
name|sizebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_USERUSED
operator|||
name|prop
operator|==
name|ZFS_PROP_GROUPUSED
condition|)
block|{
name|propname
operator|=
literal|"used"
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|props
argument_list|,
literal|"quota"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
literal|"quota"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|propname
operator|=
literal|"quota"
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|props
argument_list|,
literal|"used"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
literal|"used"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sizeidx
operator|=
name|us_field_index
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizelen
operator|>
name|cb
operator|->
name|cb_width
index|[
name|sizeidx
index|]
condition|)
name|cb
operator|->
name|cb_width
index|[
name|sizeidx
index|]
operator|=
name|sizelen
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|space
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_us_node
parameter_list|(
name|boolean_t
name|scripted
parameter_list|,
name|boolean_t
name|parsable
parameter_list|,
name|int
modifier|*
name|fields
parameter_list|,
name|int
name|types
parameter_list|,
name|size_t
modifier|*
name|width
parameter_list|,
name|us_node_t
modifier|*
name|node
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
init|=
name|node
operator|->
name|usn_nvl
decl_stmt|;
name|char
name|valstr
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|int
name|cfield
init|=
literal|0
decl_stmt|;
name|int
name|field
decl_stmt|;
name|uint32_t
name|ustype
decl_stmt|;
comment|/* Check type */
operator|(
name|void
operator|)
name|nvlist_lookup_uint32
argument_list|(
name|nvl
argument_list|,
literal|"type"
argument_list|,
operator|&
name|ustype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ustype
operator|&
name|types
operator|)
condition|)
return|return;
while|while
condition|(
operator|(
name|field
operator|=
name|fields
index|[
name|cfield
index|]
operator|)
operator|!=
name|USFIELD_LAST
condition|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|data_type_t
name|type
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
name|uint64_t
name|val64
decl_stmt|;
name|char
modifier|*
name|strval
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|us_field_names
index|[
name|field
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|type
operator|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_UINT32
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint32
argument_list|(
name|nvp
argument_list|,
operator|&
name|val32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|nvp
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|nvp
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid data type\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|USFIELD_TYPE
case|:
name|strval
operator|=
operator|(
name|char
operator|*
operator|)
name|us_type2str
argument_list|(
name|val32
argument_list|)
expr_stmt|;
break|break;
case|case
name|USFIELD_NAME
case|:
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|valstr
argument_list|,
literal|"%llu"
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|strval
operator|=
name|valstr
expr_stmt|;
block|}
break|break;
case|case
name|USFIELD_USED
case|:
case|case
name|USFIELD_QUOTA
case|:
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
if|if
condition|(
name|parsable
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|valstr
argument_list|,
literal|"%llu"
argument_list|,
name|val64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_nicenum
argument_list|(
name|val64
argument_list|,
name|valstr
argument_list|,
sizeof|sizeof
argument_list|(
name|valstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
name|USFIELD_QUOTA
operator|&&
name|strcmp
argument_list|(
name|valstr
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|strval
operator|=
literal|"none"
expr_stmt|;
else|else
name|strval
operator|=
name|valstr
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|strval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|USFIELD_TYPE
operator|||
name|field
operator|==
name|USFIELD_NAME
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|width
index|[
name|field
index|]
argument_list|,
name|strval
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
index|[
name|field
index|]
argument_list|,
name|strval
argument_list|)
expr_stmt|;
name|first
operator|=
name|B_FALSE
expr_stmt|;
name|cfield
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_us
parameter_list|(
name|boolean_t
name|scripted
parameter_list|,
name|boolean_t
name|parsable
parameter_list|,
name|int
modifier|*
name|fields
parameter_list|,
name|int
name|types
parameter_list|,
name|size_t
modifier|*
name|width
parameter_list|,
name|boolean_t
name|rmnode
parameter_list|,
name|uu_avl_t
modifier|*
name|avl
parameter_list|)
block|{
name|us_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|col
decl_stmt|;
name|int
name|cfield
init|=
literal|0
decl_stmt|;
name|int
name|field
decl_stmt|;
if|if
condition|(
operator|!
name|scripted
condition|)
block|{
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
while|while
condition|(
operator|(
name|field
operator|=
name|fields
index|[
name|cfield
index|]
operator|)
operator|!=
name|USFIELD_LAST
condition|)
block|{
name|col
operator|=
name|gettext
argument_list|(
name|us_field_hdr
index|[
name|field
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|USFIELD_TYPE
operator|||
name|field
operator|==
name|USFIELD_NAME
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|first
condition|?
literal|"%-*s"
else|:
literal|"  %-*s"
argument_list|,
name|width
index|[
name|field
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|first
condition|?
literal|"%*s"
else|:
literal|"  %*s"
argument_list|,
name|width
index|[
name|field
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|B_FALSE
expr_stmt|;
name|cfield
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|node
operator|=
name|uu_avl_first
argument_list|(
name|avl
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|uu_avl_next
argument_list|(
name|avl
argument_list|,
name|node
argument_list|)
control|)
block|{
name|print_us_node
argument_list|(
name|scripted
argument_list|,
name|parsable
argument_list|,
name|fields
argument_list|,
name|types
argument_list|,
name|width
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmnode
condition|)
name|nvlist_free
argument_list|(
name|node
operator|->
name|usn_nvl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_userspace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zfs_userquota_prop_t
name|p
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|avl_pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|avl_tree
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|char
name|deffields
index|[]
init|=
literal|"type,name,used,quota"
decl_stmt|;
name|char
modifier|*
name|ofield
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tfield
init|=
name|NULL
decl_stmt|;
name|int
name|cfield
init|=
literal|0
decl_stmt|;
name|int
name|fields
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|scripted
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|prtnum
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|parsable
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|sid2posix
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|NULL
decl_stmt|;
name|int
name|types
init|=
name|USTYPE_PSX_USR
operator||
name|USTYPE_SMB_USR
decl_stmt|;
name|us_cbdata_t
name|cb
decl_stmt|;
name|us_node_t
modifier|*
name|node
decl_stmt|;
name|us_node_t
modifier|*
name|rmnode
decl_stmt|;
name|uu_list_pool_t
modifier|*
name|listpool
decl_stmt|;
name|uu_list_t
modifier|*
name|list
decl_stmt|;
name|uu_avl_index_t
name|idx
init|=
literal|0
decl_stmt|;
name|uu_list_index_t
name|idx2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"groupspace"
argument_list|)
operator|==
literal|0
condition|)
comment|/* Toggle default group types */
name|types
operator|=
name|USTYPE_PSX_GRP
operator||
name|USTYPE_SMB_GRP
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nHpo:s:S:t:i"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|prtnum
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|parsable
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ofield
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|c
operator|==
literal|'s'
condition|?
name|B_FALSE
else|:
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid field '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|tfield
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|sid2posix
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Use default output fields if not specified using -o */
if|if
condition|(
name|ofield
operator|==
name|NULL
condition|)
name|ofield
operator|=
name|deffields
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|delim
operator|=
name|strchr
argument_list|(
name|ofield
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|fields
index|[
name|cfield
operator|++
index|]
operator|=
name|us_field_index
argument_list|(
name|ofield
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type '%s' "
literal|"for -o option\n"
argument_list|)
argument_list|,
name|ofield
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|delim
operator|!=
name|NULL
condition|)
name|ofield
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|NULL
condition|)
do|;
name|fields
index|[
name|cfield
index|]
operator|=
name|USFIELD_LAST
expr_stmt|;
comment|/* Override output types (-t option) */
if|if
condition|(
name|tfield
operator|!=
name|NULL
condition|)
block|{
name|types
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|delim
operator|=
name|strchr
argument_list|(
name|tfield
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|us_type_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tfield
argument_list|,
name|us_type_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|B_TRUE
expr_stmt|;
name|types
operator||=
name|us_type_bits
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type "
literal|"'%s' for -t option\n"
argument_list|)
argument_list|,
name|tfield
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|delim
operator|!=
name|NULL
condition|)
name|tfield
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|delim
operator|!=
name|NULL
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|avl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"us_avl_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|us_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|us_node_t
argument_list|,
name|usn_avlnode
argument_list|)
argument_list|,
name|us_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|avl_tree
operator|=
name|uu_avl_create
argument_list|(
name|avl_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* Always add default sorting columns */
operator|(
name|void
operator|)
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
literal|"type"
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
literal|"name"
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_sortcol
operator|=
name|sortcol
expr_stmt|;
name|cb
operator|.
name|cb_numname
operator|=
name|prtnum
expr_stmt|;
name|cb
operator|.
name|cb_nicenum
operator|=
operator|!
name|parsable
expr_stmt|;
name|cb
operator|.
name|cb_avl_pool
operator|=
name|avl_pool
expr_stmt|;
name|cb
operator|.
name|cb_avl
operator|=
name|avl_tree
expr_stmt|;
name|cb
operator|.
name|cb_sid2posix
operator|=
name|sid2posix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USFIELD_LAST
condition|;
name|i
operator|++
control|)
name|cb
operator|.
name|cb_width
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
name|us_field_hdr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ZFS_NUM_USERQUOTA_PROPS
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|p
operator|==
name|ZFS_PROP_USERUSED
operator|||
name|p
operator|==
name|ZFS_PROP_USERQUOTA
operator|)
operator|&&
operator|!
operator|(
name|types
operator|&
operator|(
name|USTYPE_PSX_USR
operator||
name|USTYPE_SMB_USR
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p
operator|==
name|ZFS_PROP_GROUPUSED
operator|||
name|p
operator|==
name|ZFS_PROP_GROUPQUOTA
operator|)
operator|&&
operator|!
operator|(
name|types
operator|&
operator|(
name|USTYPE_PSX_GRP
operator||
name|USTYPE_SMB_GRP
operator|)
operator|)
operator|)
condition|)
continue|continue;
name|cb
operator|.
name|cb_prop
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_userspace
argument_list|(
name|zhp
argument_list|,
name|p
argument_list|,
name|userspace_cb
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Sort the list */
if|if
condition|(
operator|(
name|node
operator|=
name|uu_avl_first
argument_list|(
name|avl_tree
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|us_populated
operator|=
name|B_TRUE
expr_stmt|;
name|listpool
operator|=
name|uu_list_pool_create
argument_list|(
literal|"tmplist"
argument_list|,
sizeof|sizeof
argument_list|(
name|us_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|us_node_t
argument_list|,
name|usn_listnode
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
expr_stmt|;
name|list
operator|=
name|uu_list_create
argument_list|(
name|listpool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
expr_stmt|;
name|uu_list_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|usn_listnode
argument_list|,
name|listpool
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|rmnode
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|uu_avl_next
argument_list|(
name|avl_tree
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|uu_avl_remove
argument_list|(
name|avl_tree
argument_list|,
name|rmnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_list_find
argument_list|(
name|list
argument_list|,
name|rmnode
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx2
argument_list|)
operator|==
name|NULL
condition|)
name|uu_list_insert
argument_list|(
name|list
argument_list|,
name|rmnode
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|node
operator|=
name|uu_list_first
argument_list|(
name|list
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|uu_list_next
argument_list|(
name|list
argument_list|,
name|node
argument_list|)
control|)
block|{
name|us_sort_info_t
name|sortinfo
init|=
block|{
name|sortcol
block|,
name|cb
operator|.
name|cb_numname
block|}
decl_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|avl_tree
argument_list|,
name|node
argument_list|,
operator|&
name|sortinfo
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
name|uu_avl_insert
argument_list|(
name|avl_tree
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|uu_list_destroy
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|uu_list_pool_destroy
argument_list|(
name|listpool
argument_list|)
expr_stmt|;
comment|/* Print and free node nvlist memory */
name|print_us
argument_list|(
name|scripted
argument_list|,
name|parsable
argument_list|,
name|fields
argument_list|,
name|types
argument_list|,
name|cb
operator|.
name|cb_width
argument_list|,
name|B_TRUE
argument_list|,
name|cb
operator|.
name|cb_avl
argument_list|)
expr_stmt|;
name|zfs_free_sort_columns
argument_list|(
name|sortcol
argument_list|)
expr_stmt|;
comment|/* Clean up the AVL tree */
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|,
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|avl_tree
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|avl_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * list [-Hp][-r|-d max] [-o property[,...]] [-s property] ... [-S property] ...  *      [-t type[,...]] [filesystem|volume|snapshot] ...  *  *	-H	Scripted mode; elide headers and separate columns by tabs.  *	-p	Display values in parsable (literal) format.  *	-r	Recurse over all children.  *	-d	Limit recursion by depth.  *	-o	Control which fields to display.  *	-s	Specify sort columns, descending order.  *	-S	Specify sort columns, ascending order.  *	-t	Control which object types to display.  *  * When given no arguments, list all filesystems in the system.  * Otherwise, list the specified datasets, optionally recursing down them if  * '-r' is specified.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|list_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|boolean_t
name|cb_literal
decl_stmt|;
name|boolean_t
name|cb_scripted
decl_stmt|;
name|zprop_list_t
modifier|*
name|cb_proplist
decl_stmt|;
block|}
name|list_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Given a list of columns to display, output appropriate headers for each one.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|list_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|pl
init|=
name|cb
operator|->
name|cb_proplist
decl_stmt|;
name|char
name|headerbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
name|header
operator|=
name|zfs_prop_column_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|headerbuf
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|headerbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|headerbuf
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|header
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset and a list of fields, print out all the properties according  * to the described layout.  */
end_comment

begin_function
specifier|static
name|void
name|print_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|list_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|pl
init|=
name|cb
operator|->
name|cb_proplist
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|propstr
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|property
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|)
expr_stmt|;
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|cb
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_prop_userquota
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfs_prop_get_userquota
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|cb
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_prop_written
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfs_prop_get_written
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|cb
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|propstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 		 * If this is being called in scripted mode, or if this is the 		 * last column and it is left-justified, don't include a width 		 * format specifier. 		 */
if|if
condition|(
name|cb
operator|->
name|cb_scripted
operator|||
operator|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic callback function to list a dataset or snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|list_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|list_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_scripted
condition|)
name|print_header
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|print_dataset
argument_list|(
name|zhp
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|char
name|default_fields
index|[]
init|=
literal|"name,used,available,referenced,mountpoint"
decl_stmt|;
name|int
name|types
init|=
name|ZFS_TYPE_DATASET
decl_stmt|;
name|boolean_t
name|types_specified
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|fields
init|=
name|NULL
decl_stmt|;
name|list_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
name|ZFS_ITER_PROP_LISTSNAPS
operator||
name|ZFS_ITER_ARGS_CAN_BE_PATHS
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"HS:d:o:prs:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
name|fields
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_LITERAL_PROPS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|limit
operator|=
name|parse_depth
argument_list|(
name|optarg
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|types
operator|=
literal|0
expr_stmt|;
name|types_specified
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|&=
operator|~
name|ZFS_ITER_PROP_LISTSNAPS
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|type_subopts
index|[]
init|=
block|{
literal|"filesystem"
block|,
literal|"volume"
block|,
literal|"snapshot"
block|,
literal|"snap"
block|,
literal|"bookmark"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|type_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|types
operator||=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|types
operator||=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|types
operator||=
name|ZFS_TYPE_BOOKMARK
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|types
operator|=
name|ZFS_TYPE_DATASET
operator||
name|ZFS_TYPE_BOOKMARK
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type '%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL
condition|)
name|fields
operator|=
name|default_fields
expr_stmt|;
comment|/* 	 * If we are only going to list snapshot names and sort by name, 	 * then we can use faster version. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fields
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
operator|&&
name|zfs_sort_only_by_name
argument_list|(
name|sortcol
argument_list|)
condition|)
name|flags
operator||=
name|ZFS_ITER_SIMPLE
expr_stmt|;
comment|/* 	 * If "-o space" and no types were specified, don't display snapshots. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fields
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
operator|&&
name|types_specified
operator|==
name|B_FALSE
condition|)
name|types
operator|&=
operator|~
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
comment|/* 	 * If the user specifies '-o all', the zprop_get_list() doesn't 	 * normally include the name of the dataset.  For 'zfs list', we always 	 * want this property to be first. 	 */
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|types
argument_list|,
name|sortcol
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|limit
argument_list|,
name|list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
name|zfs_free_sort_columns
argument_list|(
name|sortcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_first
operator|&&
operator|!
name|cb
operator|.
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no datasets available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rename [-f]<fs | snap | vol><fs | snap | vol>  * zfs rename [-f] -p<fs | vol><fs | vol>  * zfs rename -r<snap><snap>  *  * Renames the given dataset to another of the same type.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|force_unmount
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"prf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_unmount
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|parents
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-p and -r options are mutually "
literal|"exclusive\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"source dataset for recursive "
literal|"rename must be a snapshot\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|parents
condition|?
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
else|:
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If we were asked and the name looks good, try to create ancestors. */
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|&&
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
operator|(
name|zfs_rename
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|recurse
argument_list|,
name|force_unmount
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs promote<fs>  *  * Promotes the given clone fs to be the parent  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing clone filesystem"
literal|" argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_promote
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rollback [-rRf]<snapshot>  *  *	-r	Delete any intervening snapshots before doing rollback  *	-R	Delete any snapshots and their clones  *	-f	ignored for backwards compatability  *  * Given a filesystem, rollback to a specific snapshot, discarding any changes  * since then and making it the active dataset.  If more recent snapshots exist,  * the command will complain unless the '-r' flag is given.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_cbdata
block|{
name|uint64_t
name|cb_create
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_doclones
decl_stmt|;
name|char
modifier|*
name|cb_target
decl_stmt|;
name|int
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_recurse
decl_stmt|;
block|}
name|rollback_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|rollback_check_dependent
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot rollback to "
literal|"'%s': clones of previous snapshots exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to "
literal|"force deletion of the following clones and "
literal|"dependents:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report any snapshots more recent than the one specified.  Used when '-r' is  * not specified.  We reuse this same callback for the snapshot dependents - if  * 'cb_dependent' is set, then this is a dependent and we should report it  * without checking the transaction group.  */
end_comment

begin_function
specifier|static
name|int
name|rollback_check
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_doclones
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
operator|!
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"rollback to '%s': more recent snapshots "
literal|"or bookmarks exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to "
literal|"force deletion of the following "
literal|"snapshots and bookmarks:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|rollback_check_dependent
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|rollback_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|,
modifier|*
name|snap
decl_stmt|;
name|char
name|parentname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rRf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* open the snapshot */
if|if
condition|(
operator|(
name|snap
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* open the parent dataset */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parentname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|parentname
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strrchr
argument_list|(
name|parentname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|parentname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check for more recent snapshots and/or clones based on the presence 	 * of '-r' and '-R'. 	 */
name|cb
operator|.
name|cb_target
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|rollback_check
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_bookmarks
argument_list|(
name|zhp
argument_list|,
name|rollback_check
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
operator|.
name|cb_error
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Rollback parent to the given snapshot. 	 */
name|ret
operator|=
name|zfs_rollback
argument_list|(
name|zhp
argument_list|,
name|snap
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|out
label|:
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs set property=value ... { fs | snap | vol } ...  *  * Sets the given properties for all datasets specified on the command line.  */
end_comment

begin_function
specifier|static
name|int
name|set_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|props
init|=
name|data
decl_stmt|;
if|if
condition|(
name|zfs_prop_set_list
argument_list|(
name|zhp
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|libzfs_errno
argument_list|(
name|g_zfs
argument_list|)
condition|)
block|{
case|case
name|EZFS_MOUNTFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to remount filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EZFS_SHARENFSFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to reshare filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|int
name|ds_start
init|=
operator|-
literal|1
decl_stmt|;
comment|/* argv idx of first dataset arg */
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check for options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|'='
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property=value "
literal|"argument(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset "
literal|"name(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* validate argument order:  prop=val args followed by dataset args */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ds_start
operator|>
literal|0
condition|)
block|{
comment|/* out-of-order prop=val argument */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid "
literal|"argument order\n"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ds_start
operator|<
literal|0
condition|)
block|{
name|ds_start
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ds_start
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset name(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Populate a list of property settings */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ds_start
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|parseprop
argument_list|(
name|props
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
operator|-
name|ds_start
argument_list|,
name|argv
operator|+
name|ds_start
argument_list|,
literal|0
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|set_callback
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|snap_cbdata
block|{
name|nvlist_t
modifier|*
name|sd_nvl
decl_stmt|;
name|boolean_t
name|sd_recursive
decl_stmt|;
specifier|const
name|char
modifier|*
name|sd_snapname
decl_stmt|;
block|}
name|snap_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|zfs_snapshot_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|snap_cbdata_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_recursive
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_INCONSISTENT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|asprintf
argument_list|(
operator|&
name|name
argument_list|,
literal|"%s@%s"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|sd
operator|->
name|sd_snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|sd
operator|->
name|sd_nvl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_recursive
condition|)
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_snapshot_cb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs snapshot [-r] [-o prop=value] ...<fs@snap>  *  * Creates a snapshot with the given name.  While functionally equivalent to  * 'zfs create', it is a separate command to differentiate intent.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|snap_cbdata_t
name|sd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|multiple_snaps
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|.
name|sd_nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ro:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'r'
case|:
name|sd
operator|.
name|sd_recursive
operator|=
name|B_TRUE
expr_stmt|;
name|multiple_snaps
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|multiple_snaps
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|char
modifier|*
name|atp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
name|sd
operator|.
name|sd_snapname
operator|=
name|atp
operator|+
literal|1
expr_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
name|zfs_snapshot_cb
argument_list|(
name|zhp
argument_list|,
operator|&
name|sd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|usage
goto|;
block|}
name|ret
operator|=
name|zfs_snapshot_nvl
argument_list|(
name|g_zfs
argument_list|,
name|sd
operator|.
name|sd_nvl
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|.
name|sd_nvl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|multiple_snaps
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no snapshots were created\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
name|usage
label|:
name|nvlist_free
argument_list|(
name|sd
operator|.
name|sd_nvl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a backup stream to stdout.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|fromname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|toname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|resume_token
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|sendflags_t
name|flags
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|dbgnv
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|extraverbose
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":i:I:RDpvnPLet:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|fromname
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|fromname
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|optarg
expr_stmt|;
name|flags
operator|.
name|doall
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|flags
operator|.
name|replicate
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator|.
name|props
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|flags
operator|.
name|parsable
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|.
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
name|extraverbose
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|.
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|.
name|progress
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|flags
operator|.
name|dedup
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator|.
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|flags
operator|.
name|largeblock
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|flags
operator|.
name|embed_data
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|resume_token
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|resume_token
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fromname
operator|!=
name|NULL
operator|||
name|flags
operator|.
name|replicate
operator|||
name|flags
operator|.
name|props
operator|||
name|flags
operator|.
name|dedup
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid flags combined with -t\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no additional "
literal|"arguments are permitted with -t\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flags
operator|.
name|dryrun
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Stream can not be written to a terminal.\n"
literal|"You must redirect standard output.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|resume_token
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|zfs_send_resume
argument_list|(
name|g_zfs
argument_list|,
operator|&
name|flags
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|resume_token
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Special case sending a filesystem, or from a bookmark. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|fromname
operator|&&
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'#'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
name|frombuf
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|enum
name|lzc_send_flags
name|lzc_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|.
name|replicate
operator|||
name|flags
operator|.
name|doall
operator|||
name|flags
operator|.
name|props
operator|||
name|flags
operator|.
name|dedup
operator|||
name|flags
operator|.
name|dryrun
operator|||
name|flags
operator|.
name|verbose
operator|||
name|flags
operator|.
name|progress
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: "
literal|"Unsupported flag with filesystem or bookmark.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|flags
operator|.
name|largeblock
condition|)
name|lzc_flags
operator||=
name|LZC_SEND_FLAG_LARGE_BLOCK
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|embed_data
condition|)
name|lzc_flags
operator||=
name|LZC_SEND_FLAG_EMBED_DATA
expr_stmt|;
if|if
condition|(
name|fromname
operator|!=
name|NULL
operator|&&
operator|(
name|fromname
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|fromname
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
comment|/* 			 * Incremental source name begins with # or @. 			 * Default to same fs as target. 			 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|frombuf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|frombuf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|frombuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|frombuf
argument_list|,
name|fromname
argument_list|,
sizeof|sizeof
argument_list|(
name|frombuf
argument_list|)
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|frombuf
expr_stmt|;
block|}
name|err
operator|=
name|zfs_send_one
argument_list|(
name|zhp
argument_list|,
name|fromname
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|lzc_flags
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|toname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If they specified the full path to the snapshot, chop off 	 * everything except the short name of the snapshot, but special 	 * case if they specify the origin. 	 */
if|if
condition|(
name|fromname
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|origin
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zprop_source_t
name|src
decl_stmt|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ORIGIN
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|origin
argument_list|,
name|fromname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fromname
operator|=
name|NULL
expr_stmt|;
name|flags
operator|.
name|fromorigin
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|fromname
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|fromname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"incremental source must be "
literal|"in same filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fromname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid incremental source\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|.
name|replicate
operator|&&
name|fromname
operator|==
name|NULL
condition|)
name|flags
operator|.
name|doall
operator|=
name|B_TRUE
expr_stmt|;
name|err
operator|=
name|zfs_send
argument_list|(
name|zhp
argument_list|,
name|fromname
argument_list|,
name|toname
argument_list|,
operator|&
name|flags
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|extraverbose
condition|?
operator|&
name|dbgnv
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraverbose
operator|&&
name|dbgnv
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * dump_nvlist prints to stdout, but that's been 		 * redirected to a file.  Make it print to stderr 		 * instead. 		 */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|STDERR_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|dbgnv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|dbgnv
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore a backup stream from stdin.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|recvflags_t
name|flags
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|abort_resumable
init|=
name|B_FALSE
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":o:denuvFsA"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'d'
case|:
name|flags
operator|.
name|isprefix
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|flags
operator|.
name|isprefix
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|.
name|istail
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator|.
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|flags
operator|.
name|nomount
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator|.
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator|.
name|resumable
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|flags
operator|.
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|abort_resumable
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|nvp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
literal|"origin"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abort_resumable
condition|)
block|{
if|if
condition|(
name|flags
operator|.
name|isprefix
operator|||
name|flags
operator|.
name|istail
operator|||
name|flags
operator|.
name|dryrun
operator|||
name|flags
operator|.
name|resumable
operator|||
name|flags
operator|.
name|nomount
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|char
name|namebuf
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
literal|"%s/%%recv"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|g_zfs
argument_list|,
name|namebuf
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|namebuf
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|err
operator|=
name|zfs_destroy
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_INCONSISTENT
argument_list|)
operator|||
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_RECEIVE_RESUME_TOKEN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' does not have any "
literal|"resumable receive state to abort\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zfs_destroy
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Backup stream can not be read "
literal|"from a terminal.\n"
literal|"You must redirect standard input.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zfs_receive
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|props
argument_list|,
operator|&
name|flags
argument_list|,
name|STDIN_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allow/unallow stuff  */
end_comment

begin_comment
comment|/* copied from zfs/sys/dsl_deleg.h */
end_comment

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_CREATE
value|"create"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_DESTROY
value|"destroy"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_SNAPSHOT
value|"snapshot"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_ROLLBACK
value|"rollback"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_CLONE
value|"clone"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_PROMOTE
value|"promote"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_RENAME
value|"rename"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_MOUNT
value|"mount"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_SHARE
value|"share"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_SEND
value|"send"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_RECEIVE
value|"receive"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_ALLOW
value|"allow"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_USERPROP
value|"userprop"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_VSCAN
value|"vscan"
end_define

begin_comment
comment|/* ??? */
end_comment

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_USERQUOTA
value|"userquota"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_GROUPQUOTA
value|"groupquota"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_USERUSED
value|"userused"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_GROUPUSED
value|"groupused"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_HOLD
value|"hold"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_RELEASE
value|"release"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_DIFF
value|"diff"
end_define

begin_define
define|#
directive|define
name|ZFS_DELEG_PERM_BOOKMARK
value|"bookmark"
end_define

begin_define
define|#
directive|define
name|ZFS_NUM_DELEG_NOTES
value|ZFS_DELEG_NOTE_NONE
end_define

begin_decl_stmt
specifier|static
name|zfs_deleg_perm_tab_t
name|zfs_deleg_perm_tbl
index|[]
init|=
block|{
block|{
name|ZFS_DELEG_PERM_ALLOW
block|,
name|ZFS_DELEG_NOTE_ALLOW
block|}
block|,
block|{
name|ZFS_DELEG_PERM_CLONE
block|,
name|ZFS_DELEG_NOTE_CLONE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_CREATE
block|,
name|ZFS_DELEG_NOTE_CREATE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_DESTROY
block|,
name|ZFS_DELEG_NOTE_DESTROY
block|}
block|,
block|{
name|ZFS_DELEG_PERM_DIFF
block|,
name|ZFS_DELEG_NOTE_DIFF
block|}
block|,
block|{
name|ZFS_DELEG_PERM_HOLD
block|,
name|ZFS_DELEG_NOTE_HOLD
block|}
block|,
block|{
name|ZFS_DELEG_PERM_MOUNT
block|,
name|ZFS_DELEG_NOTE_MOUNT
block|}
block|,
block|{
name|ZFS_DELEG_PERM_PROMOTE
block|,
name|ZFS_DELEG_NOTE_PROMOTE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_RECEIVE
block|,
name|ZFS_DELEG_NOTE_RECEIVE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_RELEASE
block|,
name|ZFS_DELEG_NOTE_RELEASE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_RENAME
block|,
name|ZFS_DELEG_NOTE_RENAME
block|}
block|,
block|{
name|ZFS_DELEG_PERM_ROLLBACK
block|,
name|ZFS_DELEG_NOTE_ROLLBACK
block|}
block|,
block|{
name|ZFS_DELEG_PERM_SEND
block|,
name|ZFS_DELEG_NOTE_SEND
block|}
block|,
block|{
name|ZFS_DELEG_PERM_SHARE
block|,
name|ZFS_DELEG_NOTE_SHARE
block|}
block|,
block|{
name|ZFS_DELEG_PERM_SNAPSHOT
block|,
name|ZFS_DELEG_NOTE_SNAPSHOT
block|}
block|,
block|{
name|ZFS_DELEG_PERM_BOOKMARK
block|,
name|ZFS_DELEG_NOTE_BOOKMARK
block|}
block|,
block|{
name|ZFS_DELEG_PERM_GROUPQUOTA
block|,
name|ZFS_DELEG_NOTE_GROUPQUOTA
block|}
block|,
block|{
name|ZFS_DELEG_PERM_GROUPUSED
block|,
name|ZFS_DELEG_NOTE_GROUPUSED
block|}
block|,
block|{
name|ZFS_DELEG_PERM_USERPROP
block|,
name|ZFS_DELEG_NOTE_USERPROP
block|}
block|,
block|{
name|ZFS_DELEG_PERM_USERQUOTA
block|,
name|ZFS_DELEG_NOTE_USERQUOTA
block|}
block|,
block|{
name|ZFS_DELEG_PERM_USERUSED
block|,
name|ZFS_DELEG_NOTE_USERUSED
block|}
block|,
block|{
name|NULL
block|,
name|ZFS_DELEG_NOTE_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* permission structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|deleg_perm
block|{
name|zfs_deleg_who_type_t
name|dp_who_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|dp_name
decl_stmt|;
name|boolean_t
name|dp_local
decl_stmt|;
name|boolean_t
name|dp_descend
decl_stmt|;
block|}
name|deleg_perm_t
typedef|;
end_typedef

begin_comment
comment|/* */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|deleg_perm_node
block|{
name|deleg_perm_t
name|dpn_perm
decl_stmt|;
name|uu_avl_node_t
name|dpn_avl_node
decl_stmt|;
block|}
name|deleg_perm_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fs_perm
name|fs_perm_t
typedef|;
end_typedef

begin_comment
comment|/* permissions set */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|who_perm
block|{
name|zfs_deleg_who_type_t
name|who_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|who_name
decl_stmt|;
comment|/* id */
name|char
name|who_ug_name
index|[
literal|256
index|]
decl_stmt|;
comment|/* user/group name */
name|fs_perm_t
modifier|*
name|who_fsperm
decl_stmt|;
comment|/* uplink */
name|uu_avl_t
modifier|*
name|who_deleg_perm_avl
decl_stmt|;
comment|/* permissions */
block|}
name|who_perm_t
typedef|;
end_typedef

begin_comment
comment|/* */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|who_perm_node
block|{
name|who_perm_t
name|who_perm
decl_stmt|;
name|uu_avl_node_t
name|who_avl_node
decl_stmt|;
block|}
name|who_perm_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fs_perm_set
name|fs_perm_set_t
typedef|;
end_typedef

begin_comment
comment|/* fs permissions */
end_comment

begin_struct
struct|struct
name|fs_perm
block|{
specifier|const
name|char
modifier|*
name|fsp_name
decl_stmt|;
name|uu_avl_t
modifier|*
name|fsp_sc_avl
decl_stmt|;
comment|/* sets,create */
name|uu_avl_t
modifier|*
name|fsp_uge_avl
decl_stmt|;
comment|/* user,group,everyone */
name|fs_perm_set_t
modifier|*
name|fsp_set
decl_stmt|;
comment|/* uplink */
block|}
struct|;
end_struct

begin_comment
comment|/* */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_perm_node
block|{
name|fs_perm_t
name|fspn_fsperm
decl_stmt|;
name|uu_avl_t
modifier|*
name|fspn_avl
decl_stmt|;
name|uu_list_node_t
name|fspn_list_node
decl_stmt|;
block|}
name|fs_perm_node_t
typedef|;
end_typedef

begin_comment
comment|/* top level structure */
end_comment

begin_struct
struct|struct
name|fs_perm_set
block|{
name|uu_list_pool_t
modifier|*
name|fsps_list_pool
decl_stmt|;
name|uu_list_t
modifier|*
name|fsps_list
decl_stmt|;
comment|/* list of fs_perms */
name|uu_avl_pool_t
modifier|*
name|fsps_named_set_avl_pool
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|fsps_who_perm_avl_pool
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|fsps_deleg_perm_avl_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|deleg_perm_type
parameter_list|(
name|zfs_deleg_note_t
name|note
parameter_list|)
block|{
comment|/* subcommands */
switch|switch
condition|(
name|note
condition|)
block|{
comment|/* SUBCOMMANDS */
comment|/* OTHER */
case|case
name|ZFS_DELEG_NOTE_GROUPQUOTA
case|:
case|case
name|ZFS_DELEG_NOTE_GROUPUSED
case|:
case|case
name|ZFS_DELEG_NOTE_USERPROP
case|:
case|case
name|ZFS_DELEG_NOTE_USERQUOTA
case|:
case|case
name|ZFS_DELEG_NOTE_USERUSED
case|:
comment|/* other */
return|return
operator|(
name|gettext
argument_list|(
literal|"other"
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|gettext
argument_list|(
literal|"subcommand"
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|who_type2weight
parameter_list|(
name|zfs_deleg_who_type_t
name|who_type
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
switch|switch
condition|(
name|who_type
condition|)
block|{
case|case
name|ZFS_DELEG_NAMED_SET_SETS
case|:
case|case
name|ZFS_DELEG_NAMED_SET
case|:
name|res
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_CREATE_SETS
case|:
case|case
name|ZFS_DELEG_CREATE
case|:
name|res
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_USER_SETS
case|:
case|case
name|ZFS_DELEG_USER
case|:
name|res
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
case|case
name|ZFS_DELEG_GROUP
case|:
name|res
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_EVERYONE_SETS
case|:
case|case
name|ZFS_DELEG_EVERYONE
case|:
name|res
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|who_perm_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|who_perm_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|who_perm_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
name|zfs_deleg_who_type_t
name|ltype
init|=
name|l
operator|->
name|who_perm
operator|.
name|who_type
decl_stmt|;
name|zfs_deleg_who_type_t
name|rtype
init|=
name|r
operator|->
name|who_perm
operator|.
name|who_type
decl_stmt|;
name|int
name|lweight
init|=
name|who_type2weight
argument_list|(
name|ltype
argument_list|)
decl_stmt|;
name|int
name|rweight
init|=
name|who_type2weight
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
name|int
name|res
init|=
name|lweight
operator|-
name|rweight
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|res
operator|=
name|strncmp
argument_list|(
name|l
operator|->
name|who_perm
operator|.
name|who_name
argument_list|,
name|r
operator|->
name|who_perm
operator|.
name|who_name
argument_list|,
name|ZFS_MAX_DELEG_NAME
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|deleg_perm_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|deleg_perm_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|deleg_perm_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
name|int
name|res
init|=
name|strncmp
argument_list|(
name|l
operator|->
name|dpn_perm
operator|.
name|dp_name
argument_list|,
name|r
operator|->
name|dpn_perm
operator|.
name|dp_name
argument_list|,
name|ZFS_MAX_DELEG_NAME
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fs_perm_set_init
parameter_list|(
name|fs_perm_set_t
modifier|*
name|fspset
parameter_list|)
block|{
name|bzero
argument_list|(
name|fspset
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_perm_set_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fspset
operator|->
name|fsps_list_pool
operator|=
name|uu_list_pool_create
argument_list|(
literal|"fsps_list_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|fs_perm_node_t
argument_list|,
name|fspn_list_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fspset
operator|->
name|fsps_list
operator|=
name|uu_list_create
argument_list|(
name|fspset
operator|->
name|fsps_list_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fspset
operator|->
name|fsps_named_set_avl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"named_set_avl_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|who_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|who_perm_node_t
argument_list|,
name|who_avl_node
argument_list|)
argument_list|,
name|who_perm_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fspset
operator|->
name|fsps_who_perm_avl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"who_perm_avl_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|who_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|who_perm_node_t
argument_list|,
name|who_avl_node
argument_list|)
argument_list|,
name|who_perm_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fspset
operator|->
name|fsps_deleg_perm_avl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"deleg_perm_avl_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|deleg_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|deleg_perm_node_t
argument_list|,
name|dpn_avl_node
argument_list|)
argument_list|,
name|deleg_perm_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
specifier|inline
name|void
name|fs_perm_fini
parameter_list|(
name|fs_perm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|who_perm_fini
parameter_list|(
name|who_perm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|fs_perm_set_fini
parameter_list|(
name|fs_perm_set_t
modifier|*
name|fspset
parameter_list|)
block|{
name|fs_perm_node_t
modifier|*
name|node
init|=
name|uu_list_first
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|fs_perm_node_t
modifier|*
name|next_node
init|=
name|uu_list_next
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|fs_perm_t
modifier|*
name|fsperm
init|=
operator|&
name|node
operator|->
name|fspn_fsperm
decl_stmt|;
name|fs_perm_fini
argument_list|(
name|fsperm
argument_list|)
expr_stmt|;
name|uu_list_remove
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next_node
expr_stmt|;
block|}
name|uu_avl_pool_destroy
argument_list|(
name|fspset
operator|->
name|fsps_named_set_avl_pool
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|fspset
operator|->
name|fsps_who_perm_avl_pool
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|fspset
operator|->
name|fsps_deleg_perm_avl_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|deleg_perm_init
parameter_list|(
name|deleg_perm_t
modifier|*
name|deleg_perm
parameter_list|,
name|zfs_deleg_who_type_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|deleg_perm
operator|->
name|dp_who_type
operator|=
name|type
expr_stmt|;
name|deleg_perm
operator|->
name|dp_name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|who_perm_init
parameter_list|(
name|who_perm_t
modifier|*
name|who_perm
parameter_list|,
name|fs_perm_t
modifier|*
name|fsperm
parameter_list|,
name|zfs_deleg_who_type_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uu_avl_pool_t
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
name|fsperm
operator|->
name|fsp_set
operator|->
name|fsps_deleg_perm_avl_pool
expr_stmt|;
name|bzero
argument_list|(
name|who_perm
argument_list|,
sizeof|sizeof
argument_list|(
name|who_perm_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|who_perm
operator|->
name|who_deleg_perm_avl
operator|=
name|uu_avl_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|who_perm
operator|->
name|who_type
operator|=
name|type
expr_stmt|;
name|who_perm
operator|->
name|who_name
operator|=
name|name
expr_stmt|;
name|who_perm
operator|->
name|who_fsperm
operator|=
name|fsperm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|who_perm_fini
parameter_list|(
name|who_perm_t
modifier|*
name|who_perm
parameter_list|)
block|{
name|deleg_perm_node_t
modifier|*
name|node
init|=
name|uu_avl_first
argument_list|(
name|who_perm
operator|->
name|who_deleg_perm_avl
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|deleg_perm_node_t
modifier|*
name|next_node
init|=
name|uu_avl_next
argument_list|(
name|who_perm
operator|->
name|who_deleg_perm_avl
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|uu_avl_remove
argument_list|(
name|who_perm
operator|->
name|who_deleg_perm_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next_node
expr_stmt|;
block|}
name|uu_avl_destroy
argument_list|(
name|who_perm
operator|->
name|who_deleg_perm_avl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fs_perm_init
parameter_list|(
name|fs_perm_t
modifier|*
name|fsperm
parameter_list|,
name|fs_perm_set_t
modifier|*
name|fspset
parameter_list|,
specifier|const
name|char
modifier|*
name|fsname
parameter_list|)
block|{
name|uu_avl_pool_t
modifier|*
name|nset_pool
init|=
name|fspset
operator|->
name|fsps_named_set_avl_pool
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|who_pool
init|=
name|fspset
operator|->
name|fsps_who_perm_avl_pool
decl_stmt|;
name|bzero
argument_list|(
name|fsperm
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_perm_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fsperm
operator|->
name|fsp_sc_avl
operator|=
name|uu_avl_create
argument_list|(
name|nset_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fsperm
operator|->
name|fsp_uge_avl
operator|=
name|uu_avl_create
argument_list|(
name|who_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|fsperm
operator|->
name|fsp_set
operator|=
name|fspset
expr_stmt|;
name|fsperm
operator|->
name|fsp_name
operator|=
name|fsname
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fs_perm_fini
parameter_list|(
name|fs_perm_t
modifier|*
name|fsperm
parameter_list|)
block|{
name|who_perm_node_t
modifier|*
name|node
init|=
name|uu_avl_first
argument_list|(
name|fsperm
operator|->
name|fsp_sc_avl
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|who_perm_node_t
modifier|*
name|next_node
init|=
name|uu_avl_next
argument_list|(
name|fsperm
operator|->
name|fsp_sc_avl
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|who_perm_t
modifier|*
name|who_perm
init|=
operator|&
name|node
operator|->
name|who_perm
decl_stmt|;
name|who_perm_fini
argument_list|(
name|who_perm
argument_list|)
expr_stmt|;
name|uu_avl_remove
argument_list|(
name|fsperm
operator|->
name|fsp_sc_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next_node
expr_stmt|;
block|}
name|node
operator|=
name|uu_avl_first
argument_list|(
name|fsperm
operator|->
name|fsp_uge_avl
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|who_perm_node_t
modifier|*
name|next_node
init|=
name|uu_avl_next
argument_list|(
name|fsperm
operator|->
name|fsp_uge_avl
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|who_perm_t
modifier|*
name|who_perm
init|=
operator|&
name|node
operator|->
name|who_perm
decl_stmt|;
name|who_perm_fini
argument_list|(
name|who_perm
argument_list|)
expr_stmt|;
name|uu_avl_remove
argument_list|(
name|fsperm
operator|->
name|fsp_uge_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next_node
expr_stmt|;
block|}
name|uu_avl_destroy
argument_list|(
name|fsperm
operator|->
name|fsp_sc_avl
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|fsperm
operator|->
name|fsp_uge_avl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_deleg_perm_node
parameter_list|(
name|uu_avl_t
modifier|*
name|avl
parameter_list|,
name|deleg_perm_node_t
modifier|*
name|node
parameter_list|,
name|zfs_deleg_who_type_t
name|who_type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
name|locality
parameter_list|)
block|{
name|uu_avl_index_t
name|idx
init|=
literal|0
decl_stmt|;
name|deleg_perm_node_t
modifier|*
name|found_node
init|=
name|NULL
decl_stmt|;
name|deleg_perm_t
modifier|*
name|deleg_perm
init|=
operator|&
name|node
operator|->
name|dpn_perm
decl_stmt|;
name|deleg_perm_init
argument_list|(
name|deleg_perm
argument_list|,
name|who_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|found_node
operator|=
name|uu_avl_find
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|uu_avl_insert
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|=
name|found_node
expr_stmt|;
name|deleg_perm
operator|=
operator|&
name|node
operator|->
name|dpn_perm
expr_stmt|;
block|}
switch|switch
condition|(
name|locality
condition|)
block|{
case|case
name|ZFS_DELEG_LOCAL
case|:
name|deleg_perm
operator|->
name|dp_local
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_DESCENDENT
case|:
name|deleg_perm
operator|->
name|dp_descend
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NA
case|:
break|break;
default|default:
name|assert
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* invalid locality */
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|parse_who_perm
parameter_list|(
name|who_perm_t
modifier|*
name|who_perm
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
name|locality
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|fs_perm_set_t
modifier|*
name|fspset
init|=
name|who_perm
operator|->
name|who_fsperm
operator|->
name|fsp_set
decl_stmt|;
name|uu_avl_t
modifier|*
name|avl
init|=
name|who_perm
operator|->
name|who_deleg_perm_avl
decl_stmt|;
name|zfs_deleg_who_type_t
name|who_type
init|=
name|who_perm
operator|->
name|who_type
decl_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|data_type_t
name|type
init|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|avl_pool
init|=
name|fspset
operator|->
name|fsps_deleg_perm_avl_pool
decl_stmt|;
name|deleg_perm_node_t
modifier|*
name|node
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|deleg_perm_node_t
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|type
operator|==
name|DATA_TYPE_BOOLEAN
argument_list|)
expr_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|dpn_avl_node
argument_list|,
name|avl_pool
argument_list|)
expr_stmt|;
name|set_deleg_perm_node
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|who_type
argument_list|,
name|name
argument_list|,
name|locality
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|parse_fs_perm
parameter_list|(
name|fs_perm_t
modifier|*
name|fsperm
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|fs_perm_set_t
modifier|*
name|fspset
init|=
name|fsperm
operator|->
name|fsp_set
decl_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvl2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|uu_avl_t
modifier|*
name|avl
init|=
name|NULL
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|avl_pool
init|=
name|NULL
decl_stmt|;
name|zfs_deleg_who_type_t
name|perm_type
init|=
name|name
index|[
literal|0
index|]
decl_stmt|;
name|char
name|perm_locality
init|=
name|name
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|perm_name
init|=
name|name
operator|+
literal|3
decl_stmt|;
name|boolean_t
name|is_set
init|=
name|B_TRUE
decl_stmt|;
name|who_perm_t
modifier|*
name|who_perm
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
literal|'$'
operator|==
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvpair_value_nvlist
argument_list|(
name|nvp
argument_list|,
operator|&
name|nvl2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|perm_type
condition|)
block|{
case|case
name|ZFS_DELEG_CREATE
case|:
case|case
name|ZFS_DELEG_CREATE_SETS
case|:
case|case
name|ZFS_DELEG_NAMED_SET
case|:
case|case
name|ZFS_DELEG_NAMED_SET_SETS
case|:
name|avl_pool
operator|=
name|fspset
operator|->
name|fsps_named_set_avl_pool
expr_stmt|;
name|avl
operator|=
name|fsperm
operator|->
name|fsp_sc_avl
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_USER
case|:
case|case
name|ZFS_DELEG_USER_SETS
case|:
case|case
name|ZFS_DELEG_GROUP
case|:
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
case|case
name|ZFS_DELEG_EVERYONE
case|:
case|case
name|ZFS_DELEG_EVERYONE_SETS
case|:
name|avl_pool
operator|=
name|fspset
operator|->
name|fsps_who_perm_avl_pool
expr_stmt|;
name|avl
operator|=
name|fsperm
operator|->
name|fsp_uge_avl
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
operator|!
literal|"unhandled zfs_deleg_who_type_t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_set
condition|)
block|{
name|who_perm_node_t
modifier|*
name|found_node
init|=
name|NULL
decl_stmt|;
name|who_perm_node_t
modifier|*
name|node
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|who_perm_node_t
argument_list|)
argument_list|)
decl_stmt|;
name|who_perm
operator|=
operator|&
name|node
operator|->
name|who_perm
expr_stmt|;
name|uu_avl_index_t
name|idx
init|=
literal|0
decl_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|who_avl_node
argument_list|,
name|avl_pool
argument_list|)
expr_stmt|;
name|who_perm_init
argument_list|(
name|who_perm
argument_list|,
name|fsperm
argument_list|,
name|perm_type
argument_list|,
name|perm_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|found_node
operator|=
name|uu_avl_find
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|avl
operator|==
name|fsperm
operator|->
name|fsp_uge_avl
condition|)
block|{
name|uid_t
name|rid
init|=
literal|0
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|g
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|nice_name
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|perm_type
condition|)
block|{
case|case
name|ZFS_DELEG_USER_SETS
case|:
case|case
name|ZFS_DELEG_USER
case|:
name|rid
operator|=
name|atoi
argument_list|(
name|perm_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|getpwuid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|nice_name
operator|=
name|p
operator|->
name|pw_name
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
case|case
name|ZFS_DELEG_GROUP
case|:
name|rid
operator|=
name|atoi
argument_list|(
name|perm_name
argument_list|)
expr_stmt|;
name|g
operator|=
name|getgrgid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
name|nice_name
operator|=
name|g
operator|->
name|gr_name
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|nice_name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|node
operator|->
name|who_perm
operator|.
name|who_ug_name
argument_list|,
name|nice_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
name|uu_avl_insert
argument_list|(
name|avl
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|found_node
expr_stmt|;
name|who_perm
operator|=
operator|&
name|node
operator|->
name|who_perm
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|parse_who_perm
argument_list|(
name|who_perm
argument_list|,
name|nvl2
argument_list|,
name|perm_locality
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|parse_fs_perm_set
parameter_list|(
name|fs_perm_set_t
modifier|*
name|fspset
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|uu_avl_index_t
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvl2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|fsname
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|data_type_t
name|type
init|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|fs_perm_t
modifier|*
name|fsperm
init|=
name|NULL
decl_stmt|;
name|fs_perm_node_t
modifier|*
name|node
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fs_perm_node_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|fsperm
operator|=
operator|&
name|node
operator|->
name|fspn_fsperm
expr_stmt|;
name|assert
argument_list|(
name|DATA_TYPE_NVLIST
operator|==
name|type
argument_list|)
expr_stmt|;
name|uu_list_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|fspn_list_node
argument_list|,
name|fspset
operator|->
name|fsps_list_pool
argument_list|)
expr_stmt|;
name|idx
operator|=
name|uu_list_numnodes
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|)
expr_stmt|;
name|fs_perm_init
argument_list|(
name|fsperm
argument_list|,
name|fspset
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvpair_value_nvlist
argument_list|(
name|nvp
argument_list|,
operator|&
name|nvl2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parse_fs_perm
argument_list|(
name|fsperm
argument_list|,
name|nvl2
argument_list|)
expr_stmt|;
name|uu_list_insert
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|deleg_perm_comment
parameter_list|(
name|zfs_deleg_note_t
name|note
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|""
decl_stmt|;
comment|/* subcommands */
switch|switch
condition|(
name|note
condition|)
block|{
comment|/* SUBCOMMANDS */
case|case
name|ZFS_DELEG_NOTE_ALLOW
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the permission that is being"
literal|"\n\t\t\t\tallowed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_CLONE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'create' ability and 'mount'"
literal|"\n\t\t\t\tability in the origin file system"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_CREATE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'mount' ability"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_DESTROY
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'mount' ability"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_DIFF
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows lookup of paths within a dataset;"
literal|"\n\t\t\t\tgiven an object number. Ordinary users need this"
literal|"\n\t\t\t\tin order to use zfs diff"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_HOLD
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows adding a user hold to a snapshot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_MOUNT
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows mount/umount of ZFS datasets"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_PROMOTE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'mount'\n\t\t\t\tand"
literal|" 'promote' ability in the origin file system"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_RECEIVE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'mount' and 'create'"
literal|" ability"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_RELEASE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows releasing a user hold which\n\t\t\t\t"
literal|"might destroy the snapshot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_RENAME
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Must also have the 'mount' and 'create'"
literal|"\n\t\t\t\tability in the new parent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_ROLLBACK
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_SEND
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_SHARE
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows sharing file systems over NFS or SMB"
literal|"\n\t\t\t\tprotocols"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_SNAPSHOT
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
comment|/*  *	case ZFS_DELEG_NOTE_VSCAN:  *		str = gettext("");  *		break;  */
comment|/* OTHER */
case|case
name|ZFS_DELEG_NOTE_GROUPQUOTA
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows accessing any groupquota@... property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_GROUPUSED
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows reading any groupused@... property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_USERPROP
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows changing any user property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_USERQUOTA
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows accessing any userquota@... property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NOTE_USERUSED
case|:
name|str
operator|=
name|gettext
argument_list|(
literal|"Allows reading any userused@... property"
argument_list|)
expr_stmt|;
break|break;
comment|/* other */
default|default:
name|str
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|allow_opts
block|{
name|boolean_t
name|local
decl_stmt|;
name|boolean_t
name|descend
decl_stmt|;
name|boolean_t
name|user
decl_stmt|;
name|boolean_t
name|group
decl_stmt|;
name|boolean_t
name|everyone
decl_stmt|;
name|boolean_t
name|create
decl_stmt|;
name|boolean_t
name|set
decl_stmt|;
name|boolean_t
name|recursive
decl_stmt|;
comment|/* unallow only */
name|boolean_t
name|prt_usage
decl_stmt|;
name|boolean_t
name|prt_perms
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|;
name|char
modifier|*
name|perms
decl_stmt|;
specifier|const
name|char
modifier|*
name|dataset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|prop_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str1
init|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|char
modifier|*
name|str2
init|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|b
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|allow_usage
parameter_list|(
name|boolean_t
name|un
parameter_list|,
name|boolean_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opt_desc
index|[]
init|=
block|{
literal|"-h"
block|,
name|gettext
argument_list|(
literal|"show this help message and exit"
argument_list|)
block|,
literal|"-l"
block|,
name|gettext
argument_list|(
literal|"set permission locally"
argument_list|)
block|,
literal|"-d"
block|,
name|gettext
argument_list|(
literal|"set permission for descents"
argument_list|)
block|,
literal|"-u"
block|,
name|gettext
argument_list|(
literal|"set permission for user"
argument_list|)
block|,
literal|"-g"
block|,
name|gettext
argument_list|(
literal|"set permission for group"
argument_list|)
block|,
literal|"-e"
block|,
name|gettext
argument_list|(
literal|"set permission for everyone"
argument_list|)
block|,
literal|"-c"
block|,
name|gettext
argument_list|(
literal|"set create time permission"
argument_list|)
block|,
literal|"-s"
block|,
name|gettext
argument_list|(
literal|"define permission set"
argument_list|)
block|,
comment|/* unallow only */
literal|"-r"
block|,
name|gettext
argument_list|(
literal|"remove permissions recursively"
argument_list|)
block|, 	}
decl_stmt|;
name|size_t
name|unallow_size
init|=
sizeof|sizeof
argument_list|(
name|opt_desc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|allow_size
init|=
name|unallow_size
operator|-
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|props
index|[
name|ZFS_NUM_PROPS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
name|zprop_desc_t
modifier|*
name|pdtbl
init|=
name|zfs_prop_get_table
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|gettext
argument_list|(
literal|"%-16s %-14s\t%s\n"
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"Usage: %s\n"
argument_list|)
argument_list|,
name|get_usage
argument_list|(
name|un
condition|?
name|HELP_UNALLOW
else|:
name|HELP_ALLOW
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"Options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|un
condition|?
name|unallow_size
else|:
name|allow_size
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|opt
init|=
name|opt_desc
index|[
name|i
operator|++
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|optdsc
init|=
name|opt_desc
index|[
name|i
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"  %-10s  %s\n"
argument_list|)
argument_list|,
name|opt
argument_list|,
name|optdsc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe following permissions are "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"TYPE"
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"NOTES"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZFS_NUM_DELEG_NOTES
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|perm_name
init|=
name|zfs_deleg_perm_tbl
index|[
name|i
index|]
operator|.
name|z_perm
decl_stmt|;
name|zfs_deleg_note_t
name|perm_note
init|=
name|zfs_deleg_perm_tbl
index|[
name|i
index|]
operator|.
name|z_note
decl_stmt|;
specifier|const
name|char
modifier|*
name|perm_type
init|=
name|deleg_perm_type
argument_list|(
name|perm_note
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|perm_comment
init|=
name|deleg_perm_comment
argument_list|(
name|perm_note
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|perm_name
argument_list|,
name|perm_type
argument_list|,
name|perm_comment
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZFS_NUM_PROPS
condition|;
name|i
operator|++
control|)
block|{
name|zprop_desc_t
modifier|*
name|pd
init|=
operator|&
name|pdtbl
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_visible
operator|!=
name|B_TRUE
condition|)
continue|continue;
if|if
condition|(
name|pd
operator|->
name|pd_attr
operator|==
name|PROP_READONLY
condition|)
continue|continue;
name|props
index|[
name|count
operator|++
index|]
operator|=
name|pd
operator|->
name|pd_name
expr_stmt|;
block|}
name|props
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
name|qsort
argument_list|(
name|props
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|prop_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|props
index|[
name|i
index|]
argument_list|,
name|gettext
argument_list|(
literal|"property"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nzfs: error: %s"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|munge_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|un
parameter_list|,
name|size_t
name|expected_argc
parameter_list|,
name|char
modifier|*
modifier|*
name|permsp
parameter_list|)
block|{
if|if
condition|(
name|un
operator|&&
name|argc
operator|==
name|expected_argc
operator|-
literal|1
condition|)
operator|*
name|permsp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
name|expected_argc
condition|)
operator|*
name|permsp
operator|=
name|argv
index|[
name|argc
operator|-
literal|2
index|]
expr_stmt|;
else|else
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"wrong number of parameters\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_allow_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|un
parameter_list|,
name|struct
name|allow_opts
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|uge_sum
init|=
name|opts
operator|->
name|user
operator|+
name|opts
operator|->
name|group
operator|+
name|opts
operator|->
name|everyone
decl_stmt|;
name|int
name|csuge_sum
init|=
name|opts
operator|->
name|create
operator|+
name|opts
operator|->
name|set
operator|+
name|uge_sum
decl_stmt|;
name|int
name|ldcsuge_sum
init|=
name|csuge_sum
operator|+
name|opts
operator|->
name|local
operator|+
name|opts
operator|->
name|descend
decl_stmt|;
name|int
name|all_sum
init|=
name|un
condition|?
name|ldcsuge_sum
operator|+
name|opts
operator|->
name|recursive
else|:
name|ldcsuge_sum
decl_stmt|;
if|if
condition|(
name|uge_sum
operator|>
literal|1
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"-u, -g, and -e are mutually exclusive\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|prt_usage
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|all_sum
operator|==
literal|0
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|->
name|set
condition|)
block|{
if|if
condition|(
name|csuge_sum
operator|>
literal|1
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"invalid options combined with -s\n"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|->
name|dataset
operator|=
name|munge_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
literal|3
argument_list|,
operator|&
name|opts
operator|->
name|perms
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"invalid set name: missing '@' prefix\n"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|->
name|who
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|create
condition|)
block|{
if|if
condition|(
name|ldcsuge_sum
operator|>
literal|1
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"invalid options combined with -c\n"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|->
name|dataset
operator|=
name|munge_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
literal|2
argument_list|,
operator|&
name|opts
operator|->
name|perms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|everyone
condition|)
block|{
if|if
condition|(
name|csuge_sum
operator|>
literal|1
condition|)
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"invalid options combined with -e\n"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|->
name|dataset
operator|=
name|munge_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
literal|2
argument_list|,
operator|&
name|opts
operator|->
name|perms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uge_sum
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"everyone"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opts
operator|->
name|everyone
operator|=
name|B_TRUE
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|opts
operator|->
name|dataset
operator|=
name|munge_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
literal|2
argument_list|,
operator|&
name|opts
operator|->
name|perms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|un
condition|)
block|{
name|opts
operator|->
name|prt_perms
operator|=
name|B_TRUE
expr_stmt|;
name|opts
operator|->
name|dataset
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|opts
operator|->
name|dataset
operator|=
name|munge_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
literal|3
argument_list|,
operator|&
name|opts
operator|->
name|perms
argument_list|)
expr_stmt|;
name|opts
operator|->
name|who
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|opts
operator|->
name|local
operator|&&
operator|!
name|opts
operator|->
name|descend
condition|)
block|{
name|opts
operator|->
name|local
operator|=
name|B_TRUE
expr_stmt|;
name|opts
operator|->
name|descend
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_allow_perm
parameter_list|(
name|zfs_deleg_who_type_t
name|type
parameter_list|,
name|boolean_t
name|local
parameter_list|,
name|boolean_t
name|descend
parameter_list|,
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|char
modifier|*
name|perms
parameter_list|,
name|nvlist_t
modifier|*
name|top_nvl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|ld
index|[
literal|2
index|]
init|=
block|{
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
name|char
name|who_buf
index|[
name|MAXNAMELEN
operator|+
literal|32
index|]
decl_stmt|;
name|char
name|base_type
init|=
literal|'\0'
decl_stmt|;
name|char
name|set_type
init|=
literal|'\0'
decl_stmt|;
name|nvlist_t
modifier|*
name|base_nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|set_nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|base_nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|set_nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_DELEG_NAMED_SET_SETS
case|:
case|case
name|ZFS_DELEG_NAMED_SET
case|:
name|set_type
operator|=
name|ZFS_DELEG_NAMED_SET_SETS
expr_stmt|;
name|base_type
operator|=
name|ZFS_DELEG_NAMED_SET
expr_stmt|;
name|ld
index|[
literal|0
index|]
operator|=
name|ZFS_DELEG_NA
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_CREATE_SETS
case|:
case|case
name|ZFS_DELEG_CREATE
case|:
name|set_type
operator|=
name|ZFS_DELEG_CREATE_SETS
expr_stmt|;
name|base_type
operator|=
name|ZFS_DELEG_CREATE
expr_stmt|;
name|ld
index|[
literal|0
index|]
operator|=
name|ZFS_DELEG_NA
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_USER_SETS
case|:
case|case
name|ZFS_DELEG_USER
case|:
name|set_type
operator|=
name|ZFS_DELEG_USER_SETS
expr_stmt|;
name|base_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|ld
index|[
literal|0
index|]
operator|=
name|ZFS_DELEG_LOCAL
expr_stmt|;
if|if
condition|(
name|descend
condition|)
name|ld
index|[
literal|1
index|]
operator|=
name|ZFS_DELEG_DESCENDENT
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
case|case
name|ZFS_DELEG_GROUP
case|:
name|set_type
operator|=
name|ZFS_DELEG_GROUP_SETS
expr_stmt|;
name|base_type
operator|=
name|ZFS_DELEG_GROUP
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|ld
index|[
literal|0
index|]
operator|=
name|ZFS_DELEG_LOCAL
expr_stmt|;
if|if
condition|(
name|descend
condition|)
name|ld
index|[
literal|1
index|]
operator|=
name|ZFS_DELEG_DESCENDENT
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_EVERYONE_SETS
case|:
case|case
name|ZFS_DELEG_EVERYONE
case|:
name|set_type
operator|=
name|ZFS_DELEG_EVERYONE_SETS
expr_stmt|;
name|base_type
operator|=
name|ZFS_DELEG_EVERYONE
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|ld
index|[
literal|0
index|]
operator|=
name|ZFS_DELEG_LOCAL
expr_stmt|;
if|if
condition|(
name|descend
condition|)
name|ld
index|[
literal|1
index|]
operator|=
name|ZFS_DELEG_DESCENDENT
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|set_type
operator|!=
literal|'\0'
operator|&&
name|base_type
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|perms
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|curr
init|=
name|perms
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|curr
operator|+
name|strlen
argument_list|(
name|perms
argument_list|)
decl_stmt|;
while|while
condition|(
name|curr
operator|<
name|end
condition|)
block|{
name|char
modifier|*
name|delim
init|=
name|strchr
argument_list|(
name|curr
argument_list|,
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|delim
operator|==
name|NULL
condition|)
name|delim
operator|=
name|end
expr_stmt|;
else|else
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|curr
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|nvl
operator|=
name|set_nvl
expr_stmt|;
else|else
name|nvl
operator|=
name|base_nvl
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_boolean
argument_list|(
name|nvl
argument_list|,
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
operator|!=
name|end
condition|)
operator|*
name|delim
operator|=
literal|','
expr_stmt|;
name|curr
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|char
name|locality
init|=
name|ld
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|locality
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|nvlist_empty
argument_list|(
name|base_nvl
argument_list|)
condition|)
block|{
if|if
condition|(
name|who
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$%s"
argument_list|,
name|base_type
argument_list|,
name|locality
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$"
argument_list|,
name|base_type
argument_list|,
name|locality
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_nvlist
argument_list|(
name|top_nvl
argument_list|,
name|who_buf
argument_list|,
name|base_nvl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nvlist_empty
argument_list|(
name|set_nvl
argument_list|)
condition|)
block|{
if|if
condition|(
name|who
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$%s"
argument_list|,
name|set_type
argument_list|,
name|locality
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$"
argument_list|,
name|set_type
argument_list|,
name|locality
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_nvlist
argument_list|(
name|top_nvl
argument_list|,
name|who_buf
argument_list|,
name|set_nvl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|char
name|locality
init|=
name|ld
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|locality
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|who
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$%s"
argument_list|,
name|base_type
argument_list|,
name|locality
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$"
argument_list|,
name|base_type
argument_list|,
name|locality
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_boolean
argument_list|(
name|top_nvl
argument_list|,
name|who_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|who
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$%s"
argument_list|,
name|set_type
argument_list|,
name|locality
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|who_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|who_buf
argument_list|)
argument_list|,
literal|"%c%c$"
argument_list|,
name|set_type
argument_list|,
name|locality
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_boolean
argument_list|(
name|top_nvl
argument_list|,
name|who_buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|construct_fsacl_list
parameter_list|(
name|boolean_t
name|un
parameter_list|,
name|struct
name|allow_opts
modifier|*
name|opts
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|)
block|{
if|if
condition|(
name|nvlist_alloc
argument_list|(
name|nvlp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|set
condition|)
block|{
name|store_allow_perm
argument_list|(
name|ZFS_DELEG_NAMED_SET
argument_list|,
name|opts
operator|->
name|local
argument_list|,
name|opts
operator|->
name|descend
argument_list|,
name|opts
operator|->
name|who
argument_list|,
name|opts
operator|->
name|perms
argument_list|,
operator|*
name|nvlp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|create
condition|)
block|{
name|store_allow_perm
argument_list|(
name|ZFS_DELEG_CREATE
argument_list|,
name|opts
operator|->
name|local
argument_list|,
name|opts
operator|->
name|descend
argument_list|,
name|NULL
argument_list|,
name|opts
operator|->
name|perms
argument_list|,
operator|*
name|nvlp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|everyone
condition|)
block|{
name|store_allow_perm
argument_list|(
name|ZFS_DELEG_EVERYONE
argument_list|,
name|opts
operator|->
name|local
argument_list|,
name|opts
operator|->
name|descend
argument_list|,
name|NULL
argument_list|,
name|opts
operator|->
name|perms
argument_list|,
operator|*
name|nvlp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|curr
init|=
name|opts
operator|->
name|who
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|curr
operator|+
name|strlen
argument_list|(
name|curr
argument_list|)
decl_stmt|;
while|while
condition|(
name|curr
operator|<
name|end
condition|)
block|{
specifier|const
name|char
modifier|*
name|who
decl_stmt|;
name|zfs_deleg_who_type_t
name|who_type
init|=
name|ZFS_DELEG_WHO_UNKNOWN
decl_stmt|;
name|char
modifier|*
name|endch
decl_stmt|;
name|char
modifier|*
name|delim
init|=
name|strchr
argument_list|(
name|curr
argument_list|,
literal|','
argument_list|)
decl_stmt|;
name|char
name|errbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|id
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|g
init|=
name|NULL
decl_stmt|;
name|uid_t
name|rid
decl_stmt|;
if|if
condition|(
name|delim
operator|==
name|NULL
condition|)
name|delim
operator|=
name|end
expr_stmt|;
else|else
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|rid
operator|=
operator|(
name|uid_t
operator|)
name|strtol
argument_list|(
name|curr
argument_list|,
operator|&
name|endch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|user
condition|)
block|{
name|who_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
if|if
condition|(
operator|*
name|endch
operator|!=
literal|'\0'
condition|)
name|p
operator|=
name|getpwnam
argument_list|(
name|curr
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|getpwuid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|rid
operator|=
name|p
operator|->
name|pw_uid
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
literal|256
argument_list|,
name|gettext
argument_list|(
literal|"invalid user %s"
argument_list|)
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_TRUE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|group
condition|)
block|{
name|who_type
operator|=
name|ZFS_DELEG_GROUP
expr_stmt|;
if|if
condition|(
operator|*
name|endch
operator|!=
literal|'\0'
condition|)
name|g
operator|=
name|getgrnam
argument_list|(
name|curr
argument_list|)
expr_stmt|;
else|else
name|g
operator|=
name|getgrgid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|!=
name|NULL
condition|)
name|rid
operator|=
name|g
operator|->
name|gr_gid
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
literal|256
argument_list|,
name|gettext
argument_list|(
literal|"invalid group %s"
argument_list|)
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_TRUE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|endch
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|getpwnam
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|getpwuid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|endch
operator|!=
literal|'\0'
condition|)
block|{
name|g
operator|=
name|getgrnam
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|getgrgid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|who_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
name|rid
operator|=
name|p
operator|->
name|pw_uid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|!=
name|NULL
condition|)
block|{
name|who_type
operator|=
name|ZFS_DELEG_GROUP
expr_stmt|;
name|rid
operator|=
name|g
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
literal|256
argument_list|,
name|gettext
argument_list|(
literal|"invalid user/group %s"
argument_list|)
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|allow_usage
argument_list|(
name|un
argument_list|,
name|B_TRUE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|id
argument_list|,
literal|"%u"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|who
operator|=
name|id
expr_stmt|;
name|store_allow_perm
argument_list|(
name|who_type
argument_list|,
name|opts
operator|->
name|local
argument_list|,
name|opts
operator|->
name|descend
argument_list|,
name|who
argument_list|,
name|opts
operator|->
name|perms
argument_list|,
operator|*
name|nvlp
argument_list|)
expr_stmt|;
name|curr
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_set_creat_perms
parameter_list|(
name|uu_avl_t
modifier|*
name|who_avl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sc_title
index|[]
init|=
block|{
name|gettext
argument_list|(
literal|"Permission sets:\n"
argument_list|)
block|,
name|gettext
argument_list|(
literal|"Create time permissions:\n"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|title_ptr
init|=
name|sc_title
decl_stmt|;
name|who_perm_node_t
modifier|*
name|who_node
init|=
name|NULL
decl_stmt|;
name|int
name|prev_weight
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|who_node
operator|=
name|uu_avl_first
argument_list|(
name|who_avl
argument_list|)
init|;
name|who_node
operator|!=
name|NULL
condition|;
name|who_node
operator|=
name|uu_avl_next
argument_list|(
name|who_avl
argument_list|,
name|who_node
argument_list|)
control|)
block|{
name|uu_avl_t
modifier|*
name|avl
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_deleg_perm_avl
decl_stmt|;
name|zfs_deleg_who_type_t
name|who_type
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|who_name
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_name
decl_stmt|;
name|int
name|weight
init|=
name|who_type2weight
argument_list|(
name|who_type
argument_list|)
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|deleg_perm_node_t
modifier|*
name|deleg_node
decl_stmt|;
if|if
condition|(
name|prev_weight
operator|!=
name|weight
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
operator|*
name|title_ptr
operator|++
argument_list|)
expr_stmt|;
name|prev_weight
operator|=
name|weight
expr_stmt|;
block|}
if|if
condition|(
name|who_name
operator|==
name|NULL
operator|||
name|strnlen
argument_list|(
name|who_name
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s "
argument_list|,
name|who_name
argument_list|)
expr_stmt|;
for|for
control|(
name|deleg_node
operator|=
name|uu_avl_first
argument_list|(
name|avl
argument_list|)
init|;
name|deleg_node
operator|!=
name|NULL
condition|;
name|deleg_node
operator|=
name|uu_avl_next
argument_list|(
name|avl
argument_list|,
name|deleg_node
argument_list|)
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|deleg_node
operator|->
name|dpn_perm
operator|.
name|dp_name
argument_list|)
expr_stmt|;
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",%s"
argument_list|,
name|deleg_node
operator|->
name|dpn_perm
operator|.
name|dp_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_uge_deleg_perms
parameter_list|(
name|uu_avl_t
modifier|*
name|who_avl
parameter_list|,
name|boolean_t
name|local
parameter_list|,
name|boolean_t
name|descend
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|)
block|{
name|who_perm_node_t
modifier|*
name|who_node
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|prt_title
init|=
name|B_TRUE
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|who_avl
argument_list|,
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|who_node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|who_name
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|nice_who_name
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_ug_name
decl_stmt|;
name|uu_avl_t
modifier|*
name|avl
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_deleg_perm_avl
decl_stmt|;
name|zfs_deleg_who_type_t
name|who_type
init|=
name|who_node
operator|->
name|who_perm
operator|.
name|who_type
decl_stmt|;
name|char
name|delim
init|=
literal|' '
decl_stmt|;
name|deleg_perm_node_t
modifier|*
name|deleg_node
decl_stmt|;
name|boolean_t
name|prt_who
init|=
name|B_TRUE
decl_stmt|;
for|for
control|(
name|deleg_node
operator|=
name|uu_avl_first
argument_list|(
name|avl
argument_list|)
init|;
name|deleg_node
operator|!=
name|NULL
condition|;
name|deleg_node
operator|=
name|uu_avl_next
argument_list|(
name|avl
argument_list|,
name|deleg_node
argument_list|)
control|)
block|{
if|if
condition|(
name|local
operator|!=
name|deleg_node
operator|->
name|dpn_perm
operator|.
name|dp_local
operator|||
name|descend
operator|!=
name|deleg_node
operator|->
name|dpn_perm
operator|.
name|dp_descend
condition|)
continue|continue;
if|if
condition|(
name|prt_who
condition|)
block|{
specifier|const
name|char
modifier|*
name|who
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|prt_title
condition|)
block|{
name|prt_title
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|who_type
condition|)
block|{
case|case
name|ZFS_DELEG_USER_SETS
case|:
case|case
name|ZFS_DELEG_USER
case|:
name|who
operator|=
name|gettext
argument_list|(
literal|"user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nice_who_name
condition|)
name|who_name
operator|=
name|nice_who_name
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
case|case
name|ZFS_DELEG_GROUP
case|:
name|who
operator|=
name|gettext
argument_list|(
literal|"group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nice_who_name
condition|)
name|who_name
operator|=
name|nice_who_name
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_EVERYONE_SETS
case|:
case|case
name|ZFS_DELEG_EVERYONE
case|:
name|who
operator|=
name|gettext
argument_list|(
literal|"everyone"
argument_list|)
expr_stmt|;
name|who_name
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|who
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|prt_who
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|who_name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s %s"
argument_list|,
name|who
argument_list|,
name|who_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c%s"
argument_list|,
name|delim
argument_list|,
name|deleg_node
operator|->
name|dpn_perm
operator|.
name|dp_name
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|','
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prt_who
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fs_perms
parameter_list|(
name|fs_perm_set_t
modifier|*
name|fspset
parameter_list|)
block|{
name|fs_perm_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAMELEN
operator|+
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|buf
decl_stmt|;
for|for
control|(
name|node
operator|=
name|uu_list_first
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|uu_list_next
argument_list|(
name|fspset
operator|->
name|fsps_list
argument_list|,
name|node
argument_list|)
control|)
block|{
name|uu_avl_t
modifier|*
name|sc_avl
init|=
name|node
operator|->
name|fspn_fsperm
operator|.
name|fsp_sc_avl
decl_stmt|;
name|uu_avl_t
modifier|*
name|uge_avl
init|=
name|node
operator|->
name|fspn_fsperm
operator|.
name|fsp_uge_avl
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"---- Permissions on %s "
argument_list|)
argument_list|,
name|node
operator|->
name|fspn_fsperm
operator|.
name|fsp_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dsname
argument_list|)
expr_stmt|;
name|left
operator|=
literal|70
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
operator|--
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_set_creat_perms
argument_list|(
name|sc_avl
argument_list|)
expr_stmt|;
name|print_uge_deleg_perms
argument_list|(
name|uge_avl
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|,
name|gettext
argument_list|(
literal|"Local permissions:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_uge_deleg_perms
argument_list|(
name|uge_avl
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|,
name|gettext
argument_list|(
literal|"Descendent permissions:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_uge_deleg_perms
argument_list|(
name|uge_avl
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|,
name|gettext
argument_list|(
literal|"Local+Descendent permissions:\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|fs_perm_set_t
name|fs_perm_set
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|deleg_perms
block|{
name|boolean_t
name|un
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|set_deleg_perms
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|deleg_perms
modifier|*
name|perms
init|=
operator|(
expr|struct
name|deleg_perms
operator|*
operator|)
name|data
decl_stmt|;
name|zfs_type_t
name|zfs_type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|zfs_type
operator|!=
name|ZFS_TYPE_FILESYSTEM
operator|&&
name|zfs_type
operator|!=
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zfs_set_fsacl
argument_list|(
name|zhp
argument_list|,
name|perms
operator|->
name|un
argument_list|,
name|perms
operator|->
name|nvl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_allow_unallow_impl
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|un
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|perm_nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|update_perm_nvl
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|allow_opts
name|opts
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstr
init|=
name|un
condition|?
literal|"ldugecsrh"
else|:
literal|"ldugecsh"
decl_stmt|;
comment|/* check opts */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|opts
operator|.
name|local
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|opts
operator|.
name|descend
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|opts
operator|.
name|user
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|opts
operator|.
name|group
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|opts
operator|.
name|everyone
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|opts
operator|.
name|set
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|opts
operator|.
name|create
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|opts
operator|.
name|recursive
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|opts
operator|.
name|prt_usage
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
name|parse_allow_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|un
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
comment|/* try to open the dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|opts
operator|.
name|dataset
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to open dataset: %s\n"
argument_list|,
name|opts
operator|.
name|dataset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_get_fsacl
argument_list|(
name|zhp
argument_list|,
operator|&
name|perm_nvl
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|cleanup2
goto|;
name|fs_perm_set_init
argument_list|(
operator|&
name|fs_perm_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_fs_perm_set
argument_list|(
operator|&
name|fs_perm_set
argument_list|,
name|perm_nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to parse fsacl permissions\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup1
goto|;
block|}
if|if
condition|(
name|opts
operator|.
name|prt_perms
condition|)
name|print_fs_perms
argument_list|(
operator|&
name|fs_perm_set
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|construct_fsacl_list
argument_list|(
name|un
argument_list|,
operator|&
name|opts
argument_list|,
operator|&
name|update_perm_nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_set_fsacl
argument_list|(
name|zhp
argument_list|,
name|un
argument_list|,
name|update_perm_nvl
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|cleanup0
goto|;
if|if
condition|(
name|un
operator|&&
name|opts
operator|.
name|recursive
condition|)
block|{
name|struct
name|deleg_perms
name|data
init|=
block|{
name|un
block|,
name|update_perm_nvl
block|}
decl_stmt|;
if|if
condition|(
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|set_deleg_perms
argument_list|,
operator|&
name|data
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|cleanup0
goto|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|cleanup0
label|:
name|nvlist_free
argument_list|(
name|perm_nvl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|update_perm_nvl
argument_list|)
expr_stmt|;
name|cleanup1
label|:
name|fs_perm_set_fini
argument_list|(
operator|&
name|fs_perm_set
argument_list|)
expr_stmt|;
name|cleanup2
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_allow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zfs_do_allow_unallow_impl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_unallow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zfs_do_allow_unallow_impl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_hold_rele_impl
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|holding
parameter_list|)
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|boolean_t
name|recursive
init|=
name|B_FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
init|=
name|holding
condition|?
literal|"rt"
else|:
literal|"r"
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|recursive
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|tag
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|holding
operator|&&
name|tag
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* tags starting with '.' are reserved for libzfs */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"tag may not start with '.'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' is not a snapshot\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|++
name|errors
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
name|delim
operator|-
name|path
argument_list|)
expr_stmt|;
name|parent
index|[
name|delim
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|parent
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
block|{
operator|++
name|errors
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|holding
condition|)
block|{
if|if
condition|(
name|zfs_hold
argument_list|(
name|zhp
argument_list|,
name|delim
operator|+
literal|1
argument_list|,
name|tag
argument_list|,
name|recursive
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|errors
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zfs_release
argument_list|(
name|zhp
argument_list|,
name|delim
operator|+
literal|1
argument_list|,
name|tag
argument_list|,
name|recursive
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|errors
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|errors
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs hold [-r] [-t]<tag><snap> ...  *  *	-r	Recursively hold  *  * Apply a user-hold with the given tag to the list of snapshots.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_hold
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zfs_do_hold_rele_impl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs release [-r]<tag><snap> ...  *  *	-r	Recursively release  *  * Release a user-hold with the given tag from the list of snapshots.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_release
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zfs_do_hold_rele_impl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|holds_cbdata
block|{
name|boolean_t
name|cb_recursive
decl_stmt|;
specifier|const
name|char
modifier|*
name|cb_snapname
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|cb_nvlp
decl_stmt|;
name|size_t
name|cb_max_namelen
decl_stmt|;
name|size_t
name|cb_max_taglen
decl_stmt|;
block|}
name|holds_cbdata_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|STRFTIME_FMT_STR
value|"%a %b %e %k:%M %Y"
end_define

begin_define
define|#
directive|define
name|DATETIME_BUF_LEN
value|(32)
end_define

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|print_holds
parameter_list|(
name|boolean_t
name|scripted
parameter_list|,
name|size_t
name|nwidth
parameter_list|,
name|size_t
name|tagwidth
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|hdr_cols
index|[]
init|=
block|{
literal|"NAME"
block|,
literal|"TAG"
block|,
literal|"TIMESTAMP"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|col
decl_stmt|;
if|if
condition|(
operator|!
name|scripted
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|col
operator|=
name|gettext
argument_list|(
name|hdr_cols
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|i
condition|?
name|tagwidth
else|:
name|nwidth
argument_list|,
name|col
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zname
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl2
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp2
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_nvlist
argument_list|(
name|nvp
argument_list|,
operator|&
name|nvl2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nvp2
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl2
argument_list|,
name|nvp2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|tsbuf
index|[
name|DATETIME_BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|tagname
init|=
name|nvpair_name
argument_list|(
name|nvp2
argument_list|)
decl_stmt|;
name|uint64_t
name|val
init|=
literal|0
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|char
name|sep
init|=
name|scripted
condition|?
literal|'\t'
else|:
literal|' '
decl_stmt|;
name|size_t
name|sepnum
init|=
name|scripted
condition|?
literal|1
else|:
literal|2
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|nvp2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|time
operator|=
operator|(
name|time_t
operator|)
name|val
expr_stmt|;
operator|(
name|void
operator|)
name|localtime_r
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|tsbuf
argument_list|,
name|DATETIME_BUF_LEN
argument_list|,
name|gettext
argument_list|(
name|STRFTIME_FMT_STR
argument_list|)
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s%*c%-*s%*c%s\n"
argument_list|,
name|nwidth
argument_list|,
name|zname
argument_list|,
name|sepnum
argument_list|,
name|sep
argument_list|,
name|tagwidth
argument_list|,
name|tagname
argument_list|,
name|sepnum
argument_list|,
name|sep
argument_list|,
name|tsbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Generic callback function to list a dataset or snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|holds_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|holds_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|top_nvl
init|=
operator|*
name|cbp
operator|->
name|cb_nvlp
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|zname
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|size_t
name|znamelen
init|=
name|strlen
argument_list|(
name|zname
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_recursive
condition|)
block|{
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
name|char
modifier|*
name|delim
init|=
name|strchr
argument_list|(
name|zname
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|delim
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|snapname
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cbp
operator|->
name|cb_snapname
argument_list|,
name|snapname
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_get_holds
argument_list|(
name|zhp
argument_list|,
operator|&
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|znamelen
operator|>
name|cbp
operator|->
name|cb_max_namelen
condition|)
name|cbp
operator|->
name|cb_max_namelen
operator|=
name|znamelen
expr_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|tag
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|size_t
name|taglen
init|=
name|strlen
argument_list|(
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|taglen
operator|>
name|cbp
operator|->
name|cb_max_taglen
condition|)
name|cbp
operator|->
name|cb_max_taglen
operator|=
name|taglen
expr_stmt|;
block|}
return|return
operator|(
name|nvlist_add_nvlist
argument_list|(
name|top_nvl
argument_list|,
name|zname
argument_list|,
name|nvl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs holds [-r]<snap> ...  *  *	-r	Recursively hold  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_holds
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|scripted
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|recursive
init|=
name|B_FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
init|=
literal|"rH"
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|int
name|types
init|=
name|ZFS_TYPE_SNAPSHOT
decl_stmt|;
name|holds_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|recursive
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recursive
condition|)
block|{
name|types
operator||=
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|snapshot
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|snapshot
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' is not a snapshot\n"
argument_list|)
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
operator|++
name|errors
expr_stmt|;
continue|continue;
block|}
name|snapname
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
name|snapshot
index|[
name|delim
operator|-
name|snapshot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|.
name|cb_recursive
operator|=
name|recursive
expr_stmt|;
name|cb
operator|.
name|cb_snapname
operator|=
name|snapname
expr_stmt|;
name|cb
operator|.
name|cb_nvlp
operator|=
operator|&
name|nvl
expr_stmt|;
comment|/* 		 *  1. collect holds data, set format options 		 */
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|types
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|limit
argument_list|,
name|holds_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
operator|++
name|errors
expr_stmt|;
block|}
comment|/* 	 *  2. print holds data 	 */
name|print_holds
argument_list|(
name|scripted
argument_list|,
name|cb
operator|.
name|cb_max_namelen
argument_list|,
name|cb
operator|.
name|cb_max_taglen
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_empty
argument_list|(
name|nvl
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no datasets available\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|!=
name|errors
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECK_SPINNER
value|30
end_define

begin_define
define|#
directive|define
name|SPINNER_TIME
value|3
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|MOUNT_TIME
value|5
end_define

begin_comment
comment|/* seconds */
end_comment

begin_function
specifier|static
name|int
name|get_one_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|spin
index|[]
init|=
block|{
literal|"-"
block|,
literal|"\\"
block|,
literal|"|"
block|,
literal|"/"
block|}
decl_stmt|;
specifier|static
name|int
name|spinval
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|spincheck
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|last_spin_time
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
name|get_all_cb_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_verbose
condition|)
block|{
if|if
condition|(
operator|--
name|spincheck
operator|<
literal|0
condition|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_spin_time
operator|+
name|SPINNER_TIME
operator|<
name|now
condition|)
block|{
name|update_progress
argument_list|(
name|spin
index|[
name|spinval
operator|++
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
name|last_spin_time
operator|=
name|now
expr_stmt|;
block|}
name|spincheck
operator|=
name|CHECK_SPINNER
expr_stmt|;
block|}
block|}
comment|/* 	 * Interate over any nested datasets. 	 */
if|if
condition|(
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|get_one_dataset
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Skip any datasets whose type does not match. 	 */
if|if
condition|(
operator|(
name|type
operator|&
name|ZFS_TYPE_FILESYSTEM
operator|)
operator|==
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|libzfs_add_handle
argument_list|(
name|cbp
argument_list|,
name|zhp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cbp
operator|->
name|cb_used
operator|<=
name|cbp
operator|->
name|cb_alloc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_all_datasets
parameter_list|(
name|zfs_handle_t
modifier|*
modifier|*
modifier|*
name|dslist
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|,
name|boolean_t
name|verbose
parameter_list|)
block|{
name|get_all_cb_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cb
operator|.
name|cb_verbose
operator|=
name|verbose
expr_stmt|;
name|cb
operator|.
name|cb_getone
operator|=
name|get_one_dataset
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|set_progress_header
argument_list|(
name|gettext
argument_list|(
literal|"Reading ZFS config"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_root
argument_list|(
name|g_zfs
argument_list|,
name|get_one_dataset
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|*
name|dslist
operator|=
name|cb
operator|.
name|cb_handles
expr_stmt|;
operator|*
name|count
operator|=
name|cb
operator|.
name|cb_used
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|finish_progress
argument_list|(
name|gettext
argument_list|(
literal|"done."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for sharing or mounting filesystems.  Because the code is so  * similar, we have a common function with an extra parameter to determine which  * mode we are using.  */
end_comment

begin_define
define|#
directive|define
name|OP_SHARE
value|0x1
end_define

begin_define
define|#
directive|define
name|OP_MOUNT
value|0x2
end_define

begin_comment
comment|/*  * Share or mount a dataset.  */
end_comment

begin_function
specifier|static
name|int
name|share_mount_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|protocol
parameter_list|,
name|boolean_t
name|explicit
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|shareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|smbshareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
name|op
operator|==
name|OP_SHARE
condition|?
literal|"share"
else|:
literal|"mount"
decl_stmt|;
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|,
name|canmount
decl_stmt|;
name|boolean_t
name|shared_nfs
decl_stmt|,
name|shared_smb
decl_stmt|;
name|assert
argument_list|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|&
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
comment|/* 	 * Check to make sure we can mount/share this dataset.  If we 	 * are in the global zone and the filesystem is exported to a 	 * local zone, or if we are in a local zone and the 	 * filesystem is not exported, then it is an error. 	 */
name|zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
if|if
condition|(
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"dataset is exported to a local zone\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"permission denied\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Ignore any filesystems which don't apply to us. This 	 * includes those with a legacy mountpoint, or those with 	 * legacy share options. 	 */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|smbshareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|smbshareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share '%s': "
literal|"legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use share(1M) to "
literal|"share this filesystem, or set "
literal|"sharenfs property on\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We cannot share or mount legacy filesystems. If the 	 * shareopts is non-legacy but the mountpoint is legacy, we 	 * treat it as a legacy share. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"legacy mountpoint\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use %s(1M) to "
literal|"%s this filesystem\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': no "
literal|"mountpoint set\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * canmount	explicit	outcome 	 * on		no		pass through 	 * on		yes		pass through 	 * off		no		return 0 	 * off		yes		display error, return 1 	 * noauto	no		return 0 	 * noauto	yes		pass through 	 */
name|canmount
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|canmount
operator|==
name|ZFS_CANMOUNT_OFF
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"'canmount' property is set to 'off'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|canmount
operator|==
name|ZFS_CANMOUNT_NOAUTO
operator|&&
operator|!
name|explicit
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If this filesystem is inconsistent and has a receive resume 	 * token, we can not mount it. 	 */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_INCONSISTENT
argument_list|)
operator|&&
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_RECEIVE_RESUME_TOKEN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"Contains partially-completed state from "
literal|"\"zfs receive -r\", which can be resumed with "
literal|"\"zfs send -t\"\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * At this point, we have verified that the mountpoint and/or 	 * shareopts are appropriate for auto management. If the 	 * filesystem is already mounted or shared, return (failing 	 * for explicit requests); otherwise mount or share the 	 * filesystem. 	 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|shared_nfs
operator|=
name|zfs_is_shared_nfs
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shared_smb
operator|=
name|zfs_is_shared_smb
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shared_nfs
operator|&&
name|shared_smb
operator|)
operator|||
operator|(
name|shared_nfs
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|shared_smb
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': filesystem already shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|&&
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zfs_shareall
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zfs_share_nfs
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"smb"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zfs_share_smb
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': invalid share type '%s' "
literal|"specified\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
operator|(
name|char
operator|*
operator|)
name|options
expr_stmt|;
if|if
condition|(
operator|!
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTOPT_REMOUNT
argument_list|)
operator|&&
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot mount "
literal|"'%s': filesystem already mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|options
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reports progress in the form "(current/total)".  Not thread-safe.  */
end_comment

begin_function
specifier|static
name|void
name|report_mount_progress
parameter_list|(
name|int
name|current
parameter_list|,
name|int
name|total
parameter_list|)
block|{
specifier|static
name|time_t
name|last_progress_time
init|=
literal|0
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|char
name|info
index|[
literal|32
index|]
decl_stmt|;
comment|/* report 1..n instead of 0..n-1 */
operator|++
name|current
expr_stmt|;
comment|/* display header if we're here for the first time */
if|if
condition|(
name|current
operator|==
literal|1
condition|)
block|{
name|set_progress_header
argument_list|(
name|gettext
argument_list|(
literal|"Mounting ZFS filesystems"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|!=
name|total
operator|&&
name|last_progress_time
operator|+
name|MOUNT_TIME
operator|>=
name|now
condition|)
block|{
comment|/* too soon to report again */
return|return;
block|}
name|last_progress_time
operator|=
name|now
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|info
argument_list|,
literal|"(%d/%d)"
argument_list|,
name|current
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|total
condition|)
name|finish_progress
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|update_progress
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_options
parameter_list|(
name|char
modifier|*
name|mntopts
parameter_list|,
name|char
modifier|*
name|newopts
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|mntopts
argument_list|)
decl_stmt|;
comment|/* original length plus new string to append plus 1 for the comma */
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|newopts
argument_list|)
operator|>=
name|MNT_LINE_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"the opts argument for "
literal|"'%c' option is too long (more than %d chars)\n"
argument_list|)
argument_list|,
literal|"-o"
argument_list|,
name|MNT_LINE_MAX
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mntopts
condition|)
name|mntopts
index|[
name|len
operator|++
index|]
operator|=
literal|','
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|mntopts
index|[
name|len
index|]
argument_list|,
name|newopts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|share_mount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_MOUNT
condition|?
literal|":avo:O"
else|:
literal|"a"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"empty mount "
literal|"options (-o) specified\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
name|safe_malloc
argument_list|(
name|MNT_LINE_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* option validation is done later */
name|append_options
argument_list|(
name|options
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|flags
operator||=
name|MS_OVERLAY
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|do_all
condition|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|dslist
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|protocol
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nfs"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"smb"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"share type "
literal|"must be 'nfs' or 'smb'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|start_progress_timer
argument_list|()
expr_stmt|;
name|get_all_datasets
argument_list|(
operator|&
name|dslist
argument_list|,
operator|&
name|count
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qsort
argument_list|(
name|dslist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|libzfs_dataset_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|report_mount_progress
argument_list|(
name|i
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|share_mount_one
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
name|B_FALSE
argument_list|,
name|options
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zfs_close
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dslist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|struct
name|mnttab
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|OP_SHARE
operator|)
operator|||
operator|(
name|options
operator|!=
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem "
literal|"argument (specify -a for all)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When mount is given no arguments, go through /etc/mnttab and 		 * display any active ZFS mounts.  We hide any snapshots, since 		 * they are controlled automatically. 		 */
name|rewind
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
while|while
condition|(
name|getmntent
argument_list|(
name|mnttab_file
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|entry
operator|.
name|mnt_special
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s  %s\n"
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|entry
operator|.
name|mnt_mountp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|share_mount_one
argument_list|(
name|zhp
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|B_TRUE
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs mount -a [nfs]  * zfs mount filesystem  *  * Mount all filesystems, or mount the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs share -a [nfs | smb]  * zfs share filesystem  *  * Share all filesystems, or share the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|unshare_unmount_node
block|{
name|zfs_handle_t
modifier|*
name|un_zhp
decl_stmt|;
name|char
modifier|*
name|un_mountp
decl_stmt|;
name|uu_avl_node_t
name|un_avlnode
decl_stmt|;
block|}
name|unshare_unmount_node_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|unshare_unmount_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|unshare_unmount_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|un_mountp
argument_list|,
name|r
operator|->
name|un_mountp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine used by zfs_do_umount() and manual_unmount().  Given an  * absolute path, find the entry /etc/mnttab, verify that its a ZFS filesystem,  * and unmount it appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_path
parameter_list|(
name|int
name|op
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|is_manual
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|struct
name|extmnttab
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
operator|(
name|op
operator|==
name|OP_SHARE
operator|)
condition|?
literal|"unshare"
else|:
literal|"unmount"
decl_stmt|;
name|ino_t
name|path_inode
decl_stmt|;
comment|/* 	 * Search for the path in /etc/mnttab.  Rather than looking for the 	 * specific path, which can be fooled by non-standard paths (i.e. ".." 	 * or "//"), we stat() the path and search for the corresponding 	 * (major,minor) device pair. 	 */
if|if
condition|(
name|stat64
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': %s\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|path_inode
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
comment|/* 	 * Search for the given (major,minor) pair in the mount table. 	 */
name|rewind
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|getextmntent
argument_list|(
name|mnttab_file
argument_list|,
operator|&
name|entry
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|mnt_major
operator|==
name|major
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|)
operator|&&
name|entry
operator|.
name|mnt_minor
operator|==
name|minor
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not "
literal|"currently mounted\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"warning: %s not in mnttab\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|umount2
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s: %s\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not a ZFS "
literal|"filesystem\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stat64
argument_list|(
name|entry
operator|.
name|mnt_mountp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': %s\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|statbuf
operator|.
name|st_ino
operator|!=
name|path_inode
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"%s '%s': not a mountpoint\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
name|char
name|nfs_mnt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|smbshare_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|smbshare_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|smbshare_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshare_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare "
literal|"'%s': legacy share\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare '%s': "
literal|"not currently shared\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unshareall_bypath
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|mtpt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mtpt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|mtpt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_manual
condition|)
block|{
name|ret
operator|=
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|mtpt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unmount "
literal|"'%s': legacy mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use umount(1M) "
literal|"to unmount this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for unsharing or unmounting a filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|nfs_mnt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|sharesmb
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
literal|"a"
else|:
literal|"af"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|do_all
condition|)
block|{
comment|/* 		 * We could make use of zfs_for_each() to walk all datasets in 		 * the system, but this would be very inefficient, especially 		 * since we would have to linearly search /etc/mnttab for each 		 * one.  Instead, do one pass through /etc/mnttab looking for 		 * zfs entries and call zfs_unmount() for each one. 		 * 		 * Things get a little tricky if the administrator has created 		 * mountpoints beneath other ZFS filesystems.  In this case, we 		 * have to unmount the deepest filesystems first.  To accomplish 		 * this, we place all the mountpoints in an AVL tree sorted by 		 * the special type (dataset name), and walk the result in 		 * reverse to make sure to get any snapshots first. 		 */
name|struct
name|mnttab
name|entry
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|tree
init|=
name|NULL
decl_stmt|;
name|unshare_unmount_node_t
modifier|*
name|node
decl_stmt|;
name|uu_avl_index_t
name|idx
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"unmount_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|unshare_unmount_node_t
argument_list|,
name|un_avlnode
argument_list|)
argument_list|,
name|unshare_unmount_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|tree
operator|=
name|uu_avl_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|rewind
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
while|while
condition|(
name|getmntent
argument_list|(
name|mnttab_file
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ignore non-ZFS entries */
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* ignore snapshots */
if|if
condition|(
name|strchr
argument_list|(
name|entry
operator|.
name|mnt_special
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Ignore datasets that are excluded/restricted by 			 * parent pool name. 			 */
if|if
condition|(
name|zpool_skip_pool
argument_list|(
name|zfs_get_pool_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
case|case
name|OP_MOUNT
case|:
comment|/* Ignore legacy mounts */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Ignore canmount=noauto mounts */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
operator|==
name|ZFS_CANMOUNT_NOAUTO
condition|)
continue|continue;
default|default:
break|break;
block|}
name|node
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|un_zhp
operator|=
name|zhp
expr_stmt|;
name|node
operator|->
name|un_mountp
operator|=
name|safe_strdup
argument_list|(
name|entry
operator|.
name|mnt_mountp
argument_list|)
expr_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|un_avlnode
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|uu_avl_insert
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Walk the AVL tree in reverse, unmounting each filesystem and 		 * removing it from the AVL tree in the process. 		 */
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|tree
argument_list|,
name|UU_WALK_REVERSE
operator||
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|tree
argument_list|,
name|node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
if|if
condition|(
name|zfs_unshareall_bypath
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|zfs_unmount
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We have an argument, but it may be a full path or a ZFS 		 * filesystem.  Pass full paths off to unmount_path() (shared by 		 * manual_unmount), otherwise open the filesystem and pass to 		 * zfs_unmount(). 		 */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|op
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
name|ZFS_PROP_SHARENFS
else|:
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|sharesmb
argument_list|,
sizeof|sizeof
argument_list|(
name|sharesmb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sharesmb
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': not currently "
literal|"shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unshareall
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': legacy "
literal|"mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"umount(1M) to unmount this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': not currently "
literal|"mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unmount -a  * zfs unmount filesystem  *  * Unmount all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unshare -a  * zfs unshare filesystem  *  * Unshare all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/mount.  Do the mount if the mountpoint is  * 'legacy'.  Otherwise, complain that use should be using 'zfs mount'.  */
end_comment

begin_function
specifier|static
name|int
name|manual_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|mntopts
index|[
name|MNT_LINE_MAX
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dataset
decl_stmt|,
modifier|*
name|path
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":mo:O"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|mntopts
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|flags
operator||=
name|MS_OVERLAY
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flags
operator||=
name|MS_NOMNTTAB
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: mount [-o opts] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check that we only have two arguments */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing mountpoint argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mount<dataset><mountpoint>\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|dataset
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* try to open the dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|dataset
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* check for legacy mountpoint and complain appropriately */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mount
argument_list|(
name|dataset
argument_list|,
name|path
argument_list|,
name|MS_OPTIONSTR
operator||
name|flags
argument_list|,
name|MNTTYPE_ZFS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mntopts
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mount failed: %s\n"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem '%s' cannot be "
literal|"mounted using 'mount -F zfs'\n"
argument_list|)
argument_list|,
name|dataset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Use 'zfs set mountpoint=%s' "
literal|"instead.\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"If you must use 'mount -F zfs' "
literal|"or /etc/vfstab, use 'zfs set mountpoint=legacy'.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"See zfs(1M) for more "
literal|"information.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/umount.  Unlike a manual mount, we allow  * unmounts of non-legacy filesystems, as this is the dominant administrative  * interface.  */
end_comment

begin_function
specifier|static
name|int
name|manual_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing path "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f]<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|OP_MOUNT
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_command_idx
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_diff
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tosnap
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fromsnap
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"FHt"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'F'
case|:
name|flags
operator||=
name|ZFS_DIFF_CLASSIFY
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|flags
operator||=
name|ZFS_DIFF_PARSEABLE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|ZFS_DIFF_TIMESTAMP
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"must provide at least one snapshot name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fromsnap
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|tosnap
operator|=
operator|(
name|argc
operator|==
literal|2
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|NULL
expr_stmt|;
name|copy
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|fromsnap
operator|!=
literal|'@'
condition|)
name|copy
operator|=
name|strdup
argument_list|(
name|fromsnap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tosnap
condition|)
name|copy
operator|=
name|strdup
argument_list|(
name|tosnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|atp
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|copy
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore SIGPIPE so that the library can give us 	 * information on any failure 	 */
operator|(
name|void
operator|)
name|sigignore
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_show_diffs
argument_list|(
name|zhp
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs bookmark<fs@snap><fs#bmark>  *  * Creates a bookmark with the given name from the given snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_bookmark
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing bookmark argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|'#'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid bookmark name '%s' -- "
literal|"must contain a '#'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* 		 * Snapshot name begins with @. 		 * Default to same fs as bookmark. 		 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|snapname
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|snapname
argument_list|,
literal|'#'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|snapname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|snapname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|snapname
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lzc_bookmark
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|err_msg
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create bookmark '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|EXDEV
case|:
name|err_msg
operator|=
literal|"bookmark is in a different pool"
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|err_msg
operator|=
literal|"bookmark exists"
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|err_msg
operator|=
literal|"invalid argument"
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|err_msg
operator|=
literal|"bookmark feature not enabled"
expr_stmt|;
break|break;
case|case
name|ENOSPC
case|:
name|err_msg
operator|=
literal|"out of space"
expr_stmt|;
break|break;
default|default:
name|err_msg
operator|=
literal|"unknown error"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|errbuf
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
name|err_msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
name|usage
label|:
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TEXT_DOMAIN
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zfs_save_arguments
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|history_str
argument_list|,
sizeof|sizeof
argument_list|(
name|history_str
argument_list|)
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mnttab_file
operator|=
name|fopen
argument_list|(
name|MNTTAB
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: unable to "
literal|"open %s\n"
argument_list|)
argument_list|,
name|MNTTAB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This command also doubles as the /etc/fs mount and unmount program. 	 * Determine if we should take this behavior based on argv[0]. 	 */
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"mount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_mount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_unmount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make sure the user has specified some command. 		 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing command\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cmdname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * The 'umount' command is an alias for 'unmount' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"unmount"
expr_stmt|;
comment|/* 		 * The 'recv' command is an alias for 'receive' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"recv"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"receive"
expr_stmt|;
comment|/* 		 * The 'snap' command is an alias for 'snapshot' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"snap"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"snapshot"
expr_stmt|;
comment|/* 		 * Special case '-?' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * Run the appropriate command. 		 */
name|libzfs_mnttab_cache
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_command_idx
argument_list|(
name|cmdname
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|cmdname
argument_list|,
literal|'='
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|find_command_idx
argument_list|(
literal|"set"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"unrecognized "
literal|"command '%s'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|libzfs_mnttab_cache
argument_list|(
name|g_zfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|log_history
condition|)
operator|(
name|void
operator|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'ZFS_ABORT' environment variable causes us to dump core on exit 	 * for the purposes of running ::findleaks. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

