begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2012 by Frederik Wessels. All rights reserved.  * Copyright (c) 2013 by Prasad Joshi (sTec). All rights reserved.  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>.  * Copyright 2016 Nexenta Systems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<priv.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<zfs_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zpool_util.h"
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_include
include|#
directive|include
file|"zfeature_common.h"
end_include

begin_include
include|#
directive|include
file|"statcommon.h"
end_include

begin_function_decl
specifier|static
name|int
name|zpool_do_create
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_destroy
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_add
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_remove
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_labelclear
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_list
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_iostat
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_status
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_online
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_offline
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_clear
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_reopen
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_reguid
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_attach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_detach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_replace
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_split
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_scrub
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_import
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_export
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_upgrade
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_history
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_get
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_set
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These libumem hooks provide a reasonable set of defaults for the allocator's  * debugging facilities.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|HELP_ADD
block|,
name|HELP_ATTACH
block|,
name|HELP_CLEAR
block|,
name|HELP_CREATE
block|,
name|HELP_DESTROY
block|,
name|HELP_DETACH
block|,
name|HELP_EXPORT
block|,
name|HELP_HISTORY
block|,
name|HELP_IMPORT
block|,
name|HELP_IOSTAT
block|,
name|HELP_LABELCLEAR
block|,
name|HELP_LIST
block|,
name|HELP_OFFLINE
block|,
name|HELP_ONLINE
block|,
name|HELP_REPLACE
block|,
name|HELP_REMOVE
block|,
name|HELP_SCRUB
block|,
name|HELP_STATUS
block|,
name|HELP_UPGRADE
block|,
name|HELP_GET
block|,
name|HELP_SET
block|,
name|HELP_SPLIT
block|,
name|HELP_REGUID
block|,
name|HELP_REOPEN
block|}
name|zpool_help_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zpool_command
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|zpool_help_t
name|usage
decl_stmt|;
block|}
name|zpool_command_t
typedef|;
end_typedef

begin_comment
comment|/*  * Master command table.  Each ZFS command has a name, associated function, and  * usage message.  The usage messages need to be internationalized, so we have  * to have a function to return the usage message based on a command index.  *  * These commands are organized according to how they are displayed in the usage  * message.  An empty command (one with a NULL name) indicates an empty line in  * the generic usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|zpool_command_t
name|command_table
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|zpool_do_create
block|,
name|HELP_CREATE
block|}
block|,
block|{
literal|"destroy"
block|,
name|zpool_do_destroy
block|,
name|HELP_DESTROY
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"add"
block|,
name|zpool_do_add
block|,
name|HELP_ADD
block|}
block|,
block|{
literal|"remove"
block|,
name|zpool_do_remove
block|,
name|HELP_REMOVE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"labelclear"
block|,
name|zpool_do_labelclear
block|,
name|HELP_LABELCLEAR
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"list"
block|,
name|zpool_do_list
block|,
name|HELP_LIST
block|}
block|,
block|{
literal|"iostat"
block|,
name|zpool_do_iostat
block|,
name|HELP_IOSTAT
block|}
block|,
block|{
literal|"status"
block|,
name|zpool_do_status
block|,
name|HELP_STATUS
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"online"
block|,
name|zpool_do_online
block|,
name|HELP_ONLINE
block|}
block|,
block|{
literal|"offline"
block|,
name|zpool_do_offline
block|,
name|HELP_OFFLINE
block|}
block|,
block|{
literal|"clear"
block|,
name|zpool_do_clear
block|,
name|HELP_CLEAR
block|}
block|,
block|{
literal|"reopen"
block|,
name|zpool_do_reopen
block|,
name|HELP_REOPEN
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"attach"
block|,
name|zpool_do_attach
block|,
name|HELP_ATTACH
block|}
block|,
block|{
literal|"detach"
block|,
name|zpool_do_detach
block|,
name|HELP_DETACH
block|}
block|,
block|{
literal|"replace"
block|,
name|zpool_do_replace
block|,
name|HELP_REPLACE
block|}
block|,
block|{
literal|"split"
block|,
name|zpool_do_split
block|,
name|HELP_SPLIT
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"scrub"
block|,
name|zpool_do_scrub
block|,
name|HELP_SCRUB
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"import"
block|,
name|zpool_do_import
block|,
name|HELP_IMPORT
block|}
block|,
block|{
literal|"export"
block|,
name|zpool_do_export
block|,
name|HELP_EXPORT
block|}
block|,
block|{
literal|"upgrade"
block|,
name|zpool_do_upgrade
block|,
name|HELP_UPGRADE
block|}
block|,
block|{
literal|"reguid"
block|,
name|zpool_do_reguid
block|,
name|HELP_REGUID
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"history"
block|,
name|zpool_do_history
block|,
name|HELP_HISTORY
block|}
block|,
block|{
literal|"get"
block|,
name|zpool_do_get
block|,
name|HELP_GET
block|}
block|,
block|{
literal|"set"
block|,
name|zpool_do_set
block|,
name|HELP_SET
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOMMAND
value|(sizeof (command_table) / sizeof (command_table[0]))
end_define

begin_decl_stmt
specifier|static
name|zpool_command_t
modifier|*
name|current_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|history_str
index|[
name|HIS_MAX_RECORD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|log_history
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|timestamp_fmt
init|=
name|NODATE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_usage
parameter_list|(
name|zpool_help_t
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|HELP_ADD
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tadd [-fn]<pool><vdev> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ATTACH
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tattach [-f]<pool><device> "
literal|"<new-device>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CLEAR
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tclear [-nF]<pool> [device]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CREATE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tcreate [-fnd] [-B] "
literal|"[-o property=value] ... \n"
literal|"\t    [-O file-system-property=value] ... \n"
literal|"\t    [-m mountpoint] [-R root]<pool><vdev> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DESTROY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdestroy [-f]<pool>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DETACH
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdetach<pool><device>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_EXPORT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\texport [-f]<pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_HISTORY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\thistory [-il] [<pool>] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_IMPORT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\timport [-d dir] [-D]\n"
literal|"\timport [-d dir | -c cachefile] [-F [-n]]<pool | id>\n"
literal|"\timport [-o mntopts] [-o property=value] ... \n"
literal|"\t    [-d dir | -c cachefile] [-D] [-f] [-m] [-N] "
literal|"[-R root] [-F [-n]] -a\n"
literal|"\timport [-o mntopts] [-o property=value] ... \n"
literal|"\t    [-d dir | -c cachefile] [-D] [-f] [-m] [-N] "
literal|"[-R root] [-F [-n]]\n"
literal|"\t<pool | id> [newpool]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_IOSTAT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tiostat [-v] [-T d|u] [pool] ... [interval "
literal|"[count]]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LABELCLEAR
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlabelclear [-f]<vdev>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LIST
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlist [-Hp] [-o property[,...]] "
literal|"[-T d|u] [pool] ... [interval [count]]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_OFFLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\toffline [-t]<pool><device> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ONLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tonline<pool><device> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REPLACE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treplace [-f]<pool><device> "
literal|"[new-device]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REMOVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tremove<pool><device> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REOPEN
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treopen<pool>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SCRUB
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tscrub [-s]<pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_STATUS
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tstatus [-vx] [-T d|u] [pool] ... [interval "
literal|"[count]]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UPGRADE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tupgrade\n"
literal|"\tupgrade -v\n"
literal|"\tupgrade [-V version]<-a | pool ...>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tget [-Hp] [-o \"all\" | field[,...]] "
literal|"<\"all\" | property[,...]><pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tset<property=value><pool> \n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SPLIT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsplit [-n] [-R altroot] [-o mntopts]\n"
literal|"\t    [-o property=value]<pool><newpool> "
literal|"[<device> ...]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REGUID
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treguid<pool>\n"
argument_list|)
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Callback routine that will print out a pool property value.  */
end_comment

begin_function
specifier|static
name|int
name|print_prop_cb
parameter_list|(
name|int
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|cb
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s  "
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  NO   "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" YES   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_prop_values
argument_list|(
name|prop
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|zpool_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZPROP_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage message.  If we're inside a command, display only the usage for  * that command.  Otherwise, iterate over the entire command table and display  * a complete usage message.  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|current_command
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage: zpool command args ...\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"where 'command' is one of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|current_command
operator|->
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nthe following properties are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%-15s  %s   %s\n\n"
argument_list|,
literal|"PROPERTY"
argument_list|,
literal|"EDIT"
argument_list|,
literal|"VALUES"
argument_list|)
expr_stmt|;
comment|/* Iterate over all properties */
operator|(
name|void
operator|)
name|zprop_iter
argument_list|(
name|print_prop_cb
argument_list|,
name|fp
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s   "
argument_list|,
literal|"feature@..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"YES   disabled | enabled | active\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe feature@ properties must be "
literal|"appended with a feature name.\nSee zpool-features(5).\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See comments at end of main(). 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_vdev_tree
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|indent
parameter_list|,
name|boolean_t
name|print_logs
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|is_log
init|=
name|B_FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_log
operator|&&
operator|!
name|print_logs
operator|)
operator|||
operator|(
operator|!
name|is_log
operator|&&
name|print_logs
operator|)
condition|)
continue|continue;
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|prop_list_contains_feature
parameter_list|(
name|nvlist_t
modifier|*
name|proplist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|proplist
argument_list|,
name|NULL
argument_list|)
init|;
name|NULL
operator|!=
name|nvp
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|proplist
argument_list|,
name|nvp
argument_list|)
control|)
block|{
if|if
condition|(
name|zpool_prop_feature
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a property pair (name, string-value) into a property nvlist.  */
end_comment

begin_function
specifier|static
name|int
name|add_prop_list
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|char
modifier|*
name|propval
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|props
parameter_list|,
name|boolean_t
name|poolprop
parameter_list|)
block|{
name|zpool_prop_t
name|prop
init|=
name|ZPROP_INVAL
decl_stmt|;
name|zfs_prop_t
name|fprop
decl_stmt|;
name|nvlist_t
modifier|*
name|proplist
decl_stmt|;
specifier|const
name|char
modifier|*
name|normnm
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
operator|*
name|props
operator|==
name|NULL
operator|&&
name|nvlist_alloc
argument_list|(
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|proplist
operator|=
operator|*
name|props
expr_stmt|;
if|if
condition|(
name|poolprop
condition|)
block|{
specifier|const
name|char
modifier|*
name|vname
init|=
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
operator|&&
operator|!
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property '%s' is "
literal|"not a valid pool property\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* 		 * feature@ properties and version should not be specified 		 * at the same time. 		 */
if|if
condition|(
operator|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
operator|&&
name|nvlist_exists
argument_list|(
name|proplist
argument_list|,
name|vname
argument_list|)
operator|)
operator|||
operator|(
name|prop
operator|==
name|ZPOOL_PROP_VERSION
operator|&&
name|prop_list_contains_feature
argument_list|(
name|proplist
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'feature@' and "
literal|"'version' properties cannot be specified "
literal|"together\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
condition|)
name|normnm
operator|=
name|propname
expr_stmt|;
else|else
name|normnm
operator|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fprop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|!=
name|ZPROP_INVAL
condition|)
block|{
name|normnm
operator|=
name|zfs_prop_to_name
argument_list|(
name|fprop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normnm
operator|=
name|propname
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|proplist
argument_list|,
name|normnm
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
operator|&&
name|prop
operator|!=
name|ZPOOL_PROP_CACHEFILE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property '%s' "
literal|"specified multiple times\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|proplist
argument_list|,
name|normnm
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool add [-fn]<pool><vdev> ...  *  *	-f	Force addition of devices, even if they appear in use  *	-n	Do not add the devices, but display the resulting layout if  *		they were to be added.  *  * Adds the given vdevs to 'pool'.  As with create, the bulk of this work is  * handled by get_vdev_spec(), which constructs the nvlist needed to pass to  * libzfs.  */
end_comment

begin_function
name|int
name|zpool_do_add
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_boot_label_t
name|boot_type
decl_stmt|;
name|uint64_t
name|boot_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fn"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing vdev specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool '%s' is unavailable\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_is_bootable
argument_list|(
name|zhp
argument_list|)
condition|)
name|boot_type
operator|=
name|ZPOOL_COPY_BOOT_LABEL
expr_stmt|;
else|else
name|boot_type
operator|=
name|ZPOOL_NO_BOOT_LABEL
expr_stmt|;
comment|/* pass off to get_vdev_spec for processing */
name|boot_size
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_BOOTSIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|,
operator|!
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|dryrun
argument_list|,
name|boot_type
argument_list|,
name|boot_size
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dryrun
condition|)
block|{
name|nvlist_t
modifier|*
name|poolnvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|poolnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would update '%s' to the following "
literal|"configuration:\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* print original main pool and new tree */
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|poolname
argument_list|,
name|poolnvroot
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* Do the same for the logs */
if|if
condition|(
name|num_logs
argument_list|(
name|poolnvroot
argument_list|)
operator|>
literal|0
condition|)
block|{
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
literal|"logs"
argument_list|,
name|poolnvroot
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_logs
argument_list|(
name|nvroot
argument_list|)
operator|>
literal|0
condition|)
block|{
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
literal|"logs"
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
name|zpool_add
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool remove<pool><vdev> ...  *  * Removes the given vdev from the pool.  Currently, this supports removing  * spares, cache, and log devices from the pool.  */
end_comment

begin_function
name|int
name|zpool_do_remove
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|poolname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zpool_vdev_remove
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool labelclear [-f]<vdev>  *  *	-f	Force clearing the label for the vdevs which are members of  *		the exported or foreign pools.  *  * Verifies that the vdev is not active and zeros out the label information  * on the device.  */
end_comment

begin_function
name|int
name|zpool_do_labelclear
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|vdev
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|pool_state_t
name|state
decl_stmt|;
name|boolean_t
name|inuse
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get vdev name */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing vdev name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if we were given absolute path and use it as is. 	 * Otherwise if the provided vdev name doesn't point to a file, 	 * try prepending dsk path and appending s0. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|vdev
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|stat
argument_list|(
name|vdev
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|vdev
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZFS_DISK_ROOT
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|vdev
argument_list|,
literal|"s0"
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|vdev
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"failed to find device %s, try specifying absolute "
literal|"path instead\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|vdev
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"failed to open %s: %s\n"
argument_list|)
argument_list|,
name|vdev
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|config
argument_list|)
operator|!=
literal|0
operator|||
name|config
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"failed to read label from %s\n"
argument_list|)
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zpool_in_use
argument_list|(
name|g_zfs
argument_list|,
name|fd
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|inuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"failed to check state for %s\n"
argument_list|)
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|inuse
condition|)
goto|goto
name|wipe_label
goto|;
switch|switch
condition|(
name|state
condition|)
block|{
default|default:
case|case
name|POOL_STATE_ACTIVE
case|:
case|case
name|POOL_STATE_SPARE
case|:
case|case
name|POOL_STATE_L2CACHE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s is a member (%s) of pool \"%s\"\n"
argument_list|)
argument_list|,
name|vdev
argument_list|,
name|zpool_pool_state_to_name
argument_list|(
name|state
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|errout
goto|;
case|case
name|POOL_STATE_EXPORTED
case|:
if|if
condition|(
name|force
condition|)
break|break;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to override the following error:\n"
literal|"%s is a member of exported pool \"%s\"\n"
argument_list|)
argument_list|,
name|vdev
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|errout
goto|;
case|case
name|POOL_STATE_POTENTIALLY_ACTIVE
case|:
if|if
condition|(
name|force
condition|)
break|break;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to override the following error:\n"
literal|"%s is a member of potentially active pool \"%s\"\n"
argument_list|)
argument_list|,
name|vdev
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|errout
goto|;
case|case
name|POOL_STATE_DESTROYED
case|:
comment|/* inuse should never be set for a destroyed pool */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|wipe_label
label|:
name|ret
operator|=
name|zpool_clear_label
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"failed to clear label for %s\n"
argument_list|)
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
block|}
name|errout
label|:
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool create [-fnd] [-B] [-o property=value] ...  *		[-O file-system-property=value] ...  *		[-R root] [-m mountpoint]<pool><dev> ...  *  *	-B	Create boot partition.  *	-f	Force creation, even if devices appear in use  *	-n	Do not create the pool, but display the resulting layout if it  *		were to be created.  *      -R	Create a pool under an alternate root  *      -m	Set default mountpoint for the root dataset.  By default it's  *		'/<pool>'  *	-o	Set property=value.  *	-d	Don't automatically enable all supported pool features  *		(individual features can be enabled with -o).  *	-O	Set fsproperty=value in the pool's root file system  *  * Creates the named pool according to the given vdev specification.  The  * bulk of the vdev processing is done in get_vdev_spec() in zpool_vdev.c.  Once  * we get the nvlist back from get_vdev_spec(), we either print out the contents  * (if '-n' was specified), or pass it to libzfs to do the creation.  */
end_comment

begin_define
define|#
directive|define
name|SYSTEM256
value|(256 * 1024 * 1024)
end_define

begin_function
name|int
name|zpool_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|enable_all_pool_feat
init|=
name|B_TRUE
decl_stmt|;
name|zpool_boot_label_t
name|boot_type
init|=
name|ZPOOL_NO_BOOT_LABEL
decl_stmt|;
name|uint64_t
name|boot_size
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mountpoint
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|fsprops
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|propval
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":fndBR:m:o:O:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|enable_all_pool_feat
operator|=
name|B_FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* 			 * We should create the system partition. 			 * Also make sure the size is set. 			 */
name|boot_type
operator|=
name|ZPOOL_CREATE_BOOT_LABEL
expr_stmt|;
if|if
condition|(
name|boot_size
operator|==
literal|0
condition|)
name|boot_size
operator|=
name|SYSTEM256
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|altroot
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|add_prop_list
argument_list|(
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|errout
goto|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|add_prop_list
argument_list|(
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
literal|"none"
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|errout
goto|;
break|break;
case|case
literal|'m'
case|:
comment|/* Equivalent to -O mountpoint=optarg */
name|mountpoint
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing "
literal|"'=' for -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|add_prop_list
argument_list|(
name|optarg
argument_list|,
name|propval
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|errout
goto|;
comment|/* 			 * Get bootsize value for make_root_vdev(). 			 */
if|if
condition|(
name|zpool_name_to_prop
argument_list|(
name|optarg
argument_list|)
operator|==
name|ZPOOL_PROP_BOOTSIZE
condition|)
block|{
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|propval
argument_list|,
operator|&
name|boot_size
argument_list|)
operator|<
literal|0
operator|||
name|boot_size
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad boot partition size "
literal|"'%s': %s\n"
argument_list|)
argument_list|,
name|propval
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
comment|/* 			 * If the user is creating a pool that doesn't support 			 * feature flags, don't enable any features. 			 */
if|if
condition|(
name|zpool_name_to_prop
argument_list|(
name|optarg
argument_list|)
operator|==
name|ZPOOL_PROP_VERSION
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|u_longlong_t
name|ver
decl_stmt|;
name|ver
operator|=
name|strtoull
argument_list|(
name|propval
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|ver
operator|<
name|SPA_VERSION_FEATURES
condition|)
block|{
name|enable_all_pool_feat
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zpool_name_to_prop
argument_list|(
name|optarg
argument_list|)
operator|==
name|ZPOOL_PROP_ALTROOT
condition|)
name|altroot
operator|=
name|propval
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing "
literal|"'=' for -O option\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
comment|/* 			 * Mountpoints are checked and then added later. 			 * Uniquely among properties, they can be specified 			 * more than once, to avoid conflict with -m. 			 */
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MOUNTPOINT
argument_list|)
argument_list|)
condition|)
block|{
name|mountpoint
operator|=
name|propval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_prop_list
argument_list|(
name|optarg
argument_list|,
name|propval
argument_list|,
operator|&
name|fsprops
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
goto|goto
name|errout
goto|;
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing vdev specification\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * As a special case, check for use of '/' in the name, and direct the 	 * user to use 'zfs create' instead. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|poolname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot create '%s': invalid "
literal|"character '/' in pool name\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs create' to "
literal|"create a dataset\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
comment|/* 	 * Make sure the bootsize is set when ZPOOL_CREATE_BOOT_LABEL is used, 	 * and not set otherwise. 	 */
if|if
condition|(
name|boot_type
operator|==
name|ZPOOL_CREATE_BOOT_LABEL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|char
modifier|*
name|strptr
decl_stmt|,
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|propname
operator|=
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
operator|&
name|strptr
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|asprintf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%"
name|PRIu64
argument_list|,
name|boot_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|rv
operator|=
name|add_prop_list
argument_list|(
name|propname
argument_list|,
name|buf
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|char
modifier|*
name|strptr
decl_stmt|;
name|propname
operator|=
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
operator|&
name|strptr
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"error: setting boot "
literal|"partition size requires option '-B'\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
comment|/* pass off to get_vdev_spec for bulk processing */
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|NULL
argument_list|,
name|force
argument_list|,
operator|!
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|dryrun
argument_list|,
name|boot_type
argument_list|,
name|boot_size
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
goto|goto
name|errout
goto|;
comment|/* make_root_vdev() allows 0 toplevel children if there are spares */
if|if
condition|(
operator|!
name|zfs_allocatable_devs
argument_list|(
name|nvroot
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: at least one toplevel vdev must be "
literal|"specified\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|altroot
operator|!=
name|NULL
operator|&&
name|altroot
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid alternate root '%s': "
literal|"must be an absolute path\n"
argument_list|)
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
comment|/* 	 * Check the validity of the mountpoint and direct the user to use the 	 * '-m' mountpoint option if it looks like its in use. 	 */
if|if
condition|(
name|mountpoint
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_NONE
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
if|if
condition|(
name|mountpoint
operator|&&
name|mountpoint
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid mountpoint "
literal|"'%s': must be an absolute path, 'legacy', or "
literal|"'none'\n"
argument_list|)
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|mountpoint
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|altroot
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/%s"
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|altroot
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mountpoint '%s' : "
literal|"%s\n"
argument_list|)
argument_list|,
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-m' "
literal|"option to provide a different default\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
elseif|else
if|if
condition|(
name|dirp
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
literal|3
operator|&&
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|!=
name|NULL
condition|)
name|count
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mountpoint "
literal|"'%s' exists and is not empty\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-m' "
literal|"option to provide a "
literal|"different default\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
block|}
comment|/* 	 * Now that the mountpoint's validity has been checked, ensure that 	 * the property is set appropriately prior to creating the pool. 	 */
if|if
condition|(
name|mountpoint
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|add_prop_list
argument_list|(
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MOUNTPOINT
argument_list|)
argument_list|,
name|mountpoint
argument_list|,
operator|&
name|fsprops
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dryrun
condition|)
block|{
comment|/* 		 * For a dry run invocation, print out a basic message and run 		 * through all the vdevs in the list and print out in an 		 * appropriate hierarchy. 		 */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would create '%s' with the "
literal|"following layout:\n\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|NULL
argument_list|,
name|poolname
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_logs
argument_list|(
name|nvroot
argument_list|)
operator|>
literal|0
condition|)
name|print_vdev_tree
argument_list|(
name|NULL
argument_list|,
literal|"logs"
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Hand off to libzfs. 		 */
if|if
condition|(
name|enable_all_pool_feat
condition|)
block|{
name|spa_feature_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|char
name|propname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|zfeature_info_t
modifier|*
name|feat
init|=
operator|&
name|spa_feature_table
index|[
name|i
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|propname
argument_list|)
argument_list|,
literal|"feature@%s"
argument_list|,
name|feat
operator|->
name|fi_uname
argument_list|)
expr_stmt|;
comment|/* 				 * Skip feature if user specified it manually 				 * on the command line. 				 */
if|if
condition|(
name|nvlist_exists
argument_list|(
name|props
argument_list|,
name|propname
argument_list|)
condition|)
continue|continue;
name|ret
operator|=
name|add_prop_list
argument_list|(
name|propname
argument_list|,
name|ZFS_FEATURE_ENABLED
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zpool_create
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|,
name|nvroot
argument_list|,
name|props
argument_list|,
name|fsprops
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|pool
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zfs_mount
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|zfs_shareall
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|libzfs_errno
argument_list|(
name|g_zfs
argument_list|)
operator|==
name|EZFS_INVALIDNAME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool name may have "
literal|"been omitted\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|errout
label|:
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fsprops
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|badusage
label|:
name|nvlist_free
argument_list|(
name|fsprops
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool destroy<pool>  *  * 	-f	Forcefully unmount any datasets  *  * Destroy the given pool.  Automatically unmounts any datasets in the pool.  */
end_comment

begin_function
name|int
name|zpool_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|pool
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|pool
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * As a special case, check for use of '/' in the name, and 		 * direct the user to use 'zfs destroy' instead. 		 */
if|if
condition|(
name|strchr
argument_list|(
name|pool
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs destroy' to "
literal|"destroy a dataset\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_disable_datasets
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"could not destroy '%s': "
literal|"could not unmount datasets\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* The history must be logged as part of the export */
name|log_history
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
operator|(
name|zpool_destroy
argument_list|(
name|zhp
argument_list|,
name|history_str
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool export [-f]<pool> ...  *  *	-f	Forcefully unmount datasets  *  * Export the given pools.  By default, the command will attempt to cleanly  * unmount any active datasets within the pool.  If the '-f' flag is specified,  * then the datasets will be forcefully unmounted.  */
end_comment

begin_function
name|int
name|zpool_do_export
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|hardforce
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fF"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|hardforce
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zpool_disable_datasets
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The history must be logged as part of the export */
name|log_history
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|hardforce
condition|)
block|{
if|if
condition|(
name|zpool_export_force
argument_list|(
name|zhp
argument_list|,
name|history_str
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zpool_export
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|,
name|history_str
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a vdev configuration, determine the maximum width needed for the device  * name column.  */
end_comment

begin_function
specifier|static
name|int
name|max_width
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|nv
argument_list|,
name|B_TRUE
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
operator|>
name|max
condition|)
name|max
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|max
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|max
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|max
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|ret
expr_stmt|;
block|}
return|return
operator|(
name|max
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|spare_cbdata
block|{
name|uint64_t
name|cb_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|cb_zhp
decl_stmt|;
block|}
name|spare_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|boolean_t
name|find_vdev
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|uint64_t
name|search
parameter_list|)
block|{
name|uint64_t
name|guid
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
operator|&&
name|search
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_vdev
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_spare
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|spare_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_vdev
argument_list|(
name|nvroot
argument_list|,
name|cbp
operator|->
name|cb_guid
argument_list|)
condition|)
block|{
name|cbp
operator|->
name|cb_zhp
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out configuration state as requested by status_callback.  */
end_comment

begin_function
name|void
name|print_status_config
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|namewidth
parameter_list|,
name|int
name|depth
parameter_list|,
name|boolean_t
name|isspare
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|pool_scan_stat_t
modifier|*
name|ps
init|=
name|NULL
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
name|rbuf
index|[
literal|6
index|]
decl_stmt|,
name|wbuf
index|[
literal|6
index|]
decl_stmt|,
name|cbuf
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|uint64_t
name|notpresent
decl_stmt|;
name|spare_cbdata_t
name|cb
decl_stmt|;
specifier|const
name|char
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
name|children
operator|=
literal|0
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|state
operator|=
name|zpool_state_to_name
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspare
condition|)
block|{
comment|/* 		 * For hot spares, we use the terms 'INUSE' and 'AVAILABLE' for 		 * online drives. 		 */
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_SPARED
condition|)
name|state
operator|=
literal|"INUSE"
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
name|state
operator|=
literal|"AVAIL"
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%-*s  %-8s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|namewidth
operator|-
name|depth
argument_list|,
name|name
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspare
condition|)
block|{
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_read_errors
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_write_errors
argument_list|,
name|wbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_checksum_errors
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %5s %5s %5s"
argument_list|,
name|rbuf
argument_list|,
name|wbuf
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|notpresent
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  was %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vs
operator|->
name|vs_aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"cannot open"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"missing device"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"insufficient replicas"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"newer version"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_UNSUP_FEAT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"unsupported feature(s)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_SPARED
case|:
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|cb
operator|.
name|cb_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|find_spare
argument_list|,
operator|&
name|cb
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"currently in "
literal|"use"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"in use by "
literal|"pool '%s'"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"currently in use"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VDEV_AUX_ERR_EXCEEDED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"too many errors"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_IO_FAILURE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"experienced I/O failures"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_LOG
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"bad intent log"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_EXTERNAL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"external device fault"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_SPLIT_POOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"split into new pool"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"corrupted data"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SCAN_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ps
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
name|ps
operator|->
name|pss_state
operator|==
name|DSS_SCANNING
operator|&&
name|vs
operator|->
name|vs_scan_processed
operator|!=
literal|0
operator|&&
name|children
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  (%s)"
argument_list|)
argument_list|,
operator|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
operator|)
condition|?
literal|"resilvering"
else|:
literal|"repairing"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|islog
init|=
name|B_FALSE
decl_stmt|,
name|ishole
init|=
name|B_FALSE
decl_stmt|;
comment|/* Don't print logs or holes here */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
operator|&
name|ishole
argument_list|)
expr_stmt|;
if|if
condition|(
name|islog
operator|||
name|ishole
condition|)
continue|continue;
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|isspare
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the configuration of an exported pool.  Iterate over all vdevs in the  * pool, printing out the name and status for each one.  */
end_comment

begin_function
name|void
name|print_import_config
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|namewidth
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|vname
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_HOLE
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%-*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|namewidth
operator|-
name|depth
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %s"
argument_list|,
name|zpool_state_to_name
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vs
operator|->
name|vs_aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"cannot open"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"missing device"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"insufficient replicas"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"newer version"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_UNSUP_FEAT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"unsupported feature(s)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_ERR_EXCEEDED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"too many errors"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"corrupted data"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|is_log
init|=
name|B_FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_log
condition|)
continue|continue;
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|print_import_config
argument_list|(
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tcache\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t  %s\n"
argument_list|,
name|vname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tspares\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t  %s\n"
argument_list|,
name|vname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print log vdevs.  * Logs are recorded as top level vdevs in the main pool child array  * but with "is_log" set to 1. We use either print_status_config() or  * print_import_config() to print the top level logs then any log  * children (eg mirrored slogs) are printed recursively - which  * works because only the top level vdev is marked "is_log"  */
end_comment

begin_function
specifier|static
name|void
name|print_logs
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|namewidth
parameter_list|,
name|boolean_t
name|verbose
parameter_list|)
block|{
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tlogs\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|is_log
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_log
condition|)
continue|continue;
name|name
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|name
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
literal|2
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
else|else
name|print_import_config
argument_list|(
name|name
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display the status for the given pool.  */
end_comment

begin_function
specifier|static
name|void
name|show_import
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|uint64_t
name|pool_state
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|int
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|health
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|int
name|namewidth
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|pool_state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|health
operator|=
name|zpool_state_to_name
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
expr_stmt|;
name|reason
operator|=
name|zpool_import_status
argument_list|(
name|config
argument_list|,
operator|&
name|msgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"   pool: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"     id: %llu\n"
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  state: %s"
argument_list|)
argument_list|,
name|health
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" (DESTROYED)"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
case|case
name|ZPOOL_STATUS_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: One or more devices are "
literal|"missing from the system.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_R
case|:
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: One or more devices contains "
literal|"corrupted data.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_DATA
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: The pool data is corrupted.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_OFFLINE_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: One or more devices "
literal|"are offlined.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_POOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: The pool metadata is "
literal|"corrupted.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_OLDER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: The pool is formatted using a "
literal|"legacy on-disk version.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: The pool is formatted using an "
literal|"incompatible version.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FEAT_DISABLED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: Some supported features are "
literal|"not enabled on the pool.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_READ
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool uses the following "
literal|"feature(s) not supported on this sytem:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_print_unsup_feat
argument_list|(
name|config
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_WRITE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool can only be accessed "
literal|"in read-only mode on this system. It\n\tcannot be "
literal|"accessed in read-write mode because it uses the "
literal|"following\n\tfeature(s) not supported on this system:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_print_unsup_feat
argument_list|(
name|config
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_HOSTID_MISMATCH
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: The pool was last accessed by "
literal|"another system.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FAULTED_DEV_R
case|:
case|case
name|ZPOOL_STATUS_FAULTED_DEV_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: One or more devices are "
literal|"faulted.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_BAD_LOG
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: An intent log record cannot be "
literal|"read.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_RESILVERING
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" status: One or more devices were being "
literal|"resilvered.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * No other status can be seen when importing pools. 		 */
name|assert
argument_list|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Print out an action according to the overall state of the pool. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_VERSION_OLDER
operator|||
name|reason
operator|==
name|ZPOOL_STATUS_FEAT_DISABLED
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool can be "
literal|"imported using its name or numeric identifier, "
literal|"though\n\tsome features will not be available "
literal|"without an explicit 'zpool upgrade'.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_HOSTID_MISMATCH
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool can be "
literal|"imported using its name or numeric "
literal|"identifier and\n\tthe '-f' flag.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool can be "
literal|"imported using its name or numeric "
literal|"identifier.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_DEGRADED
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool can be imported "
literal|"despite missing or damaged devices.  The\n\tfault "
literal|"tolerance of the pool may be compromised if imported.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool cannot be "
literal|"imported.  Access the pool on a system running "
literal|"newer\n\tsoftware, or recreate the pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_READ
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be "
literal|"imported. Access the pool on a system that "
literal|"supports\n\tthe required feature(s), or recreate "
literal|"the pool from backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_WRITE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be "
literal|"imported in read-write mode. Import the pool "
literal|"with\n"
literal|"\t\"-o readonly=on\", access the pool on a system "
literal|"that supports the\n\trequired feature(s), or "
literal|"recreate the pool from backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
case|case
name|ZPOOL_STATUS_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool cannot be "
literal|"imported. Attach the missing\n\tdevices and try "
literal|"again.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" action: The pool cannot be "
literal|"imported due to damaged devices or data.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print the comment attached to the pool. */
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_COMMENT
argument_list|,
operator|&
name|comment
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"comment: %s\n"
argument_list|)
argument_list|,
name|comment
argument_list|)
expr_stmt|;
comment|/* 	 * If the state is "closed" or "can't open", and the aux state 	 * is "corrupt data": 	 */
if|if
condition|(
operator|(
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CLOSED
operator|)
operator|||
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|)
operator|)
operator|&&
operator|(
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
operator|)
condition|)
block|{
if|if
condition|(
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tThe pool was destroyed, "
literal|"but can be imported using the '-Df' flags.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pool_state
operator|!=
name|POOL_STATE_EXPORTED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tThe pool may be active on "
literal|"another system, but can be imported using\n\t"
literal|"the '-f' flag.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"   see: http://illumos.org/msg/%s\n"
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" config:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|namewidth
operator|=
name|max_width
argument_list|(
name|NULL
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namewidth
operator|<
literal|10
condition|)
name|namewidth
operator|=
literal|10
expr_stmt|;
name|print_import_config
argument_list|(
name|name
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_logs
argument_list|(
name|nvroot
argument_list|)
operator|>
literal|0
condition|)
name|print_logs
argument_list|(
name|NULL
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_BAD_GUID_SUM
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\n\tAdditional devices are known to "
literal|"be part of this pool, though their\n\texact "
literal|"configuration cannot be determined.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform the import for the given configuration.  This passes the heavy  * lifting off to zpool_import_props(), and then mounts the datasets contained  * within the pool.  */
end_comment

begin_function
specifier|static
name|int
name|do_import
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
specifier|const
name|char
modifier|*
name|mntopts
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': pool "
literal|"is formatted using an unsupported ZFS version\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_EXPORTED
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ZFS_IMPORT_ANY_HOST
operator|)
condition|)
block|{
name|uint64_t
name|hostid
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|gethostid
argument_list|()
condition|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|uint64_t
name|timestamp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TIMESTAMP
argument_list|,
operator|&
name|timestamp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|timestamp
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import "
literal|"'%s': pool may be in use from other "
literal|"system, it was last accessed by %s "
literal|"(hostid: 0x%lx) on %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|hostname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hostid
argument_list|,
name|asctime
argument_list|(
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to "
literal|"import anyway\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"pool may be in use from other system\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to import "
literal|"anyway\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zpool_import_props
argument_list|(
name|g_zfs
argument_list|,
name|config
argument_list|,
name|newname
argument_list|,
name|props
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|newname
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|!=
name|POOL_STATE_UNAVAIL
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ZFS_IMPORT_ONLY
operator|)
operator|&&
name|zpool_enable_datasets
argument_list|(
name|zhp
argument_list|,
name|mntopts
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool import [-d dir] [-D]  *       import [-o mntopts] [-o prop=value] ... [-R root] [-D]  *              [-d dir | -c cachefile] [-f] -a  *       import [-o mntopts] [-o prop=value] ... [-R root] [-D]  *              [-d dir | -c cachefile] [-f] [-n] [-F]<pool | id> [newpool]  *  *	 -c	Read pool information from a cachefile instead of searching  *		devices.  *  *       -d	Scan in a specific directory, other than /dev/dsk.  More than  *		one directory can be specified using multiple '-d' options.  *  *       -D     Scan for previously destroyed pools or import all or only  *              specified destroyed pools.  *  *       -R	Temporarily import the pool, with all mountpoints relative to  *		the given root.  The pool will remain exported when the machine  *		is rebooted.  *  *       -V	Import even in the presence of faulted vdevs.  This is an  *       	intentionally undocumented option for testing purposes, and  *       	treats the pool configuration as complete, leaving any bad  *		vdevs in the FAULTED state. In other words, it does verbatim  *		import.  *  *       -f	Force import, even if it appears that the pool is active.  *  *       -F     Attempt rewind if necessary.  *  *       -n     See if rewind would work, but don't actually rewind.  *  *       -N     Import the pool but don't mount datasets.  *  *       -T     Specify a starting txg to use for import. This option is  *       	intentionally undocumented option for testing purposes.  *  *       -a	Import all pools found.  *  *       -o	Set property=value and/or temporary mount options (without '=').  *  * The import command scans for pools to import, and import pools based on pool  * name and GUID.  The pool can also be renamed as part of the import process.  */
end_comment

begin_function
name|int
name|zpool_do_import
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|searchdirs
init|=
name|NULL
decl_stmt|;
name|int
name|nsearch
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|pools
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|do_all
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_destroyed
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|mntopts
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|searchguid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|searchname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|propval
decl_stmt|;
name|nvlist_t
modifier|*
name|found_config
decl_stmt|;
name|nvlist_t
modifier|*
name|policy
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|first
decl_stmt|;
name|int
name|flags
init|=
name|ZFS_IMPORT_NORMAL
decl_stmt|;
name|uint32_t
name|rewind_policy
init|=
name|ZPOOL_NO_REWIND
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_rewind
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|xtreme_rewind
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|pool_state
decl_stmt|,
name|txg
init|=
operator|-
literal|1ULL
decl_stmt|;
name|char
modifier|*
name|cachefile
init|=
name|NULL
decl_stmt|;
name|importargs_t
name|idata
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":aCc:d:DEfFmnNo:rR:T:VX"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cachefile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|searchdirs
operator|==
name|NULL
condition|)
block|{
name|searchdirs
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|tmp
init|=
name|safe_malloc
argument_list|(
operator|(
name|nsearch
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|searchdirs
argument_list|,
name|tmp
argument_list|,
name|nsearch
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
name|searchdirs
operator|=
name|tmp
expr_stmt|;
block|}
name|searchdirs
index|[
name|nsearch
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_destroyed
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator||=
name|ZFS_IMPORT_ANY_HOST
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|do_rewind
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flags
operator||=
name|ZFS_IMPORT_MISSING_LOG
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|flags
operator||=
name|ZFS_IMPORT_ONLY
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|add_prop_list
argument_list|(
name|optarg
argument_list|,
name|propval
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|mntopts
operator|=
name|optarg
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|add_prop_list
argument_list|(
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|add_prop_list
argument_list|(
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
literal|"none"
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
condition|)
goto|goto
name|error
goto|;
break|break;
case|case
literal|'T'
case|:
name|errno
operator|=
literal|0
expr_stmt|;
name|txg
operator|=
name|strtoull
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid txg value\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|rewind_policy
operator|=
name|ZPOOL_DO_REWIND
operator||
name|ZPOOL_EXTREME_REWIND
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|flags
operator||=
name|ZFS_IMPORT_VERBATIM
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|xtreme_rewind
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|cachefile
operator|&&
name|nsearch
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-c is incompatible with -d\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dryrun
operator|||
name|xtreme_rewind
operator|)
operator|&&
operator|!
name|do_rewind
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-n or -X only meaningful with -F\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dryrun
condition|)
name|rewind_policy
operator|=
name|ZPOOL_TRY_REWIND
expr_stmt|;
elseif|else
if|if
condition|(
name|do_rewind
condition|)
name|rewind_policy
operator|=
name|ZPOOL_DO_REWIND
expr_stmt|;
if|if
condition|(
name|xtreme_rewind
condition|)
name|rewind_policy
operator||=
name|ZPOOL_EXTREME_REWIND
expr_stmt|;
comment|/* In the future, we can capture further policy and include it here */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|policy
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|policy
argument_list|,
name|ZPOOL_REWIND_REQUEST_TXG
argument_list|,
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint32
argument_list|(
name|policy
argument_list|,
name|ZPOOL_REWIND_REQUEST
argument_list|,
name|rewind_policy
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|searchdirs
operator|==
name|NULL
condition|)
block|{
name|searchdirs
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|searchdirs
index|[
literal|0
index|]
operator|=
name|ZFS_DISK_ROOT
expr_stmt|;
name|nsearch
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check argument count */
if|if
condition|(
name|do_all
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check for the SYS_CONFIG privilege.  We do this explicitly 		 * here because otherwise any attempt to discover pools will 		 * silently fail. 		 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|!
name|priv_ineffect
argument_list|(
name|PRIV_SYS_CONFIG
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"discover pools: permission denied\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|policy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Depending on the arguments given, we do one of the following: 	 * 	 *<none>	Iterate through all pools and display information about 	 *		each one. 	 * 	 *	-a	Iterate through all pools and try to import each one. 	 * 	 *<id>	Find the pool that corresponds to the given GUID/pool 	 *		name and import that one. 	 * 	 *	-D	Above options applies only to destroyed pools. 	 */
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|searchguid
operator|=
name|strtoull
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|searchname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|searchguid
operator|=
literal|0
expr_stmt|;
block|}
name|found_config
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * User specified a name or guid.  Ensure it's unique. 		 */
name|idata
operator|.
name|unique
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|idata
operator|.
name|path
operator|=
name|searchdirs
expr_stmt|;
name|idata
operator|.
name|paths
operator|=
name|nsearch
expr_stmt|;
name|idata
operator|.
name|poolname
operator|=
name|searchname
expr_stmt|;
name|idata
operator|.
name|guid
operator|=
name|searchguid
expr_stmt|;
name|idata
operator|.
name|cachefile
operator|=
name|cachefile
expr_stmt|;
name|pools
operator|=
name|zpool_search_import
argument_list|(
name|g_zfs
argument_list|,
operator|&
name|idata
argument_list|)
expr_stmt|;
if|if
condition|(
name|pools
operator|!=
name|NULL
operator|&&
name|idata
operator|.
name|exists
operator|&&
operator|(
name|argc
operator|==
literal|1
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"a pool with that name already exists\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use the form '%s "
literal|"<pool | id><newpool>' to give it a new name\n"
argument_list|)
argument_list|,
literal|"zpool import"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pools
operator|==
name|NULL
operator|&&
name|idata
operator|.
name|exists
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"a pool with that name is already created/imported,\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"and no additional pools "
literal|"with that name were found\n"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pools
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"no such pool available\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|policy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * At this point we have a list of import candidate configs. Even if 	 * we were searching by pool name or guid, we still need to 	 * post-process the list to deal with pool state and possible 	 * duplicate names. 	 */
name|err
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
name|B_TRUE
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|pools
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|config
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|pool_state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_destroyed
operator|&&
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
continue|continue;
if|if
condition|(
name|do_destroyed
operator|&&
name|pool_state
operator|!=
name|POOL_STATE_DESTROYED
condition|)
continue|continue;
name|verify
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_REWIND_POLICY
argument_list|,
name|policy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|B_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|do_all
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_all
condition|)
block|{
name|err
operator||=
name|do_import
argument_list|(
name|config
argument_list|,
name|NULL
argument_list|,
name|mntopts
argument_list|,
name|props
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|show_import
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|searchname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 			 * We are searching for a pool based on name. 			 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|searchname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_config
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': more than "
literal|"one matching pool\n"
argument_list|)
argument_list|,
name|searchname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"import by numeric ID instead\n"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|found_config
operator|=
name|config
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint64_t
name|guid
decl_stmt|;
comment|/* 			 * Search for a pool by guid. 			 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|searchguid
condition|)
name|found_config
operator|=
name|config
expr_stmt|;
block|}
block|}
comment|/* 	 * If we were searching for a specific pool, verify that we found a 	 * pool, and then do the import. 	 */
if|if
condition|(
name|argc
operator|!=
literal|0
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_config
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"no such pool available\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|err
operator||=
name|do_import
argument_list|(
name|found_config
argument_list|,
name|argc
operator|==
literal|1
condition|?
name|NULL
else|:
name|argv
index|[
literal|1
index|]
argument_list|,
name|mntopts
argument_list|,
name|props
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we were just looking for pools, report an error if none were 	 * found. 	 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|first
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no pools available to import\n"
argument_list|)
argument_list|)
expr_stmt|;
name|error
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|pools
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|iostat_cbdata
block|{
name|boolean_t
name|cb_verbose
decl_stmt|;
name|int
name|cb_namewidth
decl_stmt|;
name|int
name|cb_iteration
decl_stmt|;
name|zpool_list_t
modifier|*
name|cb_list
decl_stmt|;
block|}
name|iostat_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|print_iostat_separator
parameter_list|(
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|cb_namewidth
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  -----  -----  -----  -----  -----  -----\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_iostat_header
parameter_list|(
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s     capacity     operations    bandwidth\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  alloc   free   read  write   read  write\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"pool"
argument_list|)
expr_stmt|;
name|print_iostat_separator
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a single statistic.  */
end_comment

begin_function
specifier|static
name|void
name|print_one_stat
parameter_list|(
name|uint64_t
name|value
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %5s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out all the statistics for the given vdev.  This can either be the  * toplevel configuration, or called recursively.  If 'name' is NULL, then this  * is a verbose output, and we don't want to display the toplevel pool stats.  */
end_comment

begin_function
name|void
name|print_vdev_stats
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|oldnv
parameter_list|,
name|nvlist_t
modifier|*
name|newnv
parameter_list|,
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|oldchild
decl_stmt|,
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|vdev_stat_t
modifier|*
name|oldvs
decl_stmt|,
modifier|*
name|newvs
decl_stmt|;
name|vdev_stat_t
name|zerovs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|tdelta
decl_stmt|;
name|double
name|scale
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
if|if
condition|(
name|oldnv
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|oldnv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|oldvs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldvs
operator|=
operator|&
name|zerovs
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|newnv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|newvs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
operator|>
name|cb
operator|->
name|cb_namewidth
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s%*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cb
operator|->
name|cb_namewidth
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|depth
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|tdelta
operator|=
name|newvs
operator|->
name|vs_timestamp
operator|-
name|oldvs
operator|->
name|vs_timestamp
expr_stmt|;
if|if
condition|(
name|tdelta
operator|==
literal|0
condition|)
name|scale
operator|=
literal|1.0
expr_stmt|;
else|else
name|scale
operator|=
operator|(
name|double
operator|)
name|NANOSEC
operator|/
name|tdelta
expr_stmt|;
comment|/* only toplevel vdevs have capacity stats */
if|if
condition|(
name|newvs
operator|->
name|vs_space
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"      -      -"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_one_stat
argument_list|(
name|newvs
operator|->
name|vs_alloc
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
name|newvs
operator|->
name|vs_space
operator|-
name|newvs
operator|->
name|vs_alloc
argument_list|)
expr_stmt|;
block|}
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_READ
index|]
operator|-
name|oldvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_READ
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_WRITE
index|]
operator|-
name|oldvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_WRITE
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_READ
index|]
operator|-
name|oldvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_READ
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_WRITE
index|]
operator|-
name|oldvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_WRITE
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_verbose
condition|)
return|return;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|newnv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|newchild
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|oldnv
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|oldnv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|oldchild
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|ishole
init|=
name|B_FALSE
decl_stmt|,
name|islog
init|=
name|B_FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|newchild
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
operator|&
name|ishole
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|newchild
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishole
operator|||
name|islog
condition|)
continue|continue;
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|oldnv
condition|?
name|oldchild
index|[
name|c
index|]
else|:
name|NULL
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Log device section 	 */
if|if
condition|(
name|num_logs
argument_list|(
name|newnv
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s      -      -      -      -      -      "
literal|"-\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"logs"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|islog
init|=
name|B_FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|newchild
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
expr_stmt|;
if|if
condition|(
name|islog
condition|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|oldnv
condition|?
name|oldchild
index|[
name|c
index|]
else|:
name|NULL
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Include level 2 ARC devices in iostat output 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|newnv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|newchild
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|oldnv
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|oldnv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|oldchild
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|children
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s      -      -      -      -      -      "
literal|"-\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"cache"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|oldnv
condition|?
name|oldchild
index|[
name|c
index|]
else|:
name|NULL
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|refresh_iostat
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
comment|/* 	 * If the pool has disappeared, remove it from the list and continue. 	 */
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|missing
condition|)
name|pool_list_remove
argument_list|(
name|cb
operator|->
name|cb_list
argument_list|,
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback to print out the iostats for the given pool.  */
end_comment

begin_function
name|int
name|print_iostat
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|oldconfig
decl_stmt|,
modifier|*
name|newconfig
decl_stmt|;
name|nvlist_t
modifier|*
name|oldnvroot
decl_stmt|,
modifier|*
name|newnvroot
decl_stmt|;
name|newconfig
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
operator|&
name|oldconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_iteration
operator|==
literal|1
condition|)
name|oldconfig
operator|=
name|NULL
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|newnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldconfig
operator|==
name|NULL
condition|)
name|oldnvroot
operator|=
name|NULL
expr_stmt|;
else|else
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|oldconfig
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|oldnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Print out the statistics for the pool. 	 */
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|oldnvroot
argument_list|,
name|newnvroot
argument_list|,
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_verbose
condition|)
name|print_iostat_separator
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_namewidth
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_verbose
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
name|strlen
argument_list|(
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|cb_namewidth
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The width must fall into the range [10,38].  The upper limit is the 	 * maximum we can have and still fit in 80 columns. 	 */
if|if
condition|(
name|cb
operator|->
name|cb_namewidth
operator|<
literal|10
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_namewidth
operator|>
literal|38
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
literal|38
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the input string, get the 'interval' and 'count' value if there is one.  */
end_comment

begin_function
specifier|static
name|void
name|get_interval_count
parameter_list|(
name|int
modifier|*
name|argcp
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|long
modifier|*
name|iv
parameter_list|,
name|unsigned
name|long
modifier|*
name|cnt
parameter_list|)
block|{
name|unsigned
name|long
name|interval
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|argcp
decl_stmt|,
name|errno
decl_stmt|;
comment|/* 	 * Determine if the last argument is an integer or a pool name 	 */
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|interval
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"interval "
literal|"cannot be zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Ignore the last parameter 			 */
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this is not a valid number, just plow on.  The 			 * user will get a more informative error message later 			 * on. 			 */
name|interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If the last argument is also an integer, then we have both a count 	 * and an interval. 	 */
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|interval
expr_stmt|;
name|interval
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"interval "
literal|"cannot be zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Ignore the last parameter 			 */
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|iv
operator|=
name|interval
expr_stmt|;
operator|*
name|cnt
operator|=
name|count
expr_stmt|;
operator|*
name|argcp
operator|=
name|argc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_timestamp_arg
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
name|timestamp_fmt
operator|=
name|UDATE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
name|timestamp_fmt
operator|=
name|DDATE
expr_stmt|;
else|else
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zpool iostat [-v] [-T d|u] [pool] ... [interval [count]]  *  *	-v	Display statistics for individual vdevs  *	-T	Display a timestamp in date(1) or Unix format  *  * This command can be tricky because we want to be able to deal with pool  * creation/destruction as well as vdev configuration changes.  The bulk of this  * processing is handled by the pool_list_* routines in zpool_iter.c.  We rely  * on pool_list_update() to detect the addition of new pools.  Configuration  * changes are all handled within libzfs.  */
end_comment

begin_function
name|int
name|zpool_do_iostat
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|npools
decl_stmt|;
name|unsigned
name|long
name|interval
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|zpool_list_t
modifier|*
name|list
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|iostat_cbdata_t
name|cb
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"T:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'T'
case|:
name|get_timestamp_arg
argument_list|(
operator|*
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|get_interval_count
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|interval
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Construct the list of all interesting pools. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|=
name|pool_list_get
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
operator|&
name|ret
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|argc
operator|!=
literal|0
condition|)
block|{
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|interval
operator|==
literal|0
condition|)
block|{
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Enter the main iostat loop. 	 */
name|cb
operator|.
name|cb_list
operator|=
name|list
expr_stmt|;
name|cb
operator|.
name|cb_verbose
operator|=
name|verbose
expr_stmt|;
name|cb
operator|.
name|cb_iteration
operator|=
literal|0
expr_stmt|;
name|cb
operator|.
name|cb_namewidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pool_list_update
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|npools
operator|=
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Refresh all statistics.  This is done as an explicit step 		 * before calculating the maximum name width, so that any 		 * configuration changes are properly accounted for. 		 */
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|refresh_iostat
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
comment|/* 		 * Iterate over all pools to determine the maximum width 		 * for the pool / device name column across all pools. 		 */
name|cb
operator|.
name|cb_namewidth
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|get_namewidth
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp_fmt
operator|!=
name|NODATE
condition|)
name|print_timestamp
argument_list|(
name|timestamp_fmt
argument_list|)
expr_stmt|;
comment|/* 		 * If it's the first time, or verbose mode, print the header. 		 */
if|if
condition|(
operator|++
name|cb
operator|.
name|cb_iteration
operator|==
literal|1
operator|||
name|verbose
condition|)
name|print_iostat_header
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|print_iostat
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
comment|/* 		 * If there's more than one pool, and we're not in verbose mode 		 * (which prints a separator for us), then print a separator. 		 */
if|if
condition|(
name|npools
operator|>
literal|1
operator|&&
operator|!
name|verbose
condition|)
name|print_iostat_separator
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Flush the output so that redirection to a file isn't buffered 		 * indefinitely. 		 */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|list_cbdata
block|{
name|boolean_t
name|cb_verbose
decl_stmt|;
name|int
name|cb_namewidth
decl_stmt|;
name|boolean_t
name|cb_scripted
decl_stmt|;
name|zprop_list_t
modifier|*
name|cb_proplist
decl_stmt|;
name|boolean_t
name|cb_literal
decl_stmt|;
block|}
name|list_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Given a list of columns to display, output appropriate headers for each one.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|list_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|pl
init|=
name|cb
operator|->
name|cb_proplist
decl_stmt|;
name|char
name|headerbuf
index|[
name|ZPOOL_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
name|size_t
name|width
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
name|width
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|cb
operator|->
name|cb_verbose
condition|)
block|{
comment|/* 			 * Reset the width to accommodate the verbose listing 			 * of devices. 			 */
name|width
operator|=
name|cb
operator|->
name|cb_namewidth
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
name|B_FALSE
expr_stmt|;
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
name|header
operator|=
name|zpool_prop_column_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
name|right_justify
operator|=
name|zpool_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|headerbuf
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|headerbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|headerbuf
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|header
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
argument_list|,
name|header
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|width
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a pool and a list of properties, print out all the properties according  * to the described layout.  */
end_comment

begin_function
specifier|static
name|void
name|print_pool
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|list_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|pl
init|=
name|cb
operator|->
name|cb_proplist
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|char
name|property
index|[
name|ZPOOL_MAXPROPLEN
index|]
decl_stmt|;
name|char
modifier|*
name|propstr
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
name|size_t
name|width
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
name|width
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|cb
operator|->
name|cb_verbose
condition|)
block|{
comment|/* 			 * Reset the width to accommodate the verbose listing 			 * of devices. 			 */
name|width
operator|=
name|cb
operator|->
name|cb_namewidth
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|cb
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|zpool_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|zpool_prop_feature
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
operator|||
name|zpool_prop_unsupported
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
operator|)
operator|&&
name|zpool_prop_get_feature
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|propstr
operator|=
name|property
expr_stmt|;
block|}
else|else
block|{
name|propstr
operator|=
literal|"-"
expr_stmt|;
block|}
comment|/* 		 * If this is being called in scripted mode, or if this is the 		 * last column and it is left-justified, don't include a width 		 * format specifier. 		 */
if|if
condition|(
name|cb
operator|->
name|cb_scripted
operator|||
operator|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_one_column
parameter_list|(
name|zpool_prop_t
name|prop
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|boolean_t
name|scripted
parameter_list|,
name|boolean_t
name|valid
parameter_list|)
block|{
name|char
name|propval
index|[
literal|64
index|]
decl_stmt|;
name|boolean_t
name|fixed
decl_stmt|;
name|size_t
name|width
init|=
name|zprop_width
argument_list|(
name|prop
argument_list|,
operator|&
name|fixed
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_EXPANDSZ
case|:
if|if
condition|(
name|value
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propval
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|value
argument_list|,
name|propval
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_FRAGMENTATION
case|:
if|if
condition|(
name|value
operator|==
name|ZFS_FRAG_INVALID
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propval
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propval
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|,
literal|"%llu%%"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CAPACITY
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propval
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|,
literal|"%llu%%"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_nicenum
argument_list|(
name|value
argument_list|,
name|propval
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propval
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|propval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|propval
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %*s"
argument_list|,
name|width
argument_list|,
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_list_stats
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|list_cbdata_t
modifier|*
name|cb
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|boolean_t
name|scripted
init|=
name|cb
operator|->
name|cb_scripted
decl_stmt|;
name|uint64_t
name|islog
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|haslog
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|dashes
init|=
literal|"%-*s      -      -      -         -      -      -\n"
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|boolean_t
name|toplevel
init|=
operator|(
name|vs
operator|->
name|vs_space
operator|!=
literal|0
operator|)
decl_stmt|;
name|uint64_t
name|cap
decl_stmt|;
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
operator|>
name|cb
operator|->
name|cb_namewidth
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s%*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cb
operator|->
name|cb_namewidth
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|depth
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * Print the properties for the individual vdevs. Some 		 * properties are only applicable to toplevel vdevs. The 		 * 'toplevel' boolean value is passed to the print_one_column() 		 * to indicate that the value is valid. 		 */
name|print_one_column
argument_list|(
name|ZPOOL_PROP_SIZE
argument_list|,
name|vs
operator|->
name|vs_space
argument_list|,
name|scripted
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
name|print_one_column
argument_list|(
name|ZPOOL_PROP_ALLOCATED
argument_list|,
name|vs
operator|->
name|vs_alloc
argument_list|,
name|scripted
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
name|print_one_column
argument_list|(
name|ZPOOL_PROP_FREE
argument_list|,
name|vs
operator|->
name|vs_space
operator|-
name|vs
operator|->
name|vs_alloc
argument_list|,
name|scripted
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
name|print_one_column
argument_list|(
name|ZPOOL_PROP_EXPANDSZ
argument_list|,
name|vs
operator|->
name|vs_esize
argument_list|,
name|scripted
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|print_one_column
argument_list|(
name|ZPOOL_PROP_FRAGMENTATION
argument_list|,
name|vs
operator|->
name|vs_fragmentation
argument_list|,
name|scripted
argument_list|,
operator|(
name|vs
operator|->
name|vs_fragmentation
operator|!=
name|ZFS_FRAG_INVALID
operator|&&
name|toplevel
operator|)
argument_list|)
expr_stmt|;
name|cap
operator|=
operator|(
name|vs
operator|->
name|vs_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|vs
operator|->
name|vs_alloc
operator|*
literal|100
operator|/
name|vs
operator|->
name|vs_space
operator|)
expr_stmt|;
name|print_one_column
argument_list|(
name|ZPOOL_PROP_CAPACITY
argument_list|,
name|cap
argument_list|,
name|scripted
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|ishole
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
operator|&
name|ishole
argument_list|)
operator|==
literal|0
operator|&&
name|ishole
condition|)
continue|continue;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
operator|==
literal|0
operator|&&
name|islog
condition|)
block|{
name|haslog
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_list_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|haslog
operator|==
name|B_TRUE
condition|)
block|{
comment|/* LINTED E_SEC_PRINTF_VAR_FMT */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dashes
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"log"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|islog
condition|)
continue|continue;
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_list_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
operator|&&
name|children
operator|>
literal|0
condition|)
block|{
comment|/* LINTED E_SEC_PRINTF_VAR_FMT */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dashes
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"cache"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_list_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
operator|&&
name|children
operator|>
literal|0
condition|)
block|{
comment|/* LINTED E_SEC_PRINTF_VAR_FMT */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dashes
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"spare"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_list_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Generic callback function to list a pool.  */
end_comment

begin_function
name|int
name|list_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|list_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_pool
argument_list|(
name|zhp
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_verbose
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|print_list_stats
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|nvroot
argument_list|,
name|cbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool list [-Hp] [-o prop[,prop]*] [-T d|u] [pool] ... [interval [count]]  *  *	-H	Scripted mode.  Don't display headers, and separate properties  *		by a single tab.  *	-o	List of properties to display.  Defaults to  *		"name,size,allocated,free,expandsize,fragmentation,capacity,"  *		"dedupratio,health,altroot"  * 	-p	Diplay values in parsable (exact) format.  *	-T	Display a timestamp in date(1) or Unix format  *  * List all pools in the system, whether or not they're healthy.  Output space  * statistics for each one, as well as health status summary.  */
end_comment

begin_function
name|int
name|zpool_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|list_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|char
name|default_props
index|[]
init|=
literal|"name,size,allocated,free,expandsize,fragmentation,capacity,"
literal|"dedupratio,health,altroot"
decl_stmt|;
name|char
modifier|*
name|props
init|=
name|default_props
decl_stmt|;
name|unsigned
name|long
name|interval
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|zpool_list_t
modifier|*
name|list
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":Ho:pT:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|props
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|get_timestamp_arg
argument_list|(
operator|*
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|cb
operator|.
name|cb_verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|get_interval_count
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|interval
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|props
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|list
operator|=
name|pool_list_get
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
operator|&
name|ret
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|cb
operator|.
name|cb_namewidth
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|get_namewidth
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp_fmt
operator|!=
name|NODATE
condition|)
name|print_timestamp
argument_list|(
name|timestamp_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_scripted
operator|&&
operator|(
name|first
operator|||
name|cb
operator|.
name|cb_verbose
operator|)
condition|)
block|{
name|print_header
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|ret
operator|=
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_TRUE
argument_list|,
name|list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
break|break;
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|!
name|cb
operator|.
name|cb_scripted
operator|&&
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zpool_do_attach_or_replace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|,
modifier|*
name|old_disk
decl_stmt|,
modifier|*
name|new_disk
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zpool_boot_label_t
name|boot_type
decl_stmt|;
name|uint64_t
name|boot_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|old_disk
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<new_device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|new_disk
operator|=
name|old_disk
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
name|argv
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|new_disk
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool '%s' is unavailable\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_is_bootable
argument_list|(
name|zhp
argument_list|)
condition|)
name|boot_type
operator|=
name|ZPOOL_COPY_BOOT_LABEL
expr_stmt|;
else|else
name|boot_type
operator|=
name|ZPOOL_NO_BOOT_LABEL
expr_stmt|;
name|boot_size
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_BOOTSIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|replacing
argument_list|,
name|B_FALSE
argument_list|,
name|boot_type
argument_list|,
name|boot_size
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|zpool_vdev_attach
argument_list|(
name|zhp
argument_list|,
name|old_disk
argument_list|,
name|new_disk
argument_list|,
name|nvroot
argument_list|,
name|replacing
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool replace [-f]<pool><device><new_device>  *  *	-f	Force attach, even if<new_device> appears to be in use.  *  * Replace<device> with<new_device>.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_replace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zpool_do_attach_or_replace
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool attach [-f]<pool><device><new_device>  *  *	-f	Force attach, even if<new_device> appears to be in use.  *  * Attach<new_device> to the mirror containing<device>.  If<device> is not  * part of a mirror, then<device> will be transformed into a mirror of  *<device> and<new_device>.  In either case,<new_device> will begin life  * with a DTL of [0, now], and will immediately begin to resilver itself.  */
end_comment

begin_function
name|int
name|zpool_do_attach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zpool_do_attach_or_replace
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool detach [-f]<pool><device>  *  *	-f	Force detach of<device>, even if DTLs argue against it  *		(not supported yet)  *  * Detach a device from a mirror.  The operation will be refused if<device>  * is the last device in the mirror, or if the DTLs indicate that this device  * has the only valid copy of some data.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_detach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
name|zpool_vdev_detach
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool split [-n] [-o prop=val] ...  *		[-o mntopt] ...  *		[-R altroot]<pool><newpool> [<device> ...]  *  *	-n	Do not split the pool, but display the resulting layout if  *		it were to be split.  *	-o	Set property=value, or set mount options.  *	-R	Mount the split-off pool under an alternate root.  *  * Splits the named pool and gives it the new pool name.  Devices to be split  * off may be listed, provided that no more than one device is specified  * per top-level vdev mirror.  The newly split pool is left in an exported  * state unless -R is specified.  *  * Restrictions: the top-level of the pool pool must only be made up of  * mirrors; all devices in the pool must be healthy; no device may be  * undergoing a resilvering operation.  */
end_comment

begin_function
name|int
name|zpool_do_split
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|srcpool
decl_stmt|,
modifier|*
name|newpool
decl_stmt|,
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|mntopts
init|=
name|NULL
decl_stmt|;
name|splitflags_t
name|flags
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|flags
operator|.
name|dryrun
operator|=
name|B_FALSE
expr_stmt|;
name|flags
operator|.
name|import
operator|=
name|B_FALSE
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":R:no:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'R'
case|:
name|flags
operator|.
name|import
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|add_prop_list
argument_list|(
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|flags
operator|.
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|add_prop_list
argument_list|(
name|optarg
argument_list|,
name|propval
argument_list|,
operator|&
name|props
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mntopts
operator|=
name|optarg
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|flags
operator|.
name|import
operator|&&
name|mntopts
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"setting mntopts is only "
literal|"valid when importing the pool\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Missing new pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|srcpool
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|newpool
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|srcpool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|config
operator|=
name|split_mirror_vdev
argument_list|(
name|zhp
argument_list|,
name|newpool
argument_list|,
name|props
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would create '%s' with the "
literal|"following layout:\n\n"
argument_list|)
argument_list|,
name|newpool
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|NULL
argument_list|,
name|newpool
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|||
name|flags
operator|.
name|dryrun
operator|||
operator|!
name|flags
operator|.
name|import
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * The split was successful. Now we need to open the new 	 * pool and import it. 	 */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|newpool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|!=
name|POOL_STATE_UNAVAIL
operator|&&
name|zpool_enable_datasets
argument_list|(
name|zhp
argument_list|,
name|mntopts
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Split was successful, but "
literal|"the datasets could not all be mounted\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Try doing '%s' with a "
literal|"different altroot\n"
argument_list|)
argument_list|,
literal|"zpool import"
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool online<pool><device> ...  */
end_comment

begin_function
name|int
name|zpool_do_online
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|vdev_state_t
name|newstate
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"et"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'e'
case|:
name|flags
operator||=
name|ZFS_ONLINE_EXPAND
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zpool_vdev_online
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|,
operator|&
name|newstate
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|newstate
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"warning: device '%s' "
literal|"onlined, but remains in faulted state\n"
argument_list|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstate
operator|==
name|VDEV_STATE_FAULTED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"use 'zpool "
literal|"clear' to restore a faulted "
literal|"device\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"use 'zpool "
literal|"replace' to replace devices "
literal|"that are no longer present\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool offline [-ft]<pool><device> ...  *  *	-f	Force the device into the offline state, even if doing  *		so would appear to compromise pool availability.  *		(not supported yet)  *  *	-t	Only take the device off-line temporarily.  The offline  *		state will not be persistent across reboots.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_offline
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|istmp
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ft"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|istmp
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zpool_vdev_offline
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|istmp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool clear<pool> [device]  *  * Clear all errors associated with a pool or a particular device.  */
end_comment

begin_function
name|int
name|zpool_do_clear
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_rewind
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|xtreme_rewind
init|=
name|B_FALSE
decl_stmt|;
name|uint32_t
name|rewind_policy
init|=
name|ZPOOL_NO_REWIND
decl_stmt|;
name|nvlist_t
modifier|*
name|policy
init|=
name|NULL
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|pool
decl_stmt|,
modifier|*
name|device
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"FnX"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'F'
case|:
name|do_rewind
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|xtreme_rewind
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dryrun
operator|||
name|xtreme_rewind
operator|)
operator|&&
operator|!
name|do_rewind
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-n or -X only meaningful with -F\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dryrun
condition|)
name|rewind_policy
operator|=
name|ZPOOL_TRY_REWIND
expr_stmt|;
elseif|else
if|if
condition|(
name|do_rewind
condition|)
name|rewind_policy
operator|=
name|ZPOOL_DO_REWIND
expr_stmt|;
if|if
condition|(
name|xtreme_rewind
condition|)
name|rewind_policy
operator||=
name|ZPOOL_EXTREME_REWIND
expr_stmt|;
comment|/* In future, further rewind policy choices can be passed along here */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|policy
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint32
argument_list|(
name|policy
argument_list|,
name|ZPOOL_REWIND_REQUEST
argument_list|,
name|rewind_policy
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pool
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|device
operator|=
name|argc
operator|==
literal|2
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|policy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_clear
argument_list|(
name|zhp
argument_list|,
name|device
argument_list|,
name|policy
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|policy
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool reguid<pool>  */
end_comment

begin_function
name|int
name|zpool_do_reguid
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
name|zpool_reguid
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool reopen<pool>  *  * Reopen the pool so that the kernel can update the sizes of all vdevs.  */
end_comment

begin_function
name|int
name|zpool_do_reopen
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|pool
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|pool
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
name|zpool_reopen
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|scrub_cbdata
block|{
name|int
name|cb_type
decl_stmt|;
name|int
name|cb_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|cb_argv
decl_stmt|;
block|}
name|scrub_cbdata_t
typedef|;
end_typedef

begin_function
name|int
name|scrub_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|scrub_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Ignore faulted pools. 	 */
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot scrub '%s': pool is "
literal|"currently unavailable\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zpool_scan
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool scrub [-s]<pool> ...  *  *	-s	Stop.  Stops any in-progress scrub.  */
end_comment

begin_function
name|int
name|zpool_do_scrub
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|scrub_cbdata_t
name|cb
decl_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|POOL_SCAN_SCRUB
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"s"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|cb
operator|.
name|cb_type
operator|=
name|POOL_SCAN_NONE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|cb
operator|.
name|cb_argc
operator|=
name|argc
expr_stmt|;
name|cb
operator|.
name|cb_argv
operator|=
name|argv
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|scrub_callback
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|status_cbdata
block|{
name|int
name|cb_count
decl_stmt|;
name|boolean_t
name|cb_allpools
decl_stmt|;
name|boolean_t
name|cb_verbose
decl_stmt|;
name|boolean_t
name|cb_explain
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
name|boolean_t
name|cb_dedup_stats
decl_stmt|;
block|}
name|status_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Print out detailed scrub status.  */
end_comment

begin_function
name|void
name|print_scan_status
parameter_list|(
name|pool_scan_stat_t
modifier|*
name|ps
parameter_list|)
block|{
name|time_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|uint64_t
name|elapsed
decl_stmt|,
name|mins_left
decl_stmt|,
name|hours_left
decl_stmt|;
name|uint64_t
name|pass_exam
decl_stmt|,
name|examined
decl_stmt|,
name|total
decl_stmt|;
name|uint_t
name|rate
decl_stmt|;
name|double
name|fraction_done
decl_stmt|;
name|char
name|processed_buf
index|[
literal|7
index|]
decl_stmt|,
name|examined_buf
index|[
literal|7
index|]
decl_stmt|,
name|total_buf
index|[
literal|7
index|]
decl_stmt|,
name|rate_buf
index|[
literal|7
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  scan: "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's never been a scan, there's not much to say. */
if|if
condition|(
name|ps
operator|==
name|NULL
operator|||
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_NONE
operator|||
name|ps
operator|->
name|pss_func
operator|>=
name|POOL_SCAN_FUNCS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"none requested\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|start
operator|=
name|ps
operator|->
name|pss_start_time
expr_stmt|;
name|end
operator|=
name|ps
operator|->
name|pss_end_time
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|ps
operator|->
name|pss_processed
argument_list|,
name|processed_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|processed_buf
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
operator|||
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
argument_list|)
expr_stmt|;
comment|/* 	 * Scan is finished or canceled. 	 */
if|if
condition|(
name|ps
operator|->
name|pss_state
operator|==
name|DSS_FINISHED
condition|)
block|{
name|uint64_t
name|minutes_taken
init|=
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|60
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
condition|)
block|{
name|fmt
operator|=
name|gettext
argument_list|(
literal|"scrub repaired %s in %lluh%um with "
literal|"%llu errors on %s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
condition|)
block|{
name|fmt
operator|=
name|gettext
argument_list|(
literal|"resilvered %s in %lluh%um with "
literal|"%llu errors on %s"
argument_list|)
expr_stmt|;
block|}
comment|/* LINTED */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|fmt
argument_list|,
name|processed_buf
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|minutes_taken
operator|/
literal|60
argument_list|)
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|minutes_taken
operator|%
literal|60
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ps
operator|->
name|pss_errors
argument_list|,
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ps
operator|->
name|pss_state
operator|==
name|DSS_CANCELED
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"scrub canceled on %s"
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"resilver canceled on %s"
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|assert
argument_list|(
name|ps
operator|->
name|pss_state
operator|==
name|DSS_SCANNING
argument_list|)
expr_stmt|;
comment|/* 	 * Scan is in progress. 	 */
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"scrub in progress since %s"
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"resilver in progress since %s"
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|examined
operator|=
name|ps
operator|->
name|pss_examined
condition|?
name|ps
operator|->
name|pss_examined
else|:
literal|1
expr_stmt|;
name|total
operator|=
name|ps
operator|->
name|pss_to_examine
expr_stmt|;
name|fraction_done
operator|=
operator|(
name|double
operator|)
name|examined
operator|/
name|total
expr_stmt|;
comment|/* elapsed time for this pass */
name|elapsed
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|ps
operator|->
name|pss_pass_start
expr_stmt|;
name|elapsed
operator|=
name|elapsed
condition|?
name|elapsed
else|:
literal|1
expr_stmt|;
name|pass_exam
operator|=
name|ps
operator|->
name|pss_pass_exam
condition|?
name|ps
operator|->
name|pss_pass_exam
else|:
literal|1
expr_stmt|;
name|rate
operator|=
name|pass_exam
operator|/
name|elapsed
expr_stmt|;
name|rate
operator|=
name|rate
condition|?
name|rate
else|:
literal|1
expr_stmt|;
name|mins_left
operator|=
operator|(
operator|(
name|total
operator|-
name|examined
operator|)
operator|/
name|rate
operator|)
operator|/
literal|60
expr_stmt|;
name|hours_left
operator|=
name|mins_left
operator|/
literal|60
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|examined
argument_list|,
name|examined_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|examined_buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|total
argument_list|,
name|total_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|total_buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|rate
argument_list|,
name|rate_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rate_buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * do not print estimated time if hours_left is more than 30 days 	 */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"    %s scanned out of %s at %s/s"
argument_list|)
argument_list|,
name|examined_buf
argument_list|,
name|total_buf
argument_list|,
name|rate_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hours_left
operator|<
operator|(
literal|30
operator|*
literal|24
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|", %lluh%um to go\n"
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|hours_left
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|mins_left
operator|%
literal|60
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|", (scan is slow, no estimated time)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"    %s resilvered, %.2f%% done\n"
argument_list|)
argument_list|,
name|processed_buf
argument_list|,
literal|100
operator|*
name|fraction_done
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"    %s repaired, %.2f%% done\n"
argument_list|)
argument_list|,
name|processed_buf
argument_list|,
literal|100
operator|*
name|fraction_done
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_error_log
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nverrlist
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|size_t
name|len
init|=
name|MAXPATHLEN
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|zpool_get_errlog
argument_list|(
name|zhp
argument_list|,
operator|&
name|nverrlist
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"errors: List of errors unavailable "
literal|"(insufficient privileges)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"errors: Permanent errors have been "
literal|"detected in the following files:\n\n"
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|safe_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nverrlist
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|obj
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_DATASET
argument_list|,
operator|&
name|dsobj
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_OBJECT
argument_list|,
operator|&
name|obj
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zpool_obj_to_path
argument_list|(
name|zhp
argument_list|,
name|dsobj
argument_list|,
name|obj
argument_list|,
name|pathname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %s\n"
argument_list|,
literal|""
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nverrlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_spares
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|spares
parameter_list|,
name|uint_t
name|nspares
parameter_list|,
name|int
name|namewidth
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tspares\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|name
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|namewidth
argument_list|,
literal|2
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_l2cache
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|l2cache
parameter_list|,
name|uint_t
name|nl2cache
parameter_list|,
name|int
name|namewidth
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nl2cache
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tcache\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|l2cache
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|name
argument_list|,
name|l2cache
index|[
name|i
index|]
argument_list|,
name|namewidth
argument_list|,
literal|2
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_dedup_stats
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|ddt_histogram_t
modifier|*
name|ddh
decl_stmt|;
name|ddt_stat_t
modifier|*
name|dds
decl_stmt|;
name|ddt_object_t
modifier|*
name|ddo
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
comment|/* 	 * If the pool was faulted then we may not have been able to 	 * obtain the config. Otherwise, if we have anything in the dedup 	 * table continue processing the stats. 	 */
if|if
condition|(
name|nvlist_lookup_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_OBJ_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ddo
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" dedup: "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddo
operator|->
name|ddo_count
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no DDT entries\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"DDT entries %llu, size %llu on disk, %llu in core\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ddo
operator|->
name|ddo_count
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ddo
operator|->
name|ddo_dspace
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ddo
operator|->
name|ddo_mspace
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|dds
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_HISTOGRAM
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ddh
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zpool_dump_ddt
argument_list|(
name|dds
argument_list|,
name|ddh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a summary of pool status.  Displays a summary such as:  *  *        pool: tank  *	status: DEGRADED  *	reason: One or more devices ...  *         see: http://illumos.org/msg/ZFS-xxxx-01  *	config:  *		mirror		DEGRADED  *                c1t0d0	OK  *                c2t0d0	UNAVAIL  *  * When given the '-v' option, we print out the complete config.  If the '-e'  * option is specified, then we print out error rate information as well.  */
end_comment

begin_function
name|int
name|status_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|status_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|int
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|health
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reason
operator|=
name|zpool_get_status
argument_list|(
name|zhp
argument_list|,
operator|&
name|msgid
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_count
operator|++
expr_stmt|;
comment|/* 	 * If we were given 'zpool status -x', only report those pools with 	 * problems. 	 */
if|if
condition|(
name|cbp
operator|->
name|cb_explain
operator|&&
operator|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
operator|||
name|reason
operator|==
name|ZPOOL_STATUS_VERSION_OLDER
operator|||
name|reason
operator|==
name|ZPOOL_STATUS_FEAT_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_allpools
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"pool '%s' is healthy\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|health
operator|=
name|zpool_state_to_name
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  pool: %s\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" state: %s\n"
argument_list|)
argument_list|,
name|health
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be opened.  Sufficient replicas exist for\n\tthe pool to "
literal|"continue functioning in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Attach the missing device and "
literal|"online it using 'zpool online'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be opened.  There are insufficient\n\treplicas for the "
literal|"pool to continue functioning.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Attach the missing device and "
literal|"online it using 'zpool online'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_R
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be used because the label is missing or\n\tinvalid.  "
literal|"Sufficient replicas exist for the pool to continue\n\t"
literal|"functioning in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Replace the device using "
literal|"'zpool replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be used because the label is missing \n\tor invalid.  "
literal|"There are insufficient replicas for the pool to "
literal|"continue\n\tfunctioning.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_explain_recover
argument_list|(
name|zpool_get_handle
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|reason
argument_list|,
name|config
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FAILING_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"experienced an unrecoverable error.  An\n\tattempt was "
literal|"made to correct the error.  Applications are "
literal|"unaffected.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Determine if the device needs "
literal|"to be replaced, and clear the errors\n\tusing "
literal|"'zpool clear' or replace the device with 'zpool "
literal|"replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_OFFLINE_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"been taken offline by the administrator.\n\tSufficient "
literal|"replicas exist for the pool to continue functioning in "
literal|"a\n\tdegraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Online the device using "
literal|"'zpool online' or replace the device with\n\t'zpool "
literal|"replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_REMOVED_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"been removed by the administrator.\n\tSufficient "
literal|"replicas exist for the pool to continue functioning in "
literal|"a\n\tdegraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Online the device using "
literal|"'zpool online' or replace the device with\n\t'zpool "
literal|"replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_RESILVERING
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices is "
literal|"currently being resilvered.  The pool will\n\tcontinue "
literal|"to function, possibly in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Wait for the resilver to "
literal|"complete.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_DATA
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"experienced an error resulting in data\n\tcorruption.  "
literal|"Applications may be affected.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Restore the file in question "
literal|"if possible.  Otherwise restore the\n\tentire pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_POOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool metadata is corrupted "
literal|"and the pool cannot be opened.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_explain_recover
argument_list|(
name|zpool_get_handle
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|reason
argument_list|,
name|config
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_OLDER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool is formatted using a "
literal|"legacy on-disk format.  The pool can\n\tstill be used, "
literal|"but some features are unavailable.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Upgrade the pool using 'zpool "
literal|"upgrade'.  Once this is done, the\n\tpool will no longer "
literal|"be accessible on software that does not support feature\n"
literal|"\tflags.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool has been upgraded to a "
literal|"newer, incompatible on-disk version.\n\tThe pool cannot "
literal|"be accessed on this system.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Access the pool from a system "
literal|"running more recent software, or\n\trestore the pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FEAT_DISABLED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: Some supported features are not "
literal|"enabled on the pool. The pool can\n\tstill be used, but "
literal|"some features are unavailable.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Enable all features using "
literal|"'zpool upgrade'. Once this is done,\n\tthe pool may no "
literal|"longer be accessible by software that does not support\n\t"
literal|"the features. See zpool-features(5) for details.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_READ
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool cannot be accessed on "
literal|"this system because it uses the\n\tfollowing feature(s) "
literal|"not supported on this system:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_print_unsup_feat
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Access the pool from a system "
literal|"that supports the required feature(s),\n\tor restore the "
literal|"pool from backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_UNSUP_FEAT_WRITE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool can only be accessed "
literal|"in read-only mode on this system. It\n\tcannot be "
literal|"accessed in read-write mode because it uses the "
literal|"following\n\tfeature(s) not supported on this system:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_print_unsup_feat
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be accessed in "
literal|"read-write mode. Import the pool with\n"
literal|"\t\"-o readonly=on\", access the pool from a system that "
literal|"supports the\n\trequired feature(s), or restore the "
literal|"pool from backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FAULTED_DEV_R
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices are "
literal|"faulted in response to persistent errors.\n\tSufficient "
literal|"replicas exist for the pool to continue functioning "
literal|"in a\n\tdegraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Replace the faulted device, "
literal|"or use 'zpool clear' to mark the device\n\trepaired.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FAULTED_DEV_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices are "
literal|"faulted in response to persistent errors.  There are "
literal|"insufficient replicas for the pool to\n\tcontinue "
literal|"functioning.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Destroy and re-create the pool "
literal|"from a backup source.  Manually marking the device\n"
literal|"\trepaired using 'zpool clear' may allow some data "
literal|"to be recovered.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_IO_FAILURE_WAIT
case|:
case|case
name|ZPOOL_STATUS_IO_FAILURE_CONTINUE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices are "
literal|"faulted in response to IO failures.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Make sure the affected devices "
literal|"are connected, then run 'zpool clear'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_BAD_LOG
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: An intent log record "
literal|"could not be read.\n"
literal|"\tWaiting for adminstrator intervention to fix the "
literal|"faulted pool.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Either restore the affected "
literal|"device(s) and run 'zpool online',\n"
literal|"\tor ignore the intent log records by running "
literal|"'zpool clear'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * The remaining errors can't actually be generated, yet. 		 */
name|assert
argument_list|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"   see: http://illumos.org/msg/%s\n"
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|int
name|namewidth
decl_stmt|;
name|uint64_t
name|nerr
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|pool_scan_stat_t
modifier|*
name|ps
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SCAN_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ps
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|print_scan_status
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|namewidth
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namewidth
operator|<
literal|10
condition|)
name|namewidth
operator|=
literal|10
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"config:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\t%-*s  %-8s %5s %5s %5s\n"
argument_list|)
argument_list|,
name|namewidth
argument_list|,
literal|"NAME"
argument_list|,
literal|"STATE"
argument_list|,
literal|"READ"
argument_list|,
literal|"WRITE"
argument_list|,
literal|"CKSUM"
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_logs
argument_list|(
name|nvroot
argument_list|)
operator|>
literal|0
condition|)
name|print_logs
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
name|print_l2cache
argument_list|(
name|zhp
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|namewidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
name|print_spares
argument_list|(
name|zhp
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|namewidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|nerr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|nverrlist
init|=
name|NULL
decl_stmt|;
comment|/* 			 * If the approximate error count is small, get a 			 * precise count by fetching the entire log and 			 * uniquifying the results. 			 */
if|if
condition|(
name|nerr
operator|>
literal|0
operator|&&
name|nerr
operator|<
literal|100
operator|&&
operator|!
name|cbp
operator|->
name|cb_verbose
operator|&&
name|zpool_get_errlog
argument_list|(
name|zhp
argument_list|,
operator|&
name|nverrlist
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
name|nerr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nverrlist
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nerr
operator|++
expr_stmt|;
block|}
block|}
name|nvlist_free
argument_list|(
name|nverrlist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"errors: No known data "
literal|"errors\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"errors: %llu data "
literal|"errors, use '-v' for a list\n"
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|nerr
argument_list|)
expr_stmt|;
else|else
name|print_error_log
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_dedup_stats
condition|)
name|print_dedup_stats
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"config: The configuration cannot be "
literal|"determined.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool status [-vx] [-T d|u] [pool] ... [interval [count]]  *  *	-v	Display complete error logs  *	-x	Display only pools with potential problems  *	-D	Display dedup status (undocumented)  *	-T	Display a timestamp in date(1) or Unix format  *  * Describes the health status of all pools or some subset.  */
end_comment

begin_function
name|int
name|zpool_do_status
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|interval
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|status_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vxDT:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|cb
operator|.
name|cb_verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cb
operator|.
name|cb_explain
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|cb
operator|.
name|cb_dedup_stats
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|get_timestamp_arg
argument_list|(
operator|*
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|get_interval_count
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|interval
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|cb
operator|.
name|cb_allpools
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|timestamp_fmt
operator|!=
name|NODATE
condition|)
name|print_timestamp
argument_list|(
name|timestamp_fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|status_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_count
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|.
name|cb_explain
operator|&&
name|cb
operator|.
name|cb_first
operator|&&
name|cb
operator|.
name|cb_allpools
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"all pools are healthy\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|upgrade_cbdata
block|{
name|int
name|cb_first
decl_stmt|;
name|int
name|cb_argc
decl_stmt|;
name|uint64_t
name|cb_version
decl_stmt|;
name|char
modifier|*
modifier|*
name|cb_argv
decl_stmt|;
block|}
name|upgrade_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|upgrade_version
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|version
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|oldversion
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|oldversion
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|oldversion
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oldversion
operator|<
name|version
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zpool_upgrade
argument_list|(
name|zhp
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Successfully upgraded "
literal|"'%s' from version %llu to feature flags.\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|oldversion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Successfully upgraded "
literal|"'%s' from version %llu to version %llu.\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|oldversion
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_enable_all
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|count
decl_stmt|;
name|boolean_t
name|firstff
init|=
name|B_TRUE
decl_stmt|;
name|nvlist_t
modifier|*
name|enabled
init|=
name|zpool_get_features
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_uname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fguid
init|=
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_guid
decl_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|enabled
argument_list|,
name|fguid
argument_list|)
condition|)
block|{
name|char
modifier|*
name|propname
decl_stmt|;
name|verify
argument_list|(
operator|-
literal|1
operator|!=
name|asprintf
argument_list|(
operator|&
name|propname
argument_list|,
literal|"feature@%s"
argument_list|,
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zpool_set_prop
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|,
name|ZFS_FEATURE_ENABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|firstff
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Enabled the "
literal|"following features on '%s':\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|firstff
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  %s\n"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|propname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|countp
operator|!=
name|NULL
condition|)
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_cb
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|boolean_t
name|printnl
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
name|cbp
operator|->
name|cb_version
condition|)
block|{
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
name|upgrade_version
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|printnl
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * If they did "zpool upgrade -a", then we could 		 * be doing ioctls to different pools.  We need 		 * to log this history once to each pool, and bypass 		 * the normal history logging that happens in main(). 		 */
operator|(
name|void
operator|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
expr_stmt|;
name|log_history
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|int
name|count
decl_stmt|;
name|ret
operator|=
name|upgrade_enable_all
argument_list|(
name|zhp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|printnl
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printnl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_list_older_cb
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
name|SPA_VERSION_FEATURES
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following pools are "
literal|"formatted with legacy version numbers and can\n"
literal|"be upgraded to use feature flags.  After "
literal|"being upgraded, these pools\nwill no "
literal|"longer be accessible by software that does not "
literal|"support feature\nflags.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  POOL\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"---  ------------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%2llu   %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|version
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_list_disabled_cb
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|int
name|i
decl_stmt|;
name|boolean_t
name|poolfirst
init|=
name|B_TRUE
decl_stmt|;
name|nvlist_t
modifier|*
name|enabled
init|=
name|zpool_get_features
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fguid
init|=
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_guid
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
init|=
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_uname
decl_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|enabled
argument_list|,
name|fguid
argument_list|)
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nSome "
literal|"supported features are not "
literal|"enabled on the following pools. "
literal|"Once a\nfeature is enabled the "
literal|"pool may become incompatible with "
literal|"software\nthat does not support "
literal|"the feature. See "
literal|"zpool-features(5) for "
literal|"details.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"POOL  "
literal|"FEATURE\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"------"
literal|"---------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|poolfirst
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|poolfirst
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"      %s\n"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_one
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|boolean_t
name|printnl
init|=
name|B_FALSE
decl_stmt|;
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|uint64_t
name|cur_version
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"log"
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"'log' is now a reserved word\n"
literal|"Pool 'log' must be renamed using export and import"
literal|" to upgrade.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cur_version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_version
operator|>
name|cbp
operator|->
name|cb_version
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Pool '%s' is already formatted "
literal|"using more current version '%llu'.\n\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cur_version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_version
operator|!=
name|SPA_VERSION
operator|&&
name|cur_version
operator|==
name|cbp
operator|->
name|cb_version
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Pool '%s' is already formatted "
literal|"using version %llu.\n\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cur_version
operator|!=
name|cbp
operator|->
name|cb_version
condition|)
block|{
name|printnl
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|upgrade_version
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|upgrade_enable_all
argument_list|(
name|zhp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|printnl
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_version
operator|==
name|SPA_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Pool '%s' already has all "
literal|"supported features enabled.\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printnl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool upgrade  * zpool upgrade -v  * zpool upgrade [-V version]<-a | pool ...>  *  * With no arguments, display downrev'd ZFS pool available for upgrade.  * Individual pools can be upgraded by specifying the pool, and '-a' will  * upgrade all pools.  */
end_comment

begin_function
name|int
name|zpool_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|upgrade_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|showversions
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|upgradeall
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":avV:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|upgradeall
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|showversions
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|cb
operator|.
name|cb_version
operator|=
name|strtoll
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
operator|||
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|cb
operator|.
name|cb_version
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid version '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|cb
operator|.
name|cb_argc
operator|=
name|argc
expr_stmt|;
name|cb
operator|.
name|cb_argv
operator|=
name|argv
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_version
operator|==
literal|0
condition|)
block|{
name|cb
operator|.
name|cb_version
operator|=
name|SPA_VERSION
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|upgradeall
operator|&&
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-V option is "
literal|"incompatible with other arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|showversions
condition|)
block|{
if|if
condition|(
name|upgradeall
operator|||
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-v option is "
literal|"incompatible with other arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|upgradeall
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-a option should not "
literal|"be used along with a pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"This system supports ZFS pool feature "
literal|"flags.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|showversions
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following features are "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"FEAT DESCRIPTION\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"----------------------------------------------"
literal|"---------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|zfeature_info_t
modifier|*
name|fi
init|=
operator|&
name|spa_feature_table
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ro
init|=
operator|(
name|fi
operator|->
name|fi_flags
operator|&
name|ZFEATURE_FLAG_READONLY_COMPAT
operator|)
condition|?
literal|" (read-only compatible)"
else|:
literal|""
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
name|fi
operator|->
name|fi_uname
argument_list|,
name|ro
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"     %s\n"
argument_list|,
name|fi
operator|->
name|fi_desc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following legacy versions are also "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  DESCRIPTION\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  -----------------------------------------"
literal|"---------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 1   Initial ZFS version\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 2   Ditto blocks "
literal|"(replicated metadata)\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 3   Hot spares and double parity "
literal|"RAID-Z\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 4   zpool history\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 5   Compression using the gzip "
literal|"algorithm\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 6   bootfs pool property\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 7   Separate intent log devices\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 8   Delegated administration\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 9   refquota and refreservation "
literal|"properties\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 10  Cache devices\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 11  Improved scrub performance\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 12  Snapshot properties\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 13  snapused property\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 14  passthrough-x aclinherit\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 15  user/group space accounting\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 16  stmf property support\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 17  Triple-parity RAID-Z\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 18  Snapshot user holds\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 19  Log device removal\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 20  Compression using zle "
literal|"(zero-length encoding)\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 21  Deduplication\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 22  Received properties\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 23  Slim ZIL\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 24  System attributes\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 25  Improved scrub stats\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 26  Improved snapshot deletion "
literal|"performance\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 27  Improved snapshot creation "
literal|"performance\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 28  Multiple vdev replacements\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nFor more information on a particular "
literal|"version, including supported releases,\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"see the ZFS Administration Guide.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|upgradeall
condition|)
block|{
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|upgrade_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_first
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|cb_version
operator|==
name|SPA_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All pools are already "
literal|"formatted using feature flags.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Every feature flags "
literal|"pool already has all supported features "
literal|"enabled.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All pools are already "
literal|"formatted with version %llu or higher.\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_version
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|upgrade_list_older_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All pools are formatted "
literal|"using feature flags.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nUse 'zpool upgrade -v' "
literal|"for a list of available legacy versions.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|upgrade_list_disabled_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Every feature flags pool has "
literal|"all supported features enabled.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|upgrade_one
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|hist_cbdata
block|{
name|boolean_t
name|first
decl_stmt|;
name|boolean_t
name|longfmt
decl_stmt|;
name|boolean_t
name|internal
decl_stmt|;
block|}
name|hist_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Print out the command history for a specific pool.  */
end_comment

begin_function
specifier|static
name|int
name|get_history_one
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvhis
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|records
decl_stmt|;
name|uint_t
name|numrecords
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|hist_cbdata_t
modifier|*
name|cb
init|=
operator|(
name|hist_cbdata_t
operator|*
operator|)
name|data
decl_stmt|;
name|cb
operator|->
name|first
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"History for '%s':\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zpool_get_history
argument_list|(
name|zhp
argument_list|,
operator|&
name|nvhis
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvhis
argument_list|,
name|ZPOOL_HIST_RECORD
argument_list|,
operator|&
name|records
argument_list|,
operator|&
name|numrecords
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrecords
condition|;
name|i
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|rec
init|=
name|records
index|[
name|i
index|]
decl_stmt|;
name|char
name|tbuf
index|[
literal|30
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_TIME
argument_list|)
condition|)
block|{
name|time_t
name|tsec
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|tsec
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|records
index|[
name|i
index|]
argument_list|,
name|ZPOOL_HIST_TIME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|localtime_r
argument_list|(
operator|&
name|tsec
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%F.%T"
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_CMD
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s"
argument_list|,
name|tbuf
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_CMD
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_EVENT
argument_list|)
condition|)
block|{
name|int
name|ievent
init|=
name|fnvlist_lookup_uint64
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_EVENT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|internal
condition|)
continue|continue;
if|if
condition|(
name|ievent
operator|>=
name|ZFS_NUM_LEGACY_HISTORY_EVENTS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s unrecognized record:\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|rec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s [internal %s txg:%lld] %s"
argument_list|,
name|tbuf
argument_list|,
name|zfs_history_event_names
index|[
name|ievent
index|]
argument_list|,
name|fnvlist_lookup_uint64
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_TXG
argument_list|)
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_STR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cb
operator|->
name|internal
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s [txg:%lld] %s"
argument_list|,
name|tbuf
argument_list|,
name|fnvlist_lookup_uint64
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_TXG
argument_list|)
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_DSNAME
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s (%llu)"
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_DSNAME
argument_list|)
argument_list|,
name|fnvlist_lookup_uint64
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_DSID
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INT_STR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_IOCTL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cb
operator|->
name|internal
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s ioctl %s\n"
argument_list|,
name|tbuf
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_IOCTL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INPUT_NVL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"    input:\n"
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|fnvlist_lookup_nvlist
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_INPUT_NVL
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_OUTPUT_NVL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"    output:\n"
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|fnvlist_lookup_nvlist
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_OUTPUT_NVL
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cb
operator|->
name|internal
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s unrecognized record:\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|rec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cb
operator|->
name|longfmt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_WHO
argument_list|)
condition|)
block|{
name|uid_t
name|who
init|=
name|fnvlist_lookup_uint64
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_WHO
argument_list|)
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwuid
argument_list|(
name|who
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"user %d "
argument_list|,
operator|(
name|int
operator|)
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s) "
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_HOST
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"on %s"
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_HOST
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_ZONE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|":%s"
argument_list|,
name|fnvlist_lookup_string
argument_list|(
name|rec
argument_list|,
name|ZPOOL_HIST_ZONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvhis
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool history<pool>  *  * Displays the history of commands that modified pools.  */
end_comment

begin_function
name|int
name|zpool_do_history
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|hist_cbdata_t
name|cbdata
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|cbdata
operator|.
name|first
operator|=
name|B_TRUE
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"li"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|cbdata
operator|.
name|longfmt
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|cbdata
operator|.
name|internal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|get_history_one
argument_list|,
operator|&
name|cbdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|cbdata
operator|.
name|first
operator|==
name|B_TRUE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zprop_get_cbdata_t
modifier|*
name|cbp
init|=
operator|(
name|zprop_get_cbdata_t
operator|*
operator|)
name|data
decl_stmt|;
name|char
name|value
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|zprop_source_t
name|srctype
decl_stmt|;
name|zprop_list_t
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
name|cbp
operator|->
name|cb_proplist
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * Skip the special fake placeholder. This will also skip 		 * over the name property when 'all' is specified. 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZPOOL_PROP_NAME
operator|&&
name|pl
operator|==
name|cbp
operator|->
name|cb_proplist
condition|)
continue|continue;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZPROP_INVAL
operator|&&
operator|(
name|zpool_prop_feature
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
operator|||
name|zpool_prop_unsupported
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
operator|)
condition|)
block|{
name|srctype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
if|if
condition|(
name|zpool_prop_get_feature
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zprop_print_one_property
argument_list|(
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|value
argument_list|,
name|srctype
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|srctype
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|zprop_print_one_property
argument_list|(
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|value
argument_list|,
name|srctype
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool get [-Hp] [-o "all" | field[,...]]<"all" | property[,...]><pool> ...  *  *	-H	Scripted mode.  Don't display headers, and separate properties  *		by a single tab.  *	-o	List of columns to display.  Defaults to  *		"name,property,value,source".  * 	-p	Diplay values in parsable (exact) format.  *  * Get properties of pools in the system. Output space statistics  * for each one as well as other attributes.  */
end_comment

begin_function
name|int
name|zpool_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zprop_get_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zprop_list_t
name|fake_name
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Set up default columns and sources. 	 */
name|cb
operator|.
name|cb_sources
operator|=
name|ZPROP_SRC_ALL
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|ZFS_TYPE_POOL
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":Hpo:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|bzero
argument_list|(
operator|&
name|cb
operator|.
name|cb_columns
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
operator|.
name|cb_columns
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|col_subopts
index|[]
init|=
block|{
literal|"name"
block|,
literal|"property"
block|,
literal|"value"
block|,
literal|"source"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|ZFS_GET_NCOLS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too "
literal|"many fields given to -o "
literal|"option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|col_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"\"all\" conflicts "
literal|"with specific fields "
literal|"given to -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
name|i
operator|=
name|ZFS_GET_NCOLS
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid column name "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|!=
name|NULL
condition|)
block|{
name|fake_name
operator|.
name|pl_prop
operator|=
name|ZPOOL_PROP_NAME
expr_stmt|;
name|fake_name
operator|.
name|pl_width
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|fake_name
operator|.
name|pl_next
operator|=
name|cb
operator|.
name|cb_proplist
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
operator|&
name|fake_name
expr_stmt|;
block|}
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|get_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|==
operator|&
name|fake_name
condition|)
name|zprop_free_list
argument_list|(
name|fake_name
operator|.
name|pl_next
argument_list|)
expr_stmt|;
else|else
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|set_cbdata
block|{
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|char
modifier|*
name|cb_value
decl_stmt|;
name|boolean_t
name|cb_any_successful
decl_stmt|;
block|}
name|set_cbdata_t
typedef|;
end_typedef

begin_function
name|int
name|set_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|set_cbdata_t
modifier|*
name|cb
init|=
operator|(
name|set_cbdata_t
operator|*
operator|)
name|data
decl_stmt|;
name|error
operator|=
name|zpool_set_prop
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_propname
argument_list|,
name|cb
operator|->
name|cb_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cb
operator|->
name|cb_any_successful
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|set_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property=value "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many pool names\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_propname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|=
name|strchr
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_value
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing value in "
literal|"property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|cb
operator|.
name|cb_value
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|++
expr_stmt|;
name|error
operator|=
name|for_each_pool
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|set_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_command_idx
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TEXT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure the user has specified some command. 	 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing command\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cmdname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Special case '-?' 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
name|zfs_save_arguments
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|history_str
argument_list|,
sizeof|sizeof
argument_list|(
name|history_str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Run the appropriate command. 	 */
if|if
condition|(
name|find_command_idx
argument_list|(
name|cmdname
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|cmdname
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|verify
argument_list|(
name|find_command_idx
argument_list|(
literal|"set"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"freeze"
argument_list|)
operator|==
literal|0
operator|&&
name|argc
operator|==
literal|3
condition|)
block|{
comment|/* 		 * 'freeze' is a vile debugging abomination, so we treat 		 * it as such. 		 */
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|ioctl
argument_list|(
name|fd
argument_list|,
name|ZFS_IOC_POOL_FREEZE
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"unrecognized "
literal|"command '%s'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|log_history
condition|)
operator|(
name|void
operator|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'ZFS_ABORT' environment variable causes us to dump core on exit 	 * for the purposes of running ::findleaks. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

