begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lexical analysis of RCS files */
end_comment

begin_comment
comment|/******************************************************************************  *                     Lexical Analysis.  *                     hashtable, Lexinit, nextlex, getlex, getkey,  *                     getid, getnum, readstring, printstring, savestring,  *                     checkid, fatserror, error, faterror, warn, diagnose  *                     Testprogram: define LEXDB  ******************************************************************************  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.19  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.18  1995/06/01 16:23:43  eggert  * (map_fd_deallocate,mmap_deallocate,read_deallocate,nothing_to_deallocate):  * New functions.  * (Iclose): If large_memory and maps_memory, use them to deallocate mapping.  * (fd2RILE): Use map_fd if available.  * If one mapping method fails, try the next instead of giving up;  * if they all fail, fall back on ordinary read.  * Work around bug: root mmap over NFS succeeds, but accessing dumps core.  * Use MAP_FAILED macro for mmap failure, and `char *' instead of caddr_t.  * (advise_access): Use madvise only if this instance used mmap.  * (Iopen): Use fdSafer to get safer file descriptor.  * (aflush): Moved here from rcsedit.c.  *  * Revision 5.17  1994/03/20 04:52:58  eggert  * Don't worry if madvise fails.  Add Orewind.  Remove lint.  *  * Revision 5.16  1993/11/09 17:55:29  eggert  * Fix `label: }' typo.  *  * Revision 5.15  1993/11/03 17:42:27  eggert  * Improve quality of diagnostics by putting file names in them more often.  * Don't discard ignored phrases.  *  * Revision 5.14  1992/07/28  16:12:44  eggert  * Identifiers may now start with a digit and (unless they are symbolic names)  * may contain `.'.  Avoid `unsigned'.  Statement macro names now end in _.  *  * Revision 5.13  1992/02/17  23:02:27  eggert  * Work around NFS mmap SIGBUS problem.  *  * Revision 5.12  1992/01/06  02:42:34  eggert  * Use OPEN_O_BINARY if mode contains 'b'.  *  * Revision 5.11  1991/11/03  03:30:44  eggert  * Fix porting bug to ancient hosts lacking vfprintf.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  *  * Revision 5.9  1991/09/24  00:28:42  eggert  * Don't export errsay().  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add eoflex(), mmap support.  Tune.  *  * Revision 5.7  1991/04/21  11:58:26  eggert  * Add MS-DOS support.  *  * Revision 5.6  1991/02/25  07:12:42  eggert  * Work around fputs bug.  strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/12/04  05:18:47  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/19  20:05:28  hammer  * no longer gives warning about unknown keywords if -q is specified  *  * Revision 5.3  1990/11/01  05:03:48  eggert  * When ignoring unknown phrases, copy them to the output RCS file.  *  * Revision 5.2  1990/09/04  08:02:27  eggert  * Count RCS lines better.  *  * Revision 5.1  1990/08/29  07:14:03  eggert  * Work around buggy compilers with defective argument promotion.  *  * Revision 5.0  1990/08/22  08:12:55  eggert  * Remove compile-time limits; use malloc instead.  * Report errno-related errors with perror().  * Ansify and Posixate.  Add support for ISO 8859.  * Use better hash function.  *  * Revision 4.6  89/05/01  15:13:07  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/08/28  15:01:12  eggert  * Don't loop when writing error messages to a full filesystem.  * Flush stderr/stdout when mixing output.  * Yield exit status compatible with diff(1).  * Shrink stdio code size; allow cc -R; remove lint.  *  * Revision 4.4  87/12/18  11:44:47  narten  * fixed to use "varargs" in "fprintf"; this is required if it is to  * work on a SPARC machine such as a Sun-4  *  * Revision 4.3  87/10/18  10:37:18  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to version 4.1  *  * Revision 1.3  87/09/24  14:00:17  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:33  jenkins  * Port to suns  *  * Revision 4.1  83/03/25  18:12:51  wft  * Only changed $Header to $Id.  *  * Revision 3.3  82/12/10  16:22:37  wft  * Improved error messages, changed exit status on error to 1.  *  * Revision 3.2  82/11/28  21:27:10  wft  * Renamed ctab to map and included EOFILE; ctab is now a macro in rcsbase.h.  * Added fflsbuf(), fputs(), and fprintf(), which abort the RCS operations  * properly in case there is an IO-error (e.g., file system full).  *  * Revision 3.1  82/10/11  19:43:56  wft  * removed unused label out:;  * made sure all calls to getc() return into an integer, not a char.  */
end_comment

begin_comment
comment|/* #define LEXDB */
end_comment

begin_comment
comment|/* version LEXDB is for testing the lexical analyzer. The testprogram  * reads a stream of lexemes, enters the revision numbers into the  * hashtable, and prints the recognized tokens. Keywords are recognized  * as identifiers.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|lexId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|char
modifier|*
name|checkidentifier
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|errsay
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatsay
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lookup
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|startsay
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warnsay
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|nexthsh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*pointer to next hash entry, set by lookup*/
end_comment

begin_decl_stmt
name|enum
name|tokens
name|nexttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next token, set by nextlex                    */
end_comment

begin_decl_stmt
name|int
name|hshenter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*if true, next suitable lexeme will be entered */
end_comment

begin_comment
comment|/*into the symbol table. Handle with care.      */
end_comment

begin_decl_stmt
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next input character, initialized by Lexinit  */
end_comment

begin_decl_stmt
name|long
name|rcsline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current line-number of input		    */
end_comment

begin_decl_stmt
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*counter for errors                            */
end_comment

begin_decl_stmt
name|int
name|quietflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*indicates quiet mode                          */
end_comment

begin_decl_stmt
name|RILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*input file descriptor			    */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*file descriptor for echoing input             */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|foutptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy of frewrite, but 0 to suppress echo  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf
name|tokbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token buffer				    */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|NextString
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next token				    */
end_comment

begin_comment
comment|/*  * Our hash algorithm is h[0] = 0, h[i+1] = 4*h[i] + c,  * so hshsize should be odd.  * See B J McKenzie, R Harries& T Bell, Selecting a hashing algorithm,  * Software--practice& experience 20, 2 (Feb 1990), 209-224.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|hshsize
end_ifndef

begin_define
define|#
directive|define
name|hshsize
value|511
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|hshtab
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*hashtable			    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignored_phrases
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* have we ignored phrases in this RCS file? */
end_comment

begin_function
name|void
name|warnignore
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ignored_phrases
condition|)
block|{
name|ignored_phrases
operator|=
name|true
expr_stmt|;
name|rcswarn
argument_list|(
literal|"Unknown phrases like `%s ...;' are present."
argument_list|,
name|NextString
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lookup
parameter_list|(
name|str
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
comment|/* Function: Looks up the character string pointed to by str in the  * hashtable. If the string is not present, a new entry for it is created.  * In any case, the address of the corresponding hashtable entry is placed  * into nexthsh.  */
block|{
specifier|register
name|unsigned
name|ihash
decl_stmt|;
comment|/* index into hashtable */
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* calculate hash code */
name|sp
operator|=
name|str
expr_stmt|;
name|ihash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|ihash
operator|=
operator|(
name|ihash
operator|<<
literal|2
operator|)
operator|+
operator|*
name|sp
operator|++
expr_stmt|;
name|ihash
operator|%=
name|hshsize
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|hshtab
index|[
name|ihash
index|]
init|;
condition|;
name|p
operator|=
operator|&
name|n
operator|->
name|nexthsh
control|)
if|if
condition|(
operator|!
operator|(
name|n
operator|=
operator|*
name|p
operator|)
condition|)
block|{
comment|/* empty slot found */
operator|*
name|p
operator|=
name|n
operator|=
name|ftalloc
argument_list|(
expr|struct
name|hshentry
argument_list|)
expr_stmt|;
name|n
operator|->
name|num
operator|=
name|fstr_save
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|n
operator|->
name|nexthsh
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDB
name|VOID
name|printf
argument_list|(
literal|"\nEntered: %s at %u "
argument_list|,
name|str
argument_list|,
name|ihash
argument_list|)
decl_stmt|;
endif|#
directive|endif
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|n
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
comment|/* match found */
break|break;
name|nexthsh
operator|=
name|n
expr_stmt|;
name|NextString
operator|=
name|n
operator|->
name|num
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Lexinit
parameter_list|()
comment|/* Function: Initialization of lexical analyzer:  * initializes the hashtable,  * initializes nextc, nexttok if finptr != 0  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|hshsize
init|;
literal|0
operator|<=
operator|--
name|c
condition|;
control|)
block|{
name|hshtab
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|nerror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|finptr
condition|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
name|hshenter
operator|=
name|true
expr_stmt|;
name|ignored_phrases
operator|=
name|false
expr_stmt|;
name|rcsline
operator|=
literal|1
expr_stmt|;
name|bufrealloc
argument_list|(
operator|&
name|tokbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Iget_
argument_list|(
argument|finptr
argument_list|,
argument|nextc
argument_list|)
name|nextlex
argument_list|()
expr_stmt|;
comment|/*initial token*/
block|}
block|}
end_function

begin_function
name|void
name|nextlex
parameter_list|()
comment|/* Function: Reads the next token and sets nexttok to the next token code.  * Only if hshenter is set, a revision number is entered into the  * hashtable and a pointer to it is placed into nexthsh.  * This is useful for avoiding that dates are placed into the hashtable.  * For ID's and NUM's, NextString is set to the character string.  * Assumption: nextc contains the next character.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
index|]
operator|)
condition|)
block|{
default|default:
name|fatserror
argument_list|(
literal|"unknown character `%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDB
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note: falls into next case */
case|case
name|SPACE
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
continue|continue;
case|case
name|IDCHAR
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|d
operator|=
name|ID
expr_stmt|;
comment|/* fall into */
case|case
name|DIGIT
case|:
case|case
name|PERIOD
case|:
name|sp
operator|=
name|tokbuf
operator|.
name|string
expr_stmt|;
name|limit
operator|=
name|sp
operator|+
name|tokbuf
operator|.
name|size
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|IDCHAR
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|d
operator|=
name|ID
expr_stmt|;
comment|/* fall into */
case|case
name|DIGIT
case|:
case|case
name|PERIOD
case|:
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|sp
condition|)
name|sp
operator|=
name|bufenlarge
argument_list|(
operator|&
name|tokbuf
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|DIGIT
operator|||
name|d
operator|==
name|PERIOD
condition|)
block|{
name|d
operator|=
name|NUM
expr_stmt|;
if|if
condition|(
name|hshenter
condition|)
block|{
name|lookup
argument_list|(
name|tokbuf
operator|.
name|string
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NextString
operator|=
name|fstr_save
argument_list|(
name|tokbuf
operator|.
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBEGIN
case|:
comment|/* long string */
name|d
operator|=
name|STRING
expr_stmt|;
comment|/* note: only the initial SBEGIN has been read*/
comment|/* read the string, and reset nextc afterwards*/
break|break;
case|case
name|COLON
case|:
case|case
name|SEMI
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
break|break;
block|}
break|break;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|nexttok
operator|=
name|d
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eoflex
parameter_list|()
comment|/*  * Yield true if we look ahead to the end of the input, false otherwise.  * nextc becomes undefined at end of file.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|fout
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|SPACE
case|:
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|{uncache(fin);return true;}
argument_list|)
break|break;
block|}
if|if
condition|(
name|fout
condition|)
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fout
argument_list|)
block|}
block|}
end_function

begin_function
name|int
name|getlex
parameter_list|(
name|token
parameter_list|)
name|enum
name|tokens
name|token
decl_stmt|;
comment|/* Function: Checks if nexttok is the same as token. If so,  * advances the input by calling nextlex and returns true.  * otherwise returns false.  * Doesn't work for strings and keywords; loses the character string for ids.  */
block|{
if|if
condition|(
name|nexttok
operator|==
name|token
condition|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getkeyopt
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Function: If the current token is a keyword identical to key,  * advances the input by calling nextlex and returns true;  * otherwise returns false.  */
block|{
if|if
condition|(
name|nexttok
operator|==
name|ID
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|NextString
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* match found */
name|ffree1
argument_list|(
name|NextString
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|getkey
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Check that the current input token is a keyword identical to key,  * and advance the input by calling nextlex.  */
block|{
if|if
condition|(
operator|!
name|getkeyopt
argument_list|(
name|key
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"missing '%s' keyword"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getkeystring
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Check that the current input token is a keyword identical to key,  * and advance the input by calling nextlex; then look ahead for a string.  */
block|{
name|getkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttok
operator|!=
name|STRING
condition|)
name|fatserror
argument_list|(
literal|"missing string after '%s' keyword"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|getid
parameter_list|()
comment|/* Function: Checks if nexttok is an identifier. If so,  * advances the input by calling nextlex and returns a pointer  * to the identifier; otherwise returns 0.  * Treats keywords as identifiers.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|ID
condition|)
block|{
name|name
operator|=
name|NextString
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|name
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
comment|/* Function: Checks if nexttok is a number. If so,  * advances the input by calling nextlex and returns a pointer  * to the hashtable entry.  Otherwise returns 0.  * Doesn't work if hshenter is false.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|num
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|NUM
condition|)
block|{
name|num
operator|=
name|nexthsh
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|num
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|cbuf
name|getphrases
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* * Get a series of phrases that do not start with KEY.  Yield resulting buffer. * Stop when the next phrase starts with a token that is not an identifier, * or is KEY.  Copy input to foutptr if it is set.  Unlike ignorephrases(), * this routine assumes nextlex() has already been invoked before we start. */
block|{
name|declarecache
expr_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|kn
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
if|#
directive|if
name|large_memory
define|#
directive|define
name|savech_
parameter_list|(
name|c
parameter_list|)
value|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
name|struct
name|buf
name|b
decl_stmt|;
define|#
directive|define
name|savech_
parameter_list|(
name|c
parameter_list|)
value|{if (limit<=p)p=bufenlarge(&b,&limit); *p++ =(c);}
endif|#
directive|endif
if|if
condition|(
name|nexttok
operator|!=
name|ID
operator|||
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
name|clear_buf
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
else|else
block|{
name|warnignore
argument_list|()
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|#
directive|if
name|large_memory
name|r
operator|.
name|string
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|cacheptr
argument_list|()
operator|-
name|strlen
argument_list|(
name|NextString
argument_list|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|bufautobegin
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|b
argument_list|,
name|NextString
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|.
name|string
operator|+
name|strlen
argument_list|(
name|b
operator|.
name|string
argument_list|)
expr_stmt|;
name|limit
operator|=
name|b
operator|.
name|string
operator|+
name|b
operator|.
name|size
expr_stmt|;
endif|#
directive|endif
name|ffree1
argument_list|(
name|NextString
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|savech_
argument_list|(
argument|c
argument_list|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
name|fatserror
argument_list|(
literal|"unknown character `%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|COLON
case|:
case|case
name|DIGIT
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
case|case
name|PERIOD
case|:
case|case
name|SPACE
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
continue|continue;
case|case
name|SBEGIN
case|:
comment|/* long string */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
name|savech_
argument_list|(
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
default|default:
continue|continue;
case|case
name|SDELIM
case|:
break|break;
block|}
break|break;
block|}
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
break|break;
name|savech_
argument_list|(
argument|c
argument_list|)
block|}
continue|continue;
case|case
name|SEMI
case|:
name|cacheget_
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|NEWLN
condition|)
block|{
if|if
condition|(
name|frew
condition|)
name|aputc_
argument_list|(
name|c
argument_list|,
name|frew
argument_list|)
operator|++
name|rcsline
expr_stmt|;
name|savech_
argument_list|(
argument|c
argument_list|)
name|cacheget_
argument_list|(
argument|c
argument_list|)
block|}
if|#
directive|if
name|large_memory
name|r
operator|.
name|size
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|cacheptr
argument_list|()
operator|-
literal|1
operator|-
name|r
operator|.
name|string
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|SPACE
case|:
name|cacheget_
argument_list|(
argument|c
argument_list|)
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|frew
condition|)
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|frew
argument_list|)
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|Letter
condition|)
block|{
for|for
control|(
name|kn
operator|=
name|key
init|;
name|c
operator|&&
operator|*
name|kn
operator|==
name|c
condition|;
name|kn
operator|++
control|)
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
operator|!
operator|*
name|kn
condition|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|DIGIT
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
case|case
name|IDCHAR
case|:
case|case
name|PERIOD
case|:
break|break;
default|default:
name|nextc
operator|=
name|c
expr_stmt|;
name|NextString
operator|=
name|fstr_save
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|nexttok
operator|=
name|ID
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
goto|goto
name|returnit
goto|;
block|}
if|#
directive|if
operator|!
name|large_memory
block|{
specifier|register
name|char
specifier|const
modifier|*
name|ki
decl_stmt|;
for|for
control|(
name|ki
operator|=
name|key
init|;
name|ki
operator|<
name|kn
condition|;
control|)
name|savech_
argument_list|(
argument|*ki++
argument_list|)
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|returnit
label|:
empty_stmt|;
if|#
directive|if
operator|!
name|large_memory
return|return
name|bufremember
argument_list|(
operator|&
name|b
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|b
operator|.
name|string
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|readstring
parameter_list|()
comment|/* skip over characters until terminating single SDELIM        */
comment|/* If foutptr is set, copy every character read to foutptr.    */
comment|/* Does not advance nextlex at the end.                        */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|printstring
parameter_list|()
comment|/* Function: copy a string to stdout, until terminated with a single SDELIM.  * Does not advance nextlex at the end.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|fout
operator|=
name|stdout
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cacheget_
argument_list|(
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|cacheget_
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fout
argument_list|)
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|savestring
parameter_list|(
name|target
parameter_list|)
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
comment|/* Copies a string terminated with SDELIM from file finptr to buffer target.  * Double SDELIM is replaced with SDELIM.  * If foutptr is set, the string is also copied unchanged to foutptr.  * Does not advance nextlex at the end.  * Yield a copy of *TARGET, except with exact length.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|tp
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|limit
operator|=
name|tp
operator|+
name|target
operator|->
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|r
operator|.
name|string
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|r
operator|.
name|size
operator|=
name|tp
operator|-
name|r
operator|.
name|string
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
break|break;
block|}
if|if
condition|(
name|tp
operator|==
name|limit
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|checkidentifier
parameter_list|(
name|id
parameter_list|,
name|delimiter
parameter_list|,
name|dotok
parameter_list|)
specifier|register
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
specifier|register
name|int
name|dotok
decl_stmt|;
comment|/*   Function:  check whether the string starting at id is an   */
comment|/*		identifier and return a pointer to the delimiter*/
comment|/*		after the identifier.  White space, delim and 0 */
comment|/*              are legal delimiters.  Aborts the program if not*/
comment|/*              a legal identifier. Useful for checking commands*/
comment|/*		If !delim, the only delimiter is 0.		*/
comment|/*		Allow '.' in identifier only if DOTOK is set.   */
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
name|delim
init|=
name|delimiter
decl_stmt|;
name|int
name|isid
init|=
name|false
decl_stmt|;
name|temp
operator|=
name|id
expr_stmt|;
for|for
control|(
init|;
condition|;
name|id
operator|++
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|=
operator|*
name|id
argument_list|)
index|]
condition|)
block|{
case|case
name|IDCHAR
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|isid
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
name|DIGIT
case|:
continue|continue;
case|case
name|PERIOD
case|:
if|if
condition|(
name|dotok
condition|)
continue|continue;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|isid
operator|||
operator|(
name|c
operator|&&
operator|(
operator|!
name|delim
operator|||
operator|(
name|c
operator|!=
name|delim
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* append \0 to end of id before error message */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|id
operator|)
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|delim
condition|)
name|id
operator|++
expr_stmt|;
operator|*
name|id
operator|=
literal|'\0'
expr_stmt|;
name|faterror
argument_list|(
literal|"invalid %s `%s'"
argument_list|,
name|dotok
condition|?
literal|"identifier"
else|:
literal|"symbol"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|checkid
parameter_list|(
name|id
parameter_list|,
name|delimiter
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
block|{
return|return
name|checkidentifier
argument_list|(
name|id
argument_list|,
name|delimiter
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|checksym
parameter_list|(
name|sym
parameter_list|,
name|delimiter
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
block|{
return|return
name|checkidentifier
argument_list|(
name|sym
argument_list|,
name|delimiter
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|checksid
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
comment|/* Check whether the string ID is an identifier.  */
block|{
name|VOID
name|checkid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|checkssym
parameter_list|(
name|sym
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|VOID
name|checksym
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_define
define|#
directive|define
name|Iclose
parameter_list|(
name|f
parameter_list|)
value|fclose(f)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|maps_memory
end_if

begin_decl_stmt
specifier|static
name|int
name|Iclose
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|Iclose
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
name|tfree
argument_list|(
name|f
operator|->
name|base
argument_list|)
expr_stmt|;
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
return|return
name|fclose
argument_list|(
name|f
operator|->
name|stream
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|Iclose
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|Iclose
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
call|(
modifier|*
name|f
operator|->
name|deallocate
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
return|return
name|close
argument_list|(
name|f
operator|->
name|fd
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_map_fd
end_if

begin_decl_stmt
specifier|static
name|void
name|map_fd_deallocate
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|map_fd_deallocate
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|vm_deallocate
argument_list|(
name|task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|f
operator|->
name|base
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|base
argument_list|)
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|efaterror
argument_list|(
literal|"vm_deallocate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_mmap
end_if

begin_decl_stmt
specifier|static
name|void
name|mmap_deallocate
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mmap_deallocate
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|munmap
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|base
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"munmap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|read_deallocate
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|read_deallocate
parameter_list|(
name|f
parameter_list|)
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
name|tfree
argument_list|(
name|f
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|nothing_to_deallocate
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nothing_to_deallocate
parameter_list|(
name|f
parameter_list|)
name|RILE
modifier|*
name|f
decl_stmt|;
block|{     }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|large_memory
operator|&&
name|maps_memory
end_if

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|fd2_RILE
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|fd2_RILE
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|status
argument_list|)
else|#
directive|else
decl|static
name|RILE
modifier|*
name|fd2RILE
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RILE
modifier|*
name|fd2RILE
parameter_list|(
name|fd
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|type
decl_stmt|;
endif|#
directive|endif
name|int
name|fd
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|status
operator|=
operator|&
name|st
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
name|status
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|status
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is not a regular file"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VOID
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|#
directive|if
operator|!
operator|(
name|large_memory
operator|&&
name|maps_memory
operator|)
name|FILE
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|large_memory
return|return
name|stream
return|;
else|#
directive|else
define|#
directive|define
name|RILES
value|3
block|{
specifier|static
name|RILE
name|rilebuf
index|[
name|RILES
index|]
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|s
init|=
name|status
operator|->
name|st_size
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|status
operator|->
name|st_size
condition|)
name|faterror
argument_list|(
literal|"%s: too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|rilebuf
init|;
name|f
operator|->
name|base
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|f
operator|==
name|rilebuf
operator|+
name|RILES
condition|)
name|faterror
argument_list|(
literal|"too many RILEs"
argument_list|)
expr_stmt|;
if|#
directive|if
name|maps_memory
name|f
operator|->
name|deallocate
operator|=
name|nothing_to_deallocate
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|s
condition|)
block|{
specifier|static
name|unsigned
name|char
name|nothing
decl_stmt|;
name|f
operator|->
name|base
operator|=
operator|&
name|nothing
expr_stmt|;
comment|/* Any nonzero address will do.  */
block|}
else|else
block|{
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|has_map_fd
name|map_fd
argument_list|(
name|fd
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|(
name|vm_address_t
operator|*
operator|)
operator|&
name|f
operator|->
name|base
argument_list|,
name|TRUE
argument_list|,
operator|(
name|vm_size_t
operator|)
name|s
argument_list|)
expr_stmt|;
name|f
operator|->
name|deallocate
operator|=
name|map_fd_deallocate
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|has_mmap
if|if
condition|(
operator|!
name|f
operator|->
name|base
condition|)
block|{
name|catchmmapints
argument_list|()
expr_stmt|;
name|f
operator|->
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mmap
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|s
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAP_FAILED
define|#
directive|define
name|MAP_FAILED
value|(-1)
endif|#
directive|endif
if|if
condition|(
name|f
operator|->
name|base
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|MAP_FAILED
condition|)
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|#
directive|if
name|has_NFS
operator|&&
name|mmap_signal
comment|/* 				    * On many hosts, the superuser 				    * can mmap an NFS file it can't read. 				    * So access the first page now, and print 				    * a nice message if a bus error occurs. 				    */
name|readAccessFilenameBuffer
argument_list|(
name|name
argument_list|,
name|f
operator|->
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|f
operator|->
name|deallocate
operator|=
name|mmap_deallocate
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|f
operator|->
name|base
condition|)
block|{
name|f
operator|->
name|base
operator|=
name|tnalloc
argument_list|(
argument|unsigned char
argument_list|,
argument|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|maps_memory
block|{
comment|/* 			    * We can't map the file into memory for some reason. 			    * Read it into main memory all at once; this is 			    * the simplest substitute for memory mapping. 			    */
name|char
modifier|*
name|bufptr
init|=
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|base
decl_stmt|;
name|size_t
name|bufsiz
init|=
name|s
decl_stmt|;
do|do
block|{
name|ssize_t
name|r
init|=
name|read
argument_list|(
name|fd
argument_list|,
name|bufptr
argument_list|,
name|bufsiz
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|efaterror
argument_list|(
name|name
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* The file must have shrunk!  */
name|status
operator|->
name|st_size
operator|=
name|s
operator|-=
name|bufsiz
expr_stmt|;
name|bufsiz
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|bufptr
operator|+=
name|r
expr_stmt|;
name|bufsiz
operator|-=
name|r
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|bufsiz
condition|)
do|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|efaterror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|f
operator|->
name|deallocate
operator|=
name|read_deallocate
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|f
operator|->
name|ptr
operator|=
name|f
operator|->
name|base
expr_stmt|;
name|f
operator|->
name|lim
operator|=
name|f
operator|->
name|base
operator|+
name|s
expr_stmt|;
name|f
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|#
directive|if
operator|!
name|maps_memory
name|f
operator|->
name|readlim
operator|=
name|f
operator|->
name|base
expr_stmt|;
name|f
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
endif|#
directive|endif
name|if_advise_access
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|maps_memory
operator|&&
name|large_memory
end_if

begin_function
name|int
name|Igetmore
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|fread_type
name|r
decl_stmt|;
specifier|register
name|size_t
name|s
init|=
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|readlim
decl_stmt|;
if|if
condition|(
name|BUFSIZ
operator|<
name|s
condition|)
name|s
operator|=
name|BUFSIZ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|Fread
argument_list|(
name|f
operator|->
name|readlim
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|readlim
argument_list|)
argument_list|,
name|s
argument_list|,
name|f
operator|->
name|stream
argument_list|)
operator|)
condition|)
block|{
name|testIerror
argument_list|(
name|f
operator|->
name|stream
argument_list|)
expr_stmt|;
name|f
operator|->
name|lim
operator|=
name|f
operator|->
name|readlim
expr_stmt|;
comment|/* The file might have shrunk!  */
return|return
literal|0
return|;
block|}
name|f
operator|->
name|readlim
operator|+=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_madvise
operator|&&
name|has_mmap
operator|&&
name|large_memory
end_if

begin_function
name|void
name|advise_access
parameter_list|(
name|f
parameter_list|,
name|advice
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
name|int
name|advice
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|deallocate
operator|==
name|mmap_deallocate
condition|)
name|VOID
name|madvise
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|base
argument_list|)
argument_list|,
name|advice
argument_list|)
decl_stmt|;
comment|/* Don't worry if madvise fails; it's only advisory.  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|RILE
modifier|*
if|#
directive|if
name|large_memory
operator|&&
name|maps_memory
name|I_open
parameter_list|(
name|name
parameter_list|,
name|status
parameter_list|)
else|#
directive|else
function|Iopen
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|type
decl_stmt|;
endif|#
directive|endif
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
comment|/* Open NAME for reading, yield its descriptor, and set *STATUS.  */
block|{
name|int
name|fd
init|=
name|fdSafer
argument_list|(
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
if|#
directive|if
name|OPEN_O_BINARY
operator||
operator|(
name|strchr
argument_list|(
name|type
argument_list|,
literal|'b'
argument_list|)
condition|?
name|OPEN_O_BINARY
else|:
literal|0
operator|)
endif|#
directive|endif
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|large_memory
operator|&&
name|maps_memory
return|return
name|fd2_RILE
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|status
argument_list|)
return|;
else|#
directive|else
return|return
name|fd2RILE
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|status
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|Oerrloop
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Oerror
parameter_list|()
block|{
if|if
condition|(
name|Oerrloop
condition|)
name|exiterr
argument_list|()
expr_stmt|;
name|Oerrloop
operator|=
name|true
expr_stmt|;
name|efaterror
argument_list|(
literal|"output error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ieof
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ierror
parameter_list|()
block|{
name|efaterror
argument_list|(
literal|"input error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testIerror
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testOerror
parameter_list|(
name|o
parameter_list|)
name|FILE
modifier|*
name|o
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|o
argument_list|)
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ifclose
parameter_list|(
name|f
parameter_list|)
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|Iclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ofclose
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|fclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Izclose
parameter_list|(
name|p
parameter_list|)
name|RILE
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|Ifclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ozclose
parameter_list|(
name|p
parameter_list|)
name|FILE
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|Ofclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_function
name|void
name|testIeof
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|testIerror
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|Ieof
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Irewind
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|Orewind
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aflush
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eflush
parameter_list|()
block|{
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|Oerrloop
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|oflush
parameter_list|()
block|{
if|if
condition|(
name|fflush
argument_list|(
name|workstdout
condition|?
name|workstdout
else|:
name|stdout
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|Oerrloop
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatcleanup
parameter_list|(
name|already_newline
parameter_list|)
name|int
name|already_newline
decl_stmt|;
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|already_newline
operator|+
literal|"\n%s aborted\n"
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|startsay
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|oflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|cmdid
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s"
argument_list|,
name|cmdid
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|fatsay
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|startsay
argument_list|(
name|s
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|errsay
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|fatsay
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nerror
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warnsay
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|startsay
argument_list|(
name|s
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eerror
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|enerror
argument_list|(
name|errno
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enerror
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|errsay
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efaterror
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|enfaterror
argument_list|(
name|errno
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enfaterror
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|fatsay
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|error
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|error
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-fatal error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|errsay
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|rcserror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|rcserror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-fatal RCS file error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|errsay
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|workerror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|workerror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-fatal working file error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|errsay
argument_list|(
name|workname
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|fatserror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|fatserror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fatal RCS file syntax error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:%ld: "
argument_list|,
name|cmdid
argument_list|,
name|RCSname
argument_list|,
name|rcsline
argument_list|)
decl_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|faterror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|faterror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fatal error, terminates program after cleanup */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|fatsay
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|rcsfaterror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|rcsfaterror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fatal RCS file error, terminates program after cleanup */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|fatsay
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|warn
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|warn
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* warning */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|warnsay
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|rcswarn
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|rcswarn
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RCS file warning */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|warnsay
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|workwarn
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|workwarn
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* working file warning */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|warnsay
argument_list|(
name|workname
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|redefined
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|warn
argument_list|(
literal|"redefinition of -%c option"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|diagnose
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|diagnose
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prints a diagnostic message */
end_comment

begin_comment
comment|/* Unlike the other routines, it does not append a newline. */
end_comment

begin_comment
comment|/* This lets some callers suppress the newline, and is faster */
end_comment

begin_comment
comment|/* in implementations that flush stderr just at the end of each printf. */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|afputc
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
comment|/* afputc(c,f); acts like aputc_(c,f) but is smaller and slower.  */
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|f
argument_list|)
block|}
end_function

begin_function
name|void
name|aputs
parameter_list|(
name|s
parameter_list|,
name|iop
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
comment|/* Function: Put string s on file iop, abort on error.  */
block|{
if|#
directive|if
name|has_fputs
if|if
condition|(
name|fputs
argument_list|(
name|s
argument_list|,
name|iop
argument_list|)
operator|<
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
else|#
directive|else
name|awrite
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|iop
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
if|#
directive|if
name|has_prototypes
name|fvfprintf
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|char
specifier|const
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|fvfprintf
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
comment|/* like vfprintf, except abort program on error */
block|{
if|#
directive|if
name|has_vfprintf
if|if
condition|(
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
operator|<
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has__doprintf
name|_doprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has__doprnt
name|_doprnt
argument_list|(
name|format
argument_list|,
name|args
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
modifier|*
name|a
init|=
operator|(
name|int
operator|*
operator|)
name|args
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
name|Oerror
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_function
name|void
name|aprintf
parameter_list|(
name|FILE
modifier|*
name|iop
parameter_list|,
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|void aprintf
parameter_list|(
name|iop
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|FILE
modifier|*
name|iop
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* Function: formatted output. Same as fprintf in stdio,  * but aborts program on error  */
block|{
name|va_list
name|ap
decl_stmt|;
name|vararg_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|iop
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LEXDB
end_ifdef

begin_comment
comment|/* test program reading a stream of lexemes and printing the tokens.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|cmdid
operator|=
literal|"lextest"
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|aputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|finptr
operator|=
name|Iopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|FOPEN_R
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"can't open input file %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|eoflex
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|nexttok
condition|)
block|{
case|case
name|ID
case|:
name|VOID
name|printf
argument_list|(
literal|"ID: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
break|break;
case|case
name|NUM
case|:
if|if
condition|(
name|hshenter
condition|)
name|VOID
name|printf
argument_list|(
literal|"NUM: %s, index: %d"
argument_list|,
name|nexthsh
operator|->
name|num
argument_list|,
name|nexthsh
operator|-
name|hshtab
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"NUM, unentered: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
name|hshenter
operator|=
operator|!
name|hshenter
expr_stmt|;
comment|/*alternate between dates and numbers*/
break|break;
case|case
name|COLON
case|:
name|VOID
name|printf
argument_list|(
literal|"COLON"
argument_list|)
decl_stmt|;
break|break;
case|case
name|SEMI
case|:
name|VOID
name|printf
argument_list|(
literal|"SEMI"
argument_list|)
decl_stmt|;
break|break;
case|case
name|STRING
case|:
name|readstring
argument_list|()
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"STRING"
argument_list|)
decl_stmt|;
break|break;
case|case
name|UNKN
case|:
name|VOID
name|printf
argument_list|(
literal|"UNKN"
argument_list|)
decl_stmt|;
break|break;
default|default:
name|VOID
name|printf
argument_list|(
literal|"DEFAULT"
argument_list|)
decl_stmt|;
break|break;
block|}
name|VOID
name|printf
argument_list|(
literal|" | "
argument_list|)
decl_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|exitmain
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

