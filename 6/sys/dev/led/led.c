begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.org> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dev/led/led.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_struct
struct|struct
name|ledsc
block|{
name|LIST_ENTRY
argument_list|(
argument|ledsc
argument_list|)
name|list
expr_stmt|;
name|void
modifier|*
name|private
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|led_t
modifier|*
name|func
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|spec
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|time_t
name|last_second
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|led_unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|led_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|led_sx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ledsc
argument_list|)
name|led_list
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|led_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|led_ch
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_LED
argument_list|,
literal|"LED"
argument_list|,
literal|"LED driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|led_timeout
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ledsc
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&led_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ptr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|count
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|sc
operator|->
name|ptr
operator|==
literal|'.'
condition|)
block|{
name|sc
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|sc
operator|->
name|ptr
operator|==
literal|'U'
operator|||
operator|*
name|sc
operator|->
name|ptr
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|last_second
operator|==
name|time_second
condition|)
continue|continue;
name|sc
operator|->
name|last_second
operator|=
name|time_second
expr_stmt|;
name|sc
operator|->
name|func
argument_list|(
name|sc
operator|->
name|private
argument_list|,
operator|*
name|sc
operator|->
name|ptr
operator|==
literal|'U'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sc
operator|->
name|ptr
operator|>=
literal|'a'
operator|&&
operator|*
name|sc
operator|->
name|ptr
operator|<=
literal|'j'
condition|)
block|{
name|sc
operator|->
name|func
argument_list|(
name|sc
operator|->
name|private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|count
operator|=
operator|(
operator|*
name|sc
operator|->
name|ptr
operator|&
literal|0xf
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sc
operator|->
name|ptr
operator|>=
literal|'A'
operator|&&
operator|*
name|sc
operator|->
name|ptr
operator|<=
literal|'J'
condition|)
block|{
name|sc
operator|->
name|func
argument_list|(
name|sc
operator|->
name|private
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|count
operator|=
operator|(
operator|*
name|sc
operator|->
name|ptr
operator|&
literal|0xf
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sc
operator|->
name|ptr
operator|==
literal|'\0'
condition|)
name|sc
operator|->
name|ptr
operator|=
name|sc
operator|->
name|str
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|led_ch
argument_list|,
name|hz
operator|/
literal|10
argument_list|,
name|led_timeout
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|led_state
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb2
init|=
name|NULL
decl_stmt|;
name|struct
name|ledsc
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sb2
operator|=
name|sc
operator|->
name|spec
expr_stmt|;
name|sc
operator|->
name|spec
operator|=
name|sb
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|str
operator|=
name|sbuf_data
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ptr
operator|=
name|sc
operator|->
name|str
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|func
argument_list|(
name|sc
operator|->
name|private
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb2
operator|!=
name|NULL
condition|)
name|sbuf_delete
argument_list|(
name|sb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|led_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|512
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s2
operator|=
name|s
operator|=
name|malloc
argument_list|(
name|uio
operator|->
name|uio_resid
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|s
index|[
name|uio
operator|->
name|uio_resid
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|s
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|s2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Handle "on" and "off" immediately so people can flash really 	 * fast from userland if they want to 	 */
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|||
operator|*
name|s
operator|==
literal|'1'
condition|)
block|{
name|error
operator|=
name|led_state
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|*
name|s
operator|&
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
switch|switch
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Flash, default is 100msec/100msec. 		 * 'f2' sets 200msec/200msec etc. 		 */
case|case
literal|'f'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|>=
literal|'1'
operator|&&
name|s
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'1'
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%c%c"
argument_list|,
literal|'A'
operator|+
name|i
argument_list|,
literal|'a'
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Digits, flashes out numbers. 		 * 'd12' becomes -__________-_-______________________________ 		 */
case|case
literal|'d'
case|:
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
continue|continue;
name|i
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|10
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"Aa"
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"Aj"
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"jj"
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * String, roll your own. 		 * 'a-j' gives "off" for n/10 sec. 		 * 'A-J' gives "on" for n/10 sec. 		 * no delay before repeat 		 * 'sAaAbBa' becomes _-_--__- 		 */
case|case
literal|'s'
case|:
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<=
literal|'j'
operator|)
operator|||
operator|(
operator|*
name|s
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<=
literal|'J'
operator|)
operator|||
operator|*
name|s
operator|==
literal|'U'
operator|||
operator|*
name|s
operator|<=
literal|'u'
operator|||
operator|*
name|s
operator|==
literal|'.'
condition|)
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Morse. 		 * '.' becomes _- 		 * '-' becomes _--- 		 * ' ' becomes __ 		 * '\n' becomes ____ 		 * 1sec pause between repeats 		 * '... --- ...' -> _-_-_-___---_---_---___-_-_-__________ 		 */
case|case
literal|'m'
case|:
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"aA"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"aC"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"j"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|led_state
argument_list|(
name|dev
argument_list|,
name|sb
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|led_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_write
operator|=
name|led_write
block|,
operator|.
name|d_name
operator|=
literal|"LED"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|cdev
modifier|*
name|led_create
parameter_list|(
name|led_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ledsc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_LED
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|led_sx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|alloc_unr
argument_list|(
name|led_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|private
operator|=
name|priv
expr_stmt|;
name|sc
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|led_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|sc
operator|->
name|unit
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"led/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|led_sx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|led_list
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|led_ch
argument_list|,
name|hz
operator|/
literal|10
argument_list|,
name|led_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|led_list
argument_list|,
name|sc
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|func
argument_list|(
name|sc
operator|->
name|private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|dev
operator|)
return|;
block|}
end_function

begin_function
name|void
name|led_destroy
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ledsc
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|led_list
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|led_ch
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|led_mtx
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|led_sx
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|led_unit
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|spec
operator|!=
name|NULL
condition|)
name|sbuf_delete
argument_list|(
name|sc
operator|->
name|spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_LED
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|led_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|led_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|led_unit
operator|=
name|new_unrhdr
argument_list|(
literal|0
argument_list|,
name|minor2unit
argument_list|(
name|MAXMINOR
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|led_mtx
argument_list|,
literal|"LED mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|led_sx
argument_list|,
literal|"LED sx"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|led_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|leddev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|led_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

