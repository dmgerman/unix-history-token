begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Device tsfsdriver for Specialix I/O8+ multiport serial card.  *  * Copyright 2003 Frank Mayhar<frank@exit.com>  *  * Derived from the "si" driver by Peter Wemm<peter@netplex.com.au>, using  * lots of information from the Linux "specialix" driver by Roger Wolff  *<R.E.Wolff@BitWizard.nl> and from the Intel CD1865 "Intelligent Eight-  * Channel Communications Controller" datasheet.  Roger was also nice  * enough to answer numerous questions about stuff specific to the I/O8+  * not covered by the CD1865 datasheet.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notices, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notices, this list of conditions and the foljxowing disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN  * NO EVENT SHALL THE AUTHORS BE LIABLE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* Main tty driver routines for the Specialix I/O8+ device driver. */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_debug_sx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sx/cd1865.h>
end_include

begin_include
include|#
directive|include
file|<dev/sx/sxvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/sx/sx.h>
end_include

begin_include
include|#
directive|include
file|<dev/sx/sx_util.h>
end_include

begin_define
define|#
directive|define
name|SX_BROKEN_CTS
end_define

begin_decl_stmt
specifier|static
name|t_modem_t
name|sx_modem
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sx_start
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sx_stop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|t_close_t
name|sxclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_open_t
name|sxopen
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sx_shutdown_chan
parameter_list|(
name|struct
name|sx_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|t_break_t
name|sxbreak
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sxparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sx_modem_state
parameter_list|(
name|struct
name|sx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|card
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|sx_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DBG_ALL|DBG_PRINTF|DBG_MODEM|DBG_IOCTL|DBG_PARAM;e */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|sx_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sx_numunits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|sx_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See sx.h for these values.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|bdrates
index|[]
init|=
block|{
block|{
name|B75
block|,
name|CLK75
block|, }
block|,
block|{
name|B110
block|,
name|CLK110
block|, }
block|,
block|{
name|B150
block|,
name|CLK150
block|, }
block|,
block|{
name|B300
block|,
name|CLK300
block|, }
block|,
block|{
name|B600
block|,
name|CLK600
block|, }
block|,
block|{
name|B1200
block|,
name|CLK1200
block|, }
block|,
block|{
name|B2400
block|,
name|CLK2400
block|, }
block|,
block|{
name|B4800
block|,
name|CLK4800
block|, }
block|,
block|{
name|B9600
block|,
name|CLK9600
block|, }
block|,
block|{
name|B19200
block|,
name|CLK19200
block|, }
block|,
block|{
name|B38400
block|,
name|CLK38400
block|, }
block|,
block|{
name|B57600
block|,
name|CLK57600
block|, }
block|,
block|{
name|B115200
block|,
name|CLK115200
block|, }
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Approximate (rounded) character per second rates.  Translated at card  * initialization time to characters per clock tick.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_chartimes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|chartimes
index|[]
init|=
block|{
block|{
name|B75
block|,
literal|8
block|, }
block|,
block|{
name|B110
block|,
literal|11
block|, }
block|,
block|{
name|B150
block|,
literal|15
block|, }
block|,
block|{
name|B300
block|,
literal|30
block|, }
block|,
block|{
name|B600
block|,
literal|60
block|, }
block|,
block|{
name|B1200
block|,
literal|120
block|, }
block|,
block|{
name|B2400
block|,
literal|240
block|, }
block|,
block|{
name|B4800
block|,
literal|480
block|, }
block|,
block|{
name|B9600
block|,
literal|960
block|, }
block|,
block|{
name|B19200
block|,
literal|1920
block|, }
block|,
block|{
name|B38400
block|,
literal|3840
block|, }
block|,
block|{
name|B57600
block|,
literal|5760
block|, }
block|,
block|{
name|B115200
block|,
literal|11520
block|, }
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|in_interrupt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inside interrupt handler?          */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sx_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The flags we were configured with. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|sx_flags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_flags
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sx_pollrate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in addition to irq */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sx_realpoll
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll HW on timer */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|sx_pollrate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_pollrate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|sx_realpoll
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_realpoll
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|init_finished
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sx_poll
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * sxattach()  *	Initialize and attach the card, initialize the driver.  *  * Description:  *	This is the standard attach routine.  It initializes the I/O8+  *	card, identifies the chip on that card, then allocates and  *	initializes the various data structures used by the driver  *	itself.  */
end_comment

begin_function
name|int
name|sxattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|speedtab
modifier|*
name|spt
decl_stmt|;
name|int
name|chip
decl_stmt|,
name|x
decl_stmt|;
name|char
name|rev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sx_flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_numunits
operator|<
name|unit
operator|+
literal|1
condition|)
name|sx_numunits
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"sx%d: sxattach\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the CD1865.  */
if|if
condition|(
operator|(
name|error
operator|=
name|sx_init_cd1865
argument_list|(
name|sc
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * ID the chip: 	 * 	 * Chip           revcode   pkgtype 	 *                GFRCR     SRCR bit 7 	 * CD180 rev B    0x81      0 	 * CD180 rev C    0x82      0 	 * CD1864 rev A   0x82      1 	 * CD1865 rev A   0x83      1  -- Do not use!!! Does not work.  	 * CD1865 rev B   0x84      1 	 *       -- Thanks to Gwen Wang, Cirrus Logic (via Roger Wollf). 	 */
switch|switch
condition|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_GFRCR
argument_list|)
condition|)
block|{
case|case
literal|0x82
case|:
name|chip
operator|=
literal|1864
expr_stmt|;
name|rev
operator|=
literal|'A'
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|chip
operator|=
literal|1865
expr_stmt|;
name|rev
operator|=
literal|'A'
expr_stmt|;
break|break;
case|case
literal|0x84
case|:
name|chip
operator|=
literal|1865
expr_stmt|;
name|rev
operator|=
literal|'B'
expr_stmt|;
break|break;
case|case
literal|0x85
case|:
name|chip
operator|=
literal|1865
expr_stmt|;
name|rev
operator|=
literal|'C'
expr_stmt|;
break|break;
default|default:
name|chip
operator|=
operator|-
literal|1
expr_stmt|;
name|rev
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|chip
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"sx%d: Specialix I/O8+ CD%d processor rev %c\n"
argument_list|,
name|unit
argument_list|,
name|chip
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"sx%d: GFRCR 0x%02x\n"
operator|,
name|unit
operator|,
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_GFRCR
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLL
if|if
condition|(
name|sx_pollrate
operator|==
literal|0
condition|)
block|{
name|sx_pollrate
operator|=
name|POLLHZ
expr_stmt|;
comment|/* in addition to irq */
ifdef|#
directive|ifdef
name|REALPOLL
name|sx_realpoll
operator|=
literal|1
expr_stmt|;
comment|/* scan always */
endif|#
directive|endif
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_ports
operator|=
operator|(
expr|struct
name|sx_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sx_port
argument_list|)
operator|*
name|SX_NUMCHANS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ports
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sx%d:  No memory for sx_port structs!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ports
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sx_port
argument_list|)
operator|*
name|SX_NUMCHANS
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the channels. 	 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SX_NUMCHANS
condition|;
name|x
operator|++
control|)
block|{
name|tp
operator|=
name|ttyalloc
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|sx_start
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|sx_stop
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|sxparam
expr_stmt|;
name|tp
operator|->
name|t_break
operator|=
name|sxbreak
expr_stmt|;
name|tp
operator|->
name|t_open
operator|=
name|sxopen
expr_stmt|;
name|tp
operator|->
name|t_close
operator|=
name|sxclose
expr_stmt|;
name|sc
operator|->
name|sc_ports
index|[
name|x
index|]
operator|.
name|sp_tty
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_ports
index|[
name|x
index|]
operator|.
name|sp_state
operator|=
literal|0
expr_stmt|;
comment|/* internal flag */
name|sc
operator|->
name|sc_ports
index|[
name|x
index|]
operator|.
name|sp_chan
operator|=
name|x
expr_stmt|;
name|sc
operator|->
name|sc_ports
index|[
name|x
index|]
operator|.
name|sp_sc
operator|=
name|sc
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
operator|&
name|sc
operator|->
name|sc_ports
index|[
name|x
index|]
expr_stmt|;
name|ttycreate
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|MINOR_CALLOUT
argument_list|,
literal|"G%r%r"
argument_list|,
name|unit
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done_chartimes
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|spt
operator|=
name|chartimes
init|;
name|spt
operator|->
name|sp_speed
operator|!=
operator|-
literal|1
condition|;
name|spt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|spt
operator|->
name|sp_code
operator|/=
name|hz
operator|)
operator|==
literal|0
condition|)
name|spt
operator|->
name|sp_code
operator|=
literal|1
expr_stmt|;
block|}
name|done_chartimes
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sxopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|POLL
comment|/* 	 * We've now got a device, so start the poller. 	 */
if|if
condition|(
name|init_finished
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|sx_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|sx_pollrate
argument_list|)
expr_stmt|;
name|init_finished
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sxclose()  *	Do hard-close processing.  *  * Description:  *	Called on last close.  Handle DTR and RTS, do cleanup.  If we have  *	pending output in the FIFO, wait for it to clear before we shut down  *	the hardware.  */
end_comment

begin_function
specifier|static
name|void
name|sxclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|dcd
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_CLOSE
operator|,
literal|"sxhardclose sp_state:%x\n"
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
name|dcd
operator|=
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
name|SER_DCD
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|(
operator|!
name|tp
operator|->
name|t_actout
operator|&&
operator|!
name|dcd
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_init_in
operator|.
name|c_cflag
operator|&&
name|CLOCAL
operator|)
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_IER_TXRDY
condition|)
block|{
name|sx_cd1865_bic
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
name|sx_cd1865_bis
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
argument_list|,
name|CD1865_IER_TXEMPTY
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"sxclose"
argument_list|,
name|tp
operator|->
name|t_timeout
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|enable_intr
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sx_shutdown_chan
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Turn off the hardware.             */
name|tp
operator|->
name|t_actout
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_actout
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sxbreak
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sig
condition|)
block|{
comment|/* 		 * If there's already a break state change pending or 		 * we're already sending a break, just ignore this. 		 * Otherwise, just set our flag and start the 		 * transmitter. 		 */
if|if
condition|(
operator|!
name|SX_DOBRK
argument_list|(
name|pp
argument_list|)
operator|&&
operator|!
name|SX_BREAK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_DOBRK
expr_stmt|;
name|sx_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If a break is going, set our flag so we turn it off 		 * when we can, then kick the transmitter.  If a break 		 * isn't going and the flag is set, turn it off. 		 */
if|if
condition|(
name|SX_BREAK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_DOBRK
expr_stmt|;
name|sx_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SX_DOBRK
argument_list|(
name|pp
argument_list|)
condition|)
name|pp
operator|->
name|sp_state
operator|&=
name|SX_SS_DOBRK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * sxparam()  *	Configure line parameters.  *  * Description:  *	Configure the bitrate, wordsize, flow control and various other serial  *	port parameters for this line.  *  * Environment:  *	Called at spltty(); this may sleep, does not flush nor wait for drain,  *	nor block writes.  Caller must arrange this if it's important..  */
end_comment

begin_function
specifier|static
name|int
name|sxparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
init|=
name|tp
operator|->
name|t_sc
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ispd
init|=
literal|0
decl_stmt|;
name|int
name|ospd
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|,
name|cor1
decl_stmt|,
name|cor2
decl_stmt|,
name|cor3
decl_stmt|,
name|ier
decl_stmt|;
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_PARAM
operator|,
literal|"sxparam %x/%x\n"
operator|,
name|tp
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"OF 0x%x CF 0x%x IF 0x%x LF 0x%x\n"
operator|,
name|oflag
operator|,
name|cflag
operator|,
name|iflag
operator|,
name|lflag
operator|)
argument_list|)
expr_stmt|;
comment|/* If the port isn't hung up... */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
comment|/* Convert bit rate to hardware divisor values. */
name|ospd
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|bdrates
argument_list|)
expr_stmt|;
name|ispd
operator|=
name|t
operator|->
name|c_ispeed
condition|?
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|bdrates
argument_list|)
else|:
name|ospd
expr_stmt|;
comment|/* We only allow standard bit rates. */
if|if
condition|(
name|ospd
operator|<
literal|0
operator|||
name|ispd
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Block other activity.              */
name|cor1
operator|=
literal|0
expr_stmt|;
name|cor2
operator|=
literal|0
expr_stmt|;
name|cor3
operator|=
literal|0
expr_stmt|;
name|ier
operator|=
name|CD1865_IER_RXD
operator||
name|CD1865_IER_CD
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* We don't yet handle this stuff. */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
comment|/* Breaks */
name|val
operator||=
name|BR_IGN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|BRKINT
condition|)
comment|/* Interrupt on break? */
name|val
operator||=
name|BR_INT
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|PARMRK
condition|)
comment|/* Parity mark? */
name|val
operator||=
name|BR_PARMRK
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
comment|/* 	 * If the device isn't hung up, set the serial port bitrates. 	 */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_RBPRH
operator||
name|SX_EI
argument_list|,
operator|(
name|ispd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_RBPRL
operator||
name|SX_EI
argument_list|,
name|ispd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TBPRH
operator||
name|SX_EI
argument_list|,
operator|(
name|ospd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TBPRL
operator||
name|SX_EI
argument_list|,
name|ospd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
comment|/* Two stop bits?                     */
name|cor1
operator||=
name|CD1865_COR1_2SB
expr_stmt|;
comment|/* Yep.                              */
comment|/* 	 * Parity settings. 	 */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
comment|/* Parity enabled?                    */
name|val
operator|=
name|CD1865_COR1_NORMPAR
expr_stmt|;
comment|/* Turn on normal parity handling. */
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
comment|/* Odd Parity?                        */
name|val
operator||=
name|CD1865_COR1_ODDP
expr_stmt|;
comment|/* Turn it on.               */
block|}
else|else
name|val
operator|=
name|CD1865_COR1_NOPAR
expr_stmt|;
comment|/* Turn off parity detection.        */
name|cor1
operator||=
name|val
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNPAR
condition|)
comment|/* Ignore chars with parity errors?   */
name|cor1
operator||=
name|CD1865_COR1_IGNORE
expr_stmt|;
comment|/* 	 * Set word length. 	 */
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS8
operator|)
operator|==
name|CS8
condition|)
name|val
operator|=
name|CD1865_COR1_8BITS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS7
operator|)
operator|==
name|CS7
condition|)
name|val
operator|=
name|CD1865_COR1_7BITS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS6
operator|)
operator|==
name|CS6
condition|)
name|val
operator|=
name|CD1865_COR1_6BITS
expr_stmt|;
else|else
name|val
operator|=
name|CD1865_COR1_5BITS
expr_stmt|;
name|cor1
operator||=
name|val
expr_stmt|;
comment|/* 	 * Enable hardware RTS/CTS flow control.  We can handle output flow 	 * control at any time, since we have a dedicated CTS pin. 	 * Unfortunately, though, the RTS pin is really the DTR pin.  This 	 * means that we can't ever use the automatic input flow control of 	 * the CD1865 and that we can only use the pin for input flow 	 * control when it's wired as RTS. 	 */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
comment|/* Output flow control...             */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_OFLOW
expr_stmt|;
ifdef|#
directive|ifdef
name|SX_BROKEN_CTS
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MSVR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_MSVR_CTS
condition|)
block|{
name|enable_intr
argument_list|()
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_OSTOP
expr_stmt|;
block|}
else|else
block|{
name|enable_intr
argument_list|()
expr_stmt|;
block|}
name|ier
operator||=
name|CD1865_IER_CTS
expr_stmt|;
else|#
directive|else
comment|/* SX_BROKEN_CTS */
name|cor2
operator||=
name|CD1865_COR2_CTSAE
expr_stmt|;
comment|/* Set CTS automatic enable.       */
endif|#
directive|endif
comment|/* SX_BROKEN_CTS */
block|}
else|else
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_OFLOW
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
operator|&&
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
condition|)
comment|/* Input flow control.      */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_IFLOW
expr_stmt|;
else|else
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IFLOW
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|cor2
operator||=
name|CD1865_COR2_IXM
expr_stmt|;
comment|/* Any character is XON.      */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
block|{
name|cor2
operator||=
name|CD1865_COR2_TXIBE
expr_stmt|;
comment|/* Enable inband flow control.*/
name|cor3
operator||=
name|CD1865_COR3_FCT
operator||
name|CD1865_COR3_SCDE
expr_stmt|;
comment|/* Hide from host */
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
comment|/* Sel chan.*/
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_SCHR1
operator||
name|SX_EI
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_SCHR2
operator||
name|SX_EI
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_SCHR3
operator||
name|SX_EI
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_SCHR4
operator||
name|SX_EI
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * All set, now program the hardware. 	 */
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
comment|/* Select channel.  */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_COR1
operator||
name|SX_EI
argument_list|,
name|cor1
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_COR2
operator||
name|SX_EI
argument_list|,
name|cor2
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_COR3
operator||
name|SX_EI
argument_list|,
name|cor3
argument_list|)
expr_stmt|;
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CCR
operator||
name|SX_EI
argument_list|,
name|CD1865_CCR_CORCHG1
operator||
name|CD1865_CCR_CORCHG2
operator||
name|CD1865_CCR_CORCHG3
argument_list|)
expr_stmt|;
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
condition|)
name|val
operator|=
name|SER_DTR
expr_stmt|;
else|else
name|val
operator|=
name|SER_RTS
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
comment|/* Clear DTR/RTS if we're hung up.    */
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
comment|/* If we were hung up, we may have to */
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Last, enable the receiver and transmitter and turn on the 	 * interrupts we need (receive, carrier-detect and possibly CTS 	 * (iff we're built with SX_BROKEN_CTS and CCTS_OFLOW is on). 	 */
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
comment|/* Select channel.  */
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CCR
operator||
name|SX_EI
argument_list|,
name|CD1865_CCR_RXEN
operator||
name|CD1865_CCR_TXEN
argument_list|)
expr_stmt|;
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|ier
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"sxparam out\n"
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sx_shutdown_chan()  *	Shut down a channel on the I/O8+.  *  * Description:  *	This does all hardware shutdown processing for a channel on the I/O8+.  *	It is called from sxhardclose().  We reset the channel and turn off  *	interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|sx_shutdown_chan
parameter_list|(
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator|,
literal|"sx_shutdown_chan %x %x\n"
operator|,
name|pp
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
comment|/* Select channel.        */
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for any commands to complete. */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CCR
argument_list|,
name|CD1865_CCR_SOFTRESET
argument_list|)
expr_stmt|;
comment|/* Reset chan.   */
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.          */
name|enable_intr
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_modem()  *	Set/Get state of modem control lines.  *  * Description:  *	Get and set the state of the modem control lines that we have available  *	on the I/O8+.  The only lines we are guaranteed to have are CD and CTS.  *	We have DTR if the "DTR/RTS pin is DTR" flag is set, otherwise we have  *	RTS through the DTR pin.  */
end_comment

begin_function
specifier|static
name|int
name|sx_modem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sigon
parameter_list|,
name|int
name|sigoff
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Block interrupts.                  */
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
comment|/* Select our port. */
name|x
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MSVR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
comment|/* Get the current signals.  */
ifdef|#
directive|ifdef
name|SX_DEBUG
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_MODEM
operator|,
literal|"sx_modem MSVR 0x%x, CCSR %x GIVR %x SRSR %x\n"
operator|,
name|x
operator|,
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_CCSR
operator||
name|SX_EI
argument_list|)
operator|,
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_GIVR
operator||
name|SX_EI
argument_list|)
operator|,
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_SRSR
operator||
name|SX_EI
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* Allow other interrupts.            */
if|if
condition|(
name|sigon
operator|==
literal|0
operator|&&
name|sigoff
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
name|CD1865_MSVR_CD
operator|)
operator|==
literal|0
condition|)
name|sigon
operator||=
name|SER_DCD
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|CD1865_MSVR_CTS
operator|)
operator|==
literal|0
condition|)
name|sigon
operator||=
name|SER_CTS
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|CD1865_MSVR_DTR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
condition|)
comment|/* Odd pin is DTR?         */
name|sigon
operator||=
name|SER_DTR
expr_stmt|;
comment|/* Report DTR.     */
else|else
comment|/* Odd pin is RTS.         */
name|sigon
operator||=
name|SER_RTS
expr_stmt|;
comment|/* Report RTS.     */
block|}
return|return
operator|(
name|sigon
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sigon
operator|&
name|SER_RTS
operator|&&
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|)
operator|||
operator|(
name|sigon
operator|&
name|SER_DTR
operator|&&
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|)
condition|)
name|x
operator|&=
operator|~
name|CD1865_MSVR_DTR
expr_stmt|;
if|if
condition|(
operator|(
name|sigoff
operator|&
name|SER_RTS
operator|&&
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|)
operator|||
operator|(
name|sigoff
operator|&
name|SER_DTR
operator|&&
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|)
condition|)
name|x
operator||=
name|CD1865_MSVR_DTR
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
comment|/* 	 * Set the new modem signals. 	 */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_MSVR
operator||
name|SX_EI
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_comment
comment|/*  * sx_poll()  * 	Poller to catch missed interrupts.  *  * Description:  *	Only used if we're complied with POLL.  This routine is called every  *	sx_pollrate ticks to check for missed interrupts.  We check each card  *	in the system; if we missed an interrupt, we complain about each one  *	and later call sx_intr() to handle them.  */
end_comment

begin_function
specifier|static
name|void
name|sx_poll
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|int
name|card
decl_stmt|,
name|lost
decl_stmt|,
name|oldspl
decl_stmt|,
name|chan
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_POLL
operator|,
literal|"sx_poll\n"
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_interrupt
condition|)
goto|goto
name|out
goto|;
name|lost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|card
operator|=
literal|0
init|;
name|card
operator|<
name|sx_numunits
condition|;
name|card
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|sx_devclass
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_SRSR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_SRSR_REQint
condition|)
block|{
name|printf
argument_list|(
literal|"sx%d: lost interrupt\n"
argument_list|,
name|card
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
block|}
comment|/* 		 * Gripe about no input flow control. 		 */
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|SX_NUMCHANS
condition|;
name|pp
operator|++
operator|,
name|chan
operator|++
control|)
block|{
name|pp
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ports
index|[
name|chan
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sp_delta_overflows
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sx%d: %d tty level buffer overflows\n"
argument_list|,
name|card
argument_list|,
name|pp
operator|->
name|sp_delta_overflows
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lost
operator|||
name|sx_realpoll
condition|)
name|sx_intr
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* call intr with fake vector */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|sx_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|sx_pollrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POLL */
end_comment

begin_comment
comment|/*  * sx_transmit()  *	Handle transmit request interrupt.  *  * Description:  *	This routine handles the transmit request interrupt from the CD1865  *	chip on the I/O8+ card.  The CD1865 interrupts us for a transmit  *	request under two circumstances:  When the last character in the  *	transmit FIFO is sent and the channel is ready for more characters  *	("transmit ready"), or when the last bit of the last character in the  *	FIFO is actually transmitted ("transmit empty").  In the former case,  *	we just pass processing off to sx_start() (via the line discipline)  *	to queue more characters.  In the latter case, we were waiting for  *	the line to flush in sxhardclose() so we need to wake the sleeper.  */
end_comment

begin_function
specifier|static
name|void
name|sx_transmit
parameter_list|(
name|struct
name|sx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|card
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* 	 * Let others know what we're doing. 	 */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_IXMIT
expr_stmt|;
comment|/* 	 * Get the service request enable register to see what we're waiting 	 * for. 	 */
name|flags
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_SRER
operator||
name|SX_EI
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_TRANSMIT
operator|,
literal|"sx_xmit %x SRER %x\n"
operator|,
name|tp
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * "Transmit ready."  The transmit FIFO is empty (but there are still 	 * two characters being transmitted), so we need to tell the line 	 * discipline to send more. 	 */
if|if
condition|(
name|flags
operator|&
name|CD1865_IER_TXRDY
condition|)
block|{
name|ttyld_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IXMIT
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_TRANSMIT
operator|,
literal|"sx_xmit TXRDY out\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * "Transmit empty."  The transmitter is completely empty; turn off the 	 * service request and wake up the guy in sxhardclose() who is waiting 	 * for this. 	 */
if|if
condition|(
name|flags
operator|&
name|CD1865_IER_TXEMPTY
condition|)
block|{
name|flags
operator|&=
operator|~
name|CD1865_IER_TXEMPTY
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_SRER
operator||
name|SX_EI
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IXMIT
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_TRANSMIT
operator|,
literal|"sx_xmit out\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_modem_state()  *	Handle modem state-change request interrupt.  *  * Description:  *	Handles changed modem signals CD and CTS.  We pass the CD change  *	off to the line discipline.  We can't handle DSR since there isn't a  *	pin for it.  */
end_comment

begin_function
specifier|static
name|void
name|sx_modem_state
parameter_list|(
name|struct
name|sx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|card
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
name|mcr
decl_stmt|;
comment|/* 	 * Let others know what we're doing. 	 */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_IMODEM
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* Grab the Modem Change Register. */
name|mcr
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MCR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_MODEM_STATE
operator|,
literal|"sx_mdmst %x st %x sp %x mcr %x\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|mcr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|CD1865_MCR_CDCHG
condition|)
block|{
comment|/* CD changed?                        */
if|if
condition|(
operator|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MSVR
argument_list|)
operator|&
name|CD1865_MSVR_CD
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr on t_line %d\n"
operator|,
name|tp
operator|->
name|t_line
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CD went down.                      */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr off\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SX_BROKEN_CTS
if|if
condition|(
name|mcr
operator|&
name|CD1865_MCR_CTSCHG
condition|)
block|{
comment|/* CTS changed?                       */
if|if
condition|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MSVR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_MSVR_CTS
condition|)
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_OSTOP
expr_stmt|;
name|sx_cd1865_bic
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_OSTOP
expr_stmt|;
name|sx_cd1865_bis
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SX_BROKEN_CTS */
comment|/* Clear state-change indicator bits. */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_MCR
operator||
name|SX_EI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IMODEM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_receive()  *	Handle receive request interrupt.  *  * Description:  *	Handle a receive request interrupt from the CD1865.  This is just a  *	standard "we have characters to process" request, we don't have to  *	worry about exceptions like BREAK and such.  Exceptions are handled  *	by sx_receive_exception().  */
end_comment

begin_function
specifier|static
name|void
name|sx_receive
parameter_list|(
name|struct
name|sx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|card
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
name|count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
specifier|static
name|unsigned
name|char
name|sx_rxbuf
index|[
name|SX_BUFFERSIZE
index|]
decl_stmt|;
comment|/* input staging area */
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv %x st %x sp %x\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Let others know what we're doing. 	 */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_IRCV
expr_stmt|;
comment|/* 	 * How many characters are waiting for us? 	 */
name|count
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_RDCR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* None?  Bail.                       */
return|return;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_receive count %d\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pull the characters off the card into our local buffer, then 	 * process that. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|sx_rxbuf
index|[
name|i
index|]
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_RDR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
comment|/* 	 * If we're not open and connected, bail. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IRCV
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv not open\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the tty input buffers are blocked and we have an RTS pin, 	 * drop RTS and bail. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|&&
name|SX_IFLOW
argument_list|(
name|pp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_RTS
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_ISTOP
expr_stmt|;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IRCV
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv BYPASS\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Avoid the grotesquely inefficient lineswitch routine 		 * (ttyinput) in "raw" mode. It usually takes about 450 		 * instructions (that's without canonical processing or 		 * echo!).  slinput is reasonably fast (usually 40 		 * instructions plus call overhead). 		 */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|count
operator|>=
name|SX_I_HIGH_WATER
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
block|{
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv block\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tk_nin
operator|+=
name|count
expr_stmt|;
name|tk_rawcc
operator|+=
name|count
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|count
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sx_rxbuf
argument_list|,
name|count
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * If we were stopped and need to start again because of this 		 * receive, kick the output routine to get things going again. 		 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|sx_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv l_rint\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * It'd be nice to not have to go through the function call 		 * overhead for each char here.  It'd be nice to block input 		 * it, saving a loop here and the call/return overhead. 		 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|x
operator|++
control|)
block|{
name|i
operator|=
name|sx_rxbuf
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|pp
operator|->
name|sp_delta_overflows
operator|++
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IRCV
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE
operator|,
literal|"sx_rcv out\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_receive_exception()  *	Handle receive exception request interrupt processing.  *  * Description:  *	Handle a receive exception request interrupt from the CD1865.  *	Possible exceptions include BREAK, overrun, receiver timeout  *	and parity and frame errors.  We don't handle receiver timeout,  *	we just complain.  The rest are passed to ttyinput().  */
end_comment

begin_function
specifier|static
name|void
name|sx_receive_exception
parameter_list|(
name|struct
name|sx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|card
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|char
name|st
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|isopen
decl_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* 	 * Let others know what we're doing. 	 */
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_IRCVEXC
expr_stmt|;
comment|/* 	 * Check to see whether we should receive characters. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
name|isopen
operator|=
literal|1
expr_stmt|;
else|else
name|isopen
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_RCSR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
comment|/* Get the character status.*/
name|ch
operator|=
operator|(
name|int
operator|)
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_RDR
operator||
name|SX_EI
argument_list|)
expr_stmt|;
comment|/* Get the character.   */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE_EXC
operator|,
literal|"sx_rexc %x st %x sp %x st 0x%x ch 0x%x ('%c')\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|st
operator|,
name|ch
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
comment|/* If there's no status or the tty isn't open, bail. */
if|if
condition|(
operator|!
name|st
operator|||
operator|!
name|isopen
condition|)
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IRCVEXC
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_RECEIVE_EXC
operator|,
literal|"sx_rexc not open\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|st
operator|&
name|CD1865_RCSR_TOUT
condition|)
comment|/* Receiver timeout; just complain.   */
name|printf
argument_list|(
literal|"sx%d: port %d: Receiver timeout.\n"
argument_list|,
name|card
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_RCSR_BREAK
condition|)
name|ch
operator||=
name|TTY_BI
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_RCSR_PE
condition|)
name|ch
operator||=
name|TTY_PE
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_RCSR_FE
condition|)
name|ch
operator||=
name|TTY_FE
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_RCSR_OE
condition|)
name|ch
operator||=
name|TTY_OE
expr_stmt|;
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_IRCVEXC
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_intr()  *	Field interrupts from the I/O8+.  *  * Description:  * The interrupt handler polls ALL ports on ALL adapters each time  * it is called.  */
end_comment

begin_function
name|void
name|sx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
name|int
name|card
decl_stmt|;
name|unsigned
name|char
name|ack
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|arg
operator|==
name|NULL
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"sx_intr\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_interrupt
condition|)
return|return;
name|in_interrupt
operator|=
literal|1
expr_stmt|;
comment|/* 	 * When we get an int we poll all the channels and do ALL pending 	 * work, not just the first one we find. This allows all cards to 	 * share the same vector. 	 * 	 * On the other hand, if we're sharing the vector with something 	 * that's not an I/O8+, we may be making extra work for ourselves. 	 */
for|for
control|(
name|card
operator|=
literal|0
init|;
name|card
operator|<
name|sx_numunits
condition|;
name|card
operator|++
control|)
block|{
name|unsigned
name|char
name|st
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|sx_devclass
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Check the Service Request Status Register to see who 		 * interrupted us and why.  May be a receive, transmit or 		 * modem-signal-change interrupt.  Reading the appropriate 		 * Request Acknowledge Register acknowledges the request and 		 * gives us the contents of the Global Service Vector Register, 		 * which in a daisy-chained configuration (not ours) uniquely 		 * identifies the particular CD1865 and gives us the request 		 * type.  We mask off the ID part and use the rest. 		 * 		 * From the CD1865 specs, it appears that only one request can 		 * happen at a time, but in testing it's pretty obvious that 		 * the specs lie.  Or perhaps we're just slow enough that the 		 * requests pile up.  Regardless, if we try to process more 		 * than one at a time without clearing the previous request 		 * (writing zero to EOIR) first, we hang the card.  Thus the 		 * "else if" logic here. 		 */
while|while
condition|(
operator|(
name|st
operator|=
operator|(
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_SRSR
operator||
name|SX_EI
argument_list|)
operator|)
operator|&
name|CD1865_SRSR_REQint
operator|)
condition|)
block|{
comment|/* 			 * Transmit request interrupt. 			 */
if|if
condition|(
name|st
operator|&
name|CD1865_SRSR_TREQint
condition|)
block|{
name|ack
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_TRAR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_GIVR_ITMASK
expr_stmt|;
name|pp
operator|=
name|sx_int_port
argument_list|(
name|sc
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
comment|/* Bad channel.               */
goto|goto
name|skip
goto|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_INTR
expr_stmt|;
comment|/* In interrupt.  */
if|if
condition|(
name|ack
operator|==
name|CD1865_GIVR_IT_TX
condition|)
name|sx_transmit
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|card
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sx%d: Bad transmit ack 0x%02x.\n"
argument_list|,
name|card
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Modem signal change request interrupt. 			 */
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_SRSR_MREQint
condition|)
block|{
name|ack
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_MRAR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_GIVR_ITMASK
expr_stmt|;
name|pp
operator|=
name|sx_int_port
argument_list|(
name|sc
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
comment|/* Bad channel.               */
goto|goto
name|skip
goto|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_INTR
expr_stmt|;
comment|/* In interrupt.  */
if|if
condition|(
name|ack
operator|==
name|CD1865_GIVR_IT_MODEM
condition|)
name|sx_modem_state
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|card
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sx%d: Bad modem ack 0x%02x.\n"
argument_list|,
name|card
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Receive request interrupt. 			 */
elseif|else
if|if
condition|(
name|st
operator|&
name|CD1865_SRSR_RREQint
condition|)
block|{
name|ack
operator|=
name|sx_cd1865_in
argument_list|(
name|sc
argument_list|,
name|CD1865_RRAR
operator||
name|SX_EI
argument_list|)
operator|&
name|CD1865_GIVR_ITMASK
expr_stmt|;
name|pp
operator|=
name|sx_int_port
argument_list|(
name|sc
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
comment|/* Bad channel.               */
goto|goto
name|skip
goto|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_INTR
expr_stmt|;
comment|/* In interrupt.  */
if|if
condition|(
name|ack
operator|==
name|CD1865_GIVR_IT_RCV
condition|)
name|sx_receive
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|card
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ack
operator|==
name|CD1865_GIVR_IT_REXC
condition|)
name|sx_receive_exception
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|card
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sx%d: Bad receive ack 0x%02x.\n"
argument_list|,
name|card
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * None of the above; this is a "can't happen," but 			 * you never know... 			 */
else|else
block|{
name|printf
argument_list|(
literal|"sx%d: Bad service request 0x%02x.\n"
argument_list|,
name|card
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_INTR
expr_stmt|;
name|skip
label|:
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_EOIR
operator||
name|SX_EI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* EOI.      */
block|}
comment|/* while (st& CD1865_SRSR_REQint)            */
block|}
comment|/* for (card = 0; card< sx_numunits; card++) */
name|in_interrupt
operator|=
literal|0
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|arg
operator|==
name|NULL
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"sx_intr out\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sx_start()  *	Handle transmit and state-change stuff.  *  * Description:  *	This is part of the line discipline processing; at various points in  *	the line discipline he calls ttstart() which calls the oproc routine,  *	which is this function.  We're called by the line discipline to start  *	data transmission and to change signal states (for RTS flow control).  *	We're also called by this driver to perform line-breaks and to actually  *	do the data transmission.   *	We can only fill the FIFO from interrupt since the card only makes it  *	available to us during a service request such as TXRDY; this only  *	happens at interrupt.  *  *	All paths through this code call ttwwakeup().  */
end_comment

begin_function
specifier|static
name|void
name|sx_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|struct
name|clist
modifier|*
name|qp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|count
init|=
name|CD1865_TFIFOSZ
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|qp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_START
operator|,
literal|"sx_start %x st %x sp %x cc %d\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|qp
operator|->
name|c_cc
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we're stopped, just wake up sleepers and get out. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"sx_start out\n"
operator|,
name|tp
operator|->
name|t_state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
comment|/* 	 * If we're not transmitting, we may have been called to crank up the 	 * transmitter and start things rolling or we may have been called to 	 * get a bit of tty state.  If the latter, handle it.  Either way, if 	 * we have data to transmit, turn on the transmit-ready interrupt, 	 * set the XMIT flag and we're done.  As soon as we allow interrupts 	 * the card will interrupt for the first chunk of data.  Note that 	 * we don't mark the tty as busy until we are actually sending data 	 * and then only if we have more than will fill the FIFO.  If there's 	 * no data to transmit, just handle the tty state. 	 */
if|if
condition|(
operator|!
name|SX_XMITTING
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* 		 * If we were flow-controlled and input is no longer blocked, 		 * raise RTS if we can. 		 */
if|if
condition|(
name|SX_ISTOP
argument_list|(
name|pp
argument_list|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|&&
name|SX_IFLOW
argument_list|(
name|pp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
name|SER_RTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_ISTOP
expr_stmt|;
block|}
comment|/* 		 * If input is blocked, drop RTS if we can and set our flag. 		 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|SX_DTRPIN
argument_list|(
name|pp
argument_list|)
operator|&&
name|SX_IFLOW
argument_list|(
name|pp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sx_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_RTS
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_ISTOP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
operator|&&
operator|!
name|SX_OSTOP
argument_list|(
name|pp
argument_list|)
operator|)
operator|||
name|SX_DOBRK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
name|sx_cd1865_bis
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_XMIT
expr_stmt|;
block|}
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"sx_start out B st %x sp %x cc %d\n"
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|qp
operator|->
name|c_cc
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we weren't called from an interrupt or it wasn't a transmit 	 * interrupt, we've done all we need to do.  Everything else is done 	 * in the transmit interrupt. 	 */
if|if
condition|(
operator|!
name|SX_INTR
argument_list|(
name|pp
argument_list|)
operator|||
operator|!
name|SX_IXMIT
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"sx_start out X\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We're transmitting.  If the clist is empty and we don't have a break 	 * to send, turn off transmit-ready interrupts, and clear the XMIT 	 * flag.  Mark the tty as no longer busy, in case we haven't done 	 * that yet. A future call to sxwrite() with more characters will 	 * start up the process once more. 	 */
if|if
condition|(
name|qp
operator|->
name|c_cc
operator|==
literal|0
operator|&&
operator|!
name|SX_DOBRK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
comment|/*		sx_cd1865_out(sc, CD1865_CAR|SX_EI, pp->sp_chan);*/
name|sx_cd1865_bic
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_XMIT
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"sx_start out E st %x sp %x\n"
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|disable_intr
argument_list|()
expr_stmt|;
comment|/* 	 * If we have a BREAK state-change pending, handle it.  If we aren't 	 * sending a break, start one.  If we are, turn it off. 	 */
if|if
condition|(
name|SX_DOBRK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|count
operator|-=
literal|2
expr_stmt|;
comment|/* Account for escape chars in FIFO.  */
if|if
condition|(
name|SX_BREAK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* Doing break, stop it.              */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|CD1865_C_ESC
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|CD1865_C_EBRK
argument_list|)
expr_stmt|;
name|sx_cd1865_etcmode
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_BREAK
expr_stmt|;
block|}
else|else
block|{
comment|/* Start doing break.                 */
name|sx_cd1865_etcmode
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|CD1865_C_ESC
argument_list|)
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|CD1865_C_SBRK
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SX_SS_BREAK
expr_stmt|;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SX_SS_DOBRK
expr_stmt|;
block|}
comment|/* 	 * We've still got data in the clist, fill the channel's FIFO.  The 	 * CD1865 only gives us access to the FIFO during a transmit ready 	 * request [interrupt] for this channel. 	 */
while|while
condition|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
operator|&&
name|count
operator|--
operator|>=
literal|0
condition|)
block|{
specifier|register
name|unsigned
name|char
name|ch
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|ch
operator|=
operator|(
name|char
operator|)
name|getc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
comment|/* 		 * If we're doing a break we're in ETC mode, so we need to 		 * double any NULs in the stream. 		 */
if|if
condition|(
name|SX_BREAK
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* Doing break, in ETC mode.          */
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
comment|/* NUL?  Double it.                 */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
comment|/* 			 * Peek the next character; if it's a NUL, we need 			 * to escape it, but we can't if we're out of FIFO. 			 * We'll do it on the next pass and leave the FIFO 			 * incompletely filled. 			 */
if|if
condition|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|qp
operator|->
name|c_cf
expr_stmt|;
name|cp
operator|=
name|nextc
argument_list|(
name|qp
argument_list|,
name|cp
argument_list|,
operator|&
name|nch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nch
operator|==
literal|'\0'
operator|&&
name|count
operator|<
literal|1
condition|)
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_TDR
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* 	 * If we still have data to transmit, mark the tty busy for the 	 * line discipline. 	 */
if|if
condition|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
comment|/* Wake up sleepers if necessary. */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"sx_start out R %d/%d\n"
operator|,
name|count
operator|,
name|qp
operator|->
name|c_cc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line. called at spltty();  */
end_comment

begin_function
name|void
name|sx_stop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|struct
name|sx_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sx_port
modifier|*
name|pp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|sp_sc
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_STOP
operator|,
literal|"sx_stop(%x,%x)\n"
operator|,
name|tp
operator|,
name|rw
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* XXX: must check (rw& FWRITE | FREAD) etc flushing... */
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CAR
operator||
name|SX_EI
argument_list|,
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
name|sx_cd1865_bic
argument_list|(
name|sc
argument_list|,
name|CD1865_IER
operator||
name|SX_EI
argument_list|,
name|CD1865_IER_TXRDY
argument_list|)
expr_stmt|;
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
comment|/* Wait for CCR to go idle.   */
name|sx_cd1865_out
argument_list|(
name|sc
argument_list|,
name|CD1865_CCR
operator||
name|SX_EI
argument_list|,
name|CD1865_CCR_TXDIS
argument_list|)
expr_stmt|;
name|sx_cd1865_wait_CCR
argument_list|(
name|sc
argument_list|,
name|SX_EI
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* what level are we meant to be flushing anyway? */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Nothing to do for FREAD. 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SX_DEBUG
end_ifdef

begin_function
name|void
name|sx_dprintf
parameter_list|(
name|struct
name|sx_port
modifier|*
name|pp
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|logbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|logptr
decl_stmt|;
name|char
modifier|*
name|lbuf
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|logbuf
operator|==
name|NULL
condition|)
block|{
name|logbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1024
operator|*
literal|1024
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|logptr
operator|=
name|logbuf
expr_stmt|;
block|}
name|lbuf
operator|=
name|linebuf
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|==
name|NULL
operator|&&
operator|(
name|sx_debug
operator|&
name|flags
operator|)
operator|)
operator|||
operator|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|pp
operator|->
name|sp_debug
operator|&
name|flags
operator|)
operator|||
operator|(
name|sx_debug
operator|&
name|flags
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|sp_tty
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|linebuf
argument_list|,
literal|256
argument_list|,
literal|"sx%d(%d): "
argument_list|,
operator|(
name|int
operator|)
name|pp
operator|->
name|sp_sc
operator|->
name|sc_unit
argument_list|,
operator|(
name|int
operator|)
name|pp
operator|->
name|sp_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|256
condition|)
name|n
operator|=
literal|256
expr_stmt|;
name|lbuf
operator|+=
name|n
expr_stmt|;
block|}
name|m
operator|=
name|n
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|lbuf
argument_list|,
literal|256
operator|-
name|m
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|256
operator|-
name|m
condition|)
name|n
operator|=
literal|256
operator|-
name|m
expr_stmt|;
name|n
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|logptr
operator|+
name|n
operator|+
literal|1
operator|>
name|logbuf
operator|+
operator|(
literal|1024
operator|*
literal|1024
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|logptr
argument_list|,
name|logbuf
operator|+
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|-
name|logptr
argument_list|)
expr_stmt|;
name|logptr
operator|=
name|logbuf
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|linebuf
argument_list|,
name|logptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|logptr
operator|+=
name|n
expr_stmt|;
operator|*
name|logptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sx_debug
operator|&
name|DBG_PRINTF
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

