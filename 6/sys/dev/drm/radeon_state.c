begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* radeon_state.c -- State support for Radeon -*- linux-c -*- */
end_comment

begin_comment
comment|/*-  * Copyright 2000 VA Linux Systems, Inc., Fremont, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Gareth Hughes<gareth@valinux.com>  *    Kevin E. Martin<martin@valinux.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm_sarea.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/radeon_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/radeon_drv.h"
end_include

begin_comment
comment|/* ================================================================  * Helper functions for client state checking and fixup  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|radeon_check_and_fixup_offset
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|u32
modifier|*
name|offset
parameter_list|)
block|{
name|u64
name|off
init|=
operator|*
name|offset
decl_stmt|;
name|u32
name|fb_start
init|=
name|dev_priv
operator|->
name|fb_location
decl_stmt|;
name|u32
name|fb_end
init|=
name|fb_start
operator|+
name|dev_priv
operator|->
name|fb_size
operator|-
literal|1
decl_stmt|;
name|u32
name|gart_start
init|=
name|dev_priv
operator|->
name|gart_vm_start
decl_stmt|;
name|u32
name|gart_end
init|=
name|gart_start
operator|+
name|dev_priv
operator|->
name|gart_size
operator|-
literal|1
decl_stmt|;
name|struct
name|drm_radeon_driver_file_fields
modifier|*
name|radeon_priv
decl_stmt|;
comment|/* Hrm ... the story of the offset ... So this function converts 	 * the various ideas of what userland clients might have for an 	 * offset in the card address space into an offset into the card 	 * address space :) So with a sane client, it should just keep 	 * the value intact and just do some boundary checking. However, 	 * not all clients are sane. Some older clients pass us 0 based 	 * offsets relative to the start of the framebuffer and some may 	 * assume the AGP aperture it appended to the framebuffer, so we 	 * try to detect those cases and fix them up. 	 * 	 * Note: It might be a good idea here to make sure the offset lands 	 * in some "allowed" area to protect things like the PCIE GART... 	 */
comment|/* First, the best case, the offset already lands in either the 	 * framebuffer or the GART mapped space 	 */
if|if
condition|(
operator|(
name|off
operator|>=
name|fb_start
operator|&&
name|off
operator|<=
name|fb_end
operator|)
operator|||
operator|(
name|off
operator|>=
name|gart_start
operator|&&
name|off
operator|<=
name|gart_end
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Ok, that didn't happen... now check if we have a zero based 	 * offset that fits in the framebuffer + gart space, apply the 	 * magic offset we get from SETPARAM or calculated from fb_location 	 */
if|if
condition|(
name|off
operator|<
operator|(
name|dev_priv
operator|->
name|fb_size
operator|+
name|dev_priv
operator|->
name|gart_size
operator|)
condition|)
block|{
name|radeon_priv
operator|=
name|filp_priv
operator|->
name|driver_priv
expr_stmt|;
name|off
operator|+=
name|radeon_priv
operator|->
name|radeon_fb_delta
expr_stmt|;
block|}
comment|/* Finally, assume we aimed at a GART offset if beyond the fb */
if|if
condition|(
name|off
operator|>
name|fb_end
condition|)
name|off
operator|=
name|off
operator|-
name|fb_end
operator|-
literal|1
operator|+
name|gart_start
expr_stmt|;
comment|/* Now recheck and fail if out of bounds */
if|if
condition|(
operator|(
name|off
operator|>=
name|fb_start
operator|&&
name|off
operator|<=
name|fb_end
operator|)
operator|||
operator|(
name|off
operator|>=
name|gart_start
operator|&&
name|off
operator|<=
name|gart_end
operator|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"offset fixed up to 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|off
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|off
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|radeon_check_and_fixup_packets
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|int
name|id
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|RADEON_EMIT_PP_MISC
case|:
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
operator|(
name|RADEON_RB3D_DEPTHOFFSET
operator|-
name|RADEON_PP_MISC
operator|)
operator|/
literal|4
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid depth buffer offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|RADEON_EMIT_PP_CNTL
case|:
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
operator|(
name|RADEON_RB3D_COLOROFFSET
operator|-
name|RADEON_PP_CNTL
operator|)
operator|/
literal|4
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid colour buffer offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|R200_EMIT_PP_TXOFFSET_0
case|:
case|case
name|R200_EMIT_PP_TXOFFSET_1
case|:
case|case
name|R200_EMIT_PP_TXOFFSET_2
case|:
case|case
name|R200_EMIT_PP_TXOFFSET_3
case|:
case|case
name|R200_EMIT_PP_TXOFFSET_4
case|:
case|case
name|R200_EMIT_PP_TXOFFSET_5
case|:
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid R200 texture offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|RADEON_EMIT_PP_TXFILTER_0
case|:
case|case
name|RADEON_EMIT_PP_TXFILTER_1
case|:
case|case
name|RADEON_EMIT_PP_TXFILTER_2
case|:
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
operator|(
name|RADEON_PP_TXOFFSET_0
operator|-
name|RADEON_PP_TXFILTER_0
operator|)
operator|/
literal|4
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid R100 texture offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_0
case|:
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_1
case|:
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_2
case|:
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_3
case|:
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_4
case|:
case|case
name|R200_EMIT_PP_CUBIC_OFFSETS_5
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid R200 cubic texture offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
break|break;
block|}
case|case
name|RADEON_EMIT_PP_CUBIC_OFFSETS_T0
case|:
case|case
name|RADEON_EMIT_PP_CUBIC_OFFSETS_T1
case|:
case|case
name|RADEON_EMIT_PP_CUBIC_OFFSETS_T2
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid R100 cubic texture offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|RADEON_EMIT_RB3D_COLORPITCH
case|:
case|case
name|RADEON_EMIT_RE_LINE_PATTERN
case|:
case|case
name|RADEON_EMIT_SE_LINE_WIDTH
case|:
case|case
name|RADEON_EMIT_PP_LUM_MATRIX
case|:
case|case
name|RADEON_EMIT_PP_ROT_MATRIX_0
case|:
case|case
name|RADEON_EMIT_RB3D_STENCILREFMASK
case|:
case|case
name|RADEON_EMIT_SE_VPORT_XSCALE
case|:
case|case
name|RADEON_EMIT_SE_CNTL
case|:
case|case
name|RADEON_EMIT_SE_CNTL_STATUS
case|:
case|case
name|RADEON_EMIT_RE_MISC
case|:
case|case
name|RADEON_EMIT_PP_BORDER_COLOR_0
case|:
case|case
name|RADEON_EMIT_PP_BORDER_COLOR_1
case|:
case|case
name|RADEON_EMIT_PP_BORDER_COLOR_2
case|:
case|case
name|RADEON_EMIT_SE_ZBIAS_FACTOR
case|:
case|case
name|RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT
case|:
case|case
name|RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_0
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_1
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_2
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_3
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_4
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_5
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_6
case|:
case|case
name|R200_EMIT_PP_TXCBLEND_7
case|:
case|case
name|R200_EMIT_TCL_LIGHT_MODEL_CTL_0
case|:
case|case
name|R200_EMIT_TFACTOR_0
case|:
case|case
name|R200_EMIT_VTX_FMT_0
case|:
case|case
name|R200_EMIT_VAP_CTL
case|:
case|case
name|R200_EMIT_MATRIX_SELECT_0
case|:
case|case
name|R200_EMIT_TEX_PROC_CTL_2
case|:
case|case
name|R200_EMIT_TCL_UCP_VERT_BLEND_CTL
case|:
case|case
name|R200_EMIT_PP_TXFILTER_0
case|:
case|case
name|R200_EMIT_PP_TXFILTER_1
case|:
case|case
name|R200_EMIT_PP_TXFILTER_2
case|:
case|case
name|R200_EMIT_PP_TXFILTER_3
case|:
case|case
name|R200_EMIT_PP_TXFILTER_4
case|:
case|case
name|R200_EMIT_PP_TXFILTER_5
case|:
case|case
name|R200_EMIT_VTE_CNTL
case|:
case|case
name|R200_EMIT_OUTPUT_VTX_COMP_SEL
case|:
case|case
name|R200_EMIT_PP_TAM_DEBUG3
case|:
case|case
name|R200_EMIT_PP_CNTL_X
case|:
case|case
name|R200_EMIT_RB3D_DEPTHXY_OFFSET
case|:
case|case
name|R200_EMIT_RE_AUX_SCISSOR_CNTL
case|:
case|case
name|R200_EMIT_RE_SCISSOR_TL_0
case|:
case|case
name|R200_EMIT_RE_SCISSOR_TL_1
case|:
case|case
name|R200_EMIT_RE_SCISSOR_TL_2
case|:
case|case
name|R200_EMIT_SE_VAP_CNTL_STATUS
case|:
case|case
name|R200_EMIT_SE_VTX_STATE_CNTL
case|:
case|case
name|R200_EMIT_RE_POINTSIZE
case|:
case|case
name|R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_0
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_1
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_2
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_3
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_4
case|:
case|case
name|R200_EMIT_PP_CUBIC_FACES_5
case|:
case|case
name|RADEON_EMIT_PP_TEX_SIZE_0
case|:
case|case
name|RADEON_EMIT_PP_TEX_SIZE_1
case|:
case|case
name|RADEON_EMIT_PP_TEX_SIZE_2
case|:
case|case
name|R200_EMIT_RB3D_BLENDCOLOR
case|:
case|case
name|R200_EMIT_TCL_POINT_SPRITE_CNTL
case|:
case|case
name|RADEON_EMIT_PP_CUBIC_FACES_0
case|:
case|case
name|RADEON_EMIT_PP_CUBIC_FACES_1
case|:
case|case
name|RADEON_EMIT_PP_CUBIC_FACES_2
case|:
case|case
name|R200_EMIT_PP_TRI_PERF_CNTL
case|:
case|case
name|R200_EMIT_PP_AFS_0
case|:
case|case
name|R200_EMIT_PP_AFS_1
case|:
case|case
name|R200_EMIT_ATF_TFACTOR
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_0
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_1
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_2
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_3
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_4
case|:
case|case
name|R200_EMIT_PP_TXCTLALL_5
case|:
case|case
name|R200_EMIT_VAP_PVS_CNTL
case|:
comment|/* These packets don't contain memory offsets */
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown state packet ID %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|radeon_check_and_fixup_packet3
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|unsigned
name|int
modifier|*
name|cmdsz
parameter_list|)
block|{
name|u32
modifier|*
name|cmd
init|=
operator|(
name|u32
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
decl_stmt|;
operator|*
name|cmdsz
operator|=
literal|2
operator|+
operator|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|&
name|RADEON_CP_PACKET_COUNT_MASK
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|&
literal|0xc0000000
operator|)
operator|!=
name|RADEON_CP_PACKET3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Not a type 3 packet\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
literal|4
operator|*
operator|*
name|cmdsz
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Packet size larger than size of data provided\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Check client state and fix it up if necessary */
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|)
block|{
comment|/* MSB of opcode: next DWORD GUI_CNTL */
name|u32
name|offset
decl_stmt|;
if|if
condition|(
name|cmd
index|[
literal|1
index|]
operator|&
operator|(
name|RADEON_GMC_SRC_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator|)
condition|)
block|{
name|offset
operator|=
name|cmd
index|[
literal|2
index|]
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid first packet offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|cmd
index|[
literal|2
index|]
operator|=
operator|(
name|cmd
index|[
literal|2
index|]
operator|&
literal|0xffc00000
operator|)
operator||
name|offset
operator|>>
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
index|[
literal|1
index|]
operator|&
name|RADEON_GMC_SRC_PITCH_OFFSET_CNTL
operator|)
operator|&&
operator|(
name|cmd
index|[
literal|1
index|]
operator|&
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator|)
condition|)
block|{
name|offset
operator|=
name|cmd
index|[
literal|3
index|]
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid second packet offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|cmd
index|[
literal|3
index|]
operator|=
operator|(
name|cmd
index|[
literal|3
index|]
operator|&
literal|0xffc00000
operator|)
operator||
name|offset
operator|>>
literal|10
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * CP hardware state programming functions  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|radeon_emit_clip_rect
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_clip_rect_t
modifier|*
name|box
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   box:  x1=%d y1=%d  x2=%d y2=%d\n"
argument_list|,
name|box
operator|->
name|x1
argument_list|,
name|box
operator|->
name|y1
argument_list|,
name|box
operator|->
name|x2
argument_list|,
name|box
operator|->
name|y2
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RE_TOP_LEFT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|->
name|y1
operator|<<
literal|16
operator|)
operator||
name|box
operator|->
name|x1
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RE_WIDTH_HEIGHT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
operator|(
name|box
operator|->
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|box
operator|->
name|x2
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit 1.1 state  */
end_comment

begin_function
specifier|static
name|int
name|radeon_emit_state
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_context_regs_t
modifier|*
name|ctx
parameter_list|,
name|drm_radeon_texture_regs_t
modifier|*
name|tex
parameter_list|,
name|unsigned
name|int
name|dirty
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dirty=0x%08x\n"
argument_list|,
name|dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_CONTEXT
condition|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|ctx
operator|->
name|rb3d_depthoffset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid depth buffer offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|ctx
operator|->
name|rb3d_coloroffset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid depth buffer offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_MISC
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_misc
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_fog_color
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|re_solid_color
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_blendcntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_depthoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_depthpitch
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_zstencilcntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_CNTL
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_cntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_cntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_coloroffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RB3D_COLORPITCH
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_colorpitch
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_VERTFMT
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_COORD_FMT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_coord_fmt
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_LINE
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RE_LINE_PATTERN
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|re_line_pattern
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|re_line_state
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_LINE_WIDTH
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_line_width
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_BUMPMAP
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_LUM_MATRIX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_lum_matrix
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_ROT_MATRIX_0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_rot_matrix_0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|pp_rot_matrix_1
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_MASKS
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RB3D_STENCILREFMASK
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_stencilrefmask
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_ropcntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|rb3d_planemask
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_VIEWPORT
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_VPORT_XSCALE
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_xscale
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_xoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_yscale
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_yoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_zscale
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_vport_zoffset
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_SETUP
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_CNTL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_cntl
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_CNTL_STATUS
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|se_cntl_status
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_MISC
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RE_MISC
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|ctx
operator|->
name|re_misc
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_TEX0
condition|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txoffset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid texture offset for unit 0\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_TXFILTER_0
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txfilter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txformat
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txcblend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_txablend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_tfactor
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_BORDER_COLOR_0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|0
index|]
operator|.
name|pp_border_color
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_TEX1
condition|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txoffset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid texture offset for unit 1\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_TXFILTER_1
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txfilter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txformat
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txcblend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_txablend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_tfactor
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_BORDER_COLOR_1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|1
index|]
operator|.
name|pp_border_color
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|RADEON_UPLOAD_TEX2
condition|)
block|{
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txoffset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid texture offset for unit 2\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_TXFILTER_2
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txfilter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txformat
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txoffset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txcblend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_txablend
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_tfactor
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_BORDER_COLOR_2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tex
index|[
literal|2
index|]
operator|.
name|pp_border_color
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit 1.2 state  */
end_comment

begin_function
specifier|static
name|int
name|radeon_emit_state2
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_state_t
modifier|*
name|state
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dirty
operator|&
name|RADEON_UPLOAD_ZBIAS
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_ZBIAS_FACTOR
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|state
operator|->
name|context2
operator|.
name|se_zbias_factor
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|state
operator|->
name|context2
operator|.
name|se_zbias_constant
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
return|return
name|radeon_emit_state
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|state
operator|->
name|context
argument_list|,
name|state
operator|->
name|tex
argument_list|,
name|state
operator|->
name|dirty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* New (1.3) state mechanism.  3 commands (packet, scalar, vector) in  * 1.3 cmdbuffers allow all previous state to be updated as well as  * the tcl scalar and vector areas.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|packet
index|[
name|RADEON_MAX_STATE_PACKETS
index|]
init|=
block|{
block|{
name|RADEON_PP_MISC
block|,
literal|7
block|,
literal|"RADEON_PP_MISC"
block|}
block|,
block|{
name|RADEON_PP_CNTL
block|,
literal|3
block|,
literal|"RADEON_PP_CNTL"
block|}
block|,
block|{
name|RADEON_RB3D_COLORPITCH
block|,
literal|1
block|,
literal|"RADEON_RB3D_COLORPITCH"
block|}
block|,
block|{
name|RADEON_RE_LINE_PATTERN
block|,
literal|2
block|,
literal|"RADEON_RE_LINE_PATTERN"
block|}
block|,
block|{
name|RADEON_SE_LINE_WIDTH
block|,
literal|1
block|,
literal|"RADEON_SE_LINE_WIDTH"
block|}
block|,
block|{
name|RADEON_PP_LUM_MATRIX
block|,
literal|1
block|,
literal|"RADEON_PP_LUM_MATRIX"
block|}
block|,
block|{
name|RADEON_PP_ROT_MATRIX_0
block|,
literal|2
block|,
literal|"RADEON_PP_ROT_MATRIX_0"
block|}
block|,
block|{
name|RADEON_RB3D_STENCILREFMASK
block|,
literal|3
block|,
literal|"RADEON_RB3D_STENCILREFMASK"
block|}
block|,
block|{
name|RADEON_SE_VPORT_XSCALE
block|,
literal|6
block|,
literal|"RADEON_SE_VPORT_XSCALE"
block|}
block|,
block|{
name|RADEON_SE_CNTL
block|,
literal|2
block|,
literal|"RADEON_SE_CNTL"
block|}
block|,
block|{
name|RADEON_SE_CNTL_STATUS
block|,
literal|1
block|,
literal|"RADEON_SE_CNTL_STATUS"
block|}
block|,
block|{
name|RADEON_RE_MISC
block|,
literal|1
block|,
literal|"RADEON_RE_MISC"
block|}
block|,
block|{
name|RADEON_PP_TXFILTER_0
block|,
literal|6
block|,
literal|"RADEON_PP_TXFILTER_0"
block|}
block|,
block|{
name|RADEON_PP_BORDER_COLOR_0
block|,
literal|1
block|,
literal|"RADEON_PP_BORDER_COLOR_0"
block|}
block|,
block|{
name|RADEON_PP_TXFILTER_1
block|,
literal|6
block|,
literal|"RADEON_PP_TXFILTER_1"
block|}
block|,
block|{
name|RADEON_PP_BORDER_COLOR_1
block|,
literal|1
block|,
literal|"RADEON_PP_BORDER_COLOR_1"
block|}
block|,
block|{
name|RADEON_PP_TXFILTER_2
block|,
literal|6
block|,
literal|"RADEON_PP_TXFILTER_2"
block|}
block|,
block|{
name|RADEON_PP_BORDER_COLOR_2
block|,
literal|1
block|,
literal|"RADEON_PP_BORDER_COLOR_2"
block|}
block|,
block|{
name|RADEON_SE_ZBIAS_FACTOR
block|,
literal|2
block|,
literal|"RADEON_SE_ZBIAS_FACTOR"
block|}
block|,
block|{
name|RADEON_SE_TCL_OUTPUT_VTX_FMT
block|,
literal|11
block|,
literal|"RADEON_SE_TCL_OUTPUT_VTX_FMT"
block|}
block|,
block|{
name|RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED
block|,
literal|17
block|,
literal|"RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_0
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_0"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_1
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_1"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_2
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_2"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_3
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_3"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_4
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_4"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_5
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_5"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_6
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_6"
block|}
block|,
block|{
name|R200_PP_TXCBLEND_7
block|,
literal|4
block|,
literal|"R200_PP_TXCBLEND_7"
block|}
block|,
block|{
name|R200_SE_TCL_LIGHT_MODEL_CTL_0
block|,
literal|6
block|,
literal|"R200_SE_TCL_LIGHT_MODEL_CTL_0"
block|}
block|,
block|{
name|R200_PP_TFACTOR_0
block|,
literal|6
block|,
literal|"R200_PP_TFACTOR_0"
block|}
block|,
block|{
name|R200_SE_VTX_FMT_0
block|,
literal|4
block|,
literal|"R200_SE_VTX_FMT_0"
block|}
block|,
block|{
name|R200_SE_VAP_CNTL
block|,
literal|1
block|,
literal|"R200_SE_VAP_CNTL"
block|}
block|,
block|{
name|R200_SE_TCL_MATRIX_SEL_0
block|,
literal|5
block|,
literal|"R200_SE_TCL_MATRIX_SEL_0"
block|}
block|,
block|{
name|R200_SE_TCL_TEX_PROC_CTL_2
block|,
literal|5
block|,
literal|"R200_SE_TCL_TEX_PROC_CTL_2"
block|}
block|,
block|{
name|R200_SE_TCL_UCP_VERT_BLEND_CTL
block|,
literal|1
block|,
literal|"R200_SE_TCL_UCP_VERT_BLEND_CTL"
block|}
block|,
block|{
name|R200_PP_TXFILTER_0
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_0"
block|}
block|,
block|{
name|R200_PP_TXFILTER_1
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_1"
block|}
block|,
block|{
name|R200_PP_TXFILTER_2
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_2"
block|}
block|,
block|{
name|R200_PP_TXFILTER_3
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_3"
block|}
block|,
block|{
name|R200_PP_TXFILTER_4
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_4"
block|}
block|,
block|{
name|R200_PP_TXFILTER_5
block|,
literal|6
block|,
literal|"R200_PP_TXFILTER_5"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_0
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_0"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_1
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_1"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_2
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_2"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_3
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_3"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_4
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_4"
block|}
block|,
block|{
name|R200_PP_TXOFFSET_5
block|,
literal|1
block|,
literal|"R200_PP_TXOFFSET_5"
block|}
block|,
block|{
name|R200_SE_VTE_CNTL
block|,
literal|1
block|,
literal|"R200_SE_VTE_CNTL"
block|}
block|,
block|{
name|R200_SE_TCL_OUTPUT_VTX_COMP_SEL
block|,
literal|1
block|,
literal|"R200_SE_TCL_OUTPUT_VTX_COMP_SEL"
block|}
block|,
block|{
name|R200_PP_TAM_DEBUG3
block|,
literal|1
block|,
literal|"R200_PP_TAM_DEBUG3"
block|}
block|,
block|{
name|R200_PP_CNTL_X
block|,
literal|1
block|,
literal|"R200_PP_CNTL_X"
block|}
block|,
block|{
name|R200_RB3D_DEPTHXY_OFFSET
block|,
literal|1
block|,
literal|"R200_RB3D_DEPTHXY_OFFSET"
block|}
block|,
block|{
name|R200_RE_AUX_SCISSOR_CNTL
block|,
literal|1
block|,
literal|"R200_RE_AUX_SCISSOR_CNTL"
block|}
block|,
block|{
name|R200_RE_SCISSOR_TL_0
block|,
literal|2
block|,
literal|"R200_RE_SCISSOR_TL_0"
block|}
block|,
block|{
name|R200_RE_SCISSOR_TL_1
block|,
literal|2
block|,
literal|"R200_RE_SCISSOR_TL_1"
block|}
block|,
block|{
name|R200_RE_SCISSOR_TL_2
block|,
literal|2
block|,
literal|"R200_RE_SCISSOR_TL_2"
block|}
block|,
block|{
name|R200_SE_VAP_CNTL_STATUS
block|,
literal|1
block|,
literal|"R200_SE_VAP_CNTL_STATUS"
block|}
block|,
block|{
name|R200_SE_VTX_STATE_CNTL
block|,
literal|1
block|,
literal|"R200_SE_VTX_STATE_CNTL"
block|}
block|,
block|{
name|R200_RE_POINTSIZE
block|,
literal|1
block|,
literal|"R200_RE_POINTSIZE"
block|}
block|,
block|{
name|R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0
block|,
literal|4
block|,
literal|"R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0"
block|}
block|,
block|{
name|R200_PP_CUBIC_FACES_0
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_0"
block|}
block|,
comment|/* 61 */
block|{
name|R200_PP_CUBIC_OFFSET_F1_0
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_0"
block|}
block|,
comment|/* 62 */
block|{
name|R200_PP_CUBIC_FACES_1
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_1"
block|}
block|,
block|{
name|R200_PP_CUBIC_OFFSET_F1_1
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_1"
block|}
block|,
block|{
name|R200_PP_CUBIC_FACES_2
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_2"
block|}
block|,
block|{
name|R200_PP_CUBIC_OFFSET_F1_2
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_2"
block|}
block|,
block|{
name|R200_PP_CUBIC_FACES_3
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_3"
block|}
block|,
block|{
name|R200_PP_CUBIC_OFFSET_F1_3
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_3"
block|}
block|,
block|{
name|R200_PP_CUBIC_FACES_4
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_4"
block|}
block|,
block|{
name|R200_PP_CUBIC_OFFSET_F1_4
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_4"
block|}
block|,
block|{
name|R200_PP_CUBIC_FACES_5
block|,
literal|1
block|,
literal|"R200_PP_CUBIC_FACES_5"
block|}
block|,
block|{
name|R200_PP_CUBIC_OFFSET_F1_5
block|,
literal|5
block|,
literal|"R200_PP_CUBIC_OFFSET_F1_5"
block|}
block|,
block|{
name|RADEON_PP_TEX_SIZE_0
block|,
literal|2
block|,
literal|"RADEON_PP_TEX_SIZE_0"
block|}
block|,
block|{
name|RADEON_PP_TEX_SIZE_1
block|,
literal|2
block|,
literal|"RADEON_PP_TEX_SIZE_1"
block|}
block|,
block|{
name|RADEON_PP_TEX_SIZE_2
block|,
literal|2
block|,
literal|"RADEON_PP_TEX_SIZE_2"
block|}
block|,
block|{
name|R200_RB3D_BLENDCOLOR
block|,
literal|3
block|,
literal|"R200_RB3D_BLENDCOLOR"
block|}
block|,
block|{
name|R200_SE_TCL_POINT_SPRITE_CNTL
block|,
literal|1
block|,
literal|"R200_SE_TCL_POINT_SPRITE_CNTL"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_FACES_0
block|,
literal|1
block|,
literal|"RADEON_PP_CUBIC_FACES_0"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_OFFSET_T0_0
block|,
literal|5
block|,
literal|"RADEON_PP_CUBIC_OFFSET_T0_0"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_FACES_1
block|,
literal|1
block|,
literal|"RADEON_PP_CUBIC_FACES_1"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_OFFSET_T1_0
block|,
literal|5
block|,
literal|"RADEON_PP_CUBIC_OFFSET_T1_0"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_FACES_2
block|,
literal|1
block|,
literal|"RADEON_PP_CUBIC_FACES_2"
block|}
block|,
block|{
name|RADEON_PP_CUBIC_OFFSET_T2_0
block|,
literal|5
block|,
literal|"RADEON_PP_CUBIC_OFFSET_T2_0"
block|}
block|,
block|{
name|R200_PP_TRI_PERF
block|,
literal|2
block|,
literal|"R200_PP_TRI_PERF"
block|}
block|,
block|{
name|R200_PP_AFS_0
block|,
literal|32
block|,
literal|"R200_PP_AFS_0"
block|}
block|,
comment|/* 85 */
block|{
name|R200_PP_AFS_1
block|,
literal|32
block|,
literal|"R200_PP_AFS_1"
block|}
block|,
block|{
name|R200_PP_TFACTOR_0
block|,
literal|8
block|,
literal|"R200_ATF_TFACTOR"
block|}
block|,
block|{
name|R200_PP_TXFILTER_0
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_0"
block|}
block|,
block|{
name|R200_PP_TXFILTER_1
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_1"
block|}
block|,
block|{
name|R200_PP_TXFILTER_2
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_2"
block|}
block|,
block|{
name|R200_PP_TXFILTER_3
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_3"
block|}
block|,
block|{
name|R200_PP_TXFILTER_4
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_4"
block|}
block|,
block|{
name|R200_PP_TXFILTER_5
block|,
literal|8
block|,
literal|"R200_PP_TXCTLALL_5"
block|}
block|,
block|{
name|R200_VAP_PVS_CNTL_1
block|,
literal|2
block|,
literal|"R200_VAP_PVS_CNTL"
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* ================================================================  * Performance monitoring functions  */
end_comment

begin_function
specifier|static
name|void
name|radeon_clear_box
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|u32
name|color
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|x
operator|+=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|boxes
index|[
literal|0
index|]
operator|.
name|x1
expr_stmt|;
name|y
operator|+=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|boxes
index|[
literal|0
index|]
operator|.
name|y1
expr_stmt|;
switch|switch
condition|(
name|dev_priv
operator|->
name|color_fmt
condition|)
block|{
case|case
name|RADEON_COLOR_FORMAT_RGB565
case|:
name|color
operator|=
operator|(
operator|(
operator|(
name|r
operator|&
literal|0xf8
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|g
operator|&
literal|0xfc
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|b
operator|&
literal|0xf8
operator|)
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|RADEON_COLOR_FORMAT_ARGB8888
case|:
default|default:
name|color
operator|=
operator|(
operator|(
operator|(
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|r
operator|<<
literal|16
operator|)
operator||
operator|(
name|g
operator|<<
literal|8
operator|)
operator||
name|b
operator|)
expr_stmt|;
break|break;
block|}
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_DP_WRITE_MASK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CNTL_PAINT_MULTI
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_BRUSH_SOLID_COLOR
operator||
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|<<
literal|8
operator|)
operator||
name|RADEON_GMC_SRC_DATATYPE_COLOR
operator||
name|RADEON_ROP3_P
operator||
name|RADEON_GMC_CLR_CMP_CNTL_DIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|page_flipping
operator|&&
name|dev_priv
operator|->
name|current_page
operator|==
literal|1
condition|)
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|front_pitch_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|back_pitch_offset
argument_list|)
expr_stmt|;
block|}
name|OUT_RING
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
name|h
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_performance_boxes
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
comment|/* Collapse various things into a wait flag -- trying to 	 * guess if userspase slept -- better just to have them tell us. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|last_frame_reads
operator|>
literal|1
operator|||
name|dev_priv
operator|->
name|stats
operator|.
name|last_clear_reads
operator|>
name|dev_priv
operator|->
name|stats
operator|.
name|clears
condition|)
block|{
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator||=
name|RADEON_BOX_WAIT_IDLE
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|freelist_loops
condition|)
block|{
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator||=
name|RADEON_BOX_WAIT_IDLE
expr_stmt|;
block|}
comment|/* Purple box for page flipping 	 */
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator|&
name|RADEON_BOX_FLIP
condition|)
name|radeon_clear_box
argument_list|(
name|dev_priv
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* Red box if we have to wait for idle at any point 	 */
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator|&
name|RADEON_BOX_WAIT_IDLE
condition|)
name|radeon_clear_box
argument_list|(
name|dev_priv
argument_list|,
literal|16
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Blue box: lost context? 	 */
comment|/* Yellow box for texture swaps 	 */
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator|&
name|RADEON_BOX_TEXTURE_LOAD
condition|)
name|radeon_clear_box
argument_list|(
name|dev_priv
argument_list|,
literal|40
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Green box if hardware never idles (as far as we can tell) 	 */
if|if
condition|(
operator|!
operator|(
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator|&
name|RADEON_BOX_DMA_IDLE
operator|)
condition|)
name|radeon_clear_box
argument_list|(
name|dev_priv
argument_list|,
literal|64
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Draw bars indicating number of buffers allocated 	 * (not a great measure, easily confused) 	 */
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|requested_bufs
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|stats
operator|.
name|requested_bufs
operator|>
literal|100
condition|)
name|dev_priv
operator|->
name|stats
operator|.
name|requested_bufs
operator|=
literal|100
expr_stmt|;
name|radeon_clear_box
argument_list|(
name|dev_priv
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|,
name|dev_priv
operator|->
name|stats
operator|.
name|requested_bufs
argument_list|,
literal|4
argument_list|,
literal|196
argument_list|,
literal|128
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|dev_priv
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ================================================================  * CP command dispatch functions  */
end_comment

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_clear
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_radeon_clear_t
modifier|*
name|clear
parameter_list|,
name|drm_radeon_clear_rect_t
modifier|*
name|depth_boxes
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_radeon_depth_clear_t
modifier|*
name|depth_clear
init|=
operator|&
name|dev_priv
operator|->
name|depth_clear
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|drm_clip_rect_t
modifier|*
name|pbox
init|=
name|sarea_priv
operator|->
name|boxes
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|clear
operator|->
name|flags
decl_stmt|;
name|u32
name|rb3d_cntl
init|=
literal|0
decl_stmt|,
name|rb3d_stencilrefmask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"flags = 0x%x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|stats
operator|.
name|clears
operator|++
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|page_flipping
operator|&&
name|dev_priv
operator|->
name|current_page
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
name|flags
decl_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|RADEON_FRONT
operator||
name|RADEON_BACK
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|RADEON_FRONT
condition|)
name|flags
operator||=
name|RADEON_BACK
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|RADEON_BACK
condition|)
name|flags
operator||=
name|RADEON_FRONT
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|RADEON_FRONT
operator||
name|RADEON_BACK
operator|)
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Ensure the 3D stream is idle before doing a 		 * 2D fill to clear the front or back buffer. 		 */
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_DP_WRITE_MASK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|clear
operator|->
name|color_mask
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 		 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x1
decl_stmt|;
name|int
name|y
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y1
decl_stmt|;
name|int
name|w
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|-
name|x
decl_stmt|;
name|int
name|h
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|-
name|y
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dispatch clear %d,%d-%d,%d flags 0x%x\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RADEON_FRONT
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CNTL_PAINT_MULTI
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_BRUSH_SOLID_COLOR
operator||
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|<<
literal|8
operator|)
operator||
name|RADEON_GMC_SRC_DATATYPE_COLOR
operator||
name|RADEON_ROP3_P
operator||
name|RADEON_GMC_CLR_CMP_CNTL_DIS
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|front_pitch_offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|clear
operator|->
name|clear_color
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
name|h
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_BACK
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CNTL_PAINT_MULTI
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_BRUSH_SOLID_COLOR
operator||
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|<<
literal|8
operator|)
operator||
name|RADEON_GMC_SRC_DATATYPE_COLOR
operator||
name|RADEON_ROP3_P
operator||
name|RADEON_GMC_CLR_CMP_CNTL_DIS
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|back_pitch_offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|clear
operator|->
name|clear_color
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
name|h
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* hyper z clear */
comment|/* no docs available, based on reverse engeneering by Stephane Marchesin */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|RADEON_DEPTH
operator||
name|RADEON_STENCIL
operator|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|RADEON_CLEAR_FASTZ
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|depthpixperline
init|=
name|dev_priv
operator|->
name|depth_fmt
operator|==
name|RADEON_DEPTH_FORMAT_16BIT_INT_Z
condition|?
operator|(
name|dev_priv
operator|->
name|depth_pitch
operator|/
literal|2
operator|)
else|:
operator|(
name|dev_priv
operator|->
name|depth_pitch
operator|/
literal|4
operator|)
decl_stmt|;
name|u32
name|clearmask
decl_stmt|;
name|u32
name|tempRB3D_DEPTHCLEARVALUE
init|=
name|clear
operator|->
name|clear_depth
operator||
operator|(
operator|(
name|clear
operator|->
name|depth_mask
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
decl_stmt|;
comment|/* Make sure we restore the 3D state next time. 		 * we haven't touched any "normal" state - still need this? 		 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|flags
operator|&
name|CHIP_HAS_HIERZ
operator|)
operator|&&
operator|(
name|flags
operator|&
name|RADEON_USE_HIERZ
operator|)
condition|)
block|{
comment|/* FIXME : reverse engineer that for Rx00 cards */
comment|/* FIXME : the mask supposedly contains low-res z values. So can't set 			   just to the max (0xff? or actually 0x3fff?), need to take z clear 			   value into account? */
comment|/* pattern seems to work for r100, though get slight 			   rendering errors with glxgears. If hierz is not enabled for r100, 			   only 4 bits which indicate clear (15,16,31,32, all zero) matter, the 			   other ones are ignored, and the same clear mask can be used. That's 			   very different behaviour than R200 which needs different clear mask 			   and different number of tiles to clear if hierz is enabled or not !?! 			 */
name|clearmask
operator|=
operator|(
literal|0xff
operator|<<
literal|22
operator|)
operator||
operator|(
literal|0xff
operator|<<
literal|6
operator|)
operator||
literal|0x003f003f
expr_stmt|;
block|}
else|else
block|{
comment|/* clear mask : chooses the clearing pattern. 			   rv250: could be used to clear only parts of macrotiles 			   (but that would get really complicated...)? 			   bit 0 and 1 (either or both of them ?!?!) are used to 			   not clear tile (or maybe one of the bits indicates if the tile is 			   compressed or not), bit 2 and 3 to not clear tile 1,...,. 			   Pattern is as follows: 			   | 0,1 | 4,5 | 8,9 |12,13|16,17|20,21|24,25|28,29| 			   bits ------------------------------------------------- 			   | 2,3 | 6,7 |10,11|14,15|18,19|22,23|26,27|30,31| 			   rv100: clearmask covers 2x8 4x1 tiles, but one clear still 			   covers 256 pixels ?!? 			 */
name|clearmask
operator|=
literal|0x0
expr_stmt|;
block|}
name|BEGIN_RING
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_DEPTHCLEARVALUE
argument_list|,
name|tempRB3D_DEPTHCLEARVALUE
argument_list|)
expr_stmt|;
comment|/* what offset is this exactly ? */
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_ZMASKOFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* need ctlstat, otherwise get some strange black flickering */
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_ZCACHE_CTLSTAT
argument_list|,
name|RADEON_RB3D_ZC_FLUSH_ALL
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tileoffset
decl_stmt|,
name|nrtilesx
decl_stmt|,
name|nrtilesy
decl_stmt|,
name|j
decl_stmt|;
comment|/* it looks like r200 needs rv-style clears, at least if hierz is not enabled? */
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|flags
operator|&
name|CHIP_HAS_HIERZ
operator|)
operator|&&
operator|!
operator|(
name|dev_priv
operator|->
name|microcode_version
operator|==
name|UCODE_R200
operator|)
condition|)
block|{
comment|/* FIXME : figure this out for r200 (when hierz is enabled). Or 				   maybe r200 actually doesn't need to put the low-res z value into 				   the tile cache like r100, but just needs to clear the hi-level z-buffer? 				   Works for R100, both with hierz and without. 				   R100 seems to operate on 2x1 8x8 tiles, but... 				   odd: offset/nrtiles need to be 64 pix (4 block) aligned? Potentially 				   problematic with resolutions which are not 64 pix aligned? */
name|tileoffset
operator|=
operator|(
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|3
operator|)
operator|*
name|depthpixperline
operator|+
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|)
operator|>>
literal|6
expr_stmt|;
name|nrtilesx
operator|=
operator|(
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|&
operator|~
literal|63
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|&
operator|~
literal|63
operator|)
operator|)
operator|>>
literal|4
expr_stmt|;
name|nrtilesy
operator|=
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|>>
literal|3
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|3
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nrtilesy
condition|;
name|j
operator|++
control|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_CLEAR_ZMASK
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first tile */
name|OUT_RING
argument_list|(
name|tileoffset
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* the number of tiles to clear */
name|OUT_RING
argument_list|(
name|nrtilesx
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* clear mask : chooses the clearing pattern. */
name|OUT_RING
argument_list|(
name|clearmask
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|tileoffset
operator|+=
name|depthpixperline
operator|>>
literal|6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|microcode_version
operator|==
name|UCODE_R200
condition|)
block|{
comment|/* works for rv250. */
comment|/* find first macro tile (8x2 4x4 z-pixels on rv250) */
name|tileoffset
operator|=
operator|(
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|3
operator|)
operator|*
name|depthpixperline
operator|+
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|)
operator|>>
literal|5
expr_stmt|;
name|nrtilesx
operator|=
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|>>
literal|5
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|>>
literal|5
operator|)
expr_stmt|;
name|nrtilesy
operator|=
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|>>
literal|3
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|3
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nrtilesy
condition|;
name|j
operator|++
control|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_CLEAR_ZMASK
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first tile */
comment|/* judging by the first tile offset needed, could possibly 					   directly address/clear 4x4 tiles instead of 8x2 * 4x4 					   macro tiles, though would still need clear mask for 					   right/bottom if truely 4x4 granularity is desired ? */
name|OUT_RING
argument_list|(
name|tileoffset
operator|*
literal|16
argument_list|)
expr_stmt|;
comment|/* the number of tiles to clear */
name|OUT_RING
argument_list|(
name|nrtilesx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* clear mask : chooses the clearing pattern. */
name|OUT_RING
argument_list|(
name|clearmask
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|tileoffset
operator|+=
name|depthpixperline
operator|>>
literal|5
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* rv 100 */
comment|/* rv100 might not need 64 pix alignment, who knows */
comment|/* offsets are, hmm, weird */
name|tileoffset
operator|=
operator|(
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|4
operator|)
operator|*
name|depthpixperline
operator|+
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|)
operator|>>
literal|6
expr_stmt|;
name|nrtilesx
operator|=
operator|(
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|&
operator|~
literal|63
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|x1
operator|&
operator|~
literal|63
operator|)
operator|)
operator|>>
literal|4
expr_stmt|;
name|nrtilesy
operator|=
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|>>
literal|4
operator|)
operator|-
operator|(
name|pbox
index|[
name|i
index|]
operator|.
name|y1
operator|>>
literal|4
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nrtilesy
condition|;
name|j
operator|++
control|)
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_CLEAR_ZMASK
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|tileoffset
operator|*
literal|128
argument_list|)
expr_stmt|;
comment|/* the number of tiles to clear */
name|OUT_RING
argument_list|(
name|nrtilesx
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* clear mask : chooses the clearing pattern. */
name|OUT_RING
argument_list|(
name|clearmask
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|tileoffset
operator|+=
name|depthpixperline
operator|>>
literal|6
expr_stmt|;
block|}
block|}
block|}
comment|/* TODO don't always clear all hi-level z tiles */
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|flags
operator|&
name|CHIP_HAS_HIERZ
operator|)
operator|&&
operator|(
name|dev_priv
operator|->
name|microcode_version
operator|==
name|UCODE_R200
operator|)
operator|&&
operator|(
name|flags
operator|&
name|RADEON_USE_HIERZ
operator|)
condition|)
comment|/* r100 and cards without hierarchical z-buffer have no high-level z-buffer */
comment|/* FIXME : the mask supposedly contains low-res z values. So can't set 			   just to the max (0xff? or actually 0x3fff?), need to take z clear 			   value into account? */
block|{
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_CLEAR_HIZ
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
comment|/* First tile */
name|OUT_RING
argument_list|(
literal|0x3cc0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
literal|0xff
operator|<<
literal|22
operator|)
operator||
operator|(
literal|0xff
operator|<<
literal|6
operator|)
operator||
literal|0x003f003f
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* We have to clear the depth and/or stencil buffers by 	 * rendering a quad into just those buffers.  Thus, we have to 	 * make sure the 3D engine is configured correctly. 	 */
elseif|else
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|microcode_version
operator|==
name|UCODE_R200
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|RADEON_DEPTH
operator||
name|RADEON_STENCIL
operator|)
operator|)
condition|)
block|{
name|int
name|tempPP_CNTL
decl_stmt|;
name|int
name|tempRE_CNTL
decl_stmt|;
name|int
name|tempRB3D_CNTL
decl_stmt|;
name|int
name|tempRB3D_ZSTENCILCNTL
decl_stmt|;
name|int
name|tempRB3D_STENCILREFMASK
decl_stmt|;
name|int
name|tempRB3D_PLANEMASK
decl_stmt|;
name|int
name|tempSE_CNTL
decl_stmt|;
name|int
name|tempSE_VTE_CNTL
decl_stmt|;
name|int
name|tempSE_VTX_FMT_0
decl_stmt|;
name|int
name|tempSE_VTX_FMT_1
decl_stmt|;
name|int
name|tempSE_VAP_CNTL
decl_stmt|;
name|int
name|tempRE_AUX_SCISSOR_CNTL
decl_stmt|;
name|tempPP_CNTL
operator|=
literal|0
expr_stmt|;
name|tempRE_CNTL
operator|=
literal|0
expr_stmt|;
name|tempRB3D_CNTL
operator|=
name|depth_clear
operator|->
name|rb3d_cntl
expr_stmt|;
name|tempRB3D_ZSTENCILCNTL
operator|=
name|depth_clear
operator|->
name|rb3d_zstencilcntl
expr_stmt|;
name|tempRB3D_STENCILREFMASK
operator|=
literal|0x0
expr_stmt|;
name|tempSE_CNTL
operator|=
name|depth_clear
operator|->
name|se_cntl
expr_stmt|;
comment|/* Disable TCL */
name|tempSE_VAP_CNTL
operator|=
operator|(
comment|/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
operator|(
literal|0x9
operator|<<
name|SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT
operator|)
operator|)
expr_stmt|;
name|tempRB3D_PLANEMASK
operator|=
literal|0x0
expr_stmt|;
name|tempRE_AUX_SCISSOR_CNTL
operator|=
literal|0x0
expr_stmt|;
name|tempSE_VTE_CNTL
operator|=
name|SE_VTE_CNTL__VTX_XY_FMT_MASK
operator||
name|SE_VTE_CNTL__VTX_Z_FMT_MASK
expr_stmt|;
comment|/* Vertex format (X, Y, Z, W) */
name|tempSE_VTX_FMT_0
operator|=
name|SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK
operator||
name|SE_VTX_FMT_0__VTX_W0_PRESENT_MASK
expr_stmt|;
name|tempSE_VTX_FMT_1
operator|=
literal|0x0
expr_stmt|;
comment|/* 		 * Depth buffer specific enables 		 */
if|if
condition|(
name|flags
operator|&
name|RADEON_DEPTH
condition|)
block|{
comment|/* Enable depth buffer */
name|tempRB3D_CNTL
operator||=
name|RADEON_Z_ENABLE
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable depth buffer */
name|tempRB3D_CNTL
operator|&=
operator|~
name|RADEON_Z_ENABLE
expr_stmt|;
block|}
comment|/* 		 * Stencil buffer specific enables 		 */
if|if
condition|(
name|flags
operator|&
name|RADEON_STENCIL
condition|)
block|{
name|tempRB3D_CNTL
operator||=
name|RADEON_STENCIL_ENABLE
expr_stmt|;
name|tempRB3D_STENCILREFMASK
operator|=
name|clear
operator|->
name|depth_mask
expr_stmt|;
block|}
else|else
block|{
name|tempRB3D_CNTL
operator|&=
operator|~
name|RADEON_STENCIL_ENABLE
expr_stmt|;
name|tempRB3D_STENCILREFMASK
operator|=
literal|0x00000000
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_USE_COMP_ZBUF
condition|)
block|{
name|tempRB3D_ZSTENCILCNTL
operator||=
name|RADEON_Z_COMPRESSION_ENABLE
operator||
name|RADEON_Z_DECOMPRESSION_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_USE_HIERZ
condition|)
block|{
name|tempRB3D_ZSTENCILCNTL
operator||=
name|RADEON_Z_HIERARCHY_ENABLE
expr_stmt|;
block|}
name|BEGIN_RING
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_PP_CNTL
argument_list|,
name|tempPP_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_RE_CNTL
argument_list|,
name|tempRE_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_CNTL
argument_list|,
name|tempRB3D_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_ZSTENCILCNTL
argument_list|,
name|tempRB3D_ZSTENCILCNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_STENCILREFMASK
argument_list|,
name|tempRB3D_STENCILREFMASK
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_PLANEMASK
argument_list|,
name|tempRB3D_PLANEMASK
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_SE_CNTL
argument_list|,
name|tempSE_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_SE_VTE_CNTL
argument_list|,
name|tempSE_VTE_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_SE_VTX_FMT_0
argument_list|,
name|tempSE_VTX_FMT_0
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_SE_VTX_FMT_1
argument_list|,
name|tempSE_VTX_FMT_1
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_SE_VAP_CNTL
argument_list|,
name|tempSE_VAP_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|R200_RE_AUX_SCISSOR_CNTL
argument_list|,
name|tempRE_AUX_SCISSOR_CNTL
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 		 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
comment|/* Funny that this should be required -- 			 *  sets top-left? 			 */
name|radeon_emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|boxes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|R200_3D_DRAW_IMMD_2
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|RADEON_PRIM_TYPE_RECT_LIST
operator||
name|RADEON_PRIM_WALK_RING
operator||
operator|(
literal|3
operator|<<
name|RADEON_NUM_VERTICES_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x3f800000
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x3f800000
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x3f800000
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|RADEON_DEPTH
operator||
name|RADEON_STENCIL
operator|)
operator|)
condition|)
block|{
name|int
name|tempRB3D_ZSTENCILCNTL
init|=
name|depth_clear
operator|->
name|rb3d_zstencilcntl
decl_stmt|;
name|rb3d_cntl
operator|=
name|depth_clear
operator|->
name|rb3d_cntl
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RADEON_DEPTH
condition|)
block|{
name|rb3d_cntl
operator||=
name|RADEON_Z_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|rb3d_cntl
operator|&=
operator|~
name|RADEON_Z_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_STENCIL
condition|)
block|{
name|rb3d_cntl
operator||=
name|RADEON_STENCIL_ENABLE
expr_stmt|;
name|rb3d_stencilrefmask
operator|=
name|clear
operator|->
name|depth_mask
expr_stmt|;
comment|/* misnamed field */
block|}
else|else
block|{
name|rb3d_cntl
operator|&=
operator|~
name|RADEON_STENCIL_ENABLE
expr_stmt|;
name|rb3d_stencilrefmask
operator|=
literal|0x00000000
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_USE_COMP_ZBUF
condition|)
block|{
name|tempRB3D_ZSTENCILCNTL
operator||=
name|RADEON_Z_COMPRESSION_ENABLE
operator||
name|RADEON_Z_DECOMPRESSION_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RADEON_USE_HIERZ
condition|)
block|{
name|tempRB3D_ZSTENCILCNTL
operator||=
name|RADEON_Z_HIERARCHY_ENABLE
expr_stmt|;
block|}
name|BEGIN_RING
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_PP_CNTL
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x00000000
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|rb3d_cntl
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_ZSTENCILCNTL
argument_list|,
name|tempRB3D_ZSTENCILCNTL
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_STENCILREFMASK
argument_list|,
name|rb3d_stencilrefmask
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_RB3D_PLANEMASK
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_SE_CNTL
argument_list|,
name|depth_clear
operator|->
name|se_cntl
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 		 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
comment|/* Funny that this should be required -- 			 *  sets top-left? 			 */
name|radeon_emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|boxes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_DRAW_IMMD
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_VTX_Z_PRESENT
operator||
name|RADEON_VTX_PKCOLOR_PRESENT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|RADEON_PRIM_TYPE_RECT_LIST
operator||
name|RADEON_PRIM_WALK_RING
operator||
name|RADEON_MAOS_ENABLE
operator||
name|RADEON_VTX_FMT_RADEON_MODE
operator||
operator|(
literal|3
operator|<<
name|RADEON_NUM_VERTICES_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X1
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_X2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_Y2
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|depth_boxes
index|[
name|i
index|]
operator|.
name|ui
index|[
name|CLEAR_DEPTH
index|]
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Increment the clear counter.  The client-side 3D driver must 	 * wait on this value before performing the clear ioctl.  We 	 * need this because the card's so damned fast... 	 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_clear
operator|++
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|RADEON_CLEAR_AGE
argument_list|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_clear
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_swap
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|drm_clip_rect_t
modifier|*
name|pbox
init|=
name|sarea_priv
operator|->
name|boxes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Do some trivial performance monitoring... 	 */
if|if
condition|(
name|dev_priv
operator|->
name|do_boxes
condition|)
name|radeon_cp_performance_boxes
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Wait for the 3D stream to idle before dispatching the bitblt. 	 * This will prevent data corruption between the two streams. 	 */
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x1
decl_stmt|;
name|int
name|y
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y1
decl_stmt|;
name|int
name|w
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|-
name|x
decl_stmt|;
name|int
name|h
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|-
name|y
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dispatch swap %d,%d-%d,%d\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CNTL_BITBLT_MULTI
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_GMC_SRC_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_BRUSH_NONE
operator||
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|<<
literal|8
operator|)
operator||
name|RADEON_GMC_SRC_DATATYPE_COLOR
operator||
name|RADEON_ROP3_S
operator||
name|RADEON_DP_SRC_SOURCE_MEMORY
operator||
name|RADEON_GMC_CLR_CMP_CNTL_DIS
operator||
name|RADEON_GMC_WR_MSK_DIS
argument_list|)
expr_stmt|;
comment|/* Make this work even if front& back are flipped: 		 */
if|if
condition|(
name|dev_priv
operator|->
name|current_page
operator|==
literal|0
condition|)
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|back_pitch_offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|front_pitch_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|front_pitch_offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|back_pitch_offset
argument_list|)
expr_stmt|;
block|}
name|OUT_RING
argument_list|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|w
operator|<<
literal|16
operator|)
operator||
name|h
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
comment|/* Increment the frame counter.  The client-side 3D driver must 	 * throttle the framerate by waiting for this value before 	 * performing the swapbuffer ioctl. 	 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|++
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|RADEON_FRAME_AGE
argument_list|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_flip
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_sarea_t
modifier|*
name|sarea
init|=
operator|(
name|drm_sarea_t
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|handle
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|dev_priv
operator|->
name|current_page
operator|==
literal|1
operator|)
condition|?
name|dev_priv
operator|->
name|front_offset
else|:
name|dev_priv
operator|->
name|back_offset
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s: page=%d pfCurrentPage=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dev_priv
operator|->
name|current_page
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pfCurrentPage
argument_list|)
expr_stmt|;
comment|/* Do some trivial performance monitoring... 	 */
if|if
condition|(
name|dev_priv
operator|->
name|do_boxes
condition|)
block|{
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator||=
name|RADEON_BOX_FLIP
expr_stmt|;
name|radeon_cp_performance_boxes
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
comment|/* Update the frame offsets for both CRTCs 	 */
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_CRTC_OFFSET
argument_list|,
operator|(
operator|(
name|sarea
operator|->
name|frame
operator|.
name|y
operator|*
name|dev_priv
operator|->
name|front_pitch
operator|+
name|sarea
operator|->
name|frame
operator|.
name|x
operator|*
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|-
literal|2
operator|)
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_CRTC2_OFFSET
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|crtc2_base
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* Increment the frame counter.  The client-side 3D driver must 	 * throttle the framerate by waiting for this value before 	 * performing the swapbuffer ioctl. 	 */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|++
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pfCurrentPage
operator|=
name|dev_priv
operator|->
name|current_page
operator|=
literal|1
operator|-
name|dev_priv
operator|->
name|current_page
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_FRAME_AGE
argument_list|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bad_prim_vertex_nr
parameter_list|(
name|int
name|primitive
parameter_list|,
name|int
name|nr
parameter_list|)
block|{
switch|switch
condition|(
name|primitive
operator|&
name|RADEON_PRIM_TYPE_MASK
condition|)
block|{
case|case
name|RADEON_PRIM_TYPE_NONE
case|:
case|case
name|RADEON_PRIM_TYPE_POINT
case|:
return|return
name|nr
operator|<
literal|1
return|;
case|case
name|RADEON_PRIM_TYPE_LINE
case|:
return|return
operator|(
name|nr
operator|&
literal|1
operator|)
operator|||
name|nr
operator|==
literal|0
return|;
case|case
name|RADEON_PRIM_TYPE_LINE_STRIP
case|:
return|return
name|nr
operator|<
literal|2
return|;
case|case
name|RADEON_PRIM_TYPE_TRI_LIST
case|:
case|case
name|RADEON_PRIM_TYPE_3VRT_POINT_LIST
case|:
case|case
name|RADEON_PRIM_TYPE_3VRT_LINE_LIST
case|:
case|case
name|RADEON_PRIM_TYPE_RECT_LIST
case|:
return|return
name|nr
operator|%
literal|3
operator|||
name|nr
operator|==
literal|0
return|;
case|case
name|RADEON_PRIM_TYPE_TRI_FAN
case|:
case|case
name|RADEON_PRIM_TYPE_TRI_STRIP
case|:
return|return
name|nr
operator|<
literal|3
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|start
decl_stmt|;
name|unsigned
name|int
name|finish
decl_stmt|;
name|unsigned
name|int
name|prim
decl_stmt|;
name|unsigned
name|int
name|numverts
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|vc_format
decl_stmt|;
block|}
name|drm_radeon_tcl_prim_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_vertex
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|buf
parameter_list|,
name|drm_radeon_tcl_prim_t
modifier|*
name|prim
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|offset
init|=
name|dev_priv
operator|->
name|gart_buffers_offset
operator|+
name|buf
operator|->
name|offset
operator|+
name|prim
operator|->
name|start
decl_stmt|;
name|int
name|numverts
init|=
operator|(
name|int
operator|)
name|prim
operator|->
name|numverts
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"hwprim 0x%x vfmt 0x%x %d..%d %d verts\n"
argument_list|,
name|prim
operator|->
name|prim
argument_list|,
name|prim
operator|->
name|vc_format
argument_list|,
name|prim
operator|->
name|start
argument_list|,
name|prim
operator|->
name|finish
argument_list|,
name|prim
operator|->
name|numverts
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_prim_vertex_nr
argument_list|(
name|prim
operator|->
name|prim
argument_list|,
name|prim
operator|->
name|numverts
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad prim %x numverts %d\n"
argument_list|,
name|prim
operator|->
name|prim
argument_list|,
name|prim
operator|->
name|numverts
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
comment|/* Emit the next cliprect */
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
block|{
name|radeon_emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|boxes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the vertex buffer rendering commands */
name|BEGIN_RING
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_3D_RNDR_GEN_INDX_PRIM
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|numverts
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|prim
operator|->
name|vc_format
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|prim
operator|->
name|prim
operator||
name|RADEON_PRIM_WALK_LIST
operator||
name|RADEON_COLOR_ORDER_RGBA
operator||
name|RADEON_VTX_FMT_RADEON_MODE
operator||
operator|(
name|numverts
operator|<<
name|RADEON_NUM_VERTICES_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|nbox
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_discard_buffer
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|buf_priv
operator|->
name|age
operator|=
operator|++
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
expr_stmt|;
comment|/* Emit the vertex buffer age */
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_DISPATCH_AGE
argument_list|(
name|buf_priv
operator|->
name|age
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_indirect
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|buf
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"indirect: buf=%d s=0x%x e=0x%x\n"
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|end
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|dev_priv
operator|->
name|gart_buffers_offset
operator|+
name|buf
operator|->
name|offset
operator|+
name|start
operator|)
decl_stmt|;
name|int
name|dwords
init|=
operator|(
name|end
operator|-
name|start
operator|+
literal|3
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
decl_stmt|;
comment|/* Indirect buffer data must be an even number of 		 * dwords, so if we've been given an odd number we must 		 * pad the data with a Type-2 CP packet. 		 */
if|if
condition|(
name|dwords
operator|&
literal|1
condition|)
block|{
name|u32
modifier|*
name|data
init|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
operator|+
name|buf
operator|->
name|offset
operator|+
name|start
operator|)
decl_stmt|;
name|data
index|[
name|dwords
operator|++
index|]
operator|=
name|RADEON_CP_PACKET2
expr_stmt|;
block|}
comment|/* Fire off the indirect buffer */
name|BEGIN_RING
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_CP_IB_BASE
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dwords
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_indices
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_t
modifier|*
name|elt_buf
parameter_list|,
name|drm_radeon_tcl_prim_t
modifier|*
name|prim
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|offset
init|=
name|dev_priv
operator|->
name|gart_buffers_offset
operator|+
name|prim
operator|->
name|offset
decl_stmt|;
name|u32
modifier|*
name|data
decl_stmt|;
name|int
name|dwords
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|start
init|=
name|prim
operator|->
name|start
operator|+
name|RADEON_INDEX_PRIM_OFFSET
decl_stmt|;
name|int
name|count
init|=
operator|(
name|prim
operator|->
name|finish
operator|-
name|start
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"hwprim 0x%x vfmt 0x%x %d..%d offset: %x nr %d\n"
argument_list|,
name|prim
operator|->
name|prim
argument_list|,
name|prim
operator|->
name|vc_format
argument_list|,
name|prim
operator|->
name|start
argument_list|,
name|prim
operator|->
name|finish
argument_list|,
name|prim
operator|->
name|offset
argument_list|,
name|prim
operator|->
name|numverts
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_prim_vertex_nr
argument_list|(
name|prim
operator|->
name|prim
argument_list|,
name|count
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad prim %x count %d\n"
argument_list|,
name|prim
operator|->
name|prim
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|start
operator|>=
name|prim
operator|->
name|finish
operator|||
operator|(
name|prim
operator|->
name|start
operator|&
literal|0x7
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer prim %d\n"
argument_list|,
name|prim
operator|->
name|prim
argument_list|)
expr_stmt|;
return|return;
block|}
name|dwords
operator|=
operator|(
name|prim
operator|->
name|finish
operator|-
name|prim
operator|->
name|start
operator|+
literal|3
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
operator|+
name|elt_buf
operator|->
name|offset
operator|+
name|prim
operator|->
name|start
operator|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|CP_PACKET3
argument_list|(
name|RADEON_3D_RNDR_GEN_INDX_PRIM
argument_list|,
name|dwords
operator|-
literal|2
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|offset
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|prim
operator|->
name|numverts
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|prim
operator|->
name|vc_format
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
operator|(
name|prim
operator|->
name|prim
operator||
name|RADEON_PRIM_WALK_IND
operator||
name|RADEON_COLOR_ORDER_RGBA
operator||
name|RADEON_VTX_FMT_RADEON_MODE
operator||
operator|(
name|count
operator|<<
name|RADEON_NUM_VERTICES_SHIFT
operator|)
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
name|radeon_emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|boxes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|radeon_cp_dispatch_indirect
argument_list|(
name|dev
argument_list|,
name|elt_buf
argument_list|,
name|prim
operator|->
name|start
argument_list|,
name|prim
operator|->
name|finish
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|nbox
condition|)
do|;
block|}
end_function

begin_define
define|#
directive|define
name|RADEON_MAX_TEXTURE_SIZE
value|RADEON_BUFFER_SIZE
end_define

begin_function
specifier|static
name|int
name|radeon_cp_dispatch_texture
parameter_list|(
name|DRMFILE
name|filp
parameter_list|,
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_radeon_texture_t
modifier|*
name|tex
parameter_list|,
name|drm_radeon_tex_image_t
modifier|*
name|image
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|u32
name|format
decl_stmt|;
name|u32
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|u8
name|__user
modifier|*
name|data
decl_stmt|;
name|int
name|size
decl_stmt|,
name|dwords
decl_stmt|,
name|tex_width
decl_stmt|,
name|blit_width
decl_stmt|,
name|spitch
decl_stmt|;
name|u32
name|height
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u32
name|texpitch
decl_stmt|,
name|microtile
decl_stmt|;
name|u32
name|offset
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_check_and_fixup_offset
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|tex
operator|->
name|offset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid destination offset\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|dev_priv
operator|->
name|stats
operator|.
name|boxes
operator||=
name|RADEON_BOX_TEXTURE_LOAD
expr_stmt|;
comment|/* Flush the pixel cache.  This ensures no pixel data gets mixed 	 * up with the texture data from the host data blit, otherwise 	 * part of the texture image may be corrupted. 	 */
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|RADEON_FLUSH_CACHE
argument_list|()
expr_stmt|;
name|RADEON_WAIT_UNTIL_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* The compiler won't optimize away a division by a variable, 	 * even if the only legal values are powers of two.  Thus, we'll 	 * use a shift instead. 	 */
switch|switch
condition|(
name|tex
operator|->
name|format
condition|)
block|{
case|case
name|RADEON_TXFORMAT_ARGB8888
case|:
case|case
name|RADEON_TXFORMAT_RGBA8888
case|:
name|format
operator|=
name|RADEON_COLOR_FORMAT_ARGB8888
expr_stmt|;
name|tex_width
operator|=
name|tex
operator|->
name|width
operator|*
literal|4
expr_stmt|;
name|blit_width
operator|=
name|image
operator|->
name|width
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|RADEON_TXFORMAT_AI88
case|:
case|case
name|RADEON_TXFORMAT_ARGB1555
case|:
case|case
name|RADEON_TXFORMAT_RGB565
case|:
case|case
name|RADEON_TXFORMAT_ARGB4444
case|:
case|case
name|RADEON_TXFORMAT_VYUY422
case|:
case|case
name|RADEON_TXFORMAT_YVYU422
case|:
name|format
operator|=
name|RADEON_COLOR_FORMAT_RGB565
expr_stmt|;
name|tex_width
operator|=
name|tex
operator|->
name|width
operator|*
literal|2
expr_stmt|;
name|blit_width
operator|=
name|image
operator|->
name|width
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|RADEON_TXFORMAT_I8
case|:
case|case
name|RADEON_TXFORMAT_RGB332
case|:
name|format
operator|=
name|RADEON_COLOR_FORMAT_CI8
expr_stmt|;
name|tex_width
operator|=
name|tex
operator|->
name|width
operator|*
literal|1
expr_stmt|;
name|blit_width
operator|=
name|image
operator|->
name|width
operator|*
literal|1
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid texture format %d\n"
argument_list|,
name|tex
operator|->
name|format
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|spitch
operator|=
name|blit_width
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|spitch
operator|==
literal|0
operator|&&
name|image
operator|->
name|height
operator|>
literal|1
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|texpitch
operator|=
name|tex
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
operator|(
name|texpitch
operator|<<
literal|22
operator|)
operator|&
name|RADEON_DST_TILE_MICRO
condition|)
block|{
name|microtile
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tex_width
operator|<
literal|64
condition|)
block|{
name|texpitch
operator|&=
operator|~
operator|(
name|RADEON_DST_TILE_MICRO
operator|>>
literal|22
operator|)
expr_stmt|;
comment|/* we got tiled coordinates, untile them */
name|image
operator|->
name|x
operator|*=
literal|2
expr_stmt|;
block|}
block|}
else|else
name|microtile
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"tex=%dx%d blit=%d\n"
argument_list|,
name|tex_width
argument_list|,
name|tex
operator|->
name|height
argument_list|,
name|blit_width
argument_list|)
expr_stmt|;
do|do
block|{
name|DRM_DEBUG
argument_list|(
literal|"tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n"
argument_list|,
name|tex
operator|->
name|offset
operator|>>
literal|10
argument_list|,
name|tex
operator|->
name|pitch
argument_list|,
name|tex
operator|->
name|format
argument_list|,
name|image
operator|->
name|x
argument_list|,
name|image
operator|->
name|y
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Make a copy of some parameters in case we have to 		 * update them for a multi-pass texture blit. 		 */
name|height
operator|=
name|image
operator|->
name|height
expr_stmt|;
name|data
operator|=
operator|(
specifier|const
name|u8
name|__user
operator|*
operator|)
name|image
operator|->
name|data
expr_stmt|;
name|size
operator|=
name|height
operator|*
name|blit_width
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|RADEON_MAX_TEXTURE_SIZE
condition|)
block|{
name|height
operator|=
name|RADEON_MAX_TEXTURE_SIZE
operator|/
name|blit_width
expr_stmt|;
name|size
operator|=
name|height
operator|*
name|blit_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<
literal|4
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
name|size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|buf
operator|=
name|radeon_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
operator|!
name|buf
condition|)
block|{
name|radeon_do_cp_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|buf
operator|=
name|radeon_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"radeon_cp_dispatch_texture: EAGAIN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|tex
operator|->
name|image
argument_list|,
name|image
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|image
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
name|DRM_ERR
argument_list|(
name|EAGAIN
argument_list|)
return|;
block|}
comment|/* Dispatch the indirect buffer. 		 */
name|buffer
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|agp_buffer_map
operator|->
name|handle
operator|+
name|buf
operator|->
name|offset
operator|)
expr_stmt|;
name|dwords
operator|=
name|size
operator|/
literal|4
expr_stmt|;
define|#
directive|define
name|RADEON_COPY_MT
parameter_list|(
name|_buf
parameter_list|,
name|_data
parameter_list|,
name|_width
parameter_list|)
define|\
value|do { \ 		if (DRM_COPY_FROM_USER(_buf, _data, (_width))) {\ 			DRM_ERROR("EFAULT on pad, %d bytes\n", (_width)); \ 			return DRM_ERR(EFAULT); \ 		} \ 	} while(0)
if|if
condition|(
name|microtile
condition|)
block|{
comment|/* texture micro tiling in use, minimum texture width is thus 16 bytes. 			   however, we cannot use blitter directly for texture width< 64 bytes, 			   since minimum tex pitch is 64 bytes and we need this to match 			   the texture width, otherwise the blitter will tile it wrong. 			   Thus, tiling manually in this case. Additionally, need to special 			   case tex height = 1, since our actual image will have height 2 			   and we need to ensure we don't read beyond the texture size 			   from user space. */
if|if
condition|(
name|tex
operator|->
name|height
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|tex_width
operator|>=
literal|64
operator|||
name|tex_width
operator|<=
literal|16
condition|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tex_width
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tex_width
operator|==
literal|32
condition|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|RADEON_COPY_MT
argument_list|(
name|buffer
operator|+
literal|8
argument_list|,
name|data
operator|+
literal|16
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tex_width
operator|>=
literal|64
operator|||
name|tex_width
operator|==
literal|16
condition|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tex_width
operator|<
literal|16
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tex
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
name|tex_width
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
name|data
operator|+=
name|tex_width
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tex_width
operator|==
literal|32
condition|)
block|{
comment|/* TODO: make sure this works when not fitting in one buffer 				   (i.e. 32bytes x 2048...) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tex
operator|->
name|height
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|16
expr_stmt|;
name|RADEON_COPY_MT
argument_list|(
name|buffer
operator|+
literal|8
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|16
expr_stmt|;
name|RADEON_COPY_MT
argument_list|(
name|buffer
operator|+
literal|4
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|16
expr_stmt|;
name|RADEON_COPY_MT
argument_list|(
name|buffer
operator|+
literal|12
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|16
expr_stmt|;
name|buffer
operator|+=
literal|16
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|tex_width
operator|>=
literal|32
condition|)
block|{
comment|/* Texture image width is larger than the minimum, so we 				 * can upload it directly. 				 */
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dwords
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Texture image width is less than the minimum, so we 				 * need to pad out each image scanline to the minimum 				 * width. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tex
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|RADEON_COPY_MT
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
name|tex_width
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|8
expr_stmt|;
name|data
operator|+=
name|tex_width
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|RADEON_COPY_MT
name|buf
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|size
expr_stmt|;
name|offset
operator|=
name|dev_priv
operator|->
name|gart_buffers_offset
operator|+
name|buf
operator|->
name|offset
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET3
argument_list|(
name|RADEON_CNTL_BITBLT_MULTI
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_GMC_SRC_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_DST_PITCH_OFFSET_CNTL
operator||
name|RADEON_GMC_BRUSH_NONE
operator||
operator|(
name|format
operator|<<
literal|8
operator|)
operator||
name|RADEON_GMC_SRC_DATATYPE_COLOR
operator||
name|RADEON_ROP3_S
operator||
name|RADEON_DP_SRC_SOURCE_MEMORY
operator||
name|RADEON_GMC_CLR_CMP_CNTL_DIS
operator||
name|RADEON_GMC_WR_MSK_DIS
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|spitch
operator|<<
literal|22
operator|)
operator||
operator|(
name|offset
operator|>>
literal|10
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|texpitch
operator|<<
literal|22
operator|)
operator||
operator|(
name|tex
operator|->
name|offset
operator|>>
literal|10
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|image
operator|->
name|x
operator|<<
literal|16
operator|)
operator||
name|image
operator|->
name|y
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|image
operator|->
name|width
operator|<<
literal|16
operator|)
operator||
name|height
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Update the input parameters for next time */
name|image
operator|->
name|y
operator|+=
name|height
expr_stmt|;
name|image
operator|->
name|height
operator|-=
name|height
expr_stmt|;
name|image
operator|->
name|data
operator|=
operator|(
specifier|const
name|u8
name|__user
operator|*
operator|)
name|image
operator|->
name|data
operator|+
name|size
expr_stmt|;
block|}
do|while
condition|(
name|image
operator|->
name|height
operator|>
literal|0
condition|)
do|;
comment|/* Flush the pixel cache after the blit completes.  This ensures 	 * the texture data is written out to memory before rendering 	 * continues. 	 */
name|BEGIN_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|RADEON_FLUSH_CACHE
argument_list|()
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_dispatch_stipple
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|stipple
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|35
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_RE_STIPPLE_ADDR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0x00000000
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|RADEON_RE_STIPPLE_DATA
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|OUT_RING
argument_list|(
name|stipple
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_apply_surface_regs
parameter_list|(
name|int
name|surf_index
parameter_list|,
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
return|return;
name|radeon_do_cp_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_SURFACE0_INFO
operator|+
literal|16
operator|*
name|surf_index
argument_list|,
name|dev_priv
operator|->
name|surfaces
index|[
name|surf_index
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_SURFACE0_LOWER_BOUND
operator|+
literal|16
operator|*
name|surf_index
argument_list|,
name|dev_priv
operator|->
name|surfaces
index|[
name|surf_index
index|]
operator|.
name|lower
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_SURFACE0_UPPER_BOUND
operator|+
literal|16
operator|*
name|surf_index
argument_list|,
name|dev_priv
operator|->
name|surfaces
index|[
name|surf_index
index|]
operator|.
name|upper
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates a virtual surface  * doesn't always allocate a real surface, will stretch an existing  * surface when possible.  *  * Note that refcount can be at most 2, since during a free refcount=3  * might mean we have to allocate a new surface which might not always  * be available.  * For example : we allocate three contigous surfaces ABC. If B is  * freed, we suddenly need two surfaces to store A and C, which might  * not always be available.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_surface
parameter_list|(
name|drm_radeon_surface_alloc_t
modifier|*
name|new
parameter_list|,
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|DRMFILE
name|filp
parameter_list|)
block|{
name|struct
name|radeon_virt_surface
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|virt_surface_index
decl_stmt|;
name|uint32_t
name|new_upper
decl_stmt|,
name|new_lower
decl_stmt|;
name|new_lower
operator|=
name|new
operator|->
name|address
expr_stmt|;
name|new_upper
operator|=
name|new_lower
operator|+
name|new
operator|->
name|size
operator|-
literal|1
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
name|new_lower
operator|>=
name|new_upper
operator|)
operator|||
operator|(
name|new
operator|->
name|flags
operator|==
literal|0
operator|)
operator|||
operator|(
name|new
operator|->
name|size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|new_upper
operator|&
name|RADEON_SURF_ADDRESS_FIXED_MASK
operator|)
operator|!=
name|RADEON_SURF_ADDRESS_FIXED_MASK
operator|)
operator|||
operator|(
operator|(
name|new_lower
operator|&
name|RADEON_SURF_ADDRESS_FIXED_MASK
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* make sure there is no overlap with existing surfaces */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|new_lower
operator|>=
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|)
operator|&&
operator|(
name|new_lower
operator|<
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|upper
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_lower
operator|<
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|)
operator|&&
operator|(
name|new_upper
operator|>
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|)
operator|)
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* find a virtual surface */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|i
index|]
operator|.
name|filp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|2
operator|*
name|RADEON_MAX_SURFACES
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|virt_surface_index
operator|=
name|i
expr_stmt|;
comment|/* try to reuse an existing surface */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
comment|/* extend before */
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|==
literal|1
operator|)
operator|&&
operator|(
name|new
operator|->
name|flags
operator|==
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|flags
operator|)
operator|&&
operator|(
name|new_upper
operator|+
literal|1
operator|==
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|)
condition|)
block|{
name|s
operator|=
operator|&
operator|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|virt_surface_index
index|]
operator|)
expr_stmt|;
name|s
operator|->
name|surface_index
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|lower
operator|=
name|new_lower
expr_stmt|;
name|s
operator|->
name|upper
operator|=
name|new_upper
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|new
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|++
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|=
name|s
operator|->
name|lower
expr_stmt|;
name|radeon_apply_surface_regs
argument_list|(
name|s
operator|->
name|surface_index
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|virt_surface_index
return|;
block|}
comment|/* extend after */
if|if
condition|(
operator|(
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|==
literal|1
operator|)
operator|&&
operator|(
name|new
operator|->
name|flags
operator|==
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|flags
operator|)
operator|&&
operator|(
name|new_lower
operator|==
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|upper
operator|+
literal|1
operator|)
condition|)
block|{
name|s
operator|=
operator|&
operator|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|virt_surface_index
index|]
operator|)
expr_stmt|;
name|s
operator|->
name|surface_index
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|lower
operator|=
name|new_lower
expr_stmt|;
name|s
operator|->
name|upper
operator|=
name|new_upper
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|new
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|++
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|upper
operator|=
name|s
operator|->
name|upper
expr_stmt|;
name|radeon_apply_surface_regs
argument_list|(
name|s
operator|->
name|surface_index
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|virt_surface_index
return|;
block|}
block|}
comment|/* okay, we need a new one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|s
operator|=
operator|&
operator|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|virt_surface_index
index|]
operator|)
expr_stmt|;
name|s
operator|->
name|surface_index
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|lower
operator|=
name|new_lower
expr_stmt|;
name|s
operator|->
name|upper
operator|=
name|new_upper
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|new
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|lower
operator|=
name|s
operator|->
name|lower
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|upper
operator|=
name|s
operator|->
name|upper
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
name|radeon_apply_surface_regs
argument_list|(
name|s
operator|->
name|surface_index
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|virt_surface_index
return|;
block|}
block|}
comment|/* we didn't find anything */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_surface
parameter_list|(
name|DRMFILE
name|filp
parameter_list|,
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|lower
parameter_list|)
block|{
name|struct
name|radeon_virt_surface
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* find the virtual surface */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
operator|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|filp
condition|)
block|{
if|if
condition|(
operator|(
name|lower
operator|==
name|s
operator|->
name|lower
operator|)
operator|&&
operator|(
name|filp
operator|==
name|s
operator|->
name|filp
operator|)
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|lower
operator|==
name|s
operator|->
name|lower
condition|)
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|lower
operator|=
name|s
operator|->
name|upper
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|upper
operator|==
name|s
operator|->
name|upper
condition|)
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|upper
operator|=
name|s
operator|->
name|lower
expr_stmt|;
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|refcount
operator|==
literal|0
condition|)
name|dev_priv
operator|->
name|surfaces
index|[
name|s
operator|->
name|surface_index
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|filp
operator|=
name|NULL
expr_stmt|;
name|radeon_apply_surface_regs
argument_list|(
name|s
operator|->
name|surface_index
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_surfaces_release
parameter_list|(
name|DRMFILE
name|filp
parameter_list|,
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|RADEON_MAX_SURFACES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|i
index|]
operator|.
name|filp
operator|==
name|filp
condition|)
name|free_surface
argument_list|(
name|filp
argument_list|,
name|dev_priv
argument_list|,
name|dev_priv
operator|->
name|virt_surfaces
index|[
name|i
index|]
operator|.
name|lower
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ================================================================  * IOCTL functions  */
end_comment

begin_function
specifier|static
name|int
name|radeon_surface_alloc
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_surface_alloc_t
name|alloc
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|alloc
argument_list|,
operator|(
name|drm_radeon_surface_alloc_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_surface
argument_list|(
operator|&
name|alloc
argument_list|,
name|dev_priv
argument_list|,
name|filp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_surface_free
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_surface_free_t
name|memfree
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|memfree
argument_list|,
operator|(
name|drm_radeon_surface_free_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|memfree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_surface
argument_list|(
name|filp
argument_list|,
name|dev_priv
argument_list|,
name|memfree
operator|.
name|address
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_clear
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_radeon_clear_t
name|clear
decl_stmt|;
name|drm_radeon_clear_rect_t
name|depth_boxes
index|[
name|RADEON_NR_SAREA_CLIPRECTS
index|]
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|clear
argument_list|,
operator|(
name|drm_radeon_clear_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|clear
argument_list|)
argument_list|)
expr_stmt|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|RADEON_NR_SAREA_CLIPRECTS
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
name|RADEON_NR_SAREA_CLIPRECTS
expr_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|depth_boxes
argument_list|,
name|clear
operator|.
name|depth_boxes
argument_list|,
name|sarea_priv
operator|->
name|nbox
operator|*
sizeof|sizeof
argument_list|(
name|depth_boxes
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|radeon_cp_dispatch_clear
argument_list|(
name|dev
argument_list|,
operator|&
name|clear
argument_list|,
name|depth_boxes
argument_list|)
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Not sure why this isn't set all the time:  */
end_comment

begin_function
specifier|static
name|int
name|radeon_do_init_pageflip
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_CRTC_OFFSET_CNTL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_READ
argument_list|(
name|RADEON_CRTC_OFFSET_CNTL
argument_list|)
operator||
name|RADEON_CRTC_OFFSET_FLIP_CNTL
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_CRTC2_OFFSET_CNTL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|RADEON_READ
argument_list|(
name|RADEON_CRTC2_OFFSET_CNTL
argument_list|)
operator||
name|RADEON_CRTC_OFFSET_FLIP_CNTL
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|dev_priv
operator|->
name|page_flipping
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|current_page
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pfCurrentPage
operator|=
name|dev_priv
operator|->
name|current_page
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called whenever a client dies, from drm_release.  * NOTE:  Lock isn't necessarily held when this is called!  */
end_comment

begin_function
specifier|static
name|int
name|radeon_do_cleanup_pageflip
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|current_page
operator|!=
literal|0
condition|)
name|radeon_cp_dispatch_flip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|page_flipping
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Swapping and flipping are different operations, need different ioctls.  * They can& should be intermixed to support multiple 3d windows.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_cp_flip
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|page_flipping
condition|)
name|radeon_do_init_pageflip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|radeon_cp_dispatch_flip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_swap
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|RADEON_NR_SAREA_CLIPRECTS
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
name|RADEON_NR_SAREA_CLIPRECTS
expr_stmt|;
name|radeon_cp_dispatch_swap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_vertex
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|drm_radeon_vertex_t
name|vertex
decl_stmt|;
name|drm_radeon_tcl_prim_t
name|prim
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sarea_priv
operator|=
name|dev_priv
operator|->
name|sarea_priv
expr_stmt|;
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|vertex
argument_list|,
operator|(
name|drm_radeon_vertex_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|vertex
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d index=%d count=%d discard=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|vertex
operator|.
name|idx
argument_list|,
name|vertex
operator|.
name|count
argument_list|,
name|vertex
operator|.
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertex
operator|.
name|idx
operator|<
literal|0
operator|||
name|vertex
operator|.
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|vertex
operator|.
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|vertex
operator|.
name|prim
operator|<
literal|0
operator|||
name|vertex
operator|.
name|prim
operator|>
name|RADEON_PRIM_TYPE_3VRT_LINE_LIST
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer prim %d\n"
argument_list|,
name|vertex
operator|.
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|vertex
operator|.
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"process %d using buffer owned by %p\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|buf
operator|->
name|filp
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"sending pending buffer %d\n"
argument_list|,
name|vertex
operator|.
name|idx
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Build up a prim_t record: 	 */
if|if
condition|(
name|vertex
operator|.
name|count
condition|)
block|{
name|buf
operator|->
name|used
operator|=
name|vertex
operator|.
name|count
expr_stmt|;
comment|/* not used? */
if|if
condition|(
name|sarea_priv
operator|->
name|dirty
operator|&
operator|~
name|RADEON_UPLOAD_CLIPRECTS
condition|)
block|{
if|if
condition|(
name|radeon_emit_state
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|context_state
argument_list|,
name|sarea_priv
operator|->
name|tex_state
argument_list|,
name|sarea_priv
operator|->
name|dirty
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_state failed\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
operator|(
name|RADEON_UPLOAD_TEX0IMAGES
operator||
name|RADEON_UPLOAD_TEX1IMAGES
operator||
name|RADEON_UPLOAD_TEX2IMAGES
operator||
name|RADEON_REQUIRE_QUIESCENCE
operator|)
expr_stmt|;
block|}
name|prim
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|prim
operator|.
name|finish
operator|=
name|vertex
operator|.
name|count
expr_stmt|;
comment|/* unused */
name|prim
operator|.
name|prim
operator|=
name|vertex
operator|.
name|prim
expr_stmt|;
name|prim
operator|.
name|numverts
operator|=
name|vertex
operator|.
name|count
expr_stmt|;
name|prim
operator|.
name|vc_format
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|vc_format
expr_stmt|;
name|radeon_cp_dispatch_vertex
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|prim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vertex
operator|.
name|discard
condition|)
block|{
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_indices
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|drm_radeon_indices_t
name|elts
decl_stmt|;
name|drm_radeon_tcl_prim_t
name|prim
decl_stmt|;
name|int
name|count
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sarea_priv
operator|=
name|dev_priv
operator|->
name|sarea_priv
expr_stmt|;
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|elts
argument_list|,
operator|(
name|drm_radeon_indices_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|elts
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d index=%d start=%d end=%d discard=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|elts
operator|.
name|idx
argument_list|,
name|elts
operator|.
name|start
argument_list|,
name|elts
operator|.
name|end
argument_list|,
name|elts
operator|.
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
operator|.
name|idx
operator|<
literal|0
operator|||
name|elts
operator|.
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|elts
operator|.
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|elts
operator|.
name|prim
operator|<
literal|0
operator|||
name|elts
operator|.
name|prim
operator|>
name|RADEON_PRIM_TYPE_3VRT_LINE_LIST
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer prim %d\n"
argument_list|,
name|elts
operator|.
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|elts
operator|.
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"process %d using buffer owned by %p\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|buf
operator|->
name|filp
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"sending pending buffer %d\n"
argument_list|,
name|elts
operator|.
name|idx
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|count
operator|=
operator|(
name|elts
operator|.
name|end
operator|-
name|elts
operator|.
name|start
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
expr_stmt|;
name|elts
operator|.
name|start
operator|-=
name|RADEON_INDEX_PRIM_OFFSET
expr_stmt|;
if|if
condition|(
name|elts
operator|.
name|start
operator|&
literal|0x7
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"misaligned buffer 0x%x\n"
argument_list|,
name|elts
operator|.
name|start
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|elts
operator|.
name|start
operator|<
name|buf
operator|->
name|used
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"no header 0x%x - 0x%x\n"
argument_list|,
name|elts
operator|.
name|start
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|buf
operator|->
name|used
operator|=
name|elts
operator|.
name|end
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|dirty
operator|&
operator|~
name|RADEON_UPLOAD_CLIPRECTS
condition|)
block|{
if|if
condition|(
name|radeon_emit_state
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|context_state
argument_list|,
name|sarea_priv
operator|->
name|tex_state
argument_list|,
name|sarea_priv
operator|->
name|dirty
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_state failed\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
operator|(
name|RADEON_UPLOAD_TEX0IMAGES
operator||
name|RADEON_UPLOAD_TEX1IMAGES
operator||
name|RADEON_UPLOAD_TEX2IMAGES
operator||
name|RADEON_REQUIRE_QUIESCENCE
operator|)
expr_stmt|;
block|}
comment|/* Build up a prim_t record: 	 */
name|prim
operator|.
name|start
operator|=
name|elts
operator|.
name|start
expr_stmt|;
name|prim
operator|.
name|finish
operator|=
name|elts
operator|.
name|end
expr_stmt|;
name|prim
operator|.
name|prim
operator|=
name|elts
operator|.
name|prim
expr_stmt|;
name|prim
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* offset from start of dma buffers */
name|prim
operator|.
name|numverts
operator|=
name|RADEON_MAX_VB_VERTS
expr_stmt|;
comment|/* duh */
name|prim
operator|.
name|vc_format
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|vc_format
expr_stmt|;
name|radeon_cp_dispatch_indices
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|prim
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
operator|.
name|discard
condition|)
block|{
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_texture
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_texture_t
name|tex
decl_stmt|;
name|drm_radeon_tex_image_t
name|image
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|tex
argument_list|,
operator|(
name|drm_radeon_texture_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tex
operator|.
name|image
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"null texture image!\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|image
argument_list|,
operator|(
name|drm_radeon_tex_image_t
name|__user
operator|*
operator|)
name|tex
operator|.
name|image
argument_list|,
sizeof|sizeof
argument_list|(
name|image
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ret
operator|=
name|radeon_cp_dispatch_texture
argument_list|(
name|filp
argument_list|,
name|dev
argument_list|,
operator|&
name|tex
argument_list|,
operator|&
name|image
argument_list|)
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_stipple
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_stipple_t
name|stipple
decl_stmt|;
name|u32
name|mask
index|[
literal|32
index|]
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|stipple
argument_list|,
operator|(
name|drm_radeon_stipple_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|stipple
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|mask
argument_list|,
name|stipple
operator|.
name|mask
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|radeon_cp_dispatch_stipple
argument_list|(
name|dev
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_indirect
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|drm_radeon_indirect_t
name|indirect
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|indirect
argument_list|,
operator|(
name|drm_radeon_indirect_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|indirect
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"indirect: idx=%d s=%d e=%d d=%d\n"
argument_list|,
name|indirect
operator|.
name|idx
argument_list|,
name|indirect
operator|.
name|start
argument_list|,
name|indirect
operator|.
name|end
argument_list|,
name|indirect
operator|.
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
operator|.
name|idx
operator|<
literal|0
operator|||
name|indirect
operator|.
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|indirect
operator|.
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|indirect
operator|.
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"process %d using buffer owned by %p\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|buf
operator|->
name|filp
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"sending pending buffer %d\n"
argument_list|,
name|indirect
operator|.
name|idx
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|indirect
operator|.
name|start
operator|<
name|buf
operator|->
name|used
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"reusing indirect: start=0x%x actual=0x%x\n"
argument_list|,
name|indirect
operator|.
name|start
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|indirect
operator|.
name|end
expr_stmt|;
comment|/* Wait for the 3D stream to idle before the indirect buffer 	 * containing 2D acceleration commands is processed. 	 */
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
comment|/* Dispatch the indirect buffer full of commands from the 	 * X server.  This is insecure and is thus only available to 	 * privileged clients. 	 */
name|radeon_cp_dispatch_indirect
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|indirect
operator|.
name|start
argument_list|,
name|indirect
operator|.
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
operator|.
name|discard
condition|)
block|{
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_vertex2
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_radeon_sarea_t
modifier|*
name|sarea_priv
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|drm_radeon_vertex2_t
name|vertex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|laststate
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sarea_priv
operator|=
name|dev_priv
operator|->
name|sarea_priv
expr_stmt|;
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|vertex
argument_list|,
operator|(
name|drm_radeon_vertex2_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|vertex
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d index=%d discard=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|vertex
operator|.
name|idx
argument_list|,
name|vertex
operator|.
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertex
operator|.
name|idx
operator|<
literal|0
operator|||
name|vertex
operator|.
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|vertex
operator|.
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|vertex
operator|.
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"process %d using buffer owned by %p\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|buf
operator|->
name|filp
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"sending pending buffer %d\n"
argument_list|,
name|vertex
operator|.
name|idx
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|RADEON_NR_SAREA_CLIPRECTS
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
for|for
control|(
name|laststate
operator|=
literal|0xff
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertex
operator|.
name|nr_prims
condition|;
name|i
operator|++
control|)
block|{
name|drm_radeon_prim_t
name|prim
decl_stmt|;
name|drm_radeon_tcl_prim_t
name|tclprim
decl_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|prim
argument_list|,
operator|&
name|vertex
operator|.
name|prim
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|prim
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|prim
operator|.
name|stateidx
operator|!=
name|laststate
condition|)
block|{
name|drm_radeon_state_t
name|state
decl_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|state
argument_list|,
operator|&
name|vertex
operator|.
name|state
index|[
name|prim
operator|.
name|stateidx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|radeon_emit_state2
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_state2 failed\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|laststate
operator|=
name|prim
operator|.
name|stateidx
expr_stmt|;
block|}
name|tclprim
operator|.
name|start
operator|=
name|prim
operator|.
name|start
expr_stmt|;
name|tclprim
operator|.
name|finish
operator|=
name|prim
operator|.
name|finish
expr_stmt|;
name|tclprim
operator|.
name|prim
operator|=
name|prim
operator|.
name|prim
expr_stmt|;
name|tclprim
operator|.
name|vc_format
operator|=
name|prim
operator|.
name|vc_format
expr_stmt|;
if|if
condition|(
name|prim
operator|.
name|prim
operator|&
name|RADEON_PRIM_WALK_IND
condition|)
block|{
name|tclprim
operator|.
name|offset
operator|=
name|prim
operator|.
name|numverts
operator|*
literal|64
expr_stmt|;
name|tclprim
operator|.
name|numverts
operator|=
name|RADEON_MAX_VB_VERTS
expr_stmt|;
comment|/* duh */
name|radeon_cp_dispatch_indices
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|tclprim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tclprim
operator|.
name|numverts
operator|=
name|prim
operator|.
name|numverts
expr_stmt|;
name|tclprim
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* not used */
name|radeon_cp_dispatch_vertex
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|tclprim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|==
literal|1
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vertex
operator|.
name|discard
condition|)
block|{
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_emit_packets
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_cmd_header_t
name|header
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|id
init|=
operator|(
name|int
operator|)
name|header
operator|.
name|packet
operator|.
name|packet_id
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|reg
decl_stmt|;
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|cmdbuf
operator|->
name|buf
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
name|id
operator|>=
name|RADEON_MAX_STATE_PACKETS
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|sz
operator|=
name|packet
index|[
name|id
index|]
operator|.
name|len
expr_stmt|;
name|reg
operator|=
name|packet
index|[
name|id
index|]
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Packet size provided larger than data provided\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|radeon_check_and_fixup_packets
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
name|id
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Packet verification failed\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|BEGIN_RING
argument_list|(
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|reg
argument_list|,
operator|(
name|sz
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|radeon_emit_scalars
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_header_t
name|header
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|sz
init|=
name|header
operator|.
name|scalars
operator|.
name|count
decl_stmt|;
name|int
name|start
init|=
name|header
operator|.
name|scalars
operator|.
name|offset
decl_stmt|;
name|int
name|stride
init|=
name|header
operator|.
name|scalars
operator|.
name|stride
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|3
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_TCL_SCALAR_INDX_REG
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|start
operator||
operator|(
name|stride
operator|<<
name|RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|RADEON_SE_TCL_SCALAR_DATA_REG
argument_list|,
name|sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* God this is ugly  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|radeon_emit_scalars2
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_header_t
name|header
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|sz
init|=
name|header
operator|.
name|scalars
operator|.
name|count
decl_stmt|;
name|int
name|start
init|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|header
operator|.
name|scalars
operator|.
name|offset
operator|)
operator|+
literal|0x100
decl_stmt|;
name|int
name|stride
init|=
name|header
operator|.
name|scalars
operator|.
name|stride
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|3
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_TCL_SCALAR_INDX_REG
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|start
operator||
operator|(
name|stride
operator|<<
name|RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|RADEON_SE_TCL_SCALAR_DATA_REG
argument_list|,
name|sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|radeon_emit_vectors
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_header_t
name|header
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|sz
init|=
name|header
operator|.
name|vectors
operator|.
name|count
decl_stmt|;
name|int
name|start
init|=
name|header
operator|.
name|vectors
operator|.
name|offset
decl_stmt|;
name|int
name|stride
init|=
name|header
operator|.
name|vectors
operator|.
name|stride
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|5
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_SE_TCL_STATE_FLUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_TCL_VECTOR_INDX_REG
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|start
operator||
operator|(
name|stride
operator|<<
name|RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|RADEON_SE_TCL_VECTOR_DATA_REG
argument_list|,
operator|(
name|sz
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|radeon_emit_veclinear
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_radeon_cmd_header_t
name|header
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|int
name|sz
init|=
name|header
operator|.
name|veclinear
operator|.
name|count
operator|*
literal|4
decl_stmt|;
name|int
name|start
init|=
name|header
operator|.
name|veclinear
operator|.
name|addr_lo
operator||
operator|(
name|header
operator|.
name|veclinear
operator|.
name|addr_hi
operator|<<
literal|8
operator|)
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
operator|!
name|sz
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sz
operator|*
literal|4
operator|>
name|cmdbuf
operator|->
name|bufsz
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|BEGIN_RING
argument_list|(
literal|5
operator|+
name|sz
argument_list|)
expr_stmt|;
name|OUT_RING_REG
argument_list|(
name|RADEON_SE_TCL_STATE_FLUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0
argument_list|(
name|RADEON_SE_TCL_VECTOR_INDX_REG
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|start
operator||
operator|(
literal|1
operator|<<
name|RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CP_PACKET0_TABLE
argument_list|(
name|RADEON_SE_TCL_VECTOR_DATA_REG
argument_list|,
operator|(
name|sz
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_emit_packet3
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|int
name|cmdsz
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|radeon_check_and_fixup_packet3
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
name|cmdbuf
argument_list|,
operator|&
name|cmdsz
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Packet verification failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|BEGIN_RING
argument_list|(
name|cmdsz
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdsz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
name|cmdbuf
operator|->
name|buf
operator|+=
name|cmdsz
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|cmdsz
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_emit_packet3_cliprect
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|,
name|drm_radeon_kcmd_buffer_t
modifier|*
name|cmdbuf
parameter_list|,
name|int
name|orig_nbox
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_clip_rect_t
name|box
decl_stmt|;
name|unsigned
name|int
name|cmdsz
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|drm_clip_rect_t
name|__user
modifier|*
name|boxes
init|=
name|cmdbuf
operator|->
name|boxes
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|radeon_check_and_fixup_packet3
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
name|cmdbuf
argument_list|,
operator|&
name|cmdsz
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Packet verification failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|orig_nbox
condition|)
goto|goto
name|out
goto|;
do|do
block|{
if|if
condition|(
name|i
operator|<
name|cmdbuf
operator|->
name|nbox
condition|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|boxes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* FIXME The second and subsequent times round 			 * this loop, send a WAIT_UNTIL_3D_IDLE before 			 * calling emit_clip_rect(). This fixes a 			 * lockup on fast machines when sending 			 * several cliprects with a cmdbuf, as when 			 * waving a 2D window over a 3D 			 * window. Something in the commands from user 			 * space seems to hang the card when they're 			 * sent several times in a row. That would be 			 * the correct place to fix it but this works 			 * around it until I can figure that out - Tim 			 * Smith */
if|if
condition|(
name|i
condition|)
block|{
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
name|radeon_emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|box
argument_list|)
expr_stmt|;
block|}
name|BEGIN_RING
argument_list|(
name|cmdsz
argument_list|)
expr_stmt|;
name|OUT_RING_TABLE
argument_list|(
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdsz
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|cmdbuf
operator|->
name|nbox
condition|)
do|;
if|if
condition|(
name|cmdbuf
operator|->
name|nbox
operator|==
literal|1
condition|)
name|cmdbuf
operator|->
name|nbox
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|cmdbuf
operator|->
name|buf
operator|+=
name|cmdsz
operator|*
literal|4
expr_stmt|;
name|cmdbuf
operator|->
name|bufsz
operator|-=
name|cmdsz
operator|*
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_emit_wait
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s: %x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|RADEON_WAIT_2D
case|:
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_2D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
break|break;
case|case
name|RADEON_WAIT_3D
case|:
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_3D_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
break|break;
case|case
name|RADEON_WAIT_2D
operator||
name|RADEON_WAIT_3D
case|:
name|BEGIN_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RADEON_WAIT_UNTIL_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_cmdbuf
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|drm_radeon_kcmd_buffer_t
name|cmdbuf
decl_stmt|;
name|drm_radeon_cmd_header_t
name|header
decl_stmt|;
name|int
name|orig_nbox
decl_stmt|,
name|orig_bufsz
decl_stmt|;
name|char
modifier|*
name|kbuf
init|=
name|NULL
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|cmdbuf
argument_list|,
operator|(
name|drm_radeon_kcmd_buffer_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|RING_SPACE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|VB_AGE_TEST_WITH_RETURN
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|.
name|bufsz
operator|>
literal|64
operator|*
literal|1024
operator|||
name|cmdbuf
operator|.
name|bufsz
operator|<
literal|0
condition|)
block|{
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Allocate an in-kernel area and copy in the cmdbuf.  Do this to avoid 	 * races between checking values and using those values in other code, 	 * and simply to avoid a lot of function calls to copy in data. 	 */
name|orig_bufsz
operator|=
name|cmdbuf
operator|.
name|bufsz
expr_stmt|;
if|if
condition|(
name|orig_bufsz
operator|!=
literal|0
condition|)
block|{
name|kbuf
operator|=
name|drm_alloc
argument_list|(
name|cmdbuf
operator|.
name|bufsz
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbuf
operator|==
name|NULL
condition|)
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|kbuf
argument_list|,
operator|(
name|void
name|__user
operator|*
operator|)
name|cmdbuf
operator|.
name|buf
argument_list|,
name|cmdbuf
operator|.
name|bufsz
argument_list|)
condition|)
block|{
name|drm_free
argument_list|(
name|kbuf
argument_list|,
name|orig_bufsz
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|cmdbuf
operator|.
name|buf
operator|=
name|kbuf
expr_stmt|;
block|}
name|orig_nbox
operator|=
name|cmdbuf
operator|.
name|nbox
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|microcode_version
operator|==
name|UCODE_R300
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|r300_do_cp_cmdbuf
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_bufsz
operator|!=
literal|0
condition|)
name|drm_free
argument_list|(
name|kbuf
argument_list|,
name|orig_bufsz
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* microcode_version != r300 */
while|while
condition|(
name|cmdbuf
operator|.
name|bufsz
operator|>=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|header
operator|.
name|i
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|cmdbuf
operator|.
name|buf
expr_stmt|;
name|cmdbuf
operator|.
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|cmdbuf
operator|.
name|bufsz
operator|-=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|.
name|header
operator|.
name|cmd_type
condition|)
block|{
case|case
name|RADEON_CMD_PACKET
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_PACKET\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_packets
argument_list|(
name|dev_priv
argument_list|,
name|filp_priv
argument_list|,
name|header
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_packets failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_SCALARS
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_SCALARS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_scalars
argument_list|(
name|dev_priv
argument_list|,
name|header
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_scalars failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_VECTORS
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_VECTORS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_vectors
argument_list|(
name|dev_priv
argument_list|,
name|header
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_vectors failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_DMA_DISCARD
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_DMA_DISCARD\n"
argument_list|)
expr_stmt|;
name|idx
operator|=
name|header
operator|.
name|dma
operator|.
name|buf_idx
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer index %d (of %d max)\n"
argument_list|,
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
operator|||
name|buf
operator|->
name|pending
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad buffer %p %p %d\n"
argument_list|,
name|buf
operator|->
name|filp
argument_list|,
name|filp
argument_list|,
name|buf
operator|->
name|pending
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|radeon_cp_discard_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RADEON_CMD_PACKET3
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_PACKET3\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_packet3
argument_list|(
name|dev
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_packet3 failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_PACKET3_CLIP
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_PACKET3_CLIP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_packet3_cliprect
argument_list|(
name|dev
argument_list|,
name|filp_priv
argument_list|,
operator|&
name|cmdbuf
argument_list|,
name|orig_nbox
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_packet3_clip failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_SCALARS2
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_SCALARS2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_scalars2
argument_list|(
name|dev_priv
argument_list|,
name|header
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_scalars2 failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_WAIT
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_WAIT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_wait
argument_list|(
name|dev
argument_list|,
name|header
operator|.
name|wait
operator|.
name|flags
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_wait failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|RADEON_CMD_VECLINEAR
case|:
name|DRM_DEBUG
argument_list|(
literal|"RADEON_CMD_VECLINEAR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_emit_veclinear
argument_list|(
name|dev_priv
argument_list|,
name|header
argument_list|,
operator|&
name|cmdbuf
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"radeon_emit_veclinear failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"bad cmd_type %d at %p\n"
argument_list|,
name|header
operator|.
name|header
operator|.
name|cmd_type
argument_list|,
name|cmdbuf
operator|.
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|orig_bufsz
operator|!=
literal|0
condition|)
name|drm_free
argument_list|(
name|kbuf
argument_list|,
name|orig_bufsz
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"DONE\n"
argument_list|)
expr_stmt|;
name|COMMIT_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|orig_bufsz
operator|!=
literal|0
condition|)
name|drm_free
argument_list|(
name|kbuf
argument_list|,
name|orig_bufsz
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_getparam
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_getparam_t
name|param
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|param
argument_list|,
operator|(
name|drm_radeon_getparam_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|param
operator|.
name|param
condition|)
block|{
case|case
name|RADEON_PARAM_GART_BUFFER_OFFSET
case|:
name|value
operator|=
name|dev_priv
operator|->
name|gart_buffers_offset
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_LAST_FRAME
case|:
name|dev_priv
operator|->
name|stats
operator|.
name|last_frame_reads
operator|++
expr_stmt|;
name|value
operator|=
name|GET_SCRATCH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_LAST_DISPATCH
case|:
name|value
operator|=
name|GET_SCRATCH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_LAST_CLEAR
case|:
name|dev_priv
operator|->
name|stats
operator|.
name|last_clear_reads
operator|++
expr_stmt|;
name|value
operator|=
name|GET_SCRATCH
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_IRQ_NR
case|:
name|value
operator|=
name|dev
operator|->
name|irq
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_GART_BASE
case|:
name|value
operator|=
name|dev_priv
operator|->
name|gart_vm_start
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_REGISTER_HANDLE
case|:
name|value
operator|=
name|dev_priv
operator|->
name|mmio
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_STATUS_HANDLE
case|:
name|value
operator|=
name|dev_priv
operator|->
name|ring_rptr_offset
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|__LP64__
comment|/* 		 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a 		 * pointer which can't fit into an int-sized variable.  According to 		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so 		 * not supporting it shouldn't be a problem.  If the same functionality 		 * is needed on 64-bit platforms, a new ioctl() would have to be added, 		 * so backwards-compatibility for the embedded platforms can be 		 * maintained.  --davidm 4-Feb-2004. 		 */
case|case
name|RADEON_PARAM_SAREA_HANDLE
case|:
comment|/* The lock is the first dword in the sarea. */
name|value
operator|=
operator|(
name|long
operator|)
name|dev
operator|->
name|lock
operator|.
name|hw_lock
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|RADEON_PARAM_GART_TEX_HANDLE
case|:
name|value
operator|=
name|dev_priv
operator|->
name|gart_textures_offset
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_SCRATCH_OFFSET
case|:
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|writeback_works
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|value
operator|=
name|RADEON_SCRATCH_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|RADEON_PARAM_CARD_TYPE
case|:
if|if
condition|(
name|dev_priv
operator|->
name|flags
operator|&
name|CHIP_IS_PCIE
condition|)
name|value
operator|=
name|RADEON_CARD_PCIE
expr_stmt|;
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|flags
operator|&
name|CHIP_IS_AGP
condition|)
name|value
operator|=
name|RADEON_CARD_AGP
expr_stmt|;
else|else
name|value
operator|=
name|RADEON_CARD_PCI
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"Invalid parameter %d\n"
argument_list|,
name|param
operator|.
name|param
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|param
operator|.
name|value
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"copy_to_user\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_cp_setparam
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_file_t
modifier|*
name|filp_priv
decl_stmt|;
name|drm_radeon_setparam_t
name|sp
decl_stmt|;
name|struct
name|drm_radeon_driver_file_fields
modifier|*
name|radeon_priv
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s called with no initialization\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_GET_PRIV_WITH_RETURN
argument_list|(
name|filp_priv
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|sp
argument_list|,
operator|(
name|drm_radeon_setparam_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|.
name|param
condition|)
block|{
case|case
name|RADEON_SETPARAM_FB_LOCATION
case|:
name|radeon_priv
operator|=
name|filp_priv
operator|->
name|driver_priv
expr_stmt|;
name|radeon_priv
operator|->
name|radeon_fb_delta
operator|=
name|dev_priv
operator|->
name|fb_location
operator|-
name|sp
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|RADEON_SETPARAM_SWITCH_TILING
case|:
if|if
condition|(
name|sp
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"color tiling disabled\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch_offset
operator|&=
operator|~
name|RADEON_DST_TILE_MACRO
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch_offset
operator|&=
operator|~
name|RADEON_DST_TILE_MACRO
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|tiling_enabled
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|.
name|value
operator|==
literal|1
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"color tiling enabled\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch_offset
operator||=
name|RADEON_DST_TILE_MACRO
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch_offset
operator||=
name|RADEON_DST_TILE_MACRO
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|tiling_enabled
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RADEON_SETPARAM_PCIGART_LOCATION
case|:
name|dev_priv
operator|->
name|pcigart_offset
operator|=
name|sp
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|RADEON_SETPARAM_NEW_MEMMAP
case|:
name|dev_priv
operator|->
name|new_memmap
operator|=
name|sp
operator|.
name|value
expr_stmt|;
break|break;
default|default:
name|DRM_DEBUG
argument_list|(
literal|"Invalid parameter %d\n"
argument_list|,
name|sp
operator|.
name|param
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When a client dies:  *    - Check for and clean up flipped page state  *    - Free any alloced GART memory.  *    - Free any alloced radeon surfaces.  *  * DRM infrastructure takes care of reclaiming dma buffers.  */
end_comment

begin_function
name|void
name|radeon_driver_preclose
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|DRMFILE
name|filp
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|page_flipping
condition|)
block|{
name|radeon_do_cleanup_pageflip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|radeon_mem_release
argument_list|(
name|filp
argument_list|,
name|dev_priv
operator|->
name|gart_heap
argument_list|)
expr_stmt|;
name|radeon_mem_release
argument_list|(
name|filp
argument_list|,
name|dev_priv
operator|->
name|fb_heap
argument_list|)
expr_stmt|;
name|radeon_surfaces_release
argument_list|(
name|filp
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|radeon_driver_lastclose
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|radeon_do_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|radeon_driver_open
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_radeon_driver_file_fields
modifier|*
name|radeon_priv
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|radeon_priv
operator|=
operator|(
expr|struct
name|drm_radeon_driver_file_fields
operator|*
operator|)
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|radeon_priv
argument_list|)
argument_list|,
name|DRM_MEM_FILES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|filp_priv
operator|->
name|driver_priv
operator|=
name|radeon_priv
expr_stmt|;
if|if
condition|(
name|dev_priv
condition|)
name|radeon_priv
operator|->
name|radeon_fb_delta
operator|=
name|dev_priv
operator|->
name|fb_location
expr_stmt|;
else|else
name|radeon_priv
operator|->
name|radeon_fb_delta
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|radeon_driver_postclose
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_file_t
modifier|*
name|filp_priv
parameter_list|)
block|{
name|struct
name|drm_radeon_driver_file_fields
modifier|*
name|radeon_priv
init|=
name|filp_priv
operator|->
name|driver_priv
decl_stmt|;
name|drm_free
argument_list|(
name|radeon_priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|radeon_priv
argument_list|)
argument_list|,
name|DRM_MEM_FILES
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|drm_ioctl_desc_t
name|radeon_ioctls
index|[]
init|=
block|{
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_INIT
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_init
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_START
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_start
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_STOP
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_stop
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_RESET
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_reset
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_IDLE
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_idle
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CP_RESUME
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_resume
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_RESET
argument_list|)
index|]
operator|=
block|{
name|radeon_engine_reset
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_FULLSCREEN
argument_list|)
index|]
operator|=
block|{
name|radeon_fullscreen
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_SWAP
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_swap
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CLEAR
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_clear
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_VERTEX
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_vertex
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_INDICES
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_indices
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_TEXTURE
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_texture
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_STIPPLE
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_stipple
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_INDIRECT
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_indirect
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_VERTEX2
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_vertex2
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_CMDBUF
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_cmdbuf
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_GETPARAM
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_getparam
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_FLIP
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_flip
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_ALLOC
argument_list|)
index|]
operator|=
block|{
name|radeon_mem_alloc
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_FREE
argument_list|)
index|]
operator|=
block|{
name|radeon_mem_free
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_INIT_HEAP
argument_list|)
index|]
operator|=
block|{
name|radeon_mem_init_heap
block|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_IRQ_EMIT
argument_list|)
index|]
operator|=
block|{
name|radeon_irq_emit
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_IRQ_WAIT
argument_list|)
index|]
operator|=
block|{
name|radeon_irq_wait
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_SETPARAM
argument_list|)
index|]
operator|=
block|{
name|radeon_cp_setparam
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_SURF_ALLOC
argument_list|)
index|]
operator|=
block|{
name|radeon_surface_alloc
block|,
name|DRM_AUTH
block|}
block|,
index|[
name|DRM_IOCTL_NR
argument_list|(
name|DRM_RADEON_SURF_FREE
argument_list|)
index|]
operator|=
block|{
name|radeon_surface_free
block|,
name|DRM_AUTH
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|radeon_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|radeon_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

