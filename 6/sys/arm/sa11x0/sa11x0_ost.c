begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: sa11x0_ost.c,v 1.11 2003/07/15 00:24:51 lukem Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 Mark Brinicombe.  * Copyright (c) 1997 Causality Limited.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by IWAMOTO Toshihiro and Ichiro FUKUHARA.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/katelib.h>
end_include

begin_include
include|#
directive|include
file|<arm/sa11x0/sa11x0_reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/sa11x0/sa11x0_var.h>
end_include

begin_include
include|#
directive|include
file|<arm/sa11x0/sa11x0_ostreg.h>
end_include

begin_function_decl
specifier|static
name|int
name|saost_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saost_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gettick
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clockintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	statintr(void *);
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|rtcinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct mtx clock_lock;
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|saost_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|bus_addr_t
name|sc_baseaddr
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
name|u_int32_t
name|sc_clock_count
decl_stmt|;
name|u_int32_t
name|sc_statclock_count
decl_stmt|;
name|u_int32_t
name|sc_statclock_step
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|saost_softc
modifier|*
name|saost_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TIMER_FREQUENCY
value|3686400
end_define

begin_comment
comment|/* 3.6864MHz */
end_comment

begin_define
define|#
directive|define
name|TICKS_PER_MICROSECOND
value|(TIMER_FREQUENCY/1000000)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|STATHZ
end_ifndef

begin_define
define|#
directive|define
name|STATHZ
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|saost_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|saost_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|saost_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|saost_driver
init|=
block|{
literal|"saost"
block|,
name|saost_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|saost_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|saost_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|saost
argument_list|,
name|saip
argument_list|,
name|saost_driver
argument_list|,
name|saost_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|saost_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saost_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|saost_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sa11x0_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|sa
operator|->
name|sc_iot
expr_stmt|;
name|sc
operator|->
name|sc_baseaddr
operator|=
literal|0x90000000
expr_stmt|;
name|saost_sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|sa
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_baseaddr
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: Cannot map registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable all channel and clear interrupt status */
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_IR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_SR
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clockintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|clockframe
modifier|*
name|frame
init|=
name|arg
decl_stmt|;
name|u_int32_t
name|oscr
decl_stmt|,
name|nextmatch
decl_stmt|,
name|oldmatch
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
literal|0
block|mtx_lock_spin(&clock_lock);
endif|#
directive|endif
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_SR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* schedule next clock intr */
name|oldmatch
operator|=
name|saost_sc
operator|->
name|sc_clock_count
expr_stmt|;
name|nextmatch
operator|=
name|oldmatch
operator|+
name|TIMER_FREQUENCY
operator|/
name|hz
expr_stmt|;
name|oscr
operator|=
name|bus_space_read_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_CR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextmatch
operator|>
name|oldmatch
operator|&&
operator|(
name|oscr
operator|>
name|nextmatch
operator|||
name|oscr
operator|<
name|oldmatch
operator|)
operator|)
operator|||
operator|(
name|nextmatch
operator|<
name|oldmatch
operator|&&
name|oscr
operator|>
name|nextmatch
operator|&&
name|oscr
operator|<
name|oldmatch
operator|)
condition|)
block|{
comment|/* 		 * we couldn't set the matching register in time. 		 * just set it to some value so that next interrupt happens. 		 * XXX is it possible to compansate lost interrupts? 		 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|oscr
operator|=
name|bus_space_read_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_CR
argument_list|)
expr_stmt|;
name|nextmatch
operator|=
name|oscr
operator|+
literal|10
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|saost_sc
operator|->
name|sc_clock_count
operator|=
name|nextmatch
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_MR0
argument_list|,
name|nextmatch
argument_list|)
expr_stmt|;
name|hardclock
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_unlock_spin(&clock_lock);
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void statintr(arg) 	void *arg; { 	struct clockframe *frame = arg; 	u_int32_t oscr, nextmatch, oldmatch; 	int s;  	bus_space_write_4(saost_sc->sc_iot, saost_sc->sc_ioh, 			SAOST_SR, 2);
comment|/* schedule next clock intr */
end_comment

begin_comment
unit|oldmatch = saost_sc->sc_statclock_count; 	nextmatch = oldmatch + saost_sc->sc_statclock_step;  	bus_space_write_4(saost_sc->sc_iot, saost_sc->sc_ioh, SAOST_MR1, 			  nextmatch); 	oscr = bus_space_read_4(saost_sc->sc_iot, saost_sc->sc_ioh, 				SAOST_CR);  	if ((nextmatch> oldmatch&& 	     (oscr> nextmatch || oscr< oldmatch)) || 	    (nextmatch< oldmatch&& oscr> nextmatch&& oscr< oldmatch)) {
comment|/* 		 * we couldn't set the matching register in time. 		 * just set it to some value so that next interrupt happens. 		 * XXX is it possible to compansate lost interrupts? 		 */
end_comment

begin_endif
unit|s = splhigh(); 		oscr = bus_space_read_4(saost_sc->sc_iot, saost_sc->sc_ioh, 					SAOST_CR); 		nextmatch = oscr + 10; 		bus_space_write_4(saost_sc->sc_iot, saost_sc->sc_ioh, 				  SAOST_MR1, nextmatch); 		splx(s); 	}  	saost_sc->sc_statclock_count = nextmatch; 	statclock(frame);  }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void setstatclockrate(int hz) { 	u_int32_t count;  	saost_sc->sc_statclock_step = TIMER_FREQUENCY / hz; 	count = bus_space_read_4(saost_sc->sc_iot, saost_sc->sc_ioh, SAOST_CR); 	count += saost_sc->sc_statclock_step; 	saost_sc->sc_statclock_count = count; 	bus_space_write_4(saost_sc->sc_iot, saost_sc->sc_ioh, 			SAOST_MR1, count); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|cpu_initclocks
parameter_list|()
block|{
name|device_t
name|dev
init|=
name|saost_sc
operator|->
name|sc_dev
decl_stmt|;
name|stathz
operator|=
name|STATHZ
expr_stmt|;
name|profhz
operator|=
name|stathz
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_init(&clock_lock, "SA1110 Clock locké", NULL, MTX_SPIN);
endif|#
directive|endif
name|saost_sc
operator|->
name|sc_statclock_step
operator|=
name|TIMER_FREQUENCY
operator|/
name|stathz
expr_stmt|;
name|struct
name|resource
modifier|*
name|irq1
decl_stmt|,
modifier|*
name|irq2
decl_stmt|;
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ih1
comment|/*, *ih2 */
decl_stmt|;
name|printf
argument_list|(
literal|"clock: hz=%d stathz = %d\n"
argument_list|,
name|hz
argument_list|,
name|stathz
argument_list|)
expr_stmt|;
comment|/* Use the channels 0 and 1 for hardclock and statclock, respectively */
name|saost_sc
operator|->
name|sc_clock_count
operator|=
name|TIMER_FREQUENCY
operator|/
name|hz
expr_stmt|;
name|saost_sc
operator|->
name|sc_statclock_count
operator|=
name|TIMER_FREQUENCY
operator|/
name|stathz
expr_stmt|;
name|irq1
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
name|irq2
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq1
argument_list|,
name|INTR_TYPE_CLK
operator||
name|INTR_FAST
argument_list|,
name|clockintr
argument_list|,
name|NULL
argument_list|,
operator|&
name|ih1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_setup_intr(dev, irq2, INTR_TYPE_CLK | INTR_FAST, statintr, NULL 	    ,&ih2);
endif|#
directive|endif
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_SR
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_IR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_MR0
argument_list|,
name|saost_sc
operator|->
name|sc_clock_count
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_space_write_4(saost_sc->sc_iot, saost_sc->sc_ioh, SAOST_MR1, 			  0);
endif|#
directive|endif
comment|/* Zero the counter value */
name|bus_space_write_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gettick
parameter_list|()
block|{
name|int
name|counter
decl_stmt|;
name|u_int
name|savedints
decl_stmt|;
name|savedints
operator|=
name|disable_interrupts
argument_list|(
name|I32_bit
argument_list|)
expr_stmt|;
name|counter
operator|=
name|bus_space_read_4
argument_list|(
name|saost_sc
operator|->
name|sc_iot
argument_list|,
name|saost_sc
operator|->
name|sc_ioh
argument_list|,
name|SAOST_CR
argument_list|)
expr_stmt|;
name|restore_interrupts
argument_list|(
name|savedints
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
end_function

begin_function
name|void
name|DELAY
parameter_list|(
name|usecs
parameter_list|)
name|int
name|usecs
decl_stmt|;
block|{
name|u_int32_t
name|tick
decl_stmt|,
name|otick
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|j
decl_stmt|,
name|csec
decl_stmt|,
name|usec
decl_stmt|;
name|csec
operator|=
name|usecs
operator|/
literal|10000
expr_stmt|;
name|usec
operator|=
name|usecs
operator|%
literal|10000
expr_stmt|;
name|usecs
operator|=
operator|(
name|TIMER_FREQUENCY
operator|/
literal|100
operator|)
operator|*
name|csec
operator|+
operator|(
name|TIMER_FREQUENCY
operator|/
literal|100
operator|)
operator|*
name|usec
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
operator|!
name|saost_sc
condition|)
block|{
comment|/* clock isn't initialized yet */
for|for
control|(
init|;
name|usecs
operator|>
literal|0
condition|;
name|usecs
operator|--
control|)
for|for
control|(
name|j
operator|=
literal|100
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
empty_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|mtx_lock_spin(&clock_lock);
endif|#
directive|endif
name|otick
operator|=
name|gettick
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|100
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
empty_stmt|;
name|tick
operator|=
name|gettick
argument_list|()
expr_stmt|;
name|delta
operator|=
name|tick
operator|-
name|otick
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|usecs
condition|)
block|{
break|break;
block|}
name|usecs
operator|-=
name|delta
expr_stmt|;
name|otick
operator|=
name|tick
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|mtx_unlock_spin(&clock_lock);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cpu_startprofclock
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"STARTPROFCLOCK\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpu_stopprofclock
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

