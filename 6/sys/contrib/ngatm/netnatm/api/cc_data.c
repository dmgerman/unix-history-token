begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* * Copyright (c) 2004 *	Hartmut Brandt *	All rights reserved. * * Author: Harti Brandt<harti@freebsd.org> * * Redistribution of this software and documentation and use in source and * binary forms, with or without modification, are permitted provided that * the following conditions are met: * * 1. Redistributions of source code or documentation must retain the above *    copyright notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE AUTHOR * AND ITS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL * THE AUTHOR OR ITS CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * $Begemot: libunimsg/netnatm/api/cc_data.c,v 1.1 2004/07/08 08:21:50 brandt Exp $ * * ATM API as defined per af-saa-0108 */
end_comment

begin_include
include|#
directive|include
file|<netnatm/unimsg.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unistruct.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unimsglib.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/unisap.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unidef.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/atmapi.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccatm.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccpriv.h>
end_include

begin_comment
comment|/*  * Create a new call control instance  */
end_comment

begin_function
name|struct
name|ccdata
modifier|*
name|cc_create
parameter_list|(
specifier|const
name|struct
name|cc_funcs
modifier|*
name|vtab
parameter_list|)
block|{
name|struct
name|ccdata
modifier|*
name|cc
decl_stmt|;
name|cc
operator|=
name|CCMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|cc
operator|->
name|user_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cc
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|cc
operator|->
name|orphaned_conns
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cc
operator|->
name|def_sigs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|)
expr_stmt|;
name|cc
operator|->
name|funcs
operator|=
name|vtab
expr_stmt|;
name|cc
operator|->
name|cookie
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset everything the hard way by just freeing the data  */
end_comment

begin_function
name|void
name|cc_reset
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|)
block|{
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|cc
operator|->
name|user_list
argument_list|)
condition|)
name|cc_user_destroy
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|user_list
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cc
operator|->
name|port_list
argument_list|)
condition|)
name|cc_port_destroy
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|port_list
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|cc
operator|->
name|orphaned_conns
argument_list|)
condition|)
name|cc_conn_destroy
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|orphaned_conns
argument_list|)
argument_list|)
expr_stmt|;
name|CCASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|cc
operator|->
name|user_list
argument_list|)
argument_list|,
operator|(
literal|"user list not empty"
operator|)
argument_list|)
expr_stmt|;
name|CCASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|cc
operator|->
name|orphaned_conns
argument_list|)
argument_list|,
operator|(
literal|"still orphaned conns"
operator|)
argument_list|)
expr_stmt|;
name|cc_sig_flush_all
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy a call control instance and free all data  */
end_comment

begin_function
name|void
name|cc_destroy
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|)
block|{
name|cc_reset
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set/get logging flags  */
end_comment

begin_function
name|void
name|cc_set_log
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|cc
operator|->
name|log
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|cc_get_log
parameter_list|(
specifier|const
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|)
block|{
return|return
operator|(
name|cc
operator|->
name|log
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get extended status */
end_comment

begin_function
name|int
name|cc_get_extended_status
parameter_list|(
specifier|const
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|struct
name|atm_exstatus
modifier|*
name|status
parameter_list|,
name|struct
name|atm_exstatus_ep
modifier|*
modifier|*
name|pep
parameter_list|,
name|struct
name|atm_exstatus_port
modifier|*
modifier|*
name|pport
parameter_list|,
name|struct
name|atm_exstatus_conn
modifier|*
modifier|*
name|pconn
parameter_list|,
name|struct
name|atm_exstatus_party
modifier|*
modifier|*
name|pparty
parameter_list|)
block|{
specifier|const
name|struct
name|ccuser
modifier|*
name|user
decl_stmt|;
specifier|const
name|struct
name|ccport
modifier|*
name|port
decl_stmt|;
specifier|const
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
specifier|const
name|struct
name|ccparty
modifier|*
name|party
decl_stmt|;
name|struct
name|atm_exstatus_ep
modifier|*
name|eep
decl_stmt|;
name|struct
name|atm_exstatus_port
modifier|*
name|eport
decl_stmt|;
name|struct
name|atm_exstatus_conn
modifier|*
name|econn
decl_stmt|;
name|struct
name|atm_exstatus_party
modifier|*
name|eparty
decl_stmt|;
comment|/* count and allocate */
name|status
operator|->
name|neps
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|user
argument_list|,
argument|&cc->user_list
argument_list|,
argument|node_link
argument_list|)
name|status
operator|->
name|neps
operator|++
expr_stmt|;
name|status
operator|->
name|nports
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|nconns
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|nparties
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&cc->orphaned_conns
argument_list|,
argument|port_link
argument_list|)
block|{
name|status
operator|->
name|nconns
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|party
argument_list|,
argument|&conn->parties
argument_list|,
argument|link
argument_list|)
name|status
operator|->
name|nparties
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&cc->port_list
argument_list|,
argument|node_link
argument_list|)
block|{
name|status
operator|->
name|nports
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&port->conn_list
argument_list|,
argument|port_link
argument_list|)
block|{
name|status
operator|->
name|nconns
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|party
argument_list|,
argument|&conn->parties
argument_list|,
argument|link
argument_list|)
name|status
operator|->
name|nparties
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|pep
operator|=
name|CCMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pep
argument_list|)
operator|*
name|status
operator|->
name|neps
argument_list|)
expr_stmt|;
operator|*
name|pport
operator|=
name|CCMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pport
argument_list|)
operator|*
name|status
operator|->
name|nports
argument_list|)
expr_stmt|;
operator|*
name|pconn
operator|=
name|CCMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pconn
argument_list|)
operator|*
name|status
operator|->
name|nconns
argument_list|)
expr_stmt|;
operator|*
name|pparty
operator|=
name|CCMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pparty
argument_list|)
operator|*
name|status
operator|->
name|nparties
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pep
operator|==
name|NULL
operator|||
operator|*
name|pport
operator|==
name|NULL
operator|||
operator|*
name|pconn
operator|==
name|NULL
operator|||
operator|*
name|pparty
operator|==
name|NULL
condition|)
block|{
name|CCFREE
argument_list|(
operator|*
name|pep
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
operator|*
name|pport
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
operator|*
name|pconn
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
operator|*
name|pparty
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|eep
operator|=
operator|*
name|pep
expr_stmt|;
name|eport
operator|=
operator|*
name|pport
expr_stmt|;
name|econn
operator|=
operator|*
name|pconn
expr_stmt|;
name|eparty
operator|=
operator|*
name|pparty
expr_stmt|;
comment|/* collect information */
name|LIST_FOREACH
argument_list|(
argument|user
argument_list|,
argument|&cc->user_list
argument_list|,
argument|node_link
argument_list|)
block|{
name|strcpy
argument_list|(
name|eep
operator|->
name|name
argument_list|,
name|user
operator|->
name|name
argument_list|)
expr_stmt|;
name|eep
operator|->
name|state
operator|=
name|user
operator|->
name|state
expr_stmt|;
name|eep
operator|++
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&cc->orphaned_conns
argument_list|,
argument|port_link
argument_list|)
block|{
name|econn
operator|->
name|id
operator|=
name|econn
operator|-
operator|*
name|pconn
expr_stmt|;
name|econn
operator|->
name|port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|user
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|econn
operator|->
name|ep
argument_list|,
name|conn
operator|->
name|user
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|econn
operator|->
name|ep
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|econn
operator|->
name|state
operator|=
name|conn
operator|->
name|state
expr_stmt|;
name|econn
operator|->
name|cref
operator|=
name|conn
operator|->
name|cref
operator|.
name|cref
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|cref
operator|.
name|flag
condition|)
name|econn
operator|->
name|cref
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|party
argument_list|,
argument|&conn->parties
argument_list|,
argument|link
argument_list|)
block|{
name|eparty
operator|->
name|connid
operator|=
name|econn
operator|-
operator|*
name|pconn
expr_stmt|;
name|eparty
operator|->
name|epref
operator|=
name|party
operator|->
name|epref
operator|.
name|epref
expr_stmt|;
name|eparty
operator|->
name|state
operator|=
name|party
operator|->
name|state
expr_stmt|;
name|eparty
operator|++
expr_stmt|;
block|}
name|econn
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&cc->port_list
argument_list|,
argument|node_link
argument_list|)
block|{
name|eport
operator|->
name|portno
operator|=
name|port
operator|->
name|param
operator|.
name|port
expr_stmt|;
name|eport
operator|->
name|state
operator|=
name|port
operator|->
name|admin
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&port->conn_list
argument_list|,
argument|port_link
argument_list|)
block|{
name|econn
operator|->
name|id
operator|=
name|econn
operator|-
operator|*
name|pconn
expr_stmt|;
name|econn
operator|->
name|port
operator|=
name|port
operator|->
name|param
operator|.
name|port
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|user
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|econn
operator|->
name|ep
argument_list|,
name|conn
operator|->
name|user
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|econn
operator|->
name|ep
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|econn
operator|->
name|state
operator|=
name|conn
operator|->
name|state
expr_stmt|;
name|econn
operator|->
name|cref
operator|=
name|conn
operator|->
name|cref
operator|.
name|cref
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|cref
operator|.
name|flag
condition|)
name|econn
operator|->
name|cref
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|party
argument_list|,
argument|&conn->parties
argument_list|,
argument|link
argument_list|)
block|{
name|eparty
operator|->
name|connid
operator|=
name|econn
operator|-
operator|*
name|pconn
expr_stmt|;
name|eparty
operator|->
name|epref
operator|=
name|party
operator|->
name|epref
operator|.
name|epref
expr_stmt|;
name|eparty
operator|->
name|state
operator|=
name|party
operator|->
name|state
expr_stmt|;
name|eparty
operator|++
expr_stmt|;
block|}
name|econn
operator|++
expr_stmt|;
block|}
name|eport
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

