begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2003 Hewlett-Packard Development Company, L.P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_include
include|#
directive|include
file|"uwx_uinfo.h"
end_include

begin_include
include|#
directive|include
file|"uwx_utable.h"
end_include

begin_include
include|#
directive|include
file|"uwx_scoreboard.h"
end_include

begin_include
include|#
directive|include
file|"uwx_bstream.h"
end_include

begin_include
include|#
directive|include
file|"uwx_trace.h"
end_include

begin_include
include|#
directive|include
file|"uwx_swap.h"
end_include

begin_function_decl
name|int
name|uwx_count_ones
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  uwx_uinfo.c  *  *  This file contains the routines for reading and decoding  *  the unwind information block.   *  *  The main entry point, uwx_decode_uinfo(), is given a pointer  *  to an unwind table entry and a pointer (passed by reference)  *  to be filled in with a pointer to an update vector. It will  *  read and decode the unwind descriptors contained in the  *  unwind information block, then build the register state array,  *  which describes the actions necessary to step from the current  *  frame to the previous one.  */
end_comment

begin_define
define|#
directive|define
name|COPYIN_UINFO_4
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						WORDSZ, env->cb_token) : \ 	(*(uint32_t *)(dest) = *(uint32_t *)(src), WORDSZ) )
end_define

begin_define
define|#
directive|define
name|COPYIN_UINFO_8
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						DWORDSZ, env->cb_token) : \ 	(*(uint64_t *)(dest) = *(uint64_t *)(src), DWORDSZ) )
end_define

begin_comment
comment|/* uwx_default_rstate: Returns the default register state for a leaf routine */
end_comment

begin_function
name|int
name|uwx_default_rstate
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstatep
parameter_list|)
block|{
name|struct
name|uwx_scoreboard
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|uwx_init_scoreboards
argument_list|(
name|env
argument_list|)
expr_stmt|;
operator|*
name|rstatep
operator|=
name|sb
operator|->
name|rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_uinfo: Decodes unwind info region */
end_comment

begin_function
name|int
name|uwx_decode_uinfo
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstatep
parameter_list|)
block|{
name|uint64_t
name|uinfohdr
decl_stmt|;
name|unsigned
name|int
name|ulen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|uwx_bstream
name|bstream
decl_stmt|;
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
decl_stmt|;
name|int
name|ip_slot
decl_stmt|;
name|int
name|cur_slot
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|uwx_rhdr
name|rhdr
decl_stmt|;
comment|/* Remember the offset from the start of the function */
comment|/* to the current IP. This helps the client find */
comment|/* the symbolic information. */
name|env
operator|->
name|function_offset
operator|=
name|env
operator|->
name|remapped_ip
operator|-
name|uentry
operator|->
name|code_start
expr_stmt|;
comment|/* Read the unwind info header using the copyin callback. */
comment|/* (If we're reading a 32-bit unwind table, we need to */
comment|/* read the header as two 32-bit pieces to preserve the */
comment|/* guarantee that we always call copyin for aligned */
comment|/* 4-byte or 8-byte chunks.) */
comment|/* Then compute the length of the unwind descriptor */
comment|/* region and initialize a byte stream to read it. */
if|if
condition|(
name|uentry
operator|->
name|unwind_flags
operator|&
name|UNWIND_TBL_32BIT
condition|)
block|{
name|len
operator|=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
argument_list|,
name|uentry
operator|->
name|unwind_info
argument_list|)
expr_stmt|;
name|len
operator|+=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
operator|+
name|WORDSZ
argument_list|,
name|uentry
operator|->
name|unwind_info
operator|+
name|WORDSZ
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
name|COPYIN_UINFO_8
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
argument_list|,
name|uentry
operator|->
name|unwind_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|DWORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UINFO
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
name|uwx_swap8
argument_list|(
operator|&
name|uinfohdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|uentry
operator|->
name|unwind_flags
operator|&
name|UNWIND_TBL_32BIT
condition|)
name|ulen
operator|=
name|UNW_LENGTH
argument_list|(
name|uinfohdr
argument_list|)
operator|*
name|WORDSZ
expr_stmt|;
else|else
name|ulen
operator|=
name|UNW_LENGTH
argument_list|(
name|uinfohdr
argument_list|)
operator|*
name|DWORDSZ
expr_stmt|;
name|uwx_init_bstream
argument_list|(
operator|&
name|bstream
argument_list|,
name|env
argument_list|,
name|uentry
operator|->
name|unwind_info
operator|+
name|DWORDSZ
argument_list|,
name|ulen
argument_list|,
name|UWX_COPYIN_UINFO
argument_list|)
expr_stmt|;
name|TRACE_R_UIB
argument_list|(
argument|uentry
argument_list|,
argument|ulen
argument_list|)
comment|/* Create an initial scoreboard for tracking the unwind state. */
name|scoreboard
operator|=
name|uwx_init_scoreboards
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* Prepare to read and decode the unwind regions described */
comment|/* by the unwind info block. Find the target "ip" slot */
comment|/* relative to the beginning of the region. The lower 4 bits */
comment|/* of the actual IP encode the slot number within a bundle. */
name|cur_slot
operator|=
literal|0
expr_stmt|;
name|ip_slot
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|&
operator|~
literal|0x0fLL
operator|)
operator|-
name|uentry
operator|->
name|code_start
argument_list|)
operator|/
name|BUNDLESZ
operator|*
name|SLOTSPERBUNDLE
operator|+
call|(
name|unsigned
name|int
call|)
argument_list|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Loop over the regions in the unwind info block. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Decode the next region header. */
comment|/* We have an error if we reach the end of the info block, */
comment|/* since we should have found our target ip slot by then. */
comment|/* We also have an error if the next byte isn't a region */
comment|/* header record. */
name|status
operator|=
name|uwx_decode_rhdr
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
operator|&
name|rhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
comment|/* If a prologue region, get a new scoreboard, pushing */
comment|/* the previous one onto the prologue stack. Then read */
comment|/* and decode the prologue region records. */
if|if
condition|(
name|rhdr
operator|.
name|is_prologue
condition|)
block|{
name|scoreboard
operator|=
name|uwx_new_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|scoreboard
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|status
operator|=
name|uwx_decode_prologue
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
name|scoreboard
argument_list|,
operator|&
name|rhdr
argument_list|,
name|ip_slot
argument_list|)
expr_stmt|;
block|}
comment|/* If a body region, read and decode the body region */
comment|/* records. If the body has an epilogue count, */
comment|/* uwx_decode_body will note that in the region header */
comment|/* record for use at the bottom of the loop. */
else|else
block|{
name|status
operator|=
name|uwx_decode_body
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
name|scoreboard
argument_list|,
operator|&
name|rhdr
argument_list|,
name|ip_slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|TRACE_R_DUMP_SB
argument_list|(
argument|scoreboard
argument_list|,
argument|rhdr
argument_list|,
argument|cur_slot
argument_list|,
argument|ip_slot
argument_list|)
comment|/* If the target ip slot is within this region, we're done. */
comment|/* Return the scoreboard's register state array. */
if|if
condition|(
name|ip_slot
operator|<
name|rhdr
operator|.
name|rlen
condition|)
block|{
operator|*
name|rstatep
operator|=
name|scoreboard
operator|->
name|rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
comment|/* Otherwise, update the current ip slot, pop the */
comment|/* scoreboard stack based on the epilogue count, */
comment|/* and loop back around for the next region. */
name|cur_slot
operator|+=
name|rhdr
operator|.
name|rlen
expr_stmt|;
name|ip_slot
operator|-=
name|rhdr
operator|.
name|rlen
expr_stmt|;
if|if
condition|(
name|rhdr
operator|.
name|ecount
operator|>
literal|0
condition|)
block|{
name|scoreboard
operator|=
name|uwx_pop_scoreboards
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|rhdr
operator|.
name|ecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|scoreboard
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_PROLOG_UF
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* uwx_decode_rhdr: Decodes a region header record */
end_comment

begin_function
name|int
name|uwx_decode_rhdr
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|)
block|{
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Get the first byte of the next descriptor record. */
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_NOUDESC
return|;
comment|/* Initialize region header record. */
name|rhdr
operator|->
name|is_prologue
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|grsave
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|ecount
operator|=
literal|0
expr_stmt|;
comment|/* Format R1 */
if|if
condition|(
name|b0
operator|<
literal|0x40
condition|)
block|{
if|if
condition|(
operator|(
name|b0
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(R1) prologue"
argument_list|,
argument|b0
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(R1) body"
argument_list|,
argument|b0
argument_list|)
block|}
name|rhdr
operator|->
name|rlen
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
block|}
comment|/* Format R2 */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0x60
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_RHDR_2L
argument_list|(
literal|"(R2) prologue_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|val
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
name|rhdr
operator|->
name|rlen
operator|=
operator|(
name|unsigned
name|int
operator|)
name|val
expr_stmt|;
name|rhdr
operator|->
name|mask
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x07
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|rhdr
operator|->
name|grsave
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
block|}
comment|/* Format R3 */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
if|if
condition|(
operator|(
name|b0
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|TRACE_I_DECODE_RHDR_1L
argument_list|(
literal|"(R3) prologue"
argument_list|,
argument|b0
argument_list|,
argument|val
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TRACE_I_DECODE_RHDR_1L
argument_list|(
literal|"(R3) body"
argument_list|,
argument|b0
argument_list|,
argument|val
argument_list|)
block|}
name|rhdr
operator|->
name|rlen
operator|=
operator|(
name|unsigned
name|int
operator|)
name|val
expr_stmt|;
block|}
comment|/* Otherwise, not a region header record. */
else|else
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_prologue: Decodes a prologue region */
end_comment

begin_function
name|int
name|uwx_decode_prologue
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|,
name|int
name|ip_slot
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|int
name|b2
decl_stmt|;
name|int
name|b3
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|parm1
decl_stmt|;
name|uint64_t
name|parm2
decl_stmt|;
name|uint64_t
name|newrstate
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|tspill
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|priunat_mem_rstate
decl_stmt|;
name|int
name|t_priunat_mem
decl_stmt|;
name|unsigned
name|int
name|gr_mem_mask
decl_stmt|;
name|unsigned
name|int
name|br_mem_mask
decl_stmt|;
name|unsigned
name|int
name|fr_mem_mask
decl_stmt|;
name|unsigned
name|int
name|gr_gr_mask
decl_stmt|;
name|unsigned
name|int
name|br_gr_mask
decl_stmt|;
name|int
name|ngr
decl_stmt|;
name|int
name|nbr
decl_stmt|;
name|int
name|nfr
decl_stmt|;
name|unsigned
name|int
name|spill_base
decl_stmt|;
name|unsigned
name|int
name|gr_base
decl_stmt|;
name|unsigned
name|int
name|br_base
decl_stmt|;
name|unsigned
name|int
name|fr_base
decl_stmt|;
comment|/* Initialize an array of register states from the current */
comment|/* scoreboard, along with a parallel array of spill times. */
comment|/* We use this as a temporary scoreboard, then update the */
comment|/* real scoreboard at the end of the procedure. */
comment|/* We initialize the spill time to (rhdr.rlen - 1) so that */
comment|/* spills without a "when" descriptor will take effect */
comment|/* at the end of the prologue region. */
comment|/* (Boundary condition: all actions in a zero-length prologue */
comment|/* will appear to have happened in the instruction slot */
comment|/* immediately preceding the prologue.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
block|}
name|priunat_mem_rstate
operator|=
name|UWX_DISP_NONE
expr_stmt|;
name|t_priunat_mem
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
name|fr_mem_mask
operator|=
literal|0
expr_stmt|;
name|gr_mem_mask
operator|=
literal|0
expr_stmt|;
name|br_mem_mask
operator|=
literal|0
expr_stmt|;
name|gr_gr_mask
operator|=
literal|0
expr_stmt|;
name|br_gr_mask
operator|=
literal|0
expr_stmt|;
name|nfr
operator|=
literal|0
expr_stmt|;
name|ngr
operator|=
literal|0
expr_stmt|;
name|nbr
operator|=
literal|0
expr_stmt|;
name|spill_base
operator|=
literal|0
expr_stmt|;
comment|/* If prologue_gr header record supplied mask and grsave, */
comment|/* record these in the scoreboard. */
name|reg
operator|=
name|rhdr
operator|->
name|grsave
expr_stmt|;
name|mask
operator|=
name|rhdr
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
literal|0x8
condition|)
block|{
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x4
condition|)
block|{
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x2
condition|)
block|{
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x1
condition|)
block|{
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
comment|/* Read prologue descriptor records until */
comment|/* we hit another region header. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
comment|/* Return the last byte read to the byte stream, since it's */
comment|/* really the first byte of the next region header record. */
if|if
condition|(
name|b0
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|uwx_unget_byte
argument_list|(
name|bstream
argument_list|,
name|b0
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|b0
operator|&
literal|0x70
operator|)
operator|>>
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* 1000 xxxx */
case|case
literal|1
case|:
comment|/* 1001 xxxx */
comment|/* Format P1 (br_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P1) br_mem"
argument_list|,
argument|b0
argument_list|)
name|br_mem_mask
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1010 xxxx */
comment|/* Format P2 (br_gr) */
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P2) br_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|mask
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x0f
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|reg
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
name|br_gr_mask
operator|=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_BR
operator|&&
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x01
condition|)
block|{
name|newrstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* 1011 xxxx */
comment|/* Format P3 */
if|if
condition|(
name|b0
operator|<
literal|0xb8
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|r
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x7
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|reg
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
comment|/* psp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) psp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* rp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* pfs_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) pfs_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* preds_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) preds_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* unat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) unat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* lc_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) lc_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* rp_br */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rp_br"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_BR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* rnat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rnat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* bsp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) bsp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|9
case|:
comment|/* bspstore_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) bspstore_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
comment|/* Don't track BSPSTORE yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|10
case|:
comment|/* fpsr_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) fpsr_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* priunat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) priunat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PRIUNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) ??"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Format P4 (spill_mask) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xb8
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P4) spill_mask"
argument_list|,
argument|b0
argument_list|)
comment|/* The spill_mask descriptor is followed by */
comment|/* an imask field whose length is determined */
comment|/* by the region length: there are two mask */
comment|/* bits per instruction slot in the region. */
comment|/* We decode these bits two at a time, counting */
comment|/* the number of FRs, GRs, and BRs that are */
comment|/* saved up to the slot of interest. Other */
comment|/* descriptors describe which sets of these */
comment|/* registers are spilled, and we put those */
comment|/* two pieces of information together at the */
comment|/* end of the main loop. */
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|rhdr
operator|->
name|rlen
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|t
operator|+
name|i
operator|)
operator|<
name|ip_slot
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|b1
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x00
case|:
break|break;
case|case
literal|0x40
case|:
name|nfr
operator|++
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|ngr
operator|++
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|nbr
operator|++
expr_stmt|;
break|break;
block|}
name|b1
operator|=
name|b1
operator|<<
literal|2
expr_stmt|;
block|}
name|t
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Format P5 (frgr_mem) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xb9
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_4
argument_list|(
literal|"(P5) frgr_mem"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|,
argument|b3
argument_list|)
name|gr_mem_mask
operator|=
name|b1
operator|>>
literal|4
expr_stmt|;
name|fr_mem_mask
operator|=
operator|(
operator|(
name|b1
operator|&
literal|0x0f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|b2
operator|<<
literal|8
operator|)
operator||
name|b3
expr_stmt|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* 1100 xxxx */
comment|/* Format P6 (fr_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P6) fr_mem"
argument_list|,
argument|b0
argument_list|)
name|fr_mem_mask
operator|=
name|b0
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* 1101 xxxx */
comment|/* Format P6 (gr_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P6) gr_mem"
argument_list|,
argument|b0
argument_list|)
name|gr_mem_mask
operator|=
name|b0
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* 1110 xxxx */
comment|/* Format P7 */
name|r
operator|=
name|b0
operator|&
literal|0xf
expr_stmt|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
comment|/* mem_stack_f */
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_1LL
argument_list|(
literal|"(P7) mem_stack_f"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|,
argument|parm2
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPPLUS
argument_list|(
name|parm2
operator|*
literal|16
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_PSP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* mem_stack_v */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) mem_stack_v"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PSP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* spill_base */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) spill_base"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|spill_base
operator|=
literal|4
operator|*
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* psp_sprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) psp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* rp_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) rp_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_RP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* rp_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) rp_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* pfs_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) pfs_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PFS
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* pfs_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) pfs_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* preds_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) preds_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PREDS
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* preds_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) preds_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* lc_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) lc_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_LC
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* lc_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) lc_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* unat_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) unat_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_UNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* unat_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) unat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* fpsr_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) fpsr_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_FPSR
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* fpsr_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) fpsr_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|7
case|:
comment|/* 1111 xxxx */
comment|/* Format P8 */
if|if
condition|(
name|b0
operator|==
literal|0xf0
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
switch|switch
condition|(
name|b1
condition|)
block|{
case|case
literal|1
case|:
comment|/* rp_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* pfs_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) pfs_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* preds_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) preds_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* lc_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) lc_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* unat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) unat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* fpsr_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) fpsr_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* bsp_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|8
case|:
comment|/* bsp_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|9
case|:
comment|/* bsp_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|10
case|:
comment|/* bspstore_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|11
case|:
comment|/* bspstore_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|12
case|:
comment|/* bspstore_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|13
case|:
comment|/* rnat_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_RNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* rnat_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* rnat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* priunat_when_gr */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_when_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PRIUNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|17
case|:
comment|/* priunat_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|priunat_mem_rstate
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
comment|/* priunat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|priunat_mem_rstate
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
comment|/* priunat_when_mem */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_when_mem"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|t_priunat_mem
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
default|default:
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) ??"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Format P9 (gr_gr) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf1
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_3
argument_list|(
literal|"(P9) gr_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
name|mask
operator|=
name|b1
operator|&
literal|0x0f
expr_stmt|;
name|reg
operator|=
name|b2
operator|&
literal|0x7f
expr_stmt|;
name|gr_gr_mask
operator|=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_GR
operator|&&
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x01
condition|)
block|{
name|newrstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
block|}
comment|/* Format X1 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf9
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X1)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X2 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfa
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X2)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X3 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfb
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X3)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X4 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfc
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X4)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format P10 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xff
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_3
argument_list|(
literal|"(P10) abi"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
name|env
operator|->
name|abi_context
operator|=
operator|(
name|b1
operator|<<
literal|8
operator|)
operator||
name|b2
expr_stmt|;
return|return
name|UWX_ABI_FRAME
return|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
break|break;
block|}
block|}
comment|/* Process the masks of spilled GRs, FRs, and BRs to */
comment|/* determine when and where each register was saved. */
name|fr_base
operator|=
name|spill_base
operator|+
literal|16
operator|*
name|uwx_count_ones
argument_list|(
name|fr_mem_mask
argument_list|)
expr_stmt|;
name|br_base
operator|=
name|fr_base
operator|+
literal|8
operator|*
name|uwx_count_ones
argument_list|(
name|br_mem_mask
argument_list|)
expr_stmt|;
name|gr_base
operator|=
name|br_base
operator|+
literal|8
operator|*
name|uwx_count_ones
argument_list|(
name|gr_mem_mask
argument_list|)
expr_stmt|;
name|TRACE_I_DECODE_PROLOGUE_SPILL_BASE
argument_list|(
argument|spill_base
argument_list|)
name|TRACE_I_DECODE_PROLOGUE_MASKS
argument_list|(
argument|gr_mem_mask
argument_list|,
argument|gr_gr_mask
argument_list|)
name|TRACE_I_DECODE_PROLOGUE_NSPILL
argument_list|(
argument|ngr
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ngr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_GR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gr_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|gr_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|gr_base
operator|-=
literal|8
expr_stmt|;
name|ngr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gr_gr_mask
operator|&
literal|1
condition|)
block|{
name|tspill
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ngr
operator|--
expr_stmt|;
block|}
name|gr_gr_mask
operator|=
name|gr_gr_mask
operator|>>
literal|1
expr_stmt|;
name|gr_mem_mask
operator|=
name|gr_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nbr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_BR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|br_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|br_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|br_base
operator|-=
literal|8
expr_stmt|;
name|nbr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|br_gr_mask
operator|&
literal|1
condition|)
block|{
name|tspill
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|nbr
operator|--
expr_stmt|;
block|}
name|br_gr_mask
operator|=
name|br_gr_mask
operator|>>
literal|1
expr_stmt|;
name|br_mem_mask
operator|=
name|br_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nfr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_FR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fr_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_FR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|fr_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_FR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fr_base
operator|-=
literal|16
expr_stmt|;
name|nfr
operator|--
expr_stmt|;
block|}
name|fr_mem_mask
operator|=
name|fr_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Update the scoreboard. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip_slot
operator|>=
name|rhdr
operator|->
name|rlen
operator|||
name|ip_slot
operator|>
name|tspill
index|[
name|i
index|]
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|newrstate
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|priunat_mem_rstate
operator|!=
name|UWX_DISP_NONE
operator|&&
name|ip_slot
operator|>
name|t_priunat_mem
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_PRIUNAT
index|]
operator|=
name|priunat_mem_rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_function
name|int
name|uwx_count_ones
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x55555555
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xaaaaaaaa
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x33333333
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xcccccccc
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x0f0f0f0f
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xf0f0f0f0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x00ff00ff
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xff00ff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|mask
operator|&
literal|0x0000ffff
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_body: Decodes a body region */
end_comment

begin_function
name|int
name|uwx_decode_body
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|,
name|int
name|ip_slot
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|int
name|b2
decl_stmt|;
name|int
name|b3
decl_stmt|;
name|int
name|label
decl_stmt|;
name|int
name|ecount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|parm1
decl_stmt|;
name|uint64_t
name|parm2
decl_stmt|;
name|uint64_t
name|newrstate
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|tspill
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|t_sp_restore
decl_stmt|;
comment|/* Initialize an array of register states from the current */
comment|/* scoreboard, along with a parallel array of spill times. */
comment|/* We use this as a temporary scoreboard, then update the */
comment|/* real scoreboard at the end of the procedure. */
comment|/* We initialize the spill time to (rhdr.rlen - 1) so that */
comment|/* spills without a "when" descriptor will take effect */
comment|/* at the end of the prologue region. */
comment|/* (Boundary condition: all actions in a zero-length prologue */
comment|/* will appear to have happened in the instruction slot */
comment|/* immediately preceding the prologue.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
block|}
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
comment|/* Read body descriptor records until */
comment|/* we hit another region header. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
comment|/* Return the last byte read to the byte stream, since it's */
comment|/* really the first byte of the next region header record. */
if|if
condition|(
name|b0
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|uwx_unget_byte
argument_list|(
name|bstream
argument_list|,
name|b0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Format B1 (label_state) */
if|if
condition|(
name|b0
operator|<
literal|0xa0
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(B1) label_state"
argument_list|,
argument|b0
argument_list|)
name|label
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_label_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Format B1 (copy_state)  */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0xc0
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(B1) copy_state"
argument_list|,
argument|b0
argument_list|)
name|label
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_copy_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
expr_stmt|;
block|}
block|}
comment|/* Format B2 (epilogue) */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0xe0
condition|)
block|{
name|ecount
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B2) epilogue"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|rhdr
operator|->
name|ecount
operator|=
name|ecount
operator|+
literal|1
expr_stmt|;
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
block|}
comment|/* Format B3 (epilogue) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xe0
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1LL
argument_list|(
literal|"(B3) epilogue"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|,
argument|parm2
argument_list|)
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
name|rhdr
operator|->
name|ecount
operator|=
operator|(
name|unsigned
name|int
operator|)
name|parm2
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Format B4 (label_state) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf0
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B4) label_state"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|label
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
name|status
operator|=
name|uwx_label_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Format B4 (copy_state) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf8
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B4) copy_state"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|label
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
name|status
operator|=
name|uwx_copy_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
expr_stmt|;
block|}
block|}
comment|/* Format X1 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf9
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X1)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X2 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfa
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X2)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X3 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfb
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X3)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X4 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfc
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X4)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Update the scoreboard. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip_slot
operator|>
name|tspill
index|[
name|i
index|]
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|newrstate
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If we've passed the point in the epilogue where sp */
comment|/* is restored, update the scoreboard entry for PSP */
comment|/* and reset any entries for registers saved in memory. */
if|if
condition|(
name|ip_slot
operator|>
name|t_sp_restore
condition|)
block|{
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPPLUS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|UWX_GET_DISP_CODE
argument_list|(
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
argument_list|)
operator|==
name|UWX_DISP_SPREL
argument_list|(
literal|0
argument_list|)
operator|||
name|UWX_GET_DISP_CODE
argument_list|(
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
argument_list|)
operator|==
name|UWX_DISP_PSPREL
argument_list|(
literal|0
argument_list|)
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|UWX_DISP_NONE
expr_stmt|;
block|}
block|}
return|return
name|UWX_OK
return|;
block|}
end_function

end_unit

