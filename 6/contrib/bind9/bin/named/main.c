begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: main.c,v 1.119.2.3.2.25 2006/11/10 18:51:06 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/app.h>
end_include

begin_include
include|#
directive|include
file|<isc/commandline.h>
end_include

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/hash.h>
end_include

begin_include
include|#
directive|include
file|<isc/os.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/resource.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isccc/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dst/result.h>
end_include

begin_comment
comment|/*  * Defining NS_MAIN provides storage declarations (rather than extern)  * for variables in named/globals.h.  */
end_comment

begin_define
define|#
directive|define
name|NS_MAIN
value|1
end_define

begin_include
include|#
directive|include
file|<named/builtin.h>
end_include

begin_include
include|#
directive|include
file|<named/control.h>
end_include

begin_include
include|#
directive|include
file|<named/globals.h>
end_include

begin_comment
comment|/* Explicit, though named/log.h includes it. */
end_comment

begin_include
include|#
directive|include
file|<named/interfacemgr.h>
end_include

begin_include
include|#
directive|include
file|<named/log.h>
end_include

begin_include
include|#
directive|include
file|<named/os.h>
end_include

begin_include
include|#
directive|include
file|<named/server.h>
end_include

begin_include
include|#
directive|include
file|<named/lwresd.h>
end_include

begin_include
include|#
directive|include
file|<named/main.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
end_ifdef

begin_include
include|#
directive|include
file|<named/ns_smf_globals.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Include header files for database drivers here.  */
end_comment

begin_comment
comment|/* #include "xxdb.h" */
end_comment

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|want_stats
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|program_name
index|[
name|ISC_DIR_NAMEMAX
index|]
init|=
literal|"named"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|absolute_conffile
index|[
name|ISC_DIR_PATHMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|saved_command_line
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|version
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ns_main_earlywarning
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_lctx
operator|!=
name|NULL
condition|)
block|{
name|isc_log_vwrite
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_main_earlyfatal
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_lctx
operator|!=
name|NULL
condition|)
block|{
name|isc_log_vwrite
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
literal|"exiting (due to early fatal error)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assertion_failed
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|isc_assertiontype_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|cond
parameter_list|)
block|{
comment|/* 	 * Handle assertion failures. 	 */
if|if
condition|(
name|ns_g_lctx
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Reset the assetion callback in case it is the log 		 * routines causing the assertion. 		 */
name|isc_assertion_setcallback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
literal|"%s:%d: %s(%s) failed"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|isc_assertion_typetotext
argument_list|(
name|type
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
literal|"exiting (due to assertion failure)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(%s) failed\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|isc_assertion_typetotext
argument_list|(
name|type
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns_g_coreok
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|library_fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|library_fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Handle isc_error_fatal() calls from our libraries. 	 */
if|if
condition|(
name|ns_g_lctx
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Reset the error callback in case it is the log 		 * routines causing the assertion. 		 */
name|isc_error_setfatal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
literal|"%s:%d: fatal error:"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|isc_log_vwrite
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_CRITICAL
argument_list|,
literal|"exiting (due to fatal error in library)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: fatal error: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns_g_coreok
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|library_unexpected_error
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|library_unexpected_error
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Handle isc_error_unexpected() calls from our libraries. 	 */
if|if
condition|(
name|ns_g_lctx
operator|!=
name|NULL
condition|)
block|{
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s:%d: unexpected error:"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|isc_log_vwrite
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: fatal error: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lwresd_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: lwresd [-4|-6] [-c conffile | -C resolvconffile] "
literal|"[-d debuglevel]\n"
literal|"              [-f|-g] [-n number_of_cpus] [-p port] "
literal|"[-P listen-port] [-s]\n"
literal|"              [-t chrootdir] [-u username] [-i pidfile]\n"
literal|"              [-m {usage|trace|record}]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ns_g_lwresdonly
condition|)
block|{
name|lwresd_usage
argument_list|()
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: named [-4|-6] [-c conffile] [-d debuglevel] "
literal|"[-f|-g] [-n number_of_cpus]\n"
literal|"             [-p port] [-s] [-t chrootdir] [-u username]\n"
literal|"             [-m {usage|trace|record}]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_command_line
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|eob
decl_stmt|;
specifier|const
name|char
name|truncated
index|[]
init|=
literal|"..."
decl_stmt|;
name|isc_boolean_t
name|quoted
init|=
name|ISC_FALSE
decl_stmt|;
name|dst
operator|=
name|saved_command_line
expr_stmt|;
name|eob
operator|=
name|saved_command_line
operator|+
sizeof|sizeof
argument_list|(
name|saved_command_line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
name|dst
operator|<
name|eob
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|' '
expr_stmt|;
name|src
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\0'
operator|&&
name|dst
operator|<
name|eob
condition|)
block|{
comment|/* 			 * This won't perfectly produce a shell-independent 			 * pastable command line in all circumstances, but 			 * comes close, and for practical purposes will 			 * nearly always be fine. 			 */
if|if
condition|(
name|quoted
operator|||
name|isalnum
argument_list|(
operator|*
name|src
operator|&
literal|0xff
argument_list|)
operator|||
operator|*
name|src
operator|==
literal|'-'
operator|||
operator|*
name|src
operator|==
literal|'_'
operator|||
operator|*
name|src
operator|==
literal|'.'
operator|||
operator|*
name|src
operator|==
literal|'/'
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|quoted
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|quoted
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|saved_command_line
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|truncated
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|eob
condition|)
name|strcpy
argument_list|(
name|eob
operator|-
sizeof|sizeof
argument_list|(
name|truncated
argument_list|)
argument_list|,
name|truncated
argument_list|)
expr_stmt|;
else|else
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_int
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|long
name|int
name|ltmp
decl_stmt|;
name|ltmp
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|int
operator|)
name|ltmp
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"%s '%s' must be numeric"
argument_list|,
name|desc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
operator|||
name|tmp
operator|!=
name|ltmp
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"%s '%s' out of range"
argument_list|,
name|desc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|flag_def
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|}
name|mem_debug_flags
index|[]
init|=
block|{
block|{
literal|"trace"
block|,
name|ISC_MEM_DEBUGTRACE
block|}
block|,
block|{
literal|"record"
block|,
name|ISC_MEM_DEBUGRECORD
block|}
block|,
block|{
literal|"usage"
block|,
name|ISC_MEM_DEBUGUSAGE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|set_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|flag_def
modifier|*
name|defs
parameter_list|,
name|unsigned
name|int
modifier|*
name|ret
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|struct
name|flag_def
modifier|*
name|def
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|','
argument_list|)
decl_stmt|;
name|int
name|arglen
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
name|end
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arglen
operator|=
name|end
operator|-
name|arg
expr_stmt|;
for|for
control|(
name|def
operator|=
name|defs
init|;
name|def
operator|->
name|name
operator|!=
name|NULL
condition|;
name|def
operator|++
control|)
block|{
if|if
condition|(
name|arglen
operator|==
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|def
operator|->
name|name
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|arg
argument_list|,
name|def
operator|->
name|name
argument_list|,
name|arglen
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ret
operator||=
name|def
operator|->
name|value
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|ns_main_earlyfatal
argument_list|(
literal|"unrecognized flag '%.*s'"
argument_list|,
name|arglen
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|found
label|:
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
break|break;
name|arg
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_command_line
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|port
decl_stmt|;
name|isc_boolean_t
name|disable6
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|disable4
init|=
name|ISC_FALSE
decl_stmt|;
name|save_command_line
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|isc_commandline_errprint
operator|=
name|ISC_FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|isc_commandline_parse
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46c:C:d:fgi:lm:n:N:p:P:st:u:vx:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'4'
case|:
if|if
condition|(
name|disable4
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"cannot specify -4 and -6"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_net_probeipv4
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"IPv4 not supported by OS"
argument_list|)
expr_stmt|;
name|isc_net_disableipv6
argument_list|()
expr_stmt|;
name|disable6
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
name|disable6
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"cannot specify -4 and -6"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"IPv6 not supported by OS"
argument_list|)
expr_stmt|;
name|isc_net_disableipv4
argument_list|()
expr_stmt|;
name|disable4
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ns_g_conffile
operator|=
name|isc_commandline_argument
expr_stmt|;
name|lwresd_g_conffile
operator|=
name|isc_commandline_argument
expr_stmt|;
if|if
condition|(
name|lwresd_g_useresolvconf
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"cannot specify -c and -C"
argument_list|)
expr_stmt|;
name|ns_g_conffileset
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|lwresd_g_resolvconffile
operator|=
name|isc_commandline_argument
expr_stmt|;
if|if
condition|(
name|ns_g_conffileset
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"cannot specify -c and -C"
argument_list|)
expr_stmt|;
name|lwresd_g_useresolvconf
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ns_g_debuglevel
operator|=
name|parse_int
argument_list|(
name|isc_commandline_argument
argument_list|,
literal|"debug level"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ns_g_foreground
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|ns_g_foreground
operator|=
name|ISC_TRUE
expr_stmt|;
name|ns_g_logstderr
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
comment|/* XXXBEW -i should be removed */
case|case
literal|'i'
case|:
name|lwresd_g_defaultpidfile
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ns_g_lwresdonly
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|set_flags
argument_list|(
name|isc_commandline_argument
argument_list|,
name|mem_debug_flags
argument_list|,
operator|&
name|isc_mem_debugging
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Deprecated. */
case|case
literal|'n'
case|:
name|ns_g_cpus
operator|=
name|parse_int
argument_list|(
name|isc_commandline_argument
argument_list|,
literal|"number of cpus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_cpus
operator|==
literal|0
condition|)
name|ns_g_cpus
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|parse_int
argument_list|(
name|isc_commandline_argument
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
literal|65535
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"port '%s' out of range"
argument_list|,
name|isc_commandline_argument
argument_list|)
expr_stmt|;
name|ns_g_port
operator|=
name|port
expr_stmt|;
break|break;
comment|/* XXXBEW Should -P be removed? */
case|case
literal|'P'
case|:
name|port
operator|=
name|parse_int
argument_list|(
name|isc_commandline_argument
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
operator|||
name|port
operator|>
literal|65535
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"port '%s' out of range"
argument_list|,
name|isc_commandline_argument
argument_list|)
expr_stmt|;
name|lwresd_g_listenport
operator|=
name|port
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* XXXRTH temporary syntax */
name|want_stats
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* XXXJAB should we make a copy? */
name|ns_g_chrootdir
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ns_g_username
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"BIND %s\n"
argument_list|,
name|ns_g_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"unknown option '-%c'"
argument_list|,
name|isc_commandline_option
argument_list|)
expr_stmt|;
default|default:
name|ns_main_earlyfatal
argument_list|(
literal|"parsing options returned %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|isc_commandline_index
expr_stmt|;
name|argv
operator|+=
name|isc_commandline_index
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"extra command line arguments"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|create_managers
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|unsigned
name|int
name|cpus_detected
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|cpus_detected
operator|=
name|isc_os_ncpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|ns_g_cpus
operator|==
literal|0
condition|)
name|ns_g_cpus
operator|=
name|cpus_detected
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_SERVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"found %u CPU%s, using %u worker thread%s"
argument_list|,
name|cpus_detected
argument_list|,
name|cpus_detected
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|ns_g_cpus
argument_list|,
name|ns_g_cpus
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ns_g_cpus
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|isc_taskmgr_create
argument_list|(
name|ns_g_mctx
argument_list|,
name|ns_g_cpus
argument_list|,
literal|0
argument_list|,
operator|&
name|ns_g_taskmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_taskmgr_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_timermgr_create
argument_list|(
name|ns_g_mctx
argument_list|,
operator|&
name|ns_g_timermgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timermgr_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_socketmgr_create
argument_list|(
name|ns_g_mctx
argument_list|,
operator|&
name|ns_g_socketmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_socketmgr_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_entropy_create
argument_list|(
name|ns_g_mctx
argument_list|,
operator|&
name|ns_g_entropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_entropy_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_hash_create
argument_list|(
name|ns_g_mctx
argument_list|,
name|ns_g_entropy
argument_list|,
name|DNS_NAME_MAXWIRE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_hash_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_managers
parameter_list|(
name|void
parameter_list|)
block|{
name|ns_lwresd_shutdown
argument_list|()
expr_stmt|;
name|isc_entropy_detach
argument_list|(
operator|&
name|ns_g_entropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_fallbackentropy
operator|!=
name|NULL
condition|)
name|isc_entropy_detach
argument_list|(
operator|&
name|ns_g_fallbackentropy
argument_list|)
expr_stmt|;
comment|/* 	 * isc_taskmgr_destroy() will block until all tasks have exited, 	 */
name|isc_taskmgr_destroy
argument_list|(
operator|&
name|ns_g_taskmgr
argument_list|)
expr_stmt|;
name|isc_timermgr_destroy
argument_list|(
operator|&
name|ns_g_timermgr
argument_list|)
expr_stmt|;
name|isc_socketmgr_destroy
argument_list|(
operator|&
name|ns_g_socketmgr
argument_list|)
expr_stmt|;
comment|/* 	 * isc_hash_destroy() cannot be called as long as a resolver may be 	 * running.  Calling this after isc_taskmgr_destroy() ensures the 	 * call is safe. 	 */
name|isc_hash_destroy
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
name|char
modifier|*
name|instance
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Get the user and group information before changing the root 	 * directory, so the administrator does not need to keep a copy 	 * of the user and group databases in the chroot'ed environment. 	 */
name|ns_os_inituserinfo
argument_list|(
name|ns_g_username
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize time conversion information 	 */
name|ns_os_tzset
argument_list|()
expr_stmt|;
name|ns_os_opendevnull
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
comment|/* Check if named is under smf control, before chroot. */
name|result
operator|=
name|ns_smf_get_instance
argument_list|(
operator|&
name|instance
argument_list|,
literal|0
argument_list|,
name|ns_g_mctx
argument_list|)
expr_stmt|;
comment|/* We don't care about instance, just check if we got one. */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|ns_smf_got_instance
operator|=
literal|1
expr_stmt|;
else|else
name|ns_smf_got_instance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|ns_g_mctx
argument_list|,
name|instance
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_LIBSCF */
ifdef|#
directive|ifdef
name|PATH_RANDOMDEV
comment|/* 	 * Initialize system's random device as fallback entropy source 	 * if running chroot'ed. 	 */
if|if
condition|(
name|ns_g_chrootdir
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_entropy_create
argument_list|(
name|ns_g_mctx
argument_list|,
operator|&
name|ns_g_fallbackentropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"isc_entropy_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_entropy_createfilesource
argument_list|(
name|ns_g_fallbackentropy
argument_list|,
name|PATH_RANDOMDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_main_earlywarning
argument_list|(
literal|"could not open pre-chroot "
literal|"entropy source %s: %s"
argument_list|,
name|PATH_RANDOMDEV
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_entropy_detach
argument_list|(
operator|&
name|ns_g_fallbackentropy
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ns_os_chroot
argument_list|(
name|ns_g_chrootdir
argument_list|)
expr_stmt|;
comment|/* 	 * For operating systems which have a capability mechanism, now 	 * is the time to switch to minimal privs and change our user id. 	 * On traditional UNIX systems, this call will be a no-op, and we 	 * will change the user ID after reading the config file the first 	 * time.  (We need to read the config file to know which possibly 	 * privileged ports to bind() to.) 	 */
name|ns_os_minprivs
argument_list|()
expr_stmt|;
name|result
operator|=
name|ns_log_init
argument_list|(
name|ISC_TF
argument_list|(
name|ns_g_username
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"ns_log_init() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now is the time to daemonize (if we're not running in the 	 * foreground).  We waited until now because we wanted to get 	 * a valid logging context setup.  We cannot daemonize any later, 	 * because calling create_managers() will create threads, which 	 * would be lost after fork(). 	 */
if|if
condition|(
operator|!
name|ns_g_foreground
condition|)
name|ns_os_daemonize
argument_list|()
expr_stmt|;
comment|/* 	 * We call isc_app_start() here as some versions of FreeBSD's fork() 	 * destroys all the signal handling it sets up. 	 */
name|result
operator|=
name|isc_app_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"isc_app_start() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"starting BIND %s%s"
argument_list|,
name|ns_g_version
argument_list|,
name|saved_command_line
argument_list|)
expr_stmt|;
comment|/* 	 * Get the initial resource limits. 	 */
operator|(
name|void
operator|)
name|isc_resource_getlimit
argument_list|(
name|isc_resource_stacksize
argument_list|,
operator|&
name|ns_g_initstacksize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_resource_getlimit
argument_list|(
name|isc_resource_datasize
argument_list|,
operator|&
name|ns_g_initdatasize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_resource_getlimit
argument_list|(
name|isc_resource_coresize
argument_list|,
operator|&
name|ns_g_initcoresize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_resource_getlimit
argument_list|(
name|isc_resource_openfiles
argument_list|,
operator|&
name|ns_g_initopenfiles
argument_list|)
expr_stmt|;
comment|/* 	 * If the named configuration filename is relative, prepend the current 	 * directory's name before possibly changing to another directory. 	 */
if|if
condition|(
operator|!
name|isc_file_isabsolute
argument_list|(
name|ns_g_conffile
argument_list|)
condition|)
block|{
name|result
operator|=
name|isc_file_absolutepath
argument_list|(
name|ns_g_conffile
argument_list|,
name|absolute_conffile
argument_list|,
sizeof|sizeof
argument_list|(
name|absolute_conffile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"could not construct absolute path of "
literal|"configuration file: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ns_g_conffile
operator|=
name|absolute_conffile
expr_stmt|;
block|}
name|result
operator|=
name|create_managers
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"create_managers() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ns_builtin_init
argument_list|()
expr_stmt|;
comment|/* 	 * Add calls to register sdb drivers here. 	 */
comment|/* xxdb_init(); */
name|ns_server_create
argument_list|(
name|ns_g_mctx
argument_list|,
operator|&
name|ns_g_server
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_managers
argument_list|()
expr_stmt|;
name|ns_server_destroy
argument_list|(
operator|&
name|ns_g_server
argument_list|)
expr_stmt|;
name|ns_builtin_deinit
argument_list|()
expr_stmt|;
comment|/* 	 * Add calls to unregister sdb drivers here. 	 */
comment|/* xxdb_clear(); */
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_GENERAL
argument_list|,
name|NS_LOGMODULE_MAIN
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"exiting"
argument_list|)
expr_stmt|;
name|ns_log_shutdown
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|memstats
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ns_main_setmemstats
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
comment|/* 	 * Caller has to ensure locking. 	 */
if|if
condition|(
name|memstats
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|memstats
argument_list|)
expr_stmt|;
name|memstats
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return;
name|memstats
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|memstats
condition|)
name|strcpy
argument_list|(
name|memstats
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
end_ifdef

begin_comment
comment|/*  * Get FMRI for the named process.  */
end_comment

begin_function
name|isc_result_t
name|ns_smf_get_instance
parameter_list|(
name|char
modifier|*
modifier|*
name|ins_name
parameter_list|,
name|int
name|debug
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|scf_handle_t
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
modifier|*
name|instance
decl_stmt|;
name|REQUIRE
argument_list|(
name|ins_name
operator|!=
name|NULL
operator|&&
operator|*
name|ins_name
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|scf_handle_create
argument_list|(
name|SCF_VERSION
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"scf_handle_create() failed: %s"
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|scf_handle_bind
argument_list|(
name|h
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"scf_handle_bind() failed: %s"
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|scf_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|namelen
operator|=
name|scf_myname
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"scf_myname() failed: %s"
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|scf_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|instance
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"ns_smf_get_instance memory "
literal|"allocation failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
argument_list|)
expr_stmt|;
name|scf_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|scf_myname
argument_list|(
name|h
argument_list|,
name|instance
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"scf_myname() failed: %s"
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|scf_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|scf_handle_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
operator|*
name|ins_name
operator|=
name|instance
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBSCF */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
name|char
modifier|*
name|instance
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Record version in core image. 	 * strings named.core | grep "named version:" 	 */
name|strlcat
argument_list|(
name|version
argument_list|,
ifdef|#
directive|ifdef
name|__DATE__
literal|"named version: BIND "
name|VERSION
literal|" ("
name|__DATE__
literal|")"
argument_list|,
else|#
directive|else
literal|"named version: BIND "
name|VERSION
argument_list|,
endif|#
directive|endif
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_file_progname
argument_list|(
operator|*
name|argv
argument_list|,
name|program_name
argument_list|,
sizeof|sizeof
argument_list|(
name|program_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"program name too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|program_name
argument_list|,
literal|"lwresd"
argument_list|)
operator|==
literal|0
condition|)
name|ns_g_lwresdonly
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_assertion_setcallback
argument_list|(
name|assertion_failed
argument_list|)
expr_stmt|;
name|isc_error_setfatal
argument_list|(
name|library_fatal_error
argument_list|)
expr_stmt|;
name|isc_error_setunexpected
argument_list|(
name|library_unexpected_error
argument_list|)
expr_stmt|;
name|ns_os_init
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|dns_result_register
argument_list|()
expr_stmt|;
name|dst_result_register
argument_list|()
expr_stmt|;
name|isccc_result_register
argument_list|()
expr_stmt|;
name|parse_command_line
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * Warn about common configuration error. 	 */
if|if
condition|(
name|ns_g_chrootdir
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|ns_g_chrootdir
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ns_g_chrootdir
argument_list|,
name|ns_g_conffile
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ns_g_conffile
index|[
name|len
index|]
operator|==
literal|'/'
operator|||
name|ns_g_conffile
index|[
name|len
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|ns_main_earlywarning
argument_list|(
literal|"config filename (-c %s) contains "
literal|"chroot path (-t %s)"
argument_list|,
name|ns_g_conffile
argument_list|,
name|ns_g_chrootdir
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|isc_mem_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ns_g_mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"isc_mem_create() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* 	 * Start things running and then wait for a shutdown request 	 * or reload. 	 */
do|do
block|{
name|result
operator|=
name|isc_app_run
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_RELOAD
condition|)
block|{
name|ns_server_reloadwanted
argument_list|(
name|ns_g_server
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_app_run(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Force exit. 			 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
block|}
do|while
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
do|;
ifdef|#
directive|ifdef
name|HAVE_LIBSCF
if|if
condition|(
name|ns_smf_want_disable
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|ns_smf_get_instance
argument_list|(
operator|&
name|instance
argument_list|,
literal|1
argument_list|,
name|ns_g_mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|instance
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|smf_disable_instance
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"smf_disable_instance() "
literal|"failed for %s : %s"
argument_list|,
name|instance
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|ns_g_mctx
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_LIBSCF */
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|want_stats
condition|)
block|{
name|isc_mem_stats
argument_list|(
name|ns_g_mctx
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|isc_mutex_stats
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memstats
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|memstats
argument_list|,
literal|"w"
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_stats
argument_list|(
name|ns_g_mctx
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|isc_mutex_stats
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|isc_stdio_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|isc_mem_destroy
argument_list|(
operator|&
name|ns_g_mctx
argument_list|)
expr_stmt|;
name|ns_main_setmemstats
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|isc_app_finish
argument_list|()
expr_stmt|;
name|ns_os_closedevnull
argument_list|()
expr_stmt|;
name|ns_os_shutdown
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

