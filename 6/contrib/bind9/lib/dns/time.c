begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: time.c,v 1.18.2.4.2.8 2004/08/28 06:25:20 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_comment
comment|/* Required for HP/UX (and others?) */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdtime.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/time.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|days
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|dns_time64_totext
parameter_list|(
name|isc_int64_t
name|t
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"YYYYMMDDHHMMSS"
argument_list|)
index|]
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|unsigned
name|int
name|l
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|REQUIRE
argument_list|(
name|t
operator|>=
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|is_leap
parameter_list|(
name|y
parameter_list|)
value|((((y) % 4) == 0&& ((y) % 100) != 0) || ((y) % 400) == 0)
define|#
directive|define
name|year_secs
parameter_list|(
name|y
parameter_list|)
value|((is_leap(y) ? 366 : 365 ) * 86400)
define|#
directive|define
name|month_secs
parameter_list|(
name|m
parameter_list|,
name|y
parameter_list|)
value|((days[m] + ((m == 1&& is_leap(y)) ? 1 : 0 )) * 86400)
name|tm
operator|.
name|tm_year
operator|=
literal|70
expr_stmt|;
while|while
condition|(
operator|(
name|secs
operator|=
name|year_secs
argument_list|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
argument_list|)
operator|)
operator|<=
name|t
condition|)
block|{
name|t
operator|-=
name|secs
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|++
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|>
literal|9999
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
name|tm
operator|.
name|tm_mon
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|secs
operator|=
name|month_secs
argument_list|(
name|tm
operator|.
name|tm_mon
argument_list|,
name|tm
operator|.
name|tm_year
operator|+
literal|1900
argument_list|)
operator|)
operator|<=
name|t
condition|)
block|{
name|t
operator|-=
name|secs
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|++
expr_stmt|;
block|}
name|tm
operator|.
name|tm_mday
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|86400
operator|<=
name|t
condition|)
block|{
name|t
operator|-=
literal|86400
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|++
expr_stmt|;
block|}
name|tm
operator|.
name|tm_hour
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|3600
operator|<=
name|t
condition|)
block|{
name|t
operator|-=
literal|3600
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|++
expr_stmt|;
block|}
name|tm
operator|.
name|tm_min
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|60
operator|<=
name|t
condition|)
block|{
name|t
operator|-=
literal|60
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|++
expr_stmt|;
block|}
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|int
operator|)
name|t
expr_stmt|;
comment|/* yyyy  mm  dd  HH  MM  SS */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%04d%02d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|.
name|tm_mday
argument_list|,
name|tm
operator|.
name|tm_hour
argument_list|,
name|tm
operator|.
name|tm_min
argument_list|,
name|tm
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|region
operator|.
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
name|region
operator|.
name|base
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_time32_totext
parameter_list|(
name|isc_uint32_t
name|value
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_int64_t
name|start
decl_stmt|;
name|isc_int64_t
name|base
decl_stmt|;
name|isc_int64_t
name|t
decl_stmt|;
comment|/* 	 * Adjust the time to the closest epoch.  This should be changed 	 * to use a 64-bit counterpart to isc_stdtime_get() if one ever 	 * is defined, but even the current code is good until the year 	 * 2106. 	 */
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|isc_int64_t
operator|)
name|now
expr_stmt|;
name|start
operator|-=
literal|0x7fffffff
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
operator|(
name|base
operator|+
name|value
operator|)
operator|)
operator|<
name|start
condition|)
block|{
name|base
operator|+=
literal|0x80000000
expr_stmt|;
name|base
operator|+=
literal|0x80000000
expr_stmt|;
block|}
return|return
operator|(
name|dns_time64_totext
argument_list|(
name|t
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_time64_fromtext
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|isc_int64_t
modifier|*
name|target
parameter_list|)
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
name|isc_int64_t
name|value
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|RANGE
parameter_list|(
name|min
parameter_list|,
name|max
parameter_list|,
name|value
parameter_list|)
define|\
value|do { \ 		if (value< (min) || value> (max)) \ 			return (ISC_R_RANGE); \ 	} while (0)
if|if
condition|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|!=
literal|14U
condition|)
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|source
argument_list|,
literal|"%4d%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|)
operator|!=
literal|6
condition|)
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
name|RANGE
argument_list|(
literal|1970
argument_list|,
literal|9999
argument_list|,
name|year
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
literal|1
argument_list|,
literal|12
argument_list|,
name|month
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
literal|1
argument_list|,
name|days
index|[
name|month
operator|-
literal|1
index|]
operator|+
operator|(
operator|(
name|month
operator|==
literal|2
operator|&&
name|is_leap
argument_list|(
name|year
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|day
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
literal|0
argument_list|,
literal|23
argument_list|,
name|hour
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
literal|0
argument_list|,
literal|59
argument_list|,
name|minute
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
literal|0
argument_list|,
literal|60
argument_list|,
name|second
argument_list|)
expr_stmt|;
comment|/* 60 == leap second. */
comment|/* 	 * Calulate seconds since epoch. 	 */
name|value
operator|=
name|second
operator|+
operator|(
literal|60
operator|*
name|minute
operator|)
operator|+
operator|(
literal|3600
operator|*
name|hour
operator|)
operator|+
operator|(
operator|(
name|day
operator|-
literal|1
operator|)
operator|*
literal|86400
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|month
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|value
operator|+=
name|days
index|[
name|i
index|]
operator|*
literal|86400
expr_stmt|;
if|if
condition|(
name|is_leap
argument_list|(
name|year
argument_list|)
operator|&&
name|month
operator|>
literal|2
condition|)
name|value
operator|+=
literal|86400
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|<
name|year
condition|;
name|i
operator|++
control|)
block|{
name|secs
operator|=
operator|(
name|is_leap
argument_list|(
name|i
argument_list|)
condition|?
literal|366
else|:
literal|365
operator|)
operator|*
literal|86400
expr_stmt|;
name|value
operator|+=
name|secs
expr_stmt|;
block|}
operator|*
name|target
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_time32_fromtext
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
modifier|*
name|target
parameter_list|)
block|{
name|isc_int64_t
name|value64
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_time64_fromtext
argument_list|(
name|source
argument_list|,
operator|&
name|value64
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
operator|*
name|target
operator|=
operator|(
name|isc_uint32_t
operator|)
name|value64
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

