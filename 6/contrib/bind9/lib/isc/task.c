begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: task.c,v 1.85.2.3.8.5 2004/10/15 00:45:45 marka Exp $ */
end_comment

begin_comment
comment|/*  * Principal Author: Bob Halley  */
end_comment

begin_comment
comment|/*  * XXXRTH  Need to document the states a task can be in, and the rules  * for changing states.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/condition.h>
end_include

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_include
include|#
directive|include
file|"task_p.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_define
define|#
directive|define
name|ISC_TASK_NAMES
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_TASK_TRACE
end_ifdef

begin_define
define|#
directive|define
name|XTRACE
parameter_list|(
name|m
parameter_list|)
value|fprintf(stderr, "task %p thread %lu: %s\n", \ 				       task, isc_thread_self(), (m))
end_define

begin_define
define|#
directive|define
name|XTTRACE
parameter_list|(
name|t
parameter_list|,
name|m
parameter_list|)
value|fprintf(stderr, "task %p thread %lu: %s\n", \ 				       (t), isc_thread_self(), (m))
end_define

begin_define
define|#
directive|define
name|XTHREADTRACE
parameter_list|(
name|m
parameter_list|)
value|fprintf(stderr, "thread %lu: %s\n", \ 				       isc_thread_self(), (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTTRACE
parameter_list|(
name|t
parameter_list|,
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTHREADTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***  *** Types.  ***/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|task_state_idle
block|,
name|task_state_ready
block|,
name|task_state_running
block|,
name|task_state_done
block|}
name|task_state_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TASK_MAGIC
value|ISC_MAGIC('T', 'A', 'S', 'K')
end_define

begin_define
define|#
directive|define
name|VALID_TASK
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, TASK_MAGIC)
end_define

begin_struct
struct|struct
name|isc_task
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_taskmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by task lock. */
name|task_state_t
name|state
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_eventlist_t
name|events
decl_stmt|;
name|isc_eventlist_t
name|on_shutdown
decl_stmt|;
name|unsigned
name|int
name|quantum
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_TASK_NAMES
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
endif|#
directive|endif
comment|/* Locked by task manager lock. */
name|LINK
argument_list|(
argument|isc_task_t
argument_list|)
name|link
expr_stmt|;
name|LINK
argument_list|(
argument|isc_task_t
argument_list|)
name|ready_link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TASK_F_SHUTTINGDOWN
value|0x01
end_define

begin_define
define|#
directive|define
name|TASK_SHUTTINGDOWN
parameter_list|(
name|t
parameter_list|)
value|(((t)->flags& TASK_F_SHUTTINGDOWN) \ 					 != 0)
end_define

begin_define
define|#
directive|define
name|TASK_MANAGER_MAGIC
value|ISC_MAGIC('T', 'S', 'K', 'M')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, TASK_MANAGER_MAGIC)
end_define

begin_struct
struct|struct
name|isc_taskmgr
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|unsigned
name|int
name|workers
decl_stmt|;
name|isc_thread_t
modifier|*
name|threads
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* Locked by task manager lock. */
name|unsigned
name|int
name|default_quantum
decl_stmt|;
name|LIST
argument_list|(
argument|isc_task_t
argument_list|)
name|tasks
expr_stmt|;
name|isc_tasklist_t
name|ready_tasks
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_condition_t
name|work_available
decl_stmt|;
name|isc_condition_t
name|exclusive_granted
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|unsigned
name|int
name|tasks_running
decl_stmt|;
name|isc_boolean_t
name|exclusive_requested
decl_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|unsigned
name|int
name|refs
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_TASKMGR_QUANTUM
value|10
end_define

begin_define
define|#
directive|define
name|DEFAULT_DEFAULT_QUANTUM
value|5
end_define

begin_define
define|#
directive|define
name|FINISHED
parameter_list|(
name|m
parameter_list|)
value|((m)->exiting&& EMPTY((m)->tasks))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_decl_stmt
specifier|static
name|isc_taskmgr_t
modifier|*
name|taskmgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/***  *** Tasks.  ***/
end_comment

begin_function
specifier|static
name|void
name|task_finished
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|task
operator|->
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EMPTY
argument_list|(
name|task
operator|->
name|on_shutdown
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_done
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"task_finished"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|manager
operator|->
name|tasks
argument_list|,
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|FINISHED
argument_list|(
name|manager
argument_list|)
condition|)
block|{
comment|/* 		 * All tasks have completed and the 		 * task manager is exiting.  Wake up 		 * any idle worker threads so they 		 * can exit. 		 */
name|BROADCAST
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|task
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|task
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_task_create
parameter_list|(
name|isc_taskmgr_t
modifier|*
name|manager
parameter_list|,
name|unsigned
name|int
name|quantum
parameter_list|,
name|isc_task_t
modifier|*
modifier|*
name|taskp
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|taskp
operator|!=
name|NULL
operator|&&
operator|*
name|taskp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|task
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|XTRACE
argument_list|(
literal|"isc_task_create"
argument_list|)
expr_stmt|;
name|task
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|task
operator|->
name|state
operator|=
name|task_state_idle
expr_stmt|;
name|task
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|INIT_LIST
argument_list|(
name|task
operator|->
name|events
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
name|task
operator|->
name|on_shutdown
argument_list|)
expr_stmt|;
name|task
operator|->
name|quantum
operator|=
name|quantum
expr_stmt|;
name|task
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|task
operator|->
name|now
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_TASK_NAMES
name|memset
argument_list|(
name|task
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|task
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|INIT_LINK
argument_list|(
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INIT_LINK
argument_list|(
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|manager
operator|->
name|exiting
condition|)
block|{
if|if
condition|(
name|task
operator|->
name|quantum
operator|==
literal|0
condition|)
name|task
operator|->
name|quantum
operator|=
name|manager
operator|->
name|default_quantum
expr_stmt|;
name|APPEND
argument_list|(
name|manager
operator|->
name|tasks
argument_list|,
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|exiting
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|task
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SHUTTINGDOWN
operator|)
return|;
block|}
name|task
operator|->
name|magic
operator|=
name|TASK_MAGIC
expr_stmt|;
operator|*
name|taskp
operator|=
name|task
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_attach
parameter_list|(
name|isc_task_t
modifier|*
name|source
parameter_list|,
name|isc_task_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
comment|/* 	 * Attach *targetp to source. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|XTTRACE
argument_list|(
name|source
argument_list|,
literal|"isc_task_attach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|task_shutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|isc_boolean_t
name|was_idle
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* 	 * Caller must be holding the task's lock. 	 */
name|XTRACE
argument_list|(
literal|"task_shutdown"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TASK_SHUTTINGDOWN
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_SHUTTINGDOWN
argument_list|,
literal|"shutting down"
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|->
name|flags
operator||=
name|TASK_F_SHUTTINGDOWN
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|state
operator|==
name|task_state_idle
condition|)
block|{
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|->
name|state
operator|=
name|task_state_ready
expr_stmt|;
name|was_idle
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_ready
operator|||
name|task
operator|->
name|state
operator|==
name|task_state_running
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we post shutdown events LIFO. 		 */
for|for
control|(
name|event
operator|=
name|TAIL
argument_list|(
name|task
operator|->
name|on_shutdown
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|DEQUEUE
argument_list|(
name|task
operator|->
name|on_shutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ENQUEUE
argument_list|(
name|task
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|was_idle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|task_ready
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|task
operator|->
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_ready
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"task_ready"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ENQUEUE
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|,
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|task_detach
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
comment|/* 	 * Caller must be holding the task lock. 	 */
name|REQUIRE
argument_list|(
name|task
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"detach"
argument_list|)
expr_stmt|;
name|task
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|references
operator|==
literal|0
operator|&&
name|task
operator|->
name|state
operator|==
name|task_state_idle
condition|)
block|{
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * There are no references to this task, and no 		 * pending events.  We could try to optimize and 		 * either initiate shutdown or clean up the task, 		 * depending on its state, but it's easier to just 		 * make the task ready and allow run() or the event 		 * loop to deal with shutting down and termination. 		 */
name|task
operator|->
name|state
operator|=
name|task_state_ready
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_detach
parameter_list|(
name|isc_task_t
modifier|*
modifier|*
name|taskp
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_boolean_t
name|was_idle
decl_stmt|;
comment|/* 	 * Detach *taskp from its task. 	 */
name|REQUIRE
argument_list|(
name|taskp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|*
name|taskp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"isc_task_detach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|was_idle
operator|=
name|task_detach
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_idle
condition|)
name|task_ready
argument_list|(
name|task
argument_list|)
expr_stmt|;
operator|*
name|taskp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|task_send
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
block|{
name|isc_boolean_t
name|was_idle
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
comment|/* 	 * Caller must be holding the task lock. 	 */
name|REQUIRE
argument_list|(
name|eventp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event
operator|=
operator|*
name|eventp
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|state
operator|!=
name|task_state_done
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"task_send"
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|state
operator|==
name|task_state_idle
condition|)
block|{
name|was_idle
operator|=
name|ISC_TRUE
expr_stmt|;
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|->
name|state
operator|=
name|task_state_ready
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_ready
operator|||
name|task
operator|->
name|state
operator|==
name|task_state_running
argument_list|)
expr_stmt|;
name|ENQUEUE
argument_list|(
name|task
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
operator|*
name|eventp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|was_idle
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_send
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
block|{
name|isc_boolean_t
name|was_idle
decl_stmt|;
comment|/* 	 * Send '*event' to 'task'. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"isc_task_send"
argument_list|)
expr_stmt|;
comment|/* 	 * We're trying hard to hold locks for as short a time as possible. 	 * We're also trying to hold as few locks as possible.  This is why 	 * some processing is deferred until after the lock is released. 	 */
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|was_idle
operator|=
name|task_send
argument_list|(
name|task
argument_list|,
name|eventp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_idle
condition|)
block|{
comment|/* 		 * We need to add this task to the ready queue. 		 * 		 * We've waited until now to do it because making a task 		 * ready requires locking the manager.  If we tried to do 		 * this while holding the task lock, we could deadlock. 		 * 		 * We've changed the state to ready, so no one else will 		 * be trying to add this task to the ready queue.  The 		 * only way to leave the ready state is by executing the 		 * task.  It thus doesn't matter if events are added, 		 * removed, or a shutdown is started in the interval 		 * between the time we released the task lock, and the time 		 * we add the task to the ready queue. 		 */
name|task_ready
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isc_task_sendanddetach
parameter_list|(
name|isc_task_t
modifier|*
modifier|*
name|taskp
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
block|{
name|isc_boolean_t
name|idle1
decl_stmt|,
name|idle2
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
comment|/* 	 * Send '*event' to '*taskp' and then detach '*taskp' from its 	 * task. 	 */
name|REQUIRE
argument_list|(
name|taskp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|*
name|taskp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"isc_task_sendanddetach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|idle1
operator|=
name|task_send
argument_list|(
name|task
argument_list|,
name|eventp
argument_list|)
expr_stmt|;
name|idle2
operator|=
name|task_detach
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If idle1, then idle2 shouldn't be true as well since we're holding 	 * the task lock, and thus the task cannot switch from ready back to 	 * idle. 	 */
name|INSIST
argument_list|(
operator|!
operator|(
name|idle1
operator|&&
name|idle2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle1
operator|||
name|idle2
condition|)
name|task_ready
argument_list|(
name|task
argument_list|)
expr_stmt|;
operator|*
name|taskp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PURGE_OK
parameter_list|(
name|event
parameter_list|)
value|(((event)->ev_attributes& ISC_EVENTATTR_NOPURGE) == 0)
end_define

begin_function
specifier|static
name|unsigned
name|int
name|dequeue_events
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|void
modifier|*
name|sender
parameter_list|,
name|isc_eventtype_t
name|first
parameter_list|,
name|isc_eventtype_t
name|last
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|isc_eventlist_t
modifier|*
name|events
parameter_list|,
name|isc_boolean_t
name|purging
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|last
operator|>=
name|first
argument_list|)
expr_stmt|;
name|XTRACE
argument_list|(
literal|"dequeue_events"
argument_list|)
expr_stmt|;
comment|/* 	 * Events matching 'sender', whose type is>= first and<= last, and 	 * whose tag is 'tag' will be dequeued.  If 'purging', matching events 	 * which are marked as unpurgable will not be dequeued. 	 * 	 * sender == NULL means "any sender", and tag == NULL means "any tag". 	 */
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|HEAD
argument_list|(
name|task
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|>=
name|first
operator|&&
name|event
operator|->
name|ev_type
operator|<=
name|last
operator|&&
operator|(
name|sender
operator|==
name|NULL
operator|||
name|event
operator|->
name|ev_sender
operator|==
name|sender
operator|)
operator|&&
operator|(
name|tag
operator|==
name|NULL
operator|||
name|event
operator|->
name|ev_tag
operator|==
name|tag
operator|)
operator|&&
operator|(
operator|!
name|purging
operator|||
name|PURGE_OK
argument_list|(
name|event
argument_list|)
operator|)
condition|)
block|{
name|DEQUEUE
argument_list|(
name|task
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ENQUEUE
argument_list|(
operator|*
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_task_purgerange
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|void
modifier|*
name|sender
parameter_list|,
name|isc_eventtype_t
name|first
parameter_list|,
name|isc_eventtype_t
name|last
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|isc_eventlist_t
name|events
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
comment|/* 	 * Purge events from a task's event queue. 	 */
name|XTRACE
argument_list|(
literal|"isc_task_purgerange"
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|events
argument_list|)
expr_stmt|;
name|count
operator|=
name|dequeue_events
argument_list|(
name|task
argument_list|,
name|sender
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|tag
argument_list|,
operator|&
name|events
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|HEAD
argument_list|(
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that purging never changes the state of the task. 	 */
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_task_purge
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|void
modifier|*
name|sender
parameter_list|,
name|isc_eventtype_t
name|type
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
comment|/* 	 * Purge events from a task's event queue. 	 */
name|XTRACE
argument_list|(
literal|"isc_task_purge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|isc_task_purgerange
argument_list|(
name|task
argument_list|,
name|sender
argument_list|,
name|type
argument_list|,
name|type
argument_list|,
name|tag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc_task_purgeevent
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|curr_event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
comment|/* 	 * Purge 'event' from a task's event queue. 	 * 	 * XXXRTH:  WARNING:  This method may be removed before beta. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If 'event' is on the task's event queue, it will be purged, 	 * unless it is marked as unpurgeable.  'event' does not have to be 	 * on the task's event queue; in fact, it can even be an invalid 	 * pointer.  Purging only occurs if the event is actually on the task's 	 * event queue. 	 * 	 * Purging never changes the state of the task. 	 */
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_event
operator|=
name|HEAD
argument_list|(
name|task
operator|->
name|events
argument_list|)
init|;
name|curr_event
operator|!=
name|NULL
condition|;
name|curr_event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|NEXT
argument_list|(
name|curr_event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_event
operator|==
name|event
operator|&&
name|PURGE_OK
argument_list|(
name|event
argument_list|)
condition|)
block|{
name|DEQUEUE
argument_list|(
name|task
operator|->
name|events
argument_list|,
name|curr_event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_event
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|isc_event_free
argument_list|(
operator|&
name|curr_event
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_task_unsendrange
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|void
modifier|*
name|sender
parameter_list|,
name|isc_eventtype_t
name|first
parameter_list|,
name|isc_eventtype_t
name|last
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|isc_eventlist_t
modifier|*
name|events
parameter_list|)
block|{
comment|/* 	 * Remove events from a task's event queue. 	 */
name|XTRACE
argument_list|(
literal|"isc_task_unsendrange"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dequeue_events
argument_list|(
name|task
argument_list|,
name|sender
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|tag
argument_list|,
name|events
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_task_unsend
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|void
modifier|*
name|sender
parameter_list|,
name|isc_eventtype_t
name|type
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|isc_eventlist_t
modifier|*
name|events
parameter_list|)
block|{
comment|/* 	 * Remove events from a task's event queue. 	 */
name|XTRACE
argument_list|(
literal|"isc_task_unsend"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dequeue_events
argument_list|(
name|task
argument_list|,
name|sender
argument_list|,
name|type
argument_list|,
name|type
argument_list|,
name|tag
argument_list|,
name|events
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_task_onshutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_boolean_t
name|disallowed
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
comment|/* 	 * Send a shutdown event with action 'action' and argument 'arg' when 	 * 'task' is shutdown. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|task
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|ISC_TASKEVENT_SHUTDOWN
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TASK_SHUTTINGDOWN
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|disallowed
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
block|}
else|else
name|ENQUEUE
argument_list|(
name|task
operator|->
name|on_shutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disallowed
condition|)
name|isc_mem_put
argument_list|(
name|task
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|event
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_shutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|isc_boolean_t
name|was_idle
decl_stmt|;
comment|/* 	 * Shutdown 'task'. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|was_idle
operator|=
name|task_shutdown
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_idle
condition|)
name|task_ready
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_task_destroy
parameter_list|(
name|isc_task_t
modifier|*
modifier|*
name|taskp
parameter_list|)
block|{
comment|/* 	 * Destroy '*taskp'. 	 */
name|REQUIRE
argument_list|(
name|taskp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
operator|*
name|taskp
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
name|taskp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_task_setname
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
comment|/* 	 * Name 'task'. 	 */
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_TASK_NAMES
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|task
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|task
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|task
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|task
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|task
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|tag
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|isc_task_getname
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
return|return
operator|(
name|task
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc_task_gettag
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
return|return
operator|(
name|task
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_getcurrenttime
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_stdtime_t
modifier|*
name|t
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|task
operator|->
name|now
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***  *** Task Manager.  ***/
end_comment

begin_function
specifier|static
name|void
name|dispatch
parameter_list|(
name|isc_taskmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|unsigned
name|int
name|total_dispatch_count
init|=
literal|0
decl_stmt|;
name|isc_tasklist_t
name|ready_tasks
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Again we're trying to hold the lock for as short a time as possible 	 * and to do as little locking and unlocking as possible. 	 * 	 * In both while loops, the appropriate lock must be held before the 	 * while body starts.  Code which acquired the lock at the top of 	 * the loop would be more readable, but would result in a lot of 	 * extra locking.  Compare: 	 * 	 * Straightforward: 	 * 	 *	LOCK(); 	 *	... 	 *	UNLOCK(); 	 *	while (expression) { 	 *		LOCK(); 	 *		... 	 *		UNLOCK(); 	 * 	 *	       	Unlocked part here... 	 * 	 *		LOCK(); 	 *		... 	 *		UNLOCK(); 	 *	} 	 * 	 * Note how if the loop continues we unlock and then immediately lock. 	 * For N iterations of the loop, this code does 2N+1 locks and 2N+1 	 * unlocks.  Also note that the lock is not held when the while 	 * condition is tested, which may or may not be important, depending 	 * on the expression. 	 * 	 * As written: 	 * 	 *	LOCK(); 	 *	while (expression) { 	 *		... 	 *		UNLOCK(); 	 * 	 *	       	Unlocked part here... 	 * 	 *		LOCK(); 	 *		... 	 *	} 	 *	UNLOCK(); 	 * 	 * For N iterations of the loop, this code does N+1 locks and N+1 	 * unlocks.  The while expression is always protected by the lock. 	 */
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|ISC_LIST_INIT
argument_list|(
name|ready_tasks
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|FINISHED
argument_list|(
name|manager
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 		 * For reasons similar to those given in the comment in 		 * isc_task_send() above, it is safe for us to dequeue 		 * the task while only holding the manager lock, and then 		 * change the task to running state while only holding the 		 * task lock. 		 */
while|while
condition|(
operator|(
name|EMPTY
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|)
operator|||
name|manager
operator|->
name|exclusive_requested
operator|)
operator|&&
operator|!
name|FINISHED
argument_list|(
name|manager
argument_list|)
condition|)
block|{
name|XTHREADTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_WAIT
argument_list|,
literal|"wait"
argument_list|)
argument_list|)
expr_stmt|;
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|XTHREADTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_AWAKE
argument_list|,
literal|"awake"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
if|if
condition|(
name|total_dispatch_count
operator|>=
name|DEFAULT_TASKMGR_QUANTUM
operator|||
name|EMPTY
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|)
condition|)
break|break;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|XTHREADTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_WORKING
argument_list|,
literal|"working"
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|=
name|HEAD
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|dispatch_count
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|requeue
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|finished
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|INSIST
argument_list|(
name|VALID_TASK
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Note we only unlock the manager lock if we actually 			 * have a task to do.  We must reacquire the manager 			 * lock before exiting the 'if (task != NULL)' block. 			 */
name|DEQUEUE
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|,
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
name|manager
operator|->
name|tasks_running
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_ready
argument_list|)
expr_stmt|;
name|task
operator|->
name|state
operator|=
name|task_state_running
expr_stmt|;
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_RUNNING
argument_list|,
literal|"running"
argument_list|)
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|task
operator|->
name|now
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
condition|)
block|{
name|event
operator|=
name|HEAD
argument_list|(
name|task
operator|->
name|events
argument_list|)
expr_stmt|;
name|DEQUEUE
argument_list|(
name|task
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 					 * Execute the event action. 					 */
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_EXECUTE
argument_list|,
literal|"execute action"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_action
operator|!=
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
name|event
operator|->
name|ev_action
call|)
argument_list|(
name|task
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|dispatch_count
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|total_dispatch_count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
block|}
if|if
condition|(
name|task
operator|->
name|references
operator|==
literal|0
operator|&&
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
operator|&&
operator|!
name|TASK_SHUTTINGDOWN
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|isc_boolean_t
name|was_idle
decl_stmt|;
comment|/* 					 * There are no references and no 					 * pending events for this task, 					 * which means it will not become 					 * runnable again via an external 					 * action (such as sending an event 					 * or detaching). 					 * 					 * We initiate shutdown to prevent 					 * it from becoming a zombie. 					 * 					 * We do this here instead of in 					 * the "if EMPTY(task->events)" block 					 * below because: 					 * 					 *	If we post no shutdown events, 					 *	we want the task to finish. 					 * 					 *	If we did post shutdown events, 					 *	will still want the task's 					 *	quantum to be applied. 					 */
name|was_idle
operator|=
name|task_shutdown
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|was_idle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EMPTY
argument_list|(
name|task
operator|->
name|events
argument_list|)
condition|)
block|{
comment|/* 					 * Nothing else to do for this task 					 * right now. 					 */
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_EMPTY
argument_list|,
literal|"empty"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|references
operator|==
literal|0
operator|&&
name|TASK_SHUTTINGDOWN
argument_list|(
name|task
argument_list|)
condition|)
block|{
comment|/* 						 * The task is done. 						 */
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_DONE
argument_list|,
literal|"done"
argument_list|)
argument_list|)
expr_stmt|;
name|finished
operator|=
name|ISC_TRUE
expr_stmt|;
name|task
operator|->
name|state
operator|=
name|task_state_done
expr_stmt|;
block|}
else|else
name|task
operator|->
name|state
operator|=
name|task_state_idle
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dispatch_count
operator|>=
name|task
operator|->
name|quantum
condition|)
block|{
comment|/* 					 * Our quantum has expired, but 					 * there is more work to be done. 					 * We'll requeue it to the ready 					 * queue later. 					 * 					 * We don't check quantum until 					 * dispatching at least one event, 					 * so the minimum quantum is one. 					 */
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TASK
argument_list|,
name|ISC_MSG_QUANTUM
argument_list|,
literal|"quantum"
argument_list|)
argument_list|)
expr_stmt|;
name|task
operator|->
name|state
operator|=
name|task_state_ready
expr_stmt|;
name|requeue
operator|=
name|ISC_TRUE
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
name|task_finished
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|tasks_running
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|manager
operator|->
name|exclusive_requested
operator|&&
name|manager
operator|->
name|tasks_running
operator|==
literal|1
condition|)
block|{
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|exclusive_granted
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
if|if
condition|(
name|requeue
condition|)
block|{
comment|/* 				 * We know we're awake, so we don't have 				 * to wakeup any sleeping threads if the 				 * ready queue is empty before we requeue. 				 * 				 * A possible optimization if the queue is 				 * empty is to 'goto' the 'if (task != NULL)' 				 * block, avoiding the ENQUEUE of the task 				 * and the subsequent immediate DEQUEUE 				 * (since it is the only executable task). 				 * We don't do this because then we'd be 				 * skipping the exit_requested check.  The 				 * cost of ENQUEUE is low anyway, especially 				 * when you consider that we'd have to do 				 * an extra EMPTY check to see if we could 				 * do the optimization.  If the ready queue 				 * were usually nonempty, the 'optimization' 				 * might even hurt rather than help. 				 */
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|ENQUEUE
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|,
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
else|#
directive|else
name|ENQUEUE
argument_list|(
name|ready_tasks
argument_list|,
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|ISC_LIST_APPENDLIST
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|,
name|ready_tasks
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_function
specifier|static
name|isc_threadresult_t
ifdef|#
directive|ifdef
name|_WIN32
name|WINAPI
endif|#
directive|endif
name|run
parameter_list|(
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|uap
decl_stmt|;
name|XTHREADTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_STARTING
argument_list|,
literal|"starting"
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch
argument_list|(
name|manager
argument_list|)
expr_stmt|;
name|XTHREADTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_EXITING
argument_list|,
literal|"exiting"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_threadresult_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_function
specifier|static
name|void
name|manager_free
parameter_list|(
name|isc_taskmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|exclusive_granted
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
operator|->
name|threads
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_taskmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|workers
parameter_list|,
name|unsigned
name|int
name|default_quantum
parameter_list|,
name|isc_taskmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|started
init|=
literal|0
decl_stmt|;
name|isc_taskmgr_t
modifier|*
name|manager
decl_stmt|;
comment|/* 	 * Create a new task manager. 	 */
name|REQUIRE
argument_list|(
name|workers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
operator|&&
operator|*
name|managerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|started
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|workers
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskmgr
operator|!=
name|NULL
condition|)
block|{
name|taskmgr
operator|->
name|refs
operator|++
expr_stmt|;
operator|*
name|managerp
operator|=
name|taskmgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|manager
operator|->
name|magic
operator|=
name|TASK_MANAGER_MAGIC
expr_stmt|;
name|manager
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_mgr
goto|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|manager
operator|->
name|workers
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|threads
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|workers
operator|*
sizeof|sizeof
argument_list|(
name|isc_thread_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|threads
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_lock
goto|;
block|}
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_threads
goto|;
block|}
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|exclusive_granted
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_workavailable
goto|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
if|if
condition|(
name|default_quantum
operator|==
literal|0
condition|)
name|default_quantum
operator|=
name|DEFAULT_DEFAULT_QUANTUM
expr_stmt|;
name|manager
operator|->
name|default_quantum
operator|=
name|default_quantum
expr_stmt|;
name|INIT_LIST
argument_list|(
name|manager
operator|->
name|tasks
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|)
expr_stmt|;
name|manager
operator|->
name|tasks_running
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|exclusive_requested
operator|=
name|ISC_FALSE
expr_stmt|;
name|manager
operator|->
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Start workers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|workers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isc_thread_create
argument_list|(
name|run
argument_list|,
name|manager
argument_list|,
operator|&
name|manager
operator|->
name|threads
index|[
name|manager
operator|->
name|workers
index|]
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|manager
operator|->
name|workers
operator|++
expr_stmt|;
name|started
operator|++
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|started
operator|==
literal|0
condition|)
block|{
name|manager_free
argument_list|(
name|manager
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTHREADS
operator|)
return|;
block|}
name|isc_thread_setconcurrency
argument_list|(
name|workers
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
name|taskmgr
operator|=
name|manager
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
operator|*
name|managerp
operator|=
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|cleanup_workavailable
label|:
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
name|cleanup_threads
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|threads
argument_list|)
expr_stmt|;
name|cleanup_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup_mgr
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_taskmgr_destroy
parameter_list|(
name|isc_taskmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_taskmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* 	 * Destroy '*managerp'. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|manager
operator|->
name|refs
operator|--
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|XTHREADTRACE
argument_list|(
literal|"isc_taskmgr_destroy"
argument_list|)
expr_stmt|;
comment|/* 	 * Only one non-worker thread may ever call this routine. 	 * If a worker thread wants to initiate shutdown of the 	 * task manager, it should ask some non-worker thread to call 	 * isc_taskmgr_destroy(), e.g. by signalling a condition variable 	 * that the startup thread is sleeping on. 	 */
comment|/* 	 * Unlike elsewhere, we're going to hold this lock a long time. 	 * We need to do so, because otherwise the list of tasks could 	 * change while we were traversing it. 	 * 	 * This is also the only function where we will hold both the 	 * task manager lock and a task lock at the same time. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we only get called once. 	 */
name|INSIST
argument_list|(
operator|!
name|manager
operator|->
name|exiting
argument_list|)
expr_stmt|;
name|manager
operator|->
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Post shutdown event(s) to every task (if they haven't already been 	 * posted). 	 */
for|for
control|(
name|task
operator|=
name|HEAD
argument_list|(
name|manager
operator|->
name|tasks
argument_list|)
init|;
name|task
operator|!=
name|NULL
condition|;
name|task
operator|=
name|NEXT
argument_list|(
name|task
argument_list|,
name|link
argument_list|)
control|)
block|{
name|LOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_shutdown
argument_list|(
name|task
argument_list|)
condition|)
name|ENQUEUE
argument_list|(
name|manager
operator|->
name|ready_tasks
argument_list|,
name|task
argument_list|,
name|ready_link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|task
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * Wake up any sleeping workers.  This ensures we get work done if 	 * there's work left to do, and if there are already no tasks left 	 * it will cause the workers to see manager->exiting. 	 */
name|BROADCAST
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for all the worker threads to exit. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|manager
operator|->
name|workers
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|isc_thread_join
argument_list|(
name|manager
operator|->
name|threads
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * Dispatch the shutdown events. 	 */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|isc__taskmgr_ready
argument_list|()
condition|)
operator|(
name|void
operator|)
name|isc__taskmgr_dispatch
argument_list|()
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|tasks
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|manager_free
argument_list|(
name|manager
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_function
name|isc_boolean_t
name|isc__taskmgr_ready
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|taskmgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TF
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|taskmgr
operator|->
name|ready_tasks
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__taskmgr_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|taskmgr
decl_stmt|;
if|if
condition|(
name|taskmgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
name|dispatch
argument_list|(
name|manager
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_function
name|isc_result_t
name|isc_task_beginexclusive
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|task
operator|->
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_running
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|exclusive_requested
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_LOCKBUSY
operator|)
return|;
block|}
name|manager
operator|->
name|exclusive_requested
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|manager
operator|->
name|tasks_running
operator|>
literal|1
condition|)
block|{
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|exclusive_granted
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_task_endexclusive
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_taskmgr_t
modifier|*
name|manager
init|=
name|task
operator|->
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|->
name|state
operator|==
name|task_state_running
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|manager
operator|->
name|exclusive_requested
argument_list|)
expr_stmt|;
name|manager
operator|->
name|exclusive_requested
operator|=
name|ISC_FALSE
expr_stmt|;
name|BROADCAST
argument_list|(
operator|&
name|manager
operator|->
name|work_available
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

