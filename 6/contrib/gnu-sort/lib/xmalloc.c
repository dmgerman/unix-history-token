begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xmalloc.c -- malloc with out of memory checking     Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_MAX
end_ifndef

begin_define
define|#
directive|define
name|SIZE_MAX
value|((size_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate an array of N objects, each with S bytes of memory,    dynamically, with error checking.  S must be nonzero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|xnmalloc_inline
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|xalloc_oversized
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|n
operator|*
name|s
argument_list|)
operator|)
operator|&&
name|n
operator|!=
literal|0
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xnmalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|xnmalloc_inline
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate N bytes of memory dynamically, with error checking.  */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
return|return
name|xnmalloc_inline
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change the size of an allocated block of memory P to an array of N    objects each of S bytes, with error checking.  S must be nonzero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|xnrealloc_inline
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|xalloc_oversized
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
operator|*
name|s
argument_list|)
operator|)
operator|&&
name|n
operator|!=
literal|0
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xnrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|xnrealloc_inline
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change the size of an allocated block of memory P to N bytes,    with error checking.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|xnrealloc_inline
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If P is null, allocate a block of at least *PN such objects;    otherwise, reallocate P so that it contains more than *PN objects    each of S bytes.  *PN must be nonzero unless P is null, and S must    be nonzero.  Set *PN to the new number of objects, and return the    pointer to the new block.  *PN is never set to zero, and the    returned pointer is never null.     Repeated reallocations are guaranteed to make progress, either by    allocating an initial block with a nonzero size, or by allocating a    larger block.     In the following implementation, nonzero sizes are doubled so that    repeated reallocations have O(N log N) overall cost rather than    O(N**2) cost, but the specification for this function does not    guarantee that sizes are doubled.     Here is an example of use:       int *p = NULL;      size_t used = 0;      size_t allocated = 0;       void      append_int (int value)        { 	 if (used == allocated) 	   p = x2nrealloc (p,&allocated, sizeof *p); 	 p[used++] = value;        }     This causes x2nrealloc to allocate a block of some nonzero size the    first time it is called.     To have finer-grained control over the initial size, set *PN to a    nonzero value before calling this function with P == NULL.  For    example:       int *p = NULL;      size_t used = 0;      size_t allocated = 0;      size_t allocated1 = 1000;       void      append_int (int value)        { 	 if (used == allocated) 	   { 	     p = x2nrealloc (p,&allocated1, sizeof *p); 	     allocated = allocated1; 	   } 	 p[used++] = value;        }     */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|x2nrealloc_inline
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|size_t
name|n
init|=
operator|*
name|pn
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* The approximate size to use for initial small allocation 	     requests, when the invoking code specifies an old size of 	     zero.  64 bytes is the largest "small" request for the 	     GNU C library malloc.  */
enum|enum
block|{
name|DEFAULT_MXFAST
init|=
literal|64
block|}
enum|;
name|n
operator|=
name|DEFAULT_MXFAST
operator|/
name|s
expr_stmt|;
name|n
operator|+=
operator|!
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|SIZE_MAX
operator|/
literal|2
operator|/
name|s
operator|<
name|n
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
block|}
operator|*
name|pn
operator|=
name|n
expr_stmt|;
return|return
name|xrealloc
argument_list|(
name|p
argument_list|,
name|n
operator|*
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|x2nrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|x2nrealloc_inline
argument_list|(
name|p
argument_list|,
name|pn
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If P is null, allocate a block of at least *PN bytes; otherwise,    reallocate P so that it contains more than *PN bytes.  *PN must be    nonzero unless P is null.  Set *PN to the new block's size, and    return the pointer to the new block.  *PN is never set to zero, and    the returned pointer is never null.  */
end_comment

begin_function
name|void
modifier|*
name|x2realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|)
block|{
return|return
name|x2nrealloc_inline
argument_list|(
name|p
argument_list|,
name|pn
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate S bytes of zeroed memory dynamically, with error checking.    There's no need for xnzalloc (N, S), since it would be equivalent    to xcalloc (N, S).  */
end_comment

begin_function
name|void
modifier|*
name|xzalloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
name|memset
argument_list|(
name|xmalloc
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate zeroed memory for N elements of S bytes, with error    checking.  S must be nonzero.  */
end_comment

begin_function
name|void
modifier|*
name|xcalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Test for overflow, since some calloc implementations don't have      proper overflow checks.  */
if|if
condition|(
name|xalloc_oversized
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|p
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
operator|)
operator|&&
name|n
operator|!=
literal|0
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Clone an object P of size S, with error checking.  There's no need    for xnclone (P, N, S), since xclone (P, N * S) works without any    need for an arithmetic overflow check.  */
end_comment

begin_function
name|void
modifier|*
name|xclone
parameter_list|(
name|void
specifier|const
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|memcpy
argument_list|(
name|xmalloc
argument_list|(
name|s
argument_list|)
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

end_unit

