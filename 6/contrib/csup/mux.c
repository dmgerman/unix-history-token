begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2006, Maxime Henrion<mux@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"mux.h"
end_include

begin_comment
comment|/*  * Packet types.  */
end_comment

begin_define
define|#
directive|define
name|MUX_STARTUPREQ
value|0
end_define

begin_define
define|#
directive|define
name|MUX_STARTUPREP
value|1
end_define

begin_define
define|#
directive|define
name|MUX_CONNECT
value|2
end_define

begin_define
define|#
directive|define
name|MUX_ACCEPT
value|3
end_define

begin_define
define|#
directive|define
name|MUX_RESET
value|4
end_define

begin_define
define|#
directive|define
name|MUX_DATA
value|5
end_define

begin_define
define|#
directive|define
name|MUX_WINDOW
value|6
end_define

begin_define
define|#
directive|define
name|MUX_CLOSE
value|7
end_define

begin_comment
comment|/*  * Header sizes.  */
end_comment

begin_define
define|#
directive|define
name|MUX_STARTUPHDRSZ
value|3
end_define

begin_define
define|#
directive|define
name|MUX_CONNECTHDRSZ
value|8
end_define

begin_define
define|#
directive|define
name|MUX_ACCEPTHDRSZ
value|8
end_define

begin_define
define|#
directive|define
name|MUX_RESETHDRSZ
value|2
end_define

begin_define
define|#
directive|define
name|MUX_DATAHDRSZ
value|4
end_define

begin_define
define|#
directive|define
name|MUX_WINDOWHDRSZ
value|6
end_define

begin_define
define|#
directive|define
name|MUX_CLOSEHDRSZ
value|2
end_define

begin_define
define|#
directive|define
name|MUX_PROTOVER
value|0
end_define

begin_comment
comment|/* Protocol version. */
end_comment

begin_struct
struct|struct
name|mux_header
block|{
name|uint8_t
name|type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|uint16_t
name|version
decl_stmt|;
block|}
name|__packed
name|mh_startup
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
name|uint16_t
name|mss
decl_stmt|;
name|uint32_t
name|window
decl_stmt|;
block|}
name|__packed
name|mh_connect
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
name|uint16_t
name|mss
decl_stmt|;
name|uint32_t
name|window
decl_stmt|;
block|}
name|__packed
name|mh_accept
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
block|}
name|__packed
name|mh_reset
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
block|}
name|__packed
name|mh_data
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
name|uint32_t
name|window
decl_stmt|;
block|}
name|__packed
name|mh_window
struct|;
struct|struct
block|{
name|uint8_t
name|id
decl_stmt|;
block|}
name|__packed
name|mh_close
struct|;
block|}
name|mh_u
union|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|mh_startup
value|mh_u.mh_startup
end_define

begin_define
define|#
directive|define
name|mh_connect
value|mh_u.mh_connect
end_define

begin_define
define|#
directive|define
name|mh_accept
value|mh_u.mh_accept
end_define

begin_define
define|#
directive|define
name|mh_reset
value|mh_u.mh_reset
end_define

begin_define
define|#
directive|define
name|mh_data
value|mh_u.mh_data
end_define

begin_define
define|#
directive|define
name|mh_window
value|mh_u.mh_window
end_define

begin_define
define|#
directive|define
name|mh_close
value|mh_u.mh_close
end_define

begin_define
define|#
directive|define
name|MUX_MAXCHAN
value|2
end_define

begin_comment
comment|/* Channel states. */
end_comment

begin_define
define|#
directive|define
name|CS_UNUSED
value|0
end_define

begin_define
define|#
directive|define
name|CS_LISTENING
value|1
end_define

begin_define
define|#
directive|define
name|CS_CONNECTING
value|2
end_define

begin_define
define|#
directive|define
name|CS_ESTABLISHED
value|3
end_define

begin_define
define|#
directive|define
name|CS_RDCLOSED
value|4
end_define

begin_define
define|#
directive|define
name|CS_WRCLOSED
value|5
end_define

begin_define
define|#
directive|define
name|CS_CLOSED
value|6
end_define

begin_comment
comment|/* Channel flags. */
end_comment

begin_define
define|#
directive|define
name|CF_CONNECT
value|0x01
end_define

begin_define
define|#
directive|define
name|CF_ACCEPT
value|0x02
end_define

begin_define
define|#
directive|define
name|CF_RESET
value|0x04
end_define

begin_define
define|#
directive|define
name|CF_WINDOW
value|0x08
end_define

begin_define
define|#
directive|define
name|CF_DATA
value|0x10
end_define

begin_define
define|#
directive|define
name|CF_CLOSE
value|0x20
end_define

begin_define
define|#
directive|define
name|CHAN_SBSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* Send buffer size. */
end_comment

begin_define
define|#
directive|define
name|CHAN_RBSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* Receive buffer size. */
end_comment

begin_define
define|#
directive|define
name|CHAN_MAXSEGSIZE
value|1024
end_define

begin_comment
comment|/* Maximum segment size. */
end_comment

begin_comment
comment|/* Circular buffer. */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|in
decl_stmt|;
name|size_t
name|out
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|chan
block|{
name|int
name|flags
decl_stmt|;
name|int
name|state
decl_stmt|;
name|pthread_mutex_t
name|lock
decl_stmt|;
name|struct
name|mux
modifier|*
name|mux
decl_stmt|;
comment|/* Receiver state variables. */
name|struct
name|buf
modifier|*
name|recvbuf
decl_stmt|;
name|pthread_cond_t
name|rdready
decl_stmt|;
name|uint32_t
name|recvseq
decl_stmt|;
name|uint16_t
name|recvmss
decl_stmt|;
comment|/* Sender state variables. */
name|struct
name|buf
modifier|*
name|sendbuf
decl_stmt|;
name|pthread_cond_t
name|wrready
decl_stmt|;
name|uint32_t
name|sendseq
decl_stmt|;
name|uint32_t
name|sendwin
decl_stmt|;
name|uint16_t
name|sendmss
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mux
block|{
name|int
name|closed
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|socket
decl_stmt|;
name|pthread_mutex_t
name|lock
decl_stmt|;
name|pthread_cond_t
name|done
decl_stmt|;
name|struct
name|chan
modifier|*
name|channels
index|[
name|MUX_MAXCHAN
index|]
decl_stmt|;
name|int
name|nchans
decl_stmt|;
comment|/* Sender thread data. */
name|pthread_t
name|sender
decl_stmt|;
name|pthread_cond_t
name|sender_newwork
decl_stmt|;
name|pthread_cond_t
name|sender_started
decl_stmt|;
name|int
name|sender_waiting
decl_stmt|;
name|int
name|sender_ready
decl_stmt|;
name|int
name|sender_lastid
decl_stmt|;
comment|/* Receiver thread data. */
name|pthread_t
name|receiver
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|sock_writev
parameter_list|(
name|int
parameter_list|,
name|struct
name|iovec
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sock_write
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sock_read
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sock_readwait
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mux_init
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mux_lock
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mux_unlock
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|chan
modifier|*
name|chan_new
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|chan
modifier|*
name|chan_get
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|chan
modifier|*
name|chan_connect
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chan_lock
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chan_unlock
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chan_insert
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chan_free
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|buf
modifier|*
name|buf_new
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|buf_count
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|buf_avail
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|buf_get
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|buf_put
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|buf_free
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sender_wakeup
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|sender_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sender_waitforwork
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sender_scan
parameter_list|(
name|struct
name|mux
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sender_cleanup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|receiver_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sock_writev
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|iovcnt
parameter_list|)
block|{
name|ssize_t
name|nbytes
decl_stmt|;
name|again
label|:
name|nbytes
operator|=
name|writev
argument_list|(
name|s
argument_list|,
name|iov
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|nbytes
operator|>
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|nbytes
operator|>=
name|iov
operator|->
name|iov_len
condition|)
block|{
name|nbytes
operator|-=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|iov
operator|++
expr_stmt|;
name|iovcnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iov
operator|->
name|iov_len
operator|-=
name|nbytes
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|iov
operator|->
name|iov_base
operator|+
name|nbytes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|sock_write
parameter_list|(
name|int
name|s
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|ret
operator|=
name|sock_writev
argument_list|(
name|s
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sock_read
parameter_list|(
name|int
name|s
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ssize_t
name|nbytes
decl_stmt|;
name|again
label|:
name|nbytes
operator|=
name|read
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sock_readwait
parameter_list|(
name|int
name|s
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ssize_t
name|nbytes
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|left
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|sock_read
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ECONNRESET
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|left
operator|-=
name|nbytes
expr_stmt|;
name|cp
operator|+=
name|nbytes
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mux_lock
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mux_unlock
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a TCP multiplexer on the given socket. */
end_comment

begin_function
name|struct
name|mux
modifier|*
name|mux_open
parameter_list|(
name|int
name|sock
parameter_list|,
name|struct
name|chan
modifier|*
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|mux
modifier|*
name|m
decl_stmt|;
name|struct
name|chan
modifier|*
name|chan0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mux
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
operator|->
name|channels
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|channels
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|nchans
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|socket
operator|=
name|sock
expr_stmt|;
name|m
operator|->
name|sender_waiting
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|sender_lastid
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|sender_ready
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|m
operator|->
name|done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|m
operator|->
name|sender_newwork
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|m
operator|->
name|sender_started
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|mux_init
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan0
operator|=
name|chan_connect
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan0
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
operator|*
name|chan
operator|=
name|chan0
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
name|bad
label|:
name|mux_shutdown
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|STATUS_FAILURE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mux_close
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mux_close
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
name|assert
argument_list|(
name|m
operator|->
name|closed
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
name|m
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
name|chan_free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
name|pthread_cond_destroy
argument_list|(
operator|&
name|m
operator|->
name|sender_started
argument_list|)
expr_stmt|;
name|pthread_cond_destroy
argument_list|(
operator|&
name|m
operator|->
name|sender_newwork
argument_list|)
expr_stmt|;
name|pthread_cond_destroy
argument_list|(
operator|&
name|m
operator|->
name|done
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|m
operator|->
name|status
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close a channel. */
end_comment

begin_function
name|int
name|chan_close
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_ESTABLISHED
condition|)
block|{
name|chan
operator|->
name|state
operator|=
name|CS_WRCLOSED
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|CF_CLOSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_RDCLOSED
condition|)
block|{
name|chan
operator|->
name|state
operator|=
name|CS_CLOSED
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|CF_CLOSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_WRCLOSED
operator|||
name|chan
operator|->
name|state
operator|==
name|CS_CLOSED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|chan
operator|->
name|mux
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|chan_wait
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
while|while
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_CLOSED
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|,
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the ID of an available channel in the listening state. */
end_comment

begin_function
name|int
name|chan_listen
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
name|m
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_UNUSED
condition|)
block|{
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator|=
name|CS_LISTENING
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan
operator|=
name|chan_new
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator|=
name|CS_LISTENING
expr_stmt|;
name|i
operator|=
name|chan_insert
argument_list|(
name|m
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|chan_free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|chan
modifier|*
name|chan_accept
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|id
argument_list|)
expr_stmt|;
while|while
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_LISTENING
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|,
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_ESTABLISHED
condition|)
block|{
name|errno
operator|=
name|ECONNRESET
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read bytes from a channel. */
end_comment

begin_function
name|ssize_t
name|chan_read
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|n
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_RDCLOSED
operator|||
name|chan
operator|->
name|state
operator|==
name|CS_CLOSED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_ESTABLISHED
operator|&&
name|chan
operator|->
name|state
operator|!=
name|CS_WRCLOSED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|count
operator|=
name|buf_count
argument_list|(
name|chan
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
break|break;
name|pthread_cond_wait
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|,
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf_get
argument_list|(
name|chan
operator|->
name|recvbuf
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|chan
operator|->
name|recvseq
operator|+=
name|n
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|CF_WINDOW
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* We need to wake up the sender so that it sends a window update. */
name|sender_wakeup
argument_list|(
name|chan
operator|->
name|mux
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write bytes to a channel. */
end_comment

begin_function
name|ssize_t
name|chan_write
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|avail
decl_stmt|,
name|n
decl_stmt|,
name|pos
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_ESTABLISHED
operator|&&
name|chan
operator|->
name|state
operator|!=
name|CS_RDCLOSED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EPIPE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|avail
operator|=
name|buf_avail
argument_list|(
name|chan
operator|->
name|sendbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>
literal|0
condition|)
break|break;
name|pthread_cond_wait
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|,
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|avail
argument_list|,
name|size
operator|-
name|pos
argument_list|)
expr_stmt|;
name|buf_put
argument_list|(
name|chan
operator|->
name|sendbuf
argument_list|,
name|cp
operator|+
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|n
expr_stmt|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|chan
operator|->
name|mux
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal channel API.  */
end_comment

begin_function
specifier|static
name|struct
name|chan
modifier|*
name|chan_connect
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_UNUSED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan
operator|->
name|state
operator|=
name|CS_CONNECTING
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|CF_CONNECT
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
while|while
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_CONNECTING
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|,
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_ESTABLISHED
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a channel from its ID, creating it if necessary.  * The channel is returned locked.  */
end_comment

begin_function
specifier|static
name|struct
name|chan
modifier|*
name|chan_get
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|assert
argument_list|(
name|id
operator|<
name|MUX_MAXCHAN
argument_list|)
expr_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan
operator|=
name|m
operator|->
name|channels
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|chan
operator|=
name|chan_new
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|channels
index|[
name|id
index|]
operator|=
name|chan
expr_stmt|;
name|m
operator|->
name|nchans
operator|++
expr_stmt|;
block|}
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lock a channel. */
end_comment

begin_function
specifier|static
name|void
name|chan_lock
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlock a channel.  */
end_comment

begin_function
specifier|static
name|void
name|chan_unlock
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new channel.  */
end_comment

begin_function
specifier|static
name|struct
name|chan
modifier|*
name|chan_new
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator|=
name|CS_UNUSED
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|mux
operator|=
name|m
expr_stmt|;
name|chan
operator|->
name|sendbuf
operator|=
name|buf_new
argument_list|(
name|CHAN_SBSIZE
argument_list|)
expr_stmt|;
name|chan
operator|->
name|sendseq
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|sendwin
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|sendmss
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|recvbuf
operator|=
name|buf_new
argument_list|(
name|CHAN_RBSIZE
argument_list|)
expr_stmt|;
name|chan
operator|->
name|recvseq
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|recvmss
operator|=
name|CHAN_MAXSEGSIZE
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|chan
operator|->
name|lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free any resources associated with a channel. */
end_comment

begin_function
specifier|static
name|void
name|chan_free
parameter_list|(
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|pthread_cond_destroy
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|)
expr_stmt|;
name|pthread_cond_destroy
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|chan
operator|->
name|lock
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|chan
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|chan
operator|->
name|sendbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the new channel in the channel list. */
end_comment

begin_function
specifier|static
name|int
name|chan_insert
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|struct
name|chan
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MUX_MAXCHAN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|channels
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|channels
index|[
name|i
index|]
operator|=
name|chan
expr_stmt|;
name|m
operator|->
name|nchans
operator|++
expr_stmt|;
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
name|errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the multiplexer protocol.  *  * This means negotiating protocol version and starting  * the receiver and sender threads.  */
end_comment

begin_function
specifier|static
name|int
name|mux_init
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mux_header
name|mh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mh
operator|.
name|type
operator|=
name|MUX_STARTUPREQ
expr_stmt|;
name|mh
operator|.
name|mh_startup
operator|.
name|version
operator|=
name|htons
argument_list|(
name|MUX_PROTOVER
argument_list|)
expr_stmt|;
name|error
operator|=
name|sock_write
argument_list|(
name|m
operator|->
name|socket
argument_list|,
operator|&
name|mh
argument_list|,
name|MUX_STARTUPHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|sock_readwait
argument_list|(
name|m
operator|->
name|socket
argument_list|,
operator|&
name|mh
argument_list|,
name|MUX_STARTUPHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mh
operator|.
name|type
operator|!=
name|MUX_STARTUPREP
operator|||
name|ntohs
argument_list|(
name|mh
operator|.
name|mh_startup
operator|.
name|version
argument_list|)
operator|!=
name|MUX_PROTOVER
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|pthread_create
argument_list|(
operator|&
name|m
operator|->
name|sender
argument_list|,
name|NULL
argument_list|,
name|sender_loop
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Make sure the sender thread has run and is waiting for new work 	 * before going on.  Otherwise, it might lose the race and a 	 * request, which will cause a deadlock. 	 */
while|while
condition|(
operator|!
name|m
operator|->
name|sender_ready
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|m
operator|->
name|sender_started
argument_list|,
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|pthread_create
argument_list|(
operator|&
name|m
operator|->
name|receiver
argument_list|,
name|NULL
argument_list|,
name|receiver_loop
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close all the channels, terminate the sender and receiver thread.  * This is an important function because it is used everytime we need  * to wake up all the worker threads to abort the program.  *  * This function accepts an error message that will be printed if the  * multiplexer wasn't already closed.  This is useful because it ensures  * that only the first error message will be printed, and that it will  * be printed before doing the actual shutdown work.  If this is a  * normal shutdown, NULL can be passed instead.  *  * The "status" parameter of the first mux_shutdown() call is retained  * and then returned by mux_close(),  so that the main thread can know  * what type of error happened in the end, if any.  */
end_comment

begin_function
name|void
name|mux_shutdown
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|pthread_t
name|self
decl_stmt|,
name|sender
decl_stmt|,
name|receiver
decl_stmt|;
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|closed
condition|)
block|{
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|self
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
name|sender
operator|=
name|m
operator|->
name|sender
expr_stmt|;
name|receiver
operator|=
name|m
operator|->
name|receiver
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pthread_equal
argument_list|(
name|self
argument_list|,
name|receiver
argument_list|)
condition|)
name|name
operator|=
literal|"Receiver"
expr_stmt|;
elseif|else
if|if
condition|(
name|pthread_equal
argument_list|(
name|self
argument_list|,
name|sender
argument_list|)
condition|)
name|name
operator|=
literal|"Sender"
expr_stmt|;
else|else
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MUX_MAXCHAN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|=
name|m
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_UNUSED
condition|)
block|{
name|chan
operator|->
name|state
operator|=
name|CS_CLOSED
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|)
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|)
expr_stmt|;
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pthread_equal
argument_list|(
name|self
argument_list|,
name|receiver
argument_list|)
condition|)
block|{
name|ret
operator|=
name|pthread_cancel
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ret
argument_list|)
expr_stmt|;
name|pthread_join
argument_list|(
name|receiver
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|val
operator|==
name|PTHREAD_CANCELED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pthread_equal
argument_list|(
name|self
argument_list|,
name|sender
argument_list|)
condition|)
block|{
name|ret
operator|=
name|pthread_cancel
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ret
argument_list|)
expr_stmt|;
name|pthread_join
argument_list|(
name|sender
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|val
operator|==
name|PTHREAD_CANCELED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sender_wakeup
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|)
block|{
name|int
name|waiting
decl_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|m
operator|->
name|sender_waiting
expr_stmt|;
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * We don't care about the race here: if the sender was 	 * waiting and is not anymore, we'll just send a useless 	 * signal; if he wasn't waiting then he won't go to sleep 	 * before having sent what we want him to. 	 */
if|if
condition|(
name|waiting
condition|)
name|pthread_cond_signal
argument_list|(
operator|&
name|m
operator|->
name|sender_newwork
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|sender_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|mux_header
name|mh
decl_stmt|;
name|struct
name|mux
modifier|*
name|m
decl_stmt|;
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|winsize
decl_stmt|;
name|uint16_t
name|hdrsize
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|,
name|iovcnt
decl_stmt|,
name|what
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mux
operator|*
operator|)
name|arg
expr_stmt|;
name|again
label|:
name|id
operator|=
name|sender_waitforwork
argument_list|(
name|m
argument_list|,
operator|&
name|what
argument_list|)
expr_stmt|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|hdrsize
operator|=
name|size
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|CF_CONNECT
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_CONNECT
expr_stmt|;
name|mh
operator|.
name|mh_connect
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|mh
operator|.
name|mh_connect
operator|.
name|mss
operator|=
name|htons
argument_list|(
name|chan
operator|->
name|recvmss
argument_list|)
expr_stmt|;
name|mh
operator|.
name|mh_connect
operator|.
name|window
operator|=
name|htonl
argument_list|(
name|chan
operator|->
name|recvseq
operator|+
name|chan
operator|->
name|recvbuf
operator|->
name|size
argument_list|)
expr_stmt|;
name|hdrsize
operator|=
name|MUX_CONNECTHDRSZ
expr_stmt|;
break|break;
case|case
name|CF_ACCEPT
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_ACCEPT
expr_stmt|;
name|mh
operator|.
name|mh_accept
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|mh
operator|.
name|mh_accept
operator|.
name|mss
operator|=
name|htons
argument_list|(
name|chan
operator|->
name|recvmss
argument_list|)
expr_stmt|;
name|mh
operator|.
name|mh_accept
operator|.
name|window
operator|=
name|htonl
argument_list|(
name|chan
operator|->
name|recvseq
operator|+
name|chan
operator|->
name|recvbuf
operator|->
name|size
argument_list|)
expr_stmt|;
name|hdrsize
operator|=
name|MUX_ACCEPTHDRSZ
expr_stmt|;
break|break;
case|case
name|CF_RESET
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_RESET
expr_stmt|;
name|mh
operator|.
name|mh_reset
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|hdrsize
operator|=
name|MUX_RESETHDRSZ
expr_stmt|;
break|break;
case|case
name|CF_WINDOW
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_WINDOW
expr_stmt|;
name|mh
operator|.
name|mh_window
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|mh
operator|.
name|mh_window
operator|.
name|window
operator|=
name|htonl
argument_list|(
name|chan
operator|->
name|recvseq
operator|+
name|chan
operator|->
name|recvbuf
operator|->
name|size
argument_list|)
expr_stmt|;
name|hdrsize
operator|=
name|MUX_WINDOWHDRSZ
expr_stmt|;
break|break;
case|case
name|CF_DATA
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_DATA
expr_stmt|;
name|mh
operator|.
name|mh_data
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|buf_count
argument_list|(
name|chan
operator|->
name|sendbuf
argument_list|)
argument_list|,
name|chan
operator|->
name|sendmss
argument_list|)
expr_stmt|;
name|winsize
operator|=
name|chan
operator|->
name|sendwin
operator|-
name|chan
operator|->
name|sendseq
expr_stmt|;
if|if
condition|(
name|winsize
operator|<
name|size
condition|)
name|size
operator|=
name|winsize
expr_stmt|;
name|mh
operator|.
name|mh_data
operator|.
name|len
operator|=
name|htons
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|hdrsize
operator|=
name|MUX_DATAHDRSZ
expr_stmt|;
break|break;
case|case
name|CF_CLOSE
case|:
name|mh
operator|.
name|type
operator|=
name|MUX_CLOSE
expr_stmt|;
name|mh
operator|.
name|mh_close
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|hdrsize
operator|=
name|MUX_CLOSEHDRSZ
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|mh
operator|.
name|type
operator|==
name|MUX_DATA
argument_list|)
expr_stmt|;
comment|/* 		 * Older FreeBSD versions (and maybe other OSes) have the 		 * iov_base field defined as char *.  Cast to char * to 		 * silence a warning in this case. 		 */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mh
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|hdrsize
expr_stmt|;
name|iovcnt
operator|=
literal|1
expr_stmt|;
comment|/* We access the buffer directly to avoid some copying. */
name|buf
operator|=
name|chan
operator|->
name|sendbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|buf
operator|->
name|size
operator|+
literal|1
operator|-
name|buf
operator|->
name|out
argument_list|)
expr_stmt|;
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_base
operator|=
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|out
expr_stmt|;
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|iovcnt
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
comment|/* Wrapping around. */
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_base
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_len
operator|=
name|size
operator|-
name|len
expr_stmt|;
name|iovcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Since we're the only thread sending bytes from the 		 * buffer and modifying buf->out, it's safe to unlock 		 * here during I/O.  It avoids keeping the channel lock 		 * too long, since write() might block. 		 */
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|error
operator|=
name|sock_writev
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|iov
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|chan
operator|->
name|sendseq
operator|+=
name|size
expr_stmt|;
name|buf
operator|->
name|out
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|out
operator|>
name|buf
operator|->
name|size
condition|)
name|buf
operator|->
name|out
operator|-=
name|buf
operator|->
name|size
operator|+
literal|1
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|error
operator|=
name|sock_write
argument_list|(
name|m
operator|->
name|socket
argument_list|,
operator|&
name|mh
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
goto|goto
name|again
goto|;
name|bad
label|:
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|mux_shutdown
argument_list|(
name|m
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|STATUS_TRANSIENTFAILURE
argument_list|)
expr_stmt|;
else|else
name|mux_shutdown
argument_list|(
name|m
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|STATUS_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sender_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mux
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mux
operator|*
operator|)
name|arg
expr_stmt|;
name|mux_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sender_waitforwork
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|what
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|mux_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pthread_cleanup_push
argument_list|(
name|sender_cleanup
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|sender_ready
condition|)
block|{
name|pthread_cond_signal
argument_list|(
operator|&
name|m
operator|->
name|sender_started
argument_list|)
expr_stmt|;
name|m
operator|->
name|sender_ready
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|id
operator|=
name|sender_scan
argument_list|(
name|m
argument_list|,
name|what
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|m
operator|->
name|sender_waiting
operator|=
literal|1
expr_stmt|;
name|pthread_cond_wait
argument_list|(
operator|&
name|m
operator|->
name|sender_newwork
argument_list|,
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|sender_waiting
operator|=
literal|0
expr_stmt|;
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan for work to do for the sender.  Has to be called with  * the multiplexer lock held.  */
end_comment

begin_function
specifier|static
name|int
name|sender_scan
parameter_list|(
name|struct
name|mux
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|what
parameter_list|)
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|nchans
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|id
operator|=
name|m
operator|->
name|sender_lastid
expr_stmt|;
do|do
block|{
name|id
operator|++
expr_stmt|;
if|if
condition|(
name|id
operator|>=
name|m
operator|->
name|nchans
condition|)
name|id
operator|=
literal|0
expr_stmt|;
name|chan
operator|=
name|m
operator|->
name|channels
index|[
name|id
index|]
expr_stmt|;
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|!=
name|CS_UNUSED
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|sendseq
operator|!=
name|chan
operator|->
name|sendwin
operator|&&
name|buf_count
argument_list|(
name|chan
operator|->
name|sendbuf
argument_list|)
operator|>
literal|0
condition|)
name|chan
operator|->
name|flags
operator||=
name|CF_DATA
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flags
condition|)
block|{
comment|/* By order of importance. */
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_CONNECT
condition|)
operator|*
name|what
operator|=
name|CF_CONNECT
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_ACCEPT
condition|)
operator|*
name|what
operator|=
name|CF_ACCEPT
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_RESET
condition|)
operator|*
name|what
operator|=
name|CF_RESET
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_WINDOW
condition|)
operator|*
name|what
operator|=
name|CF_WINDOW
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_DATA
condition|)
operator|*
name|what
operator|=
name|CF_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|CF_CLOSE
condition|)
operator|*
name|what
operator|=
name|CF_CLOSE
expr_stmt|;
name|chan
operator|->
name|flags
operator|&=
operator|~
operator|*
name|what
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|m
operator|->
name|sender_lastid
operator|=
name|id
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
block|}
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|id
operator|!=
name|m
operator|->
name|sender_lastid
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the rest of a packet header depending on its type. */
end_comment

begin_define
define|#
directive|define
name|SOCK_READREST
parameter_list|(
name|s
parameter_list|,
name|mh
parameter_list|,
name|hsize
parameter_list|)
define|\
value|sock_readwait(s, (char *)&mh + sizeof(mh.type), (hsize) - sizeof(mh.type))
end_define

begin_function
name|void
modifier|*
name|receiver_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mux_header
name|mh
decl_stmt|;
name|struct
name|mux
modifier|*
name|m
decl_stmt|;
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|uint16_t
name|size
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mux
operator|*
operator|)
name|arg
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|sock_readwait
argument_list|(
name|m
operator|->
name|socket
argument_list|,
operator|&
name|mh
operator|.
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|mh
operator|.
name|type
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|mh
operator|.
name|type
condition|)
block|{
case|case
name|MUX_CONNECT
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_CONNECTHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|mh
operator|.
name|mh_connect
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_LISTENING
condition|)
block|{
name|chan
operator|->
name|state
operator|=
name|CS_ESTABLISHED
expr_stmt|;
name|chan
operator|->
name|sendmss
operator|=
name|ntohs
argument_list|(
name|mh
operator|.
name|mh_connect
operator|.
name|mss
argument_list|)
expr_stmt|;
name|chan
operator|->
name|sendwin
operator|=
name|ntohl
argument_list|(
name|mh
operator|.
name|mh_connect
operator|.
name|window
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|CF_ACCEPT
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|)
expr_stmt|;
block|}
else|else
name|chan
operator|->
name|flags
operator||=
name|CF_RESET
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|MUX_ACCEPT
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_ACCEPTHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|mh
operator|.
name|mh_accept
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_CONNECTING
condition|)
block|{
name|chan
operator|->
name|sendmss
operator|=
name|ntohs
argument_list|(
name|mh
operator|.
name|mh_accept
operator|.
name|mss
argument_list|)
expr_stmt|;
name|chan
operator|->
name|sendwin
operator|=
name|ntohl
argument_list|(
name|mh
operator|.
name|mh_accept
operator|.
name|window
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator|=
name|CS_ESTABLISHED
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|chan
operator|->
name|wrready
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|flags
operator||=
name|CF_RESET
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MUX_RESET
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_RESETHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
goto|goto
name|badproto
goto|;
case|case
name|MUX_WINDOW
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_WINDOWHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|mh
operator|.
name|mh_window
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_ESTABLISHED
operator|||
name|chan
operator|->
name|state
operator|==
name|CS_RDCLOSED
condition|)
block|{
name|chan
operator|->
name|sendwin
operator|=
name|ntohl
argument_list|(
name|mh
operator|.
name|mh_window
operator|.
name|window
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|sender_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MUX_DATA
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_DATAHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|mh
operator|.
name|mh_data
operator|.
name|id
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|mh
operator|.
name|mh_data
operator|.
name|len
argument_list|)
expr_stmt|;
name|buf
operator|=
name|chan
operator|->
name|recvbuf
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|->
name|state
operator|!=
name|CS_ESTABLISHED
operator|&&
name|chan
operator|->
name|state
operator|!=
name|CS_WRCLOSED
operator|)
operator|||
operator|(
name|len
operator|>
name|buf_avail
argument_list|(
name|buf
argument_list|)
operator|||
name|len
operator|>
name|chan
operator|->
name|recvmss
operator|)
condition|)
block|{
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
goto|goto
name|badproto
goto|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Similarly to the sender code, it's safe to 			 * unlock the channel here. 			 */
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|buf
operator|->
name|size
operator|+
literal|1
operator|-
name|buf
operator|->
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|sock_readwait
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|in
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|len
operator|>
name|size
condition|)
block|{
comment|/* Wrapping around. */
name|error
operator|=
name|sock_readwait
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|len
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|chan_lock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|buf
operator|->
name|in
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|in
operator|>
name|buf
operator|->
name|size
condition|)
name|buf
operator|->
name|in
operator|-=
name|buf
operator|->
name|size
operator|+
literal|1
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
break|break;
case|case
name|MUX_CLOSE
case|:
name|error
operator|=
name|SOCK_READREST
argument_list|(
name|m
operator|->
name|socket
argument_list|,
name|mh
argument_list|,
name|MUX_CLOSEHDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|chan
operator|=
name|chan_get
argument_list|(
name|m
argument_list|,
name|mh
operator|.
name|mh_close
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_ESTABLISHED
condition|)
name|chan
operator|->
name|state
operator|=
name|CS_RDCLOSED
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|CS_WRCLOSED
condition|)
name|chan
operator|->
name|state
operator|=
name|CS_CLOSED
expr_stmt|;
else|else
goto|goto
name|badproto
goto|;
name|pthread_cond_signal
argument_list|(
operator|&
name|chan
operator|->
name|rdready
argument_list|)
expr_stmt|;
name|chan_unlock
argument_list|(
name|chan
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|badproto
goto|;
block|}
block|}
name|bad
label|:
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
operator|||
name|errno
operator|==
name|ECONNABORTED
condition|)
name|mux_shutdown
argument_list|(
name|m
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|STATUS_TRANSIENTFAILURE
argument_list|)
expr_stmt|;
else|else
name|mux_shutdown
argument_list|(
name|m
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|STATUS_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|badproto
label|:
name|mux_shutdown
argument_list|(
name|m
argument_list|,
literal|"Protocol error"
argument_list|,
name|STATUS_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Circular buffers API.  */
end_comment

begin_function
specifier|static
name|struct
name|buf
modifier|*
name|buf_new
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|out
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_free
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
name|free
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Number of bytes stored in the buffer. */
end_comment

begin_function
specifier|static
name|size_t
name|buf_count
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
name|size_t
name|count
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|in
operator|>=
name|buf
operator|->
name|out
condition|)
name|count
operator|=
name|buf
operator|->
name|in
operator|-
name|buf
operator|->
name|out
expr_stmt|;
else|else
name|count
operator|=
name|buf
operator|->
name|size
operator|+
literal|1
operator|+
name|buf
operator|->
name|in
operator|-
name|buf
operator|->
name|out
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes available in the buffer. */
end_comment

begin_function
specifier|static
name|size_t
name|buf_avail
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
name|size_t
name|avail
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|out
operator|>
name|buf
operator|->
name|in
condition|)
name|avail
operator|=
name|buf
operator|->
name|out
operator|-
name|buf
operator|->
name|in
operator|-
literal|1
expr_stmt|;
else|else
name|avail
operator|=
name|buf
operator|->
name|size
operator|+
name|buf
operator|->
name|out
operator|-
name|buf
operator|->
name|in
expr_stmt|;
return|return
operator|(
name|avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_put
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buf_avail
argument_list|(
name|buf
argument_list|)
operator|>=
name|size
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|size
operator|+
literal|1
operator|-
name|buf
operator|->
name|in
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|size
condition|)
block|{
comment|/* Wrapping around. */
name|memcpy
argument_list|(
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|in
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|cp
operator|+
name|len
argument_list|,
name|size
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not wrapping around. */
name|memcpy
argument_list|(
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|in
argument_list|,
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|in
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|in
operator|>
name|buf
operator|->
name|size
condition|)
name|buf
operator|->
name|in
operator|-=
name|buf
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_get
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buf_count
argument_list|(
name|buf
argument_list|)
operator|>=
name|size
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|size
operator|+
literal|1
operator|-
name|buf
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|size
condition|)
block|{
comment|/* Wrapping around. */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
operator|+
name|len
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|size
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not wrapping around. */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|out
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|out
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|out
operator|>
name|buf
operator|->
name|size
condition|)
name|buf
operator|->
name|out
operator|-=
name|buf
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
end_function

end_unit

