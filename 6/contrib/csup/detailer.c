begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2006, Maxime Henrion<mux@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"detailer.h"
end_include

begin_include
include|#
directive|include
file|"fixups.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"mux.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"status.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* Internal error codes. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_PROTO
value|(-1)
end_define

begin_comment
comment|/* Protocol error. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_MSG
value|(-2)
end_define

begin_comment
comment|/* Error is in detailer->errmsg. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_READ
value|(-3)
end_define

begin_comment
comment|/* Error reading from server. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_WRITE
value|(-4)
end_define

begin_comment
comment|/* Error writing to server. */
end_comment

begin_struct
struct|struct
name|detailer
block|{
name|struct
name|config
modifier|*
name|config
decl_stmt|;
name|struct
name|stream
modifier|*
name|rd
decl_stmt|;
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|detailer_batch
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_coll
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|struct
name|status
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_dofile
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|struct
name|status
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|detailer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread_args
modifier|*
name|args
decl_stmt|;
name|struct
name|detailer
name|dbuf
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|arg
expr_stmt|;
name|d
operator|=
operator|&
name|dbuf
expr_stmt|;
name|d
operator|->
name|config
operator|=
name|args
operator|->
name|config
expr_stmt|;
name|d
operator|->
name|rd
operator|=
name|args
operator|->
name|rd
expr_stmt|;
name|d
operator|->
name|wr
operator|=
name|args
operator|->
name|wr
expr_stmt|;
name|d
operator|->
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|detailer_batch
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|DETAILER_ERR_PROTO
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: Protocol error"
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_FAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_MSG
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: %s"
argument_list|,
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_FAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_READ
case|:
if|if
condition|(
name|stream_eof
argument_list|(
name|d
operator|->
name|rd
argument_list|)
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Premature EOF from server"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Network read failure: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|args
operator|->
name|status
operator|=
name|STATUS_TRANSIENTFAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_WRITE
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Network write failure: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_TRANSIENTFAILURE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_batch
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|config
modifier|*
name|config
decl_stmt|;
name|struct
name|stream
modifier|*
name|rd
decl_stmt|,
modifier|*
name|wr
decl_stmt|;
name|struct
name|coll
modifier|*
name|coll
decl_stmt|;
name|struct
name|status
modifier|*
name|st
decl_stmt|;
name|struct
name|fixup
modifier|*
name|fixup
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|collname
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|release
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fixupseof
decl_stmt|;
name|config
operator|=
name|d
operator|->
name|config
expr_stmt|;
name|rd
operator|=
name|d
operator|->
name|rd
expr_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|coll
argument_list|,
argument|&config->colls
argument_list|,
argument|co_next
argument_list|)
block|{
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_SKIP
condition|)
continue|continue;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|collname
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|release
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|error
operator|=
name|proto_get_time
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|coll
operator|->
name|co_scantime
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|line
operator|!=
name|NULL
operator|||
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"COLL"
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|collname
argument_list|,
name|coll
operator|->
name|co_name
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|release
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"COLL %s %s\n"
argument_list|,
name|coll
operator|->
name|co_name
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
block|{
name|stream_filter_start
argument_list|(
name|rd
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stream_filter_start
argument_list|(
name|wr
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|status_open
argument_list|(
name|coll
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
name|error
operator|=
name|detailer_coll
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|status_close
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
block|{
name|stream_filter_stop
argument_list|(
name|rd
argument_list|)
expr_stmt|;
name|stream_filter_stop
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
comment|/* Now send fixups if needed. */
name|fixup
operator|=
name|NULL
expr_stmt|;
name|fixupseof
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|coll
argument_list|,
argument|&config->colls
argument_list|,
argument|co_next
argument_list|)
block|{
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_SKIP
condition|)
continue|continue;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"COLL %s %s\n"
argument_list|,
name|coll
operator|->
name|co_name
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
name|stream_filter_start
argument_list|(
name|wr
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fixupseof
condition|)
block|{
if|if
condition|(
name|fixup
operator|==
name|NULL
condition|)
name|fixup
operator|=
name|fixups_get
argument_list|(
name|config
operator|->
name|fixups
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|==
name|NULL
condition|)
block|{
name|fixupseof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixup
operator|->
name|f_coll
operator|!=
name|coll
condition|)
break|break;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"Y %s %s %s\n"
argument_list|,
name|fixup
operator|->
name|f_name
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|fixup
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
name|stream_filter_stop
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_coll
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|struct
name|status
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|rd
decl_stmt|,
modifier|*
name|wr
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rd
operator|=
name|d
operator|->
name|rd
expr_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
while|while
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'D'
case|:
comment|/* Delete file. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"D %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
break|break;
case|case
literal|'U'
case|:
comment|/* Add or update file. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|detailer_dofile
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|st
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
literal|'!'
case|:
comment|/* Warning from server. */
name|msg
operator|=
name|proto_get_rest
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Server warning: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
block|}
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_dofile
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|struct
name|status
modifier|*
name|st
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
name|md5
index|[
name|MD5_DIGEST_SIZE
index|]
decl_stmt|;
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|struct
name|fattr
modifier|*
name|fa
decl_stmt|;
name|struct
name|statusrec
modifier|*
name|sr
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|path
operator|=
name|checkoutpath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|fa
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have the file, so the only option at this 		   point is to tell the server to send it.  The server 		   may figure out that the file is dead, in which case 		   it will tell us. */
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"C %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|status_get
argument_list|(
name|st
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|errmsg
operator|=
name|status_errmsg
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|sr
operator|=
name|NULL
expr_stmt|;
comment|/* If our recorded information doesn't match the file that the 	   client has, then ignore the recorded information. */
if|if
condition|(
name|sr
operator|!=
name|NULL
operator|&&
operator|(
name|sr
operator|->
name|sr_type
operator|!=
name|SR_CHECKOUTLIVE
operator|||
operator|!
name|fattr_equal
argument_list|(
name|sr
operator|->
name|sr_clientattr
argument_list|,
name|fa
argument_list|)
operator|)
condition|)
name|sr
operator|=
name|NULL
expr_stmt|;
name|fattr_free
argument_list|(
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|sr
operator|->
name|sr_revdate
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"U %s %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|sr
operator|->
name|sr_revnum
argument_list|,
name|sr
operator|->
name|sr_revdate
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We don't have complete and/or accurate recorded information 	 * about what version of the file we have.  Compute the file's 	 * checksum as an aid toward identifying which version it is. 	 */
name|error
operator|=
name|MD5_File
argument_list|(
name|path
argument_list|,
name|md5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|d
operator|->
name|errmsg
argument_list|,
literal|"Cannot calculate checksum for \"%s\": %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"S %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|md5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"s %s %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|sr
operator|->
name|sr_revnum
argument_list|,
name|md5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

