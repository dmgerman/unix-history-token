begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze file differences for GNU DIFF.    Copyright (C) 1988, 1989, 1992, 1993, 1997 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* The basic algorithm is described in:    "An O(ND) Difference Algorithm and its Variations", Eugene Myers,    Algorithmica Vol. 1 No. 2, 1986, pp. 251-266;    see especially section 4.2, which describes the variation used below.    Unless the --minimal option is specified, this code uses the TOO_EXPENSIVE    heuristic, by Paul Eggert, to limit the cost to O(N**1.5 log N)    at the price of producing suboptimal output for large inputs with    many differences.     The basic algorithm was independently discovered as described in:    "Algorithms for Approximate String Matching", E. Ukkonen,    Information and Control Vol. 64, 1985, pp. 100-118.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"cmpbuf.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|no_discards
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|xvec
decl_stmt|,
modifier|*
name|yvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vectors being compared. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|fdiag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by diagonal, containing 				   1 + the X coordinate of the point furthest 				   along the given diagonal in the forward 				   search of the edit matrix. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bdiag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by diagonal, containing 				   the X coordinate of the point furthest 				   along the given diagonal in the backward 				   search of the edit matrix. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|too_expensive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Edit scripts longer than this are too 				   expensive to compute.  */
end_comment

begin_define
define|#
directive|define
name|SNAKE_LIMIT
value|20
end_define

begin_comment
comment|/* Snakes bigger than this are considered `big'.  */
end_comment

begin_struct
struct|struct
name|partition
block|{
name|int
name|xmid
decl_stmt|,
name|ymid
decl_stmt|;
comment|/* Midpoints of this partition.  */
name|int
name|lo_minimal
decl_stmt|;
comment|/* Nonzero if low half will be analyzed minimally.  */
name|int
name|hi_minimal
decl_stmt|;
comment|/* Likewise for high half.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|diag
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|partition
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|change
modifier|*
name|add_change
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|change
modifier|*
name|build_reverse_script
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|change
modifier|*
name|build_script
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|briefly_report
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|file_data
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compareseq
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|discard_confusing_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shift_boundaries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the midpoint of the shortest edit script for a specified    portion of the two files.     Scan from the beginnings of the files, and simultaneously from the ends,    doing a breadth-first search through the space of edit-sequence.    When the two searches meet, we have found the midpoint of the shortest    edit sequence.     If MINIMAL is nonzero, find the minimal edit script regardless    of expense.  Otherwise, if the search is too expensive, use    heuristics to stop the search and report a suboptimal answer.     Set PART->(XMID,YMID) to the midpoint (XMID,YMID).  The diagonal number    XMID - YMID equals the number of inserted lines minus the number    of deleted lines (counting only lines before the midpoint).    Return the approximate edit cost; this is the total number of    lines inserted or deleted (counting only lines before the midpoint),    unless a heuristic is used to terminate the search prematurely.     Set PART->LEFT_MINIMAL to nonzero iff the minimal edit script for the    left half of the partition is known; similarly for PART->RIGHT_MINIMAL.     This function assumes that the first lines of the specified portions    of the two files do not match, and likewise that the last lines do not    match.  The caller must trim matching lines from the beginning and end    of the portions it is going to specify.     If we return the "wrong" partitions,    the worst this can do is cause suboptimal diff output.    It cannot cause incorrect diff output.  */
end_comment

begin_function
specifier|static
name|int
name|diag
parameter_list|(
name|xoff
parameter_list|,
name|xlim
parameter_list|,
name|yoff
parameter_list|,
name|ylim
parameter_list|,
name|minimal
parameter_list|,
name|part
parameter_list|)
name|int
name|xoff
decl_stmt|,
name|xlim
decl_stmt|,
name|yoff
decl_stmt|,
name|ylim
decl_stmt|,
name|minimal
decl_stmt|;
name|struct
name|partition
modifier|*
name|part
decl_stmt|;
block|{
name|int
modifier|*
specifier|const
name|fd
init|=
name|fdiag
decl_stmt|;
comment|/* Give the compiler a chance. */
name|int
modifier|*
specifier|const
name|bd
init|=
name|bdiag
decl_stmt|;
comment|/* Additional help for the compiler. */
name|int
specifier|const
modifier|*
specifier|const
name|xv
init|=
name|xvec
decl_stmt|;
comment|/* Still more help for the compiler. */
name|int
specifier|const
modifier|*
specifier|const
name|yv
init|=
name|yvec
decl_stmt|;
comment|/* And more and more . . . */
name|int
specifier|const
name|dmin
init|=
name|xoff
operator|-
name|ylim
decl_stmt|;
comment|/* Minimum valid diagonal. */
name|int
specifier|const
name|dmax
init|=
name|xlim
operator|-
name|yoff
decl_stmt|;
comment|/* Maximum valid diagonal. */
name|int
specifier|const
name|fmid
init|=
name|xoff
operator|-
name|yoff
decl_stmt|;
comment|/* Center diagonal of top-down search. */
name|int
specifier|const
name|bmid
init|=
name|xlim
operator|-
name|ylim
decl_stmt|;
comment|/* Center diagonal of bottom-up search. */
name|int
name|fmin
init|=
name|fmid
decl_stmt|,
name|fmax
init|=
name|fmid
decl_stmt|;
comment|/* Limits of top-down search. */
name|int
name|bmin
init|=
name|bmid
decl_stmt|,
name|bmax
init|=
name|bmid
decl_stmt|;
comment|/* Limits of bottom-up search. */
name|int
name|c
decl_stmt|;
comment|/* Cost. */
name|int
name|odd
init|=
operator|(
name|fmid
operator|-
name|bmid
operator|)
operator|&
literal|1
decl_stmt|;
comment|/* True if southeast corner is on an odd 				   diagonal with respect to the northwest. */
name|fd
index|[
name|fmid
index|]
operator|=
name|xoff
expr_stmt|;
name|bd
index|[
name|bmid
index|]
operator|=
name|xlim
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
condition|;
operator|++
name|c
control|)
block|{
name|int
name|d
decl_stmt|;
comment|/* Active diagonal. */
name|int
name|big_snake
init|=
literal|0
decl_stmt|;
comment|/* Extend the top-down search by an edit step in each diagonal. */
name|fmin
operator|>
name|dmin
condition|?
name|fd
index|[
operator|--
name|fmin
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
else|:
operator|++
name|fmin
expr_stmt|;
name|fmax
operator|<
name|dmax
condition|?
name|fd
index|[
operator|++
name|fmax
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
else|:
operator|--
name|fmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|fd
index|[
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|fd
index|[
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|>=
name|thi
condition|)
name|x
operator|=
name|tlo
operator|+
literal|1
expr_stmt|;
else|else
name|x
operator|=
name|thi
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xlim
operator|&&
name|y
operator|<
name|ylim
operator|&&
name|xv
index|[
name|x
index|]
operator|==
name|yv
index|[
name|y
index|]
condition|)
operator|++
name|x
operator|,
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|-
name|oldx
operator|>
name|SNAKE_LIMIT
condition|)
name|big_snake
operator|=
literal|1
expr_stmt|;
name|fd
index|[
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|odd
operator|&&
name|bmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|bmax
operator|&&
name|bd
index|[
name|d
index|]
operator|<=
name|x
condition|)
block|{
name|part
operator|->
name|xmid
operator|=
name|x
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|y
expr_stmt|;
name|part
operator|->
name|lo_minimal
operator|=
name|part
operator|->
name|hi_minimal
operator|=
literal|1
expr_stmt|;
return|return
literal|2
operator|*
name|c
operator|-
literal|1
return|;
block|}
block|}
comment|/* Similarly extend the bottom-up search.  */
name|bmin
operator|>
name|dmin
condition|?
name|bd
index|[
operator|--
name|bmin
operator|-
literal|1
index|]
operator|=
name|INT_MAX
else|:
operator|++
name|bmin
expr_stmt|;
name|bmax
operator|<
name|dmax
condition|?
name|bd
index|[
operator|++
name|bmax
operator|+
literal|1
index|]
operator|=
name|INT_MAX
else|:
operator|--
name|bmax
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|oldx
decl_stmt|,
name|tlo
init|=
name|bd
index|[
name|d
operator|-
literal|1
index|]
decl_stmt|,
name|thi
init|=
name|bd
index|[
name|d
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tlo
operator|<
name|thi
condition|)
name|x
operator|=
name|tlo
expr_stmt|;
else|else
name|x
operator|=
name|thi
operator|-
literal|1
expr_stmt|;
name|oldx
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|d
expr_stmt|;
while|while
condition|(
name|x
operator|>
name|xoff
operator|&&
name|y
operator|>
name|yoff
operator|&&
name|xv
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|yv
index|[
name|y
operator|-
literal|1
index|]
condition|)
operator|--
name|x
operator|,
operator|--
name|y
expr_stmt|;
if|if
condition|(
name|oldx
operator|-
name|x
operator|>
name|SNAKE_LIMIT
condition|)
name|big_snake
operator|=
literal|1
expr_stmt|;
name|bd
index|[
name|d
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|odd
operator|&&
name|fmin
operator|<=
name|d
operator|&&
name|d
operator|<=
name|fmax
operator|&&
name|x
operator|<=
name|fd
index|[
name|d
index|]
condition|)
block|{
name|part
operator|->
name|xmid
operator|=
name|x
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|y
expr_stmt|;
name|part
operator|->
name|lo_minimal
operator|=
name|part
operator|->
name|hi_minimal
operator|=
literal|1
expr_stmt|;
return|return
literal|2
operator|*
name|c
return|;
block|}
block|}
if|if
condition|(
name|minimal
condition|)
continue|continue;
comment|/* Heuristic: check occasionally for a diagonal that has made 	 lots of progress compared with the edit distance. 	 If we have any such, find the one that has made the most 	 progress and return it as if it had succeeded.  	 With this heuristic, for files with a constant small density 	 of changes, the algorithm is linear in the file size.  */
if|if
condition|(
name|c
operator|>
literal|200
operator|&&
name|big_snake
operator|&&
name|heuristic
condition|)
block|{
name|int
name|best
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|fmid
decl_stmt|;
name|int
name|x
init|=
name|fd
index|[
name|d
index|]
decl_stmt|;
name|int
name|y
init|=
name|x
operator|-
name|d
decl_stmt|;
name|int
name|v
init|=
operator|(
name|x
operator|-
name|xoff
operator|)
operator|*
literal|2
operator|-
name|dd
decl_stmt|;
if|if
condition|(
name|v
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|<
literal|0
condition|?
operator|-
name|dd
else|:
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|>
name|best
operator|&&
name|xoff
operator|+
name|SNAKE_LIMIT
operator|<=
name|x
operator|&&
name|x
operator|<
name|xlim
operator|&&
name|yoff
operator|+
name|SNAKE_LIMIT
operator|<=
name|y
operator|&&
name|y
operator|<
name|ylim
condition|)
block|{
comment|/* We have a good enough best diagonal; 			 now insist that it end with a significant snake.  */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|xv
index|[
name|x
operator|-
name|k
index|]
operator|==
name|yv
index|[
name|y
operator|-
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|SNAKE_LIMIT
condition|)
block|{
name|best
operator|=
name|v
expr_stmt|;
name|part
operator|->
name|xmid
operator|=
name|x
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|y
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|part
operator|->
name|lo_minimal
operator|=
literal|1
expr_stmt|;
name|part
operator|->
name|hi_minimal
operator|=
literal|0
expr_stmt|;
return|return
literal|2
operator|*
name|c
operator|-
literal|1
return|;
block|}
name|best
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|dd
init|=
name|d
operator|-
name|bmid
decl_stmt|;
name|int
name|x
init|=
name|bd
index|[
name|d
index|]
decl_stmt|;
name|int
name|y
init|=
name|x
operator|-
name|d
decl_stmt|;
name|int
name|v
init|=
operator|(
name|xlim
operator|-
name|x
operator|)
operator|*
literal|2
operator|+
name|dd
decl_stmt|;
if|if
condition|(
name|v
operator|>
literal|12
operator|*
operator|(
name|c
operator|+
operator|(
name|dd
operator|<
literal|0
condition|?
operator|-
name|dd
else|:
name|dd
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|>
name|best
operator|&&
name|xoff
operator|<
name|x
operator|&&
name|x
operator|<=
name|xlim
operator|-
name|SNAKE_LIMIT
operator|&&
name|yoff
operator|<
name|y
operator|&&
name|y
operator|<=
name|ylim
operator|-
name|SNAKE_LIMIT
condition|)
block|{
comment|/* We have a good enough best diagonal; 			 now insist that it end with a significant snake.  */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|xv
index|[
name|x
operator|+
name|k
index|]
operator|==
name|yv
index|[
name|y
operator|+
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|SNAKE_LIMIT
operator|-
literal|1
condition|)
block|{
name|best
operator|=
name|v
expr_stmt|;
name|part
operator|->
name|xmid
operator|=
name|x
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|y
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|best
operator|>
literal|0
condition|)
block|{
name|part
operator|->
name|lo_minimal
operator|=
literal|0
expr_stmt|;
name|part
operator|->
name|hi_minimal
operator|=
literal|1
expr_stmt|;
return|return
literal|2
operator|*
name|c
operator|-
literal|1
return|;
block|}
block|}
comment|/* Heuristic: if we've gone well beyond the call of duty, 	 give up and report halfway between our best results so far.  */
if|if
condition|(
name|c
operator|>=
name|too_expensive
condition|)
block|{
name|int
name|fxybest
decl_stmt|,
name|fxbest
decl_stmt|;
name|int
name|bxybest
decl_stmt|,
name|bxbest
decl_stmt|;
name|fxbest
operator|=
name|bxbest
operator|=
literal|0
expr_stmt|;
comment|/* Pacify `gcc -Wall'.  */
comment|/* Find forward diagonal that maximizes X + Y.  */
name|fxybest
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|d
operator|=
name|fmax
init|;
name|d
operator|>=
name|fmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
init|=
name|min
argument_list|(
name|fd
index|[
name|d
index|]
argument_list|,
name|xlim
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|x
operator|-
name|d
decl_stmt|;
if|if
condition|(
name|ylim
operator|<
name|y
condition|)
name|x
operator|=
name|ylim
operator|+
name|d
operator|,
name|y
operator|=
name|ylim
expr_stmt|;
if|if
condition|(
name|fxybest
operator|<
name|x
operator|+
name|y
condition|)
block|{
name|fxybest
operator|=
name|x
operator|+
name|y
expr_stmt|;
name|fxbest
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* Find backward diagonal that minimizes X + Y.  */
name|bxybest
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bmax
init|;
name|d
operator|>=
name|bmin
condition|;
name|d
operator|-=
literal|2
control|)
block|{
name|int
name|x
init|=
name|max
argument_list|(
name|xoff
argument_list|,
name|bd
index|[
name|d
index|]
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|x
operator|-
name|d
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|yoff
condition|)
name|x
operator|=
name|yoff
operator|+
name|d
operator|,
name|y
operator|=
name|yoff
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|y
operator|<
name|bxybest
condition|)
block|{
name|bxybest
operator|=
name|x
operator|+
name|y
expr_stmt|;
name|bxbest
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* Use the better of the two diagonals.  */
if|if
condition|(
operator|(
name|xlim
operator|+
name|ylim
operator|)
operator|-
name|bxybest
operator|<
name|fxybest
operator|-
operator|(
name|xoff
operator|+
name|yoff
operator|)
condition|)
block|{
name|part
operator|->
name|xmid
operator|=
name|fxbest
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|fxybest
operator|-
name|fxbest
expr_stmt|;
name|part
operator|->
name|lo_minimal
operator|=
literal|1
expr_stmt|;
name|part
operator|->
name|hi_minimal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|part
operator|->
name|xmid
operator|=
name|bxbest
expr_stmt|;
name|part
operator|->
name|ymid
operator|=
name|bxybest
operator|-
name|bxbest
expr_stmt|;
name|part
operator|->
name|lo_minimal
operator|=
literal|0
expr_stmt|;
name|part
operator|->
name|hi_minimal
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|2
operator|*
name|c
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare in detail contiguous subsequences of the two files    which are known, as a whole, to match each other.     The results are recorded in the vectors files[N].changed_flag, by    storing a 1 in the element for each line that is an insertion or deletion.     The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.     Note that XLIM, YLIM are exclusive bounds.    All line numbers are origin-0 and discarded lines are not counted.      If MINIMAL is nonzero, find a minimal difference no matter how    expensive it is.  */
end_comment

begin_function
specifier|static
name|void
name|compareseq
parameter_list|(
name|xoff
parameter_list|,
name|xlim
parameter_list|,
name|yoff
parameter_list|,
name|ylim
parameter_list|,
name|minimal
parameter_list|)
name|int
name|xoff
decl_stmt|,
name|xlim
decl_stmt|,
name|yoff
decl_stmt|,
name|ylim
decl_stmt|,
name|minimal
decl_stmt|;
block|{
name|int
modifier|*
specifier|const
name|xv
init|=
name|xvec
decl_stmt|;
comment|/* Help the compiler.  */
name|int
modifier|*
specifier|const
name|yv
init|=
name|yvec
decl_stmt|;
comment|/* Slide down the bottom initial diagonal. */
while|while
condition|(
name|xoff
operator|<
name|xlim
operator|&&
name|yoff
operator|<
name|ylim
operator|&&
name|xv
index|[
name|xoff
index|]
operator|==
name|yv
index|[
name|yoff
index|]
condition|)
operator|++
name|xoff
operator|,
operator|++
name|yoff
expr_stmt|;
comment|/* Slide up the top initial diagonal. */
while|while
condition|(
name|xlim
operator|>
name|xoff
operator|&&
name|ylim
operator|>
name|yoff
operator|&&
name|xv
index|[
name|xlim
operator|-
literal|1
index|]
operator|==
name|yv
index|[
name|ylim
operator|-
literal|1
index|]
condition|)
operator|--
name|xlim
operator|,
operator|--
name|ylim
expr_stmt|;
comment|/* Handle simple cases. */
if|if
condition|(
name|xoff
operator|==
name|xlim
condition|)
while|while
condition|(
name|yoff
operator|<
name|ylim
condition|)
name|files
index|[
literal|1
index|]
operator|.
name|changed_flag
index|[
name|files
index|[
literal|1
index|]
operator|.
name|realindexes
index|[
name|yoff
operator|++
index|]
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yoff
operator|==
name|ylim
condition|)
while|while
condition|(
name|xoff
operator|<
name|xlim
condition|)
name|files
index|[
literal|0
index|]
operator|.
name|changed_flag
index|[
name|files
index|[
literal|0
index|]
operator|.
name|realindexes
index|[
name|xoff
operator|++
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|c
decl_stmt|;
name|struct
name|partition
name|part
decl_stmt|;
comment|/* Find a point of correspondence in the middle of the files.  */
name|c
operator|=
name|diag
argument_list|(
name|xoff
argument_list|,
name|xlim
argument_list|,
name|yoff
argument_list|,
name|ylim
argument_list|,
name|minimal
argument_list|,
operator|&
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
block|{
comment|/* This should be impossible, because it implies that 	     one of the two subsequences is empty, 	     and that case was handled above without calling `diag'. 	     Let's verify that this is true.  */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The two subsequences differ by a single insert or delete; 	     record it and we are done.  */
block|if (part.xmid - part.ymid< xoff - yoff) 	    files[1].changed_flag[files[1].realindexes[part.ymid - 1]] = 1; 	  else 	    files[0].changed_flag[files[0].realindexes[part.xmid]] = 1;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Use the partitions to split this problem into subproblems.  */
name|compareseq
argument_list|(
name|xoff
argument_list|,
name|part
operator|.
name|xmid
argument_list|,
name|yoff
argument_list|,
name|part
operator|.
name|ymid
argument_list|,
name|part
operator|.
name|lo_minimal
argument_list|)
expr_stmt|;
name|compareseq
argument_list|(
name|part
operator|.
name|xmid
argument_list|,
name|xlim
argument_list|,
name|part
operator|.
name|ymid
argument_list|,
name|ylim
argument_list|,
name|part
operator|.
name|hi_minimal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Discard lines from one file that have no matches in the other file.     A line which is discarded will not be considered by the actual    comparison algorithm; it will be as if that line were not in the file.    The file's `realindexes' table maps virtual line numbers    (which don't count the discarded lines) into real line numbers;    this is how the actual comparison algorithm produces results    that are comprehensible when the discarded lines are counted.     When we discard a line, we also mark it as a deletion or insertion    so that it will be printed in the output.  */
end_comment

begin_function
specifier|static
name|void
name|discard_confusing_lines
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|discarded
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|equiv_count
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
comment|/* Allocate our results.  */
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|)
operator|*
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|filevec
index|[
name|f
index|]
operator|.
name|undiscarded
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|realindexes
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
expr_stmt|;
block|}
comment|/* Set up equiv_count[F][I] as the number of lines in file F      that fall in equivalence class I.  */
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|*
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|equiv_count
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
name|equiv_count
index|[
literal|1
index|]
operator|=
name|p
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|*
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
condition|;
operator|++
name|i
control|)
operator|++
name|equiv_count
index|[
literal|0
index|]
index|[
name|filevec
index|[
literal|0
index|]
operator|.
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
condition|;
operator|++
name|i
control|)
operator|++
name|equiv_count
index|[
literal|1
index|]
index|[
name|filevec
index|[
literal|1
index|]
operator|.
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* Set up tables of which lines are going to be discarded.  */
name|discarded
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|)
argument_list|)
expr_stmt|;
name|discarded
index|[
literal|1
index|]
operator|=
name|discarded
index|[
literal|0
index|]
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
expr_stmt|;
name|bzero
argument_list|(
name|discarded
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark to be discarded each line that matches no line of the other file.      If a line matches many lines, mark it as provisionally discardable.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
name|int
modifier|*
name|counts
init|=
name|equiv_count
index|[
literal|1
operator|-
name|f
index|]
decl_stmt|;
name|int
modifier|*
name|equivs
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|equivs
decl_stmt|;
name|unsigned
name|int
name|many
init|=
literal|5
decl_stmt|;
name|unsigned
name|int
name|tem
init|=
name|end
operator|/
literal|64
decl_stmt|;
comment|/* Multiply MANY by approximate square root of number of lines. 	 That is the threshold for provisionally discardable lines.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|many
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nmatch
decl_stmt|;
if|if
condition|(
name|equivs
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|nmatch
operator|=
name|counts
index|[
name|equivs
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nmatch
operator|==
literal|0
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nmatch
operator|>
name|many
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Don't really discard the provisional lines except when they occur      in a run of discardables, with nonprovisionals at the beginning      and end.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
specifier|register
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
comment|/* Cancel provisional discards not in middle of run of discards.  */
if|if
condition|(
name|discards
index|[
name|i
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We have found a nonprovisional discard.  */
specifier|register
name|int
name|j
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|provisional
init|=
literal|0
decl_stmt|;
comment|/* Find end of this run of discardable lines. 		 Count how many are provisionally discardable.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|j
index|]
operator|==
literal|2
condition|)
operator|++
name|provisional
expr_stmt|;
block|}
comment|/* Cancel provisional discards at end, and shrink the run.  */
while|while
condition|(
name|j
operator|>
name|i
operator|&&
name|discards
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|2
condition|)
name|discards
index|[
operator|--
name|j
index|]
operator|=
literal|0
operator|,
operator|--
name|provisional
expr_stmt|;
comment|/* Now we have the length of a run of discardable lines 		 whose first and last are not provisional.  */
name|length
operator|=
name|j
operator|-
name|i
expr_stmt|;
comment|/* If 1/4 of the lines in the run are provisional, 		 cancel discarding of all provisional lines in the run.  */
if|if
condition|(
name|provisional
operator|*
literal|4
operator|>
name|length
condition|)
block|{
while|while
condition|(
name|j
operator|>
name|i
condition|)
if|if
condition|(
name|discards
index|[
operator|--
name|j
index|]
operator|==
literal|2
condition|)
name|discards
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|unsigned
name|int
name|consec
decl_stmt|;
name|unsigned
name|int
name|minimum
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|tem
init|=
name|length
operator|/
literal|4
decl_stmt|;
comment|/* MINIMUM is approximate square root of LENGTH/4. 		     A subrun of two or more provisionals can stand 		     when LENGTH is at least 16. 		     A subrun of 4 or more can stand when LENGTH>= 64.  */
while|while
condition|(
operator|(
name|tem
operator|=
name|tem
operator|>>
literal|2
operator|)
operator|>
literal|0
condition|)
name|minimum
operator|*=
literal|2
expr_stmt|;
name|minimum
operator|++
expr_stmt|;
comment|/* Cancel any subrun of MINIMUM or more provisionals 		     within the larger run.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|2
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|minimum
operator|==
operator|++
name|consec
condition|)
comment|/* Back up to start of subrun, to cancel it all.  */
name|j
operator|-=
name|consec
expr_stmt|;
elseif|else
if|if
condition|(
name|minimum
operator|<
name|consec
condition|)
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Scan from beginning of run 		     until we find 3 or more nonprovisionals in a row 		     or until the first nonprovisional at least 8 lines in. 		     Until that point, cancel any provisionals.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|2
condition|)
name|consec
operator|=
literal|0
operator|,
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
operator|+
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
comment|/* I advances to the last line of the run.  */
name|i
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
comment|/* Same thing, from end.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|consec
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|8
operator|&&
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|2
condition|)
name|consec
operator|=
literal|0
operator|,
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|discards
index|[
name|i
operator|-
name|j
index|]
operator|==
literal|0
condition|)
name|consec
operator|=
literal|0
expr_stmt|;
else|else
name|consec
operator|++
expr_stmt|;
if|if
condition|(
name|consec
operator|==
literal|3
condition|)
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Actually discard the lines. */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|char
modifier|*
name|discards
init|=
name|discarded
index|[
name|f
index|]
decl_stmt|;
name|unsigned
name|int
name|end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|no_discards
operator|||
name|discards
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|filevec
index|[
name|f
index|]
operator|.
name|undiscarded
index|[
name|j
index|]
operator|=
name|filevec
index|[
name|f
index|]
operator|.
name|equivs
index|[
name|i
index|]
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|realindexes
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|filevec
index|[
name|f
index|]
operator|.
name|changed_flag
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|filevec
index|[
name|f
index|]
operator|.
name|nondiscarded_lines
operator|=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|discarded
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|equiv_count
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust inserts/deletes of identical lines to join changes    as much as possible.     We do something when a run of changed lines include a    line at one end and have an excluded, identical line at the other.    We are free to choose which identical line is included.    `compareseq' usually chooses the one at the beginning,    but usually it is cleaner to consider the following identical line    to be the "change".  */
end_comment

begin_decl_stmt
name|int
name|inhibit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|shift_boundaries
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
name|inhibit
condition|)
return|return;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|char
modifier|*
name|changed
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
specifier|const
modifier|*
name|other_changed
init|=
name|filevec
index|[
literal|1
operator|-
name|f
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
specifier|const
modifier|*
name|equivs
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|equivs
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|i_end
init|=
name|filevec
index|[
name|f
index|]
operator|.
name|buffered_lines
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|runlength
decl_stmt|,
name|start
decl_stmt|,
name|corresponding
decl_stmt|;
comment|/* Scan forwards to find beginning of another run of changes. 	     Also keep track of the corresponding point in the other file.  */
while|while
condition|(
name|i
operator|<
name|i_end
operator|&&
name|changed
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|other_changed
index|[
name|j
operator|++
index|]
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|i_end
condition|)
break|break;
name|start
operator|=
name|i
expr_stmt|;
comment|/* Find the end of this run of changes.  */
while|while
condition|(
name|changed
index|[
operator|++
name|i
index|]
condition|)
continue|continue;
while|while
condition|(
name|other_changed
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
do|do
block|{
comment|/* Record the length of this run of changes, so that 		 we can later determine whether the run has grown.  */
name|runlength
operator|=
name|i
operator|-
name|start
expr_stmt|;
comment|/* Move the changed region back, so long as the 		 previous unchanged line matches the last changed one. 		 This merges with previous changed regions.  */
while|while
condition|(
name|start
operator|&&
name|equivs
index|[
name|start
operator|-
literal|1
index|]
operator|==
name|equivs
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|changed
index|[
operator|--
name|start
index|]
operator|=
literal|1
expr_stmt|;
name|changed
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|changed
index|[
name|start
operator|-
literal|1
index|]
condition|)
name|start
operator|--
expr_stmt|;
while|while
condition|(
name|other_changed
index|[
operator|--
name|j
index|]
condition|)
continue|continue;
block|}
comment|/* Set CORRESPONDING to the end of the changed run, at the last 		 point where it corresponds to a changed run in the other file. 		 CORRESPONDING == I_END means no such point has been found.  */
name|corresponding
operator|=
name|other_changed
index|[
name|j
operator|-
literal|1
index|]
condition|?
name|i
else|:
name|i_end
expr_stmt|;
comment|/* Move the changed region forward, so long as the 		 first changed line matches the following unchanged one. 		 This merges with following changed regions. 		 Do this second, so that if there are no merges, 		 the changed region is moved forward as far as possible.  */
while|while
condition|(
name|i
operator|!=
name|i_end
operator|&&
name|equivs
index|[
name|start
index|]
operator|==
name|equivs
index|[
name|i
index|]
condition|)
block|{
name|changed
index|[
name|start
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|changed
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|other_changed
index|[
operator|++
name|j
index|]
condition|)
name|corresponding
operator|=
name|i
expr_stmt|;
block|}
block|}
do|while
condition|(
name|runlength
operator|!=
name|i
operator|-
name|start
condition|)
do|;
comment|/* If possible, move the fully-merged run of changes 	     back to a corresponding run in the other file.  */
while|while
condition|(
name|corresponding
operator|<
name|i
condition|)
block|{
name|changed
index|[
operator|--
name|start
index|]
operator|=
literal|1
expr_stmt|;
name|changed
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|other_changed
index|[
operator|--
name|j
index|]
condition|)
continue|continue;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cons an additional entry onto the front of an edit script OLD.    LINE0 and LINE1 are the first affected lines in the two files (origin 0).    DELETED is the number of lines deleted here from file 0.    INSERTED is the number of lines inserted here in file 1.     If DELETED is 0 then LINE0 is the number of the line before    which the insertion was done; vice versa for INSERTED and LINE1.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|add_change
parameter_list|(
name|line0
parameter_list|,
name|line1
parameter_list|,
name|deleted
parameter_list|,
name|inserted
parameter_list|,
name|old
parameter_list|)
name|int
name|line0
decl_stmt|,
name|line1
decl_stmt|,
name|deleted
decl_stmt|,
name|inserted
decl_stmt|;
name|struct
name|change
modifier|*
name|old
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|new
init|=
operator|(
expr|struct
name|change
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|change
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|line0
operator|=
name|line0
expr_stmt|;
name|new
operator|->
name|line1
operator|=
name|line1
expr_stmt|;
name|new
operator|->
name|inserted
operator|=
name|inserted
expr_stmt|;
name|new
operator|->
name|deleted
operator|=
name|deleted
expr_stmt|;
name|new
operator|->
name|link
operator|=
name|old
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Scan the tables of which lines are inserted and deleted,    producing an edit script in reverse order.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|build_reverse_script
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
specifier|const
name|filevec
index|[]
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|script
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|changed0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
modifier|*
name|changed1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
name|len0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
decl_stmt|;
name|int
name|len1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
decl_stmt|;
comment|/* Note that changedN[len0] does exist, and contains 0.  */
name|int
name|i0
init|=
literal|0
decl_stmt|,
name|i1
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i0
operator|<
name|len0
operator|||
name|i1
operator|<
name|len1
condition|)
block|{
if|if
condition|(
name|changed0
index|[
name|i0
index|]
operator|||
name|changed1
index|[
name|i1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
name|i0
index|]
condition|)
operator|++
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
name|i1
index|]
condition|)
operator|++
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
name|add_change
argument_list|(
name|line0
argument_list|,
name|line1
argument_list|,
name|i0
operator|-
name|line0
argument_list|,
name|i1
operator|-
name|line1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|++
operator|,
name|i1
operator|++
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
end_function

begin_comment
comment|/* Scan the tables of which lines are inserted and deleted,    producing an edit script in forward order.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|build_script
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
specifier|const
name|filevec
index|[]
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|script
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|changed0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
decl_stmt|;
name|char
modifier|*
name|changed1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
decl_stmt|;
name|int
name|i0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
decl_stmt|,
name|i1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
decl_stmt|;
comment|/* Note that changedN[-1] does exist, and contains 0.  */
while|while
condition|(
name|i0
operator|>=
literal|0
operator|||
name|i1
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|changed0
index|[
name|i0
operator|-
literal|1
index|]
operator|||
name|changed1
index|[
name|i1
operator|-
literal|1
index|]
condition|)
block|{
name|int
name|line0
init|=
name|i0
decl_stmt|,
name|line1
init|=
name|i1
decl_stmt|;
comment|/* Find # lines changed here in each file.  */
while|while
condition|(
name|changed0
index|[
name|i0
operator|-
literal|1
index|]
condition|)
operator|--
name|i0
expr_stmt|;
while|while
condition|(
name|changed1
index|[
name|i1
operator|-
literal|1
index|]
condition|)
operator|--
name|i1
expr_stmt|;
comment|/* Record this change.  */
name|script
operator|=
name|add_change
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|,
name|line0
operator|-
name|i0
argument_list|,
name|line1
operator|-
name|i1
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
comment|/* We have reached lines in the two files that match each other.  */
name|i0
operator|--
operator|,
name|i1
operator|--
expr_stmt|;
block|}
return|return
name|script
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If CHANGES, briefly report that two files differed.  */
end_comment

begin_function
specifier|static
name|void
name|briefly_report
parameter_list|(
name|changes
parameter_list|,
name|filevec
parameter_list|)
name|int
name|changes
decl_stmt|;
name|struct
name|file_data
specifier|const
name|filevec
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|changes
condition|)
name|message
argument_list|(
name|no_details_flag
condition|?
literal|"Files %s and %s differ\n"
else|:
literal|"Binary files %s and %s differ\n"
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report the differences of two files.  DEPTH is the current directory    depth. */
end_comment

begin_function
name|int
name|diff_2_files
parameter_list|(
name|filevec
parameter_list|,
name|depth
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|int
name|diags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|change
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|change
modifier|*
name|script
decl_stmt|;
name|int
name|changes
decl_stmt|;
comment|/* If we have detected that either file is binary,      compare the two files as binary.  This can happen      only when the first chunk is read.      Also, --brief without any --ignore-* options means      we can speed things up by treating the files as binary.  */
if|if
condition|(
name|read_files
argument_list|(
name|filevec
argument_list|,
name|no_details_flag
operator|&
operator|~
name|ignore_some_changes
argument_list|)
condition|)
block|{
comment|/* Files with different lengths must be different.  */
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_size
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_size
operator|&&
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|<
literal|0
operator|||
name|S_ISREG
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
operator|<
literal|0
operator|||
name|S_ISREG
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|changes
operator|=
literal|1
expr_stmt|;
comment|/* Standard input equals itself.  */
elseif|else
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
condition|)
name|changes
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Scan both files, a buffer at a time, looking for a difference.  */
block|{
comment|/* Allocate same-sized buffers for both files.  */
name|size_t
name|buffer_size
init|=
name|buffer_lcm
argument_list|(
name|STAT_BLOCKSIZE
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|stat
argument_list|)
argument_list|,
name|STAT_BLOCKSIZE
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|xrealloc
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|=
literal|0
control|)
block|{
comment|/* Read a buffer's worth from both files.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|<=
name|filevec
index|[
name|i
index|]
operator|.
name|desc
condition|)
while|while
condition|(
name|filevec
index|[
name|i
index|]
operator|.
name|buffered_chars
operator|!=
name|buffer_size
condition|)
block|{
name|int
name|r
init|=
name|read
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|filevec
index|[
name|i
index|]
operator|.
name|buffer
operator|+
name|filevec
index|[
name|i
index|]
operator|.
name|buffered_chars
argument_list|,
name|buffer_size
operator|-
name|filevec
index|[
name|i
index|]
operator|.
name|buffered_chars
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|filevec
index|[
name|i
index|]
operator|.
name|buffered_chars
operator|+=
name|r
expr_stmt|;
block|}
comment|/* If the buffers differ, the files differ.  */
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|||
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|!=
literal|0
operator|&&
name|memcmp
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|changes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If we reach end of file, the files are the same.  */
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|!=
name|buffer_size
condition|)
block|{
name|changes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|briefly_report
argument_list|(
name|changes
argument_list|,
name|filevec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate vectors for the results of comparison: 	 a flag for each line of each file, saying whether that line 	 is an insertion or deletion. 	 Allocate an extra element, always zero, at each end of each vector.  */
name|size_t
name|s
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|+
literal|4
decl_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|=
name|xmalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|++
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|changed_flag
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
literal|2
expr_stmt|;
comment|/* Some lines are obviously insertions or deletions 	 because they don't match anything.  Detect them now, and 	 avoid even thinking about them in the main comparison algorithm.  */
name|discard_confusing_lines
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* Now do the main comparison algorithm, considering just the 	 undiscarded lines.  */
name|xvec
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|undiscarded
expr_stmt|;
name|yvec
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|undiscarded
expr_stmt|;
name|diags
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|3
expr_stmt|;
name|fdiag
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|diags
operator|*
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bdiag
operator|=
name|fdiag
operator|+
name|diags
expr_stmt|;
name|fdiag
operator|+=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
name|bdiag
operator|+=
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
expr_stmt|;
comment|/* Set TOO_EXPENSIVE to be approximate square root of input size, 	 bounded below by 256.  */
name|too_expensive
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|>>=
literal|2
control|)
name|too_expensive
operator|<<=
literal|1
expr_stmt|;
name|too_expensive
operator|=
name|max
argument_list|(
literal|256
argument_list|,
name|too_expensive
argument_list|)
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|=
name|filevec
index|[
literal|0
index|]
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|=
name|filevec
index|[
literal|1
index|]
expr_stmt|;
name|compareseq
argument_list|(
literal|0
argument_list|,
name|filevec
index|[
literal|0
index|]
operator|.
name|nondiscarded_lines
argument_list|,
literal|0
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
argument_list|,
name|no_discards
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fdiag
operator|-
operator|(
name|filevec
index|[
literal|1
index|]
operator|.
name|nondiscarded_lines
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Modify the results slightly to make them prettier 	 in cases where that can validly be done.  */
name|shift_boundaries
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* Get the results of comparison in the form of a chain 	 of `struct change's -- an edit script.  */
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_ED
condition|)
name|script
operator|=
name|build_reverse_script
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
else|else
name|script
operator|=
name|build_script
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
comment|/* Set CHANGES if we had any diffs. 	 If some changes are ignored, we must scan the script to decide.  */
if|if
condition|(
name|ignore_blank_lines_flag
operator|||
name|ignore_regexp_list
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
decl_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|changes
operator|==
literal|0
condition|)
block|{
name|struct
name|change
modifier|*
name|this
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
comment|/* Find a set of changes that belong together.  */
name|this
operator|=
name|next
expr_stmt|;
name|end
operator|=
name|find_change
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Disconnect them from the rest of the changes, making them 		 a hunk, and remember the rest for next iteration.  */
name|next
operator|=
name|end
operator|->
name|link
expr_stmt|;
name|end
operator|->
name|link
operator|=
literal|0
expr_stmt|;
comment|/* Determine whether this hunk is really a difference.  */
name|analyze_hunk
argument_list|(
name|this
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
comment|/* Reconnect the script so it will all be freed properly.  */
name|end
operator|->
name|link
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|deletes
operator|||
name|inserts
condition|)
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|changes
operator|=
operator|(
name|script
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|no_details_flag
condition|)
name|briefly_report
argument_list|(
name|changes
argument_list|,
name|filevec
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|changes
operator|||
operator|!
name|no_diff_means_no_output
condition|)
block|{
comment|/* Record info for starting up output, 		 to be used if and when we have some output to print.  */
name|setup_output
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|depth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|output_style
condition|)
block|{
case|case
name|OUTPUT_CONTEXT
case|:
name|print_context_script
argument_list|(
name|script
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_UNIFIED
case|:
name|print_context_script
argument_list|(
name|script
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_ED
case|:
name|print_ed_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_FORWARD_ED
case|:
name|pr_forward_ed_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_RCS
case|:
name|print_rcs_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_NORMAL
case|:
name|print_normal_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_IFDEF
case|:
name|print_ifdef_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_SDIFF
case|:
name|print_sdiff_script
argument_list|(
name|script
argument_list|)
expr_stmt|;
block|}
name|finish_output
argument_list|()
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|undiscarded
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|changed_flag
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|equivs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|linbuf
operator|+
name|filevec
index|[
name|i
index|]
operator|.
name|linbuf_base
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|script
init|;
name|e
condition|;
name|e
operator|=
name|p
control|)
block|{
name|p
operator|=
name|e
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|filevec
index|[
name|i
index|]
operator|.
name|missing_newline
condition|)
block|{
name|diff_error
argument_list|(
literal|"No newline at end of file %s"
argument_list|,
name|filevec
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|changes
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
condition|)
name|free
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
name|changes
return|;
block|}
end_function

end_unit

