begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|find_type
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logfile_write
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|filter
operator|,
specifier|const
name|char
operator|*
name|message
operator|,
name|FILE
operator|*
name|logfp
operator|,
name|List
operator|*
name|changes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcsinfo_proc
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|template
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|title_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_logfile_proc
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_tmpfile
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|xfp
operator|,
name|char
operator|*
name|xprefix
operator|,
name|List
operator|*
name|changes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|editinfo_proc
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|template
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verifymsg_proc
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|script
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|str_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|str_list_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format for str_list's contents. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|editinfo_editor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|verifymsg_script
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ctype
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Should the logmsg be re-read during the do_verify phase?  * RereadLogAfterVerify=no|stat|yes  * LOGMSG_REREAD_NEVER  - never re-read the logmsg  * LOGMSG_REREAD_STAT   - re-read the logmsg only if it has changed  * LOGMSG_REREAD_ALWAYS - always re-read the logmsg  */
end_comment

begin_decl_stmt
name|int
name|RereadLogAfterVerify
init|=
name|LOGMSG_REREAD_ALWAYS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Puts a standard header on the output which is either being prepared for an  * editor session, or being sent to a logfile program.  The modified, added,  * and removed files are included (if any) and formatted to look pretty. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_tmpfile
parameter_list|(
name|xfp
parameter_list|,
name|xprefix
parameter_list|,
name|changes
parameter_list|)
name|FILE
modifier|*
name|xfp
decl_stmt|;
name|char
modifier|*
name|xprefix
decl_stmt|;
name|List
modifier|*
name|changes
decl_stmt|;
block|{
comment|/* set up statics */
name|fp
operator|=
name|xfp
expr_stmt|;
name|prefix
operator|=
name|xprefix
expr_stmt|;
name|type
operator|=
name|T_MODIFIED
expr_stmt|;
if|if
condition|(
name|walklist
argument_list|(
name|changes
argument_list|,
name|find_type
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sModified Files:\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|fmt_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|type
operator|=
name|T_ADDED
expr_stmt|;
if|if
condition|(
name|walklist
argument_list|(
name|changes
argument_list|,
name|find_type
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sAdded Files:\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|fmt_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|type
operator|=
name|T_REMOVED
expr_stmt|;
if|if
condition|(
name|walklist
argument_list|(
name|changes
argument_list|,
name|find_type
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sRemoved Files:\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|fmt_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Looks for nodes of a specified type and returns 1 if found  */
end_comment

begin_function
specifier|static
name|int
name|find_type
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|logfile_info
modifier|*
name|li
init|=
name|p
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Breaks the files list into reasonable sized lines to avoid line wrap...  * all in the name of pretty output.  It only works on nodes whose types  * match the one we're looking for  */
end_comment

begin_function
specifier|static
name|int
name|fmt_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
name|li
operator|=
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|tag
operator|==
name|NULL
condition|?
name|tag
operator|!=
name|NULL
else|:
name|tag
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|tag
argument_list|,
name|li
operator|->
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|col
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|prefix
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|col
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|col
operator|<
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|col
expr_stmt|;
block|}
if|if
condition|(
name|li
operator|->
name|tag
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No tag"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Tag: %s"
argument_list|,
name|li
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|li
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* Force a new line.  */
name|col
operator|=
literal|70
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|>
literal|8
operator|&&
operator|(
name|col
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|)
operator|>
literal|70
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s\t"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Builds a temporary file using setup_tmpfile() and invokes the user's  * editor on the file.  The header garbage in the resultant file is then  * stripped and the log message is stored in the "message" argument.  *   * If REPOSITORY is non-NULL, process rcsinfo for that repository; if it  * is NULL, use the CVSADM_TEMPLATE file instead.  REPOSITORY should be  * NULL when running in client mode.  */
end_comment

begin_function
name|void
name|do_editor
parameter_list|(
name|dir
parameter_list|,
name|messagep
parameter_list|,
name|repository
parameter_list|,
name|changes
parameter_list|)
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|messagep
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|changes
decl_stmt|;
block|{
specifier|static
name|int
name|reuse_log_message
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|stat
name|pre_stbuf
decl_stmt|,
name|post_stbuf
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|assert
argument_list|(
operator|!
name|current_parsed_root
operator|->
name|isremote
operator|!=
operator|!
name|repository
argument_list|)
expr_stmt|;
else|#
directive|else
name|assert
argument_list|(
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
operator|||
name|reuse_log_message
condition|)
return|return;
comment|/* Abort creation of temp file if no editor is defined */
if|if
condition|(
name|strcmp
argument_list|(
name|Editor
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|editinfo_editor
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no editor defined, must use -e or -m"
argument_list|)
expr_stmt|;
comment|/* Create a temporary file */
comment|/* FIXME - It's possible we should be relying on cvs_temp_file to open      * the file here - we get race conditions otherwise.      */
name|fname
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fname
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|messagep
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
operator|*
name|messagep
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|messagep
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|messagep
operator|)
index|[
name|strlen
argument_list|(
operator|*
name|messagep
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|!=
name|NULL
condition|)
comment|/* tack templates on if necessary */
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_RCSINFO
argument_list|,
name|repository
argument_list|,
name|rcsinfo_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|size_t
name|nwrite
decl_stmt|;
comment|/* Why "b"?  */
name|tfp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_TEMPLATE
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_TEMPLATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|tfp
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|nwrite
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|nwrite
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|nwrite
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|nwrite
operator|-=
name|n
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|tfp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_TEMPLATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|tfp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_TEMPLATE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s----------------------------------------------------------------------\n"
argument_list|,
name|CVSEDITPREFIX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sEnter Log.  Lines beginning with `%.*s' are removed automatically\n%s\n"
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|CVSEDITPREFIXLEN
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|CVSEDITPREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
operator|&&
operator|*
name|dir
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sCommitting in %s\n%s\n"
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|dir
argument_list|,
name|CVSEDITPREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|!=
name|NULL
condition|)
name|setup_tmpfile
argument_list|(
name|fp
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|changes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s----------------------------------------------------------------------\n"
argument_list|,
name|CVSEDITPREFIX
argument_list|)
expr_stmt|;
comment|/* finish off the temp file */
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|fname
argument_list|,
operator|&
name|pre_stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|pre_stbuf
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|editinfo_editor
condition|)
name|free
argument_list|(
name|editinfo_editor
argument_list|)
expr_stmt|;
name|editinfo_editor
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
empty_stmt|;
comment|/* nothing, leave editinfo_editor NULL */
elseif|else
endif|#
directive|endif
if|if
condition|(
name|repository
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_EDITINFO
argument_list|,
name|repository
argument_list|,
name|editinfo_proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* run the editor */
name|run_setup
argument_list|(
name|editinfo_editor
condition|?
name|editinfo_editor
else|:
name|Editor
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_SIGIGNORE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|editinfo_editor
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
name|editinfo_editor
condition|?
literal|"Logfile verification failed"
else|:
literal|"warning: editor session failed"
argument_list|)
expr_stmt|;
comment|/* put the entire message back into the *messagep variable */
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|messagep
condition|)
name|free
argument_list|(
operator|*
name|messagep
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|fname
argument_list|,
operator|&
name|post_stbuf
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot find size of temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_stbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
operator|*
name|messagep
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* On NT, we might read less than st_size bytes, but we won't 	   read more.  So this works.  */
operator|*
name|messagep
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|post_stbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|messagep
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|messagep
condition|)
block|{
name|size_t
name|message_len
init|=
name|post_stbuf
operator|.
name|st_size
operator|+
literal|1
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|CVSEDITPREFIXLEN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|+
name|line_length
operator|>=
name|message_len
condition|)
name|expand_string
argument_list|(
name|messagep
argument_list|,
operator|&
name|message_len
argument_list|,
name|offset
operator|+
name|line_length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|messagep
operator|+
name|offset
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|line_length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* canonicalize emply messages */
if|if
condition|(
operator|*
name|messagep
operator|!=
name|NULL
operator|&&
operator|(
operator|*
operator|*
name|messagep
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
operator|*
name|messagep
argument_list|,
literal|"\n"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|messagep
argument_list|)
expr_stmt|;
operator|*
name|messagep
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pre_stbuf
operator|.
name|st_mtime
operator|==
name|post_stbuf
operator|.
name|st_mtime
operator|||
operator|*
name|messagep
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nLog message unchanged or not specified\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"a)bort, c)ontinue, e)dit, !)reuse this message unchanged for remaining dirs\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Action: (continue) "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read from stdin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot remove temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"aborting"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_length
operator|==
literal|0
operator|||
operator|*
name|line
operator|==
literal|'\n'
operator|||
operator|*
name|line
operator|==
literal|'c'
operator|||
operator|*
name|line
operator|==
literal|'C'
condition|)
break|break;
if|if
condition|(
operator|*
name|line
operator|==
literal|'a'
operator|||
operator|*
name|line
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot remove temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"aborted by user"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'e'
operator|||
operator|*
name|line
operator|==
literal|'E'
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'!'
condition|)
block|{
name|reuse_log_message
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Unknown input\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot remove temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Runs the user-defined verification script as part of the commit or import     process.  This verification is meant to be run whether or not the user     included the -m atribute.  unlike the do_editor function, this is     independant of the running of an editor for getting a message.  */
end_comment

begin_function
name|void
name|do_verify
parameter_list|(
name|messagep
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
modifier|*
name|messagep
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|pre_stbuf
decl_stmt|,
name|post_stbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
comment|/* The verification will happen on the server.  */
return|return;
endif|#
directive|endif
comment|/* FIXME? Do we really want to skip this on noexec?  What do we do        for the other administrative files?  */
if|if
condition|(
name|noexec
operator|||
name|repository
operator|==
name|NULL
condition|)
return|return;
comment|/* Get the name of the verification script to run  */
if|if
condition|(
name|Parse_Info
argument_list|(
name|CVSROOTADM_VERIFYMSG
argument_list|,
name|repository
argument_list|,
name|verifymsg_proc
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Message verification failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verifymsg_script
condition|)
return|return;
comment|/* open a temporary file, write the message to the         temp file, and close the file.  */
if|if
condition|(
operator|(
name|fp
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|fname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|messagep
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
operator|*
name|messagep
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|messagep
operator|==
name|NULL
operator|||
operator|(
operator|*
name|messagep
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|messagep
operator|)
index|[
name|strlen
argument_list|(
operator|*
name|messagep
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|RereadLogAfterVerify
operator|==
name|LOGMSG_REREAD_STAT
condition|)
block|{
comment|/* Remember the status of the temp file for later */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|fname
argument_list|,
operator|&
name|pre_stbuf
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 	 * See if we need to sleep before running the verification 	 * script to avoid time-stamp races. 	 */
name|sleep_past
argument_list|(
name|pre_stbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
name|verifymsg_script
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_SIGIGNORE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Since following error() exits, delete the temp file now.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"Message verification failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Get the mod time and size of the possibly new log message      * in always and stat modes.      */
if|if
condition|(
name|RereadLogAfterVerify
operator|==
name|LOGMSG_REREAD_ALWAYS
operator|||
name|RereadLogAfterVerify
operator|==
name|LOGMSG_REREAD_STAT
condition|)
block|{
if|if
condition|(
name|CVS_STAT
argument_list|(
name|fname
argument_list|,
operator|&
name|post_stbuf
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot find size of temp file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* And reread the log message in `always' mode or in `stat' mode when it's      * changed      */
if|if
condition|(
name|RereadLogAfterVerify
operator|==
name|LOGMSG_REREAD_ALWAYS
operator|||
operator|(
name|RereadLogAfterVerify
operator|==
name|LOGMSG_REREAD_STAT
operator|&&
operator|(
name|pre_stbuf
operator|.
name|st_mtime
operator|!=
name|post_stbuf
operator|.
name|st_mtime
operator|||
name|pre_stbuf
operator|.
name|st_size
operator|!=
name|post_stbuf
operator|.
name|st_size
operator|)
operator|)
condition|)
block|{
comment|/* put the entire message back into the *messagep variable */
if|if
condition|(
operator|*
name|messagep
condition|)
name|free
argument_list|(
operator|*
name|messagep
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_stbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
operator|*
name|messagep
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* On NT, we might read less than st_size bytes, 	       but we won't read more.  So this works.  */
name|p
operator|=
operator|*
name|messagep
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|post_stbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|messagep
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
comment|/* Fail in this case because otherwise we will have no 			 * log message 			 */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|CVSEDITPREFIX
argument_list|,
name|CVSEDITPREFIXLEN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|p
operator|+=
name|line_length
expr_stmt|;
block|}
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Delete the temp file  */
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|verifymsg_script
argument_list|)
expr_stmt|;
name|verifymsg_script
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * callback proc for Parse_Info for rcsinfo templates this routine basically  * copies the matching template onto the end of the tempfile we are setting  * up  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|rcsinfo_proc
parameter_list|(
name|repository
parameter_list|,
name|template
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last_template
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
comment|/* nothing to do if the last one included is the same as this one */
if|if
condition|(
name|last_template
operator|&&
name|strcmp
argument_list|(
name|last_template
argument_list|,
name|template
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|last_template
condition|)
name|free
argument_list|(
name|last_template
argument_list|)
expr_stmt|;
name|last_template
operator|=
name|xstrdup
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfp
operator|=
name|CVS_FOPEN
argument_list|(
name|template
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_chars_allocated
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|tfp
argument_list|)
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|tfp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot read %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|tfp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Uses setup_tmpfile() to pass the updated message on directly to any  * logfile programs that have a regular expression match for the checked in  * directory in the source repository.  The log information is fed into the  * specified program as standard input.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|changes
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Update_Logfile
parameter_list|(
name|repository
parameter_list|,
name|xmessage
parameter_list|,
name|xlogfp
parameter_list|,
name|xchanges
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|xmessage
decl_stmt|;
name|FILE
modifier|*
name|xlogfp
decl_stmt|;
name|List
modifier|*
name|xchanges
decl_stmt|;
block|{
comment|/* nothing to do if the list is empty */
if|if
condition|(
name|xchanges
operator|==
name|NULL
operator|||
name|xchanges
operator|->
name|list
operator|->
name|next
operator|==
name|xchanges
operator|->
name|list
condition|)
return|return;
comment|/* set up static vars for update_logfile_proc */
name|message
operator|=
name|xmessage
expr_stmt|;
name|logfp
operator|=
name|xlogfp
expr_stmt|;
name|changes
operator|=
name|xchanges
expr_stmt|;
comment|/* call Parse_Info to do the actual logfile updates */
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_LOGINFO
argument_list|,
name|repository
argument_list|,
name|update_logfile_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * callback proc to actually do the logfile write from Update_Logfile  */
end_comment

begin_function
specifier|static
name|int
name|update_logfile_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|filter
decl_stmt|;
block|{
return|return
name|logfile_write
argument_list|(
name|repository
argument_list|,
name|filter
argument_list|,
name|message
argument_list|,
name|logfp
argument_list|,
name|changes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * concatenate each filename/version onto str_list  */
end_comment

begin_function
specifier|static
name|int
name|title_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|li
init|=
name|p
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|type
condition|)
block|{
comment|/* Until we decide on the correct logging solution when we add 	   directories or perform imports, T_TITLE nodes will only 	   tack on the name provided, regardless of the format string. 	   You can verify that this assumption is safe by checking the 	   code in add.c (add_directory) and import.c (import). */
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|T_TITLE
condition|)
block|{
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All other nodes use the format string. */
for|for
control|(
name|c
operator|=
name|str_list_format
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
operator|(
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
operator|(
name|li
operator|->
name|rev_old
condition|?
name|strlen
argument_list|(
name|li
operator|->
name|rev_old
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
operator|(
name|li
operator|->
name|rev_old
condition|?
name|li
operator|->
name|rev_old
else|:
literal|"NONE"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
operator|(
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
operator|(
name|li
operator|->
name|rev_new
condition|?
name|strlen
argument_list|(
name|li
operator|->
name|rev_new
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
operator|(
name|li
operator|->
name|rev_new
condition|?
name|li
operator|->
name|rev_new
else|:
literal|"NONE"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* All other characters, we insert an empty field (but 		   we do put in the comma separating it from other 		   fields).  This way if future CVS versions add formatting 		   characters, one can write a loginfo file which at least 		   won't blow up on an old CVS.  */
comment|/* Note that people who have to deal with spaces in file 		   and directory names are using space to get a known 		   delimiter for the directory name, so it's probably 		   not a good idea to ever define that as a formatting 		   character.  */
block|}
if|if
condition|(
operator|*
operator|(
name|c
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|str_list
operator|=
name|xrealloc
argument_list|(
name|str_list
argument_list|,
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str_list
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Writes some stuff to the logfile "filter" and returns the status of the  * filter program.  */
end_comment

begin_function
specifier|static
name|int
name|logfile_write
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|,
name|message
parameter_list|,
name|logfp
parameter_list|,
name|changes
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|filter
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|FILE
modifier|*
name|logfp
decl_stmt|;
name|List
modifier|*
name|changes
decl_stmt|;
block|{
name|FILE
modifier|*
name|pipefp
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|pipestatus
decl_stmt|;
name|char
modifier|*
name|fmt_percent
decl_stmt|;
comment|/* the location of the percent sign 				   that starts the format string. */
comment|/* The user may specify a format string as part of the filter.        Originally, `%s' was the only valid string.  The string that        was substituted for it was:<repository-name><file1><file2><file3> ...         Each file was either a new directory/import (T_TITLE), or a        added (T_ADDED), modified (T_MODIFIED), or removed (T_REMOVED)        file.         It is desirable to preserve that behavior so lots of commitlog        scripts won't die when they get this new code.  At the same        time, we'd like to pass other information about the files (like        version numbers, statuses, or checkin times).         The solution is to allow a format string that allows us to        specify those other pieces of information.  The format string        will be composed of `%' followed by a single format character,        or followed by a set of format characters surrounded by `{' and        `}' as separators.  The format characters are:           s = file name 	 V = old version number (pre-checkin) 	 v = new version number (post-checkin)         For example, valid format strings are:           %{} 	 %s 	 %{s} 	 %{sVv}         There's no reason that more items couldn't be added (like        modification date or file status [added, modified, updated,        etc.]) -- the code modifications would be minimal (logmsg.c        (title_proc) and commit.c (check_fileproc)).         The output will be a string of tokens separated by spaces.  For        backwards compatibility, the the first token will be the        repository name.  The rest of the tokens will be        comma-delimited lists of the information requested in the        format string.  For example, if `/u/src/master' is the        repository, `%{sVv}' is the format string, and three files        (ChangeLog, Makefile, foo.c) were modified, the output might        be:           /u/src/master ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13         Why this duplicates the old behavior when the format string is        `%s' is left as an exercise for the reader. */
name|fmt_percent
operator|=
name|strchr
argument_list|(
name|filter
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_percent
condition|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|srepos
decl_stmt|;
name|char
modifier|*
name|fmt_begin
decl_stmt|,
modifier|*
name|fmt_end
decl_stmt|;
comment|/* beginning and end of the 					   format string specified in 					   filter. */
name|char
modifier|*
name|fmt_continue
decl_stmt|;
comment|/* where the string continues 					   after the format string (we 					   might skip a '}') somewhere 					   in there... */
comment|/* Grab the format string. */
if|if
condition|(
operator|(
operator|*
operator|(
name|fmt_percent
operator|+
literal|1
operator|)
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
operator|(
name|fmt_percent
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* The percent stands alone.  This is an error.  We could 	       be treating ' ' like any other formatting character, but 	       using it as a formatting character seems like it would be 	       a mistake.  */
comment|/* Would be nice to also be giving the line number.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"loginfo: '%%' not followed by formatting character"
argument_list|)
expr_stmt|;
name|fmt_begin
operator|=
name|fmt_percent
operator|+
literal|1
expr_stmt|;
name|fmt_end
operator|=
name|fmt_begin
expr_stmt|;
name|fmt_continue
operator|=
name|fmt_begin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|fmt_percent
operator|+
literal|1
operator|)
operator|==
literal|'{'
condition|)
block|{
comment|/* The percent has a set of characters following it. */
name|fmt_begin
operator|=
name|fmt_percent
operator|+
literal|2
expr_stmt|;
name|fmt_end
operator|=
name|strchr
argument_list|(
name|fmt_begin
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_end
condition|)
block|{
comment|/* Skip over the '}' character. */
name|fmt_continue
operator|=
name|fmt_end
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There was no close brace -- assume that format                    string continues to the end of the line. */
comment|/* Would be nice to also be giving the line number.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"loginfo: '}' missing"
argument_list|)
expr_stmt|;
name|fmt_end
operator|=
name|fmt_begin
operator|+
name|strlen
argument_list|(
name|fmt_begin
argument_list|)
expr_stmt|;
name|fmt_continue
operator|=
name|fmt_end
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The percent has a single character following it.  FIXME: 	       %% should expand to a regular percent sign.  */
name|fmt_begin
operator|=
name|fmt_percent
operator|+
literal|1
expr_stmt|;
name|fmt_end
operator|=
name|fmt_begin
operator|+
literal|1
expr_stmt|;
name|fmt_continue
operator|=
name|fmt_end
expr_stmt|;
block|}
name|len
operator|=
name|fmt_end
operator|-
name|fmt_begin
expr_stmt|;
name|str_list_format
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|str_list_format
argument_list|,
name|fmt_begin
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|str_list_format
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Allocate an initial chunk of memory.  As we build up the string 	   we will realloc it.  */
if|if
condition|(
operator|!
name|str_list
condition|)
name|str_list
operator|=
name|xmalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|str_list
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Add entries to the string.  Don't bother looking for            entries if the format string is empty. */
if|if
condition|(
name|str_list_format
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|type
operator|=
name|T_TITLE
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|title_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|T_ADDED
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|title_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|T_MODIFIED
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|title_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|T_REMOVED
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|changes
argument_list|,
name|title_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|str_list_format
argument_list|)
expr_stmt|;
comment|/* Construct the final string. */
name|srepos
operator|=
name|Short_Repository
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|prog
operator|=
name|cp
operator|=
name|xmalloc
argument_list|(
operator|(
name|fmt_percent
operator|-
name|filter
operator|)
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|srepos
argument_list|)
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|str_list
argument_list|)
operator|+
name|strlen
argument_list|(
name|fmt_continue
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|cp
argument_list|,
name|filter
argument_list|,
name|fmt_percent
operator|-
name|filter
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|fmt_percent
operator|-
name|filter
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
name|cp
operator|=
name|shell_escape
argument_list|(
name|cp
argument_list|,
name|srepos
argument_list|)
expr_stmt|;
name|cp
operator|=
name|shell_escape
argument_list|(
name|cp
argument_list|,
name|str_list
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|fmt_continue
argument_list|)
expr_stmt|;
comment|/* To be nice, free up some memory. */
name|free
argument_list|(
name|str_list
argument_list|)
expr_stmt|;
name|str_list
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* There's no format string. */
name|prog
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pipefp
operator|=
name|run_popen
argument_list|(
name|prog
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot write entry to log filter: %s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"Update of %s\n"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"In directory %s:"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"<cannot get working directory: %s>\n\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"%s\n\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|setup_tmpfile
argument_list|(
name|pipefp
argument_list|,
literal|""
argument_list|,
name|changes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"Log Message:\n%s\n"
argument_list|,
operator|(
name|message
operator|)
condition|?
name|message
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfp
operator|!=
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"Status:\n"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|logfp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|logfp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|pipestatus
operator|=
name|pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pipestatus
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|pipestatus
operator|==
literal|127
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * We choose to use the *last* match within the editinfo file for this  * repository.  This allows us to have a global editinfo program for the  * root of some hierarchy, for example, and different ones within different  * sub-directories of the root (like a special checker for changes made to  * the "src" directory versus changes made to the "doc" or "test"  * directories.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|editinfo_proc
parameter_list|(
name|repository
parameter_list|,
name|editor
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|editor
decl_stmt|;
block|{
comment|/* nothing to do if the last match is the same as this one */
if|if
condition|(
name|editinfo_editor
operator|&&
name|strcmp
argument_list|(
name|editinfo_editor
argument_list|,
name|editor
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|editinfo_editor
condition|)
name|free
argument_list|(
name|editinfo_editor
argument_list|)
expr_stmt|;
name|editinfo_editor
operator|=
name|xstrdup
argument_list|(
name|editor
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  This routine is calld by Parse_Info.  it asigns the name of the  *  message verification script to the global variable verify_script  */
end_comment

begin_function
specifier|static
name|int
name|verifymsg_proc
parameter_list|(
name|repository
parameter_list|,
name|script
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|script
decl_stmt|;
block|{
if|if
condition|(
name|verifymsg_script
operator|&&
name|strcmp
argument_list|(
name|verifymsg_script
argument_list|,
name|script
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|verifymsg_script
condition|)
name|free
argument_list|(
name|verifymsg_script
argument_list|)
expr_stmt|;
name|verifymsg_script
operator|=
name|xstrdup
argument_list|(
name|script
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

