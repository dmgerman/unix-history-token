begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"f2c.h"
end_include

begin_include
include|#
directive|include
file|"fio.h"
end_include

begin_include
include|#
directive|include
file|"fmt.h"
end_include

begin_define
define|#
directive|define
name|skip
parameter_list|(
name|s
parameter_list|)
value|while(*s==' ') s++
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|interdata
end_ifdef

begin_define
define|#
directive|define
name|SYLMX
value|300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|SYLMX
value|300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|SYLMX
value|300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYLMX
end_ifndef

begin_define
define|#
directive|define
name|SYLMX
value|300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GLITCH
value|'\2'
end_define

begin_comment
comment|/* special quote character for stu */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|f__cursor
decl_stmt|,
name|f__scale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|flag
name|f__cblank
decl_stmt|,
name|f__cplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*blanks in I and compulsory plus */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|syl
name|f__syl
index|[
name|SYLMX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f__parenlvl
decl_stmt|,
name|f__pc
decl_stmt|,
name|f__revloc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|ap_end
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|quote
decl_stmt|;
name|quote
operator|=
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
name|quote
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|++
name|s
operator|!=
name|quote
condition|)
return|return
operator|(
name|s
operator|)
return|;
block|}
if|if
condition|(
name|f__elist
operator|->
name|cierr
condition|)
block|{
name|errno
operator|=
literal|100
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|f__fatal
argument_list|(
literal|100
argument_list|,
literal|"bad string"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_gen
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|struct
name|syl
modifier|*
name|p
init|=
operator|&
name|f__syl
index|[
name|f__pc
index|]
decl_stmt|;
if|if
condition|(
name|f__pc
operator|>=
name|SYLMX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"format too complicated:\n"
argument_list|)
expr_stmt|;
name|sig_die
argument_list|(
name|f__fmtbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|op
operator|=
name|a
expr_stmt|;
name|p
operator|->
name|p1
operator|=
name|b
expr_stmt|;
name|p
operator|->
name|p2
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|p2
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|f__pc
operator|++
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|char
modifier|*
name|f_list
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|gt_num
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|n
parameter_list|,
name|int
name|n1
parameter_list|)
block|{
name|int
name|m
init|=
literal|0
decl_stmt|,
name|f__cnt
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|s
init|;
condition|;
name|c
operator|=
operator|*
name|s
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|>
literal|'9'
operator|||
name|c
operator|<
literal|'0'
condition|)
break|break;
name|m
operator|=
literal|10
operator|*
name|m
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|f__cnt
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|f__cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|n1
condition|)
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|n
operator|=
name|n1
expr_stmt|;
block|}
else|else
operator|*
name|n
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|f_s
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|curloc
parameter_list|)
block|{
name|skip
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'('
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|f__parenlvl
operator|++
operator|==
literal|1
condition|)
name|f__revloc
operator|=
name|curloc
expr_stmt|;
if|if
condition|(
name|op_gen
argument_list|(
name|RET1
argument_list|,
name|curloc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|s
operator|=
name|f_list
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ne_d
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|x
decl_stmt|,
name|sign
init|=
literal|0
decl_stmt|;
name|struct
name|syl
modifier|*
name|sp
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|COLON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|NONL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'z'
operator|||
operator|*
name|s
operator|==
literal|'Z'
condition|)
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|BZ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|BN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'s'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'S'
condition|)
block|{
name|x
operator|=
name|SS
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'p'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'P'
condition|)
block|{
name|x
operator|=
name|SP
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|x
operator|=
name|S
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|SLASH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|s
operator|++
expr_stmt|;
comment|/*OUTRAGEOUS CODING TRICK */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|bad
label|:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
name|sign
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|P
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|X
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|sp
operator|=
operator|&
name|f__syl
index|[
name|op_gen
argument_list|(
name|H
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
name|sp
operator|->
name|p2
operator|.
name|s
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GLITCH
case|:
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|sp
operator|=
operator|&
name|f__syl
index|[
name|op_gen
argument_list|(
name|APOS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
name|sp
operator|->
name|p2
operator|.
name|s
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|=
name|ap_end
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'l'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'L'
condition|)
block|{
name|x
operator|=
name|TL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'r'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'R'
condition|)
block|{
name|x
operator|=
name|TR
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|x
operator|=
name|T
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|s
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|x
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|X
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|P
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_d
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|im
decl_stmt|,
name|n
decl_stmt|,
name|w
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sv
init|=
name|s
decl_stmt|;
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|STACK
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
default|default:
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|x
operator|=
literal|1
expr_stmt|;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|bad
label|:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|d
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'E'
operator|&&
operator|*
name|s
operator|!=
literal|'e'
condition|)
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|x
operator|==
literal|1
condition|?
name|E
else|:
name|G
argument_list|,
name|w
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* default is Ew.dE2 */
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|x
operator|==
literal|1
condition|?
name|EE
else|:
name|GE
argument_list|,
name|w
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
name|i
operator|=
name|O
expr_stmt|;
name|im
operator|=
name|OM
expr_stmt|;
goto|goto
name|finish_I
goto|;
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
name|i
operator|=
name|Z
expr_stmt|;
name|im
operator|=
name|ZM
expr_stmt|;
goto|goto
name|finish_I
goto|;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|L
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|found
operator|=
literal|1
expr_stmt|;
name|skip
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
block|{
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|AW
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|A
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|d
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
name|d
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|F
argument_list|,
name|w
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|d
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
name|d
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|D
argument_list|,
name|w
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
name|i
operator|=
name|I
expr_stmt|;
name|im
operator|=
name|IM
expr_stmt|;
name|finish_I
label|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|i
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gt_num
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|d
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|im
argument_list|,
name|w
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|f__pc
operator|--
expr_stmt|;
comment|/*unSTACK */
operator|*
name|p
operator|=
name|sv
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|i_tem
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|n
decl_stmt|,
name|curloc
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
return|return
operator|(
name|s
operator|)
return|;
if|if
condition|(
name|ne_d
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return
operator|(
name|t
operator|)
return|;
if|if
condition|(
name|e_d
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|s
operator|=
name|gt_num
argument_list|(
name|s
argument_list|,
operator|&
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curloc
operator|=
name|op_gen
argument_list|(
name|STACK
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|f_s
argument_list|(
name|s
argument_list|,
name|curloc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|f_list
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
control|)
block|{
name|skip
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|i_tem
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|skip
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|--
name|f__parenlvl
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|REVERT
argument_list|,
name|f__revloc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|++
name|s
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|op_gen
argument_list|(
name|GOTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|++
name|s
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pars_f
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|f__parenlvl
operator|=
name|f__revloc
operator|=
name|f__pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|f_s
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Try and delimit the format string.  Parens within          hollerith and quoted strings have to match for this          to work, but it's probably adequate for most needs.          Note that this is needed because a valid CHARACTER          variable passed for FMT= can contain '(I)garbage',          where `garbage' is billions and billions of junk          characters, and it's up to the run-time library to          know where the format string ends by counting parens.          Meanwhile, still treat NUL byte as "hard stop", since          f2c still appends that at end of FORMAT-statement          strings.  */
name|int
name|level
init|=
literal|0
decl_stmt|;
for|for
control|(
name|f__fmtlen
operator|=
literal|0
init|;
operator|(
operator|(
operator|*
name|s
operator|!=
literal|')'
operator|)
operator|||
operator|(
operator|--
name|level
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|f__fmtlen
operator|<
literal|80
operator|)
condition|;
operator|++
name|s
operator|,
operator|++
name|f__fmtlen
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
operator|++
name|level
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
operator|++
name|f__fmtlen
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|f__fmtlen
operator|=
name|e
operator|-
name|s
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STKSZ
value|10
end_define

begin_decl_stmt
name|int
name|f__cnt
index|[
name|STKSZ
index|]
decl_stmt|,
name|f__ret
index|[
name|STKSZ
index|]
decl_stmt|,
name|f__cp
decl_stmt|,
name|f__rp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|f__workdone
decl_stmt|,
name|f__nonl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|type_f
parameter_list|(
name|int
name|n
parameter_list|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
default|default:
return|return
operator|(
name|n
operator|)
return|;
case|case
name|RET1
case|:
return|return
operator|(
name|RET1
operator|)
return|;
case|case
name|REVERT
case|:
return|return
operator|(
name|REVERT
operator|)
return|;
case|case
name|GOTO
case|:
return|return
operator|(
name|GOTO
operator|)
return|;
case|case
name|STACK
case|:
return|return
operator|(
name|STACK
operator|)
return|;
case|case
name|X
case|:
case|case
name|SLASH
case|:
case|case
name|APOS
case|:
case|case
name|H
case|:
case|case
name|T
case|:
case|case
name|TL
case|:
case|case
name|TR
case|:
return|return
operator|(
name|NED
operator|)
return|;
case|case
name|F
case|:
case|case
name|I
case|:
case|case
name|IM
case|:
case|case
name|A
case|:
case|case
name|AW
case|:
case|case
name|O
case|:
case|case
name|OM
case|:
case|case
name|L
case|:
case|case
name|E
case|:
case|case
name|EE
case|:
case|case
name|D
case|:
case|case
name|G
case|:
case|case
name|GE
case|:
case|case
name|Z
case|:
case|case
name|ZM
case|:
return|return
operator|(
name|ED
operator|)
return|;
block|}
block|}
end_function

begin_function
name|integer
name|do_fio
parameter_list|(
name|ftnint
modifier|*
name|number
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|ftnlen
name|len
parameter_list|)
block|{
name|struct
name|syl
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|number
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
name|len
control|)
block|{
name|loop
label|:
switch|switch
condition|(
name|type_f
argument_list|(
operator|(
name|p
operator|=
operator|&
name|f__syl
index|[
name|f__pc
index|]
operator|)
operator|->
name|op
argument_list|)
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown code in do_fio: %d\n%.*s\n"
argument_list|,
name|p
operator|->
name|op
argument_list|,
name|f__fmtlen
argument_list|,
name|f__fmtbuf
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|f__elist
operator|->
name|cierr
argument_list|,
literal|100
argument_list|,
literal|"do_fio"
argument_list|)
expr_stmt|;
case|case
name|NED
case|:
if|if
condition|(
call|(
modifier|*
name|f__doned
call|)
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|f__pc
operator|++
expr_stmt|;
continue|continue;
case|case
name|ED
case|:
if|if
condition|(
name|f__cnt
index|[
name|f__cp
index|]
operator|<=
literal|0
condition|)
block|{
name|f__cp
operator|--
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|f__doend
call|)
argument_list|()
operator|)
return|;
name|f__cnt
index|[
name|f__cp
index|]
operator|--
expr_stmt|;
name|f__workdone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
call|(
modifier|*
name|f__doed
call|)
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|errfl
argument_list|(
name|f__elist
operator|->
name|cierr
argument_list|,
name|errno
argument_list|,
literal|"fmt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|err
argument_list|(
name|f__elist
operator|->
name|ciend
argument_list|,
operator|(
name|EOF
operator|)
argument_list|,
literal|"fmt"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|STACK
case|:
name|f__cnt
index|[
operator|++
name|f__cp
index|]
operator|=
name|p
operator|->
name|p1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|RET1
case|:
name|f__ret
index|[
operator|++
name|f__rp
index|]
operator|=
name|p
operator|->
name|p1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|GOTO
case|:
if|if
condition|(
operator|--
name|f__cnt
index|[
name|f__cp
index|]
operator|<=
literal|0
condition|)
block|{
name|f__cp
operator|--
expr_stmt|;
name|f__rp
operator|--
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|f__pc
operator|=
literal|1
operator|+
name|f__ret
index|[
name|f__rp
operator|--
index|]
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|REVERT
case|:
name|f__rp
operator|=
name|f__cp
operator|=
literal|0
expr_stmt|;
name|f__pc
operator|=
name|p
operator|->
name|p1
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|f__doend
call|)
argument_list|()
operator|)
return|;
if|if
condition|(
operator|!
name|f__workdone
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|n
operator|=
call|(
modifier|*
name|f__dorevert
call|)
argument_list|()
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
goto|goto
name|loop
goto|;
case|case
name|COLON
case|:
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|f__doend
call|)
argument_list|()
operator|)
return|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|NONL
case|:
name|f__nonl
operator|=
literal|1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|S
case|:
case|case
name|SS
case|:
name|f__cplus
operator|=
literal|0
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|SP
case|:
name|f__cplus
operator|=
literal|1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|P
case|:
name|f__scale
operator|=
name|p
operator|->
name|p1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|BN
case|:
name|f__cblank
operator|=
literal|0
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|BZ
case|:
name|f__cblank
operator|=
literal|1
expr_stmt|;
name|f__pc
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|en_fio
parameter_list|(
name|void
parameter_list|)
block|{
name|ftnint
name|one
init|=
literal|1
decl_stmt|;
return|return
operator|(
name|do_fio
argument_list|(
operator|&
name|one
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fmt_bg
parameter_list|(
name|void
parameter_list|)
block|{
name|f__workdone
operator|=
name|f__cp
operator|=
name|f__rp
operator|=
name|f__pc
operator|=
name|f__cursor
operator|=
literal|0
expr_stmt|;
name|f__cnt
index|[
literal|0
index|]
operator|=
name|f__ret
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

