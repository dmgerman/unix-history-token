begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991-1999, 2000, 2001, 2003 Free Software Foundation, Inc.     NOTE: The canonical source of this file is maintained with the GNU C Library.    Bugs can be reported to bug-glibc@prep.ai.mit.edu.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|HAVE_MBLEN
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_MBRLEN
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_STRUCT_ERA_ENTRY
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_TM_GMTOFF
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_TM_ZONE
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_TZNAME
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_TZSET
value|1
end_define

begin_define
define|#
directive|define
name|MULTIBYTE_IS_FORMAT_SAFE
value|1
end_define

begin_include
include|#
directive|include
file|"../locale/localeinfo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Some systems define `time_t' here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIME_WITH_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TZNAME
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tzname
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do multibyte processing if multibytes are supported, unless    multibyte sequences are safe in formats.  Multibyte sequences are    safe if they cannot contain byte sequences that look like format    conversion specifications.  The GNU C Library uses UTF8 multibyte    encoding, which is safe for formats, but strftime.c can be used    with other C libraries that use unsafe encodings.  */
end_comment

begin_define
define|#
directive|define
name|DO_MULTIBYTE
value|(HAVE_MBLEN&& ! MULTIBYTE_IS_FORMAT_SAFE)
end_define

begin_if
if|#
directive|if
name|DO_MULTIBYTE
end_if

begin_if
if|#
directive|if
name|HAVE_MBRLEN
end_if

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Simulate mbrlen with mblen as best we can.  */
end_comment

begin_define
define|#
directive|define
name|mbstate_t
value|int
end_define

begin_define
define|#
directive|define
name|mbrlen
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|ps
parameter_list|)
value|mblen (s, n)
end_define

begin_define
define|#
directive|define
name|mbsinit
parameter_list|(
name|ps
parameter_list|)
value|(*(ps) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|mbstate_t
name|mbstate_zero
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_WIDE
end_ifdef

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_define
define|#
directive|define
name|CHAR_T
value|wchar_t
end_define

begin_define
define|#
directive|define
name|UCHAR_T
value|unsigned int
end_define

begin_define
define|#
directive|define
name|L_
parameter_list|(
name|Str
parameter_list|)
value|L##Str
end_define

begin_define
define|#
directive|define
name|NLW
parameter_list|(
name|Sym
parameter_list|)
value|_NL_W##Sym
end_define

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|__wmemcpy (d, s, n)
end_define

begin_define
define|#
directive|define
name|STRLEN
parameter_list|(
name|s
parameter_list|)
value|__wcslen (s)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHAR_T
value|char
end_define

begin_define
define|#
directive|define
name|UCHAR_T
value|unsigned char
end_define

begin_define
define|#
directive|define
name|L_
parameter_list|(
name|Str
parameter_list|)
value|Str
end_define

begin_define
define|#
directive|define
name|NLW
parameter_list|(
name|Sym
parameter_list|)
value|Sym
end_define

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|memcpy (d, s, n)
end_define

begin_define
define|#
directive|define
name|STRLEN
parameter_list|(
name|s
parameter_list|)
value|strlen (s)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|MEMPCPY
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|__mempcpy (d, s, n)
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMPCPY
end_ifndef

begin_define
define|#
directive|define
name|MEMPCPY
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|((void *) ((char *) memcpy (d, s, n) + (n)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TYPE_SIGNED
parameter_list|(
name|t
parameter_list|)
value|((t) -1< 0)
end_define

begin_comment
comment|/* Bound on length of the string representing an integer value of type t.    Subtract one for the sign bit if t is signed;    302 / 1000 is log10 (2) rounded up;    add one for integer division truncation;    add one more for a minus sign if t is signed.  */
end_comment

begin_define
define|#
directive|define
name|INT_STRLEN_BOUND
parameter_list|(
name|t
parameter_list|)
define|\
value|((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 + 1 + TYPE_SIGNED (t))
end_define

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__isleap
end_ifndef

begin_comment
comment|/* Nonzero if YEAR is a leap year (every 4 years,    except every 100th isn't, and every 400th is).  */
end_comment

begin_define
define|#
directive|define
name|__isleap
parameter_list|(
name|year
parameter_list|)
define|\
value|((year) % 4 == 0&& ((year) % 100 != 0 || (year) % 400 == 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|tzname
value|__tzname
end_define

begin_define
define|#
directive|define
name|tzset
value|__tzset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_TM_GMTOFF
end_if

begin_comment
comment|/* Portable standalone applications should supply a "time_r.h" that    declares a POSIX-compliant localtime_r, for the benefit of older    implementations that lack localtime_r or have a nonstandard one.    See the gnulib time_r module for one way to implement this.  */
end_comment

begin_include
include|#
directive|include
file|"time_r.h"
end_include

begin_undef
undef|#
directive|undef
name|__gmtime_r
end_undef

begin_undef
undef|#
directive|undef
name|__localtime_r
end_undef

begin_define
define|#
directive|define
name|__gmtime_r
value|gmtime_r
end_define

begin_define
define|#
directive|define
name|__localtime_r
value|localtime_r
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_WIDE
end_ifdef

begin_define
define|#
directive|define
name|memset_space
parameter_list|(
name|P
parameter_list|,
name|Len
parameter_list|)
value|(wmemset (P, L' ', Len), (P) += (Len))
end_define

begin_define
define|#
directive|define
name|memset_zero
parameter_list|(
name|P
parameter_list|,
name|Len
parameter_list|)
value|(wmemset (P, L'0', Len), (P) += (Len))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memset_space
parameter_list|(
name|P
parameter_list|,
name|Len
parameter_list|)
value|(memset (P, ' ', Len), (P) += (Len))
end_define

begin_define
define|#
directive|define
name|memset_zero
parameter_list|(
name|P
parameter_list|,
name|Len
parameter_list|)
value|(memset (P, '0', Len), (P) += (Len))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|add
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|)
define|\
value|do									      \     {									      \       int _n = (n);							      \       int _delta = width - _n;						      \       int _incr = _n + (_delta> 0 ? _delta : 0);			      \       if ((size_t) _incr>= maxsize - i)				      \ 	return 0;							      \       if (p)								      \ 	{								      \ 	  if (_delta> 0)						      \ 	    {								      \ 	      if (pad == L_('0'))					      \ 		memset_zero (p, _delta);				      \ 	      else							      \ 		memset_space (p, _delta);				      \ 	    }								      \ 	  f;								      \ 	  p += _n;							      \ 	}								      \       i += _incr;							      \     } while (0)
end_define

begin_define
define|#
directive|define
name|cpy
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
define|\
value|add ((n),								      \ 	 if (to_lowcase)						      \ 	   memcpy_lowcase (p, (s), _n LOCALE_ARG);			      \ 	 else if (to_uppcase)						      \ 	   memcpy_uppcase (p, (s), _n LOCALE_ARG);			      \ 	 else								      \ 	   MEMCPY ((void *) p, (void const *) (s), _n))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_WIDE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_IN_EXTENDED_LOCALE_MODEL
end_ifndef

begin_undef
undef|#
directive|undef
name|__mbsrtowcs_l
end_undef

begin_define
define|#
directive|define
name|__mbsrtowcs_l
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|,
name|st
parameter_list|,
name|loc
parameter_list|)
value|__mbsrtowcs (d, s, l, st)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|widen
parameter_list|(
name|os
parameter_list|,
name|ws
parameter_list|,
name|l
parameter_list|)
define|\
value|{									      \     mbstate_t __st;							      \     const char *__s = os;						      \     memset (&__st, '\0', sizeof (__st));				      \     l = __mbsrtowcs_l (NULL,&__s, 0,&__st, loc);			      \     ws = (wchar_t *) alloca ((l + 1) * sizeof (wchar_t));		      \     (void) __mbsrtowcs_l (ws,&__s, l,&__st, loc);			      \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_EXTENDED_LOCALE_MODEL
end_if

begin_comment
comment|/* We use this code also for the extended locale handling where the    function gets as an additional argument the locale which has to be    used.  To access the values we have to redefine the _NL_CURRENT    macro.  */
end_comment

begin_define
define|#
directive|define
name|strftime
value|__strftime_l
end_define

begin_define
define|#
directive|define
name|wcsftime
value|__wcsftime_l
end_define

begin_undef
undef|#
directive|undef
name|_NL_CURRENT
end_undef

begin_define
define|#
directive|define
name|_NL_CURRENT
parameter_list|(
name|category
parameter_list|,
name|item
parameter_list|)
define|\
value|(current->values[_NL_ITEM_INDEX (item)].string)
end_define

begin_define
define|#
directive|define
name|LOCALE_ARG
value|, loc
end_define

begin_define
define|#
directive|define
name|LOCALE_PARAM_PROTO
value|, __locale_t loc
end_define

begin_define
define|#
directive|define
name|HELPER_LOCALE_ARG
value|, current
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOCALE_PARAM_PROTO
end_define

begin_define
define|#
directive|define
name|LOCALE_ARG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|HELPER_LOCALE_ARG
value|, _NL_CURRENT_DATA (LC_TIME)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HELPER_LOCALE_ARG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_WIDE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_IN_EXTENDED_LOCALE_MODEL
end_ifdef

begin_define
define|#
directive|define
name|TOUPPER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|__towupper_l (Ch, L)
end_define

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|__towlower_l (Ch, L)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOUPPER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|towupper (Ch)
end_define

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|towlower (Ch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_IN_EXTENDED_LOCALE_MODEL
end_ifdef

begin_define
define|#
directive|define
name|TOUPPER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|__toupper_l (Ch, L)
end_define

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|__tolower_l (Ch, L)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOUPPER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|toupper (Ch)
end_define

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|tolower (Ch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOUPPER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|(islower (Ch) ? toupper (Ch) : (Ch))
end_define

begin_define
define|#
directive|define
name|TOLOWER
parameter_list|(
name|Ch
parameter_list|,
name|L
parameter_list|)
value|(isupper (Ch) ? tolower (Ch) : (Ch))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We don't use `isdigit' here since the locale dependent    interpretation is not what we want here.  We only need to accept    the arabic digits in the ASCII range.  One day there is perhaps a    more reliable way to accept other sets of digits.  */
end_comment

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|Ch
parameter_list|)
value|((unsigned int) (Ch) - L_('0')<= 9)
end_define

begin_function
specifier|static
name|CHAR_T
modifier|*
name|memcpy_lowcase
parameter_list|(
name|CHAR_T
modifier|*
name|dest
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|src
parameter_list|,
name|size_t
name|len
name|LOCALE_PARAM_PROTO
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|dest
index|[
name|len
index|]
operator|=
name|TOLOWER
argument_list|(
operator|(
name|UCHAR_T
operator|)
name|src
index|[
name|len
index|]
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_function
specifier|static
name|CHAR_T
modifier|*
name|memcpy_uppcase
parameter_list|(
name|CHAR_T
modifier|*
name|dest
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|src
parameter_list|,
name|size_t
name|len
name|LOCALE_PARAM_PROTO
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|dest
index|[
name|len
index|]
operator|=
name|TOUPPER
argument_list|(
operator|(
name|UCHAR_T
operator|)
name|src
index|[
name|len
index|]
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|HAVE_TM_GMTOFF
end_if

begin_comment
comment|/* Yield the difference between *A and *B,    measured in seconds, ignoring leap seconds.  */
end_comment

begin_define
define|#
directive|define
name|tm_diff
value|ftime_tm_diff
end_define

begin_function
specifier|static
name|int
name|tm_diff
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|tm
modifier|*
name|b
parameter_list|)
block|{
comment|/* Compute intervening leap days correctly even if year is negative.      Take care to avoid int overflow in leap day calculations,      but it's OK to assume that A and B are close to each other.  */
name|int
name|a4
init|=
operator|(
name|a
operator|->
name|tm_year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|a
operator|->
name|tm_year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|b4
init|=
operator|(
name|b
operator|->
name|tm_year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|b
operator|->
name|tm_year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|a100
init|=
name|a4
operator|/
literal|25
operator|-
operator|(
name|a4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|b100
init|=
name|b4
operator|/
literal|25
operator|-
operator|(
name|b4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|a400
init|=
name|a100
operator|>>
literal|2
decl_stmt|;
name|int
name|b400
init|=
name|b100
operator|>>
literal|2
decl_stmt|;
name|int
name|intervening_leap_days
init|=
operator|(
name|a4
operator|-
name|b4
operator|)
operator|-
operator|(
name|a100
operator|-
name|b100
operator|)
operator|+
operator|(
name|a400
operator|-
name|b400
operator|)
decl_stmt|;
name|int
name|years
init|=
name|a
operator|->
name|tm_year
operator|-
name|b
operator|->
name|tm_year
decl_stmt|;
name|int
name|days
init|=
operator|(
literal|365
operator|*
name|years
operator|+
name|intervening_leap_days
operator|+
operator|(
name|a
operator|->
name|tm_yday
operator|-
name|b
operator|->
name|tm_yday
operator|)
operator|)
decl_stmt|;
return|return
operator|(
literal|60
operator|*
operator|(
literal|60
operator|*
operator|(
literal|24
operator|*
name|days
operator|+
operator|(
name|a
operator|->
name|tm_hour
operator|-
name|b
operator|->
name|tm_hour
operator|)
operator|)
operator|+
operator|(
name|a
operator|->
name|tm_min
operator|-
name|b
operator|->
name|tm_min
operator|)
operator|)
operator|+
operator|(
name|a
operator|->
name|tm_sec
operator|-
name|b
operator|->
name|tm_sec
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_TM_GMTOFF */
end_comment

begin_comment
comment|/* The number of days from the first day of the first ISO week of this    year to the year day YDAY with week day WDAY.  ISO weeks start on    Monday; the first ISO week has the year's first Thursday.  YDAY may    be as small as YDAY_MINIMUM.  */
end_comment

begin_define
define|#
directive|define
name|ISO_WEEK_START_WDAY
value|1
end_define

begin_comment
comment|/* Monday */
end_comment

begin_define
define|#
directive|define
name|ISO_WEEK1_WDAY
value|4
end_define

begin_comment
comment|/* Thursday */
end_comment

begin_define
define|#
directive|define
name|YDAY_MINIMUM
value|(-366)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline__
endif|#
directive|endif
specifier|static
name|int
name|iso_week_days
parameter_list|(
name|int
name|yday
parameter_list|,
name|int
name|wday
parameter_list|)
block|{
comment|/* Add enough to the first operand of % to make it nonnegative.  */
name|int
name|big_enough_multiple_of_7
init|=
operator|(
operator|-
name|YDAY_MINIMUM
operator|/
literal|7
operator|+
literal|2
operator|)
operator|*
literal|7
decl_stmt|;
return|return
operator|(
name|yday
operator|-
operator|(
name|yday
operator|-
name|wday
operator|+
name|ISO_WEEK1_WDAY
operator|+
name|big_enough_multiple_of_7
operator|)
operator|%
literal|7
operator|+
name|ISO_WEEK1_WDAY
operator|-
name|ISO_WEEK_START_WDAY
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|_NL_CURRENT
operator|||
name|HAVE_STRFTIME
operator|)
end_if

begin_decl_stmt
specifier|static
name|CHAR_T
specifier|const
name|weekday_name
index|[]
index|[
literal|10
index|]
init|=
block|{
name|L_
argument_list|(
literal|"Sunday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Monday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Tuesday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Wednesday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Thursday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Friday"
argument_list|)
block|,
name|L_
argument_list|(
literal|"Saturday"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CHAR_T
specifier|const
name|month_name
index|[]
index|[
literal|10
index|]
init|=
block|{
name|L_
argument_list|(
literal|"January"
argument_list|)
block|,
name|L_
argument_list|(
literal|"February"
argument_list|)
block|,
name|L_
argument_list|(
literal|"March"
argument_list|)
block|,
name|L_
argument_list|(
literal|"April"
argument_list|)
block|,
name|L_
argument_list|(
literal|"May"
argument_list|)
block|,
name|L_
argument_list|(
literal|"June"
argument_list|)
block|,
name|L_
argument_list|(
literal|"July"
argument_list|)
block|,
name|L_
argument_list|(
literal|"August"
argument_list|)
block|,
name|L_
argument_list|(
literal|"September"
argument_list|)
block|,
name|L_
argument_list|(
literal|"October"
argument_list|)
block|,
name|L_
argument_list|(
literal|"November"
argument_list|)
block|,
name|L_
argument_list|(
literal|"December"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When compiling this file, GNU applications can #define my_strftime    to a symbol (typically nstrftime) to get an extended strftime with    extra arguments UT and NS.  Emacs is a special case for now, but    this Emacs-specific code can be removed once Emacs's config.h    defines my_strftime.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|emacs
operator|&&
operator|!
name|defined
name|my_strftime
end_if

begin_define
define|#
directive|define
name|my_strftime
value|nstrftime
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|my_strftime
end_ifdef

begin_define
define|#
directive|define
name|extra_args
value|, ut, ns
end_define

begin_define
define|#
directive|define
name|extra_args_spec
value|, int ut, int ns
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_WIDE
end_ifdef

begin_define
define|#
directive|define
name|my_strftime
value|wcsftime
end_define

begin_define
define|#
directive|define
name|nl_get_alt_digit
value|_nl_get_walt_digit
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|my_strftime
value|strftime
end_define

begin_define
define|#
directive|define
name|nl_get_alt_digit
value|_nl_get_alt_digit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|extra_args
end_define

begin_define
define|#
directive|define
name|extra_args_spec
end_define

begin_comment
comment|/* We don't have this information in general.  */
end_comment

begin_define
define|#
directive|define
name|ut
value|0
end_define

begin_define
define|#
directive|define
name|ns
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|HAVE_RUN_TZSET_TEST
end_if

begin_comment
comment|/* Solaris 2.5.x and 2.6 tzset sometimes modify the storage returned    by localtime.  On such systems, we must use the tzset and localtime    wrappers to work around the bug.  */
end_comment

begin_expr_stmt
literal|"you must run the autoconf test for a working tzset function"
endif|#
directive|endif
comment|/* Write information from TP into S according to the format    string FORMAT, writing no more that MAXSIZE characters    (including the terminating '\0') and returning number of    characters written.  If S is NULL, nothing will be written    anywhere, so to determine how many characters would be    written, use NULL for S and (size_t) UINT_MAX for MAXSIZE.  */
name|size_t
name|my_strftime
argument_list|(
argument|CHAR_T *s
argument_list|,
argument|size_t maxsize
argument_list|,
argument|const CHAR_T *format
argument_list|,
argument|const struct tm *tp extra_args_spec LOCALE_PARAM_PROTO
argument_list|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_EXTENDED_LOCALE_MODEL
block|struct
name|locale_data
operator|*
specifier|const
name|current
operator|=
name|loc
operator|->
name|__locales
index|[
name|LC_TIME
index|]
block|;
endif|#
directive|endif
name|int
name|hour12
operator|=
name|tp
operator|->
name|tm_hour
block|;
ifdef|#
directive|ifdef
name|_NL_CURRENT
comment|/* We cannot make the following values variables since we must delay      the evaluation of these values until really needed since some      expressions might not be valid in every situation.  The `struct tm'      might be generated by a strptime() call that initialized      only a few elements.  Dereference the pointers only if the format      requires this.  Then it is ok to fail if the pointers are invalid.  */
define|#
directive|define
name|a_wkday
define|\
value|((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))
define|#
directive|define
name|f_wkday
define|\
value|((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))
define|#
directive|define
name|a_month
define|\
value|((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))
define|#
directive|define
name|f_month
define|\
value|((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))
define|#
directive|define
name|ampm
define|\
value|((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour> 11		      \ 				 ? NLW(PM_STR) : NLW(AM_STR)))
define|#
directive|define
name|aw_len
value|STRLEN (a_wkday)
define|#
directive|define
name|am_len
value|STRLEN (a_month)
define|#
directive|define
name|ap_len
value|STRLEN (ampm)
else|#
directive|else
if|#
directive|if
operator|!
name|HAVE_STRFTIME
define|#
directive|define
name|f_wkday
value|(weekday_name[tp->tm_wday])
define|#
directive|define
name|f_month
value|(month_name[tp->tm_mon])
define|#
directive|define
name|a_wkday
value|f_wkday
define|#
directive|define
name|a_month
value|f_month
define|#
directive|define
name|ampm
value|(L_("AMPM") + 2 * (tp->tm_hour> 11))
name|size_t
name|aw_len
operator|=
literal|3
block|;
name|size_t
name|am_len
operator|=
literal|3
block|;
name|size_t
name|ap_len
operator|=
literal|2
block|;
endif|#
directive|endif
endif|#
directive|endif
specifier|const
name|char
operator|*
name|zone
block|;
name|size_t
name|i
operator|=
literal|0
block|;
name|CHAR_T
operator|*
name|p
operator|=
name|s
block|;
specifier|const
name|CHAR_T
operator|*
name|f
block|;
if|#
directive|if
name|DO_MULTIBYTE
operator|&&
operator|!
name|defined
name|COMPILE_WIDE
specifier|const
name|char
operator|*
name|format_end
operator|=
name|NULL
block|;
endif|#
directive|endif
name|zone
operator|=
name|NULL
block|;
if|#
directive|if
name|HAVE_TM_ZONE
comment|/* The POSIX test suite assumes that setting      the environment variable TZ to a new value before calling strftime()      will influence the result (the %Z format) even if the information in      TP is computed with a totally different time zone.      This is bogus: though POSIX allows bad behavior like this,      POSIX does not require it.  Do the right thing instead.  */
name|zone
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|tp
operator|->
name|tm_zone
block|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_TZNAME
if|if
condition|(
name|ut
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|zone
operator|&&
operator|*
name|zone
operator|)
condition|)
name|zone
operator|=
literal|"GMT"
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* POSIX.1 requires that local time zone information be used as 	 though strftime called tzset.  */
if|#
directive|if
name|HAVE_TZSET
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|hour12
operator|>
literal|12
condition|)
name|hour12
operator|-=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|hour12
operator|==
literal|0
condition|)
name|hour12
operator|=
literal|12
expr_stmt|;
end_if

begin_for
for|for
control|(
name|f
operator|=
name|format
init|;
operator|*
name|f
operator|!=
literal|'\0'
condition|;
operator|++
name|f
control|)
block|{
name|int
name|pad
init|=
literal|0
decl_stmt|;
comment|/* Padding for number ('-', '_', or 0).  */
name|int
name|modifier
decl_stmt|;
comment|/* Field modifier ('E', 'O', or 0).  */
name|int
name|digits
decl_stmt|;
comment|/* Max digits for numeric format.  */
name|int
name|number_value
decl_stmt|;
comment|/* Numeric value to be printed.  */
name|int
name|negative_number
decl_stmt|;
comment|/* 1 if the number is negative.  */
specifier|const
name|CHAR_T
modifier|*
name|subfmt
decl_stmt|;
name|CHAR_T
modifier|*
name|bufp
decl_stmt|;
name|CHAR_T
name|buf
index|[
literal|1
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
condition|?
name|INT_STRLEN_BOUND
argument_list|(
name|time_t
argument_list|)
else|:
name|INT_STRLEN_BOUND
argument_list|(
name|int
argument_list|)
operator|)
index|]
decl_stmt|;
name|int
name|width
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|to_lowcase
init|=
literal|0
decl_stmt|;
name|int
name|to_uppcase
init|=
literal|0
decl_stmt|;
name|int
name|change_case
init|=
literal|0
decl_stmt|;
name|int
name|format_char
decl_stmt|;
if|#
directive|if
name|DO_MULTIBYTE
operator|&&
operator|!
name|defined
name|COMPILE_WIDE
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
name|L_
argument_list|(
literal|'%'
argument_list|)
case|:
break|break;
case|case
name|L_
argument_list|(
literal|'\b'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\t'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\n'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\v'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\f'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\r'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|' '
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'!'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'"'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'#'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'&'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\''
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'('
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|')'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'*'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'+'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|','
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'-'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'.'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'/'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'0'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'1'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'2'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'3'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'4'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'5'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'6'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'7'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'8'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'9'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|':'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|';'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'<'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'='
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'>'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'?'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'A'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'B'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'C'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'D'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'E'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'F'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'G'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'H'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'I'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'J'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'K'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'L'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'M'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'N'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'O'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'P'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'Q'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'R'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'S'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'T'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'U'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'V'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'W'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'X'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'Y'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'Z'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'['
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'\\'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|']'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'^'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'_'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'a'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'c'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'d'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'e'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'g'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'h'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'i'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'j'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'k'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'l'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'m'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'o'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'q'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'r'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'s'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'t'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'u'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'v'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'w'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'x'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'y'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'z'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'{'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'|'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'}'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'~'
argument_list|)
case|:
comment|/* The C Standard requires these 98 characters (plus '%') to 	     be in the basic execution character set.  None of these 	     characters can start a multibyte sequence, so they need 	     not be analyzed further.  */
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
operator|*
name|f
argument_list|)
expr_stmt|;
continue|continue;
default|default:
comment|/* Copy this multibyte sequence until we reach its end, find 	     an error, or come back to the initial shift state.  */
block|{
name|mbstate_t
name|mbstate
init|=
name|mbstate_zero
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
if|if
condition|(
operator|!
name|format_end
condition|)
name|format_end
operator|=
name|f
operator|+
name|strlen
argument_list|(
name|f
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fsize
operator|=
name|format_end
operator|-
name|f
expr_stmt|;
do|do
block|{
name|size_t
name|bytes
init|=
name|mbrlen
argument_list|(
name|f
operator|+
name|len
argument_list|,
name|fsize
operator|-
name|len
argument_list|,
operator|&
name|mbstate
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|bytes
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|f
operator|+
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bytes
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|len
operator|++
expr_stmt|;
break|break;
block|}
name|len
operator|+=
name|bytes
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|mbsinit
argument_list|(
operator|&
name|mbstate
argument_list|)
condition|)
do|;
name|cpy
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|f
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
else|#
directive|else
comment|/* ! DO_MULTIBYTE */
comment|/* Either multibyte encodings are not supported, they are 	 safe for formats, so any non-'%' byte can be copied through, 	 or this is the wide character version.  */
if|if
condition|(
operator|*
name|f
operator|!=
name|L_
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
operator|*
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* ! DO_MULTIBYTE */
comment|/* Check for flags that can modify a format.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|f
condition|)
block|{
comment|/* This influences the number formats.  */
case|case
name|L_
argument_list|(
literal|'_'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'-'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'0'
argument_list|)
case|:
name|pad
operator|=
operator|*
name|f
expr_stmt|;
continue|continue;
comment|/* This changes textual output.  */
case|case
name|L_
argument_list|(
literal|'^'
argument_list|)
case|:
name|to_uppcase
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|L_
argument_list|(
literal|'#'
argument_list|)
case|:
name|change_case
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* As a GNU extension we allow to specify the field width.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|f
argument_list|)
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|width
operator|>
name|INT_MAX
operator|/
literal|10
operator|||
operator|(
name|width
operator|==
name|INT_MAX
operator|/
literal|10
operator|&&
operator|*
name|f
operator|-
name|L_
argument_list|(
literal|'0'
argument_list|)
operator|>
name|INT_MAX
operator|%
literal|10
operator|)
condition|)
comment|/* Avoid overflow.  */
name|width
operator|=
name|INT_MAX
expr_stmt|;
else|else
block|{
name|width
operator|*=
literal|10
expr_stmt|;
name|width
operator|+=
operator|*
name|f
operator|-
name|L_
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
operator|++
name|f
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|f
argument_list|)
condition|)
do|;
block|}
comment|/* Check for modifiers.  */
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
name|L_
argument_list|(
literal|'E'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'O'
argument_list|)
case|:
name|modifier
operator|=
operator|*
name|f
operator|++
expr_stmt|;
break|break;
default|default:
name|modifier
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Now do the specified format.  */
name|format_char
operator|=
operator|*
name|f
expr_stmt|;
switch|switch
condition|(
name|format_char
condition|)
block|{
define|#
directive|define
name|DO_NUMBER
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|digits = d> width ? d : width;				      \ 	  number_value = v; goto do_number
define|#
directive|define
name|DO_NUMBER_SPACEPAD
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|digits = d> width ? d : width;				      \ 	  number_value = v; goto do_number_spacepad
case|case
name|L_
argument_list|(
literal|'%'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
operator|*
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|L_
argument_list|(
literal|'a'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|1
expr_stmt|;
name|to_lowcase
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|_NL_CURRENT
operator|||
operator|!
name|HAVE_STRFTIME
name|cpy
argument_list|(
name|aw_len
argument_list|,
name|a_wkday
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
case|case
literal|'A'
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|1
expr_stmt|;
name|to_lowcase
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|_NL_CURRENT
operator|||
operator|!
name|HAVE_STRFTIME
name|cpy
argument_list|(
name|STRLEN
argument_list|(
name|f_wkday
argument_list|)
argument_list|,
name|f_wkday
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'h'
argument_list|)
case|:
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|1
expr_stmt|;
name|to_lowcase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
if|#
directive|if
name|defined
name|_NL_CURRENT
operator|||
operator|!
name|HAVE_STRFTIME
name|cpy
argument_list|(
name|am_len
argument_list|,
name|a_month
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'B'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|1
expr_stmt|;
name|to_lowcase
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|_NL_CURRENT
operator|||
operator|!
name|HAVE_STRFTIME
name|cpy
argument_list|(
name|STRLEN
argument_list|(
name|f_month
argument_list|)
argument_list|,
name|f_month
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'c'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
ifdef|#
directive|ifdef
name|_NL_CURRENT
if|if
condition|(
operator|!
operator|(
name|modifier
operator|==
literal|'E'
operator|&&
operator|(
operator|*
operator|(
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|ERA_D_T_FMT
argument_list|)
argument_list|)
operator|)
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|D_T_FMT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
else|#
directive|else
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%a %b %e %H:%M:%S %Y"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|subformat
label|:
block|{
name|CHAR_T
modifier|*
name|old_start
init|=
name|p
decl_stmt|;
name|size_t
name|len
init|=
name|my_strftime
argument_list|(
argument|NULL
argument_list|,
argument|(size_t) -
literal|1
argument_list|,
argument|subfmt
argument_list|,
argument|tp extra_args LOCALE_ARG
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|len
argument_list|,
name|my_strftime
argument_list|(
argument|p
argument_list|,
argument|maxsize - i
argument_list|,
argument|subfmt
argument_list|,
argument|tp extra_args LOCALE_ARG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_uppcase
condition|)
while|while
condition|(
name|old_start
operator|<
name|p
condition|)
block|{
operator|*
name|old_start
operator|=
name|TOUPPER
argument_list|(
operator|(
name|UCHAR_T
operator|)
operator|*
name|old_start
argument_list|,
name|loc
argument_list|)
expr_stmt|;
operator|++
name|old_start
expr_stmt|;
block|}
block|}
break|break;
if|#
directive|if
name|HAVE_STRFTIME
operator|&&
operator|!
operator|(
name|defined
name|_NL_CURRENT
operator|&&
name|HAVE_STRUCT_ERA_ENTRY
operator|)
name|underlying_strftime
label|:
block|{
comment|/* The relevant information is available only via the 	       underlying strftime implementation, so use that.  */
name|char
name|ufmt
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|u
init|=
name|ufmt
decl_stmt|;
name|char
name|ubuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* enough for any single format in practice */
name|size_t
name|len
decl_stmt|;
comment|/* Make sure we're calling the actual underlying strftime. 	       In some cases, config.h contains something like 	       "#define strftime rpl_strftime".  */
ifdef|#
directive|ifdef
name|strftime
undef|#
directive|undef
name|strftime
name|size_t
name|strftime
parameter_list|()
function_decl|;
endif|#
directive|endif
operator|*
name|u
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
operator|*
name|u
operator|++
operator|=
name|modifier
expr_stmt|;
operator|*
name|u
operator|++
operator|=
name|format_char
expr_stmt|;
operator|*
name|u
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strftime
argument_list|(
name|ubuf
argument_list|,
sizeof|sizeof
name|ubuf
argument_list|,
name|ufmt
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|ubuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|cpy
argument_list|(
name|len
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'C'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|#
directive|if
name|HAVE_STRUCT_ERA_ENTRY
name|struct
name|era_entry
modifier|*
name|era
init|=
name|_nl_get_era_entry
argument_list|(
argument|tp HELPER_LOCALE_ARG
argument_list|)
decl_stmt|;
if|if
condition|(
name|era
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_WIDE
name|size_t
name|len
init|=
name|__wcslen
argument_list|(
name|era
operator|->
name|era_wname
argument_list|)
decl_stmt|;
name|cpy
argument_list|(
name|len
argument_list|,
name|era
operator|->
name|era_wname
argument_list|)
expr_stmt|;
else|#
directive|else
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|era
operator|->
name|era_name
argument_list|)
decl_stmt|;
name|cpy
argument_list|(
name|len
argument_list|,
name|era
operator|->
name|era_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|{
name|int
name|year
init|=
name|tp
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
decl_stmt|;
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
name|year
operator|/
literal|100
operator|-
operator|(
name|year
operator|%
literal|100
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
case|case
name|L_
argument_list|(
literal|'x'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
ifdef|#
directive|ifdef
name|_NL_CURRENT
if|if
condition|(
operator|!
operator|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
operator|&&
operator|(
operator|*
operator|(
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|ERA_D_FMT
argument_list|)
argument_list|)
operator|)
operator|!=
name|L_
argument_list|(
literal|'\0'
argument_list|)
operator|)
operator|)
condition|)
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|D_FMT
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
else|#
directive|else
comment|/* Fall through.  */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'D'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%m/%d/%y"
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
case|case
name|L_
argument_list|(
literal|'d'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'e'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER_SPACEPAD
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
comment|/* All numeric formats set DIGITS and NUMBER_VALUE and then 	     jump to one of these two labels.  */
name|do_number_spacepad
label|:
comment|/* Force `_' flag unless overridden by `0' or `-' flag.  */
if|if
condition|(
name|pad
operator|!=
name|L_
argument_list|(
literal|'0'
argument_list|)
operator|&&
name|pad
operator|!=
name|L_
argument_list|(
literal|'-'
argument_list|)
condition|)
name|pad
operator|=
name|L_
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|do_number
label|:
comment|/* Format the number according to the MODIFIER flag.  */
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
operator|&&
literal|0
operator|<=
name|number_value
condition|)
block|{
ifdef|#
directive|ifdef
name|_NL_CURRENT
comment|/* Get the locale specific alternate representation of 		 the number NUMBER_VALUE.  If none exist NULL is returned.  */
specifier|const
name|CHAR_T
modifier|*
name|cp
init|=
name|nl_get_alt_digit
argument_list|(
argument|number_value 						   HELPER_LOCALE_ARG
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|digitlen
init|=
name|STRLEN
argument_list|(
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|digitlen
operator|!=
literal|0
condition|)
block|{
name|cpy
argument_list|(
name|digitlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|{
name|unsigned
name|int
name|u
init|=
name|number_value
decl_stmt|;
name|bufp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|negative_number
operator|=
name|number_value
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|negative_number
condition|)
name|u
operator|=
operator|-
name|u
expr_stmt|;
do|do
operator|*
operator|--
name|bufp
operator|=
name|u
operator|%
literal|10
operator|+
name|L_
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|u
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
name|do_number_sign_and_padding
label|:
if|if
condition|(
name|negative_number
condition|)
operator|*
operator|--
name|bufp
operator|=
name|L_
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
name|L_
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|int
name|padding
init|=
name|digits
operator|-
operator|(
name|buf
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
name|bufp
operator|)
decl_stmt|;
if|if
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pad
operator|==
name|L_
argument_list|(
literal|'_'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|padding
operator|>=
name|maxsize
operator|-
name|i
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
condition|)
name|memset_space
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|i
operator|+=
name|padding
expr_stmt|;
name|width
operator|=
name|width
operator|>
name|padding
condition|?
name|width
operator|-
name|padding
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|digits
operator|>=
name|maxsize
operator|-
name|i
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|negative_number
condition|)
block|{
operator|++
name|bufp
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
name|L_
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|memset_zero
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|i
operator|+=
name|padding
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|cpy
argument_list|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|-
name|bufp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
break|break;
case|case
name|L_
argument_list|(
literal|'F'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|!=
literal|0
condition|)
goto|goto
name|bad_format
goto|;
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%Y-%m-%d"
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
case|case
name|L_
argument_list|(
literal|'H'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'I'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|hour12
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'k'
argument_list|)
case|:
comment|/* GNU extension.  */
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER_SPACEPAD
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'l'
argument_list|)
case|:
comment|/* GNU extension.  */
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER_SPACEPAD
argument_list|(
literal|2
argument_list|,
name|hour12
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'j'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|3
argument_list|,
literal|1
operator|+
name|tp
operator|->
name|tm_yday
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'M'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'m'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_LIBC
case|case
name|L_
argument_list|(
literal|'N'
argument_list|)
case|:
comment|/* GNU extension.  */
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|number_value
operator|=
name|ns
expr_stmt|;
if|if
condition|(
name|width
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Take an explicit width less than 9 as a precision.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|width
init|;
name|j
operator|<
literal|9
condition|;
name|j
operator|++
control|)
name|number_value
operator|/=
literal|10
expr_stmt|;
block|}
name|DO_NUMBER
argument_list|(
literal|9
argument_list|,
name|number_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'n'
argument_list|)
case|:
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
name|L_
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|L_
argument_list|(
literal|'P'
argument_list|)
case|:
name|to_lowcase
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
name|_NL_CURRENT
operator|&&
name|HAVE_STRFTIME
name|format_char
operator|=
name|L_
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|L_
argument_list|(
literal|'p'
argument_list|)
case|:
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|0
expr_stmt|;
name|to_lowcase
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|_NL_CURRENT
operator|||
operator|!
name|HAVE_STRFTIME
name|cpy
argument_list|(
name|ap_len
argument_list|,
name|ampm
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'R'
argument_list|)
case|:
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%H:%M"
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
case|case
name|L_
argument_list|(
literal|'r'
argument_list|)
case|:
if|#
directive|if
operator|!
name|defined
name|_NL_CURRENT
operator|&&
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_NL_CURRENT
if|if
condition|(
operator|*
operator|(
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|T_FMT_AMPM
argument_list|)
argument_list|)
operator|)
operator|==
name|L_
argument_list|(
literal|'\0'
argument_list|)
condition|)
endif|#
directive|endif
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%I:%M:%S %p"
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'S'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|tp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'s'
argument_list|)
case|:
comment|/* GNU extension.  */
block|{
name|struct
name|tm
name|ltm
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|ltm
operator|=
operator|*
name|tp
expr_stmt|;
name|t
operator|=
name|mktime
argument_list|(
operator|&
name|ltm
argument_list|)
expr_stmt|;
comment|/* Generate string value for T using time_t arithmetic; 	       this works even if sizeof (long)< sizeof (time_t).  */
name|bufp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|negative_number
operator|=
name|t
operator|<
literal|0
expr_stmt|;
do|do
block|{
name|int
name|d
init|=
name|t
operator|%
literal|10
decl_stmt|;
name|t
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|negative_number
condition|)
block|{
name|d
operator|=
operator|-
name|d
expr_stmt|;
comment|/* Adjust if division truncates to minus infinity.  */
if|if
condition|(
literal|0
operator|<
operator|-
literal|1
operator|%
literal|10
operator|&&
name|d
operator|<
literal|0
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|d
operator|+=
literal|10
expr_stmt|;
block|}
block|}
operator|*
operator|--
name|bufp
operator|=
name|d
operator|+
name|L_
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
literal|0
condition|)
do|;
name|digits
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_number_sign_and_padding
goto|;
block|}
case|case
name|L_
argument_list|(
literal|'X'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
ifdef|#
directive|ifdef
name|_NL_CURRENT
if|if
condition|(
operator|!
operator|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
operator|&&
operator|(
operator|*
operator|(
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|ERA_T_FMT
argument_list|)
argument_list|)
operator|)
operator|!=
name|L_
argument_list|(
literal|'\0'
argument_list|)
operator|)
operator|)
condition|)
name|subfmt
operator|=
operator|(
specifier|const
name|CHAR_T
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_TIME
argument_list|,
name|NLW
argument_list|(
name|T_FMT
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
else|#
directive|else
comment|/* Fall through.  */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|L_
argument_list|(
literal|'T'
argument_list|)
case|:
name|subfmt
operator|=
name|L_
argument_list|(
literal|"%H:%M:%S"
argument_list|)
expr_stmt|;
goto|goto
name|subformat
goto|;
case|case
name|L_
argument_list|(
literal|'t'
argument_list|)
case|:
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
name|L_
argument_list|(
literal|'\t'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|L_
argument_list|(
literal|'u'
argument_list|)
case|:
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
operator|(
name|tp
operator|->
name|tm_wday
operator|-
literal|1
operator|+
literal|7
operator|)
operator|%
literal|7
operator|+
literal|1
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'U'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
operator|(
name|tp
operator|->
name|tm_yday
operator|-
name|tp
operator|->
name|tm_wday
operator|+
literal|7
operator|)
operator|/
literal|7
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'V'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'g'
argument_list|)
case|:
case|case
name|L_
argument_list|(
literal|'G'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
block|{
name|int
name|year
init|=
name|tp
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
decl_stmt|;
name|int
name|days
init|=
name|iso_week_days
argument_list|(
name|tp
operator|->
name|tm_yday
argument_list|,
name|tp
operator|->
name|tm_wday
argument_list|)
decl_stmt|;
if|if
condition|(
name|days
operator|<
literal|0
condition|)
block|{
comment|/* This ISO week belongs to the previous year.  */
name|year
operator|--
expr_stmt|;
name|days
operator|=
name|iso_week_days
argument_list|(
name|tp
operator|->
name|tm_yday
operator|+
operator|(
literal|365
operator|+
name|__isleap
argument_list|(
name|year
argument_list|)
operator|)
argument_list|,
name|tp
operator|->
name|tm_wday
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|d
init|=
name|iso_week_days
argument_list|(
name|tp
operator|->
name|tm_yday
operator|-
operator|(
literal|365
operator|+
name|__isleap
argument_list|(
name|year
argument_list|)
operator|)
argument_list|,
name|tp
operator|->
name|tm_wday
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|d
condition|)
block|{
comment|/* This ISO week belongs to the next year.  */
name|year
operator|++
expr_stmt|;
name|days
operator|=
name|d
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
name|L_
argument_list|(
literal|'g'
argument_list|)
case|:
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
operator|(
name|year
operator|%
literal|100
operator|+
literal|100
operator|)
operator|%
literal|100
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'G'
argument_list|)
case|:
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
name|year
argument_list|)
expr_stmt|;
default|default:
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
name|days
operator|/
literal|7
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|L_
argument_list|(
literal|'W'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
operator|(
name|tp
operator|->
name|tm_yday
operator|-
operator|(
name|tp
operator|->
name|tm_wday
operator|-
literal|1
operator|+
literal|7
operator|)
operator|%
literal|7
operator|+
literal|7
operator|)
operator|/
literal|7
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'w'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
name|tp
operator|->
name|tm_wday
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'Y'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
literal|'E'
condition|)
block|{
if|#
directive|if
name|HAVE_STRUCT_ERA_ENTRY
name|struct
name|era_entry
modifier|*
name|era
init|=
name|_nl_get_era_entry
argument_list|(
argument|tp HELPER_LOCALE_ARG
argument_list|)
decl_stmt|;
if|if
condition|(
name|era
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_WIDE
name|subfmt
operator|=
name|era
operator|->
name|era_wformat
expr_stmt|;
else|#
directive|else
name|subfmt
operator|=
name|era
operator|->
name|era_format
expr_stmt|;
endif|#
directive|endif
goto|goto
name|subformat
goto|;
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'O'
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
else|else
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
name|tp
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'y'
argument_list|)
case|:
if|if
condition|(
name|modifier
operator|==
name|L_
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|#
directive|if
name|HAVE_STRUCT_ERA_ENTRY
name|struct
name|era_entry
modifier|*
name|era
init|=
name|_nl_get_era_entry
argument_list|(
argument|tp HELPER_LOCALE_ARG
argument_list|)
decl_stmt|;
if|if
condition|(
name|era
condition|)
block|{
name|int
name|delta
init|=
name|tp
operator|->
name|tm_year
operator|-
name|era
operator|->
name|start_date
index|[
literal|0
index|]
decl_stmt|;
name|DO_NUMBER
argument_list|(
literal|1
argument_list|,
operator|(
name|era
operator|->
name|offset
operator|+
name|delta
operator|*
name|era
operator|->
name|absolute_direction
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_STRFTIME
goto|goto
name|underlying_strftime
goto|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|DO_NUMBER
argument_list|(
literal|2
argument_list|,
operator|(
name|tp
operator|->
name|tm_year
operator|%
literal|100
operator|+
literal|100
operator|)
operator|%
literal|100
argument_list|)
expr_stmt|;
case|case
name|L_
argument_list|(
literal|'Z'
argument_list|)
case|:
if|if
condition|(
name|change_case
condition|)
block|{
name|to_uppcase
operator|=
literal|0
expr_stmt|;
name|to_lowcase
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_TZNAME
comment|/* The tzset() call might have changed the value.  */
if|if
condition|(
operator|!
operator|(
name|zone
operator|&&
operator|*
name|zone
operator|)
operator|&&
name|tp
operator|->
name|tm_isdst
operator|>=
literal|0
condition|)
name|zone
operator|=
name|tzname
index|[
name|tp
operator|->
name|tm_isdst
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|zone
condition|)
name|zone
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_WIDE
block|{
comment|/* The zone string is always given in multibyte form.  We have 	       to transform it first.  */
name|wchar_t
modifier|*
name|wczone
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|widen
argument_list|(
name|zone
argument_list|,
name|wczone
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cpy
argument_list|(
name|len
argument_list|,
name|wczone
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cpy
argument_list|(
name|strlen
argument_list|(
name|zone
argument_list|)
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|L_
argument_list|(
literal|'z'
argument_list|)
case|:
if|if
condition|(
name|tp
operator|->
name|tm_isdst
operator|<
literal|0
condition|)
break|break;
block|{
name|int
name|diff
decl_stmt|;
if|#
directive|if
name|HAVE_TM_GMTOFF
name|diff
operator|=
name|tp
operator|->
name|tm_gmtoff
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ut
condition|)
name|diff
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|tm
name|gtm
decl_stmt|;
name|struct
name|tm
name|ltm
decl_stmt|;
name|time_t
name|lt
decl_stmt|;
name|ltm
operator|=
operator|*
name|tp
expr_stmt|;
name|lt
operator|=
name|mktime
argument_list|(
operator|&
name|ltm
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* mktime returns -1 for errors, but -1 is also a 		       valid time_t value.  Check whether an error really 		       occurred.  */
name|struct
name|tm
name|tm
decl_stmt|;
if|if
condition|(
operator|!
name|__localtime_r
argument_list|(
operator|&
name|lt
argument_list|,
operator|&
name|tm
argument_list|)
operator|||
operator|(
operator|(
name|ltm
operator|.
name|tm_sec
operator|^
name|tm
operator|.
name|tm_sec
operator|)
operator||
operator|(
name|ltm
operator|.
name|tm_min
operator|^
name|tm
operator|.
name|tm_min
operator|)
operator||
operator|(
name|ltm
operator|.
name|tm_hour
operator|^
name|tm
operator|.
name|tm_hour
operator|)
operator||
operator|(
name|ltm
operator|.
name|tm_mday
operator|^
name|tm
operator|.
name|tm_mday
operator|)
operator||
operator|(
name|ltm
operator|.
name|tm_mon
operator|^
name|tm
operator|.
name|tm_mon
operator|)
operator||
operator|(
name|ltm
operator|.
name|tm_year
operator|^
name|tm
operator|.
name|tm_year
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|__gmtime_r
argument_list|(
operator|&
name|lt
argument_list|,
operator|&
name|gtm
argument_list|)
condition|)
break|break;
name|diff
operator|=
name|tm_diff
argument_list|(
operator|&
name|ltm
argument_list|,
operator|&
name|gtm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
name|L_
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
block|}
else|else
name|add
argument_list|(
literal|1
argument_list|,
operator|*
name|p
operator|=
name|L_
argument_list|(
literal|'+'
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|/=
literal|60
expr_stmt|;
name|DO_NUMBER
argument_list|(
literal|4
argument_list|,
operator|(
name|diff
operator|/
literal|60
operator|)
operator|*
literal|100
operator|+
name|diff
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
case|case
name|L_
argument_list|(
literal|'\0'
argument_list|)
case|:
comment|/* GNU extension: % at end of format.  */
operator|--
name|f
expr_stmt|;
comment|/* Fall through.  */
default|default:
comment|/* Unknown format; output the format, including the '%', 	     since this is most likely the right thing to do if a 	     multibyte string has been misparsed.  */
name|bad_format
label|:
block|{
name|int
name|flen
decl_stmt|;
for|for
control|(
name|flen
operator|=
literal|1
init|;
name|f
index|[
literal|1
operator|-
name|flen
index|]
operator|!=
name|L_
argument_list|(
literal|'%'
argument_list|)
condition|;
name|flen
operator|++
control|)
continue|continue;
name|cpy
argument_list|(
name|flen
argument_list|,
operator|&
name|f
index|[
literal|1
operator|-
name|flen
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|p
operator|&&
name|maxsize
operator|!=
literal|0
condition|)
operator|*
name|p
operator|=
name|L_
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|i
return|;
end_return

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_expr_stmt
unit|libc_hidden_def
operator|(
name|my_strftime
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|emacs
comment|/* For Emacs we have a separate interface which corresponds to the normal    strftime function plus the ut argument, but without the ns argument.  */
name|size_t
name|emacs_strftimeu
argument_list|(
argument|char *s
argument_list|,
argument|size_t maxsize
argument_list|,
argument|const char *format
argument_list|,
argument|const struct tm *tp
argument_list|,
argument|int ut
argument_list|)
block|{
return|return
name|my_strftime
argument_list|(
name|s
argument_list|,
name|maxsize
argument_list|,
name|format
argument_list|,
name|tp
argument_list|,
name|ut
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

