begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: configfile.c,v 1.21 2007/04/15 19:01:18 bkorb Exp $  *  Time-stamp:      "2007-04-15 11:22:46 bkorb"  *  *  configuration/rc/ini file handling.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|void
name|filePreset
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzFileName
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handleComment
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handleConfig
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handleDirective
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handleProgramSection
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handleStructure
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parseKeyWordType
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parseLoadMode
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionLoadMode
modifier|*
name|pMode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parseSetMemType
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parseValueType
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skipUnknown
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*=export_func  configFileLoad  *  * what:  parse a configuration file  * arg:   + char const*     + pzFile + the file to load +  *  * ret_type:  const tOptionValue*  * ret_desc:  An allocated, compound value structure  *  * doc:  *  This routine will load a named configuration file and parse the  *  text as a hierarchically valued option.  The option descriptor  *  created from an option definition file is not used via this interface.  *  The returned value is "named" with the input file name and is of  *  type "@code{OPARG_TYPE_HIERARCHY}".  It may be used in calls to  *  @code{optionGetValue()}, @code{optionNextValue()} and  *  @code{optionUnloadNested()}.  *  * err:  *  If the file cannot be loaded or processed, @code{NULL} is returned and  *  @var{errno} is set.  It may be set by a call to either @code{open(2)}  *  @code{mmap(2)} or other file system calls, or it may be:  *  @itemize @bullet  *  @item  *  @code{ENOENT} - the file was empty.  *  @item  *  @code{EINVAL} - the file contents are invalid -- not properly formed.  *  @item  *  @code{ENOMEM} - not enough memory to allocate the needed structures.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|configFileLoad
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
name|tOptionLoadMode
name|save_mode
init|=
name|option_load_mode
decl_stmt|;
name|char
modifier|*
name|pzText
init|=
name|text_mmap
argument_list|(
name|pzFile
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|pzText
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* errno is set */
name|option_load_mode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
name|pRes
operator|=
name|optionLoadNested
argument_list|(
name|pzText
argument_list|,
name|pzFile
argument_list|,
name|strlen
argument_list|(
name|pzFile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
block|}
else|else
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|option_load_mode
operator|=
name|save_mode
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindValue  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + pOptDesc + an option with a nested arg type +  * arg:   + char const*     + name     + name of value to find +  * arg:   + char const*     + value    + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  It will search through the list and return a matching entry.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionFindValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzVal
parameter_list|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOptDesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|pAL
init|=
name|pOptDesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|ppOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|ppOV
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|ppOV
operator|++
operator|)
decl_stmt|;
specifier|const
name|tOptionValue
modifier|*
name|pRV
init|=
name|optionGetValue
argument_list|(
name|pOV
argument_list|,
name|pzName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pRV
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|pzVal
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindNextValue  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + pOptDesc + an option with a nested arg type +  * arg:   + const tOptionValue* + pPrevVal + the last entry +  * arg:   + char const*     + name     + name of value to find +  * arg:   + char const*     + value    + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find the next entry in a nested value option or  *  configurable.  It will search through the list and return the next entry  *  that matches the criteria.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionFindNextValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
name|pPrevVal
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzVal
parameter_list|)
block|{
name|int
name|foundOldVal
init|=
literal|0
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOptDesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|pAL
init|=
name|pOptDesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|ppOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|pAL
operator|->
name|apzArgs
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|ppOV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|foundOldVal
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pOV
operator|==
name|pPrevVal
condition|)
name|foundOldVal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionGetValue  *  * what:  get a specific value from a hierarcical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal value +  * arg:   + char const*   + valueName + name of value to get +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  If "valueName" is NULL, then the first entry is returned.  Otherwise,  *  the first entry with a name that exactly matches the argument will be  *  returned.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionGetValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
name|pOld
parameter_list|,
name|char
specifier|const
modifier|*
name|pzValName
parameter_list|)
block|{
name|tArgList
modifier|*
name|pAL
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOld
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOld
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pAL
operator|=
name|pOld
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
if|if
condition|(
name|pAL
operator|->
name|useCt
operator|>
literal|0
condition|)
block|{
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|papOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|pzValName
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|papOV
expr_stmt|;
block|}
else|else
do|do
block|{
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|papOV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pOV
operator|->
name|pzName
argument_list|,
name|pzValName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionNextValue  *  * what:  get the next value from a hierarchical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal list value +  * arg:   + const tOptionValue* + pOldValue + a value from this list   +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will return the next entry after the entry passed in.  At the  *  end of the list, NULL will be returned.  If the entry is not found on the  *  list, NULL will be returned and "@var{errno}" will be set to EINVAL.  *  The "@var{pOldValue}" must have been gotten from a prior call to this  *  routine or to "@code{opitonGetValue()}".  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value or @code{pOldValue} does not point to a  *  member of that option value.  *  @item  *  @code{ENOENT} - the supplied @code{pOldValue} pointed to the last entry.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionNextValue
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
name|pOVList
parameter_list|,
name|tOptionValue
specifier|const
modifier|*
name|pOldOV
parameter_list|)
block|{
name|tArgList
modifier|*
name|pAL
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
operator|(
name|pOVList
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOVList
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pAL
operator|=
name|pOVList
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
block|{
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|papNV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
while|while
condition|(
name|ct
operator|--
operator|>
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|pNV
init|=
operator|*
operator|(
name|papNV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|pNV
operator|==
name|pOldOV
condition|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|papNV
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*  filePreset  *  *  Load a file containing presetting information (a configuration file).  */
end_comment

begin_function
specifier|static
name|void
name|filePreset
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzFileName
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptState
name|st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pzFileText
init|=
name|text_mmap
argument_list|(
name|pzFileName
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|pzFileText
argument_list|)
condition|)
return|return;
if|if
condition|(
name|direction
operator|==
name|DIRECTION_CALLED
condition|)
block|{
name|st
operator|.
name|flags
operator|=
name|OPTST_DEFINED
expr_stmt|;
name|direction
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
comment|/*      *  IF this is called via "optionProcess", then we are presetting.      *  This is the default and the PRESETTING bit will be set.      *  If this is called via "optionFileLoad", then the bit is not set      *  and we consider stuff set herein to be "set" by the client program.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|==
literal|0
condition|)
name|st
operator|.
name|flags
operator|=
name|OPTST_SET
expr_stmt|;
do|do
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzFileText
argument_list|)
condition|)
name|pzFileText
operator|++
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzFileText
argument_list|)
condition|)
block|{
name|pzFileText
operator|=
name|handleConfig
argument_list|(
name|pOpts
argument_list|,
operator|&
name|st
argument_list|,
name|pzFileText
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|pzFileText
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|int
operator|)
name|pzFileText
index|[
literal|1
index|]
argument_list|)
condition|)
name|pzFileText
operator|=
name|handleStructure
argument_list|(
name|pOpts
argument_list|,
operator|&
name|st
argument_list|,
name|pzFileText
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|pzFileText
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|pzFileText
operator|=
name|handleDirective
argument_list|(
name|pOpts
argument_list|,
name|pzFileText
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|pzFileText
operator|=
name|handleComment
argument_list|(
name|pzFileText
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|pzFileText
operator|=
name|strchr
argument_list|(
name|pzFileText
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzFileText
operator|++
operator|!=
name|NULL
condition|)
break|break;
default|default:
goto|goto
name|all_done
goto|;
block|}
break|break;
case|case
literal|'['
case|:
name|pzFileText
operator|=
name|handleProgramSection
argument_list|(
name|pOpts
argument_list|,
name|pzFileText
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|pzFileText
operator|=
name|strchr
argument_list|(
name|pzFileText
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|all_done
goto|;
comment|/* invalid format */
block|}
block|}
do|while
condition|(
name|pzFileText
operator|!=
name|NULL
condition|)
do|;
name|all_done
label|:
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  handleComment  *  *  "pzText" points to a "<!" sequence.  *  Theoretically, we should ensure that it begins with "<!--",  *  but actually I don't care that much.  It ends with "-->".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handleComment
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|strstr
argument_list|(
name|pzText
argument_list|,
literal|"-->"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
name|pz
operator|+=
literal|3
expr_stmt|;
return|return
name|pz
return|;
block|}
end_function

begin_comment
comment|/*  handleConfig  *  *  "pzText" points to the start of some value name.  *  The end of the entry is the end of the line that is not preceded by  *  a backslash escape character.  The string value is always processed  *  in "cooked" mode.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handleConfig
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|char
modifier|*
name|pzName
init|=
name|pzText
operator|++
decl_stmt|;
name|char
modifier|*
name|pzEnd
init|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pzEnd
operator|==
name|NULL
condition|)
return|return
name|pzText
operator|+
name|strlen
argument_list|(
name|pzText
argument_list|)
return|;
while|while
condition|(
name|ISNAMECHAR
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
if|if
condition|(
name|pzText
operator|>
name|pzEnd
condition|)
block|{
name|name_only
label|:
operator|*
name|pzEnd
operator|++
operator|=
name|NUL
expr_stmt|;
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|direction
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
comment|/*      *  Either the first character after the name is a ':' or '=',      *  or else we must have skipped over white space.  Anything else      *  is an invalid format and we give up parsing the text.      */
if|if
condition|(
operator|(
operator|*
name|pzText
operator|==
literal|'='
operator|)
operator|||
operator|(
operator|*
name|pzText
operator|==
literal|':'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|++
name|pzText
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|pzText
operator|>
name|pzEnd
condition|)
goto|goto
name|name_only
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*      *  IF the value is continued, remove the backslash escape and push "pzEnd"      *  on to a newline *not* preceded by a backslash.      */
if|if
condition|(
name|pzEnd
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|pcD
init|=
name|pzEnd
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pcS
init|=
name|pzEnd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|pcS
operator|++
operator|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
name|pcS
operator|=
name|NULL
expr_stmt|;
case|case
literal|'\n'
case|:
operator|*
name|pcD
operator|=
name|NUL
expr_stmt|;
name|pzEnd
operator|=
name|pcS
expr_stmt|;
goto|goto
name|copy_done
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|pcS
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
operator|*
operator|(
name|pcS
operator|++
operator|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
operator|*
operator|(
name|pcD
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|copy_done
label|:
empty_stmt|;
block|}
else|else
block|{
comment|/*          *  The newline was not preceded by a backslash.  NUL it out          */
operator|*
operator|(
name|pzEnd
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
block|}
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|direction
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
end_function

begin_comment
comment|/*  handleDirective  *  *  "pzText" points to a "<?" sequence.  *  For the moment, we only handle "<?program" directives.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handleDirective
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|char
name|ztitle
index|[
literal|32
index|]
init|=
literal|"<?"
decl_stmt|;
name|size_t
name|title_len
init|=
name|strlen
argument_list|(
name|zProg
argument_list|)
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|pzText
operator|+
literal|2
argument_list|,
name|zProg
argument_list|,
name|title_len
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|title_len
operator|+
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|++
expr_stmt|;
return|return
name|pzText
return|;
block|}
name|name_len
operator|=
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ztitle
operator|+
literal|2
argument_list|,
name|zProg
argument_list|)
expr_stmt|;
name|title_len
operator|+=
literal|2
expr_stmt|;
do|do
block|{
name|pzText
operator|+=
name|title_len
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzText
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|strneqvcmp
argument_list|(
name|pzText
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
operator|(
name|int
operator|)
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pzText
index|[
name|name_len
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
name|pzText
operator|+=
name|name_len
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|pzText
operator|=
name|strstr
argument_list|(
name|pzText
argument_list|,
name|ztitle
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pzText
operator|!=
name|NULL
condition|)
do|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/*  handleProgramSection  *  *  "pzText" points to a '[' character.  *  The "traditional" [PROG_NAME] segmentation of the config file.  *  Do not ever mix with the "<?program prog-name>" variation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handleProgramSection
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|pzText
operator|+
literal|1
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pzText
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|']'
operator|)
condition|)
return|return
name|strchr
argument_list|(
name|pzText
operator|+
name|len
operator|+
literal|2
argument_list|,
literal|'\n'
argument_list|)
return|;
if|if
condition|(
name|len
operator|>
literal|16
condition|)
return|return
name|NULL
return|;
block|{
name|char
name|z
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"[%s]"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|pzText
operator|=
name|strstr
argument_list|(
name|pzText
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/*  handleStructure  *  *  "pzText" points to a '<' character, followed by an alpha.  *  The end of the entry is either the "/>" following the name, or else a  *  "</name>" string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handleStructure
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|tOptionLoadMode
name|mode
init|=
name|option_load_mode
decl_stmt|;
name|tOptionValue
name|valu
decl_stmt|;
name|char
modifier|*
name|pzName
init|=
operator|++
name|pzText
decl_stmt|;
name|char
modifier|*
name|pzData
decl_stmt|;
name|char
modifier|*
name|pcNulPoint
decl_stmt|;
while|while
condition|(
name|ISNAMECHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
name|pcNulPoint
operator|=
name|pzText
expr_stmt|;
name|valu
operator|.
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
switch|switch
condition|(
operator|*
name|pzText
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|pzText
operator|=
name|parseAttributes
argument_list|(
name|pOpts
argument_list|,
name|pzText
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzText
operator|==
literal|'>'
condition|)
break|break;
if|if
condition|(
operator|*
name|pzText
operator|!=
literal|'/'
condition|)
return|return
name|NULL
return|;
comment|/* FALLTHROUGH */
case|case
literal|'/'
case|:
if|if
condition|(
name|pzText
index|[
literal|1
index|]
operator|!=
literal|'>'
condition|)
return|return
name|NULL
return|;
operator|*
name|pzText
operator|=
name|NUL
expr_stmt|;
name|pzText
operator|+=
literal|2
expr_stmt|;
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
case|case
literal|'>'
case|:
break|break;
default|default:
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|++
expr_stmt|;
return|return
name|pzText
return|;
block|}
comment|/*      *  If we are here, we have a value.  "pzText" points to a closing angle      *  bracket.  Separate the name from the value for a moment.      */
operator|*
name|pcNulPoint
operator|=
name|NUL
expr_stmt|;
name|pzData
operator|=
operator|++
name|pzText
expr_stmt|;
comment|/*      *  Find the end of the option text and NUL terminate it      */
block|{
name|char
name|z
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|pz
init|=
name|z
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pzName
argument_list|)
operator|+
literal|4
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|z
argument_list|)
condition|)
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"scan name"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pz
argument_list|,
literal|"</%s>"
argument_list|,
name|pzName
argument_list|)
expr_stmt|;
operator|*
name|pzText
operator|=
literal|' '
expr_stmt|;
name|pzText
operator|=
name|strstr
argument_list|(
name|pzText
argument_list|,
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
operator|!=
name|z
condition|)
name|AGFREE
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|==
name|NULL
condition|)
return|return
name|pzText
return|;
operator|*
name|pzText
operator|=
name|NUL
expr_stmt|;
name|pzText
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
comment|/*      *  Rejoin the name and value for parsing by "loadOptionLine()".      *  Erase any attributes parsed by "parseAttributes()".      */
name|memset
argument_list|(
name|pcNulPoint
argument_list|,
literal|' '
argument_list|,
name|pzData
operator|-
name|pcNulPoint
argument_list|)
expr_stmt|;
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/*  internalFileLoad  *  *  Load a configuration file.  This may be invoked either from  *  scanning the "homerc" list, or from a specific file request.  *  (see "optionFileLoad()", the implementation for --load-opts)  */
end_comment

begin_function
name|LOCAL
name|void
name|internalFileLoad
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|inc
init|=
name|DIRECTION_PRESET
decl_stmt|;
name|char
name|zFileName
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|pOpts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
return|return;
comment|/*      *  Find the last RC entry (highest priority entry)      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|pOpts
operator|->
name|papzHomeList
index|[
name|idx
operator|+
literal|1
index|]
operator|!=
name|NULL
condition|;
operator|++
name|idx
control|)
empty_stmt|;
comment|/*      *  For every path in the home list, ...  *TWICE* We start at the last      *  (highest priority) entry, work our way down to the lowest priority,      *  handling the immediate options.      *  Then we go back up, doing the normal options.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|stat
name|StatBuf
decl_stmt|;
name|cch_t
modifier|*
name|pzPath
decl_stmt|;
comment|/*          *  IF we've reached the bottom end, change direction          */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
name|pzPath
operator|=
name|pOpts
operator|->
name|papzHomeList
index|[
name|idx
index|]
expr_stmt|;
comment|/*          *  IF we've reached the top end, bail out          */
if|if
condition|(
name|pzPath
operator|==
name|NULL
condition|)
break|break;
name|idx
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
operator|!
name|optionMakePath
argument_list|(
name|zFileName
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zFileName
argument_list|)
argument_list|,
name|pzPath
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|)
condition|)
continue|continue;
comment|/*          *  IF the file name we constructed is a directory,          *  THEN append the Resource Configuration file name          *  ELSE we must have the complete file name          */
if|if
condition|(
name|stat
argument_list|(
name|zFileName
argument_list|,
operator|&
name|StatBuf
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* bogus name - skip the home list entry */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|StatBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zFileName
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzRcName
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|zFileName
argument_list|)
condition|)
continue|continue;
name|pz
operator|=
name|zFileName
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|pz
index|[
operator|-
literal|1
index|]
operator|!=
name|DIRCH
condition|)
operator|*
operator|(
name|pz
operator|++
operator|)
operator|=
name|DIRCH
expr_stmt|;
name|strcpy
argument_list|(
name|pz
argument_list|,
name|pOpts
operator|->
name|pzRcName
argument_list|)
expr_stmt|;
block|}
name|filePreset
argument_list|(
name|pOpts
argument_list|,
name|zFileName
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/*          *  IF we are now to skip config files AND we are presetting,          *  THEN change direction.  We must go the other way.          */
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
name|PRESETTING
argument_list|(
name|inc
argument_list|)
condition|)
block|{
name|idx
operator|-=
name|inc
expr_stmt|;
comment|/* go back and reprocess current file */
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
block|}
block|}
comment|/* twice for every path in the home list, ... */
block|}
end_function

begin_comment
comment|/*=export_func optionFileLoad  *  * what: Load the locatable config files, in order  *  * arg:  + tOptions*   + pOpts  + program options descriptor +  * arg:  + char const* + pzProg + program name +  *  * ret_type:  int  * ret_desc:  0 -> SUCCESS, -1 -> FAILURE  *  * doc:  *  * This function looks in all the specified directories for a configuration  * file ("rc" file or "ini" file) and processes any found twice.  The first  * time through, they are processed in reverse order (last file first).  At  * that time, only "immediate action" configurables are processed.  For  * example, if the last named file specifies not processing any more  * configuration files, then no more configuration files will be processed.  * Such an option in the @strong{first} named directory will have no effect.  *  * Once the immediate action configurables have been handled, then the  * directories are handled in normal, forward order.  In that way, later  * config files can override the settings of earlier config files.  *  * See the AutoOpts documentation for a thorough discussion of the  * config file format.  *  * Configuration files not found or not decipherable are simply ignored.  *  * err:  Returns the value, "-1" if the program options descriptor  *       is out of date or indecipherable.  Otherwise, the value "0" will  *       always be returned. =*/
end_comment

begin_function
name|int
name|optionFileLoad
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgram
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validateOptionsStruct
argument_list|(
name|pOpts
argument_list|,
name|pzProgram
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|pOpts
operator|->
name|pzProgName
operator|=
name|pzProgram
expr_stmt|;
name|internalFileLoad
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionLoadOpt  * private:  *  * what:  Load an option rc/ini file  * arg:   + tOptions* + pOpts    + program options descriptor +  * arg:   + tOptDesc* + pOptDesc + the descriptor for this arg +  *  * doc:  *  Processes the options found in the file named with  *  pOptDesc->optArg.argString. =*/
end_comment

begin_function
name|void
name|optionLoadOpt
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
comment|/*      *  IF the option is not being disabled, THEN load the file.  There must      *  be a file.  (If it is being disabled, then the disablement processing      *  already took place.  It must be done to suppress preloading of ini/rc      *  files.)      */
if|if
condition|(
operator|!
name|DISABLED_OPT
argument_list|(
name|pOptDesc
argument_list|)
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zFSErrOptLoad
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotFile
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|filePreset
argument_list|(
name|pOpts
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|DIRECTION_CALLED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  parseAttributes  *  *  Parse the various attributes of an XML-styled config file entry  */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|parseAttributes
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionLoadMode
modifier|*
name|pMode
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
name|size_t
name|lenLoadType
init|=
name|strlen
argument_list|(
name|zLoadType
argument_list|)
decl_stmt|;
name|size_t
name|lenKeyWords
init|=
name|strlen
argument_list|(
name|zKeyWords
argument_list|)
decl_stmt|;
name|size_t
name|lenSetMem
init|=
name|strlen
argument_list|(
name|zSetMembers
argument_list|)
decl_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|pzText
condition|)
block|{
case|case
literal|'/'
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
case|case
literal|'>'
case|:
return|return
name|pzText
return|;
default|default:
case|case
name|NUL
case|:
return|return
name|NULL
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|++
name|pzText
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLoadType
argument_list|,
name|lenLoadType
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pzText
operator|=
name|parseValueType
argument_list|(
name|pzText
operator|+
name|lenLoadType
argument_list|,
name|pType
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zKeyWords
argument_list|,
name|lenKeyWords
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pzText
operator|=
name|parseKeyWordType
argument_list|(
name|pOpts
argument_list|,
name|pzText
operator|+
name|lenKeyWords
argument_list|,
name|pType
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zSetMembers
argument_list|,
name|lenSetMem
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pzText
operator|=
name|parseSetMemType
argument_list|(
name|pOpts
argument_list|,
name|pzText
operator|+
name|lenSetMem
argument_list|,
name|pType
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pzText
operator|=
name|parseLoadMode
argument_list|(
name|pzText
argument_list|,
name|pMode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pzText
operator|!=
name|NULL
condition|)
do|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/*  parseKeyWordType  *  *  "pzText" points to the character after "words=".  *  What should follow is a name of a keyword (enumeration) list.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parseKeyWordType
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
return|return
name|skipUnknown
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  parseLoadMode  *  *  "pzText" points to some name character.  We check for "cooked" or  *  "uncooked" or "keep".  This function should handle any attribute  *  that does not have an associated value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parseLoadMode
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionLoadMode
modifier|*
name|pMode
parameter_list|)
block|{
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLoadCooked
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLoadCooked
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
operator|*
name|pMode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLoadUncooked
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLoadUncooked
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
operator|*
name|pMode
operator|=
name|OPTION_LOAD_UNCOOKED
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLoadKeep
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLoadKeep
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
operator|*
name|pMode
operator|=
name|OPTION_LOAD_KEEP
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
name|unknown
label|:
return|return
name|skipUnknown
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  parseSetMemType  *  *  "pzText" points to the character after "members="  *  What should follow is a name of a "set membership".  *  A collection of bit flags.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parseSetMemType
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
return|return
name|skipUnknown
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  parseValueType  *  *  "pzText" points to the character after "type="  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parseValueType
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeString
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeString
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeInteger
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeInteger
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NUMERIC
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeBool
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeBool
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_BOOLEAN
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeKeyword
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeKeyword
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_ENUMERATION
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeSetMembership
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeSetMembership
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_MEMBERSHIP
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zLtypeNest
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pzText
argument_list|,
name|zLtypeNest
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pzText
index|[
name|len
index|]
operator|==
literal|'>'
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_HIERARCHY
expr_stmt|;
return|return
name|pzText
operator|+
name|len
return|;
block|}
goto|goto
name|unknown
goto|;
block|}
block|}
name|unknown
label|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
return|return
name|skipUnknown
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  skipUnknown  *  *  Skip over some unknown attribute  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipUnknown
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
name|pzText
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|pzText
argument_list|)
condition|)
return|return
name|pzText
return|;
switch|switch
condition|(
operator|*
name|pzText
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|NULL
return|;
case|case
literal|'/'
case|:
case|case
literal|'>'
case|:
return|return
name|pzText
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  validateOptionsStruct  *  *  Make sure the option descriptor is there and that we understand it.  *  This should be called from any user entry point where one needs to  *  worry about validity.  (Some entry points are free to assume that  *  the call is not the first to the library and, thus, that this has  *  already been called.)  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|validateOptionsStruct
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgram
parameter_list|)
block|{
if|if
condition|(
name|pOpts
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|zAO_Bad
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CONFIG
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF the client has enabled translation and the translation procedure      *  is available, then go do it.      */
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|pTransProc
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|pOpts
operator|->
name|pTransProc
call|)
argument_list|()
expr_stmt|;
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_TRANSLATE
expr_stmt|;
block|}
comment|/*      *  IF the struct version is not the current, and also      *     either too large (?!) or too small,      *  THEN emit error message and fail-exit      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|structVersion
operator|!=
name|OPTIONS_STRUCT_VERSION
operator|)
operator|&&
operator|(
operator|(
name|pOpts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
operator|)
operator|||
operator|(
name|pOpts
operator|->
name|structVersion
operator|<
name|OPTIONS_MINIMUM_VERSION
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAO_Err
argument_list|,
name|pOpts
operator|->
name|origArgVect
index|[
literal|0
index|]
argument_list|,
name|NUM_TO_VER
argument_list|(
name|pOpts
operator|->
name|structVersion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOpts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
condition|)
name|fputs
argument_list|(
name|zAO_Big
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|zAO_Sml
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*      *  If the program name hasn't been set, then set the name and the path      *  and the set of equivalent characters.      */
if|if
condition|(
name|pOpts
operator|->
name|pzProgName
operator|==
name|NULL
condition|)
block|{
name|char
specifier|const
modifier|*
name|pz
init|=
name|strrchr
argument_list|(
name|pzProgram
argument_list|,
name|DIRCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
name|pOpts
operator|->
name|pzProgName
operator|=
name|pzProgram
expr_stmt|;
else|else
name|pOpts
operator|->
name|pzProgName
operator|=
name|pz
operator|+
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzProgPath
operator|=
name|pzProgram
expr_stmt|;
comment|/*          *  when comparing long names, these are equivalent          */
name|strequate
argument_list|(
name|zSepChars
argument_list|)
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/configfile.c */
end_comment

end_unit

