begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: enumeration.c,v 4.17 2007/02/04 17:44:12 bkorb Exp $  * Time-stamp:      "2007-01-13 10:22:35 bkorb"  *  *   Automated Options Paged Usage module.  *  *  This routine will run run-on options through a pager so the  *  user may examine, print or edit them at their leisure.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_decl_stmt
name|tSCC
modifier|*
name|pz_enum_err_fmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|void
name|enumError
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|findName
parameter_list|(
name|tCC
modifier|*
name|pzName
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
specifier|static
name|void
name|enumError
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
block|{
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|size_t
name|ttl_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pOpts
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|pz_enum_err_fmt
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zValidKeys
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|paz_names
operator|==
literal|0x7F
condition|)
block|{
name|paz_names
operator|++
expr_stmt|;
name|name_ct
operator|--
expr_stmt|;
block|}
comment|/*      *  Figure out the maximum length of any name, plus the total length      *  of all the names.      */
block|{
name|tCC
modifier|*
specifier|const
modifier|*
name|paz
init|=
name|paz_names
decl_stmt|;
name|int
name|ct
init|=
name|name_ct
decl_stmt|;
do|do
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
operator|(
name|paz
operator|++
operator|)
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
name|ttl_len
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
comment|/*      *  IF any one entry is about 1/2 line or longer, print one per line      */
if|if
condition|(
name|max_len
operator|>
literal|35
condition|)
block|{
do|do
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"  %s\n"
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|name_ct
operator|>
literal|0
condition|)
do|;
block|}
comment|/*      *  ELSE IF they all fit on one line, then do so.      */
elseif|else
if|if
condition|(
name|ttl_len
operator|<
literal|76
condition|)
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|name_ct
operator|>
literal|0
condition|)
do|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Otherwise, columnize the output      */
else|else
block|{
name|int
name|ent_no
init|=
literal|0
decl_stmt|;
name|char
name|zFmt
index|[
literal|16
index|]
decl_stmt|;
comment|/* format for all-but-last entries on a line */
name|sprintf
argument_list|(
name|zFmt
argument_list|,
literal|"%%-%ds"
argument_list|,
operator|(
name|int
operator|)
name|max_len
argument_list|)
expr_stmt|;
name|max_len
operator|=
literal|78
operator|/
name|max_len
expr_stmt|;
comment|/* max_len is now max entries on a line */
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*          *  Loop through all but the last entry          */
while|while
condition|(
operator|--
name|name_ct
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|ent_no
operator|==
name|max_len
condition|)
block|{
comment|/*                  *  Last entry on a line.  Start next line, too.                  */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"%s\n  "
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
name|ent_no
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zFmt
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|paz_names
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF we do not have a pOpts pointer, then this output is being requested      *  by the usage procedure.  Let's not re-invoke it recursively.      */
if|if
condition|(
name|pOpts
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|pOpts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|pOpts
operator|,
name|EXIT_FAILURE
operator|)
expr_stmt|;
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
name|fputs
argument_list|(
name|zSetMemberSettings
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uintptr_t
name|findName
parameter_list|(
name|tCC
modifier|*
name|pzName
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
name|uintptr_t
name|res
init|=
name|name_ct
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pzName
argument_list|)
decl_stmt|;
name|uintptr_t
name|idx
decl_stmt|;
comment|/*      *  Look for an exact match, but remember any partial matches.      *  Multiple partial matches means we have an ambiguous match.      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|name_ct
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|paz_names
index|[
name|idx
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pzName
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|paz_names
index|[
name|idx
index|]
index|[
name|len
index|]
operator|==
name|NUL
condition|)
return|return
name|idx
return|;
comment|/* full match */
if|if
condition|(
name|res
operator|!=
name|name_ct
condition|)
block|{
name|pz_enum_err_fmt
operator|=
name|zAmbigKey
expr_stmt|;
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
name|enumError
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|idx
expr_stmt|;
comment|/* save partial match */
block|}
block|}
comment|/*      *  no partial match -> error      */
if|if
condition|(
name|res
operator|==
name|name_ct
condition|)
block|{
name|pz_enum_err_fmt
operator|=
name|zNoKey
expr_stmt|;
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
name|enumError
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Return the matching index as a char* pointer.      *  The result gets stashed in a char* pointer, so it will have to fit.      */
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionKeywordName  * what:  Convert between enumeration values and strings  * private:  *  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   unsigned int,  enum_val,  the enumeration value to map  *  * ret_type:  char const*  * ret_desc:  the enumeration name from const memory  *  * doc:   This converts an enumeration value into the matching string. =*/
end_comment

begin_function
name|char
specifier|const
modifier|*
name|optionKeywordName
parameter_list|(
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|unsigned
name|int
name|enum_val
parameter_list|)
block|{
name|tOptDesc
name|od
decl_stmt|;
name|od
operator|.
name|optArg
operator|.
name|argEnum
operator|=
name|enum_val
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
literal|2UL
operator|)
operator|,
operator|&
name|od
operator|)
expr_stmt|;
return|return
name|od
operator|.
name|optArg
operator|.
name|argString
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionEnumerationVal  * what:  Convert from a string to an enumeration value  * private:  *  * arg:   tOptions*,     pOpts,     the program options descriptor  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   char const * const *,  paz_names, list of enumeration names  * arg:   unsigned int,  name_ct,   number of names in list  *  * ret_type:  uintptr_t  * ret_desc:  the enumeration value  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|uintptr_t
name|optionEnumerationVal
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
name|uintptr_t
name|res
init|=
literal|0UL
decl_stmt|;
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|pOpts
condition|)
block|{
case|case
literal|0UL
case|:
comment|/*          *  print the list of enumeration names.          */
name|enumError
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1UL
case|:
block|{
name|unsigned
name|int
name|ix
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  print the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
name|printf
argument_list|(
literal|"INVALID-%d"
argument_list|,
name|ix
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2UL
case|:
block|{
name|tSCC
name|zInval
index|[]
init|=
literal|"*INVALID*"
decl_stmt|;
name|unsigned
name|int
name|ix
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  Replace the enumeration value with the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
return|return
operator|(
name|uintptr_t
operator|)
name|zInval
return|;
name|res
operator|=
operator|(
name|uintptr_t
operator|)
name|paz_names
index|[
name|ix
index|]
expr_stmt|;
break|break;
block|}
default|default:
name|res
operator|=
name|findName
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionSetMembers  * what:  Convert between bit flag values and strings  * private:  *  * arg:   tOptions*,     pOpts,     the program options descriptor  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   char const * const *,  *                       paz_names, list of enumeration names  * arg:   unsigned int,  name_ct,   number of names in list  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|void
name|optionSetMembers
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|tCC
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|pOpts
condition|)
block|{
case|case
literal|0UL
case|:
comment|/*          *  print the list of enumeration names.          */
name|enumError
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1UL
case|:
block|{
comment|/*          *  print the name string.          */
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|uintptr_t
name|res
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|len
operator|++
operator|>
literal|0
condition|)
name|fputs
argument_list|(
literal|" | "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|paz_names
index|[
name|res
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|res
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|2UL
case|:
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|uintptr_t
name|res
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
comment|/*          *  Replace the enumeration value with the name string.          *  First, determine the needed length, then allocate and fill in.          */
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|paz_names
index|[
name|res
index|]
argument_list|)
operator|+
literal|8
expr_stmt|;
if|if
condition|(
operator|++
name|res
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"enum name"
argument_list|)
expr_stmt|;
comment|/*          *  Start by clearing all the bits.  We want to turn off any defaults          *  because we will be restoring to current state, not adding to          *  the default set of bits.          */
name|strcpy
argument_list|(
name|pz
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
name|pz
operator|+=
literal|4
expr_stmt|;
name|bits
operator|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|pz
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pz
operator|+
literal|3
argument_list|,
name|paz_names
index|[
name|res
index|]
argument_list|)
expr_stmt|;
name|pz
operator|+=
name|strlen
argument_list|(
name|paz_names
index|[
name|res
index|]
argument_list|)
operator|+
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|res
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
return|return;
block|}
default|default:
break|break;
block|}
block|{
name|tCC
modifier|*
name|pzArg
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
name|uintptr_t
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|pzArg
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzArg
operator|==
name|NUL
operator|)
condition|)
block|{
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
return|return;
block|}
name|res
operator|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tSCC
name|zSpn
index|[]
init|=
literal|" ,|+\t\r\f\n"
decl_stmt|;
name|int
name|iv
decl_stmt|,
name|len
decl_stmt|;
name|pzArg
operator|+=
name|strspn
argument_list|(
name|pzArg
argument_list|,
name|zSpn
argument_list|)
expr_stmt|;
name|iv
operator|=
operator|(
operator|*
name|pzArg
operator|==
literal|'!'
operator|)
expr_stmt|;
if|if
condition|(
name|iv
condition|)
name|pzArg
operator|+=
name|strspn
argument_list|(
name|pzArg
operator|+
literal|1
argument_list|,
name|zSpn
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|pzArg
argument_list|,
name|zSpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|len
operator|==
literal|3
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pzArg
argument_list|,
name|zAll
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|iv
condition|)
name|res
operator|=
literal|0
expr_stmt|;
else|else
name|res
operator|=
operator|~
literal|0UL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|==
literal|4
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pzArg
argument_list|,
name|zNone
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|iv
condition|)
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
do|do
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|bit
init|=
name|strtoul
argument_list|(
name|pzArg
argument_list|,
operator|&
name|pz
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|pzArg
operator|+
name|len
condition|)
block|{
name|char
name|z
index|[
name|AO_NAME_SIZE
index|]
decl_stmt|;
name|tCC
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
if|if
condition|(
name|len
operator|>=
name|AO_NAME_LIMIT
condition|)
break|break;
name|strncpy
argument_list|(
name|z
argument_list|,
name|pzArg
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|z
index|[
name|len
index|]
operator|=
name|NUL
expr_stmt|;
name|p
operator|=
name|z
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|pzArg
expr_stmt|;
block|}
name|bit
operator|=
literal|1UL
operator|<<
name|findName
argument_list|(
name|p
argument_list|,
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
name|res
operator|&=
operator|~
name|bit
expr_stmt|;
else|else
name|res
operator||=
name|bit
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|pzArg
index|[
name|len
index|]
operator|==
name|NUL
condition|)
break|break;
name|pzArg
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name_ct
operator|<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|)
condition|)
block|{
name|res
operator|&=
operator|(
literal|1UL
operator|<<
name|name_ct
operator|)
operator|-
literal|1UL
expr_stmt|;
block|}
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
name|res
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/enumeration.c */
end_comment

end_unit

