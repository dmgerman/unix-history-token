begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xml.c -- xml output.    $Id: xml.c,v 1.52 2004/12/19 17:02:23 karl Exp $     Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Originally written by Philippe Martin<feloy@free.fr>.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"float.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* Options */
end_comment

begin_decl_stmt
name|int
name|xml_index_divisions
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_element
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|contains_para
decl_stmt|;
name|int
name|contained_in_para
decl_stmt|;
name|int
name|keep_space
decl_stmt|;
block|}
name|element
typedef|;
end_typedef

begin_decl_stmt
name|element
name|texinfoml_element_list
index|[]
init|=
block|{
block|{
literal|"texinfo"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"setfilename"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"titlefont"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"settitle"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"documentdescription"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"node"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nodenext"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nodeprev"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nodeup"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"chapter"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"subsection"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"subsubsection"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"top"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"unnumbered"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"appendix"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"appendixsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"majorheading"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"chapheading"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"subheading"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"subsubheading"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"titlepage"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"author"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"booktitle"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"booksubtitle"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"menu"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"detailmenu"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"menuentry"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"menutitle"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"menucomment"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"menunode"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nodename"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"acronym"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"acronymword"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"acronymdesc"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"abbrev"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"abbrevword"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"abbrevdesc"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"tt"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"code"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"command"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"env"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"option"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"samp"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"kbd"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"url"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"var"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"sc"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"dfn"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"emph"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"strong"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"cite"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"notfixedwidth"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"i"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"r"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"slanted"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"sansserif"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"exdent"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"title"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ifinfo"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sp"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"center"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dircategory"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"quotation"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"example"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"smallexample"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"lisp"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"smalllisp"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"cartouche"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"copying"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"format"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"smallformat"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"display"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"smalldisplay"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"verbatim"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"footnote"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* LINEANNOTATION (docbook) */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TIP (docbook)       */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NOTE (docbook)      */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IMPORTANT (docbook) */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* WARNING (docbook)   */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CAUTION (docbook)   */
block|{
literal|"itemize"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"itemfunction"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"item"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"enumerate"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"table"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tableitem"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tableterm"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"indexterm"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"math"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"dmn"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xref"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xrefnodename"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xrefinfoname"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xrefprinteddesc"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xrefinfofile"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"xrefprintedname"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"inforef"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"inforefnodename"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"inforefrefname"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"inforefinfoname"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"uref"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"urefurl"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"urefdesc"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"urefreplacement"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"email"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"emailaddress"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"emailname"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"group"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"floattype"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"floatpos"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"caption"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"shortcaption"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TABLE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FIGURE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EXAMPLE (docbook) */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SIDEBAR (docbook) */
block|{
literal|"printindex"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"listoffloats"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"anchor"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"image"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"inlineimage"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"alttext"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* PRIMARY (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* SECONDARY (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* INFORMALFIGURE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MEDIAOBJECT (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IMAGEOBJECT (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IMAGEDATA (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TEXTOBJECT (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* INDEXENTRY (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PRIMARYIE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SECONDARYIE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* INDEXDIV (docbook) */
block|{
literal|"multitable"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TGROUP (docbook) */
block|{
literal|"columnfraction"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"thead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tbody"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"entry"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"row"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BOOKINFO (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ABSTRACT (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* REPLACEABLE (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ENVAR (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* COMMENT (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FUNCTION (docbook) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* LEGALNOTICE (docbook) */
block|{
literal|"contents"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"shortcontents"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"documentlanguage"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"setvalue"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"clearvalue"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"definition"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"definitionterm"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"definitionitem"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defcategory"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"deffunction"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defvariable"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defparam"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defdelimiter"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"deftype"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defparamtype"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defdatatype"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defclass"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defclassvar"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"defoperation"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"para"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* Must be last */
comment|/* name / contains para / contained in para / preserve space */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|element
name|docbook_element_list
index|[]
init|=
block|{
block|{
literal|"book"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TEXINFO */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SETFILENAME */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TITLEINFO */
block|{
literal|"title"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SETTITLE */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DOCUMENTDESCRIPTION (?) */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NODE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NODENEXT */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NODEPREV */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NODEUP */
block|{
literal|"chapter"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sect1"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SECTION */
block|{
literal|"sect2"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SUBSECTION */
block|{
literal|"sect3"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SUBSUBSECTION */
block|{
literal|"chapter"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TOP */
block|{
literal|"chapter"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNNUMBERED */
block|{
literal|"sect1"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNNUMBEREDSEC */
block|{
literal|"sect2"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNNUMBEREDSUBSEC */
block|{
literal|"sect3"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* UNNUMBEREDSUBSUBSEC */
block|{
literal|"appendix"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sect1"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* APPENDIXSEC */
block|{
literal|"sect2"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* APPENDIXSUBSEC */
block|{
literal|"sect3"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* APPENDIXSUBSUBSEC */
block|{
literal|"bridgehead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MAJORHEADING */
block|{
literal|"bridgehead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CHAPHEADING */
block|{
literal|"bridgehead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* HEADING */
block|{
literal|"bridgehead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SUBHEADING */
block|{
literal|"bridgehead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SUBSUBHEADING */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TITLEPAGE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* AUTHOR */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BOOKTITLE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BOOKSUBTITLE */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MENU */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DETAILMENU */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MENUENTRY */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MENUTITLE */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MENUCOMMENT */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MENUNODE */
block|{
literal|"anchor"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NODENAME */
block|{
literal|"acronym"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ACRONYMWORD */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ACRONYMDESC */
block|{
literal|"abbrev"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ABBREVWORD */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ABBREVDESC */
block|{
literal|"literal"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* TT */
block|{
literal|"literal"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* CODE */
block|{
literal|"command"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* COMMAND */
block|{
literal|"envar"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ENV */
block|{
literal|"filename"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* FILE */
block|{
literal|"option"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* OPTION */
block|{
literal|"literal"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* SAMP */
block|{
literal|"userinput"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* KBD */
block|{
literal|"wordasword"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* URL */
block|{
literal|"keycap"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* KEY */
block|{
literal|"replaceable"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* VAR */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* SC */
block|{
literal|"firstterm"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* DFN */
block|{
literal|"emphasis"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* EMPH */
block|{
literal|"emphasis"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* STRONG */
block|{
literal|"citetitle"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* CITE */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* NOTFIXEDWIDTH */
block|{
literal|"wordasword"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* I */
block|{
literal|"emphasis"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* B */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* R */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EXDENT */
block|{
literal|"title"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IFINFO */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SP */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CENTER */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DIRCATEGORY */
block|{
literal|"blockquote"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* QUOTATION */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* EXAMPLE */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* SMALLEXAMPLE */
block|{
literal|"programlisting"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* LISP */
block|{
literal|"programlisting"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* SMALLLISP */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CARTOUCHE */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* COPYING */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* FORMAT */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* SMALLFORMAT */
block|{
literal|"literallayout"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* DISPLAY */
block|{
literal|"literallayout"
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* SMALLDISPLAY */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* VERBATIM */
block|{
literal|"footnote"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"lineannotation"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"tip"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"note"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"important"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"warning"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"caution"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"itemizedlist"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ITEMIZE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ITEMFUNCTION */
block|{
literal|"listitem"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ITEM */
block|{
literal|"orderedlist"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ENUMERATE */
block|{
literal|"variablelist"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TABLE */
block|{
literal|"varlistentry"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TABLEITEM */
block|{
literal|"term"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TABLETERM */
block|{
literal|"indexterm"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INDEXTERM */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* MATH */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* DIMENSION */
block|{
literal|"xref"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREF */
block|{
literal|"link"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREFNODENAME */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREFINFONAME */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREFPRINTEDDESC */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREFINFOFILE */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XREFPRINTEDNAME */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INFOREF */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INFOREFNODENAME */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INFOREFREFNAME */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INFOREFINFONAME */
block|{
literal|"ulink"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* UREF */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* UREFURL */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* UREFDESC */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* UREFREPLACEMENT */
block|{
literal|"ulink"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* EMAIL */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* EMAILADDRESS */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* EMAILNAME */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* GROUP */
block|{
literal|""
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FLOAT */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FLOATTYPE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FLOATPOS */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CAPTION */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SHORTCAPTION */
block|{
literal|"table"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"figure"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"example"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"sidebar"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"index"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* PRINTINDEX */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* LISTOFFLOATS */
block|{
literal|""
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* ANCHOR */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IMAGE */
block|{
literal|"inlinemediaobject"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* INLINEIMAGE */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IMAGEALTTEXT */
block|{
literal|"primary"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* PRIMARY */
block|{
literal|"secondary"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"informalfigure"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mediaobject"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"imageobject"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"imagedata"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"textobject"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"indexentry"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"primaryie"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"secondaryie"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"indexdiv"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"informaltable"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tgroup"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"colspec"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"thead"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tbody"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"entry"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"row"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bookinfo"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"abstract"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"replaceable"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"envar"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"comment"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"function"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"legalnotice"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CONTENTS (xml) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SHORTCONTENTS (xml) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DOCUMENT LANGUAGE (xml) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SETVALUE (xml) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CLEARVALUE (xml) */
block|{
literal|"blockquote"
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFINITION */
block|{
literal|"screen"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* DEFINITIONTERM */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFINITIONITEM (xml) */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFCATEGORY (xml) */
block|{
literal|"function"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFFUNCTION */
block|{
literal|"varname"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFVARIABLE */
block|{
literal|"varname"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFPARAM */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFDELIMITER (xml) */
block|{
literal|"returnvalue"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFTYPE */
block|{
literal|"type"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFPARAMTYPE */
block|{
literal|"structname"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFDATATYPE */
block|{
literal|"classname"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFCLASS */
block|{
literal|"property"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFCLASSVAR */
block|{
literal|"methodname"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DEFOPERATION */
block|{
literal|"para"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* Must be last */
comment|/* name / contains para / contained in para / preserve space */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|element
modifier|*
name|xml_element_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_replace_element
block|{
name|int
name|element_to_replace
decl_stmt|;
name|int
name|element_containing
decl_stmt|;
name|int
name|element_replacing
decl_stmt|;
block|}
name|replace_element
typedef|;
end_typedef

begin_comment
comment|/* Elements to replace - Docbook only    -------------------    if `element_to_replace' have to be inserted    as a child of `element_containing,'    use `element_replacing' instead.     A value of `-1' for element_replacing means `do not use any element.' */
end_comment

begin_decl_stmt
name|replace_element
name|replace_elements
index|[]
init|=
block|{
block|{
name|I
block|,
name|TABLETERM
block|,
name|EMPH
block|}
block|,
block|{
name|B
block|,
name|TABLETERM
block|,
name|EMPH
block|}
block|,
block|{
name|TT
block|,
name|CODE
block|,
operator|-
literal|1
block|}
block|,
block|{
name|EXAMPLE
block|,
name|DISPLAY
block|,
operator|-
literal|1
block|}
block|,
block|{
name|CODE
block|,
name|DFN
block|,
operator|-
literal|1
block|}
block|,
block|{
name|CODE
block|,
name|VAR
block|,
operator|-
literal|1
block|}
block|,
block|{
name|EMPH
block|,
name|CODE
block|,
name|REPLACEABLE
block|}
block|,
block|{
name|VAR
block|,
name|VAR
block|,
operator|-
literal|1
block|}
block|,
block|{
name|VAR
block|,
name|B
block|,
name|EMPH
block|}
block|,
block|{
name|B
block|,
name|CODE
block|,
name|ENVAR
block|}
block|,
block|{
name|CODE
block|,
name|I
block|,
name|EMPH
block|}
block|,
block|{
name|SAMP
block|,
name|VAR
block|,
operator|-
literal|1
block|}
block|,
block|{
name|FORMAT
block|,
name|BOOKINFO
block|,
name|ABSTRACT
block|}
block|,
block|{
name|QUOTATION
block|,
name|ABSTRACT
block|,
operator|-
literal|1
block|}
block|,
block|{
name|LINEANNOTATION
block|,
name|LINEANNOTATION
block|,
operator|-
literal|1
block|}
block|,
block|{
name|LEGALNOTICE
block|,
name|ABSTRACT
block|,
operator|-
literal|1
block|}
block|,
block|{
name|QUOTATION
block|,
name|QUOTATION
block|,
operator|-
literal|1
block|}
block|,
comment|/* Formal versions of table and image elements.  */
block|{
name|MULTITABLE
block|,
name|FLOAT
block|,
name|FLOATTABLE
block|}
block|,
block|{
name|INFORMALFIGURE
block|,
name|FLOAT
block|,
name|FLOATFIGURE
block|}
block|,
block|{
name|CARTOUCHE
block|,
name|FLOAT
block|,
name|FLOATCARTOUCHE
block|}
block|,
comment|/* Unnecessary markup in @defun blocks.  */
block|{
name|VAR
block|,
name|DEFPARAM
block|,
operator|-
literal|1
block|}
block|,
block|{
name|CODE
block|,
name|DEFTYPE
block|,
operator|-
literal|1
block|}
block|,
comment|/* Add your elements to replace here */
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_menu_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_menu_entry_comment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_node_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_node_level
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_para
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_just_after_element
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_keep_space
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_no_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_no_para
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xml_node_id
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_sort_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_xref_token
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_bookinfo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_book_title
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_in_abstract
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we are handling an element that can appear between    @item and @itemx, @deffn and @deffnx.  */
end_comment

begin_decl_stmt
name|int
name|xml_dont_touch_items_defs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need to keep footnote state, because elements inside footnote may try    to close the previous parent para.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xml_in_footnote
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_after_table_term
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|book_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first_section_opened
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_in_tableitem
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_in_item
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_table_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_in_def_item
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_definition_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xml_after_def_term
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_table_title
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_indexentry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_secondary
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_indexterm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xml_id
parameter_list|(
name|char
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|tem
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|id
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tem
decl_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|id
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Check if a character is allowed in ID attributes.  This list differs          slightly from XML specs that it doesn't contain underscores.          See http://xml.coverpages.org/sgmlsyn/sgmlsyn.htm, ``9.3 Name''  */
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-."
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'-'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|tem
expr_stmt|;
comment|/* First character can only be a letter.  */
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'i'
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
name|int
name|xml_element
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PARA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|texinfoml_element_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
name|printf
argument_list|(
literal|"Error xml_element\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|xml_begin_document
parameter_list|(
name|char
modifier|*
name|output_filename
parameter_list|)
block|{
if|if
condition|(
name|book_started
condition|)
return|return;
name|book_started
operator|=
literal|1
expr_stmt|;
comment|/* Make sure this is the very first string of the output document.  */
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|insert_string
argument_list|(
literal|"<?xml version=\"1.0\""
argument_list|)
expr_stmt|;
comment|/* At this point, we register a delayed writing for document encoding,      so in the end, proper encoding attribute will be inserted here.      Since the user is unaware that we are implicitly executing this      command, we should disable warnings temporarily, in order to avoid      possible confusion.  (ie. if the output is not seekable,      register_delayed_write issues a warning.)  */
block|{
specifier|extern
name|int
name|print_warnings
decl_stmt|;
name|int
name|save_print_warnings
init|=
name|print_warnings
decl_stmt|;
name|print_warnings
operator|=
literal|0
expr_stmt|;
name|register_delayed_write
argument_list|(
literal|"@documentencoding"
argument_list|)
expr_stmt|;
name|print_warnings
operator|=
name|save_print_warnings
expr_stmt|;
block|}
name|insert_string
argument_list|(
literal|"?>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|docbook
condition|)
block|{
name|insert_string
argument_list|(
literal|"<!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd\" [\n<!ENTITY tex \"TeX\">\n<!ENTITY latex \"LaTeX\">\n]>"
argument_list|)
expr_stmt|;
name|xml_element_list
operator|=
name|docbook_element_list
expr_stmt|;
block|}
else|else
block|{
name|insert_string
argument_list|(
literal|"<!DOCTYPE texinfo PUBLIC \"-//GNU//DTD TexinfoML V"
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"//EN\" \"http://www.gnu.org/software/texinfo/dtd/"
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"/texinfo.dtd\">"
argument_list|)
expr_stmt|;
name|xml_element_list
operator|=
name|texinfoml_element_list
expr_stmt|;
block|}
if|if
condition|(
name|language_code
operator|!=
name|last_language_code
condition|)
block|{
if|if
condition|(
name|docbook
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|TEXINFO
argument_list|,
name|START
argument_list|,
literal|"lang=\"%s\""
argument_list|,
name|language_table
index|[
name|language_code
index|]
operator|.
name|abbrev
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|TEXINFO
argument_list|,
name|START
argument_list|,
literal|"xml:lang=\"%s\""
argument_list|,
name|language_table
index|[
name|language_code
index|]
operator|.
name|abbrev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|SETFILENAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SETFILENAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|element_stack
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|element_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xml_current_element
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|element_stack
index|[
name|element_stack_index
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_push_current_element
parameter_list|(
name|int
name|elt
parameter_list|)
block|{
name|element_stack
index|[
name|element_stack_index
operator|++
index|]
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|element_stack_index
operator|>
literal|200
condition|)
name|printf
argument_list|(
literal|"*** stack overflow (%d - %s) ***\n"
argument_list|,
name|element_stack_index
argument_list|,
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_pop_current_element
parameter_list|(
name|void
parameter_list|)
block|{
name|element_stack_index
operator|--
expr_stmt|;
if|if
condition|(
name|element_stack_index
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"*** stack underflow (%d - %d) ***\n"
argument_list|,
name|element_stack_index
argument_list|,
name|xml_current_element
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xml_current_stack_index
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|element_stack_index
return|;
block|}
end_function

begin_function
name|void
name|xml_end_current_element
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|xml_current_element
argument_list|()
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_indent
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_indentation_increment
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|element_stack_index
operator|*
name|xml_indentation_increment
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xml_start_para
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_in_para
operator|||
name|xml_in_footnote
operator|||
operator|!
name|xml_element_list
index|[
name|xml_current_element
argument_list|()
index|]
operator|.
name|contains_para
condition|)
return|return;
while|while
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
name|xml_indent
argument_list|()
expr_stmt|;
name|insert_string
argument_list|(
literal|"<para"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_no_indent
condition|)
name|insert_string
argument_list|(
literal|" role=\"continues\""
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|xml_no_indent
operator|=
literal|0
expr_stmt|;
name|xml_in_para
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_para
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xml_in_para
operator|||
name|xml_in_footnote
condition|)
return|return;
while|while
condition|(
name|cr_or_whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
name|insert_string
argument_list|(
literal|"</para>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_indentation_increment
operator|>
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|xml_in_para
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_document
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_node_open
condition|)
block|{
if|if
condition|(
name|xml_node_level
operator|!=
operator|-
literal|1
condition|)
block|{
name|xml_close_sections
argument_list|(
name|xml_node_level
argument_list|)
expr_stmt|;
name|xml_node_level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|NODE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
name|xml_close_sections
argument_list|(
name|xml_node_level
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TEXINFO
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_indentation_increment
operator|==
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"<!-- Keep this comment at the end of the file\n\ Local variables:\n\ mode: sgml\n\ sgml-indent-step:1\n\ sgml-indent-data:nil\n\ End:\n\ -->\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|element_stack_index
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Element stack index : %d\n"
argument_list|,
name|element_stack_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MUST be 0 or 1, not true or false values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|start_element_inserted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: We use `elt' rather than `element' in the argument list of    the next function, since otherwise the Solaris SUNWspro compiler    barfs because `element' is a typedef declared near the beginning of    this file.  */
end_comment

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|xml_insert_element_with_attribute
parameter_list|(
name|int
name|elt
parameter_list|,
name|int
name|arg
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|xml_insert_element_with_attribute
parameter_list|(
name|elt
parameter_list|,
name|arg
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|elt
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
comment|/* Look at the replace_elements table to see if we have to change the element */
if|if
condition|(
name|xml_sort_index
condition|)
return|return;
if|if
condition|(
name|docbook
condition|)
block|{
name|replace_element
modifier|*
name|element_list
init|=
name|replace_elements
decl_stmt|;
while|while
condition|(
name|element_list
operator|->
name|element_to_replace
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|arg
operator|==
name|START
operator|)
operator|&&
operator|(
name|element_list
operator|->
name|element_containing
operator|==
name|xml_current_element
argument_list|()
operator|)
operator|&&
operator|(
name|element_list
operator|->
name|element_to_replace
operator|==
name|elt
operator|)
operator|)
operator|||
operator|(
operator|(
name|arg
operator|==
name|END
operator|)
operator|&&
operator|(
name|element_list
operator|->
name|element_containing
operator|==
name|element_stack
index|[
name|element_stack_index
operator|-
literal|1
operator|-
name|start_element_inserted
index|]
operator|)
operator|&&
operator|(
name|element_list
operator|->
name|element_to_replace
operator|==
name|elt
operator|)
operator|)
condition|)
block|{
name|elt
operator|=
name|element_list
operator|->
name|element_replacing
expr_stmt|;
break|break;
block|}
name|element_list
operator|++
expr_stmt|;
block|}
comment|/* Forget the element */
if|if
condition|(
name|elt
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|start_element_inserted
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Replace the default value, for the next time */
name|start_element_inserted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|book_started
condition|)
return|return;
if|if
condition|(
operator|!
name|xml_dont_touch_items_defs
operator|&&
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml_after_table_term
operator|&&
name|elt
operator|!=
name|TABLETERM
operator|&&
name|xml_table_level
operator|&&
operator|!
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_after_table_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml_after_def_term
operator|&&
name|elt
operator|!=
name|DEFINITIONTERM
condition|)
block|{
name|xml_after_def_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFINITIONITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|docbook
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
return|return;
if|if
condition|(
name|executing_string
operator|&&
name|arg
operator|==
name|END
condition|)
switch|switch
condition|(
name|elt
condition|)
block|{
case|case
name|TABLEITEM
case|:
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ITEM
case|:
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DEFINITIONTERM
case|:
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* We are special-casing FIGURE element for docbook.  It does appear in      the tag stack, but not in the output.  This is to make element replacement      work beautifully.  */
if|if
condition|(
name|docbook
operator|&&
name|elt
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|xml_push_current_element
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
name|xml_pop_current_element
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|name
operator|||
operator|!
name|strlen
argument_list|(
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
comment|/*printf ("Warning: Inserting empty element %d\n", elt);*/
return|return;
block|}
if|if
condition|(
name|arg
operator|==
name|START
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|xml_no_para
operator|&&
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contained_in_para
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
operator|&&
name|xml_in_para
operator|&&
operator|!
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contained_in_para
condition|)
name|xml_end_para
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
operator|&&
name|xml_in_para
operator|&&
operator|!
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contained_in_para
condition|)
name|xml_end_para
argument_list|()
expr_stmt|;
if|if
condition|(
name|docbook
operator|&&
name|xml_table_level
operator|&&
operator|!
name|in_table_title
operator|&&
operator|!
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|&&
operator|!
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|&&
name|arg
operator|==
name|START
operator|&&
name|elt
operator|!=
name|TABLEITEM
operator|&&
name|elt
operator|!=
name|TABLETERM
operator|&&
operator|!
name|in_indexterm
operator|&&
name|xml_current_element
argument_list|()
operator|==
name|TABLE
condition|)
block|{
name|in_table_title
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|START
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|xml_keep_space
operator|&&
operator|!
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contained_in_para
condition|)
name|xml_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|xml_push_current_element
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
name|xml_pop_current_element
argument_list|()
expr_stmt|;
comment|/* Eat one newline before</example> and the like.  */
if|if
condition|(
operator|!
name|docbook
operator|&&
name|arg
operator|==
name|END
operator|&&
operator|(
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|keep_space
operator|||
name|elt
operator|==
name|GROUP
operator|)
operator|&&
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
comment|/* And eat whitespace before</entry> in @multitables.  */
if|if
condition|(
name|arg
operator|==
name|END
operator|&&
name|elt
operator|==
name|ENTRY
condition|)
while|while
condition|(
name|cr_or_whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
comment|/* Indent elements that can contain<para>.  */
if|if
condition|(
name|arg
operator|==
name|END
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|xml_keep_space
operator|&&
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contains_para
condition|)
name|xml_indent
argument_list|()
expr_stmt|;
comment|/* Here are the elements we want indented.  These do not contain<para>      directly.  */
if|if
condition|(
name|arg
operator|==
name|END
operator|&&
operator|(
name|elt
operator|==
name|MENUENTRY
operator|||
name|elt
operator|==
name|ITEMIZE
operator|||
name|elt
operator|==
name|ENUMERATE
operator|||
name|elt
operator|==
name|TABLEITEM
operator|||
name|elt
operator|==
name|TABLE
operator|||
name|elt
operator|==
name|MULTITABLE
operator|||
name|elt
operator|==
name|TGROUP
operator|||
name|elt
operator|==
name|THEAD
operator|||
name|elt
operator|==
name|TBODY
operator|||
name|elt
operator|==
name|ROW
operator|||
name|elt
operator|==
name|INFORMALFIGURE
operator|||
operator|(
operator|!
name|docbook
operator|&&
operator|(
name|elt
operator|==
name|DEFINITION
operator|||
name|elt
operator|==
name|DEFINITIONTERM
operator|)
operator|)
operator|)
condition|)
name|xml_indent
argument_list|()
expr_stmt|;
name|insert
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|insert
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/*  printf ("%s ", xml_element_list[elt].name);*/
if|if
condition|(
name|format
condition|)
block|{
name|char
name|temp_string
index|[
literal|2000
index|]
decl_stmt|;
comment|/* xx no fixed limits */
ifdef|#
directive|ifdef
name|VA_SPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_SPRINTF
name|VA_SPRINTF
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|START
operator|&&
name|xml_node_id
operator|&&
name|elt
operator|!=
name|NODENAME
condition|)
block|{
name|insert_string
argument_list|(
literal|" id=\""
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|xml_node_id
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xml_node_id
argument_list|)
expr_stmt|;
name|xml_node_id
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|keep_space
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|!
name|docbook
condition|)
name|insert_string
argument_list|(
literal|" xml:space=\"preserve\""
argument_list|)
expr_stmt|;
name|xml_keep_space
operator|++
expr_stmt|;
block|}
else|else
name|xml_keep_space
operator|--
expr_stmt|;
block|}
name|insert
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xml_in_para
operator|&&
operator|!
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contained_in_para
operator|&&
name|xml_element_list
index|[
name|elt
index|]
operator|.
name|contains_para
operator|&&
name|xml_indentation_increment
operator|>
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|xml_just_after_element
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See the NOTE before xml_insert_element_with_attribute, for why we    use `elt' rather than `element' here.  */
end_comment

begin_function
name|void
name|xml_insert_element
parameter_list|(
name|int
name|elt
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|elt
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_insert_entity
parameter_list|(
name|char
modifier|*
name|entity_name
parameter_list|)
block|{
name|int
name|saved_escape_html
init|=
name|escape_html
decl_stmt|;
if|if
condition|(
operator|!
name|book_started
condition|)
return|return;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|xml_in_para
operator|&&
operator|!
name|xml_no_para
operator|&&
operator|!
name|only_macro_expansion
operator|&&
name|xml_element_list
index|[
name|xml_current_element
argument_list|()
index|]
operator|.
name|contains_para
operator|&&
operator|!
name|in_fixed_width_font
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
name|escape_html
operator|=
literal|0
expr_stmt|;
name|add_char
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|escape_html
operator|=
name|saved_escape_html
expr_stmt|;
name|insert_string
argument_list|(
name|entity_name
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|struct
name|_xml_section
name|xml_section
typedef|;
end_typedef

begin_struct
struct|struct
name|_xml_section
block|{
name|int
name|level
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|xml_section
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|xml_section
modifier|*
name|last_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xml_begin_node
parameter_list|(
name|void
parameter_list|)
block|{
name|first_section_opened
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xml_in_abstract
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_in_bookinfo
condition|)
block|{
name|xml_insert_element
argument_list|(
name|BOOKINFO
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_bookinfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_node_open
operator|&&
operator|!
name|docbook
condition|)
block|{
if|if
condition|(
name|xml_node_level
operator|!=
operator|-
literal|1
condition|)
block|{
name|xml_close_sections
argument_list|(
name|xml_node_level
argument_list|)
expr_stmt|;
name|xml_node_level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|NODE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|NODE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_node_open
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_close_sections
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first_section_opened
condition|)
block|{
if|if
condition|(
name|xml_in_abstract
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_in_bookinfo
condition|)
block|{
name|xml_insert_element
argument_list|(
name|BOOKINFO
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_bookinfo
operator|=
literal|0
expr_stmt|;
block|}
name|first_section_opened
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|last_section
operator|&&
name|last_section
operator|->
name|level
operator|>=
name|level
condition|)
block|{
name|xml_section
modifier|*
name|temp
init|=
name|last_section
decl_stmt|;
name|xml_insert_element
argument_list|(
name|xml_element
argument_list|(
name|last_section
operator|->
name|name
argument_list|)
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|temp
operator|=
name|last_section
expr_stmt|;
name|last_section
operator|=
name|last_section
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xml_open_section
parameter_list|(
name|int
name|level
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xml_section
modifier|*
name|sect
init|=
operator|(
name|xml_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xml_section
argument_list|)
argument_list|)
decl_stmt|;
name|sect
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|sect
operator|->
name|name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sect
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sect
operator|->
name|prev
operator|=
name|last_section
expr_stmt|;
name|last_section
operator|=
name|sect
expr_stmt|;
if|if
condition|(
name|xml_node_open
operator|&&
name|xml_node_level
operator|==
operator|-
literal|1
condition|)
name|xml_node_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_start_menu_entry
parameter_list|(
name|char
modifier|*
name|tem
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|discard_until
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
comment|/* The line number was already incremented in reader_loop when we      saw the newline, and discard_until has now incremented again.  */
name|line_number
operator|--
expr_stmt|;
if|if
condition|(
name|xml_in_menu_entry
condition|)
block|{
if|if
condition|(
name|xml_in_menu_entry_comment
condition|)
block|{
name|xml_insert_element
argument_list|(
name|MENUCOMMENT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry_comment
operator|=
literal|0
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|MENUENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry
operator|=
literal|0
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|MENUENTRY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_menu_entry
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|MENUNODE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|string
operator|=
name|expansion
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|MENUNODE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* The menu item may use macros, so expand them now.  */
name|xml_insert_element
argument_list|(
name|MENUTITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|++
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|1
argument_list|,
literal|":"
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* get escaping done */
name|xml_insert_element
argument_list|(
name|MENUTITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|looking_at
argument_list|(
literal|"::"
argument_list|)
condition|)
name|discard_until
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* discard the node name */
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"."
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|input_text_offset
operator|++
expr_stmt|;
comment|/* discard the second colon or the period */
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|xml_insert_element
argument_list|(
name|MENUCOMMENT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_menu_entry_comment
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_menu
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_in_menu_entry
condition|)
block|{
if|if
condition|(
name|xml_in_menu_entry_comment
condition|)
block|{
name|xml_insert_element
argument_list|(
name|MENUCOMMENT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry_comment
operator|--
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|MENUENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry
operator|--
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|MENU
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|xml_last_character
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xml_add_char
parameter_list|(
name|int
name|character
parameter_list|)
block|{
if|if
condition|(
operator|!
name|book_started
condition|)
return|return;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
return|return;
if|if
condition|(
name|docbook
operator|&&
name|xml_table_level
operator|&&
operator|!
name|in_table_title
operator|&&
operator|!
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|&&
operator|!
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|&&
operator|!
name|cr_or_whitespace
argument_list|(
name|character
argument_list|)
operator|&&
operator|!
name|in_indexterm
condition|)
block|{
name|in_table_title
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first_section_opened
operator|&&
operator|!
name|xml_in_abstract
operator|&&
operator|!
name|xml_in_book_title
operator|&&
operator|!
name|xml_no_para
operator|&&
name|character
operator|!=
literal|'\r'
operator|&&
name|character
operator|!=
literal|'\n'
operator|&&
name|character
operator|!=
literal|' '
operator|&&
operator|!
name|is_in_insertion_of_type
argument_list|(
name|copying
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|xml_in_bookinfo
condition|)
block|{
name|xml_insert_element
argument_list|(
name|BOOKINFO
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_bookinfo
operator|=
literal|1
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xml_sort_index
operator|&&
operator|!
name|xml_in_xref_token
operator|&&
operator|!
name|xml_dont_touch_items_defs
condition|)
block|{
if|if
condition|(
name|xml_after_table_term
operator|&&
name|xml_table_level
operator|&&
operator|!
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_after_table_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml_after_def_term
condition|)
block|{
name|xml_after_def_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFINITIONITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xml_just_after_element
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|inhibit_paragraph_indentation
condition|)
block|{
if|if
condition|(
name|character
operator|==
literal|'\r'
operator|||
name|character
operator|==
literal|'\n'
operator|||
name|character
operator|==
literal|'\t'
operator|||
name|character
operator|==
literal|' '
condition|)
return|return;
name|xml_just_after_element
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_element_list
index|[
name|xml_current_element
argument_list|()
index|]
operator|.
name|contains_para
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|!
name|xml_no_para
operator|&&
operator|!
name|cr_or_whitespace
argument_list|(
name|character
argument_list|)
operator|&&
operator|!
name|in_fixed_width_font
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml_in_para
operator|&&
name|character
operator|==
literal|'\n'
operator|&&
name|xml_last_character
operator|==
literal|'\n'
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|!
name|xml_no_para
operator|&&
name|xml_element_list
index|[
name|xml_current_element
argument_list|()
index|]
operator|.
name|contains_para
condition|)
block|{
name|xml_end_para
argument_list|()
expr_stmt|;
name|xml_just_after_element
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xml_in_menu_entry_comment
operator|&&
name|character
operator|==
literal|'\n'
operator|&&
name|xml_last_character
operator|==
literal|'\n'
condition|)
block|{
name|xml_insert_element
argument_list|(
name|MENUCOMMENT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry_comment
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|MENUENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_menu_entry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_in_menu_entry_comment
operator|&&
name|whitespace
argument_list|(
name|character
argument_list|)
operator|&&
name|cr_or_whitespace
argument_list|(
name|xml_last_character
argument_list|)
condition|)
return|return;
if|if
condition|(
name|character
operator|==
literal|'\n'
operator|&&
operator|!
name|xml_in_para
operator|&&
operator|!
name|inhibit_paragraph_indentation
condition|)
return|return;
name|xml_last_character
operator|=
name|character
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'&'
operator|&&
name|escape_html
condition|)
name|insert_string
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|character
operator|==
literal|'<'
operator|&&
name|escape_html
condition|)
name|insert_string
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|character
operator|==
literal|'\n'
operator|&&
operator|!
name|xml_keep_space
condition|)
block|{
if|if
condition|(
operator|!
name|xml_in_para
operator|&&
name|xml_just_after_element
operator|&&
operator|!
name|multitable_active
condition|)
return|return;
else|else
name|insert
argument_list|(
name|docbook
condition|?
literal|'\n'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|insert
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|xml_insert_footnote
parameter_list|(
name|char
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xml_in_para
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
name|xml_in_footnote
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FOOTNOTE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"<para>"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"</para>"
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FOOTNOTE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_footnote
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to keep the quotation stack ourself, because insertion_stack    loses item_function when we are closing the block, so we don't know    what to close then.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|quotation_elt
block|{
name|struct
name|quotation_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|}
name|QUOTATION_ELT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|QUOTATION_ELT
modifier|*
name|quotation_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xml_insert_quotation
parameter_list|(
name|char
modifier|*
name|type
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|int
name|quotation_started
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|QUOTATION_ELT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QUOTATION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|=
name|xstrdup
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|quotation_stack
expr_stmt|;
name|quotation_stack
operator|=
name|new
expr_stmt|;
block|}
else|else
name|type
operator|=
name|quotation_stack
operator|->
name|type
expr_stmt|;
comment|/* Make use of special quotation styles of Docbook if we can.  */
if|if
condition|(
name|docbook
operator|&&
name|strlen
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Let's assume it started.  */
name|quotation_started
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
literal|"tip"
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|TIP
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
literal|"note"
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|NOTE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
literal|"important"
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|IMPORTANT
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
literal|"warning"
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|WARNING
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
literal|"caution"
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|CAUTION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
comment|/* Didn't find a known quotation type :\ */
name|quotation_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quotation_started
condition|)
block|{
name|xml_insert_element
argument_list|(
name|QUOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|type
argument_list|)
operator|&&
name|arg
operator|==
name|START
condition|)
name|execute_string
argument_list|(
literal|"@b{%s:} "
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
name|QUOTATION_ELT
modifier|*
name|temp
init|=
name|quotation_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return;
name|quotation_stack
operator|=
name|quotation_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Starting generic docbook floats.  Just starts elt with correct label    and id attributes, and inserts title.  */
end_comment

begin_function
name|void
name|xml_begin_docbook_float
parameter_list|(
name|int
name|elt
parameter_list|)
block|{
if|if
condition|(
name|current_float_used_title
argument_list|()
condition|)
comment|/* in a nested float */
block|{
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|START
argument_list|)
expr_stmt|;
comment|/* just insert the tag */
return|return;
block|}
comment|/* OK, need the title, tag, etc. */
if|if
condition|(
name|elt
operator|==
name|CARTOUCHE
condition|)
comment|/* no labels on<sidebar> */
block|{
if|if
condition|(
name|strlen
argument_list|(
name|current_float_id
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|START
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|elt
argument_list|,
name|START
argument_list|,
literal|"id=\"%s\""
argument_list|,
name|xml_id
argument_list|(
name|current_float_id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|current_float_id
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|elt
argument_list|,
name|START
argument_list|,
literal|"label=\"\""
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|elt
argument_list|,
name|START
argument_list|,
literal|"id=\"%s\" label=\"%s\""
argument_list|,
name|xml_id
argument_list|(
name|current_float_id
argument_list|()
argument_list|)
argument_list|,
name|current_float_number
argument_list|()
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|current_float_title
argument_list|()
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|current_float_set_title_used
argument_list|()
expr_stmt|;
comment|/* mark this title, tag, etc used */
block|}
end_function

begin_comment
comment|/*  * Lists and Tables  */
end_comment

begin_function
name|void
name|xml_begin_table
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|item_function
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|table
case|:
comment|/*if (docbook)*/
comment|/* 05-08 */
block|{
name|xml_insert_element
argument_list|(
name|TABLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_table_level
operator|++
expr_stmt|;
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
name|xml_after_table_term
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|itemize
case|:
if|if
condition|(
operator|!
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ITEMIZE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_table_level
operator|++
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ITEMFUNCTION
argument_list|,
name|START
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|item_function
operator|==
name|COMMAND_PREFIX
operator|&&
name|item_function
index|[
name|strlen
argument_list|(
name|item_function
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|&&
name|command_needs_braces
argument_list|(
name|item_function
operator|+
literal|1
argument_list|)
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_function
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_function
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ITEMFUNCTION
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|ITEMIZE
argument_list|,
name|START
argument_list|,
literal|"mark=\"%s\""
argument_list|,
operator|(
operator|*
name|item_function
operator|==
name|COMMAND_PREFIX
operator|)
condition|?
operator|&
name|item_function
index|[
literal|1
index|]
else|:
name|item_function
argument_list|)
expr_stmt|;
name|xml_table_level
operator|++
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xml_end_table
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|table
case|:
if|if
condition|(
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_insert_element
argument_list|(
name|TABLEITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|TABLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_after_table_term
operator|=
literal|0
expr_stmt|;
name|xml_table_level
operator|--
expr_stmt|;
break|break;
case|case
name|itemize
case|:
if|if
condition|(
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* gnat-style manual contains an itemized list without items! */
if|if
condition|(
name|in_table_title
condition|)
block|{
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|in_table_title
operator|=
literal|0
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|ITEMIZE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_table_level
operator|--
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xml_begin_item
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_begin_table_item
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xml_after_table_term
condition|)
block|{
if|if
condition|(
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
condition|)
name|xml_insert_element
argument_list|(
name|TABLEITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_table_title
condition|)
block|{
name|in_table_title
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|TABLEITEM
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|TABLETERM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_tableitem
index|[
name|xml_table_level
index|]
operator|=
literal|1
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
name|xml_after_table_term
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_continue_table_item
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|TABLETERM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_after_table_term
operator|=
literal|1
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_begin_enumerate
parameter_list|(
name|char
modifier|*
name|enum_arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|docbook
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"first=\"%s\""
argument_list|,
name|enum_arg
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enum_arg
argument_list|)
condition|)
block|{
name|int
name|enum_val
init|=
name|atoi
argument_list|(
name|enum_arg
argument_list|)
decl_stmt|;
comment|/* Have to check the value, not just the first digit.  */
if|if
condition|(
name|enum_val
operator|==
literal|0
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"numeration=\"arabic\" role=\"0\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|enum_val
operator|==
literal|1
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"numeration=\"arabic\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"continuation=\"continues\" numeration=\"arabic\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|enum_arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|enum_arg
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"numeration=\"upperalpha\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"continuation=\"continues\" numeration=\"upperalpha\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|enum_arg
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"numeration=\"loweralpha\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element_with_attribute
argument_list|(
name|ENUMERATE
argument_list|,
name|START
argument_list|,
literal|"continuation=\"continues\" numeration=\"loweralpha\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|xml_table_level
operator|++
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_enumerate
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_in_item
index|[
name|xml_table_level
index|]
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_item
index|[
name|xml_table_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|ENUMERATE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_table_level
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_insert_text_file
parameter_list|(
name|char
modifier|*
name|name_arg
parameter_list|)
block|{
name|char
modifier|*
name|fullname
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name_arg
argument_list|)
operator|+
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|image_file
decl_stmt|;
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|name_arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname
argument_list|,
literal|".txt"
argument_list|)
expr_stmt|;
name|image_file
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_file
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|save_inhibit_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|save_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|xml_insert_element
argument_list|(
name|TEXTOBJECT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DISPLAY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we need to remove the final newline if the image          file is only one line to allow in-line images.  On the          other hand, they could just make the file without a          final newline.  */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|image_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|add_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save_inhibit_indentation
expr_stmt|;
name|filling_enabled
operator|=
name|save_filling_enabled
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DISPLAY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TEXTOBJECT
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|image_file
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"@image file `%s' unreadable: %s"
argument_list|)
argument_list|,
name|fullname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If NAME.EXT is accessible or FORCE is nonzero, insert a docbook    imagedata element for FMT.  Return 1 if inserted something, 0 else.  */
end_comment

begin_function
specifier|static
name|int
name|try_docbook_image
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|used
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|ext
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s.%s"
argument_list|,
name|name
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|||
name|access
argument_list|(
name|fullname
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xml_insert_element
argument_list|(
name|IMAGEOBJECT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element_with_attribute
argument_list|(
name|IMAGEDATA
argument_list|,
name|START
argument_list|,
literal|"fileref=\"%s\" format=\"%s\""
argument_list|,
name|fullname
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|IMAGEDATA
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|IMAGEOBJECT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_function
name|void
name|xml_insert_docbook_image
parameter_list|(
name|char
modifier|*
name|name_arg
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|elt
init|=
name|xml_in_para
condition|?
name|INLINEIMAGE
else|:
name|MEDIAOBJECT
decl_stmt|;
if|if
condition|(
name|is_in_insertion_of_type
argument_list|(
name|floatenv
argument_list|)
condition|)
name|xml_begin_docbook_float
argument_list|(
name|INFORMALFIGURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|xml_in_para
condition|)
name|xml_insert_element
argument_list|(
name|INFORMALFIGURE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_no_para
operator|++
expr_stmt|;
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|START
argument_list|)
expr_stmt|;
comment|/* A selected few from http://docbook.org/tdg/en/html/imagedata.html.  */
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"eps"
argument_list|,
literal|"EPS"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"gif"
argument_list|,
literal|"GIF"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"jpg"
argument_list|,
literal|"JPG"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"jpeg"
argument_list|,
literal|"JPEG"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"pdf"
argument_list|,
literal|"PDF"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"png"
argument_list|,
literal|"PNG"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"svg"
argument_list|,
literal|"SVG"
argument_list|,
literal|0
argument_list|)
condition|)
name|found
operator|++
expr_stmt|;
comment|/* If no luck so far, just assume we'll eventually have a jpg.  */
if|if
condition|(
operator|!
name|found
condition|)
name|try_docbook_image
argument_list|(
name|name_arg
argument_list|,
literal|"jpg"
argument_list|,
literal|"JPG"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xml_insert_text_file
argument_list|(
name|name_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_no_para
operator|--
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|MEDIAOBJECT
condition|)
name|xml_insert_element
argument_list|(
name|INFORMALFIGURE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_asterisk
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *     INDEX  */
end_comment

begin_comment
comment|/* Used to separate primary and secondary entries in an index -- we need    to have real multilivel indexing support, not just string analysis.  */
end_comment

begin_define
define|#
directive|define
name|INDEX_SEP
value|"@this string will never appear@"
end_define

begin_comment
comment|/* was , */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|}
name|XML_SYNONYM
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|XML_SYNONYM
modifier|*
modifier|*
name|xml_synonyms
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xml_synonyms_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xml_insert_indexterm
parameter_list|(
name|char
modifier|*
name|indexterm
parameter_list|,
name|char
modifier|*
name|index
parameter_list|)
block|{
comment|/* @index commands can appear between @item and @itemx, @deffn and @deffnx.  */
if|if
condition|(
operator|!
name|docbook
condition|)
block|{
comment|/* Check to see if we need to do index redirection per @synindex.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xml_synonyms_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|xml_synonyms
index|[
name|i
index|]
operator|->
name|from
argument_list|,
name|index
argument_list|)
condition|)
name|index
operator|=
name|xstrdup
argument_list|(
name|xml_synonyms
index|[
name|i
index|]
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
name|xml_dont_touch_items_defs
operator|++
expr_stmt|;
name|xml_insert_element_with_attribute
argument_list|(
name|INDEXTERM
argument_list|,
name|START
argument_list|,
literal|"index=\"%s\""
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|in_indexterm
operator|=
literal|1
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|indexterm
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INDEXTERM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|in_indexterm
operator|=
literal|0
expr_stmt|;
name|xml_dont_touch_items_defs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|primary
init|=
name|NULL
decl_stmt|,
modifier|*
name|secondary
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|indexterm
operator|+
literal|1
argument_list|,
name|INDEX_SEP
argument_list|)
condition|)
block|{
name|primary
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|indexterm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|primary
argument_list|,
name|indexterm
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|strstr
argument_list|(
name|primary
operator|+
literal|1
argument_list|,
name|INDEX_SEP
argument_list|)
expr_stmt|;
operator|*
name|secondary
operator|=
literal|'\0'
expr_stmt|;
name|secondary
operator|+=
name|strlen
argument_list|(
name|INDEX_SEP
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element_with_attribute
argument_list|(
name|INDEXTERM
argument_list|,
name|START
argument_list|,
literal|"role=\"%s\""
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|in_indexterm
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRIMARY
argument_list|,
name|START
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|primary
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|indexterm
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRIMARY
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
name|xml_insert_element
argument_list|(
name|SECONDARY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|secondary
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SECONDARY
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|INDEXTERM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|in_indexterm
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|xml_last_section_output_position
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|last_division_letter
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|index_primary
index|[
literal|2000
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** xx no fixed limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indexdivempty
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xml_close_indexentry
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|in_indexentry
condition|)
return|return;
if|if
condition|(
name|in_secondary
condition|)
name|xml_insert_element
argument_list|(
name|SECONDARYIE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INDEXENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|in_secondary
operator|=
literal|0
expr_stmt|;
name|in_indexentry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_begin_index
parameter_list|(
name|void
parameter_list|)
block|{
typedef|typedef
struct|struct
name|xml_index_title
block|{
name|struct
name|xml_index_title
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
block|}
name|XML_INDEX_TITLE
typedef|;
specifier|static
name|XML_INDEX_TITLE
modifier|*
name|xml_index_titles
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|handling_delayed_writes
condition|)
block|{
comment|/* We assume that we just opened a section, and so that the last output is<SECTION ID="node-name"><TITLE>Title</TITLE>          where SECTION can be CHAPTER, ...  */
name|XML_INDEX_TITLE
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XML_INDEX_TITLE
argument_list|)
argument_list|)
decl_stmt|;
name|xml_section
modifier|*
name|temp
init|=
name|last_section
decl_stmt|;
name|int
name|l
init|=
name|output_paragraph_offset
operator|-
name|xml_last_section_output_position
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tmp
decl_stmt|;
name|strncpy
argument_list|(
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* We remove<SECTION */
name|tmp
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'<'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* ... and its label attribute.  */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|" label="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|output_paragraph_offset
operator|=
name|xml_last_section_output_position
expr_stmt|;
name|xml_last_section_output_position
operator|=
literal|0
expr_stmt|;
name|xml_pop_current_element
argument_list|()
expr_stmt|;
comment|/* remove section element from elements stack */
if|if
condition|(
name|last_section
condition|)
name|last_section
operator|=
name|last_section
operator|->
name|prev
expr_stmt|;
comment|/* remove section from sections stack */
if|if
condition|(
name|temp
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|title
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|xml_index_titles
expr_stmt|;
name|xml_index_titles
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|int
name|xml_index_titles_reversed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|xml_index_titles_reversed
condition|)
block|{
name|xml_index_titles
operator|=
operator|(
name|XML_INDEX_TITLE
operator|*
operator|)
name|reverse_list
argument_list|(
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|xml_index_titles
argument_list|)
expr_stmt|;
name|xml_index_titles_reversed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We put<INDEX> */
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|START
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_index_titles
condition|)
block|{
comment|/* Remove the final> */
name|output_paragraph_offset
operator|--
expr_stmt|;
comment|/* and put  ID="node-name"><TITLE>Title</TITLE> */
name|insert_string
argument_list|(
name|xml_index_titles
operator|->
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xml_index_titles
operator|->
name|title
argument_list|)
expr_stmt|;
name|xml_index_titles
operator|=
name|xml_index_titles
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|xml_index_divisions
condition|)
block|{
name|xml_insert_element
argument_list|(
name|INDEXDIV
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|indexdivempty
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|xml_end_index
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_close_indexentry
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml_index_divisions
condition|)
name|xml_insert_element
argument_list|(
name|INDEXDIV
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_index_divide
parameter_list|(
name|char
modifier|*
name|entry
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|entry
argument_list|)
operator|>
operator|(
name|strlen
argument_list|(
name|xml_element_list
index|[
name|CODE
index|]
operator|.
name|name
argument_list|)
operator|+
literal|2
operator|)
operator|&&
name|strncmp
argument_list|(
name|entry
operator|+
literal|1
argument_list|,
name|xml_element_list
index|[
name|CODE
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|xml_element_list
index|[
name|CODE
index|]
operator|.
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
name|entry
index|[
name|strlen
argument_list|(
name|xml_element_list
index|[
name|CODE
index|]
operator|.
name|name
argument_list|)
operator|+
literal|2
index|]
expr_stmt|;
else|else
name|c
operator|=
name|entry
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
name|c
argument_list|)
operator|!=
name|last_division_letter
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|last_division_letter
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|xml_close_indexentry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|indexdivempty
condition|)
block|{
name|xml_insert_element
argument_list|(
name|INDEXDIV
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INDEXDIV
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xml_insert_indexentry
parameter_list|(
name|char
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|node
parameter_list|)
block|{
name|char
modifier|*
name|primary
init|=
name|NULL
decl_stmt|,
modifier|*
name|secondary
decl_stmt|;
if|if
condition|(
name|xml_index_divisions
condition|)
name|xml_index_divide
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|indexdivempty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|entry
operator|+
literal|1
argument_list|,
name|INDEX_SEP
argument_list|)
condition|)
block|{
name|primary
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|entry
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|primary
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|strstr
argument_list|(
name|primary
operator|+
literal|1
argument_list|,
name|INDEX_SEP
argument_list|)
expr_stmt|;
operator|*
name|secondary
operator|=
literal|'\0'
expr_stmt|;
name|secondary
operator|+=
name|strlen
argument_list|(
name|INDEX_SEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_secondary
operator|&&
name|strcmp
argument_list|(
name|primary
argument_list|,
name|index_primary
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xml_insert_element
argument_list|(
name|SECONDARYIE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SECONDARYIE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|secondary
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xml_close_indexentry
argument_list|()
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INDEXENTRY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|in_indexentry
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRIMARYIE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|primary
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRIMARYIE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SECONDARYIE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|secondary
argument_list|)
expr_stmt|;
name|in_secondary
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|xml_close_indexentry
argument_list|()
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INDEXENTRY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|in_indexentry
operator|=
literal|1
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRIMARYIE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|/* Don't link to @unnumbered sections directly.      We are disabling warnings temporarily, otherwise these xrefs      will cause bogus warnings about missing punctuation.  */
block|{
specifier|extern
name|int
name|print_warnings
decl_stmt|;
name|int
name|save_print_warnings
init|=
name|print_warnings
decl_stmt|;
name|print_warnings
operator|=
literal|0
expr_stmt|;
name|execute_string
argument_list|(
literal|"%cxref{%s}"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|xstrdup
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|print_warnings
operator|=
name|save_print_warnings
expr_stmt|;
block|}
if|if
condition|(
name|primary
condition|)
block|{
name|strcpy
argument_list|(
name|index_primary
argument_list|,
name|primary
argument_list|)
expr_stmt|;
comment|/*      xml_insert_element (SECONDARYIE, END);*/
comment|/*     *(secondary-1) = ',';*/
comment|/* necessary ? */
name|free
argument_list|(
name|primary
argument_list|)
expr_stmt|;
block|}
else|else
name|xml_insert_element
argument_list|(
name|PRIMARYIE
argument_list|,
name|END
argument_list|)
expr_stmt|;
comment|/*  xml_insert_element (INDEXENTRY, END); */
block|}
end_function

begin_function
name|void
name|xml_synindex
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xml_synonyms_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|xml_synonyms
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
name|slot
operator|=
name|xml_synonyms_count
expr_stmt|;
name|xml_synonyms_count
operator|++
expr_stmt|;
name|xml_synonyms
operator|=
operator|(
name|XML_SYNONYM
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|xml_synonyms
argument_list|,
operator|(
name|xml_synonyms_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|XML_SYNONYM
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xml_synonyms
index|[
name|slot
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XML_SYNONYM
argument_list|)
argument_list|)
expr_stmt|;
name|xml_synonyms
index|[
name|slot
index|]
operator|->
name|from
operator|=
name|xstrdup
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|xml_synonyms
index|[
name|slot
index|]
operator|->
name|to
operator|=
name|xstrdup
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MULTITABLE  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|multitable_columns_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|multitable_column_widths
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xml_begin_multitable
parameter_list|(
name|int
name|ncolumns
parameter_list|,
name|int
modifier|*
name|column_widths
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|docbook
condition|)
block|{
if|if
condition|(
name|is_in_insertion_of_type
argument_list|(
name|floatenv
argument_list|)
condition|)
name|xml_begin_docbook_float
argument_list|(
name|MULTITABLE
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element
argument_list|(
name|MULTITABLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|multitable_columns_count
operator|=
name|ncolumns
expr_stmt|;
name|multitable_column_widths
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ncolumns
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|multitable_column_widths
argument_list|,
name|column_widths
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ncolumns
argument_list|)
expr_stmt|;
name|xml_no_para
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xml_insert_element
argument_list|(
name|MULTITABLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncolumns
condition|;
name|i
operator|++
control|)
block|{
name|xml_insert_element
argument_list|(
name|COLSPEC
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%d"
argument_list|,
name|column_widths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|COLSPEC
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_no_para
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xml_begin_multitable_group
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xml_insert_element_with_attribute
argument_list|(
name|TGROUP
argument_list|,
name|START
argument_list|,
literal|"cols=\"%d\""
argument_list|,
name|multitable_columns_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|multitable_columns_count
condition|;
name|i
operator|++
control|)
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|COLSPEC
argument_list|,
name|START
argument_list|,
literal|"colwidth=\"%d*\""
argument_list|,
name|multitable_column_widths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|COLSPEC
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xml_end_multitable_row
parameter_list|(
name|int
name|first_row
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first_row
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ROW
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headitem_flag
condition|)
block|{
if|if
condition|(
operator|!
name|first_row
condition|)
block|{
if|if
condition|(
name|after_headitem
condition|)
name|xml_insert_element
argument_list|(
name|THEAD
argument_list|,
name|END
argument_list|)
expr_stmt|;
else|else
name|xml_insert_element
argument_list|(
name|TBODY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TGROUP
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_begin_multitable_group
argument_list|()
expr_stmt|;
name|xml_insert_element
argument_list|(
name|THEAD
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_row
condition|)
block|{
name|xml_begin_multitable_group
argument_list|()
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TBODY
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|after_headitem
condition|)
block|{
name|xml_insert_element
argument_list|(
name|THEAD
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|TBODY
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_row
condition|)
name|xml_insert_element
argument_list|(
name|TBODY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ROW
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ENTRY
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_multitable_column
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|ENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ENTRY
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_multitable
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|ENTRY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ROW
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_headitem
condition|)
block|{
if|if
condition|(
name|docbook
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"@headitem as the last item of @multitable produces invalid Docbook documents"
argument_list|)
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|THEAD
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
name|xml_insert_element
argument_list|(
name|TBODY
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|docbook
condition|)
name|xml_insert_element
argument_list|(
name|TGROUP
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|MULTITABLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_no_para
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parameters in @def definitions  */
end_comment

begin_define
define|#
directive|define
name|DEFUN_SELF_DELIMITING
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == '(' || (c) == ')' || (c) == '[' || (c) == ']')
end_define

begin_function
name|void
name|xml_process_defun_args
parameter_list|(
name|char
modifier|*
modifier|*
name|defun_args
parameter_list|,
name|int
name|auto_var_p
parameter_list|)
block|{
name|int
name|pending_space
init|=
literal|0
decl_stmt|;
name|int
name|just_after_paramtype
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|defun_arg
init|=
operator|*
name|defun_args
operator|++
decl_stmt|;
if|if
condition|(
name|defun_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|pending_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pending_space
condition|)
block|{
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pending_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFDELIMITER
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFDELIMITER
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
name|COMMAND_PREFIX
operator|||
name|just_after_paramtype
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|','
operator|||
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFDELIMITER
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFDELIMITER
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto_var_p
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFPARAM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xml_insert_element
argument_list|(
name|DEFPARAMTYPE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFPARAMTYPE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|just_after_paramtype
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|xml_begin_definition
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|DEFINITION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_definition_level
operator|++
expr_stmt|;
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_end_definition
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DEFINITIONITEM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_def_item
index|[
name|xml_definition_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|xml_after_def_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFINITION
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_definition_level
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xml_begin_def_term
parameter_list|(
name|int
name|base_type
parameter_list|,
specifier|const
name|char
modifier|*
name|category
parameter_list|,
name|char
modifier|*
name|defined_name
parameter_list|,
name|char
modifier|*
name|type_name
parameter_list|,
name|char
modifier|*
name|type_name2
parameter_list|)
block|{
name|xml_after_def_term
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFINITIONTERM
argument_list|,
name|START
argument_list|)
expr_stmt|;
comment|/* Index entry */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|deftypefn
case|:
name|execute_string
argument_list|(
literal|"@findex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvr
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|"@vindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypecv
case|:
case|case
name|deftypeivar
case|:
name|execute_string
argument_list|(
literal|"@vindex %s %s %s\n"
argument_list|,
name|defined_name
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
case|case
name|defop
case|:
case|case
name|deftypeop
case|:
name|execute_string
argument_list|(
literal|"@findex %s %s %s\n"
argument_list|,
name|defined_name
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|"@tindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Start with category.  */
name|xml_insert_element
argument_list|(
name|DEFCATEGORY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|docbook
condition|?
literal|"--- %s:"
else|:
literal|"%s"
argument_list|,
name|category
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFCATEGORY
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Output type name first for typed definitions.  */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|xml_insert_element
argument_list|(
name|DEFTYPE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFTYPE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypecv
case|:
case|case
name|deftypeivar
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
name|xml_insert_element
argument_list|(
name|DEFTYPE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|type_name2
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFTYPE
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xml_insert_element
argument_list|(
name|DEFCLASS
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFCLASS
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Categorize rest of the definitions.  */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|deftypefn
case|:
name|xml_insert_element
argument_list|(
name|DEFFUNCTION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFFUNCTION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvr
case|:
case|case
name|deftypevr
case|:
name|xml_insert_element
argument_list|(
name|DEFVARIABLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFVARIABLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
name|xml_insert_element
argument_list|(
name|DEFDATATYPE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFDATATYPE
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
case|case
name|deftypecv
case|:
case|case
name|deftypeivar
case|:
name|xml_insert_element
argument_list|(
name|DEFCLASSVAR
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFCLASSVAR
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypemethod
case|:
comment|/* Operation / Method */
name|xml_insert_element
argument_list|(
name|DEFOPERATION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DEFOPERATION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xml_end_def_term
parameter_list|(
name|void
parameter_list|)
block|{
name|xml_insert_element
argument_list|(
name|DEFINITIONTERM
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_after_def_term
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

