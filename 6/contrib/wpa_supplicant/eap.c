begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / EAP state machines (RFC 4137)  * Copyright (c) 2004-2005, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"config_ssid.h"
end_include

begin_include
include|#
directive|include
file|"tls.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|"pcsc_funcs.h"
end_include

begin_include
include|#
directive|include
file|"wpa_ctrl.h"
end_include

begin_define
define|#
directive|define
name|EAP_MAX_AUTH_ROUNDS
value|50
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MD5
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_md5
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_tls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_mschapv2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PEAP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_peap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TTLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_ttls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_GTC
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_gtc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_OTP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_otp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_SIM
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_sim
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_LEAP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_leap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PSK
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_psk
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_AKA
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_aka
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_FAST
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_fast
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PAX
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_pax
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_methods
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EAP_MD5
operator|&
name|eap_method_md5
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_TLS
operator|&
name|eap_method_tls
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
operator|&
name|eap_method_mschapv2
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_PEAP
operator|&
name|eap_method_peap
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_TTLS
operator|&
name|eap_method_ttls
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_GTC
operator|&
name|eap_method_gtc
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_OTP
operator|&
name|eap_method_otp
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_SIM
operator|&
name|eap_method_sim
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_LEAP
operator|&
name|eap_method_leap
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_PSK
operator|&
name|eap_method_psk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_AKA
operator|&
name|eap_method_aka
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_FAST
operator|&
name|eap_method_fast
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_PAX
operator|&
name|eap_method_pax
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_EAP_METHODS
value|(sizeof(eap_methods) / sizeof(eap_methods[0]))
end_define

begin_comment
comment|/**  * eap_sm_get_eap_methods - Get EAP method based on type number  * @method: EAP type number  * Returns: Pointer to EAP method of %NULL if not found  */
end_comment

begin_function
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_sm_get_eap_methods
parameter_list|(
name|int
name|method
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|method
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|int
name|decision
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Definitions for clarifying state machine implementation */
end_comment

begin_define
define|#
directive|define
name|SM_STATE
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|static void sm_ ## machine ## _ ## state ## _Enter(struct eap_sm *sm, \ 	int global)
end_define

begin_define
define|#
directive|define
name|SM_ENTRY
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|if (!global || sm->machine ## _state != machine ## _ ## state) { \ 	sm->changed = TRUE; \ 	wpa_printf(MSG_DEBUG, "EAP: " #machine " entering state " #state); \ } \ sm->machine ## _state = machine ## _ ## state;
end_define

begin_define
define|#
directive|define
name|SM_ENTER
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 0)
end_define

begin_define
define|#
directive|define
name|SM_ENTER_GLOBAL
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 1)
end_define

begin_define
define|#
directive|define
name|SM_STEP
parameter_list|(
name|machine
parameter_list|)
define|\
value|static void sm_ ## machine ## _Step(struct eap_sm *sm)
end_define

begin_define
define|#
directive|define
name|SM_STEP_RUN
parameter_list|(
name|machine
parameter_list|)
value|sm_ ## machine ## _Step(sm)
end_define

begin_function
specifier|static
name|Boolean
name|eapol_get_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|eapol_get_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eapol_get_eapReqData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eapReqData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_deinit_prev_method
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: deinitialize previously used EAP method "
literal|"(%d, %s) at %s"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|,
name|txt
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: maintaining EAP method data for "
literal|"fast reauthentication"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"INITIALIZE"
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|FALSE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* new session - make sure this does not match with 			  * the first EAP-Packet */
comment|/* 	 * RFC 4137 does not reset eapResp and eapNoResp here. However, this 	 * seemed to be able to trigger cases where both were set and if EAPOL 	 * state machine uses eapNoResp first, it may end up not sending a real 	 * reply correctly. This occurred when the workaround in FAIL state set 	 * eapNoResp = TRUE.. Maybe that workaround needs to be fixed to do 	 * something else(?) 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* parse rxReq, rxSuccess, rxFailure, reqId, reqMethod */
name|eap_sm_parseEapReq
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|GET_METHOD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_sm_allowMethod
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|)
condition|)
block|{
name|int
name|reinit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|method
operator|==
name|sm
operator|->
name|reqMethod
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using previous method data"
literal|" for fast re-authentication"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"GET_METHOD"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
name|sm
operator|->
name|m
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|selectedMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: initialize selected EAP "
literal|"method (%d, %s)"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: Failed to initialize EAP method "
literal|"%d (%s)"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
operator|(
name|config
operator|->
name|pending_req_pin
operator|||
name|config
operator|->
name|pending_req_passphrase
operator|)
condition|)
block|{
comment|/* 					 * Return without generating Nak in 					 * order to allow entering of PIN code 					 * or passphrase to retry the current 					 * EAP packet. 					 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Pending "
literal|"PIN/passphrase request - "
literal|"skip Nak"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|sm
operator|->
name|methodState
operator|=
name|METHOD_INIT
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_METHOD
literal|"EAP method %d (%s) selected"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNak
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|struct
name|eap_method_ret
name|ret
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP::METHOD - method not selected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* Get ignore, methodState, decision, allowNotifications, and 	 * eapRespData. */
name|memset
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|ignore
operator|=
name|sm
operator|->
name|ignore
expr_stmt|;
name|ret
operator|.
name|methodState
operator|=
name|sm
operator|->
name|methodState
expr_stmt|;
name|ret
operator|.
name|decision
operator|=
name|sm
operator|->
name|decision
expr_stmt|;
name|ret
operator|.
name|allowNotifications
operator|=
name|sm
operator|->
name|allowNotifications
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|ret
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method process -> ignore=%s "
literal|"methodState=%s decision=%s"
argument_list|,
name|ret
operator|.
name|ignore
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|ret
operator|.
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|ret
operator|.
name|decision
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ignore
operator|=
name|ret
operator|.
name|ignore
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
return|return;
name|sm
operator|->
name|methodState
operator|=
name|ret
operator|.
name|methodState
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|ret
operator|.
name|decision
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|ret
operator|.
name|allowNotifications
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
operator|&&
name|sm
operator|->
name|m
operator|->
name|getKey
operator|&&
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
name|memcpy
argument_list|(
name|sm
operator|->
name|last_md5
argument_list|,
name|sm
operator|->
name|req_md5
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|reqId
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|malloc
argument_list|(
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|memcpy
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespDataLen
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
block|}
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDENTITY
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processIdentity
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NOTIFICATION
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processNotify
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNotify
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|sm
operator|->
name|eapRespData
operator|=
name|malloc
argument_list|(
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
name|memcpy
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
name|sm
operator|->
name|lastRespDataLen
expr_stmt|;
block|}
block|}
else|else
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here, but this seems to be required 	 * to get EAPOL Supplicant backend state machine into SUCCESS state. In 	 * addition, either eapResp or eapNoResp is required to be set after 	 * processing the received EAP frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here. However, either eapResp or 	 * eapNoResp is required to be set after processing the received EAP 	 * frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_FAILURE
literal|"EAP authentication failed"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|eap_success_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|reqId
parameter_list|,
name|int
name|lastId
parameter_list|)
block|{
comment|/* 	 * At least Microsoft IAS and Meetinghouse Aegis seem to be sending 	 * EAP-Success/Failure with lastId + 1 even though RFC 3748 and 	 * RFC 4137 require that reqId == lastId. In addition, it looks like 	 * Ringmaster v2.1.2.0 would be using lastId + 2 in EAP-Success. 	 * 	 * Accept this kind of Id if EAP workarounds are enabled. These are 	 * unauthenticated plaintext messages, so this should have minimal 	 * security implications (bit easier to fake EAP-Success/Failure). 	 */
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
operator|(
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|||
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|2
operator|)
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Workaround for unexpected "
literal|"identifier field in EAP Success: "
literal|"reqId=%d lastId=%d (these are supposed to be "
literal|"same)"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Success Id mismatch - reqId=%d "
literal|"lastId=%d"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
name|int
name|duplicate
decl_stmt|;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|)
operator|&&
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|||
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|>
name|EAP_MAX_AUTH_ROUNDS
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|==
name|EAP_MAX_AUTH_ROUNDS
operator|+
literal|1
condition|)
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: more than %d "
literal|"authentication rounds - abort"
argument_list|,
name|EAP_MAX_AUTH_ROUNDS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altReject
argument_list|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
name|sm
operator|->
name|leap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_PEAP
operator|&&
name|sm
operator|->
name|peap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
name|duplicate
operator|=
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|)
operator|&&
name|sm
operator|->
name|rxReq
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|duplicate
operator|&&
name|memcmp
argument_list|(
name|sm
operator|->
name|req_md5
argument_list|,
name|sm
operator|->
name|last_md5
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * RFC 4137 uses (reqId == lastId) as the only 			 * verification for duplicate EAP requests. However, 			 * this misses cases where the AS is incorrectly using 			 * the same id again; and unfortunately, such 			 * implementations exist. Use MD5 hash as an extra 			 * verification for the packets being duplicate to 			 * workaround these issues. 			 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: AS used the same Id again,"
literal|" but EAP packets were not identical"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: workaround - assume this "
literal|"is not a duplicate packet"
argument_list|)
expr_stmt|;
name|duplicate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|rxSuccess
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
operator|(
operator|(
name|sm
operator|->
name|rxFailure
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|&&
operator|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_LEAP
operator|||
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
name|duplicate
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_NOTIFICATION
operator|&&
name|sm
operator|->
name|allowNotifications
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_IDENTITY
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_NOTIFICATION
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|sm
operator|->
name|selectedMethod
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
operator|(
name|sm
operator|->
name|rxSuccess
operator|||
name|sm
operator|->
name|rxResp
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_GET_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|sm
operator|->
name|reqMethod
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDENTITY
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NOTIFICATION
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|method
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|method
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Nak (requested type %d not "
literal|"allowed)"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
operator|+
name|NUM_EAP_METHODS
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_NAK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|!=
name|sm
operator|->
name|reqMethod
operator|&&
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|++
operator|=
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|pos
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed methods"
argument_list|,
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
operator|)
operator|+
literal|1
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|pos
operator|++
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_STARTED
literal|"EAP authentication started"
argument_list|)
expr_stmt|;
comment|/* TODO: could save displayable message so that it can be shown to the 	 * user in case of interaction is required */
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Identity data"
argument_list|,
name|pos
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_imsi_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|int
name|aka
init|=
literal|0
decl_stmt|;
name|char
name|imsi
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|imsi_len
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
name|ssid
operator|->
name|eap_methods
decl_stmt|;
name|imsi_len
operator|=
sizeof|sizeof
argument_list|(
name|imsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|scard_get_imsi
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|imsi
argument_list|,
operator|&
name|imsi_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to get IMSI from SIM"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"IMSI"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
operator|*
name|pos
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
if|if
condition|(
operator|*
name|pos
operator|==
name|EAP_TYPE_AKA
condition|)
block|{
name|aka
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|ssid
operator|->
name|identity
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|identity
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|imsi_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to allocate buffer for "
literal|"IMSI-based identity"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ssid
operator|->
name|identity
index|[
literal|0
index|]
operator|=
name|aka
condition|?
literal|'0'
else|:
literal|'1'
expr_stmt|;
name|memcpy
argument_list|(
name|ssid
operator|->
name|identity
operator|+
literal|1
argument_list|,
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|identity_len
operator|=
literal|1
operator|+
name|imsi_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_get_scard_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
if|if
condition|(
name|scard_set_pin
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|ssid
operator|->
name|pin
argument_list|)
condition|)
block|{
comment|/* 		 * Make sure the same PIN is not tried again in order to avoid 		 * blocking SIM. 		 */
name|free
argument_list|(
name|ssid
operator|->
name|pin
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|pin
operator|=
name|NULL
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"PIN validation failed"
argument_list|)
expr_stmt|;
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|eap_sm_imsi_identity
argument_list|(
name|sm
argument_list|,
name|ssid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_buildIdentity - Build EAP-Identity/Response for the current network  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @id: EAP identifier for the packet  * @len: Pointer to variable that will be set to the length of the response  * @encrypted: Whether the packet is for enrypted tunnel (EAP phase 2)  * Returns: Pointer to the allocated EAP-Identity/Response packet or %NULL on  * failure  *  * This function allocates and builds an EAP-Identity/Response packet for the  * current network. The caller is responsible for freeing the returned data.  */
end_comment

begin_function
name|u8
modifier|*
name|eap_sm_buildIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
name|encrypted
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
specifier|const
name|u8
modifier|*
name|identity
decl_stmt|;
name|size_t
name|identity_len
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: configuration "
literal|"was not available"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_identity
operator|&&
operator|(
name|identity
operator|=
name|sm
operator|->
name|m
operator|->
name|get_identity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|identity_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using method re-auth "
literal|"identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|encrypted
operator|&&
name|config
operator|->
name|anonymous_identity
condition|)
block|{
name|identity
operator|=
name|config
operator|->
name|anonymous_identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|anonymous_identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using anonymous identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using real identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: identity "
literal|"configuration was not available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pcsc
condition|)
block|{
if|if
condition|(
name|eap_sm_get_scard_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"permanent identity from "
literal|"IMSI"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
operator|+
name|identity_len
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_IDENTITY
expr_stmt|;
name|memcpy
argument_list|(
name|pos
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msg_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|msg_len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_len
operator|<
literal|5
condition|)
return|return;
name|msg_len
operator|-=
literal|5
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Notification data"
argument_list|,
name|pos
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|msg
operator|=
name|malloc
argument_list|(
name|msg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_len
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|isprint
argument_list|(
name|pos
index|[
name|i
index|]
argument_list|)
condition|?
operator|(
name|char
operator|)
name|pos
index|[
name|i
index|]
else|:
literal|'_'
expr_stmt|;
name|msg
index|[
name|msg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"%s%s"
argument_list|,
name|WPA_EVENT_EAP_NOTIFICATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Generating EAP-Response Notification"
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|=
name|EAP_TYPE_NOTIFICATION
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
name|sm
operator|->
name|rxReq
operator|=
name|sm
operator|->
name|rxSuccess
operator|=
name|sm
operator|->
name|rxFailure
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|reqId
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
expr_stmt|;
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
block|{
name|md5_vector
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|*
operator|)
operator|&
name|req
argument_list|,
operator|&
name|len
argument_list|,
name|sm
operator|->
name|req_md5
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
name|sm
operator|->
name|rxReq
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
name|sm
operator|->
name|reqMethod
operator|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Request method=%d "
literal|"id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_RESPONSE
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
condition|)
block|{
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
name|sm
operator|->
name|reqMethod
operator|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Response for "
literal|"LEAP method=%d id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Response"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Success"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxSuccess
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Failure"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxFailure
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Packet with unknown "
literal|"code %d"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_sm_init - Allocate and initialize EAP state machine  * @eapol_ctx: Context data to be used with eapol_cb calls  * @eapol_cb: Pointer to EAPOL callback functions  * @msg_ctx: Context data for wpa_msg() calls  * @conf: EAP configuration  * Returns: Pointer to the allocated EAP state machine or %NULL on failure  *  * This function allocates and initializes an EAP state machine. In addition,  * this initializes TLS library for the new EAP state machine.  */
end_comment

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|void
modifier|*
name|msg_ctx
parameter_list|,
name|struct
name|eap_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|struct
name|tls_config
name|tlsconf
decl_stmt|;
name|sm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|msg_ctx
operator|=
name|msg_ctx
expr_stmt|;
name|sm
operator|->
name|ClientTimeout
operator|=
literal|60
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tlsconf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tlsconf
argument_list|)
argument_list|)
expr_stmt|;
name|tlsconf
operator|.
name|opensc_engine_path
operator|=
name|conf
operator|->
name|opensc_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_engine_path
operator|=
name|conf
operator|->
name|pkcs11_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_module_path
operator|=
name|conf
operator|->
name|pkcs11_module_path
expr_stmt|;
name|sm
operator|->
name|ssl_ctx
operator|=
name|tls_init
argument_list|(
operator|&
name|tlsconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"SSL: Failed to initialize TLS "
literal|"context."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_deinit - Deinitialize and free an EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * This function deinitializes EAP state machine and frees all allocated  * resources.  */
end_comment

begin_function
name|void
name|eap_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"EAP deinit"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|tls_deinit
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_step - Step EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: 1 if EAP state was changed or 0 if not  *  * This function advances EAP state machine to a new state to match with the  * current variables. This should be called whenever variables used by the EAP  * state machine have changed.  */
end_comment

begin_function
name|int
name|eap_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_abort - Abort EAP authentication  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Release system resources that have been allocated for the authentication  * session without fully deinitializing the EAP state machine.  */
end_comment

begin_function
name|void
name|eap_sm_abort
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
return|return
literal|"INITIALIZE"
return|;
case|case
name|EAP_DISABLED
case|:
return|return
literal|"DISABLED"
return|;
case|case
name|EAP_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|EAP_RECEIVED
case|:
return|return
literal|"RECEIVED"
return|;
case|case
name|EAP_GET_METHOD
case|:
return|return
literal|"GET_METHOD"
return|;
case|case
name|EAP_METHOD
case|:
return|return
literal|"METHOD"
return|;
case|case
name|EAP_SEND_RESPONSE
case|:
return|return
literal|"SEND_RESPONSE"
return|;
case|case
name|EAP_DISCARD
case|:
return|return
literal|"DISCARD"
return|;
case|case
name|EAP_IDENTITY
case|:
return|return
literal|"IDENTITY"
return|;
case|case
name|EAP_NOTIFICATION
case|:
return|return
literal|"NOTIFICATION"
return|;
case|case
name|EAP_RETRANSMIT
case|:
return|return
literal|"RETRANSMIT"
return|;
case|case
name|EAP_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|EAP_FAILURE
case|:
return|return
literal|"FAILURE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|METHOD_NONE
case|:
return|return
literal|"NONE"
return|;
case|case
name|METHOD_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|METHOD_CONT
case|:
return|return
literal|"CONT"
return|;
case|case
name|METHOD_MAY_CONT
case|:
return|return
literal|"MAY_CONT"
return|;
case|case
name|METHOD_DONE
case|:
return|return
literal|"DONE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|int
name|decision
parameter_list|)
block|{
switch|switch
condition|(
name|decision
condition|)
block|{
case|case
name|DECISION_FAIL
case|:
return|return
literal|"FAIL"
return|;
case|case
name|DECISION_COND_SUCC
case|:
return|return
literal|"COND_SUCC"
return|;
case|case
name|DECISION_UNCOND_SUCC
case|:
return|return
literal|"UNCOND_SUCC"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_sm_get_status - Get EAP state machine status  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @buf: buffer for status information  * @buflen: maximum buffer length  * @verbose: whether to include verbose status information  * Returns: number of bytes written to buf.  *  * Query EAP state machine for status information. This function fills in a  * text area with current status information from the EAPOL state machine. If  * the buffer (buf) is not large enough, status information will be truncated  * to fit the buffer.  */
end_comment

begin_function
name|int
name|eap_sm_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"EAP state=%s\n"
argument_list|,
name|eap_sm_state_txt
argument_list|(
name|sm
operator|->
name|EAP_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|name
operator|=
name|sm
operator|->
name|m
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|eap_method
modifier|*
name|m
init|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|selectedMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|name
operator|=
name|m
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"selectedMethod=%d (EAP-%s)\n"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_status
condition|)
block|{
name|len
operator|+=
name|sm
operator|->
name|m
operator|->
name|get_status
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"reqMethod=%d\n"
literal|"methodState=%s\n"
literal|"decision=%s\n"
literal|"ClientTimeout=%d\n"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|sm
operator|->
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|sm
operator|->
name|decision
argument_list|)
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|TYPE_IDENTITY
block|,
name|TYPE_PASSWORD
block|,
name|TYPE_OTP
block|,
name|TYPE_PIN
block|,
name|TYPE_NEW_PASSWORD
block|,
name|TYPE_PASSPHRASE
block|}
name|eap_ctrl_req_type
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|eap_sm_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|eap_ctrl_req_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
operator|||
name|sm
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_IDENTITY
case|:
name|field
operator|=
literal|"IDENTITY"
expr_stmt|;
name|txt
operator|=
literal|"Identity"
expr_stmt|;
name|config
operator|->
name|pending_req_identity
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_PASSWORD
case|:
name|field
operator|=
literal|"PASSWORD"
expr_stmt|;
name|txt
operator|=
literal|"Password"
expr_stmt|;
name|config
operator|->
name|pending_req_password
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_NEW_PASSWORD
case|:
name|field
operator|=
literal|"NEW_PASSWORD"
expr_stmt|;
name|txt
operator|=
literal|"New Password"
expr_stmt|;
name|config
operator|->
name|pending_req_new_password
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_PIN
case|:
name|field
operator|=
literal|"PIN"
expr_stmt|;
name|txt
operator|=
literal|"PIN"
expr_stmt|;
name|config
operator|->
name|pending_req_pin
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_OTP
case|:
name|field
operator|=
literal|"OTP"
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|tmp
operator|=
name|malloc
argument_list|(
name|msglen
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|txt
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|config
operator|->
name|pending_req_otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|pending_req_otp
operator|=
name|tmp
expr_stmt|;
name|config
operator|->
name|pending_req_otp_len
operator|=
name|msglen
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config
operator|->
name|pending_req_otp
operator|==
name|NULL
condition|)
return|return;
name|txt
operator|=
name|config
operator|->
name|pending_req_otp
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_PASSPHRASE
case|:
name|field
operator|=
literal|"PASSPHRASE"
expr_stmt|;
name|txt
operator|=
literal|"Private key passphrase"
expr_stmt|;
name|config
operator|->
name|pending_req_passphrase
operator|++
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|buflen
operator|=
literal|100
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
operator|+
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|WPA_CTRL_REQ
literal|"%s-%d:%s needed for SSID "
argument_list|,
name|field
argument_list|,
name|config
operator|->
name|id
argument_list|,
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|ssid
operator|&&
name|buflen
operator|>
name|len
operator|+
name|config
operator|->
name|ssid_len
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|config
operator|->
name|ssid
argument_list|,
name|config
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_identity - Request identity from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  *  * EAP methods can call this function to request identity information for the  * current network. This is normally called when the identity is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_IDENTITY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_password - Request password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  *  * EAP methods can call this function to request password information for the  * current network. This is normally called when the password is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_new_password - Request new password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  *  * EAP methods can call this function to request new password information for  * the current network. This is normally called when the EAP method indicates  * that the current password has expired and password change is required. The  * request will be sent to monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_new_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_NEW_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_pin - Request SIM or smart card PIN from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  *  * EAP methods can call this function to request SIM or smart card PIN  * information for the current network. This is normally called when the PIN is  * not included in the network configuration. The request will be sent to  * monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_pin
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_PIN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_otp - Request one time password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  * @msg: Message to be displayed to the user when asking for OTP  * @msg_len: Length of the user displayable message  *  * EAP methods can call this function to request open time password (OTP) for  * the current network. The request will be sent to monitor programs through  * the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_OTP
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_passphrase - Request passphrase from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @config: Pointer to the current network configuration  *  * EAP methods can call this function to request passphrase for a private key  * for the current network. This is normally called when the passphrase is not  * included in the network configuration. The request will be sent to monitor  * programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_passphrase
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_PASSPHRASE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_notify_ctrl_attached - Notification of attached monitor  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Notify EAP state machines that a monitor was attached to the control  * interface to trigger re-sending of pending requests for user input.  */
end_comment

begin_function
name|void
name|eap_sm_notify_ctrl_attached
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
comment|/* Re-send any pending requests for user data since a new control 	 * interface was added. This handles cases where the EAP authentication 	 * starts immediately after system startup when the user interface is 	 * not yet running. */
if|if
condition|(
name|config
operator|->
name|pending_req_identity
condition|)
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_password
condition|)
name|eap_sm_request_password
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_new_password
condition|)
name|eap_sm_request_new_password
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_otp
condition|)
name|eap_sm_request_otp
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_pin
condition|)
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_passphrase
condition|)
name|eap_sm_request_passphrase
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_type - Get EAP type for the given EAP method name  * @name: EAP method name, e.g., TLS  * Returns: EAP method type or %EAP_TYPE_NONE if not found  *  * This function maps EAP type names into EAP type numbers based on the list of  * EAP methods included in the build.  */
end_comment

begin_function
name|u8
name|eap_get_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
return|;
block|}
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_name - Get EAP method name for the given EAP type  * @type: EAP method type  * Returns: EAP method name, e.g., TLS, or %NULL if not found  *  * This function maps EAP type numbers into EAP type names based on the list of  * EAP methods included in the build.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|eap_get_name
parameter_list|(
name|EapType
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|type
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
operator|->
name|name
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_names - Get space separated list of names for supported EAP methods  * @buf: Buffer for names  * @buflen: Buffer length  * Returns: Number of characters written into buf (not including nul  * termination)  */
end_comment

begin_function
name|size_t
name|eap_get_names
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pos
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|buflen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"%s%s"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|eap_methods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
operator|-
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_allowed_phase2_type
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
name|type
operator|!=
name|EAP_TYPE_PEAP
operator|&&
name|type
operator|!=
name|EAP_TYPE_TTLS
operator|&&
name|type
operator|!=
name|EAP_TYPE_FAST
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_type - Get EAP type for the given EAP phase 2 method name  * @name: EAP method name, e.g., MD5  * Returns: EAP method type or %EAP_TYPE_NONE if not found  *  * This function maps EAP type names into EAP type numbers that are allowed for  * Phase 2, i.e., for tunneled authentication. Phase 2 is used, e.g., with  * EAP-PEAP, EAP-TTLS, and EAP-FAST.  */
end_comment

begin_function
name|u8
name|eap_get_phase2_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u8
name|type
init|=
name|eap_get_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_types - Get list of allowed EAP phase 2 types  * @config: Pointer to a network configuration  * @count: Pointer to variable filled with number of returned EAP types  * Returns: Pointer to allocated type list or %NULL on failure  *  * This function generates an array of allowed EAP phase 2 (tunneled) types for  * the given network configuration.  */
end_comment

begin_function
name|u8
modifier|*
name|eap_get_phase2_types
parameter_list|(
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|u8
modifier|*
name|buf
decl_stmt|,
name|method
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|NUM_EAP_METHODS
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
name|method
operator|=
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
expr_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|method
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
name|config
operator|->
name|private_key2
operator|==
name|NULL
condition|)
continue|continue;
name|buf
index|[
operator|*
name|count
index|]
operator|=
name|method
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_fast_reauth - Update fast_reauth setting  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @enabled: 1 = fast reauthentication is enabled, 0 = disabled  */
end_comment

begin_function
name|void
name|eap_set_fast_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|sm
operator|->
name|fast_reauth
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_workaround - Update EAP workarounds setting  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @workaround: 1 = Enable EAP workarounds, 0 = Disable EAP workarounds  */
end_comment

begin_function
name|void
name|eap_set_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|unsigned
name|int
name|workaround
parameter_list|)
block|{
name|sm
operator|->
name|workaround
operator|=
name|workaround
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config - Get current network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: Pointer to the current network configuration or %NULL if not found  */
end_comment

begin_function
name|struct
name|wpa_ssid
modifier|*
name|eap_get_config
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_key_available - Get key availability (eapKeyAvailable variable)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: 1 if EAP keying material is available, 0 if not  */
end_comment

begin_function
name|int
name|eap_key_available
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
condition|?
name|sm
operator|->
name|eapKeyAvailable
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_notify_success - Notify EAP state machine about external success trigger  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * This function is called when external event, e.g., successful completion of  * WPA-PSK key handshake, is indicating that EAP state machine should move to  * success state. This is mainly used with security modes that do not use EAP  * state machine (e.g., WPA-PSK).  */
end_comment

begin_function
name|void
name|eap_notify_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|sm
operator|->
name|EAP_state
operator|=
name|EAP_SUCCESS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_notify_lower_layer_success - Notification of lower layer success  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Notify EAP state machines that a lower layer has detected a successful  * authentication. This is used to recover from dropped EAP-Success messages.  */
end_comment

begin_function
name|void
name|eap_notify_lower_layer_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|)
operator|||
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|||
operator|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
operator|)
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully (based on lower "
literal|"layer success)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get master session key (MSK) from EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Pointer to variable that will be set to number of bytes in the key  * Returns: Pointer to the EAP keying data or %NULL on failure  *  * Fetch EAP keying material (MSK, eapKeyData) from the EAP state machine. The  * key is available only after a successful authentication. EAP state machine  * continues to manage the key data and the caller must not change or free the  * returned data.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_eapKeyData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapKeyData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapKeyDataLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapKeyData
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get EAP response data  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Pointer to variable that will be set to the length of the response  * Returns: Pointer to the EAP response (eapRespData) or %NULL on failure  *  * Fetch EAP response (eapRespData) from the EAP state machine. This data is  * available when EAP state machine has processed an incoming EAP request. The  * EAP state machine does not maintain a reference to the response after this  * function is called and the caller is responsible for freeing the data.  */
end_comment

begin_function
name|u8
modifier|*
name|eap_get_eapRespData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|u8
modifier|*
name|resp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapRespData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|resp
operator|=
name|sm
operator|->
name|eapRespData
expr_stmt|;
operator|*
name|len
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
literal|0
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_register_scard_ctx - Notification of smart card context  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @ctx: context data for smart card operations  *  * Notify EAP state machines of context data for smart card operations. This  * context data will be used as a parameter for scard_*() functions.  */
end_comment

begin_function
name|void
name|eap_register_scard_ctx
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|sm
operator|->
name|scard_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_hdr_validate - Validate EAP header  * @eap_type: Expected EAP type number  * @msg: EAP frame (starting with EAP header)  * @msglen: Length of msg  * @plen: Pointer for return payload length  * Returns: Pointer to EAP payload (after type field), or %NULL on failure  *  * This is a helper function for EAP method implementations. This is usually  * called in the beginning of struct eap_method::process() function.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_hdr_validate
parameter_list|(
name|EapType
name|eap_type
parameter_list|,
specifier|const
name|u8
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|msg
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
operator|||
operator|*
name|pos
operator|!=
name|eap_type
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid frame type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
operator|||
name|len
operator|>
name|msglen
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid EAP length"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|pos
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_config_blob - Set or add a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @blob: New value for the blob  *  * Adds a new configuration blob or replaces the current value of an existing  * blob.  */
end_comment

begin_function
name|void
name|eap_set_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_config_blob
modifier|*
name|blob
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_blob - Get a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @name: Name of the blob  * Returns: Pointer to blob data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|struct
name|wpa_config_blob
modifier|*
name|eap_get_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_force_disabled - Set force_disabled flag  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @disabled: 1 = EAP disabled, 0 = EAP enabled  *  * This function is used to force EAP state machine to be disabled when it is  * not in use (e.g., with WPA-PSK or plaintext connections).  */
end_comment

begin_function
name|void
name|eap_set_force_disabled
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|disabled
parameter_list|)
block|{
name|sm
operator|->
name|force_disabled
operator|=
name|disabled
expr_stmt|;
block|}
end_function

end_unit

