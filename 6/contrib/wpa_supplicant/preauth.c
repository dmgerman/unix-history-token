begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant - RSN pre-authentication and PMKSA caching  * Copyright (c) 2003-2006, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_NATIVE_WINDOWS
end_ifndef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_NATIVE_WINDOWS */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"sha1.h"
end_include

begin_include
include|#
directive|include
file|"wpa.h"
end_include

begin_include
include|#
directive|include
file|"driver.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"l2_packet.h"
end_include

begin_include
include|#
directive|include
file|"eapol_sm.h"
end_include

begin_include
include|#
directive|include
file|"preauth.h"
end_include

begin_include
include|#
directive|include
file|"wpa_i.h"
end_include

begin_define
define|#
directive|define
name|PMKID_CANDIDATE_PRIO_SCAN
value|1000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|pmksa_cache_max_entries
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rsn_pmksa_candidate
block|{
name|struct
name|rsn_pmksa_candidate
modifier|*
name|next
decl_stmt|;
name|u8
name|bssid
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * rsn_pmkid - Calculate PMK identifier  * @pmk: Pairwise master key  * @aa: Authenticator address  * @spa: Supplicant address  *  * IEEE Std 802.11i-2004 - 8.5.1.2 Pairwise key hierarchy  * PMKID = HMAC-SHA1-128(PMK, "PMK Name" || AA || SPA)  */
end_comment

begin_function
specifier|static
name|void
name|rsn_pmkid
parameter_list|(
specifier|const
name|u8
modifier|*
name|pmk
parameter_list|,
specifier|const
name|u8
modifier|*
name|aa
parameter_list|,
specifier|const
name|u8
modifier|*
name|spa
parameter_list|,
name|u8
modifier|*
name|pmkid
parameter_list|)
block|{
name|char
modifier|*
name|title
init|=
literal|"PMK Name"
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|addr
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|size_t
name|len
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
name|ETH_ALEN
block|,
name|ETH_ALEN
block|}
decl_stmt|;
name|unsigned
name|char
name|hash
index|[
name|SHA1_MAC_LEN
index|]
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|title
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
name|aa
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
name|spa
expr_stmt|;
name|hmac_sha1_vector
argument_list|(
name|pmk
argument_list|,
name|PMK_LEN
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pmkid
argument_list|,
name|hash
argument_list|,
name|PMKID_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|pmksa_cache_set_expiration
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pmksa_cache_free_entry
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
parameter_list|,
name|int
name|replace
parameter_list|)
block|{
name|int
name|current
decl_stmt|;
name|current
operator|=
name|sm
operator|->
name|cur_pmksa
operator|==
name|entry
operator|||
operator|(
name|sm
operator|->
name|pmk_len
operator|==
name|entry
operator|->
name|pmk_len
operator|&&
name|memcmp
argument_list|(
name|sm
operator|->
name|pmk
argument_list|,
name|entry
operator|->
name|pmk
argument_list|,
name|sm
operator|->
name|pmk_len
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|sm
operator|->
name|pmksa_count
operator|--
expr_stmt|;
if|if
condition|(
name|current
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: removed current PMKSA entry"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|cur_pmksa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
comment|/* A new entry is being added, so no need to 			 * deauthenticate in this case. This happens when EAP 			 * authentication is completed again (reauth or failed 			 * PMKSA caching attempt). */
return|return;
block|}
name|memset
argument_list|(
name|sm
operator|->
name|pmk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|pmk
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_sm_deauthenticate
argument_list|(
name|sm
argument_list|,
name|REASON_UNSPECIFIED
argument_list|)
expr_stmt|;
name|wpa_sm_req_scan
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pmksa_cache_expire
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm
operator|->
name|pmksa
operator|&&
name|sm
operator|->
name|pmksa
operator|->
name|expiration
operator|<=
name|now
condition|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
init|=
name|sm
operator|->
name|pmksa
decl_stmt|;
name|sm
operator|->
name|pmksa
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: expired PMKSA cache entry for "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|entry
operator|->
name|aa
argument_list|)
argument_list|)
expr_stmt|;
name|pmksa_cache_free_entry
argument_list|(
name|sm
argument_list|,
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pmksa_cache_set_expiration
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmksa_cache_reauth
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|sm
operator|->
name|cur_pmksa
operator|=
name|NULL
expr_stmt|;
name|eapol_sm_request_reauth
argument_list|(
name|sm
operator|->
name|eapol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmksa_cache_set_expiration
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|sec
decl_stmt|;
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
decl_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|pmksa_cache_expire
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|pmksa_cache_reauth
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|pmksa
operator|==
name|NULL
condition|)
return|return;
name|sec
operator|=
name|sm
operator|->
name|pmksa
operator|->
name|expiration
operator|-
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|<
literal|0
condition|)
name|sec
operator|=
literal|0
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sec
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|pmksa_cache_expire
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|=
name|sm
operator|->
name|cur_pmksa
condition|?
name|sm
operator|->
name|cur_pmksa
else|:
name|pmksa_cache_get
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|bssid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|sec
operator|=
name|sm
operator|->
name|pmksa
operator|->
name|reauth_time
operator|-
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|<
literal|0
condition|)
name|sec
operator|=
literal|0
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|,
name|pmksa_cache_reauth
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_add - Add a PMKSA cache entry  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @pmk: The new pairwise master key  * @pmk_len: PMK length in bytes, usually PMK_LEN (32)  * @aa: Authenticator address  * @spa: Supplicant address  * @ssid: The network configuration for which this PMK is being added  * Returns: Pointer to the added PMKSA cache entry or %NULL on error  *  * This function create a PMKSA entry for a new PMK and adds it to the PMKSA  * cache. If an old entry is already in the cache for the same Authenticator,  * this entry will be replaced with the new entry. PMKID will be calculated  * based on the PMK and the driver interface is notified of the new PMKID.  */
end_comment

begin_function
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa_cache_add
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|pmk
parameter_list|,
name|size_t
name|pmk_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|aa
parameter_list|,
specifier|const
name|u8
modifier|*
name|spa
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
decl_stmt|,
modifier|*
name|pos
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|proto
operator|!=
name|WPA_PROTO_RSN
operator|||
name|pmk_len
operator|>
name|PMK_LEN
condition|)
return|return
name|NULL
return|;
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|entry
operator|->
name|pmk
argument_list|,
name|pmk
argument_list|,
name|pmk_len
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pmk_len
operator|=
name|pmk_len
expr_stmt|;
name|rsn_pmkid
argument_list|(
name|pmk
argument_list|,
name|aa
argument_list|,
name|spa
argument_list|,
name|entry
operator|->
name|pmkid
argument_list|)
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|->
name|expiration
operator|=
name|now
operator|+
name|sm
operator|->
name|dot11RSNAConfigPMKLifetime
expr_stmt|;
name|entry
operator|->
name|reauth_time
operator|=
name|now
operator|+
name|sm
operator|->
name|dot11RSNAConfigPMKLifetime
operator|*
name|sm
operator|->
name|dot11RSNAConfigPMKReauthThreshold
operator|/
literal|100
expr_stmt|;
name|entry
operator|->
name|akmp
operator|=
name|WPA_KEY_MGMT_IEEE8021X
expr_stmt|;
name|memcpy
argument_list|(
name|entry
operator|->
name|aa
argument_list|,
name|aa
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ssid
operator|=
name|ssid
expr_stmt|;
comment|/* Replace an old entry for the same Authenticator (if found) with the 	 * new entry */
name|pos
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|aa
argument_list|,
name|pos
operator|->
name|aa
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pos
operator|->
name|pmk_len
operator|==
name|pmk_len
operator|&&
name|memcmp
argument_list|(
name|pos
operator|->
name|pmk
argument_list|,
name|pmk
argument_list|,
name|pmk_len
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|pos
operator|->
name|pmkid
argument_list|,
name|entry
operator|->
name|pmkid
argument_list|,
name|PMKID_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: reusing previous "
literal|"PMKSA entry"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|sm
operator|->
name|pmksa
operator|=
name|pos
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|pos
operator|->
name|next
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: Replace PMKSA entry for "
literal|"the current AP"
argument_list|)
expr_stmt|;
name|pmksa_cache_free_entry
argument_list|(
name|sm
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|pos
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|pmksa_count
operator|>=
name|pmksa_cache_max_entries
operator|&&
name|sm
operator|->
name|pmksa
condition|)
block|{
comment|/* Remove the oldest entry to make room for the new entry */
name|pos
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
name|sm
operator|->
name|pmksa
operator|=
name|pos
operator|->
name|next
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: removed the oldest PMKSA cache "
literal|"entry (for "
name|MACSTR
literal|") to make room for new one"
argument_list|,
name|MAC2STR
argument_list|(
name|pos
operator|->
name|aa
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_sm_remove_pmkid
argument_list|(
name|sm
argument_list|,
name|pos
operator|->
name|aa
argument_list|,
name|pos
operator|->
name|pmkid
argument_list|)
expr_stmt|;
name|pmksa_cache_free_entry
argument_list|(
name|sm
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry; order by expiration time */
name|pos
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
if|if
condition|(
name|pos
operator|->
name|expiration
operator|>
name|entry
operator|->
name|expiration
condition|)
break|break;
name|prev
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|pos
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|next
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
name|sm
operator|->
name|pmksa
operator|=
name|entry
expr_stmt|;
name|pmksa_cache_set_expiration
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
name|sm
operator|->
name|pmksa_count
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: added PMKSA cache entry for "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|entry
operator|->
name|aa
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_sm_add_pmkid
argument_list|(
name|sm
argument_list|,
name|entry
operator|->
name|aa
argument_list|,
name|entry
operator|->
name|pmkid
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_free - Free all entries in PMKSA cache  * @sm: Pointer to WPA state machine data from wpa_sm_init()  */
end_comment

begin_function
name|void
name|pmksa_cache_free
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
name|sm
operator|->
name|pmksa
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|pmksa_cache_set_expiration
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|cur_pmksa
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_get - Fetch a PMKSA cache entry  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @aa: Authenticator address or %NULL to match any  * @pmkid: PMKID or %NULL to match any  * Returns: Pointer to PMKSA cache entry or %NULL if no match was found  */
end_comment

begin_function
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa_cache_get
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|aa
parameter_list|,
specifier|const
name|u8
modifier|*
name|pmkid
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
init|=
name|sm
operator|->
name|pmksa
decl_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
if|if
condition|(
operator|(
name|aa
operator|==
name|NULL
operator|||
name|memcmp
argument_list|(
name|entry
operator|->
name|aa
argument_list|,
name|aa
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pmkid
operator|==
name|NULL
operator|||
name|memcmp
argument_list|(
name|entry
operator|->
name|pmkid
argument_list|,
name|pmkid
argument_list|,
name|PMKID_LEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|entry
return|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_notify_reconfig - Reconfiguration notification for PMKSA cache  * @sm: Pointer to WPA state machine data from wpa_sm_init()  *  * Clear references to old data structures when wpa_supplicant is reconfigured.  */
end_comment

begin_function
name|void
name|pmksa_cache_notify_reconfig
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
init|=
name|sm
operator|->
name|pmksa
decl_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|entry
operator|->
name|ssid
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa_cache_clone_entry
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|rsn_pmksa_cache
modifier|*
name|old_entry
parameter_list|,
specifier|const
name|u8
modifier|*
name|aa
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|new_entry
decl_stmt|;
name|new_entry
operator|=
name|pmksa_cache_add
argument_list|(
name|sm
argument_list|,
name|old_entry
operator|->
name|pmk
argument_list|,
name|old_entry
operator|->
name|pmk_len
argument_list|,
name|aa
argument_list|,
name|sm
operator|->
name|own_addr
argument_list|,
name|old_entry
operator|->
name|ssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* TODO: reorder entries based on expiration time? */
name|new_entry
operator|->
name|expiration
operator|=
name|old_entry
operator|->
name|expiration
expr_stmt|;
name|new_entry
operator|->
name|opportunistic
operator|=
literal|1
expr_stmt|;
return|return
name|new_entry
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_get_opportunistic - Try to get an opportunistic PMKSA entry  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @ssid: Pointer to the current network configuration  * @aa: Authenticator address for the new AP  * Returns: Pointer to a new PMKSA cache entry or %NULL if not available  *  * Try to create a new PMKSA cache entry opportunistically by guessing that the  * new AP is sharing the same PMK as another AP that has the same SSID and has  * already an entry in PMKSA cache.  */
end_comment

begin_function
specifier|static
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa_cache_get_opportunistic
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|,
specifier|const
name|u8
modifier|*
name|aa
parameter_list|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
init|=
name|sm
operator|->
name|pmksa
decl_stmt|;
if|if
condition|(
name|ssid
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|ssid
operator|==
name|ssid
condition|)
block|{
name|entry
operator|=
name|pmksa_cache_clone_entry
argument_list|(
name|sm
argument_list|,
name|entry
argument_list|,
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: added "
literal|"opportunistic PMKSA cache entry "
literal|"for "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|aa
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_get_current - Get the current used PMKSA entry  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * Returns: Pointer to the current PMKSA cache entry or %NULL if not available  */
end_comment

begin_function
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa_cache_get_current
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|sm
operator|->
name|cur_pmksa
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_clear_current - Clear the current PMKSA entry selection  * @sm: Pointer to WPA state machine data from wpa_sm_init()  */
end_comment

begin_function
name|void
name|pmksa_cache_clear_current
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|cur_pmksa
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_set_current - Set the current PMKSA entry selection  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @pmkid: PMKID for selecting PMKSA or %NULL if not used  * @bssid: BSSID for PMKSA  or %NULL if not used  * @ssid: The network configuration for the current network  * @try_opportunistic: Whether to allow opportunistic PMKSA caching  * Returns: 0 if PMKSA was found or -1 if no matching entry was found  */
end_comment

begin_function
name|int
name|pmksa_cache_set_current
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|pmkid
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|,
name|int
name|try_opportunistic
parameter_list|)
block|{
name|sm
operator|->
name|cur_pmksa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmkid
condition|)
name|sm
operator|->
name|cur_pmksa
operator|=
name|pmksa_cache_get
argument_list|(
name|sm
argument_list|,
name|NULL
argument_list|,
name|pmkid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|cur_pmksa
operator|==
name|NULL
operator|&&
name|bssid
condition|)
name|sm
operator|->
name|cur_pmksa
operator|=
name|pmksa_cache_get
argument_list|(
name|sm
argument_list|,
name|bssid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|cur_pmksa
operator|==
name|NULL
operator|&&
name|try_opportunistic
condition|)
name|sm
operator|->
name|cur_pmksa
operator|=
name|pmksa_cache_get_opportunistic
argument_list|(
name|sm
argument_list|,
name|ssid
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|cur_pmksa
condition|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: PMKID"
argument_list|,
name|sm
operator|->
name|cur_pmksa
operator|->
name|pmkid
argument_list|,
name|PMKID_LEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_cache_list - Dump text list of entries in PMKSA cache  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @buf: Buffer for the list  * @len: Length of the buffer  * Returns: number of bytes written to buffer  *  * This function is used to generate a text format representation of the  * current PMKSA cache contents for the ctrl_iface PMKSA command.  */
end_comment

begin_function
name|int
name|pmksa_cache_list
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|pos
init|=
name|buf
decl_stmt|;
name|struct
name|rsn_pmksa_cache
modifier|*
name|entry
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|buf
operator|+
name|len
operator|-
name|pos
argument_list|,
literal|"Index / AA / PMKID / expiration (in seconds) / "
literal|"opportunistic\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|sm
operator|->
name|pmksa
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|buf
operator|+
name|len
operator|-
name|pos
argument_list|,
literal|"%d "
name|MACSTR
literal|" "
argument_list|,
name|i
argument_list|,
name|MAC2STR
argument_list|(
name|entry
operator|->
name|aa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PMKID_LEN
condition|;
name|j
operator|++
control|)
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|buf
operator|+
name|len
operator|-
name|pos
argument_list|,
literal|"%02x"
argument_list|,
name|entry
operator|->
name|pmkid
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|buf
operator|+
name|len
operator|-
name|pos
argument_list|,
literal|" %d %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|entry
operator|->
name|expiration
operator|-
name|now
argument_list|)
argument_list|,
name|entry
operator|->
name|opportunistic
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
name|pos
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * pmksa_candidate_free - Free all entries in PMKSA candidate list  * @sm: Pointer to WPA state machine data from wpa_sm_init()  */
end_comment

begin_function
name|void
name|pmksa_candidate_free
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|rsn_pmksa_candidate
modifier|*
name|entry
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|=
name|sm
operator|->
name|pmksa_candidates
expr_stmt|;
name|sm
operator|->
name|pmksa_candidates
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE8021X_EAPOL
end_ifdef

begin_function
specifier|static
name|void
name|rsn_preauth_receive
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|src_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RX pre-auth from "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"RX pre-auth"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|preauth_eapol
operator|==
name|NULL
operator|||
name|memcmp
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|,
literal|"\x00\x00\x00\x00\x00\x00"
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|,
name|src_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"RSN pre-auth frame received from "
literal|"unexpected source "
name|MACSTR
literal|" - dropped"
argument_list|,
name|MAC2STR
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|eapol_sm_rx_eapol
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
name|src_addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rsn_preauth_eapol_cb
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|eapol
parameter_list|,
name|int
name|success
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
name|u8
name|pmk
index|[
name|PMK_LEN
index|]
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int
name|res
decl_stmt|,
name|pmk_len
decl_stmt|;
name|pmk_len
operator|=
name|PMK_LEN
expr_stmt|;
name|res
operator|=
name|eapol_sm_get_key
argument_list|(
name|eapol
argument_list|,
name|pmk
argument_list|,
name|PMK_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EAP_LEAP
if|if
condition|(
name|res
condition|)
block|{
name|res
operator|=
name|eapol_sm_get_key
argument_list|(
name|eapol
argument_list|,
name|pmk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pmk_len
operator|=
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EAP_LEAP */
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: PMK from pre-auth"
argument_list|,
name|pmk
argument_list|,
name|pmk_len
argument_list|)
expr_stmt|;
name|sm
operator|->
name|pmk_len
operator|=
name|pmk_len
expr_stmt|;
name|pmksa_cache_add
argument_list|(
name|sm
argument_list|,
name|pmk
argument_list|,
name|pmk_len
argument_list|,
name|sm
operator|->
name|preauth_bssid
argument_list|,
name|sm
operator|->
name|own_addr
argument_list|,
name|sm
operator|->
name|cur_ssid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"RSN: failed to get "
literal|"master session key from pre-auth EAPOL state "
literal|"machines"
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"RSN: pre-authentication with "
name|MACSTR
literal|" %s"
argument_list|,
name|MAC2STR
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|)
argument_list|,
name|success
condition|?
literal|"completed successfully"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
name|rsn_preauth_deinit
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|rsn_preauth_candidate_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rsn_preauth_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"RSN: pre-authentication with "
name|MACSTR
literal|" timed out"
argument_list|,
name|MAC2STR
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|rsn_preauth_deinit
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|rsn_preauth_candidate_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rsn_preauth_eapol_send
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
name|u8
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msglen
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* TODO: could add l2_packet_sendmsg that allows fragments to avoid 	 * extra copy here */
if|if
condition|(
name|sm
operator|->
name|l2_preauth
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|msg
operator|=
name|wpa_sm_alloc_eapol
argument_list|(
name|sm
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|msglen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"TX EAPOL (preauth)"
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|res
operator|=
name|l2_packet_send
argument_list|(
name|sm
operator|->
name|l2_preauth
argument_list|,
name|sm
operator|->
name|preauth_bssid
argument_list|,
name|ETH_P_RSN_PREAUTH
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * rsn_preauth_init - Start new RSN pre-authentication  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @dst: Authenticator address (BSSID) with which to preauthenticate  * @config: Current network configuration  * Returns: 0 on success, -1 on another pre-authentication is in progress,  * -2 on layer 2 packet initialization failure, -3 on EAPOL state machine  * initialization failure, -4 on memory allocation failure  *  * This function request an RSN pre-authentication with a given destination  * address. This is usually called for PMKSA candidates found from scan results  * or from driver reports. In addition, ctrl_iface PREAUTH command can trigger  * pre-authentication.  */
end_comment

begin_function
name|int
name|rsn_preauth_init
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|eapol_config
name|eapol_conf
decl_stmt|;
name|struct
name|eapol_ctx
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|preauth_eapol
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: starting pre-authentication "
literal|"with "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|l2_preauth
operator|=
name|l2_packet_init
argument_list|(
name|sm
operator|->
name|ifname
argument_list|,
name|sm
operator|->
name|own_addr
argument_list|,
name|ETH_P_RSN_PREAUTH
argument_list|,
name|rsn_preauth_receive
argument_list|,
name|sm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|l2_preauth
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"RSN: Failed to initialize L2 packet "
literal|"processing for pre-authentication"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|ctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to allocate EAPOL context."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|4
return|;
block|}
name|memset
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx
operator|=
name|sm
operator|->
name|ctx
operator|->
name|ctx
expr_stmt|;
name|ctx
operator|->
name|msg_ctx
operator|=
name|sm
operator|->
name|ctx
operator|->
name|ctx
expr_stmt|;
name|ctx
operator|->
name|preauth
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|cb
operator|=
name|rsn_preauth_eapol_cb
expr_stmt|;
name|ctx
operator|->
name|cb_ctx
operator|=
name|sm
expr_stmt|;
name|ctx
operator|->
name|scard_ctx
operator|=
name|sm
operator|->
name|scard_ctx
expr_stmt|;
name|ctx
operator|->
name|eapol_send
operator|=
name|rsn_preauth_eapol_send
expr_stmt|;
name|ctx
operator|->
name|eapol_send_ctx
operator|=
name|sm
expr_stmt|;
name|ctx
operator|->
name|set_config_blob
operator|=
name|sm
operator|->
name|ctx
operator|->
name|set_config_blob
expr_stmt|;
name|ctx
operator|->
name|get_config_blob
operator|=
name|sm
operator|->
name|ctx
operator|->
name|get_config_blob
expr_stmt|;
name|sm
operator|->
name|preauth_eapol
operator|=
name|eapol_sm_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|preauth_eapol
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"RSN: Failed to initialize EAPOL "
literal|"state machines for pre-authentication"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
name|memset
argument_list|(
operator|&
name|eapol_conf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|eapol_conf
argument_list|)
argument_list|)
expr_stmt|;
name|eapol_conf
operator|.
name|accept_802_1x_keys
operator|=
literal|0
expr_stmt|;
name|eapol_conf
operator|.
name|required_keys
operator|=
literal|0
expr_stmt|;
name|eapol_conf
operator|.
name|fast_reauth
operator|=
name|sm
operator|->
name|fast_reauth
expr_stmt|;
if|if
condition|(
name|config
condition|)
name|eapol_conf
operator|.
name|workaround
operator|=
name|config
operator|->
name|eap_workaround
expr_stmt|;
name|eapol_sm_notify_config
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
name|config
argument_list|,
operator|&
name|eapol_conf
argument_list|)
expr_stmt|;
comment|/* 	 * Use a shorter startPeriod with preauthentication since the first 	 * preauth EAPOL-Start frame may end up being dropped due to race 	 * condition in the AP between the data receive and key configuration 	 * after the 4-Way Handshake. 	 */
name|eapol_sm_configure
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|,
name|dst
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|eapol_sm_notify_portValid
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 802.1X::portControl = Auto */
name|eapol_sm_notify_portEnabled
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sm
operator|->
name|dot11RSNAConfigSATimeout
argument_list|,
literal|0
argument_list|,
name|rsn_preauth_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * rsn_preauth_deinit - Abort RSN pre-authentication  * @sm: Pointer to WPA state machine data from wpa_sm_init()  *  * This function aborts the current RSN pre-authentication (if one is started)  * and frees resources allocated for it.  */
end_comment

begin_function
name|void
name|rsn_preauth_deinit
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
operator|!
name|sm
operator|->
name|preauth_eapol
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|rsn_preauth_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eapol_sm_deinit
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|)
expr_stmt|;
name|sm
operator|->
name|preauth_eapol
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|sm
operator|->
name|preauth_bssid
argument_list|,
literal|0
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|l2_packet_deinit
argument_list|(
name|sm
operator|->
name|l2_preauth
argument_list|)
expr_stmt|;
name|sm
operator|->
name|l2_preauth
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * rsn_preauth_candidate_process - Process PMKSA candidates  * @sm: Pointer to WPA state machine data from wpa_sm_init()  *  * Go through the PMKSA candidates and start pre-authentication if a candidate  * without an existing PMKSA cache entry is found. Processed candidates will be  * removed from the list.  */
end_comment

begin_function
name|void
name|rsn_preauth_candidate_process
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|rsn_pmksa_candidate
modifier|*
name|candidate
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|pmksa_candidates
operator|==
name|NULL
condition|)
return|return;
comment|/* TODO: drop priority for old candidate entries */
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: processing PMKSA candidate "
literal|"list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|preauth_eapol
operator|||
name|sm
operator|->
name|proto
operator|!=
name|WPA_PROTO_RSN
operator|||
name|wpa_sm_get_state
argument_list|(
name|sm
argument_list|)
operator|!=
name|WPA_COMPLETED
operator|||
name|sm
operator|->
name|key_mgmt
operator|!=
name|WPA_KEY_MGMT_IEEE8021X
condition|)
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: not in suitable state "
literal|"for new pre-authentication"
argument_list|)
expr_stmt|;
return|return;
comment|/* invalid state for new pre-auth */
block|}
while|while
condition|(
name|sm
operator|->
name|pmksa_candidates
condition|)
block|{
name|struct
name|rsn_pmksa_cache
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|candidate
operator|=
name|sm
operator|->
name|pmksa_candidates
expr_stmt|;
name|p
operator|=
name|pmksa_cache_get
argument_list|(
name|sm
argument_list|,
name|candidate
operator|->
name|bssid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sm
operator|->
name|bssid
argument_list|,
name|candidate
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|opportunistic
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: PMKSA "
literal|"candidate "
name|MACSTR
literal|" selected for pre-authentication"
argument_list|,
name|MAC2STR
argument_list|(
name|candidate
operator|->
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|pmksa_candidates
operator|=
name|candidate
operator|->
name|next
expr_stmt|;
name|rsn_preauth_init
argument_list|(
name|sm
argument_list|,
name|candidate
operator|->
name|bssid
argument_list|,
name|sm
operator|->
name|cur_ssid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: PMKSA candidate "
name|MACSTR
literal|" does not need pre-authentication anymore"
argument_list|,
name|MAC2STR
argument_list|(
name|candidate
operator|->
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some drivers (e.g., NDIS) expect to get notified about the 		 * PMKIDs again, so report the existing data now. */
if|if
condition|(
name|p
condition|)
block|{
name|wpa_sm_add_pmkid
argument_list|(
name|sm
argument_list|,
name|candidate
operator|->
name|bssid
argument_list|,
name|p
operator|->
name|pmkid
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|pmksa_candidates
operator|=
name|candidate
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: no more pending PMKSA "
literal|"candidates"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * pmksa_candidate_add - Add a new PMKSA candidate  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @bssid: BSSID (authenticator address) of the candidate  * @prio: Priority (the smaller number, the higher priority)  * @preauth: Whether the candidate AP advertises support for pre-authentication  *  * This function is used to add PMKSA candidates for RSN pre-authentication. It  * is called from scan result processing and from driver events for PMKSA  * candidates, i.e., EVENT_PMKID_CANDIDATE events to wpa_supplicant_event().  */
end_comment

begin_function
name|void
name|pmksa_candidate_add
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|int
name|prio
parameter_list|,
name|int
name|preauth
parameter_list|)
block|{
name|struct
name|rsn_pmksa_candidate
modifier|*
name|cand
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|cur_ssid
operator|&&
name|sm
operator|->
name|cur_ssid
operator|->
name|proactive_key_caching
condition|)
name|pmksa_cache_get_opportunistic
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|cur_ssid
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preauth
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: Ignored PMKID candidate without "
literal|"preauth flag"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If BSSID already on candidate list, update the priority of the old 	 * entry. Do not override priority based on normal scan results. */
name|prev
operator|=
name|NULL
expr_stmt|;
name|cand
operator|=
name|sm
operator|->
name|pmksa_candidates
expr_stmt|;
while|while
condition|(
name|cand
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|cand
operator|->
name|bssid
argument_list|,
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cand
operator|->
name|next
expr_stmt|;
else|else
name|sm
operator|->
name|pmksa_candidates
operator|=
name|cand
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cand
expr_stmt|;
name|cand
operator|=
name|cand
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cand
condition|)
block|{
if|if
condition|(
name|prio
operator|<
name|PMKID_CANDIDATE_PRIO_SCAN
condition|)
name|cand
operator|->
name|priority
operator|=
name|prio
expr_stmt|;
block|}
else|else
block|{
name|cand
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cand
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
name|NULL
condition|)
return|return;
name|memset
argument_list|(
name|cand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cand
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cand
operator|->
name|bssid
argument_list|,
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|cand
operator|->
name|priority
operator|=
name|prio
expr_stmt|;
block|}
comment|/* Add candidate to the list; order by increasing priority value. i.e., 	 * highest priority (smallest value) first. */
name|prev
operator|=
name|NULL
expr_stmt|;
name|pos
operator|=
name|sm
operator|->
name|pmksa_candidates
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
if|if
condition|(
name|cand
operator|->
name|priority
operator|<=
name|pos
operator|->
name|priority
condition|)
break|break;
name|prev
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|pos
operator|->
name|next
expr_stmt|;
block|}
name|cand
operator|->
name|next
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cand
expr_stmt|;
else|else
name|sm
operator|->
name|pmksa_candidates
operator|=
name|cand
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: added PMKSA cache "
literal|"candidate "
name|MACSTR
literal|" prio %d"
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|rsn_preauth_candidate_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: schedule periodic scans if current AP supports preauth */
end_comment

begin_comment
comment|/**  * rsn_preauth_scan_results - Process scan results to find PMKSA candidates  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @results: Scan results  * @count: Number of BSSes in scan results  *  * This functions goes through the scan results and adds all suitable APs  * (Authenticators) into PMKSA candidate list.  */
end_comment

begin_function
name|void
name|rsn_preauth_scan_results
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_scan_result
modifier|*
name|results
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|wpa_scan_result
modifier|*
name|r
decl_stmt|;
name|struct
name|wpa_ie_data
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rsn_pmksa_cache
modifier|*
name|pmksa
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|cur_ssid
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * TODO: is it ok to free all candidates? What about the entries 	 * received from EVENT_PMKID_CANDIDATE? 	 */
name|pmksa_candidate_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|r
operator|=
operator|&
name|results
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|ssid_len
operator|!=
name|sm
operator|->
name|cur_ssid
operator|->
name|ssid_len
operator|||
name|memcmp
argument_list|(
name|r
operator|->
name|ssid
argument_list|,
name|sm
operator|->
name|cur_ssid
operator|->
name|ssid
argument_list|,
name|r
operator|->
name|ssid_len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|r
operator|->
name|bssid
argument_list|,
name|sm
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|rsn_ie_len
operator|==
literal|0
operator|||
name|wpa_parse_wpa_ie
argument_list|(
name|r
operator|->
name|rsn_ie
argument_list|,
name|r
operator|->
name|rsn_ie_len
argument_list|,
operator|&
name|ie
argument_list|)
condition|)
continue|continue;
name|pmksa
operator|=
name|pmksa_cache_get
argument_list|(
name|sm
argument_list|,
name|r
operator|->
name|bssid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmksa
operator|&&
operator|(
operator|!
name|pmksa
operator|->
name|opportunistic
operator|||
operator|!
operator|(
name|ie
operator|.
name|capabilities
operator|&
name|WPA_CAPABILITY_PREAUTH
operator|)
operator|)
condition|)
continue|continue;
comment|/* 		 * Give less priority to candidates found from normal 		 * scan results. 		 */
name|pmksa_candidate_add
argument_list|(
name|sm
argument_list|,
name|r
operator|->
name|bssid
argument_list|,
name|PMKID_CANDIDATE_PRIO_SCAN
argument_list|,
name|ie
operator|.
name|capabilities
operator|&
name|WPA_CAPABILITY_PREAUTH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * rsn_preauth_get_status - Get pre-authentication status  * @sm: Pointer to WPA state machine data from wpa_sm_init()  * @buf: Buffer for status information  * @buflen: Maximum buffer length  * @verbose: Whether to include verbose status information  * Returns: Number of bytes written to buf.  *  * Query WPA2 pre-authentication for status information. This function fills in  * a text area with current status information. If the buffer (buf) is not  * large enough, status information will be truncated to fit the buffer.  */
end_comment

begin_function
name|int
name|rsn_preauth_get_status
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|buf
decl_stmt|,
modifier|*
name|end
init|=
name|buf
operator|+
name|buflen
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|preauth_eapol
condition|)
block|{
name|pos
operator|+=
name|snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"Pre-authentication "
literal|"EAPOL state machines:\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|eapol_sm_get_status
argument_list|(
name|sm
operator|->
name|preauth_eapol
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
name|pos
operator|+=
name|res
expr_stmt|;
block|}
return|return
name|pos
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * rsn_preauth_in_progress - Verify whether pre-authentication is in progress  * @sm: Pointer to WPA state machine data from wpa_sm_init()  */
end_comment

begin_function
name|int
name|rsn_preauth_in_progress
parameter_list|(
name|struct
name|wpa_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|preauth_eapol
operator|!=
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE8021X_EAPOL */
end_comment

end_unit

