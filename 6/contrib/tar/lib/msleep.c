begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sleep a given number of milliseconds.    Copyright (C) 1992, 1993, 1994, 1997 Free Software Foundation, Inc.    Fran√ßois Pinard<pinard@iro.umontreal.ca>, 1992.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This code is heavily borrowed from Taylor UUCP 1.03.	 Ian picks one of    usleep, nap, napms, poll, select and sleep, in decreasing order of    preference.	The sleep function is always available.	 */
end_comment

begin_comment
comment|/* In many cases, we will sleep if the wanted number of milliseconds    is higher than this value.  */
end_comment

begin_define
define|#
directive|define
name|THRESHOLD_FOR_SLEEP
value|30000
end_define

begin_comment
comment|/* Include some header files.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL
end_if

begin_if
if|#
directive|if
name|HAVE_STROPTS_H
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL_H
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_STROPTS_H
operator|&&
operator|!
name|HAVE_POLL_H
end_if

begin_comment
comment|/* We need a definition for struct pollfd, although it doesn't matter    what it contains.  */
end_comment

begin_struct
struct|struct
name|pollfd
block|{
name|int
name|idummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------. | Sleep a given number of milliseconds.	 | `---------------------------------------*/
end_comment

begin_function
name|void
name|msleep
parameter_list|(
name|milliseconds
parameter_list|)
name|int
name|milliseconds
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_USLEEP
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
name|usleep
argument_list|(
name|milliseconds
operator|*
operator|(
name|long
operator|)
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_NAP
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
name|nap
argument_list|(
operator|(
name|long
operator|)
name|milliseconds
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_NAPMS
if|if
condition|(
name|milliseconds
operator|>=
name|THRESHOLD_FOR_SLEEP
condition|)
block|{
name|sleep
argument_list|(
name|milliseconds
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|milliseconds
operator|%=
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
name|napms
argument_list|(
name|milliseconds
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|sdummy
decl_stmt|;
comment|/* poll(2) checks this address */
if|if
condition|(
name|milliseconds
operator|>=
name|THRESHOLD_FOR_SLEEP
condition|)
block|{
name|sleep
argument_list|(
name|milliseconds
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|milliseconds
operator|%=
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
name|poll
argument_list|(
operator|&
name|sdummy
argument_list|,
literal|0
argument_list|,
name|milliseconds
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_SELECT
name|struct
name|timeval
name|s
decl_stmt|;
if|if
condition|(
name|milliseconds
operator|>=
name|THRESHOLD_FOR_SLEEP
condition|)
block|{
name|sleep
argument_list|(
name|milliseconds
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|milliseconds
operator|%=
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|tv_sec
operator|=
name|milliseconds
operator|/
literal|1000
expr_stmt|;
name|s
operator|.
name|tv_usec
operator|=
operator|(
name|milliseconds
operator|%
literal|1000
operator|)
operator|*
operator|(
name|long
operator|)
literal|1000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Round the time up to the next full second.  */
if|if
condition|(
name|milliseconds
operator|>
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|milliseconds
operator|+
literal|999
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

end_unit

