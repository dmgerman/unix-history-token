begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* modechange.c -- file mode manipulation    Copyright (C) 1989, 1990, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@ai.mit.edu> */
end_comment

begin_comment
comment|/* The ASCII mode string is compiled into a linked list of `struct    modechange', which can then be applied to each file to be changed.    We do this instead of re-parsing the ASCII string for each file    because the compiled form requires less computation to use; when    changing the mode of many files, this probably results in a    performance gain. */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"modechange.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"xstrtol.h"
end_include

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STAT_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|S_ISDIR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The traditional octal values corresponding to each mode bit.  */
end_comment

begin_define
define|#
directive|define
name|SUID
value|04000
end_define

begin_define
define|#
directive|define
name|SGID
value|02000
end_define

begin_define
define|#
directive|define
name|SVTX
value|01000
end_define

begin_define
define|#
directive|define
name|RUSR
value|00400
end_define

begin_define
define|#
directive|define
name|WUSR
value|00200
end_define

begin_define
define|#
directive|define
name|XUSR
value|00100
end_define

begin_define
define|#
directive|define
name|RGRP
value|00040
end_define

begin_define
define|#
directive|define
name|WGRP
value|00020
end_define

begin_define
define|#
directive|define
name|XGRP
value|00010
end_define

begin_define
define|#
directive|define
name|ROTH
value|00004
end_define

begin_define
define|#
directive|define
name|WOTH
value|00002
end_define

begin_define
define|#
directive|define
name|XOTH
value|00001
end_define

begin_define
define|#
directive|define
name|ALLM
value|07777
end_define

begin_comment
comment|/* all octal mode bits */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISUID
end_ifndef

begin_define
define|#
directive|define
name|S_ISUID
value|SUID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISGID
end_ifndef

begin_define
define|#
directive|define
name|S_ISGID
value|SGID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISVTX
end_ifndef

begin_define
define|#
directive|define
name|S_ISVTX
value|SVTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IRUSR
value|RUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IWUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IWUSR
value|WUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IXUSR
value|XUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IRGRP
value|RGRP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IWGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IWGRP
value|WGRP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IXGRP
value|XGRP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IROTH
end_ifndef

begin_define
define|#
directive|define
name|S_IROTH
value|ROTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IWOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IWOTH
value|WOTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IXOTH
value|XOTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRWXU
end_ifndef

begin_define
define|#
directive|define
name|S_IRWXU
value|(S_IRUSR | S_IWUSR | S_IXUSR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRWXG
end_ifndef

begin_define
define|#
directive|define
name|S_IRWXG
value|(S_IRGRP | S_IWGRP | S_IXGRP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRWXO
end_ifndef

begin_define
define|#
directive|define
name|S_IRWXO
value|(S_IROTH | S_IWOTH | S_IXOTH)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* All the mode bits that can be affected by chmod.  */
end_comment

begin_define
define|#
directive|define
name|CHMOD_MODE_BITS
define|\
value|(S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
end_define

begin_comment
comment|/* Return newly allocated memory to hold one element of type TYPE. */
end_comment

begin_define
define|#
directive|define
name|talloc
parameter_list|(
name|type
parameter_list|)
value|((type *) malloc (sizeof (type)))
end_define

begin_comment
comment|/* Create a mode_change entry with the specified `=ddd'-style    mode change operation, where NEW_MODE is `ddd'.  Return the    new entry, or NULL upon failure.  */
end_comment

begin_function
specifier|static
name|struct
name|mode_change
modifier|*
name|make_node_op_equals
parameter_list|(
name|mode_t
name|new_mode
parameter_list|)
block|{
name|struct
name|mode_change
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|p
return|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|op
operator|=
literal|'='
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|new_mode
expr_stmt|;
name|p
operator|->
name|affected
operator|=
name|CHMOD_MODE_BITS
expr_stmt|;
comment|/* Affect all permissions. */
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Append entry E to the end of the link list with the specified    HEAD and TAIL.  */
end_comment

begin_function
specifier|static
name|void
name|mode_append_entry
parameter_list|(
name|struct
name|mode_change
modifier|*
modifier|*
name|head
parameter_list|,
name|struct
name|mode_change
modifier|*
modifier|*
name|tail
parameter_list|,
name|struct
name|mode_change
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
operator|*
name|tail
operator|=
name|e
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|e
expr_stmt|;
operator|*
name|tail
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a linked list of file mode change operations created from    MODE_STRING, an ASCII string that contains either an octal number    specifying an absolute mode, or symbolic mode change operations with    the form:    [ugoa...][[+-=][rwxXstugo...]...][,...]    MASKED_OPS is a bitmask indicating which symbolic mode operators (=+-)    should not affect bits set in the umask when no users are given.    Operators not selected in MASKED_OPS ignore the umask.     Return MODE_INVALID if `mode_string' does not contain a valid    representation of file mode change operations;    return MODE_MEMORY_EXHAUSTED if there is insufficient memory. */
end_comment

begin_function
name|struct
name|mode_change
modifier|*
name|mode_compile
parameter_list|(
specifier|const
name|char
modifier|*
name|mode_string
parameter_list|,
name|unsigned
name|int
name|masked_ops
parameter_list|)
block|{
name|struct
name|mode_change
modifier|*
name|head
decl_stmt|;
comment|/* First element of the linked list. */
name|struct
name|mode_change
modifier|*
name|tail
decl_stmt|;
comment|/* An element of the linked list. */
name|unsigned
name|long
name|octal_value
decl_stmt|;
comment|/* The mode value, if octal.  */
name|mode_t
name|umask_value
decl_stmt|;
comment|/* The umask value (surprise). */
name|head
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|tail
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xstrtoul
argument_list|(
name|mode_string
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|,
operator|&
name|octal_value
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
condition|)
block|{
name|struct
name|mode_change
modifier|*
name|p
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
if|if
condition|(
name|octal_value
operator|!=
operator|(
name|octal_value
operator|&
name|ALLM
operator|)
condition|)
return|return
name|MODE_INVALID
return|;
comment|/* Help the compiler optimize the usual case where mode_t uses 	 the traditional octal representation.  */
name|mode
operator|=
operator|(
operator|(
name|S_ISUID
operator|==
name|SUID
operator|&&
name|S_ISGID
operator|==
name|SGID
operator|&&
name|S_ISVTX
operator|==
name|SVTX
operator|&&
name|S_IRUSR
operator|==
name|RUSR
operator|&&
name|S_IWUSR
operator|==
name|WUSR
operator|&&
name|S_IXUSR
operator|==
name|XUSR
operator|&&
name|S_IRGRP
operator|==
name|RGRP
operator|&&
name|S_IWGRP
operator|==
name|WGRP
operator|&&
name|S_IXGRP
operator|==
name|XGRP
operator|&&
name|S_IROTH
operator|==
name|ROTH
operator|&&
name|S_IWOTH
operator|==
name|WOTH
operator|&&
name|S_IXOTH
operator|==
name|XOTH
operator|)
condition|?
name|octal_value
else|:
operator|(
operator|(
name|octal_value
operator|&
name|SUID
condition|?
name|S_ISUID
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|SGID
condition|?
name|S_ISGID
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|SVTX
condition|?
name|S_ISVTX
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|RUSR
condition|?
name|S_IRUSR
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|WUSR
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|XUSR
condition|?
name|S_IXUSR
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|RGRP
condition|?
name|S_IRGRP
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|WGRP
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|XGRP
condition|?
name|S_IXGRP
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|ROTH
condition|?
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|WOTH
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator||
operator|(
name|octal_value
operator|&
name|XOTH
condition|?
name|S_IXOTH
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|make_node_op_equals
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
name|mode_append_entry
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
name|umask_value
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|umask_value
argument_list|)
expr_stmt|;
comment|/* Restore the old value. */
operator|--
name|mode_string
expr_stmt|;
comment|/* One loop iteration for each "ugoa...=+-rwxXstugo...[=+-rwxXstugo...]". */
do|do
block|{
comment|/* Which bits in the mode are operated on. */
name|mode_t
name|affected_bits
init|=
literal|0
decl_stmt|;
comment|/* `affected_bits' modified by umask. */
name|mode_t
name|affected_masked
decl_stmt|;
comment|/* Operators to actually use umask on. */
name|unsigned
name|ops_to_mask
init|=
literal|0
decl_stmt|;
name|int
name|who_specified_p
decl_stmt|;
name|affected_bits
operator|=
literal|0
expr_stmt|;
name|ops_to_mask
operator|=
literal|0
expr_stmt|;
comment|/* Turn on all the bits in `affected_bits' for each group given. */
for|for
control|(
operator|++
name|mode_string
init|;
condition|;
operator|++
name|mode_string
control|)
switch|switch
condition|(
operator|*
name|mode_string
condition|)
block|{
case|case
literal|'u'
case|:
name|affected_bits
operator||=
name|S_ISUID
operator||
name|S_IRWXU
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|affected_bits
operator||=
name|S_ISGID
operator||
name|S_IRWXG
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|affected_bits
operator||=
name|S_ISVTX
operator||
name|S_IRWXO
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|affected_bits
operator||=
name|CHMOD_MODE_BITS
expr_stmt|;
break|break;
default|default:
goto|goto
name|no_more_affected
goto|;
block|}
name|no_more_affected
label|:
comment|/* If none specified, affect all bits, except perhaps those 	 set in the umask. */
if|if
condition|(
name|affected_bits
condition|)
name|who_specified_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|who_specified_p
operator|=
literal|0
expr_stmt|;
name|affected_bits
operator|=
name|CHMOD_MODE_BITS
expr_stmt|;
name|ops_to_mask
operator|=
name|masked_ops
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|mode_string
operator|==
literal|'='
operator|||
operator|*
name|mode_string
operator|==
literal|'+'
operator|||
operator|*
name|mode_string
operator|==
literal|'-'
condition|)
block|{
name|struct
name|mode_change
modifier|*
name|change
init|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|==
name|NULL
condition|)
block|{
name|mode_free
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
block|}
name|change
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|change
operator|->
name|op
operator|=
operator|*
name|mode_string
expr_stmt|;
comment|/* One of "=+-". */
name|affected_masked
operator|=
name|affected_bits
expr_stmt|;
comment|/* Per the Single Unix Spec, if `who' is not specified and the 	     `=' operator is used, then clear all the bits first.  */
if|if
condition|(
operator|!
name|who_specified_p
operator|&&
name|ops_to_mask
operator|&
operator|(
operator|*
name|mode_string
operator|==
literal|'='
condition|?
name|MODE_MASK_EQUALS
else|:
literal|0
operator|)
condition|)
block|{
name|struct
name|mode_change
modifier|*
name|p
init|=
name|make_node_op_equals
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
name|mode_append_entry
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ops_to_mask
operator|&
operator|(
operator|*
name|mode_string
operator|==
literal|'='
condition|?
name|MODE_MASK_EQUALS
else|:
operator|*
name|mode_string
operator|==
literal|'+'
condition|?
name|MODE_MASK_PLUS
else|:
name|MODE_MASK_MINUS
operator|)
condition|)
name|affected_masked
operator|&=
operator|~
name|umask_value
expr_stmt|;
name|change
operator|->
name|affected
operator|=
name|affected_masked
expr_stmt|;
name|change
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|change
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Add the element to the tail of the list, so the operations 	     are performed in the correct order. */
name|mode_append_entry
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|change
argument_list|)
expr_stmt|;
comment|/* Set `value' according to the bits set in `affected_masked'. */
for|for
control|(
operator|++
name|mode_string
init|;
condition|;
operator|++
name|mode_string
control|)
switch|switch
condition|(
operator|*
name|mode_string
condition|)
block|{
case|case
literal|'r'
case|:
name|change
operator|->
name|value
operator||=
operator|(
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator|&
name|affected_masked
operator|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|change
operator|->
name|value
operator||=
operator|(
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&
name|affected_masked
operator|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|change
operator|->
name|flags
operator||=
name|MODE_X_IF_ANY_X
expr_stmt|;
comment|/* Fall through. */
case|case
literal|'x'
case|:
name|change
operator|->
name|value
operator||=
operator|(
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|&
name|affected_masked
operator|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Set the setuid/gid bits if `u' or `g' is selected. */
name|change
operator|->
name|value
operator||=
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Set the "save text image" bit if `o' is selected. */
name|change
operator|->
name|value
operator||=
name|S_ISVTX
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Set the affected bits to the value of the `u' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
name|S_IRWXU
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Set the affected bits to the value of the `g' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
name|S_IRWXG
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Set the affected bits to the value of the `o' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
name|S_IRWXO
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
default|default:
goto|goto
name|no_more_values
goto|;
block|}
name|no_more_values
label|:
empty_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|mode_string
operator|==
literal|','
condition|)
do|;
if|if
condition|(
operator|*
name|mode_string
operator|==
literal|0
condition|)
return|return
name|head
return|;
name|invalid
label|:
name|mode_free
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|MODE_INVALID
return|;
block|}
end_function

begin_comment
comment|/* Return a file mode change operation that sets permissions to match those    of REF_FILE.  Return MODE_BAD_REFERENCE if REF_FILE can't be accessed.  */
end_comment

begin_function
name|struct
name|mode_change
modifier|*
name|mode_create_from_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|ref_file
parameter_list|)
block|{
name|struct
name|mode_change
modifier|*
name|change
decl_stmt|;
comment|/* the only change element */
name|struct
name|stat
name|ref_stats
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ref_file
argument_list|,
operator|&
name|ref_stats
argument_list|)
condition|)
return|return
name|MODE_BAD_REFERENCE
return|;
name|change
operator|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|==
name|NULL
condition|)
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
name|change
operator|->
name|op
operator|=
literal|'='
expr_stmt|;
name|change
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|change
operator|->
name|affected
operator|=
name|CHMOD_MODE_BITS
expr_stmt|;
name|change
operator|->
name|value
operator|=
name|ref_stats
operator|.
name|st_mode
expr_stmt|;
name|change
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|change
return|;
block|}
end_function

begin_comment
comment|/* Return file mode OLDMODE, adjusted as indicated by the list of change    operations CHANGES.  If OLDMODE is a directory, the type `X'    change affects it even if no execute bits were set in OLDMODE.    The returned value has the S_IFMT bits cleared. */
end_comment

begin_function
name|mode_t
name|mode_adjust
parameter_list|(
name|mode_t
name|oldmode
parameter_list|,
specifier|const
name|struct
name|mode_change
modifier|*
name|changes
parameter_list|)
block|{
name|mode_t
name|newmode
decl_stmt|;
comment|/* The adjusted mode and one operand. */
name|mode_t
name|value
decl_stmt|;
comment|/* The other operand. */
name|newmode
operator|=
name|oldmode
operator|&
name|CHMOD_MODE_BITS
expr_stmt|;
for|for
control|(
init|;
name|changes
condition|;
name|changes
operator|=
name|changes
operator|->
name|next
control|)
block|{
if|if
condition|(
name|changes
operator|->
name|flags
operator|&
name|MODE_COPY_EXISTING
condition|)
block|{
comment|/* Isolate in `value' the bits in `newmode' to copy, given in 	     the mask `changes->value'. */
name|value
operator|=
name|newmode
operator|&
name|changes
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|changes
operator|->
name|value
operator|&
name|S_IRWXU
condition|)
comment|/* Copy `u' permissions onto `g' and `o'. */
name|value
operator||=
operator|(
operator|(
name|value
operator|&
name|S_IRUSR
condition|?
name|S_IRGRP
operator||
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IWUSR
condition|?
name|S_IWGRP
operator||
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IXUSR
condition|?
name|S_IXGRP
operator||
name|S_IXOTH
else|:
literal|0
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|changes
operator|->
name|value
operator|&
name|S_IRWXG
condition|)
comment|/* Copy `g' permissions onto `u' and `o'. */
name|value
operator||=
operator|(
operator|(
name|value
operator|&
name|S_IRGRP
condition|?
name|S_IRUSR
operator||
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IWGRP
condition|?
name|S_IWUSR
operator||
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IXGRP
condition|?
name|S_IXUSR
operator||
name|S_IXOTH
else|:
literal|0
operator|)
operator|)
expr_stmt|;
else|else
comment|/* Copy `o' permissions onto `u' and `g'. */
name|value
operator||=
operator|(
operator|(
name|value
operator|&
name|S_IROTH
condition|?
name|S_IRUSR
operator||
name|S_IRGRP
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IWOTH
condition|?
name|S_IWUSR
operator||
name|S_IRGRP
else|:
literal|0
operator|)
operator||
operator|(
name|value
operator|&
name|S_IXOTH
condition|?
name|S_IXUSR
operator||
name|S_IXGRP
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* In order to change only `u', `g', or `o' permissions, 	     or some combination thereof, clear unselected bits. 	     This cannot be done in mode_compile because the value 	     to which the `changes->affected' mask is applied depends 	     on the old mode of each file. */
name|value
operator|&=
name|changes
operator|->
name|affected
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|changes
operator|->
name|value
expr_stmt|;
comment|/* If `X', do not affect the execute bits if the file is not a 	     directory and no execute bits are already set. */
if|if
condition|(
operator|(
name|changes
operator|->
name|flags
operator|&
name|MODE_X_IF_ANY_X
operator|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
name|newmode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* Clear the execute bits. */
name|value
operator|&=
operator|~
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|changes
operator|->
name|op
condition|)
block|{
case|case
literal|'='
case|:
comment|/* Preserve the previous values in `newmode' of bits that are 	     not affected by this change operation. */
name|newmode
operator|=
operator|(
name|newmode
operator|&
operator|~
name|changes
operator|->
name|affected
operator|)
operator||
name|value
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|newmode
operator||=
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|newmode
operator|&=
operator|~
name|value
expr_stmt|;
break|break;
block|}
block|}
return|return
name|newmode
return|;
block|}
end_function

begin_comment
comment|/* Free the memory used by the list of file mode change operations    CHANGES. */
end_comment

begin_function
name|void
name|mode_free
parameter_list|(
specifier|register
name|struct
name|mode_change
modifier|*
name|changes
parameter_list|)
block|{
specifier|register
name|struct
name|mode_change
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|next
operator|=
name|changes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
name|changes
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

