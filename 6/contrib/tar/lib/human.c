begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* human.c -- print human readable file size    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Originally contributed by lm@sgi.com;    --si, output block size selection, and large file support    added by eggert@twinsun.com.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_DECL_GETENV
end_ifndef

begin_expr_stmt
literal|"this configure-time declaration test was not run"
endif|#
directive|endif
if|#
directive|if
operator|!
name|HAVE_DECL_GETENV
name|char
operator|*
name|getenv
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ENABLE_NLS
end_if

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Text
parameter_list|)
value|gettext (Text)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Text
parameter_list|)
value|Text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<argmatch.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<xstrtol.h>
end_include

begin_include
include|#
directive|include
file|"human.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|suffixes
index|[]
init|=
block|{
literal|0
block|,
comment|/* not used */
literal|'k'
block|,
comment|/* kilo */
literal|'M'
block|,
comment|/* Mega */
literal|'G'
block|,
comment|/* Giga */
literal|'T'
block|,
comment|/* Tera */
literal|'P'
block|,
comment|/* Peta */
literal|'E'
block|,
comment|/* Exa */
literal|'Z'
block|,
comment|/* Zetta */
literal|'Y'
comment|/* Yotta */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If INEXACT_STYLE is not human_round_to_even, and if easily    possible, adjust VALUE according to the style.  */
end_comment

begin_function
specifier|static
name|double
name|adjust_value
parameter_list|(
name|enum
name|human_inexact_style
name|inexact_style
parameter_list|,
name|double
name|value
parameter_list|)
block|{
comment|/* Do not use the floor or ceil functions, as that would mean      linking with the standard math library, which is a porting pain.      So leave the value alone if it is too large to easily round.  */
if|if
condition|(
name|inexact_style
operator|!=
name|human_round_to_even
operator|&&
name|value
operator|<
operator|(
name|uintmax_t
operator|)
operator|-
literal|1
condition|)
block|{
name|uintmax_t
name|u
init|=
name|value
decl_stmt|;
name|value
operator|=
name|u
operator|+
operator|(
name|inexact_style
operator|==
name|human_ceiling
operator|&&
name|u
operator|!=
name|value
operator|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Like human_readable_inexact, except always round to even.  */
end_comment

begin_function
name|char
modifier|*
name|human_readable
parameter_list|(
name|uintmax_t
name|n
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|from_block_size
parameter_list|,
name|int
name|output_block_size
parameter_list|)
block|{
return|return
name|human_readable_inexact
argument_list|(
name|n
argument_list|,
name|buf
argument_list|,
name|from_block_size
argument_list|,
name|output_block_size
argument_list|,
name|human_round_to_even
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert N to a human readable format in BUF.     N is expressed in units of FROM_BLOCK_SIZE.  FROM_BLOCK_SIZE must    be nonnegative.     OUTPUT_BLOCK_SIZE must be nonzero.  If it is positive, use units of    OUTPUT_BLOCK_SIZE in the output number.     Use INEXACT_STYLE to determine whether to take the ceiling or floor    of any result that cannot be expressed exactly.     If OUTPUT_BLOCK_SIZE is negative, use a format like "127k" if    possible, using powers of -OUTPUT_BLOCK_SIZE; otherwise, use    ordinary decimal format.  Normally -OUTPUT_BLOCK_SIZE is either    1000 or 1024; it must be at least 2.  Most people visually process    strings of 3-4 digits effectively, but longer strings of digits are    more prone to misinterpretation.  Hence, converting to an    abbreviated form usually improves readability.  Use a suffix    indicating which power is being used.  For example, assuming    -OUTPUT_BLOCK_SIZE is 1024, 8500 would be converted to 8.3k,    133456345 to 127M, 56990456345 to 53G, and so on.  Numbers smaller    than -OUTPUT_BLOCK_SIZE aren't modified.  */
end_comment

begin_function
name|char
modifier|*
name|human_readable_inexact
parameter_list|(
name|uintmax_t
name|n
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|from_block_size
parameter_list|,
name|int
name|output_block_size
parameter_list|,
name|enum
name|human_inexact_style
name|inexact_style
parameter_list|)
block|{
name|uintmax_t
name|amt
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|to_block_size
decl_stmt|;
name|int
name|tenths
init|=
literal|0
decl_stmt|;
name|int
name|power
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 0 means adjusted N == AMT.TENTHS;      1 means AMT.TENTHS< adjusted N< AMT.TENTHS + 0.05;      2 means adjusted N == AMT.TENTHS + 0.05;      3 means AMT.TENTHS + 0.05< adjusted N< AMT.TENTHS + 0.1.  */
name|int
name|rounding
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|output_block_size
operator|<
literal|0
condition|)
block|{
name|base
operator|=
operator|-
name|output_block_size
expr_stmt|;
name|to_block_size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|0
expr_stmt|;
name|to_block_size
operator|=
name|output_block_size
expr_stmt|;
block|}
name|p
operator|=
name|buf
operator|+
name|LONGEST_HUMAN_READABLE
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
comment|/* Suppress `used before initialized' warning.  */
name|power
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Adjust AMT out of FROM_BLOCK_SIZE units and into TO_BLOCK_SIZE units.  */
block|{
name|int
name|multiplier
decl_stmt|;
name|int
name|divisor
decl_stmt|;
name|int
name|r2
decl_stmt|;
name|int
name|r10
decl_stmt|;
if|if
condition|(
name|to_block_size
operator|<=
name|from_block_size
condition|?
operator|(
name|from_block_size
operator|%
name|to_block_size
operator|!=
literal|0
operator|||
operator|(
name|multiplier
operator|=
name|from_block_size
operator|/
name|to_block_size
operator|,
operator|(
name|amt
operator|=
name|n
operator|*
name|multiplier
operator|)
operator|/
name|multiplier
operator|!=
name|n
operator|)
operator|)
else|:
operator|(
name|from_block_size
operator|==
literal|0
operator|||
name|to_block_size
operator|%
name|from_block_size
operator|!=
literal|0
operator|||
operator|(
name|divisor
operator|=
name|to_block_size
operator|/
name|from_block_size
operator|,
name|r10
operator|=
operator|(
name|n
operator|%
name|divisor
operator|)
operator|*
literal|10
operator|,
name|r2
operator|=
operator|(
name|r10
operator|%
name|divisor
operator|)
operator|*
literal|2
operator|,
name|amt
operator|=
name|n
operator|/
name|divisor
operator|,
name|tenths
operator|=
name|r10
operator|/
name|divisor
operator|,
name|rounding
operator|=
name|r2
operator|<
name|divisor
condition|?
literal|0
operator|<
name|r2
else|:
literal|2
operator|+
operator|(
name|divisor
operator|<
name|r2
operator|)
operator|,
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Either the result cannot be computed easily using uintmax_t, 	   or from_block_size is zero.  Fall back on floating point. 	   FIXME: This can yield answers that are slightly off.  */
name|double
name|damt
init|=
name|n
operator|*
operator|(
name|from_block_size
operator|/
operator|(
name|double
operator|)
name|to_block_size
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.0f"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|double
name|e
init|=
literal|1
decl_stmt|;
name|power
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|e
operator|*=
name|base
expr_stmt|;
name|power
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|*
name|base
operator|<=
name|damt
operator|&&
name|power
operator|<
sizeof|sizeof
name|suffixes
operator|-
literal|1
condition|)
do|;
name|damt
operator|/=
name|e
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.1f%c"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
argument_list|)
argument_list|,
name|suffixes
index|[
name|power
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
literal|4
operator|<
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.0f%c"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
operator|*
literal|10
argument_list|)
operator|/
literal|10
argument_list|,
name|suffixes
index|[
name|power
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
block|}
comment|/* Use power of BASE notation if adjusted AMT is large enough.  */
if|if
condition|(
name|base
operator|&&
name|base
operator|<=
name|amt
condition|)
block|{
name|power
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|r10
init|=
operator|(
name|amt
operator|%
name|base
operator|)
operator|*
literal|10
operator|+
name|tenths
decl_stmt|;
name|int
name|r2
init|=
operator|(
name|r10
operator|%
name|base
operator|)
operator|*
literal|2
operator|+
operator|(
name|rounding
operator|>>
literal|1
operator|)
decl_stmt|;
name|amt
operator|/=
name|base
expr_stmt|;
name|tenths
operator|=
name|r10
operator|/
name|base
expr_stmt|;
name|rounding
operator|=
operator|(
name|r2
operator|<
name|base
condition|?
literal|0
operator|<
name|r2
operator|+
name|rounding
else|:
literal|2
operator|+
operator|(
name|base
operator|<
name|r2
operator|+
name|rounding
operator|)
operator|)
expr_stmt|;
name|power
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|<=
name|amt
operator|&&
name|power
operator|<
sizeof|sizeof
name|suffixes
operator|-
literal|1
condition|)
do|;
operator|*
operator|--
name|p
operator|=
name|suffixes
index|[
name|power
index|]
expr_stmt|;
if|if
condition|(
name|amt
operator|<
literal|10
condition|)
block|{
if|if
condition|(
literal|2
operator|*
operator|(
literal|1
operator|-
operator|(
name|int
operator|)
name|inexact_style
operator|)
operator|<
name|rounding
operator|+
operator|(
name|tenths
operator|&
operator|(
name|inexact_style
operator|==
name|human_round_to_even
operator|)
operator|)
condition|)
block|{
name|tenths
operator|++
expr_stmt|;
name|rounding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tenths
operator|==
literal|10
condition|)
block|{
name|amt
operator|++
expr_stmt|;
name|tenths
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amt
operator|<
literal|10
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|tenths
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
name|tenths
operator|=
name|rounding
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inexact_style
operator|==
name|human_ceiling
condition|?
literal|0
operator|<
name|tenths
operator|+
name|rounding
else|:
name|inexact_style
operator|==
name|human_round_to_even
condition|?
literal|5
operator|<
name|tenths
operator|+
operator|(
literal|2
operator|<
name|rounding
operator|+
operator|(
name|amt
operator|&
literal|1
operator|)
operator|)
else|:
comment|/* inexact_style == human_floor */
literal|0
condition|)
block|{
name|amt
operator|++
expr_stmt|;
if|if
condition|(
name|amt
operator|==
name|base
operator|&&
name|power
operator|<
sizeof|sizeof
name|suffixes
operator|-
literal|1
condition|)
block|{
operator|*
name|p
operator|=
name|suffixes
index|[
name|power
operator|+
literal|1
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'0'
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
name|amt
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|amt
operator|%
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|amt
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The default block size used for output.  This number may change in    the future as disks get larger.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_BLOCK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_BLOCK_SIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|block_size_args
index|[]
init|=
block|{
literal|"human-readable"
block|,
literal|"si"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|block_size_types
index|[]
init|=
block|{
operator|-
literal|1024
block|,
operator|-
literal|1000
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|default_block_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|?
literal|512
else|:
name|DEFAULT_BLOCK_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|strtol_error
name|humblock
parameter_list|(
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|int
modifier|*
name|block_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|spec
operator|&&
operator|!
operator|(
name|spec
operator|=
name|getenv
argument_list|(
literal|"BLOCK_SIZE"
argument_list|)
operator|)
condition|)
operator|*
name|block_size
operator|=
name|default_block_size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
operator|(
name|i
operator|=
name|ARGMATCH
argument_list|(
name|spec
argument_list|,
name|block_size_args
argument_list|,
name|block_size_types
argument_list|)
operator|)
condition|)
operator|*
name|block_size
operator|=
name|block_size_types
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|strtol_error
name|e
init|=
name|xstrtoul
argument_list|(
name|spec
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
literal|"eEgGkKmMpPtTyYzZ0"
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|LONGINT_OK
condition|)
return|return
name|e
return|;
if|if
condition|(
operator|*
name|ptr
condition|)
return|return
name|LONGINT_INVALID_SUFFIX_CHAR
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|val
operator|<
literal|0
operator|||
name|val
operator|!=
operator|(
name|int
operator|)
name|val
condition|)
return|return
name|LONGINT_OVERFLOW
return|;
operator|*
name|block_size
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
block|}
return|return
name|LONGINT_OK
return|;
block|}
end_function

begin_function
name|void
name|human_block_size
parameter_list|(
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|int
name|report_errors
parameter_list|,
name|int
modifier|*
name|block_size
parameter_list|)
block|{
name|strtol_error
name|e
init|=
name|humblock
argument_list|(
name|spec
argument_list|,
name|block_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|block_size
operator|==
literal|0
condition|)
block|{
operator|*
name|block_size
operator|=
name|default_block_size
argument_list|()
expr_stmt|;
name|e
operator|=
name|LONGINT_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|LONGINT_OK
operator|&&
name|report_errors
condition|)
name|STRTOL_FATAL_ERROR
argument_list|(
name|spec
argument_list|,
name|_
argument_list|(
literal|"block size"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

