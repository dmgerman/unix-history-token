begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Routine to disable IP-level socket options. This code was taken from 4.4BSD   * rlogind and kernel source, but all mistakes in it are my fault.   *   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   *   * $FreeBSD$   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) fix_options.c 1.6 97/04/08 02:29:19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|IPOPT_OPTVAL
end_ifndef

begin_define
define|#
directive|define
name|IPOPT_OPTVAL
value|0
end_define

begin_define
define|#
directive|define
name|IPOPT_OLEN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|512
end_define

begin_comment
comment|/* Was: BUFSIZ */
end_comment

begin_comment
comment|/* fix_options - get rid of IP-level socket options */
end_comment

begin_macro
name|fix_options
argument_list|(
argument|request
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|IP_OPTIONS
name|unsigned
name|char
name|optbuf
index|[
name|BUFFER_SIZE
operator|/
literal|3
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|lbuf
index|[
name|BUFFER_SIZE
index|]
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|optsize
init|=
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
decl_stmt|,
name|ipproto
decl_stmt|;
name|struct
name|protoent
modifier|*
name|ip
decl_stmt|;
name|int
name|fd
init|=
name|request
operator|->
name|fd
decl_stmt|;
name|unsigned
name|int
name|opt
decl_stmt|;
name|int
name|optlen
decl_stmt|;
name|struct
name|in_addr
name|dummy
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|sslen
decl_stmt|;
comment|/*      * check if this is AF_INET socket      * XXX IPv6 support?      */
name|sslen
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|sslen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getpeername: %m"
argument_list|)
expr_stmt|;
name|clean_exit
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|!=
name|AF_INET
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ip
operator|=
name|getprotobyname
argument_list|(
literal|"ip"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ipproto
operator|=
name|ip
operator|->
name|p_proto
expr_stmt|;
else|else
name|ipproto
operator|=
name|IPPROTO_IP
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|ipproto
argument_list|,
name|IP_OPTIONS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|optbuf
argument_list|,
operator|&
name|optsize
argument_list|)
operator|==
literal|0
operator|&&
name|optsize
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Horror! 4.[34] BSD getsockopt() prepends the first-hop destination 	 * address to the result IP options list when source routing options 	 * are present (see<netinet/ip_var.h>), but produces no output for 	 * other IP options. Solaris 2.x getsockopt() does produce output for 	 * non-routing IP options, and uses the same format as BSD even when 	 * the space for the destination address is unused. The code below 	 * does the right thing with 4.[34]BSD derivatives and Solaris 2, but 	 * may occasionally miss source routing options on incompatible 	 * systems such as Linux. Their choice. 	 *  	 * Look for source routing options. Drop the connection when one is 	 * found. Just wiping the IP options is insufficient: we would still 	 * help the attacker by providing a real TCP sequence number, and the 	 * attacker would still be able to send packets (blind spoofing). I 	 * discussed this attack with Niels Provos, half a year before the 	 * attack was described in open mailing lists. 	 *  	 * It would be cleaner to just return a yes/no reply and let the caller 	 * decide how to deal with it. Resident servers should not terminate. 	 * However I am not prepared to make changes to internal interfaces 	 * on short notice. 	 */
define|#
directive|define
name|ADDR_LEN
value|sizeof(dummy.s_addr)
for|for
control|(
name|cp
operator|=
name|optbuf
operator|+
name|ADDR_LEN
init|;
name|cp
operator|<
name|optbuf
operator|+
name|optsize
condition|;
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
name|IPOPT_OPTVAL
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_LSRR
operator|||
name|opt
operator|==
name|IPOPT_SSRR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"refused connect from %s with IP source routing options"
argument_list|,
name|eval_client
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt
operator|==
name|IPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
block|{
name|optlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|optlen
operator|=
name|cp
index|[
name|IPOPT_OLEN
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<=
literal|0
condition|)
comment|/* Do not loop! */
break|break;
block|}
block|}
name|lp
operator|=
name|lbuf
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|optbuf
init|;
name|optsize
operator|>
literal|0
condition|;
name|cp
operator|++
operator|,
name|optsize
operator|--
operator|,
name|lp
operator|+=
literal|3
control|)
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|" %2.2x"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"connect from %s with IP options (ignored):%s"
argument_list|,
name|eval_client
argument_list|(
name|request
argument_list|)
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|ipproto
argument_list|,
name|IP_OPTIONS
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|optsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_OPTIONS NULL: %m"
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

end_unit

