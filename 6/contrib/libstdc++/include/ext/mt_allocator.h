begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// MT-optimized allocator -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2003, 2004 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/** @file ext/mt_allocator.h  *  This file is a GNU extension to the Standard C++ Library.  *  You should only include this header if you are using GCC 3 or later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MT_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|_MT_ALLOCATOR_H
value|1
end_define

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<bits/functexcept.h>
end_include

begin_include
include|#
directive|include
file|<bits/gthr.h>
end_include

begin_include
include|#
directive|include
file|<bits/atomicity.h>
end_include

begin_decl_stmt
name|namespace
name|__gnu_cxx
block|{
comment|/**    *  This is a fixed size (power of 2) allocator which - when    *  compiled with thread support - will maintain one freelist per    *  size per thread plus a "global" one. Steps are taken to limit    *  the per thread freelist sizes (by returning excess back to    *  "global").    *    *  Further details:    *  http://gcc.gnu.org/onlinedocs/libstdc++/ext/mt_allocator.html    */
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|__mt_alloc
block|{
name|public
operator|:
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|_Tp
modifier|*
name|const_pointer
typedef|;
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|_Tp
name|value_type
typedef|;
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|__mt_alloc
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
empty_stmt|;
name|__mt_alloc
argument_list|()
name|throw
argument_list|()
block|{
comment|// XXX
block|}
name|__mt_alloc
argument_list|(
argument|const __mt_alloc&
argument_list|)
name|throw
argument_list|()
block|{
comment|// XXX
block|}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__mt_alloc
argument_list|(
argument|const __mt_alloc<_Tp1>& obj
argument_list|)
name|throw
argument_list|()
block|{
comment|// XXX
block|}
operator|~
name|__mt_alloc
argument_list|()
name|throw
argument_list|()
block|{ }
name|pointer
name|address
argument_list|(
argument|reference __x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|__x
return|;
block|}
name|const_pointer
name|address
argument_list|(
name|const_reference
name|__x
argument_list|)
decl|const
block|{
return|return
operator|&
name|__x
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|size_t
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
return|;
block|}
comment|// _GLIBCXX_RESOLVE_LIB_DEFECTS
comment|// 402. wrong new expression in [some_] allocator::construct
name|void
name|construct
parameter_list|(
name|pointer
name|__p
parameter_list|,
specifier|const
name|_Tp
modifier|&
name|__val
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|__p
argument_list|)
name|_Tp
argument_list|(
name|__val
argument_list|)
expr_stmt|;
block|}
name|void
name|destroy
parameter_list|(
name|pointer
name|__p
parameter_list|)
block|{
name|__p
operator|->
expr|~
name|_Tp
argument_list|()
expr_stmt|;
block|}
name|pointer
name|allocate
parameter_list|(
name|size_type
name|__n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|)
function_decl|;
comment|// Variables used to configure the behavior of the allocator,
comment|// assigned and explained in detail below.
struct|struct
name|_Tune
block|{
comment|// Alignment needed.
comment|// NB: In any case must be>= sizeof(_Block_record), that
comment|// is 4 on 32 bit machines and 8 on 64 bit machines.
name|size_t
name|_M_align
decl_stmt|;
comment|// Allocation requests (after round-up to power of 2) below
comment|// this value will be handled by the allocator. A raw new/
comment|// call will be used for requests larger than this value.
name|size_t
name|_M_max_bytes
decl_stmt|;
comment|// Size in bytes of the smallest bin.
comment|// NB: Must be a power of 2 and>= _M_align.
name|size_t
name|_M_min_bin
decl_stmt|;
comment|// In order to avoid fragmenting and minimize the number of
comment|// new() calls we always request new memory using this
comment|// value. Based on previous discussions on the libstdc++
comment|// mailing list we have choosen the value below.
comment|// See http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html
name|size_t
name|_M_chunk_size
decl_stmt|;
comment|// The maximum number of supported threads. Our Linux 2.4.18
comment|// reports 4070 in /proc/sys/kernel/threads-max
name|size_t
name|_M_max_threads
decl_stmt|;
comment|// Each time a deallocation occurs in a threaded application
comment|// we make sure that there are no more than
comment|// _M_freelist_headroom % of used memory on the freelist. If
comment|// the number of additional records is more than
comment|// _M_freelist_headroom % of the freelist, we move these
comment|// records back to the global pool.
name|size_t
name|_M_freelist_headroom
decl_stmt|;
comment|// Set to true forces all allocations to use new().
name|bool
name|_M_force_new
decl_stmt|;
name|explicit
name|_Tune
argument_list|()
operator|:
name|_M_align
argument_list|(
literal|8
argument_list|)
operator|,
name|_M_max_bytes
argument_list|(
literal|128
argument_list|)
operator|,
name|_M_min_bin
argument_list|(
literal|8
argument_list|)
operator|,
name|_M_chunk_size
argument_list|(
literal|4096
operator|-
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|,
name|_M_max_threads
argument_list|(
literal|4096
argument_list|)
operator|,
name|_M_freelist_headroom
argument_list|(
literal|10
argument_list|)
operator|,
name|_M_force_new
argument_list|(
argument|getenv(
literal|"GLIBCXX_FORCE_NEW"
argument|) ? true : false
argument_list|)
block|{ }
name|explicit
name|_Tune
argument_list|(
argument|size_t __align
argument_list|,
argument|size_t __maxb
argument_list|,
argument|size_t __minbin
argument_list|,
argument|size_t __chunk
argument_list|,
argument|size_t __maxthreads
argument_list|,
argument|size_t __headroom
argument_list|,
argument|bool __force
argument_list|)
operator|:
name|_M_align
argument_list|(
name|__align
argument_list|)
operator|,
name|_M_max_bytes
argument_list|(
name|__maxb
argument_list|)
operator|,
name|_M_min_bin
argument_list|(
name|__minbin
argument_list|)
operator|,
name|_M_chunk_size
argument_list|(
name|__chunk
argument_list|)
operator|,
name|_M_max_threads
argument_list|(
name|__maxthreads
argument_list|)
operator|,
name|_M_freelist_headroom
argument_list|(
name|__headroom
argument_list|)
operator|,
name|_M_force_new
argument_list|(
argument|__force
argument_list|)
block|{ }
block|}
struct|;
name|private
label|:
comment|// We need to create the initial lists and set up some variables
comment|// before we can answer to the first request for memory.
ifdef|#
directive|ifdef
name|__GTHREADS
specifier|static
name|__gthread_once_t
name|_S_once
decl_stmt|;
endif|#
directive|endif
specifier|static
name|bool
name|_S_init
decl_stmt|;
specifier|static
name|void
name|_S_initialize
parameter_list|()
function_decl|;
comment|// Configuration options.
specifier|static
name|_Tune
name|_S_options
decl_stmt|;
specifier|static
specifier|const
name|_Tune
name|_S_get_options
parameter_list|()
block|{
return|return
name|_S_options
return|;
block|}
specifier|static
name|void
name|_S_set_options
parameter_list|(
name|_Tune
name|__t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_S_init
condition|)
name|_S_options
operator|=
name|__t
expr_stmt|;
block|}
comment|// Using short int as type for the binmap implies we are never
comment|// caching blocks larger than 65535 with this allocator
typedef|typedef
name|unsigned
name|short
name|int
name|_Binmap_type
typedef|;
specifier|static
name|_Binmap_type
modifier|*
name|_S_binmap
decl_stmt|;
comment|// Each requesting thread is assigned an id ranging from 1 to
comment|// _S_max_threads. Thread id 0 is used as a global memory pool.
comment|// In order to get constant performance on the thread assignment
comment|// routine, we keep a list of free ids. When a thread first
comment|// requests memory we remove the first record in this list and
comment|// stores the address in a __gthread_key. When initializing the
comment|// __gthread_key we specify a destructor. When this destructor
comment|// (i.e. the thread dies) is called, we return the thread id to
comment|// the front of this list.
ifdef|#
directive|ifdef
name|__GTHREADS
struct|struct
name|_Thread_record
block|{
comment|// Points to next free thread id record. NULL if last record in list.
name|_Thread_record
modifier|*
specifier|volatile
name|_M_next
decl_stmt|;
comment|// Thread id ranging from 1 to _S_max_threads.
name|size_t
name|_M_id
decl_stmt|;
block|}
struct|;
specifier|static
name|_Thread_record
modifier|*
specifier|volatile
name|_S_thread_freelist_first
decl_stmt|;
specifier|static
name|__gthread_mutex_t
name|_S_thread_freelist_mutex
decl_stmt|;
specifier|static
name|__gthread_key_t
name|_S_thread_key
decl_stmt|;
specifier|static
name|void
name|_S_destroy_thread_key
parameter_list|(
name|void
modifier|*
name|__freelist_pos
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|static
name|size_t
name|_S_get_thread_id
parameter_list|()
function_decl|;
union|union
name|_Block_record
block|{
comment|// Points to the block_record of the next free block.
name|_Block_record
modifier|*
specifier|volatile
name|_M_next
decl_stmt|;
ifdef|#
directive|ifdef
name|__GTHREADS
comment|// The thread id of the thread which has requested this block.
name|size_t
name|_M_thread_id
decl_stmt|;
endif|#
directive|endif
block|}
union|;
struct|struct
name|_Bin_record
block|{
comment|// An "array" of pointers to the first free block for each
comment|// thread id. Memory to this "array" is allocated in _S_initialize()
comment|// for _S_max_threads + global pool 0.
name|_Block_record
modifier|*
modifier|*
specifier|volatile
name|_M_first
decl_stmt|;
ifdef|#
directive|ifdef
name|__GTHREADS
comment|// An "array" of counters used to keep track of the amount of
comment|// blocks that are on the freelist/used for each thread id.
comment|// Memory to these "arrays" is allocated in _S_initialize() for
comment|// _S_max_threads + global pool 0.
name|size_t
modifier|*
specifier|volatile
name|_M_free
decl_stmt|;
name|size_t
modifier|*
specifier|volatile
name|_M_used
decl_stmt|;
comment|// Each bin has its own mutex which is used to ensure data
comment|// integrity while changing "ownership" on a block.  The mutex
comment|// is initialized in _S_initialize().
name|__gthread_mutex_t
modifier|*
name|_M_mutex
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
comment|// An "array" of bin_records each of which represents a specific
comment|// power of 2 size. Memory to this "array" is allocated in
comment|// _S_initialize().
specifier|static
name|_Bin_record
modifier|*
specifier|volatile
name|_S_bin
decl_stmt|;
comment|// Actual value calculated in _S_initialize().
specifier|static
name|size_t
name|_S_bin_size
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|pointer
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|allocate
argument_list|(
argument|size_type __n
argument_list|,
argument|const void*
argument_list|)
block|{
comment|// Although the test in __gthread_once() would suffice, we wrap
comment|// test of the once condition in our own unlocked check. This
comment|// saves one function call to pthread_once() (which itself only
comment|// tests for the once value unlocked anyway and immediately
comment|// returns if set)
if|if
condition|(
operator|!
name|_S_init
condition|)
block|{
ifdef|#
directive|ifdef
name|__GTHREADS
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
name|__gthread_once
argument_list|(
operator|&
name|_S_once
argument_list|,
name|_S_initialize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|_S_init
condition|)
name|_S_initialize
argument_list|()
expr_stmt|;
block|}
comment|// Requests larger than _M_max_bytes are handled by new/delete
comment|// directly.
specifier|const
name|size_t
name|__bytes
operator|=
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__bytes
operator|>
name|_S_options
operator|.
name|_M_max_bytes
operator|||
name|_S_options
operator|.
name|_M_force_new
condition|)
block|{
name|void
modifier|*
name|__ret
init|=
operator|::
name|operator
name|new
argument_list|(
name|__bytes
argument_list|)
decl_stmt|;
return|return
name|static_cast
operator|<
name|_Tp
operator|*
operator|>
operator|(
name|__ret
operator|)
return|;
block|}
end_if

begin_comment
comment|// Round up to power of 2 and figure out which bin to use.
end_comment

begin_decl_stmt
specifier|const
name|size_t
name|__which
init|=
name|_S_binmap
index|[
name|__bytes
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|size_t
name|__thread_id
init|=
name|_S_get_thread_id
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Find out if we have blocks on our freelist.  If so, go ahead
end_comment

begin_comment
comment|// and use them directly without having to lock anything.
end_comment

begin_decl_stmt
specifier|const
name|_Bin_record
modifier|&
name|__bin
init|=
name|_S_bin
index|[
name|__which
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Block_record
operator|*
specifier|__block
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|==
name|NULL
condition|)
block|{
comment|// NB: For alignment reasons, we can't use the first _M_align
comment|// bytes, even when sizeof(_Block_record)< _M_align.
specifier|const
name|size_t
name|__bin_size
init|=
operator|(
operator|(
name|_S_options
operator|.
name|_M_min_bin
operator|<<
name|__which
operator|)
operator|+
name|_S_options
operator|.
name|_M_align
operator|)
decl_stmt|;
name|size_t
name|__block_count
init|=
name|_S_options
operator|.
name|_M_chunk_size
operator|/
name|__bin_size
decl_stmt|;
comment|// Are we using threads?
comment|// - Yes, check if there are free blocks on the global
comment|//   list. If so, grab up to __block_count blocks in one
comment|//   lock and change ownership. If the global list is
comment|//   empty, we allocate a new chunk and add those blocks
comment|//   directly to our own freelist (with us as owner).
comment|// - No, all operations are made directly to global pool 0
comment|//   no need to lock or change ownership but check for free
comment|//   blocks on global list (and if not add new ones) and
comment|//   get the first one.
ifdef|#
directive|ifdef
name|__GTHREADS
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
name|__gthread_mutex_lock
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
comment|// No need to hold the lock when we are adding a
comment|// whole chunk to our own list.
name|__gthread_mutex_unlock
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
name|void
modifier|*
name|__v
init|=
operator|::
name|operator
name|new
argument_list|(
name|_S_options
operator|.
name|_M_chunk_size
argument_list|)
decl_stmt|;
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|=
name|static_cast
operator|<
name|_Block_record
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|=
name|__block_count
expr_stmt|;
operator|--
name|__block_count
expr_stmt|;
specifier|__block
operator|=
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
expr_stmt|;
while|while
condition|(
name|__block_count
operator|--
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|__c
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
specifier|__block
operator|)
operator|+
name|__bin_size
decl_stmt|;
specifier|__block
operator|->
name|_M_next
operator|=
name|reinterpret_cast
operator|<
name|_Block_record
operator|*
operator|>
operator|(
name|__c
operator|)
expr_stmt|;
specifier|__block
operator|=
specifier|__block
operator|->
name|_M_next
expr_stmt|;
block|}
specifier|__block
operator|->
name|_M_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|// Is the number of required blocks greater than or
comment|// equal to the number that can be provided by the
comment|// global free list?
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|=
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|__block_count
operator|>=
name|__bin
operator|.
name|_M_free
index|[
literal|0
index|]
condition|)
block|{
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|=
name|__bin
operator|.
name|_M_free
index|[
literal|0
index|]
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|=
name|__block_count
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
literal|0
index|]
operator|-=
name|__block_count
expr_stmt|;
operator|--
name|__block_count
expr_stmt|;
specifier|__block
operator|=
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|__block_count
operator|--
operator|>
literal|0
condition|)
specifier|__block
operator|=
specifier|__block
operator|->
name|_M_next
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
specifier|__block
operator|->
name|_M_next
expr_stmt|;
specifier|__block
operator|->
name|_M_next
operator|=
name|NULL
expr_stmt|;
block|}
name|__gthread_mutex_unlock
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|void
modifier|*
name|__v
init|=
operator|::
name|operator
name|new
argument_list|(
name|_S_options
operator|.
name|_M_chunk_size
argument_list|)
decl_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
name|static_cast
operator|<
name|_Block_record
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
operator|--
name|__block_count
expr_stmt|;
specifier|__block
operator|=
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|__block_count
operator|--
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|__c
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
specifier|__block
operator|)
operator|+
name|__bin_size
decl_stmt|;
specifier|__block
operator|->
name|_M_next
operator|=
name|reinterpret_cast
operator|<
name|_Block_record
operator|*
operator|>
operator|(
name|__c
operator|)
expr_stmt|;
specifier|__block
operator|=
specifier|__block
operator|->
name|_M_next
expr_stmt|;
block|}
specifier|__block
operator|->
name|_M_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
specifier|__block
operator|=
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|=
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|->
name|_M_next
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_if
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
specifier|__block
operator|->
name|_M_thread_id
operator|=
name|__thread_id
expr_stmt|;
operator|--
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
expr_stmt|;
operator|++
name|__bin
operator|.
name|_M_used
index|[
name|__thread_id
index|]
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|__c
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
specifier|__block
operator|)
operator|+
name|_S_options
operator|.
name|_M_align
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|static_cast
operator|<
name|_Tp
operator|*
operator|>
operator|(
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|__c
operator|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}      template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|deallocate
argument_list|(
argument|pointer __p
argument_list|,
argument|size_type __n
argument_list|)
block|{
comment|// Requests larger than _M_max_bytes are handled by operators
comment|// new/delete directly.
specifier|const
name|size_t
name|__bytes
operator|=
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
block|;
if|if
condition|(
name|__bytes
operator|>
name|_S_options
operator|.
name|_M_max_bytes
operator|||
name|_S_options
operator|.
name|_M_force_new
condition|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|__p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Round up to power of 2 and figure out which bin to use.
specifier|const
name|size_t
name|__which
operator|=
name|_S_binmap
index|[
name|__bytes
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|_Bin_record
modifier|&
name|__bin
init|=
name|_S_bin
index|[
name|__which
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__c
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|__p
operator|)
operator|-
name|_S_options
operator|.
name|_M_align
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Block_record
operator|*
specifier|__block
operator|=
name|reinterpret_cast
operator|<
name|_Block_record
operator|*
operator|>
operator|(
name|__c
operator|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_if
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
comment|// Calculate the number of records to remove from our freelist:
comment|// in order to avoid too much contention we wait until the
comment|// number of records is "high enough".
specifier|const
name|size_t
name|__thread_id
init|=
name|_S_get_thread_id
argument_list|()
decl_stmt|;
name|long
name|__remove
init|=
operator|(
operator|(
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|*
name|_S_options
operator|.
name|_M_freelist_headroom
operator|)
operator|-
name|__bin
operator|.
name|_M_used
index|[
name|__thread_id
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|__remove
operator|>
name|static_cast
operator|<
name|long
operator|>
operator|(
literal|100
operator|*
operator|(
name|_S_bin_size
operator|-
name|__which
operator|)
operator|*
name|_S_options
operator|.
name|_M_freelist_headroom
operator|)
operator|&&
name|__remove
operator|>
name|static_cast
operator|<
name|long
operator|>
operator|(
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|)
condition|)
block|{
name|_Block_record
modifier|*
name|__tmp
init|=
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
decl_stmt|;
name|_Block_record
modifier|*
name|__first
init|=
name|__tmp
decl_stmt|;
name|__remove
operator|/=
name|_S_options
operator|.
name|_M_freelist_headroom
expr_stmt|;
specifier|const
name|long
name|__removed
init|=
name|__remove
decl_stmt|;
operator|--
name|__remove
expr_stmt|;
while|while
condition|(
name|__remove
operator|--
operator|>
literal|0
condition|)
name|__tmp
operator|=
name|__tmp
operator|->
name|_M_next
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|=
name|__tmp
operator|->
name|_M_next
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
operator|-=
name|__removed
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
name|__tmp
operator|->
name|_M_next
operator|=
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
name|__first
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
literal|0
index|]
operator|+=
name|__removed
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
block|}
comment|// Return this block to our list and update counters and
comment|// owner id as needed.
operator|--
name|__bin
operator|.
name|_M_used
index|[
specifier|__block
operator|->
name|_M_thread_id
index|]
expr_stmt|;
specifier|__block
operator|->
name|_M_next
operator|=
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
name|__thread_id
index|]
operator|=
specifier|__block
expr_stmt|;
operator|++
name|__bin
operator|.
name|_M_free
index|[
name|__thread_id
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|// Single threaded application - return to global pool.
specifier|__block
operator|->
name|_M_next
operator|=
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
specifier|__block
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}      template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_initialize
argument_list|()
block|{
comment|// This method is called on the first allocation (when _S_init is still
comment|// false) to create the bins.
comment|// Ensure that the static initialization of _S_options has
comment|// happened.  This depends on (a) _M_align == 0 being an invalid
comment|// value that is only present at startup, and (b) the real
comment|// static initialization that happens later not actually
comment|// changing anything.
if|if
condition|(
name|_S_options
operator|.
name|_M_align
operator|==
literal|0
condition|)
name|new
argument_list|(
argument|&_S_options
argument_list|)
name|_Tune
expr_stmt|;
end_expr_stmt

begin_comment
comment|// _M_force_new must not change after the first allocate(),
end_comment

begin_comment
comment|// which in turn calls this method, so if it's false, it's false
end_comment

begin_comment
comment|// forever and we don't need to return here ever again.
end_comment

begin_if
if|if
condition|(
name|_S_options
operator|.
name|_M_force_new
condition|)
block|{
name|_S_init
operator|=
name|true
expr_stmt|;
return|return;
block|}
end_if

begin_comment
comment|// Calculate the number of bins required based on _M_max_bytes.
end_comment

begin_comment
comment|// _S_bin_size is statically-initialized to one.
end_comment

begin_decl_stmt
name|size_t
name|__bin_size
init|=
name|_S_options
operator|.
name|_M_min_bin
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|_S_options
operator|.
name|_M_max_bytes
operator|>
name|__bin_size
condition|)
block|{
name|__bin_size
operator|<<=
literal|1
expr_stmt|;
operator|++
name|_S_bin_size
expr_stmt|;
block|}
end_while

begin_comment
comment|// Setup the bin map for quick lookup of the relevant bin.
end_comment

begin_decl_stmt
specifier|const
name|size_t
name|__j
init|=
operator|(
name|_S_options
operator|.
name|_M_max_bytes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|_Binmap_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_S_binmap
operator|=
name|static_cast
operator|<
name|_Binmap_type
operator|*
operator|>
operator|(
operator|::
name|operator
name|new
argument_list|(
name|__j
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Binmap_type
modifier|*
name|__bp
init|=
name|_S_binmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Binmap_type
name|__bin_max
init|=
name|_S_options
operator|.
name|_M_min_bin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Binmap_type
name|__bint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|_Binmap_type
name|__ct
init|=
literal|0
init|;
name|__ct
operator|<=
name|_S_options
operator|.
name|_M_max_bytes
condition|;
operator|++
name|__ct
control|)
block|{
if|if
condition|(
name|__ct
operator|>
name|__bin_max
condition|)
block|{
name|__bin_max
operator|<<=
literal|1
expr_stmt|;
operator|++
name|__bint
expr_stmt|;
block|}
operator|*
name|__bp
operator|++
operator|=
name|__bint
expr_stmt|;
block|}
end_for

begin_comment
comment|// Initialize _S_bin and its members.
end_comment

begin_decl_stmt
name|void
modifier|*
name|__v
init|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|_Bin_record
argument_list|)
operator|*
name|_S_bin_size
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_S_bin
operator|=
name|static_cast
operator|<
name|_Bin_record
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If __gthread_active_p() create and initialize the list of
end_comment

begin_comment
comment|// free thread ids. Single threaded applications use thread id 0
end_comment

begin_comment
comment|// directly and have no need for this.
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_if
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
specifier|const
name|size_t
name|__k
init|=
sizeof|sizeof
argument_list|(
name|_Thread_record
argument_list|)
operator|*
name|_S_options
operator|.
name|_M_max_threads
decl_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
name|__k
argument_list|)
expr_stmt|;
name|_S_thread_freelist_first
operator|=
name|static_cast
operator|<
name|_Thread_record
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
comment|// NOTE! The first assignable thread id is 1 since the
comment|// global pool uses id 0
name|size_t
name|__i
decl_stmt|;
for|for
control|(
name|__i
operator|=
literal|1
init|;
name|__i
operator|<
name|_S_options
operator|.
name|_M_max_threads
condition|;
operator|++
name|__i
control|)
block|{
name|_Thread_record
modifier|&
name|__tr
init|=
name|_S_thread_freelist_first
index|[
name|__i
operator|-
literal|1
index|]
decl_stmt|;
name|__tr
operator|.
name|_M_next
operator|=
operator|&
name|_S_thread_freelist_first
index|[
name|__i
index|]
expr_stmt|;
name|__tr
operator|.
name|_M_id
operator|=
name|__i
expr_stmt|;
block|}
comment|// Set last record.
name|_S_thread_freelist_first
index|[
name|__i
operator|-
literal|1
index|]
operator|.
name|_M_next
operator|=
name|NULL
expr_stmt|;
name|_S_thread_freelist_first
index|[
name|__i
operator|-
literal|1
index|]
operator|.
name|_M_id
operator|=
name|__i
expr_stmt|;
comment|// Make sure this is initialized.
ifndef|#
directive|ifndef
name|__GTHREAD_MUTEX_INIT
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|_S_thread_freelist_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Initialize per thread key to hold pointer to
comment|// _S_thread_freelist.
name|__gthread_key_create
argument_list|(
operator|&
name|_S_thread_key
argument_list|,
name|_S_destroy_thread_key
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|__max_threads
init|=
name|_S_options
operator|.
name|_M_max_threads
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|size_t
name|__n
init|=
literal|0
init|;
name|__n
operator|<
name|_S_bin_size
condition|;
operator|++
name|__n
control|)
block|{
name|_Bin_record
modifier|&
name|__bin
init|=
name|_S_bin
index|[
name|__n
index|]
decl_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|_Block_record
operator|*
argument_list|)
operator|*
name|__max_threads
argument_list|)
expr_stmt|;
name|__bin
operator|.
name|_M_first
operator|=
name|static_cast
operator|<
name|_Block_record
operator|*
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|__max_threads
argument_list|)
expr_stmt|;
name|__bin
operator|.
name|_M_free
operator|=
name|static_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|__max_threads
argument_list|)
expr_stmt|;
name|__bin
operator|.
name|_M_used
operator|=
name|static_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|__gthread_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
name|__bin
operator|.
name|_M_mutex
operator|=
name|static_cast
operator|<
name|__gthread_mutex_t
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT
block|{
comment|// Do not copy a POSIX/gthr mutex once in use.
name|__gthread_mutex_t
name|__tmp
init|=
name|__GTHREAD_MUTEX_INIT
decl_stmt|;
operator|*
name|__bin
operator|.
name|_M_mutex
operator|=
name|__tmp
expr_stmt|;
block|}
else|#
directive|else
block|{
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
name|__bin
operator|.
name|_M_mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|size_t
name|__threadn
init|=
literal|0
init|;
name|__threadn
operator|<
name|__max_threads
condition|;
operator|++
name|__threadn
control|)
block|{
name|__bin
operator|.
name|_M_first
index|[
name|__threadn
index|]
operator|=
name|NULL
expr_stmt|;
name|__bin
operator|.
name|_M_free
index|[
name|__threadn
index|]
operator|=
literal|0
expr_stmt|;
name|__bin
operator|.
name|_M_used
index|[
name|__threadn
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
name|size_t
name|__n
init|=
literal|0
init|;
name|__n
operator|<
name|_S_bin_size
condition|;
operator|++
name|__n
control|)
block|{
name|_Bin_record
modifier|&
name|__bin
init|=
name|_S_bin
index|[
name|__n
index|]
decl_stmt|;
name|__v
operator|=
operator|::
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|_Block_record
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|__bin
operator|.
name|_M_first
operator|=
name|static_cast
operator|<
name|_Block_record
operator|*
operator|*
operator|>
operator|(
name|__v
operator|)
expr_stmt|;
name|__bin
operator|.
name|_M_first
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|_S_init
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_Tp
operator|>
name|size_t
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_get_thread_id
argument_list|()
block|{
ifdef|#
directive|ifdef
name|__GTHREADS
comment|// If we have thread support and it's active we check the thread
comment|// key value and return its id or if it's not set we take the
comment|// first record from _S_thread_freelist and sets the key and
comment|// returns it's id.
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
name|_Thread_record
modifier|*
name|__freelist_pos
init|=
name|static_cast
operator|<
name|_Thread_record
operator|*
operator|>
operator|(
name|__gthread_getspecific
argument_list|(
name|_S_thread_key
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|__freelist_pos
operator|==
name|NULL
condition|)
block|{
comment|// Since _S_options._M_max_threads must be larger than
comment|// the theoretical max number of threads of the OS the
comment|// list can never be empty.
name|__gthread_mutex_lock
argument_list|(
operator|&
name|_S_thread_freelist_mutex
argument_list|)
expr_stmt|;
name|__freelist_pos
operator|=
name|_S_thread_freelist_first
expr_stmt|;
name|_S_thread_freelist_first
operator|=
name|_S_thread_freelist_first
operator|->
name|_M_next
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|_S_thread_freelist_mutex
argument_list|)
expr_stmt|;
name|__gthread_setspecific
argument_list|(
name|_S_thread_key
argument_list|,
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|__freelist_pos
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__freelist_pos
operator|->
name|_M_id
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// Otherwise (no thread support or inactive) all requests are
end_comment

begin_comment
comment|// served from the global pool 0.
end_comment

begin_expr_stmt
unit|return
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_destroy_thread_key
argument_list|(
argument|void* __freelist_pos
argument_list|)
block|{
comment|// Return this thread id record to front of thread_freelist.
name|__gthread_mutex_lock
argument_list|(
operator|&
name|_S_thread_freelist_mutex
argument_list|)
block|;
name|_Thread_record
operator|*
name|__tr
operator|=
name|static_cast
operator|<
name|_Thread_record
operator|*
operator|>
operator|(
name|__freelist_pos
operator|)
block|;
name|__tr
operator|->
name|_M_next
operator|=
name|_S_thread_freelist_first
block|;
name|_S_thread_freelist_first
operator|=
name|__tr
block|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|_S_thread_freelist_mutex
argument_list|)
block|;     }
endif|#
directive|endif
name|template
operator|<
name|typename
name|_Tp
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|&
operator|,
specifier|const
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|&
operator|,
specifier|const
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|bool
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_init
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_Tune
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_options
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_Binmap_type
operator|*
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_binmap
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_Bin_record
operator|*
specifier|volatile
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_bin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|size_t
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_bin_size
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Actual initialization in _S_initialize().
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gthread_once_t
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_once
operator|=
name|__GTHREAD_ONCE_INIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_Thread_record
operator|*
specifier|volatile
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_thread_freelist_first
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gthread_key_t
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_thread_key
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gthread_mutex_t
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_thread_freelist_mutex
operator|=
name|__GTHREAD_MUTEX_INIT
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|__mt_alloc
operator|<
name|_Tp
operator|>
operator|::
name|_S_thread_freelist_mutex
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|// namespace __gnu_cxx
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

