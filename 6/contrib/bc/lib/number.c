begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* number.c: Implements arbitrary precision numbers. */
end_comment

begin_comment
comment|/*     Copyright (C) 1991, 1992, 1993, 1994, 1997, 2000 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to:        The Free Software Foundation, Inc.       59 Temple Place, Suite 330       Boston, MA 02111-1307 USA.       You may contact the author by:        e-mail:  philnelson@acm.org       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062         *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<number.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Prototypes needed for external utility routines. */
end_comment

begin_define
define|#
directive|define
name|bc_rt_warn
value|rt_warn
end_define

begin_define
define|#
directive|define
name|bc_rt_error
value|rt_error
end_define

begin_define
define|#
directive|define
name|bc_out_of_memory
value|out_of_memory
end_define

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void rt_warn
argument_list|,
argument|(char *mesg ,...)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void rt_error
argument_list|,
argument|(char *mesg ,...)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void out_of_memory
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Storage used for special numbers. */
end_comment

begin_decl_stmt
name|bc_num
name|_zero_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bc_num
name|_one_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bc_num
name|_two_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bc_num
name|_bc_Free_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new_num allocates a number and sets fields to known values. */
end_comment

begin_function
name|bc_num
name|bc_new_num
parameter_list|(
name|length
parameter_list|,
name|scale
parameter_list|)
name|int
name|length
decl_stmt|,
name|scale
decl_stmt|;
block|{
name|bc_num
name|temp
decl_stmt|;
if|if
condition|(
name|_bc_Free_list
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|=
name|_bc_Free_list
expr_stmt|;
name|_bc_Free_list
operator|=
name|temp
operator|->
name|n_next
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|bc_num
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
block|}
name|temp
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|temp
operator|->
name|n_len
operator|=
name|length
expr_stmt|;
name|temp
operator|->
name|n_scale
operator|=
name|scale
expr_stmt|;
name|temp
operator|->
name|n_refs
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|n_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|length
operator|+
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|n_ptr
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
name|temp
operator|->
name|n_value
operator|=
name|temp
operator|->
name|n_ptr
expr_stmt|;
name|memset
argument_list|(
name|temp
operator|->
name|n_ptr
argument_list|,
literal|0
argument_list|,
name|length
operator|+
name|scale
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* "Frees" a bc_num NUM.  Actually decreases reference count and only    frees the storage if reference count is zero. */
end_comment

begin_function
name|void
name|bc_free_num
parameter_list|(
name|num
parameter_list|)
name|bc_num
modifier|*
name|num
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|num
operator|==
name|NULL
condition|)
return|return;
operator|(
operator|*
name|num
operator|)
operator|->
name|n_refs
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|num
operator|)
operator|->
name|n_refs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|num
operator|)
operator|->
name|n_ptr
condition|)
name|free
argument_list|(
operator|(
operator|*
name|num
operator|)
operator|->
name|n_ptr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num
operator|)
operator|->
name|n_next
operator|=
name|_bc_Free_list
expr_stmt|;
name|_bc_Free_list
operator|=
operator|*
name|num
expr_stmt|;
block|}
operator|*
name|num
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Intitialize the number package! */
end_comment

begin_function
name|void
name|bc_init_numbers
parameter_list|()
block|{
name|_zero_
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_one_
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_one_
operator|->
name|n_value
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|_two_
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_two_
operator|->
name|n_value
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a copy of a number!  Just increments the reference count! */
end_comment

begin_function
name|bc_num
name|bc_copy_num
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|num
operator|->
name|n_refs
operator|++
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Initialize a number NUM by making it a copy of zero. */
end_comment

begin_function
name|void
name|bc_init_num
parameter_list|(
name|num
parameter_list|)
name|bc_num
modifier|*
name|num
decl_stmt|;
block|{
operator|*
name|num
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For many things, we may have leading zeros in a number NUM.    _bc_rm_leading_zeros just moves the data "value" pointer to the    correct place and adjusts the length. */
end_comment

begin_function
specifier|static
name|void
name|_bc_rm_leading_zeros
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
comment|/* We can move n_value to point to the first non zero digit! */
while|while
condition|(
operator|*
name|num
operator|->
name|n_value
operator|==
literal|0
operator|&&
name|num
operator|->
name|n_len
operator|>
literal|1
condition|)
block|{
name|num
operator|->
name|n_value
operator|++
expr_stmt|;
name|num
operator|->
name|n_len
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two bc numbers.  Return value is 0 if equal, -1 if N1 is less    than N2 and +1 if N1 is greater than N2.  If USE_SIGN is false, just    compare the magnitudes. */
end_comment

begin_function
specifier|static
name|int
name|_bc_do_compare
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|use_sign
parameter_list|,
name|ignore_last
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|int
name|use_sign
decl_stmt|;
name|int
name|ignore_last
decl_stmt|;
block|{
name|char
modifier|*
name|n1ptr
decl_stmt|,
modifier|*
name|n2ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* First, compare signs. */
if|if
condition|(
name|use_sign
operator|&&
name|n1
operator|->
name|n_sign
operator|!=
name|n2
operator|->
name|n_sign
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Positive N1> Negative N2 */
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Negative N1< Positive N1 */
block|}
comment|/* Now compare the magnitude. */
if|if
condition|(
name|n1
operator|->
name|n_len
operator|!=
name|n2
operator|->
name|n_len
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|n_len
operator|>
name|n2
operator|->
name|n_len
condition|)
block|{
comment|/* Magnitude of n1> n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Magnitude of n1< n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* If we get here, they have the same number of integer digits.      check the integer part and the equal length part of the fraction. */
name|count
operator|=
name|n1
operator|->
name|n_len
operator|+
name|MIN
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|n1ptr
operator|=
name|n1
operator|->
name|n_value
expr_stmt|;
name|n2ptr
operator|=
name|n2
operator|->
name|n_value
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|n1ptr
operator|==
operator|*
name|n2ptr
operator|)
condition|)
block|{
name|n1ptr
operator|++
expr_stmt|;
name|n2ptr
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ignore_last
operator|&&
name|count
operator|==
literal|1
operator|&&
name|n1
operator|->
name|n_scale
operator|==
name|n2
operator|->
name|n_scale
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|n1ptr
operator|>
operator|*
name|n2ptr
condition|)
block|{
comment|/* Magnitude of n1> n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Magnitude of n1< n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* They are equal up to the last part of the equal part of the fraction. */
if|if
condition|(
name|n1
operator|->
name|n_scale
operator|!=
name|n2
operator|->
name|n_scale
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|n_scale
operator|>
name|n2
operator|->
name|n_scale
condition|)
block|{
for|for
control|(
name|count
operator|=
name|n1
operator|->
name|n_scale
operator|-
name|n2
operator|->
name|n_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
if|if
condition|(
operator|*
name|n1ptr
operator|++
operator|!=
literal|0
condition|)
block|{
comment|/* Magnitude of n1> n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|count
operator|=
name|n2
operator|->
name|n_scale
operator|-
name|n1
operator|->
name|n_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
if|if
condition|(
operator|*
name|n2ptr
operator|++
operator|!=
literal|0
condition|)
block|{
comment|/* Magnitude of n1< n2. */
if|if
condition|(
operator|!
name|use_sign
operator|||
name|n1
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* They must be equal! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the "user callable" routine to compare numbers N1 and N2. */
end_comment

begin_function
name|int
name|bc_compare
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|;
block|{
return|return
name|_bc_do_compare
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* In some places we need to check if the number is negative. */
end_comment

begin_function
name|char
name|bc_is_neg
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
return|return
name|num
operator|->
name|n_sign
operator|==
name|MINUS
return|;
block|}
end_function

begin_comment
comment|/* In some places we need to check if the number NUM is zero. */
end_comment

begin_function
name|char
name|bc_is_zero
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
comment|/* Quick check. */
if|if
condition|(
name|num
operator|==
name|_zero_
condition|)
return|return
name|TRUE
return|;
comment|/* Initialize */
name|count
operator|=
name|num
operator|->
name|n_len
operator|+
name|num
operator|->
name|n_scale
expr_stmt|;
name|nptr
operator|=
name|num
operator|->
name|n_value
expr_stmt|;
comment|/* The check */
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|nptr
operator|++
operator|==
literal|0
operator|)
condition|)
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* In some places we need to check if the number NUM is almost zero.    Specifically, all but the last digit is 0 and the last digit is 1.    Last digit is defined by scale. */
end_comment

begin_function
name|char
name|bc_is_near_zero
parameter_list|(
name|num
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|num
decl_stmt|;
name|int
name|scale
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
comment|/* Error checking */
if|if
condition|(
name|scale
operator|>
name|num
operator|->
name|n_scale
condition|)
name|scale
operator|=
name|num
operator|->
name|n_scale
expr_stmt|;
comment|/* Initialize */
name|count
operator|=
name|num
operator|->
name|n_len
operator|+
name|scale
expr_stmt|;
name|nptr
operator|=
name|num
operator|->
name|n_value
expr_stmt|;
comment|/* The check */
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|nptr
operator|++
operator|==
literal|0
operator|)
condition|)
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|!=
literal|1
operator|||
operator|*
operator|--
name|nptr
operator|!=
literal|1
operator|)
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform addition: N1 is added to N2 and the value is    returned.  The signs of N1 and N2 are ignored.    SCALE_MIN is to set the minimum scale of the result. */
end_comment

begin_function
specifier|static
name|bc_num
name|_bc_do_add
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|scale_min
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|int
name|scale_min
decl_stmt|;
block|{
name|bc_num
name|sum
decl_stmt|;
name|int
name|sum_scale
decl_stmt|,
name|sum_digits
decl_stmt|;
name|char
modifier|*
name|n1ptr
decl_stmt|,
modifier|*
name|n2ptr
decl_stmt|,
modifier|*
name|sumptr
decl_stmt|;
name|int
name|carry
decl_stmt|,
name|n1bytes
decl_stmt|,
name|n2bytes
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Prepare sum. */
name|sum_scale
operator|=
name|MAX
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|sum_digits
operator|=
name|MAX
argument_list|(
name|n1
operator|->
name|n_len
argument_list|,
name|n2
operator|->
name|n_len
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sum
operator|=
name|bc_new_num
argument_list|(
name|sum_digits
argument_list|,
name|MAX
argument_list|(
name|sum_scale
argument_list|,
name|scale_min
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero extra digits made by scale_min. */
if|if
condition|(
name|scale_min
operator|>
name|sum_scale
condition|)
block|{
name|sumptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sum
operator|->
name|n_value
operator|+
name|sum_scale
operator|+
name|sum_digits
operator|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|scale_min
operator|-
name|sum_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|sumptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start with the fraction part.  Initialize the pointers. */
name|n1bytes
operator|=
name|n1
operator|->
name|n_scale
expr_stmt|;
name|n2bytes
operator|=
name|n2
operator|->
name|n_scale
expr_stmt|;
name|n1ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n1
operator|->
name|n_value
operator|+
name|n1
operator|->
name|n_len
operator|+
name|n1bytes
operator|-
literal|1
operator|)
expr_stmt|;
name|n2ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n2
operator|->
name|n_value
operator|+
name|n2
operator|->
name|n_len
operator|+
name|n2bytes
operator|-
literal|1
operator|)
expr_stmt|;
name|sumptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sum
operator|->
name|n_value
operator|+
name|sum_scale
operator|+
name|sum_digits
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Add the fraction part.  First copy the longer fraction.*/
if|if
condition|(
name|n1bytes
operator|!=
name|n2bytes
condition|)
block|{
if|if
condition|(
name|n1bytes
operator|>
name|n2bytes
condition|)
while|while
condition|(
name|n1bytes
operator|>
name|n2bytes
condition|)
block|{
operator|*
name|sumptr
operator|--
operator|=
operator|*
name|n1ptr
operator|--
expr_stmt|;
name|n1bytes
operator|--
expr_stmt|;
block|}
else|else
while|while
condition|(
name|n2bytes
operator|>
name|n1bytes
condition|)
block|{
operator|*
name|sumptr
operator|--
operator|=
operator|*
name|n2ptr
operator|--
expr_stmt|;
name|n2bytes
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now add the remaining fraction part and equal size integer parts. */
name|n1bytes
operator|+=
name|n1
operator|->
name|n_len
expr_stmt|;
name|n2bytes
operator|+=
name|n2
operator|->
name|n_len
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n1bytes
operator|>
literal|0
operator|)
operator|&&
operator|(
name|n2bytes
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|sumptr
operator|=
operator|*
name|n1ptr
operator|--
operator|+
operator|*
name|n2ptr
operator|--
operator|+
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|sumptr
operator|>
operator|(
name|BASE
operator|-
literal|1
operator|)
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
operator|*
name|sumptr
operator|-=
name|BASE
expr_stmt|;
block|}
else|else
name|carry
operator|=
literal|0
expr_stmt|;
name|sumptr
operator|--
expr_stmt|;
name|n1bytes
operator|--
expr_stmt|;
name|n2bytes
operator|--
expr_stmt|;
block|}
comment|/* Now add carry the longer integer part. */
if|if
condition|(
name|n1bytes
operator|==
literal|0
condition|)
block|{
name|n1bytes
operator|=
name|n2bytes
expr_stmt|;
name|n1ptr
operator|=
name|n2ptr
expr_stmt|;
block|}
while|while
condition|(
name|n1bytes
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|sumptr
operator|=
operator|*
name|n1ptr
operator|--
operator|+
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|sumptr
operator|>
operator|(
name|BASE
operator|-
literal|1
operator|)
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
operator|*
name|sumptr
operator|-=
name|BASE
expr_stmt|;
block|}
else|else
name|carry
operator|=
literal|0
expr_stmt|;
name|sumptr
operator|--
expr_stmt|;
block|}
comment|/* Set final carry. */
if|if
condition|(
name|carry
operator|==
literal|1
condition|)
operator|*
name|sumptr
operator|+=
literal|1
expr_stmt|;
comment|/* Adjust sum and return. */
name|_bc_rm_leading_zeros
argument_list|(
name|sum
argument_list|)
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* Perform subtraction: N2 is subtracted from N1 and the value is    returned.  The signs of N1 and N2 are ignored.  Also, N1 is    assumed to be larger than N2.  SCALE_MIN is the minimum scale    of the result. */
end_comment

begin_function
specifier|static
name|bc_num
name|_bc_do_sub
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|scale_min
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|int
name|scale_min
decl_stmt|;
block|{
name|bc_num
name|diff
decl_stmt|;
name|int
name|diff_scale
decl_stmt|,
name|diff_len
decl_stmt|;
name|int
name|min_scale
decl_stmt|,
name|min_len
decl_stmt|;
name|char
modifier|*
name|n1ptr
decl_stmt|,
modifier|*
name|n2ptr
decl_stmt|,
modifier|*
name|diffptr
decl_stmt|;
name|int
name|borrow
decl_stmt|,
name|count
decl_stmt|,
name|val
decl_stmt|;
comment|/* Allocate temporary storage. */
name|diff_len
operator|=
name|MAX
argument_list|(
name|n1
operator|->
name|n_len
argument_list|,
name|n2
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|diff_scale
operator|=
name|MAX
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|min_len
operator|=
name|MIN
argument_list|(
name|n1
operator|->
name|n_len
argument_list|,
name|n2
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|min_scale
operator|=
name|MIN
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|diff
operator|=
name|bc_new_num
argument_list|(
name|diff_len
argument_list|,
name|MAX
argument_list|(
name|diff_scale
argument_list|,
name|scale_min
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero extra digits made by scale_min. */
if|if
condition|(
name|scale_min
operator|>
name|diff_scale
condition|)
block|{
name|diffptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|diff
operator|->
name|n_value
operator|+
name|diff_len
operator|+
name|diff_scale
operator|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|scale_min
operator|-
name|diff_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|diffptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize the subtract. */
name|n1ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n1
operator|->
name|n_value
operator|+
name|n1
operator|->
name|n_len
operator|+
name|n1
operator|->
name|n_scale
operator|-
literal|1
operator|)
expr_stmt|;
name|n2ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n2
operator|->
name|n_value
operator|+
name|n2
operator|->
name|n_len
operator|+
name|n2
operator|->
name|n_scale
operator|-
literal|1
operator|)
expr_stmt|;
name|diffptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|diff
operator|->
name|n_value
operator|+
name|diff_len
operator|+
name|diff_scale
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Subtract the numbers. */
name|borrow
operator|=
literal|0
expr_stmt|;
comment|/* Take care of the longer scaled number. */
if|if
condition|(
name|n1
operator|->
name|n_scale
operator|!=
name|min_scale
condition|)
block|{
comment|/* n1 has the longer scale */
for|for
control|(
name|count
operator|=
name|n1
operator|->
name|n_scale
operator|-
name|min_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|diffptr
operator|--
operator|=
operator|*
name|n1ptr
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* n2 has the longer scale */
for|for
control|(
name|count
operator|=
name|n2
operator|->
name|n_scale
operator|-
name|min_scale
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|val
operator|=
operator|-
operator|*
name|n2ptr
operator|--
operator|-
name|borrow
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|+=
name|BASE
expr_stmt|;
name|borrow
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|borrow
operator|=
literal|0
expr_stmt|;
operator|*
name|diffptr
operator|--
operator|=
name|val
expr_stmt|;
block|}
block|}
comment|/* Now do the equal length scale and integer parts. */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|min_len
operator|+
name|min_scale
condition|;
name|count
operator|++
control|)
block|{
name|val
operator|=
operator|*
name|n1ptr
operator|--
operator|-
operator|*
name|n2ptr
operator|--
operator|-
name|borrow
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|+=
name|BASE
expr_stmt|;
name|borrow
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|borrow
operator|=
literal|0
expr_stmt|;
operator|*
name|diffptr
operator|--
operator|=
name|val
expr_stmt|;
block|}
comment|/* If n1 has more digits then n2, we now do that subtract. */
if|if
condition|(
name|diff_len
operator|!=
name|min_len
condition|)
block|{
for|for
control|(
name|count
operator|=
name|diff_len
operator|-
name|min_len
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|val
operator|=
operator|*
name|n1ptr
operator|--
operator|-
name|borrow
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|+=
name|BASE
expr_stmt|;
name|borrow
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|borrow
operator|=
literal|0
expr_stmt|;
operator|*
name|diffptr
operator|--
operator|=
name|val
expr_stmt|;
block|}
block|}
comment|/* Clean up and return. */
name|_bc_rm_leading_zeros
argument_list|(
name|diff
argument_list|)
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Here is the full subtract routine that takes care of negative numbers.    N2 is subtracted from N1 and the result placed in RESULT.  SCALE_MIN    is the minimum scale for the result. */
end_comment

begin_function
name|void
name|bc_sub
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|result
parameter_list|,
name|scale_min
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|,
decl|*
name|result
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale_min
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|diff
init|=
name|NULL
decl_stmt|;
name|int
name|cmp_res
decl_stmt|;
name|int
name|res_scale
decl_stmt|;
if|if
condition|(
name|n1
operator|->
name|n_sign
operator|!=
name|n2
operator|->
name|n_sign
condition|)
block|{
name|diff
operator|=
name|_bc_do_add
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|diff
operator|->
name|n_sign
operator|=
name|n1
operator|->
name|n_sign
expr_stmt|;
block|}
else|else
block|{
comment|/* subtraction must be done. */
comment|/* Compare magnitudes. */
name|cmp_res
operator|=
name|_bc_do_compare
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmp_res
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* n1 is less than n2, subtract n1 from n2. */
name|diff
operator|=
name|_bc_do_sub
argument_list|(
name|n2
argument_list|,
name|n1
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|diff
operator|->
name|n_sign
operator|=
operator|(
name|n2
operator|->
name|n_sign
operator|==
name|PLUS
condition|?
name|MINUS
else|:
name|PLUS
operator|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* They are equal! return zero! */
name|res_scale
operator|=
name|MAX
argument_list|(
name|scale_min
argument_list|,
name|MAX
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
name|res_scale
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diff
operator|->
name|n_value
argument_list|,
literal|0
argument_list|,
name|res_scale
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* n2 is less than n1, subtract n2 from n1. */
name|diff
operator|=
name|_bc_do_sub
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|diff
operator|->
name|n_sign
operator|=
name|n1
operator|->
name|n_sign
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clean up and return. */
name|bc_free_num
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|diff
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Here is the full add routine that takes care of negative numbers.    N1 is added to N2 and the result placed into RESULT.  SCALE_MIN    is the minimum scale for the result. */
end_comment

begin_function
name|void
name|bc_add
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|result
parameter_list|,
name|scale_min
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|,
decl|*
name|result
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale_min
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|sum
init|=
name|NULL
decl_stmt|;
name|int
name|cmp_res
decl_stmt|;
name|int
name|res_scale
decl_stmt|;
if|if
condition|(
name|n1
operator|->
name|n_sign
operator|==
name|n2
operator|->
name|n_sign
condition|)
block|{
name|sum
operator|=
name|_bc_do_add
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|sum
operator|->
name|n_sign
operator|=
name|n1
operator|->
name|n_sign
expr_stmt|;
block|}
else|else
block|{
comment|/* subtraction must be done. */
name|cmp_res
operator|=
name|_bc_do_compare
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Compare magnitudes. */
switch|switch
condition|(
name|cmp_res
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* n1 is less than n2, subtract n1 from n2. */
name|sum
operator|=
name|_bc_do_sub
argument_list|(
name|n2
argument_list|,
name|n1
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|sum
operator|->
name|n_sign
operator|=
name|n2
operator|->
name|n_sign
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* They are equal! return zero with the correct scale! */
name|res_scale
operator|=
name|MAX
argument_list|(
name|scale_min
argument_list|,
name|MAX
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
argument_list|)
expr_stmt|;
name|sum
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
name|res_scale
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sum
operator|->
name|n_value
argument_list|,
literal|0
argument_list|,
name|res_scale
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* n2 is less than n1, subtract n2 from n1. */
name|sum
operator|=
name|_bc_do_sub
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
name|scale_min
argument_list|)
expr_stmt|;
name|sum
operator|->
name|n_sign
operator|=
name|n1
operator|->
name|n_sign
expr_stmt|;
block|}
block|}
comment|/* Clean up and return. */
name|bc_free_num
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|sum
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Recursive vs non-recursive multiply crossover ranges. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MULDIGITS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"muldigits.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MUL_BASE_DIGITS
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|mul_base_digits
init|=
name|MUL_BASE_DIGITS
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MUL_SMALL_DIGITS
value|mul_base_digits/4
end_define

begin_comment
comment|/* Multiply utility routines */
end_comment

begin_function
specifier|static
name|bc_num
name|new_sub_num
parameter_list|(
name|length
parameter_list|,
name|scale
parameter_list|,
name|value
parameter_list|)
name|int
name|length
decl_stmt|,
name|scale
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|bc_num
name|temp
decl_stmt|;
if|if
condition|(
name|_bc_Free_list
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|=
name|_bc_Free_list
expr_stmt|;
name|_bc_Free_list
operator|=
name|temp
operator|->
name|n_next
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|bc_num
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
block|}
name|temp
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|temp
operator|->
name|n_len
operator|=
name|length
expr_stmt|;
name|temp
operator|->
name|n_scale
operator|=
name|scale
expr_stmt|;
name|temp
operator|->
name|n_refs
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|n_ptr
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|n_value
operator|=
name|value
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bc_simp_mul
parameter_list|(
name|bc_num
name|n1
parameter_list|,
name|int
name|n1len
parameter_list|,
name|bc_num
name|n2
parameter_list|,
name|int
name|n2len
parameter_list|,
name|bc_num
modifier|*
name|prod
parameter_list|,
name|int
name|full_scale
parameter_list|)
block|{
name|char
modifier|*
name|n1ptr
decl_stmt|,
modifier|*
name|n2ptr
decl_stmt|,
modifier|*
name|pvptr
decl_stmt|;
name|char
modifier|*
name|n1end
decl_stmt|,
modifier|*
name|n2end
decl_stmt|;
comment|/* To the end of n1 and n2. */
name|int
name|indx
decl_stmt|,
name|sum
decl_stmt|,
name|prodlen
decl_stmt|;
name|prodlen
operator|=
name|n1len
operator|+
name|n2len
operator|+
literal|1
expr_stmt|;
operator|*
name|prod
operator|=
name|bc_new_num
argument_list|(
name|prodlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n1end
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n1
operator|->
name|n_value
operator|+
name|n1len
operator|-
literal|1
operator|)
expr_stmt|;
name|n2end
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n2
operator|->
name|n_value
operator|+
name|n2len
operator|-
literal|1
operator|)
expr_stmt|;
name|pvptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|prod
operator|)
operator|->
name|n_value
operator|+
name|prodlen
operator|-
literal|1
operator|)
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* Here is the loop... */
for|for
control|(
name|indx
operator|=
literal|0
init|;
name|indx
operator|<
name|prodlen
operator|-
literal|1
condition|;
name|indx
operator|++
control|)
block|{
name|n1ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n1end
operator|-
name|MAX
argument_list|(
literal|0
argument_list|,
name|indx
operator|-
name|n2len
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|n2ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|n2end
operator|-
name|MIN
argument_list|(
name|indx
argument_list|,
name|n2len
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|n1ptr
operator|>=
name|n1
operator|->
name|n_value
operator|)
operator|&&
operator|(
name|n2ptr
operator|<=
name|n2end
operator|)
condition|)
name|sum
operator|+=
operator|*
name|n1ptr
operator|--
operator|*
operator|*
name|n2ptr
operator|++
expr_stmt|;
operator|*
name|pvptr
operator|--
operator|=
name|sum
operator|%
name|BASE
expr_stmt|;
name|sum
operator|=
name|sum
operator|/
name|BASE
expr_stmt|;
block|}
operator|*
name|pvptr
operator|=
name|sum
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A special adder/subtractor for the recursive divide and conquer    multiply algorithm.  Note: if sub is called, accum must    be larger that what is being subtracted.  Also, accum and val    must have n_scale = 0.  (e.g. they must look like integers. *) */
end_comment

begin_function
specifier|static
name|void
name|_bc_shift_addsub
parameter_list|(
name|bc_num
name|accum
parameter_list|,
name|bc_num
name|val
parameter_list|,
name|int
name|shift
parameter_list|,
name|int
name|sub
parameter_list|)
block|{
name|signed
name|char
modifier|*
name|accp
decl_stmt|,
modifier|*
name|valp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|carry
decl_stmt|;
name|count
operator|=
name|val
operator|->
name|n_len
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|n_value
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|count
operator|--
expr_stmt|;
name|assert
argument_list|(
name|accum
operator|->
name|n_len
operator|+
name|accum
operator|->
name|n_scale
operator|>=
name|shift
operator|+
name|count
argument_list|)
expr_stmt|;
comment|/* Set up pointers and others */
name|accp
operator|=
operator|(
name|signed
name|char
operator|*
operator|)
operator|(
name|accum
operator|->
name|n_value
operator|+
name|accum
operator|->
name|n_len
operator|+
name|accum
operator|->
name|n_scale
operator|-
name|shift
operator|-
literal|1
operator|)
expr_stmt|;
name|valp
operator|=
operator|(
name|signed
name|char
operator|*
operator|)
operator|(
name|val
operator|->
name|n_value
operator|+
name|val
operator|->
name|n_len
operator|-
literal|1
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sub
condition|)
block|{
comment|/* Subtraction, carry is really borrow. */
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
name|accp
operator|-=
operator|*
name|valp
operator|--
operator|+
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|accp
operator|<
literal|0
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
operator|*
name|accp
operator|--
operator|+=
name|BASE
expr_stmt|;
block|}
else|else
block|{
name|carry
operator|=
literal|0
expr_stmt|;
name|accp
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|carry
condition|)
block|{
operator|*
name|accp
operator|-=
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|accp
operator|<
literal|0
condition|)
operator|*
name|accp
operator|--
operator|+=
name|BASE
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Addition */
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
name|accp
operator|+=
operator|*
name|valp
operator|--
operator|+
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|accp
operator|>
operator|(
name|BASE
operator|-
literal|1
operator|)
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
operator|*
name|accp
operator|--
operator|-=
name|BASE
expr_stmt|;
block|}
else|else
block|{
name|carry
operator|=
literal|0
expr_stmt|;
name|accp
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|carry
condition|)
block|{
operator|*
name|accp
operator|+=
name|carry
expr_stmt|;
if|if
condition|(
operator|*
name|accp
operator|>
operator|(
name|BASE
operator|-
literal|1
operator|)
condition|)
operator|*
name|accp
operator|--
operator|-=
name|BASE
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Recursive divide and conquer multiply algorithm.      Based on     Let u = u0 + u1*(b^n)    Let v = v0 + v1*(b^n)    Then uv = (B^2n+B^n)*u1*v1 + B^n*(u1-u0)*(v0-v1) + (B^n+1)*u0*v0     B is the base of storage, number of digits in u1,u0 close to equal. */
end_comment

begin_function
specifier|static
name|void
name|_bc_rec_mul
parameter_list|(
name|bc_num
name|u
parameter_list|,
name|int
name|ulen
parameter_list|,
name|bc_num
name|v
parameter_list|,
name|int
name|vlen
parameter_list|,
name|bc_num
modifier|*
name|prod
parameter_list|,
name|int
name|full_scale
parameter_list|)
block|{
name|bc_num
name|u0
decl_stmt|,
name|u1
decl_stmt|,
name|v0
decl_stmt|,
name|v1
decl_stmt|;
name|int
name|u0len
decl_stmt|,
name|v0len
decl_stmt|;
name|bc_num
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|int
name|n
decl_stmt|,
name|prodlen
decl_stmt|,
name|m1zero
decl_stmt|;
name|int
name|d1len
decl_stmt|,
name|d2len
decl_stmt|;
comment|/* Base case? */
if|if
condition|(
operator|(
name|ulen
operator|+
name|vlen
operator|)
operator|<
name|mul_base_digits
operator|||
name|ulen
operator|<
name|MUL_SMALL_DIGITS
operator|||
name|vlen
operator|<
name|MUL_SMALL_DIGITS
condition|)
block|{
name|_bc_simp_mul
argument_list|(
name|u
argument_list|,
name|ulen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|,
name|prod
argument_list|,
name|full_scale
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Calculate n -- the u and v split point in digits. */
name|n
operator|=
operator|(
name|MAX
argument_list|(
name|ulen
argument_list|,
name|vlen
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Split u and v. */
if|if
condition|(
name|ulen
operator|<
name|n
condition|)
block|{
name|u1
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|u0
operator|=
name|new_sub_num
argument_list|(
name|ulen
argument_list|,
literal|0
argument_list|,
name|u
operator|->
name|n_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u1
operator|=
name|new_sub_num
argument_list|(
name|ulen
operator|-
name|n
argument_list|,
literal|0
argument_list|,
name|u
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|u0
operator|=
name|new_sub_num
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|u
operator|->
name|n_value
operator|+
name|ulen
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vlen
operator|<
name|n
condition|)
block|{
name|v1
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|v0
operator|=
name|new_sub_num
argument_list|(
name|vlen
argument_list|,
literal|0
argument_list|,
name|v
operator|->
name|n_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v1
operator|=
name|new_sub_num
argument_list|(
name|vlen
operator|-
name|n
argument_list|,
literal|0
argument_list|,
name|v
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|v0
operator|=
name|new_sub_num
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
name|v
operator|->
name|n_value
operator|+
name|vlen
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
name|_bc_rm_leading_zeros
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|_bc_rm_leading_zeros
argument_list|(
name|u0
argument_list|)
expr_stmt|;
name|u0len
operator|=
name|u0
operator|->
name|n_len
expr_stmt|;
name|_bc_rm_leading_zeros
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|_bc_rm_leading_zeros
argument_list|(
name|v0
argument_list|)
expr_stmt|;
name|v0len
operator|=
name|v0
operator|->
name|n_len
expr_stmt|;
name|m1zero
operator|=
name|bc_is_zero
argument_list|(
name|u1
argument_list|)
operator|||
name|bc_is_zero
argument_list|(
name|v1
argument_list|)
expr_stmt|;
comment|/* Calculate sub results ... */
name|bc_init_num
argument_list|(
operator|&
name|d1
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|d2
argument_list|)
expr_stmt|;
name|bc_sub
argument_list|(
name|u1
argument_list|,
name|u0
argument_list|,
operator|&
name|d1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d1len
operator|=
name|d1
operator|->
name|n_len
expr_stmt|;
name|bc_sub
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|,
operator|&
name|d2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d2len
operator|=
name|d2
operator|->
name|n_len
expr_stmt|;
comment|/* Do recursive multiplies and shifted adds. */
if|if
condition|(
name|m1zero
condition|)
name|m1
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
else|else
name|_bc_rec_mul
argument_list|(
name|u1
argument_list|,
name|u1
operator|->
name|n_len
argument_list|,
name|v1
argument_list|,
name|v1
operator|->
name|n_len
argument_list|,
operator|&
name|m1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc_is_zero
argument_list|(
name|d1
argument_list|)
operator|||
name|bc_is_zero
argument_list|(
name|d2
argument_list|)
condition|)
name|m2
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
else|else
name|_bc_rec_mul
argument_list|(
name|d1
argument_list|,
name|d1len
argument_list|,
name|d2
argument_list|,
name|d2len
argument_list|,
operator|&
name|m2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc_is_zero
argument_list|(
name|u0
argument_list|)
operator|||
name|bc_is_zero
argument_list|(
name|v0
argument_list|)
condition|)
name|m3
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
else|else
name|_bc_rec_mul
argument_list|(
name|u0
argument_list|,
name|u0
operator|->
name|n_len
argument_list|,
name|v0
argument_list|,
name|v0
operator|->
name|n_len
argument_list|,
operator|&
name|m3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize product */
name|prodlen
operator|=
name|ulen
operator|+
name|vlen
operator|+
literal|1
expr_stmt|;
operator|*
name|prod
operator|=
name|bc_new_num
argument_list|(
name|prodlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m1zero
condition|)
block|{
name|_bc_shift_addsub
argument_list|(
operator|*
name|prod
argument_list|,
name|m1
argument_list|,
literal|2
operator|*
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bc_shift_addsub
argument_list|(
operator|*
name|prod
argument_list|,
name|m1
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|_bc_shift_addsub
argument_list|(
operator|*
name|prod
argument_list|,
name|m3
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bc_shift_addsub
argument_list|(
operator|*
name|prod
argument_list|,
name|m3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bc_shift_addsub
argument_list|(
operator|*
name|prod
argument_list|,
name|m2
argument_list|,
name|n
argument_list|,
name|d1
operator|->
name|n_sign
operator|!=
name|d2
operator|->
name|n_sign
argument_list|)
expr_stmt|;
comment|/* Now clean up! */
name|bc_free_num
argument_list|(
operator|&
name|u1
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|u0
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|v1
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|m1
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|v0
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|m2
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|m3
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|d1
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|d2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The multiply routine.  N2 times N1 is put int PROD with the scale of    the result being MIN(N2 scale+N1 scale, MAX (SCALE, N2 scale, N1 scale)).    */
end_comment

begin_function
name|void
name|bc_multiply
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|prod
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|,
decl|*
name|prod
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|pval
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|full_scale
decl_stmt|,
name|prod_scale
decl_stmt|;
comment|/* Initialize things. */
name|len1
operator|=
name|n1
operator|->
name|n_len
operator|+
name|n1
operator|->
name|n_scale
expr_stmt|;
name|len2
operator|=
name|n2
operator|->
name|n_len
operator|+
name|n2
operator|->
name|n_scale
expr_stmt|;
name|full_scale
operator|=
name|n1
operator|->
name|n_scale
operator|+
name|n2
operator|->
name|n_scale
expr_stmt|;
name|prod_scale
operator|=
name|MIN
argument_list|(
name|full_scale
argument_list|,
name|MAX
argument_list|(
name|scale
argument_list|,
name|MAX
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|n2
operator|->
name|n_scale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the multiply */
name|_bc_rec_mul
argument_list|(
name|n1
argument_list|,
name|len1
argument_list|,
name|n2
argument_list|,
name|len2
argument_list|,
operator|&
name|pval
argument_list|,
name|full_scale
argument_list|)
expr_stmt|;
comment|/* Assign to prod and clean up the number. */
name|pval
operator|->
name|n_sign
operator|=
operator|(
name|n1
operator|->
name|n_sign
operator|==
name|n2
operator|->
name|n_sign
condition|?
name|PLUS
else|:
name|MINUS
operator|)
expr_stmt|;
name|pval
operator|->
name|n_value
operator|=
name|pval
operator|->
name|n_ptr
expr_stmt|;
name|pval
operator|->
name|n_len
operator|=
name|len2
operator|+
name|len1
operator|+
literal|1
operator|-
name|full_scale
expr_stmt|;
name|pval
operator|->
name|n_scale
operator|=
name|prod_scale
expr_stmt|;
name|_bc_rm_leading_zeros
argument_list|(
name|pval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc_is_zero
argument_list|(
name|pval
argument_list|)
condition|)
name|pval
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|bc_free_num
argument_list|(
name|prod
argument_list|)
expr_stmt|;
operator|*
name|prod
operator|=
name|pval
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Some utility routines for the divide:  First a one digit multiply.    NUM (with SIZE digits) is multiplied by DIGIT and the result is    placed into RESULT.  It is written so that NUM and RESULT can be    the same pointers.  */
end_comment

begin_function
specifier|static
name|void
name|_one_mult
parameter_list|(
name|num
parameter_list|,
name|size
parameter_list|,
name|digit
parameter_list|,
name|result
parameter_list|)
name|unsigned
name|char
modifier|*
name|num
decl_stmt|;
name|int
name|size
decl_stmt|,
name|digit
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|carry
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|char
modifier|*
name|nptr
decl_stmt|,
modifier|*
name|rptr
decl_stmt|;
if|if
condition|(
name|digit
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|digit
operator|==
literal|1
condition|)
name|memcpy
argument_list|(
name|result
argument_list|,
name|num
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Initialize */
name|nptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|num
operator|+
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|rptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|result
operator|+
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
block|{
name|value
operator|=
operator|*
name|nptr
operator|--
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|rptr
operator|--
operator|=
name|value
operator|%
name|BASE
expr_stmt|;
name|carry
operator|=
name|value
operator|/
name|BASE
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
operator|*
name|rptr
operator|=
name|carry
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The full division routine. This computes N1 / N2.  It returns    0 if the division is ok and the result is in QUOT.  The number of    digits after the decimal point is SCALE. It returns -1 if division    by zero is tried.  The algorithm is found in Knuth Vol 2. p237. */
end_comment

begin_function
name|int
name|bc_divide
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|quot
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|n1
decl_stmt|,
name|n2
decl_stmt|,
decl|*
name|quot
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|qval
decl_stmt|;
name|unsigned
name|char
modifier|*
name|num1
decl_stmt|,
modifier|*
name|num2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|n2ptr
decl_stmt|,
modifier|*
name|qptr
decl_stmt|;
name|int
name|scale1
decl_stmt|,
name|val
decl_stmt|;
name|unsigned
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|scale2
decl_stmt|,
name|qdigits
decl_stmt|,
name|extra
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|qdig
decl_stmt|,
name|qguess
decl_stmt|,
name|borrow
decl_stmt|,
name|carry
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mval
decl_stmt|;
name|char
name|zero
decl_stmt|;
name|unsigned
name|int
name|norm
decl_stmt|;
comment|/* Test for divide by zero. */
if|if
condition|(
name|bc_is_zero
argument_list|(
name|n2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Test for divide by 1.  If it is we must truncate. */
if|if
condition|(
name|n2
operator|->
name|n_scale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n2
operator|->
name|n_len
operator|==
literal|1
operator|&&
operator|*
name|n2
operator|->
name|n_value
operator|==
literal|1
condition|)
block|{
name|qval
operator|=
name|bc_new_num
argument_list|(
name|n1
operator|->
name|n_len
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|qval
operator|->
name|n_sign
operator|=
operator|(
name|n1
operator|->
name|n_sign
operator|==
name|n2
operator|->
name|n_sign
condition|?
name|PLUS
else|:
name|MINUS
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|qval
operator|->
name|n_value
index|[
name|n1
operator|->
name|n_len
index|]
argument_list|,
literal|0
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|qval
operator|->
name|n_value
argument_list|,
name|n1
operator|->
name|n_value
argument_list|,
name|n1
operator|->
name|n_len
operator|+
name|MIN
argument_list|(
name|n1
operator|->
name|n_scale
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
name|quot
argument_list|)
expr_stmt|;
operator|*
name|quot
operator|=
name|qval
expr_stmt|;
block|}
block|}
comment|/* Set up the divide.  Move the decimal point on n1 by n2's scale.      Remember, zeros on the end of num2 are wasted effort for dividing. */
name|scale2
operator|=
name|n2
operator|->
name|n_scale
expr_stmt|;
name|n2ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|n2
operator|->
name|n_value
operator|+
name|n2
operator|->
name|n_len
operator|+
name|scale2
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|scale2
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|n2ptr
operator|--
operator|==
literal|0
operator|)
condition|)
name|scale2
operator|--
expr_stmt|;
name|len1
operator|=
name|n1
operator|->
name|n_len
operator|+
name|scale2
expr_stmt|;
name|scale1
operator|=
name|n1
operator|->
name|n_scale
operator|-
name|scale2
expr_stmt|;
if|if
condition|(
name|scale1
operator|<
name|scale
condition|)
name|extra
operator|=
name|scale
operator|-
name|scale1
expr_stmt|;
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|num1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n1
operator|->
name|n_len
operator|+
name|n1
operator|->
name|n_scale
operator|+
name|extra
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|num1
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|,
name|n1
operator|->
name|n_len
operator|+
name|n1
operator|->
name|n_scale
operator|+
name|extra
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|num1
operator|+
literal|1
argument_list|,
name|n1
operator|->
name|n_value
argument_list|,
name|n1
operator|->
name|n_len
operator|+
name|n1
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|len2
operator|=
name|n2
operator|->
name|n_len
operator|+
name|scale2
expr_stmt|;
name|num2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|num2
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|num2
argument_list|,
name|n2
operator|->
name|n_value
argument_list|,
name|len2
argument_list|)
expr_stmt|;
operator|*
operator|(
name|num2
operator|+
name|len2
operator|)
operator|=
literal|0
expr_stmt|;
name|n2ptr
operator|=
name|num2
expr_stmt|;
while|while
condition|(
operator|*
name|n2ptr
operator|==
literal|0
condition|)
block|{
name|n2ptr
operator|++
expr_stmt|;
name|len2
operator|--
expr_stmt|;
block|}
comment|/* Calculate the number of quotient digits. */
if|if
condition|(
name|len2
operator|>
name|len1
operator|+
name|scale
condition|)
block|{
name|qdigits
operator|=
name|scale
operator|+
literal|1
expr_stmt|;
name|zero
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|zero
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|len2
operator|>
name|len1
condition|)
name|qdigits
operator|=
name|scale
operator|+
literal|1
expr_stmt|;
comment|/* One for the zero integer part. */
else|else
name|qdigits
operator|=
name|len1
operator|-
name|len2
operator|+
name|scale
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Allocate and zero the storage for the quotient. */
name|qval
operator|=
name|bc_new_num
argument_list|(
name|qdigits
operator|-
name|scale
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|qval
operator|->
name|n_value
argument_list|,
literal|0
argument_list|,
name|qdigits
argument_list|)
expr_stmt|;
comment|/* Allocate storage for the temporary storage mval. */
name|mval
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mval
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
comment|/* Now for the full divide algorithm. */
if|if
condition|(
operator|!
name|zero
condition|)
block|{
comment|/* Normalize */
name|norm
operator|=
literal|10
operator|/
operator|(
operator|(
name|int
operator|)
operator|*
name|n2ptr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|norm
operator|!=
literal|1
condition|)
block|{
name|_one_mult
argument_list|(
name|num1
argument_list|,
name|len1
operator|+
name|scale1
operator|+
name|extra
operator|+
literal|1
argument_list|,
name|norm
argument_list|,
name|num1
argument_list|)
expr_stmt|;
name|_one_mult
argument_list|(
name|n2ptr
argument_list|,
name|len2
argument_list|,
name|norm
argument_list|,
name|n2ptr
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize divide loop. */
name|qdig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len2
operator|>
name|len1
condition|)
name|qptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|qval
operator|->
name|n_value
operator|+
name|len2
operator|-
name|len1
expr_stmt|;
else|else
name|qptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|qval
operator|->
name|n_value
expr_stmt|;
comment|/* Loop */
while|while
condition|(
name|qdig
operator|<=
name|len1
operator|+
name|scale
operator|-
name|len2
condition|)
block|{
comment|/* Calculate the quotient digit guess. */
if|if
condition|(
operator|*
name|n2ptr
operator|==
name|num1
index|[
name|qdig
index|]
condition|)
name|qguess
operator|=
literal|9
expr_stmt|;
else|else
name|qguess
operator|=
operator|(
name|num1
index|[
name|qdig
index|]
operator|*
literal|10
operator|+
name|num1
index|[
name|qdig
operator|+
literal|1
index|]
operator|)
operator|/
operator|*
name|n2ptr
expr_stmt|;
comment|/* Test qguess. */
if|if
condition|(
name|n2ptr
index|[
literal|1
index|]
operator|*
name|qguess
operator|>
operator|(
name|num1
index|[
name|qdig
index|]
operator|*
literal|10
operator|+
name|num1
index|[
name|qdig
operator|+
literal|1
index|]
operator|-
operator|*
name|n2ptr
operator|*
name|qguess
operator|)
operator|*
literal|10
operator|+
name|num1
index|[
name|qdig
operator|+
literal|2
index|]
condition|)
block|{
name|qguess
operator|--
expr_stmt|;
comment|/* And again. */
if|if
condition|(
name|n2ptr
index|[
literal|1
index|]
operator|*
name|qguess
operator|>
operator|(
name|num1
index|[
name|qdig
index|]
operator|*
literal|10
operator|+
name|num1
index|[
name|qdig
operator|+
literal|1
index|]
operator|-
operator|*
name|n2ptr
operator|*
name|qguess
operator|)
operator|*
literal|10
operator|+
name|num1
index|[
name|qdig
operator|+
literal|2
index|]
condition|)
name|qguess
operator|--
expr_stmt|;
block|}
comment|/* Multiply and subtract. */
name|borrow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qguess
operator|!=
literal|0
condition|)
block|{
operator|*
name|mval
operator|=
literal|0
expr_stmt|;
name|_one_mult
argument_list|(
name|n2ptr
argument_list|,
name|len2
argument_list|,
name|qguess
argument_list|,
name|mval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|num1
operator|+
name|qdig
operator|+
name|len2
expr_stmt|;
name|ptr2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mval
operator|+
name|len2
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len2
operator|+
literal|1
condition|;
name|count
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|int
operator|)
operator|*
name|ptr1
operator|-
operator|(
name|int
operator|)
operator|*
name|ptr2
operator|--
operator|-
name|borrow
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|+=
literal|10
expr_stmt|;
name|borrow
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|borrow
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr1
operator|--
operator|=
name|val
expr_stmt|;
block|}
block|}
comment|/* Test for negative result. */
if|if
condition|(
name|borrow
operator|==
literal|1
condition|)
block|{
name|qguess
operator|--
expr_stmt|;
name|ptr1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|num1
operator|+
name|qdig
operator|+
name|len2
expr_stmt|;
name|ptr2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|n2ptr
operator|+
name|len2
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len2
condition|;
name|count
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|int
operator|)
operator|*
name|ptr1
operator|+
operator|(
name|int
operator|)
operator|*
name|ptr2
operator|--
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|9
condition|)
block|{
name|val
operator|-=
literal|10
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr1
operator|--
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|==
literal|1
condition|)
operator|*
name|ptr1
operator|=
operator|(
operator|*
name|ptr1
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
block|}
comment|/* We now know the quotient digit. */
operator|*
name|qptr
operator|++
operator|=
name|qguess
expr_stmt|;
name|qdig
operator|++
expr_stmt|;
block|}
block|}
comment|/* Clean up and return the number. */
name|qval
operator|->
name|n_sign
operator|=
operator|(
name|n1
operator|->
name|n_sign
operator|==
name|n2
operator|->
name|n_sign
condition|?
name|PLUS
else|:
name|MINUS
operator|)
expr_stmt|;
if|if
condition|(
name|bc_is_zero
argument_list|(
name|qval
argument_list|)
condition|)
name|qval
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|_bc_rm_leading_zeros
argument_list|(
name|qval
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
name|quot
argument_list|)
expr_stmt|;
operator|*
name|quot
operator|=
name|qval
expr_stmt|;
comment|/* Clean up temporary storage. */
name|free
argument_list|(
name|mval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|num1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|num2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Everything is OK. */
block|}
end_block

begin_comment
comment|/* Division *and* modulo for numbers.  This computes both NUM1 / NUM2 and    NUM1 % NUM2  and puts the results in QUOT and REM, except that if QUOT    is NULL then that store will be omitted.  */
end_comment

begin_function
name|int
name|bc_divmod
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|quot
parameter_list|,
name|rem
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|num1
decl_stmt|,
name|num2
decl_stmt|,
decl|*
name|quot
decl_stmt|,
modifier|*
name|rem
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|quotient
init|=
name|NULL
decl_stmt|;
name|bc_num
name|temp
decl_stmt|;
name|int
name|rscale
decl_stmt|;
comment|/* Check for correct numbers. */
if|if
condition|(
name|bc_is_zero
argument_list|(
name|num2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Calculate final scale. */
name|rscale
operator|=
name|MAX
argument_list|(
name|num1
operator|->
name|n_scale
argument_list|,
name|num2
operator|->
name|n_scale
operator|+
name|scale
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* Calculate it. */
name|bc_divide
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|,
operator|&
name|temp
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|quot
condition|)
name|quotient
operator|=
name|bc_copy_num
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|bc_multiply
argument_list|(
name|temp
argument_list|,
name|num2
argument_list|,
operator|&
name|temp
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
name|bc_sub
argument_list|(
name|num1
argument_list|,
name|temp
argument_list|,
name|rem
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|quot
condition|)
block|{
name|bc_free_num
argument_list|(
name|quot
argument_list|)
expr_stmt|;
operator|*
name|quot
operator|=
name|quotient
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Everything is OK. */
block|}
end_block

begin_comment
comment|/* Modulo for numbers.  This computes NUM1 % NUM2  and puts the    result in RESULT.   */
end_comment

begin_function
name|int
name|bc_modulo
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|result
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|num1
decl_stmt|,
name|num2
decl_stmt|,
decl|*
name|result
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|bc_divmod
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|,
name|NULL
argument_list|,
name|result
argument_list|,
name|scale
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Raise BASE to the EXPO power, reduced modulo MOD.  The result is    placed in RESULT.  If a EXPO is not an integer,    only the integer part is used.  */
end_comment

begin_function
name|int
name|bc_raisemod
parameter_list|(
name|base
parameter_list|,
name|expo
parameter_list|,
name|mod
parameter_list|,
name|result
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|base
decl_stmt|,
name|expo
decl_stmt|,
name|mod
decl_stmt|,
decl|*
name|result
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|power
decl_stmt|,
name|exponent
decl_stmt|,
name|parity
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|rscale
decl_stmt|;
comment|/* Check for correct numbers. */
if|if
condition|(
name|bc_is_zero
argument_list|(
name|mod
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bc_is_neg
argument_list|(
name|expo
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set initial values.  */
name|power
operator|=
name|bc_copy_num
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|bc_copy_num
argument_list|(
name|expo
argument_list|)
expr_stmt|;
name|temp
operator|=
name|bc_copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|parity
argument_list|)
expr_stmt|;
comment|/* Check the base for scale digits. */
if|if
condition|(
name|base
operator|->
name|n_scale
operator|!=
literal|0
condition|)
name|bc_rt_warn
argument_list|(
literal|"non-zero scale in base"
argument_list|)
expr_stmt|;
comment|/* Check the exponent for scale digits. */
if|if
condition|(
name|exponent
operator|->
name|n_scale
operator|!=
literal|0
condition|)
block|{
name|bc_rt_warn
argument_list|(
literal|"non-zero scale in exponent"
argument_list|)
expr_stmt|;
name|bc_divide
argument_list|(
name|exponent
argument_list|,
name|_one_
argument_list|,
operator|&
name|exponent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*truncate */
block|}
comment|/* Check the modulus for scale digits. */
if|if
condition|(
name|mod
operator|->
name|n_scale
operator|!=
literal|0
condition|)
name|bc_rt_warn
argument_list|(
literal|"non-zero scale in modulus"
argument_list|)
expr_stmt|;
comment|/* Do the calculation. */
name|rscale
operator|=
name|MAX
argument_list|(
name|scale
argument_list|,
name|base
operator|->
name|n_scale
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bc_is_zero
argument_list|(
name|exponent
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|bc_divmod
argument_list|(
name|exponent
argument_list|,
name|_two_
argument_list|,
operator|&
name|exponent
argument_list|,
operator|&
name|parity
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bc_is_zero
argument_list|(
name|parity
argument_list|)
condition|)
block|{
name|bc_multiply
argument_list|(
name|temp
argument_list|,
name|power
argument_list|,
operator|&
name|temp
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bc_modulo
argument_list|(
name|temp
argument_list|,
name|mod
argument_list|,
operator|&
name|temp
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|bc_multiply
argument_list|(
name|power
argument_list|,
name|power
argument_list|,
operator|&
name|power
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bc_modulo
argument_list|(
name|power
argument_list|,
name|mod
argument_list|,
operator|&
name|power
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* Assign the value. */
name|bc_free_num
argument_list|(
operator|&
name|power
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|exponent
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|temp
expr_stmt|;
return|return
literal|0
return|;
comment|/* Everything is OK. */
block|}
end_block

begin_comment
comment|/* Raise NUM1 to the NUM2 power.  The result is placed in RESULT.    Maximum exponent is LONG_MAX.  If a NUM2 is not an integer,    only the integer part is used.  */
end_comment

begin_function
name|void
name|bc_raise
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|result
parameter_list|,
name|scale
parameter_list|)
name|bc_num
name|num1
decl_stmt|,
name|num2
decl_stmt|,
decl|*
name|result
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bc_num
name|temp
decl_stmt|,
name|power
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|int
name|rscale
decl_stmt|;
name|int
name|pwrscale
decl_stmt|;
name|int
name|calcscale
decl_stmt|;
name|char
name|neg
decl_stmt|;
comment|/* Check the exponent for scale digits and convert to a long. */
if|if
condition|(
name|num2
operator|->
name|n_scale
operator|!=
literal|0
condition|)
name|bc_rt_warn
argument_list|(
literal|"non-zero scale in exponent"
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|bc_num2long
argument_list|(
name|num2
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|==
literal|0
operator|&&
operator|(
name|num2
operator|->
name|n_len
operator|>
literal|1
operator|||
name|num2
operator|->
name|n_value
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
name|bc_rt_error
argument_list|(
literal|"exponent too large in raise"
argument_list|)
expr_stmt|;
comment|/* Special case if exponent is a zero. */
if|if
condition|(
name|exponent
operator|==
literal|0
condition|)
block|{
name|bc_free_num
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|bc_copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Other initializations. */
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
name|TRUE
expr_stmt|;
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
name|rscale
operator|=
name|scale
expr_stmt|;
block|}
else|else
block|{
name|neg
operator|=
name|FALSE
expr_stmt|;
name|rscale
operator|=
name|MIN
argument_list|(
name|num1
operator|->
name|n_scale
operator|*
name|exponent
argument_list|,
name|MAX
argument_list|(
name|scale
argument_list|,
name|num1
operator|->
name|n_scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set initial value of temp.  */
name|power
operator|=
name|bc_copy_num
argument_list|(
name|num1
argument_list|)
expr_stmt|;
name|pwrscale
operator|=
name|num1
operator|->
name|n_scale
expr_stmt|;
while|while
condition|(
operator|(
name|exponent
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|pwrscale
operator|=
literal|2
operator|*
name|pwrscale
expr_stmt|;
name|bc_multiply
argument_list|(
name|power
argument_list|,
name|power
argument_list|,
operator|&
name|power
argument_list|,
name|pwrscale
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|>>
literal|1
expr_stmt|;
block|}
name|temp
operator|=
name|bc_copy_num
argument_list|(
name|power
argument_list|)
expr_stmt|;
name|calcscale
operator|=
name|pwrscale
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|>>
literal|1
expr_stmt|;
comment|/* Do the calculation. */
while|while
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|pwrscale
operator|=
literal|2
operator|*
name|pwrscale
expr_stmt|;
name|bc_multiply
argument_list|(
name|power
argument_list|,
name|power
argument_list|,
operator|&
name|power
argument_list|,
name|pwrscale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exponent
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|calcscale
operator|=
name|pwrscale
operator|+
name|calcscale
expr_stmt|;
name|bc_multiply
argument_list|(
name|temp
argument_list|,
name|power
argument_list|,
operator|&
name|temp
argument_list|,
name|calcscale
argument_list|)
expr_stmt|;
block|}
name|exponent
operator|=
name|exponent
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Assign the value. */
if|if
condition|(
name|neg
condition|)
block|{
name|bc_divide
argument_list|(
name|_one_
argument_list|,
name|temp
argument_list|,
name|result
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bc_free_num
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|result
operator|)
operator|->
name|n_scale
operator|>
name|rscale
condition|)
operator|(
operator|*
name|result
operator|)
operator|->
name|n_scale
operator|=
name|rscale
expr_stmt|;
block|}
name|bc_free_num
argument_list|(
operator|&
name|power
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Take the square root NUM and return it in NUM with SCALE digits    after the decimal place. */
end_comment

begin_function
name|int
name|bc_sqrt
parameter_list|(
name|num
parameter_list|,
name|scale
parameter_list|)
name|bc_num
modifier|*
name|num
decl_stmt|;
name|int
name|scale
decl_stmt|;
block|{
name|int
name|rscale
decl_stmt|,
name|cmp_res
decl_stmt|,
name|done
decl_stmt|;
name|int
name|cscale
decl_stmt|;
name|bc_num
name|guess
decl_stmt|,
name|guess1
decl_stmt|,
name|point5
decl_stmt|,
name|diff
decl_stmt|;
comment|/* Initial checks. */
name|cmp_res
operator|=
name|bc_compare
argument_list|(
operator|*
name|num
argument_list|,
name|_zero_
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_res
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* error */
else|else
block|{
if|if
condition|(
name|cmp_res
operator|==
literal|0
condition|)
block|{
name|bc_free_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|cmp_res
operator|=
name|bc_compare
argument_list|(
operator|*
name|num
argument_list|,
name|_one_
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_res
operator|==
literal|0
condition|)
block|{
name|bc_free_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|bc_copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Initialize the variables. */
name|rscale
operator|=
name|MAX
argument_list|(
name|scale
argument_list|,
operator|(
operator|*
name|num
operator|)
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|guess
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|guess1
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|point5
operator|=
name|bc_new_num
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|point5
operator|->
name|n_value
index|[
literal|1
index|]
operator|=
literal|5
expr_stmt|;
comment|/* Calculate the initial guess. */
if|if
condition|(
name|cmp_res
operator|<
literal|0
condition|)
block|{
comment|/* The number is between 0 and 1.  Guess should start at 1. */
name|guess
operator|=
name|bc_copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
name|cscale
operator|=
operator|(
operator|*
name|num
operator|)
operator|->
name|n_scale
expr_stmt|;
block|}
else|else
block|{
comment|/* The number is greater than 1.  Guess should start at 10^(exp/2). */
name|bc_int2num
argument_list|(
operator|&
name|guess
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|guess1
argument_list|,
operator|(
operator|*
name|num
operator|)
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|bc_multiply
argument_list|(
name|guess1
argument_list|,
name|point5
argument_list|,
operator|&
name|guess1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|guess1
operator|->
name|n_scale
operator|=
literal|0
expr_stmt|;
name|bc_raise
argument_list|(
name|guess
argument_list|,
name|guess1
argument_list|,
operator|&
name|guess
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|guess1
argument_list|)
expr_stmt|;
name|cscale
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Find the square root using Newton's algorithm. */
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|bc_free_num
argument_list|(
operator|&
name|guess1
argument_list|)
expr_stmt|;
name|guess1
operator|=
name|bc_copy_num
argument_list|(
name|guess
argument_list|)
expr_stmt|;
name|bc_divide
argument_list|(
operator|*
name|num
argument_list|,
name|guess
argument_list|,
operator|&
name|guess
argument_list|,
name|cscale
argument_list|)
expr_stmt|;
name|bc_add
argument_list|(
name|guess
argument_list|,
name|guess1
argument_list|,
operator|&
name|guess
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc_multiply
argument_list|(
name|guess
argument_list|,
name|point5
argument_list|,
operator|&
name|guess
argument_list|,
name|cscale
argument_list|)
expr_stmt|;
name|bc_sub
argument_list|(
name|guess
argument_list|,
name|guess1
argument_list|,
operator|&
name|diff
argument_list|,
name|cscale
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc_is_near_zero
argument_list|(
name|diff
argument_list|,
name|cscale
argument_list|)
condition|)
block|{
if|if
condition|(
name|cscale
operator|<
name|rscale
operator|+
literal|1
condition|)
name|cscale
operator|=
name|MIN
argument_list|(
name|cscale
operator|*
literal|3
argument_list|,
name|rscale
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Assign the number and clean up. */
name|bc_free_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|bc_divide
argument_list|(
name|guess
argument_list|,
name|_one_
argument_list|,
name|num
argument_list|,
name|rscale
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|guess
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|guess1
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|point5
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The following routines provide output for bcd numbers package    using the rules of POSIX bc for output. */
end_comment

begin_comment
comment|/* This structure is used for saving digits in the conversion process. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stk_rec
block|{
name|long
name|digit
decl_stmt|;
name|struct
name|stk_rec
modifier|*
name|next
decl_stmt|;
block|}
name|stk_rec
typedef|;
end_typedef

begin_comment
comment|/* The reference string for digits. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ref_str
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A special output routine for "multi-character digits."  Exactly    SIZE characters must be output for the value VAL.  If SPACE is    non-zero, we must output one space before the number.  OUT_CHAR    is the actual routine for writing the characters. */
end_comment

begin_decl_stmt
name|void
name|bc_out_long
argument_list|(
name|val
argument_list|,
name|size
argument_list|,
name|space
argument_list|,
name|out_char
argument_list|)
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|,
name|space
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
name|void
function_decl|(
modifier|*
name|out_char
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
function_decl|(
modifier|*
name|out_char
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
name|digits
index|[
literal|40
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ix
decl_stmt|;
if|if
condition|(
name|space
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digits
argument_list|,
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|digits
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|len
condition|)
block|{
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|len
condition|;
name|ix
operator|++
control|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
name|digits
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Output of a bcd number.  NUM is written in base O_BASE using OUT_CHAR    as the routine to do the actual output of the characters. */
end_comment

begin_decl_stmt
name|void
name|bc_out_num
argument_list|(
name|num
argument_list|,
name|o_base
argument_list|,
name|out_char
argument_list|,
name|leading_zero
argument_list|)
name|bc_num
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|o_base
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
name|void
function_decl|(
modifier|*
name|out_char
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
function_decl|(
modifier|*
name|out_char
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|leading_zero
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nptr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|fdigit
decl_stmt|,
name|pre_space
decl_stmt|;
name|stk_rec
modifier|*
name|digits
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|bc_num
name|int_part
decl_stmt|,
name|frac_part
decl_stmt|,
name|base
decl_stmt|,
name|cur_dig
decl_stmt|,
name|t_num
decl_stmt|,
name|max_o_digit
decl_stmt|;
comment|/* The negative sign if needed. */
if|if
condition|(
name|num
operator|->
name|n_sign
operator|==
name|MINUS
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* Output the number. */
if|if
condition|(
name|bc_is_zero
argument_list|(
name|num
argument_list|)
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|o_base
operator|==
literal|10
condition|)
block|{
comment|/* The number is in base 10, do it the fast way. */
name|nptr
operator|=
name|num
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|num
operator|->
name|n_len
operator|>
literal|1
operator|||
operator|*
name|nptr
operator|!=
literal|0
condition|)
for|for
control|(
name|index
operator|=
name|num
operator|->
name|n_len
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
name|BCD_CHAR
argument_list|(
operator|*
name|nptr
operator|++
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nptr
operator|++
expr_stmt|;
if|if
condition|(
name|leading_zero
operator|&&
name|bc_is_zero
argument_list|(
name|num
argument_list|)
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
comment|/* Now the fraction. */
if|if
condition|(
name|num
operator|->
name|n_scale
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num
operator|->
name|n_scale
condition|;
name|index
operator|++
control|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
name|BCD_CHAR
argument_list|(
operator|*
name|nptr
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* special case ... */
if|if
condition|(
name|leading_zero
operator|&&
name|bc_is_zero
argument_list|(
name|num
argument_list|)
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
comment|/* The number is some other base. */
name|digits
operator|=
name|NULL
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|int_part
argument_list|)
expr_stmt|;
name|bc_divide
argument_list|(
name|num
argument_list|,
name|_one_
argument_list|,
operator|&
name|int_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|frac_part
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|cur_dig
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
name|bc_sub
argument_list|(
name|num
argument_list|,
name|int_part
argument_list|,
operator|&
name|frac_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make the INT_PART and FRAC_PART positive. */
name|int_part
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|frac_part
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|base
argument_list|,
name|o_base
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|max_o_digit
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|max_o_digit
argument_list|,
name|o_base
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the digits of the integer part and push them on a stack. */
while|while
condition|(
operator|!
name|bc_is_zero
argument_list|(
name|int_part
argument_list|)
condition|)
block|{
name|bc_modulo
argument_list|(
name|int_part
argument_list|,
name|base
argument_list|,
operator|&
name|cur_dig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|stk_rec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stk_rec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
name|temp
operator|->
name|digit
operator|=
name|bc_num2long
argument_list|(
name|cur_dig
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|digits
expr_stmt|;
name|digits
operator|=
name|temp
expr_stmt|;
name|bc_divide
argument_list|(
name|int_part
argument_list|,
name|base
argument_list|,
operator|&
name|int_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Print the digits on the stack. */
if|if
condition|(
name|digits
operator|!=
name|NULL
condition|)
block|{
comment|/* Output the digits. */
while|while
condition|(
name|digits
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|=
name|digits
expr_stmt|;
name|digits
operator|=
name|digits
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|o_base
operator|<=
literal|16
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
name|ref_str
index|[
operator|(
name|int
operator|)
name|temp
operator|->
name|digit
index|]
argument_list|)
expr_stmt|;
else|else
name|bc_out_long
argument_list|(
name|temp
operator|->
name|digit
argument_list|,
name|max_o_digit
operator|->
name|n_len
argument_list|,
literal|1
argument_list|,
name|out_char
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get and print the digits of the fraction part. */
if|if
condition|(
name|num
operator|->
name|n_scale
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|out_char
call|)
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|pre_space
operator|=
literal|0
expr_stmt|;
name|t_num
operator|=
name|bc_copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
while|while
condition|(
name|t_num
operator|->
name|n_len
operator|<=
name|num
operator|->
name|n_scale
condition|)
block|{
name|bc_multiply
argument_list|(
name|frac_part
argument_list|,
name|base
argument_list|,
operator|&
name|frac_part
argument_list|,
name|num
operator|->
name|n_scale
argument_list|)
expr_stmt|;
name|fdigit
operator|=
name|bc_num2long
argument_list|(
name|frac_part
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|int_part
argument_list|,
name|fdigit
argument_list|)
expr_stmt|;
name|bc_sub
argument_list|(
name|frac_part
argument_list|,
name|int_part
argument_list|,
operator|&
name|frac_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_base
operator|<=
literal|16
condition|)
call|(
modifier|*
name|out_char
call|)
argument_list|(
name|ref_str
index|[
name|fdigit
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|bc_out_long
argument_list|(
name|fdigit
argument_list|,
name|max_o_digit
operator|->
name|n_len
argument_list|,
name|pre_space
argument_list|,
name|out_char
argument_list|)
expr_stmt|;
name|pre_space
operator|=
literal|1
expr_stmt|;
block|}
name|bc_multiply
argument_list|(
name|t_num
argument_list|,
name|base
argument_list|,
operator|&
name|t_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bc_free_num
argument_list|(
operator|&
name|t_num
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up. */
name|bc_free_num
argument_list|(
operator|&
name|int_part
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|frac_part
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|cur_dig
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|max_o_digit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Convert a number NUM to a long.  The function returns only the integer    part of the number.  For numbers that are too large to represent as    a long, this function returns a zero.  This can be detected by checking    the NUM for zero after having a zero returned. */
end_comment

begin_function
name|long
name|bc_num2long
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Extract the int value, ignore the fraction. */
name|val
operator|=
literal|0
expr_stmt|;
name|nptr
operator|=
name|num
operator|->
name|n_value
expr_stmt|;
for|for
control|(
name|index
operator|=
name|num
operator|->
name|n_len
init|;
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|val
operator|<=
operator|(
name|LONG_MAX
operator|/
name|BASE
operator|)
operator|)
condition|;
name|index
operator|--
control|)
name|val
operator|=
name|val
operator|*
name|BASE
operator|+
operator|*
name|nptr
operator|++
expr_stmt|;
comment|/* Check for overflow.  If overflow, return zero. */
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Return the value. */
if|if
condition|(
name|num
operator|->
name|n_sign
operator|==
name|PLUS
condition|)
return|return
operator|(
name|val
operator|)
return|;
else|else
return|return
operator|(
operator|-
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an integer VAL to a bc number NUM. */
end_comment

begin_function
name|void
name|bc_int2num
parameter_list|(
name|num
parameter_list|,
name|val
parameter_list|)
name|bc_num
modifier|*
name|num
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|vptr
decl_stmt|;
name|int
name|ix
init|=
literal|1
decl_stmt|;
name|char
name|neg
init|=
literal|0
decl_stmt|;
comment|/* Sign. */
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
operator|-
name|val
expr_stmt|;
block|}
comment|/* Get things going. */
name|bptr
operator|=
name|buffer
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
name|val
operator|%
name|BASE
expr_stmt|;
name|val
operator|=
name|val
operator|/
name|BASE
expr_stmt|;
comment|/* Extract remaining digits. */
while|while
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
operator|*
name|bptr
operator|++
operator|=
name|val
operator|%
name|BASE
expr_stmt|;
name|val
operator|=
name|val
operator|/
name|BASE
expr_stmt|;
name|ix
operator|++
expr_stmt|;
comment|/* Count the digits. */
block|}
comment|/* Make the number. */
name|bc_free_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|bc_new_num
argument_list|(
name|ix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
operator|(
operator|*
name|num
operator|)
operator|->
name|n_sign
operator|=
name|MINUS
expr_stmt|;
comment|/* Assign the digits. */
name|vptr
operator|=
operator|(
operator|*
name|num
operator|)
operator|->
name|n_value
expr_stmt|;
while|while
condition|(
name|ix
operator|--
operator|>
literal|0
condition|)
operator|*
name|vptr
operator|++
operator|=
operator|*
operator|--
name|bptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a numbers to a string.  Base 10 only.*/
end_comment

begin_function
name|char
modifier|*
name|num2str
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|sptr
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|signch
decl_stmt|;
comment|/* Allocate the string memory. */
name|signch
operator|=
operator|(
name|num
operator|->
name|n_sign
operator|==
name|PLUS
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Number of sign chars. */
if|if
condition|(
name|num
operator|->
name|n_scale
operator|>
literal|0
condition|)
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|->
name|n_len
operator|+
name|num
operator|->
name|n_scale
operator|+
literal|2
operator|+
name|signch
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|->
name|n_len
operator|+
literal|1
operator|+
name|signch
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|bc_out_of_memory
argument_list|()
expr_stmt|;
comment|/* The negative sign if needed. */
name|sptr
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|signch
condition|)
operator|*
name|sptr
operator|++
operator|=
literal|'-'
expr_stmt|;
comment|/* Load the whole number. */
name|nptr
operator|=
name|num
operator|->
name|n_value
expr_stmt|;
for|for
control|(
name|index
operator|=
name|num
operator|->
name|n_len
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
operator|*
name|sptr
operator|++
operator|=
name|BCD_CHAR
argument_list|(
operator|*
name|nptr
operator|++
argument_list|)
expr_stmt|;
comment|/* Now the fraction. */
if|if
condition|(
name|num
operator|->
name|n_scale
operator|>
literal|0
condition|)
block|{
operator|*
name|sptr
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num
operator|->
name|n_scale
condition|;
name|index
operator|++
control|)
operator|*
name|sptr
operator|++
operator|=
name|BCD_CHAR
argument_list|(
operator|*
name|nptr
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the string and return it! */
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert strings to bc numbers.  Base 10 only.*/
end_comment

begin_function
name|void
name|bc_str2num
parameter_list|(
name|num
parameter_list|,
name|str
parameter_list|,
name|scale
parameter_list|)
name|bc_num
modifier|*
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|scale
decl_stmt|;
block|{
name|int
name|digits
decl_stmt|,
name|strscale
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|nptr
decl_stmt|;
name|char
name|zero_int
decl_stmt|;
comment|/* Prepare num. */
name|bc_free_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* Check for valid number and count digits. */
name|ptr
operator|=
name|str
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
name|strscale
operator|=
literal|0
expr_stmt|;
name|zero_int
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'-'
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Sign */
while|while
condition|(
operator|*
name|ptr
operator|==
literal|'0'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Skip leading zeros. */
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
operator|,
name|digits
operator|++
expr_stmt|;
comment|/* digits */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'.'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* decimal point */
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
operator|,
name|strscale
operator|++
expr_stmt|;
comment|/* digits */
if|if
condition|(
operator|(
operator|*
name|ptr
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|digits
operator|+
name|strscale
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|num
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Adjust numbers and allocate storage and initialize fields. */
name|strscale
operator|=
name|MIN
argument_list|(
name|strscale
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
operator|==
literal|0
condition|)
block|{
name|zero_int
operator|=
name|TRUE
expr_stmt|;
name|digits
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|num
operator|=
name|bc_new_num
argument_list|(
name|digits
argument_list|,
name|strscale
argument_list|)
expr_stmt|;
comment|/* Build the whole number. */
name|ptr
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|num
operator|)
operator|->
name|n_sign
operator|=
name|MINUS
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|num
operator|)
operator|->
name|n_sign
operator|=
name|PLUS
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'+'
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|ptr
operator|==
literal|'0'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Skip leading zeros. */
name|nptr
operator|=
operator|(
operator|*
name|num
operator|)
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|zero_int
condition|)
block|{
operator|*
name|nptr
operator|++
operator|=
literal|0
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|digits
operator|>
literal|0
condition|;
name|digits
operator|--
control|)
operator|*
name|nptr
operator|++
operator|=
name|CH_VAL
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
comment|/* Build the fractional part. */
if|if
condition|(
name|strscale
operator|>
literal|0
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
comment|/* skip the decimal point! */
for|for
control|(
init|;
name|strscale
operator|>
literal|0
condition|;
name|strscale
operator|--
control|)
operator|*
name|nptr
operator|++
operator|=
name|CH_VAL
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* pn prints the number NUM in base 10. */
end_comment

begin_function
specifier|static
name|void
name|out_char
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pn
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|bc_out_num
argument_list|(
name|num
argument_list|,
literal|10
argument_list|,
name|out_char
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pv prints a character array as if it was a string of bcd digits. */
end_comment

begin_function
name|void
name|pv
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
modifier|*
name|num
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|BCD_CHAR
argument_list|(
name|num
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

