begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<check.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"expat.h"
end_include

begin_include
include|#
directive|include
file|"chardata.h"
end_include

begin_decl_stmt
specifier|static
name|XML_Parser
name|parser
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|basic_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Parser not created."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|basic_teardown
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|!=
name|NULL
condition|)
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a failure using the parser state to create an error message;    this should be used when the parser reports an error we weren't    expecting. */
end_comment

begin_function
specifier|static
name|void
name|_xml_failure
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\n    %s (line %d, offset %d)\n    reported from %s, line %d"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|,
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|xml_failure
parameter_list|(
name|parser
parameter_list|)
value|_xml_failure((parser), __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|_expect_failure
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|enum
name|XML_Error
name|errorCode
parameter_list|,
name|char
modifier|*
name|errorMessage
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
name|fail
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|errorCode
condition|)
name|_xml_failure
argument_list|(
name|parser
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|expect_failure
parameter_list|(
name|text
parameter_list|,
name|errorCode
parameter_list|,
name|errorMessage
parameter_list|)
define|\
value|_expect_failure((text), (errorCode), (errorMessage), \                         __FILE__, __LINE__)
end_define

begin_comment
comment|/*  * Character& encoding tests.  */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_nul_byte
argument_list|)
end_macro

begin_block
block|{
name|char
name|text
index|[]
init|=
literal|"<doc>\0</doc>"
decl_stmt|;
comment|/* test that a NUL byte (in US-ASCII data) is an error */
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
name|fail
argument_list|(
literal|"Parser did not report error on NUL-byte."
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_INVALID_TOKEN
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_u0000_char
parameter_list|)
block|{
comment|/* test that a NUL byte (in US-ASCII data) is an error */
name|expect_failure
argument_list|(
literal|"<doc>&#0;</doc>"
argument_list|,
name|XML_ERROR_BAD_CHAR_REF
argument_list|,
literal|"Parser did not report error on NUL-byte."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf8
parameter_list|)
block|{
comment|/* This test is really just making sure we don't core on a UTF-8 BOM. */
name|char
modifier|*
name|text
init|=
literal|"\357\273\277<e/>"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf16_be
parameter_list|)
block|{
name|char
name|text
index|[]
init|=
literal|"\376\377\0<\0e\0/\0>"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf16_le
parameter_list|)
block|{
name|char
name|text
index|[]
init|=
literal|"\377\376<\0e\0/\0>\0"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|void
name|accumulate_characters
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|CharData_AppendXMLChars
argument_list|(
operator|(
name|CharData
operator|*
operator|)
name|userData
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|accumulate_attribute
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|storage
operator|->
name|count
operator|<
literal|0
operator|&&
name|atts
operator|!=
name|NULL
operator|&&
name|atts
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* "accumulate" the value of the first attribute we see */
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|atts
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|run_character_check
parameter_list|(
name|XML_Char
modifier|*
name|text
parameter_list|,
name|XML_Char
modifier|*
name|expected
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_characters
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_attribute_check
parameter_list|(
name|XML_Char
modifier|*
name|text
parameter_list|,
name|XML_Char
modifier|*
name|expected
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for SF bug #491986. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_danish_latin1
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<e>Jørgen æøåÆØÅ</e>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"J\xC3\xB8rgen \xC3\xA6\xC3\xB8\xC3\xA5\xC3\x86\xC3\x98\xC3\x85"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #514281. */
name|START_TEST
parameter_list|(
name|test_french_charref_hexidecimal
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>&#xE9;&#xE8;&#xE0;&#xE7;&#xEA;&#xC8;</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_charref_decimal
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>&#233;&#232;&#224;&#231;&#234;&#200;</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_latin1
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>\xE9\xE8\xE0\xE7\xEa\xC8</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_utf8
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='utf-8'?>\n"
literal|"<doc>\xC3\xA9</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #600479.    XXX There should be a test that exercises all legal XML Unicode    characters as PCDATA and attribute value content, and XML Name    characters as part of element and attribute names. */
name|START_TEST
parameter_list|(
name|test_utf8_false_rejection
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<doc>\xEF\xBA\xBF</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xEF\xBA\xBF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #477667.    This test assures that any 8-bit character followed by a 7-bit    character will not be mistakenly interpreted as a valid UTF-8    sequence. */
name|START_TEST
parameter_list|(
name|test_illegal_utf8
parameter_list|)
block|{
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<=
literal|255
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"<e>%ccd</e>"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"expected token error for '%c' (ordinal %d) in UTF-8 text"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_INVALID_TOKEN
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Reset the parser since we use the same parser repeatedly. */
name|XML_ParserReset
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_utf16
parameter_list|)
block|{
comment|/*<?xml version="1.0" encoding="UTF-16"?><doc a='123'>some text</doc>     */
name|char
name|text
index|[]
init|=
literal|"\000<\000?\000x\000m\000\154\000 \000v\000e\000r\000s\000i\000o"
literal|"\000n\000=\000'\0001\000.\000\060\000'\000 \000e\000n\000c\000o"
literal|"\000d\000i\000n\000g\000=\000'\000U\000T\000F\000-\0001\000\066"
literal|"\000'\000?\000>\000\n"
literal|"\000<\000d\000o\000c\000 \000a\000=\000'\0001\0002\0003\000'"
literal|"\000>\000s\000o\000m\000e\000 \000t\000e\000x\000t\000<\000/"
literal|"\000d\000o\000c\000>"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_utf16_le_epilog_newline
parameter_list|)
block|{
name|int
name|first_chunk_bytes
init|=
literal|17
decl_stmt|;
name|char
name|text
index|[]
init|=
literal|"\xFF\xFE"
comment|/* BOM */
literal|"<\000e\000/\000>\000"
comment|/* document element */
literal|"\r\000\n\000\r\000\n\000"
decl_stmt|;
comment|/* epilog */
if|if
condition|(
name|first_chunk_bytes
operator|>=
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
condition|)
name|fail
argument_list|(
literal|"bad value of first_chunk_bytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|first_chunk_bytes
argument_list|,
literal|0
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|XML_Status
name|rc
decl_stmt|;
name|rc
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
operator|+
name|first_chunk_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
name|first_chunk_bytes
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #481609. */
name|START_TEST
parameter_list|(
name|test_latin1_umlauts
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<e a='ä ö ü&#228;&#246;&#252;&#x00E4;&#x0F6;&#xFC;'\n"
literal|">ä ö ü&#228;&#246;&#252;&#x00E4;&#x0F6;&#xFC;</e>"
decl_stmt|;
name|char
modifier|*
name|utf8
init|=
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC "
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC "
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|XML_ParserReset
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_attribute_check
argument_list|(
name|text
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #422239 (maybe).    It's not clear that this reproduces enough of the context    of the reported bug. */
name|START_TEST
parameter_list|(
name|test_line_count
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<e>\n"
literal|"<e/>\n"
literal|"</e>"
decl_stmt|;
name|int
name|lineno
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno
operator|!=
literal|3
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"expected 3 lines, saw %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #478332. */
name|START_TEST
parameter_list|(
name|test_really_long_lines
parameter_list|)
block|{
comment|/* This parses an input line longer than INIT_DATA_BUF_SIZE        characters long (defined to be 1024 in xmlparse.c).  We take a        really cheesy approach to building the input buffer, because        this avoids writing bugs in buffer-filling code.     */
name|char
modifier|*
name|text
init|=
literal|"<e>"
comment|/* 64 chars */
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
comment|/* until we have at least 1024 characters on the line: */
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"</e>"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/*  * Element event tests.  */
specifier|static
name|void
name|end_element_event_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_end_element_events
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<a><b><c/></b><d><f/></d></a>"
decl_stmt|;
name|char
modifier|*
name|expected
init|=
literal|"/c/b/f/d/a"
decl_stmt|;
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetEndElementHandler
argument_list|(
name|parser
argument_list|,
name|end_element_event_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckString
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/*  * Attribute tests.  */
comment|/* Helpers used by the following test; this checks any "attr" and "refs"    attributes to make sure whitespace has been normalized.     Return true if whitespace has been normalized in a string, using    the rules for attribute value normalization.  The 'is_cdata' flag    is needed since CDATA attributes don't need to have multiple    whitespace characters collapsed to a single space, while other    attribute data types do.  (Section 3.3.3 of the recommendation.) */
specifier|static
name|int
name|is_whitespace_normalized
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|is_cdata
parameter_list|)
block|{
name|int
name|blanks
init|=
literal|0
decl_stmt|;
name|int
name|at_start
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|blanks
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
literal|'\r'
condition|)
return|return
literal|0
return|;
else|else
block|{
if|if
condition|(
name|at_start
condition|)
block|{
name|at_start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanks
operator|&&
operator|!
name|is_cdata
condition|)
comment|/* illegal leading blanks */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|blanks
operator|>
literal|1
operator|&&
operator|!
name|is_cdata
condition|)
return|return
literal|0
return|;
name|blanks
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|blanks
operator|&&
operator|!
name|is_cdata
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check the attribute whitespace checker: */
end_comment

begin_function
specifier|static
name|void
name|testhelper_is_whitespace_normalized
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|" abc def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|" abc def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc  def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc  def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi "
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\t"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\r"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc\t def"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_attr_contains_normalized_whitespace
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|atts
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
specifier|const
name|XML_Char
modifier|*
name|attrname
init|=
name|atts
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|value
init|=
name|atts
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"attr"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"ents"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"refs"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|is_whitespace_normalized
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"attribute value not normalized: %s='%s'"
argument_list|,
name|attrname
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_attr_whitespace_normalization
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ATTLIST doc\n"
literal|"            attr NMTOKENS #REQUIRED\n"
literal|"            ents ENTITIES #REQUIRED\n"
literal|"            refs IDREFS   #REQUIRED>\n"
literal|"]>\n"
literal|"<doc attr='    a  b c\t\td\te\t' refs=' id-1   \t  id-2\t\t'  \n"
literal|"     ents=' ent-1   \t\r\n"
literal|"            ent-2  '>\n"
literal|"<e id='id-1'/>\n"
literal|"<e id='id-2'/>\n"
literal|"</doc>"
decl_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|check_attr_contains_normalized_whitespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/*  * XML declaration tests.  */
name|START_TEST
parameter_list|(
name|test_xmldecl_misplaced
parameter_list|)
block|{
name|expect_failure
argument_list|(
literal|"\n"
literal|"<?xml version='1.0'?>\n"
literal|"<a/>"
argument_list|,
name|XML_ERROR_MISPLACED_XML_PI
argument_list|,
literal|"failed to report misplaced XML declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #584832. */
specifier|static
name|int
name|UnknownEncodingHandler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encoding
parameter_list|,
name|XML_Encoding
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"unsupported-encoding"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|info
operator|->
name|map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|info
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|release
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_unknown_encoding_internal_entity
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='unsupported-encoding'?>\n"
literal|"<!DOCTYPE test [<!ENTITY foo 'bar'>]>\n"
literal|"<test a='&foo;'/>"
decl_stmt|;
name|XML_SetUnknownEncodingHandler
argument_list|(
name|parser
argument_list|,
name|UnknownEncodingHandler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Test that no error is reported for unknown entities if we don't    read an external subset.  This was fixed in Expat 1.95.5. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_unread_external_subset
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Test that an error is reported for unknown entities if we don't    have an external subset. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_no_external_subset
parameter_list|)
block|{
name|expect_failure
argument_list|(
literal|"<doc>&entity;</doc>"
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity w/out a DTD."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Test that an error is reported for unknown entities if we don't    read an external subset, but have been declared standalone. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_standalone
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='us-ascii' standalone='yes'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity (standalone)."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|int
name|external_entity_loader
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|base
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|systemId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|publicId
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
operator|(
name|char
operator|*
operator|)
name|XML_GetUserData
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|XML_Parser
name|extparser
decl_stmt|;
name|extparser
operator|=
name|XML_ExternalEntityParserCreate
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extparser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Could not create external entity parser."
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|extparser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Test that an error is reported for unknown entities if we have read    an external subset. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_wfc_undeclared_entity_with_external_subset
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='us-ascii'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|char
modifier|*
name|foo_text
init|=
literal|"<!ELEMENT doc (#PCDATA)*>"
decl_stmt|;
name|XML_SetParamEntityParsing
argument_list|(
name|parser
argument_list|,
name|XML_PARAM_ENTITY_PARSING_ALWAYS
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|foo_text
argument_list|)
expr_stmt|;
name|XML_SetExternalEntityRefHandler
argument_list|(
name|parser
argument_list|,
name|external_entity_loader
argument_list|)
expr_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity with DTD."
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_wfc_no_recursive_entity_refs
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ENTITY entity '&#38;entity;'>\n"
literal|"]>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_RECURSIVE_ENTITY_REF
argument_list|,
literal|"Parser did not report recursive entity reference."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/*  * Namespaces tests.  */
specifier|static
name|void
name|namespace_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|parser
operator|=
name|XML_ParserCreateNS
argument_list|(
name|NULL
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Parser not created."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|namespace_teardown
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_teardown
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that an element name and attribute name match the expected values.    The expected values are passed as an array reference of string pointers    provided as the userData argument; the first is the expected    element name, and the second is the expected attribute name. */
end_comment

begin_function
specifier|static
name|void
name|triplet_start_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|elemstr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|userData
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected start string: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|1
index|]
argument_list|,
name|atts
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected attribute string: '%s'"
argument_list|,
name|atts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check that the element name passed to the end-element handler matches    the expected value.  The expected value is passed as the first element    in an array of strings passed as the userData argument. */
end_comment

begin_function
specifier|static
name|void
name|triplet_end_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|elemstr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected end string: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_return_ns_triplet
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<foo:e xmlns:foo='http://expat.sf.net/' bar:a='12'\n"
literal|"       xmlns:bar='http://expat.sf.net/'></foo:e>"
decl_stmt|;
name|char
modifier|*
name|elemstr
index|[]
init|=
block|{
literal|"http://expat.sf.net/ e foo"
block|,
literal|"http://expat.sf.net/ a bar"
block|}
decl_stmt|;
name|XML_SetReturnNSTriplet
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|elemstr
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|triplet_start_checker
argument_list|,
name|triplet_end_checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
specifier|static
name|void
name|overwrite_start_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"start "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|atts
operator|!=
name|NULL
condition|)
block|{
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\nattribute "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
operator|*
name|atts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atts
operator|+=
literal|2
expr_stmt|;
block|}
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overwrite_end_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"end "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_ns_tagname_overwrite_test
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|result
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|overwrite_start_checker
argument_list|,
name|overwrite_end_checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckString
argument_list|(
operator|&
name|storage
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for SF bug #566334. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_ns_tagname_overwrite
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|text
init|=
literal|"<n:e xmlns:n='http://xml.libexpat.org/'>\n"
literal|"<n:f n:attr='foo'/>\n"
literal|"<n:g n:attr2='bar'/>\n"
literal|"</n:e>"
decl_stmt|;
name|char
modifier|*
name|result
init|=
literal|"start http://xml.libexpat.org/ e\n"
literal|"start http://xml.libexpat.org/ f\n"
literal|"attribute http://xml.libexpat.org/ attr\n"
literal|"end http://xml.libexpat.org/ f\n"
literal|"start http://xml.libexpat.org/ g\n"
literal|"attribute http://xml.libexpat.org/ attr2\n"
literal|"end http://xml.libexpat.org/ g\n"
literal|"end http://xml.libexpat.org/ e\n"
decl_stmt|;
name|run_ns_tagname_overwrite_test
argument_list|(
name|text
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #566334. */
name|START_TEST
parameter_list|(
name|test_ns_tagname_overwrite_triplet
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
literal|"<n:e xmlns:n='http://xml.libexpat.org/'>\n"
literal|"<n:f n:attr='foo'/>\n"
literal|"<n:g n:attr2='bar'/>\n"
literal|"</n:e>"
decl_stmt|;
name|char
modifier|*
name|result
init|=
literal|"start http://xml.libexpat.org/ e n\n"
literal|"start http://xml.libexpat.org/ f n\n"
literal|"attribute http://xml.libexpat.org/ attr n\n"
literal|"end http://xml.libexpat.org/ f n\n"
literal|"start http://xml.libexpat.org/ g n\n"
literal|"attribute http://xml.libexpat.org/ attr2 n\n"
literal|"end http://xml.libexpat.org/ g n\n"
literal|"end http://xml.libexpat.org/ e n\n"
decl_stmt|;
name|XML_SetReturnNSTriplet
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|run_ns_tagname_overwrite_test
argument_list|(
name|text
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|Suite
modifier|*
name|make_basic_suite
parameter_list|(
name|void
parameter_list|)
block|{
name|Suite
modifier|*
name|s
init|=
name|suite_create
argument_list|(
literal|"basic"
argument_list|)
decl_stmt|;
name|TCase
modifier|*
name|tc_basic
init|=
name|tcase_create
argument_list|(
literal|"basic tests"
argument_list|)
decl_stmt|;
name|TCase
modifier|*
name|tc_namespace
init|=
name|tcase_create
argument_list|(
literal|"XML namespaces"
argument_list|)
decl_stmt|;
name|suite_add_tcase
argument_list|(
name|s
argument_list|,
name|tc_basic
argument_list|)
expr_stmt|;
name|tcase_add_checked_fixture
argument_list|(
name|tc_basic
argument_list|,
name|basic_setup
argument_list|,
name|basic_teardown
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_nul_byte
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_u0000_char
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf16_be
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf16_le
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_illegal_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf16
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf16_le_epilog_newline
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_latin1_umlauts
argument_list|)
expr_stmt|;
comment|/* Regression test for SF bug #491986. */
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_danish_latin1
argument_list|)
expr_stmt|;
comment|/* Regression test for SF bug #514281. */
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_charref_hexidecimal
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_charref_decimal
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_latin1
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf8_false_rejection
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_line_count
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_really_long_lines
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_end_element_events
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_attr_whitespace_normalization
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_xmldecl_misplaced
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_unknown_encoding_internal_entity
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_unread_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_no_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_standalone
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_with_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_no_recursive_entity_refs
argument_list|)
expr_stmt|;
name|suite_add_tcase
argument_list|(
name|s
argument_list|,
name|tc_namespace
argument_list|)
expr_stmt|;
name|tcase_add_checked_fixture
argument_list|(
name|tc_namespace
argument_list|,
name|namespace_setup
argument_list|,
name|namespace_teardown
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_return_ns_triplet
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_tagname_overwrite
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_tagname_overwrite_triplet
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|forking
init|=
literal|0
decl_stmt|,
name|forking_set
init|=
literal|0
decl_stmt|;
name|int
name|verbosity
init|=
name|CK_NORMAL
decl_stmt|;
name|Suite
modifier|*
name|s
init|=
name|make_basic_suite
argument_list|()
decl_stmt|;
name|SRunner
modifier|*
name|sr
init|=
name|srunner_create
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* run the tests for internal helper functions */
name|testhelper_is_whitespace_normalized
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|opt
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--verbose"
argument_list|)
operator|==
literal|0
condition|)
name|verbosity
operator|=
name|CK_VERBOSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-q"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--quiet"
argument_list|)
operator|==
literal|0
condition|)
name|verbosity
operator|=
name|CK_SILENT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--fork"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|forking
operator|=
literal|1
expr_stmt|;
name|forking_set
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-n"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--no-fork"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|forking
operator|=
literal|0
expr_stmt|;
name|forking_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"runtests: unknown option '%s'\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|forking_set
condition|)
name|srunner_set_fork_status
argument_list|(
name|sr
argument_list|,
name|forking
condition|?
name|CK_FORK
else|:
name|CK_NOFORK
argument_list|)
expr_stmt|;
name|srunner_run_all
argument_list|(
name|sr
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
name|nf
operator|=
name|srunner_ntests_failed
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|srunner_free
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|suite_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|nf
operator|==
literal|0
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|EXIT_FAILURE
return|;
block|}
end_function

end_unit

