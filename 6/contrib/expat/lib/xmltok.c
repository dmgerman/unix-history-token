begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd    See the file COPYING for copying permission. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILED_FROM_DSP
end_ifdef

begin_include
include|#
directive|include
file|"winconfig.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MACOS_CLASSIC
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"macconfig.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<expat_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef COMPILED_FROM_DSP */
end_comment

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"xmltok.h"
end_include

begin_include
include|#
directive|include
file|"nametab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_define
define|#
directive|define
name|IGNORE_SECTION_TOK_VTABLE
value|, PREFIX(ignoreSectionTok)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IGNORE_SECTION_TOK_VTABLE
end_define

begin_comment
comment|/* as nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VTABLE1
define|\
value|{ PREFIX(prologTok), PREFIX(contentTok), \     PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE }, \   { PREFIX(attributeValueTok), PREFIX(entityValueTok) }, \   PREFIX(sameName), \   PREFIX(nameMatchesAscii), \   PREFIX(nameLength), \   PREFIX(skipS), \   PREFIX(getAtts), \   PREFIX(charRefNumber), \   PREFIX(predefinedEntityName), \   PREFIX(updatePosition), \   PREFIX(isPublicId)
end_define

begin_define
define|#
directive|define
name|VTABLE
value|VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)
end_define

begin_define
define|#
directive|define
name|UCS2_GET_NAMING
parameter_list|(
name|pages
parameter_list|,
name|hi
parameter_list|,
name|lo
parameter_list|)
define|\
value|(namingBitmap[(pages[hi]<< 3) + ((lo)>> 5)]& (1<< ((lo)& 0x1F)))
end_define

begin_comment
comment|/* A 2 byte UTF-8 representation splits the characters 11 bits between    the bottom 5 and 6 bits of the bytes.  We need 8 bits to index into    pages, 3 bits to add to that index and 5 bits to generate the mask. */
end_comment

begin_define
define|#
directive|define
name|UTF8_GET_NAMING2
parameter_list|(
name|pages
parameter_list|,
name|byte
parameter_list|)
define|\
value|(namingBitmap[((pages)[(((byte)[0])>> 2)& 7]<< 3) \                       + ((((byte)[0])& 3)<< 1) \                       + ((((byte)[1])>> 5)& 1)] \& (1<< (((byte)[1])& 0x1F)))
end_define

begin_comment
comment|/* A 3 byte UTF-8 representation splits the characters 16 bits between    the bottom 4, 6 and 6 bits of the bytes.  We need 8 bits to index    into pages, 3 bits to add to that index and 5 bits to generate the    mask. */
end_comment

begin_define
define|#
directive|define
name|UTF8_GET_NAMING3
parameter_list|(
name|pages
parameter_list|,
name|byte
parameter_list|)
define|\
value|(namingBitmap[((pages)[((((byte)[0])& 0xF)<< 4) \                              + ((((byte)[1])>> 2)& 0xF)] \<< 3) \                       + ((((byte)[1])& 3)<< 1) \                       + ((((byte)[2])>> 5)& 1)] \& (1<< (((byte)[2])& 0x1F)))
end_define

begin_define
define|#
directive|define
name|UTF8_GET_NAMING
parameter_list|(
name|pages
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|((n) == 2 \   ? UTF8_GET_NAMING2(pages, (const unsigned char *)(p)) \   : ((n) == 3 \      ? UTF8_GET_NAMING3(pages, (const unsigned char *)(p)) \      : 0))
end_define

begin_comment
comment|/* Detection of invalid UTF-8 sequences is based on Table 3.1B    of Unicode 3.2: http://www.unicode.org/unicode/reports/tr28/    with the additional restriction of not allowing the Unicode    code points 0xFFFF and 0xFFFE (sequences EF,BF,BF and EF,BF,BE).    Implementation details:      (A& 0x80) == 0     means A< 0x80    and      (A& 0xC0) == 0xC0  means A> 0xBF */
end_comment

begin_define
define|#
directive|define
name|UTF8_INVALID2
parameter_list|(
name|p
parameter_list|)
define|\
value|((*p)< 0xC2 || ((p)[1]& 0x80) == 0 || ((p)[1]& 0xC0) == 0xC0)
end_define

begin_define
define|#
directive|define
name|UTF8_INVALID3
parameter_list|(
name|p
parameter_list|)
define|\
value|(((p)[2]& 0x80) == 0 \   || \   ((*p) == 0xEF&& (p)[1] == 0xBF \     ? \     (p)[2]> 0xBD \     : \     ((p)[2]& 0xC0) == 0xC0) \   || \   ((*p) == 0xE0 \     ? \     (p)[1]< 0xA0 || ((p)[1]& 0xC0) == 0xC0 \     : \     ((p)[1]& 0x80) == 0 \     || \     ((*p) == 0xED ? (p)[1]> 0x9F : ((p)[1]& 0xC0) == 0xC0)))
end_define

begin_define
define|#
directive|define
name|UTF8_INVALID4
parameter_list|(
name|p
parameter_list|)
define|\
value|(((p)[3]& 0x80) == 0 || ((p)[3]& 0xC0) == 0xC0 \   || \   ((p)[2]& 0x80) == 0 || ((p)[2]& 0xC0) == 0xC0 \   || \   ((*p) == 0xF0 \     ? \     (p)[1]< 0x90 || ((p)[1]& 0xC0) == 0xC0 \     : \     ((p)[1]& 0x80) == 0 \     || \     ((*p) == 0xF4 ? (p)[1]> 0x8F : ((p)[1]& 0xC0) == 0xC0)))
end_define

begin_function
specifier|static
name|int
name|FASTCALL
name|isNever
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isName2
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_GET_NAMING2
argument_list|(
name|namePages
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isName3
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_GET_NAMING3
argument_list|(
name|namePages
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|utf8_isName4
value|isNever
end_define

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isNmstrt2
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_GET_NAMING2
argument_list|(
name|nmstrtPages
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isNmstrt3
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_GET_NAMING3
argument_list|(
name|nmstrtPages
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|utf8_isNmstrt4
value|isNever
end_define

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isInvalid2
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_INVALID2
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isInvalid3
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_INVALID3
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|utf8_isInvalid4
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|UTF8_INVALID4
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|normal_encoding
block|{
name|ENCODING
name|enc
decl_stmt|;
name|unsigned
name|char
name|type
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
name|int
function_decl|(
name|FASTCALL
modifier|*
name|byteType
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isNameMin
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isNmstrtMin
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|byteToAscii
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|charMatches
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* XML_MIN_SIZE */
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isName2
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isName3
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isName4
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isNmstrt2
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isNmstrt3
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isNmstrt4
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isInvalid2
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isInvalid3
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|FASTCALL
modifier|*
name|isInvalid4
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AS_NORMAL_ENCODING
parameter_list|(
name|enc
parameter_list|)
value|((const struct normal_encoding *) (enc))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|STANDARD_VTABLE
parameter_list|(
name|E
parameter_list|)
define|\
value|E ## byteType, \  E ## isNameMin, \  E ## isNmstrtMin, \  E ## byteToAscii, \  E ## charMatches,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STANDARD_VTABLE
parameter_list|(
name|E
parameter_list|)
end_define

begin_comment
comment|/* as nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NORMAL_VTABLE
parameter_list|(
name|E
parameter_list|)
define|\
value|E ## isName2, \  E ## isName3, \  E ## isName4, \  E ## isNmstrt2, \  E ## isNmstrt3, \  E ## isNmstrt4, \  E ## isInvalid2, \  E ## isInvalid3, \  E ## isInvalid4
end_define

begin_function_decl
specifier|static
name|int
name|FASTCALL
name|checkCharRefNumber
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"xmltok_impl.h"
end_include

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|sb_isNameMin
value|isNever
end_define

begin_define
define|#
directive|define
name|sb_isNmstrtMin
value|isNever
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|MINBPC
parameter_list|(
name|enc
parameter_list|)
value|((enc)->minBytesPerChar)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* minimum bytes per character */
end_comment

begin_define
define|#
directive|define
name|MINBPC
parameter_list|(
name|enc
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SB_BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|(((struct normal_encoding *)(enc))->type[(unsigned char)*(p)])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_function
specifier|static
name|int
name|FASTCALL
name|sb_byteType
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|SB_BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->byteType(enc, p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|SB_BYTE_TYPE(enc, p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->byteToAscii(enc, p))
end_define

begin_function
specifier|static
name|int
name|FASTCALL
name|sb_byteToAscii
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
name|p
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|(*(p))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_NAME_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->isName ## n(enc, p))
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->isNmstrt ## n(enc, p))
end_define

begin_define
define|#
directive|define
name|IS_INVALID_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->isInvalid ## n(enc, p))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->isNameMin(enc, p))
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->isNmstrtMin(enc, p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_define
define|#
directive|define
name|CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
define|\
value|(AS_NORMAL_ENCODING(enc)->charMatches(enc, p, c))
end_define

begin_function
specifier|static
name|int
name|FASTCALL
name|sb_charMatches
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
return|return
operator|*
name|p
operator|==
name|c
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* c is an ASCII character */
end_comment

begin_define
define|#
directive|define
name|CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|(*(p) == c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|ident
parameter_list|)
value|normal_ ## ident
end_define

begin_include
include|#
directive|include
file|"xmltok_impl.c"
end_include

begin_undef
undef|#
directive|undef
name|MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TYPE
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TO_ASCII
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MATCHES
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_INVALID_CHAR
end_undef

begin_enum
enum|enum
block|{
comment|/* UTF8_cvalN is value of masked first byte of N byte sequence */
name|UTF8_cval1
init|=
literal|0x00
block|,
name|UTF8_cval2
init|=
literal|0xc0
block|,
name|UTF8_cval3
init|=
literal|0xe0
block|,
name|UTF8_cval4
init|=
literal|0xf0
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|FASTCALL
name|utf8_toUtf8
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|char
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|char
modifier|*
name|toLim
parameter_list|)
block|{
name|char
modifier|*
name|to
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|fromLim
operator|-
operator|*
name|fromP
operator|>
name|toLim
operator|-
operator|*
name|toP
condition|)
block|{
comment|/* Avoid copying partial characters. */
for|for
control|(
name|fromLim
operator|=
operator|*
name|fromP
operator|+
operator|(
name|toLim
operator|-
operator|*
name|toP
operator|)
init|;
name|fromLim
operator|>
operator|*
name|fromP
condition|;
name|fromLim
operator|--
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|fromLim
index|[
operator|-
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
break|break;
block|}
for|for
control|(
name|to
operator|=
operator|*
name|toP
operator|,
name|from
operator|=
operator|*
name|fromP
init|;
name|from
operator|!=
name|fromLim
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
operator|*
name|fromP
operator|=
name|from
expr_stmt|;
operator|*
name|toP
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|utf8_toUtf16
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|unsigned
name|short
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|toLim
parameter_list|)
block|{
name|unsigned
name|short
modifier|*
name|to
init|=
operator|*
name|toP
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
init|=
operator|*
name|fromP
decl_stmt|;
while|while
condition|(
name|from
operator|!=
name|fromLim
operator|&&
name|to
operator|!=
name|toLim
condition|)
block|{
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|normal_encoding
operator|*
operator|)
name|enc
operator|)
operator|->
name|type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|from
index|]
condition|)
block|{
case|case
name|BT_LEAD2
case|:
operator|*
name|to
operator|++
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|from
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|from
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
name|from
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|BT_LEAD3
case|:
operator|*
name|to
operator|++
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|from
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|from
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|from
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
name|from
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|BT_LEAD4
case|:
block|{
name|unsigned
name|long
name|n
decl_stmt|;
if|if
condition|(
name|to
operator|+
literal|1
operator|==
name|toLim
condition|)
goto|goto
name|after
goto|;
name|n
operator|=
operator|(
operator|(
name|from
index|[
literal|0
index|]
operator|&
literal|0x7
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|from
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|from
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|from
index|[
literal|3
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|n
operator|-=
literal|0x10000
expr_stmt|;
name|to
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|n
operator|>>
literal|10
operator|)
operator||
literal|0xD800
argument_list|)
expr_stmt|;
name|to
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|n
operator|&
literal|0x3FF
operator|)
operator||
literal|0xDC00
argument_list|)
expr_stmt|;
name|to
operator|+=
literal|2
expr_stmt|;
name|from
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|after
label|:
operator|*
name|fromP
operator|=
name|from
expr_stmt|;
operator|*
name|toP
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|utf8_encoding_ns
init|=
block|{
block|{
name|VTABLE1
block|,
name|utf8_toUtf8
block|,
name|utf8_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
include|#
directive|include
file|"asciitab.h"
include|#
directive|include
file|"utf8tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
name|NORMAL_VTABLE
argument_list|(
argument|utf8_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|utf8_encoding
init|=
block|{
block|{
name|VTABLE1
block|,
name|utf8_toUtf8
block|,
name|utf8_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"asciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"utf8tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
name|NORMAL_VTABLE
argument_list|(
argument|utf8_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_utf8_encoding_ns
init|=
block|{
block|{
name|VTABLE1
block|,
name|utf8_toUtf8
block|,
name|utf8_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
include|#
directive|include
file|"iasciitab.h"
include|#
directive|include
file|"utf8tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
name|NORMAL_VTABLE
argument_list|(
argument|utf8_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_utf8_encoding
init|=
block|{
block|{
name|VTABLE1
block|,
name|utf8_toUtf8
block|,
name|utf8_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"iasciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"utf8tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
name|NORMAL_VTABLE
argument_list|(
argument|utf8_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|FASTCALL
name|latin1_toUtf8
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|char
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|char
modifier|*
name|toLim
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|fromP
operator|==
name|fromLim
condition|)
break|break;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|fromP
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|toLim
operator|-
operator|*
name|toP
operator|<
literal|2
condition|)
break|break;
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator||
name|UTF8_cval2
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|toP
operator|==
name|toLim
condition|)
break|break;
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
operator|*
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|latin1_toUtf16
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|unsigned
name|short
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|toLim
parameter_list|)
block|{
while|while
condition|(
operator|*
name|fromP
operator|!=
name|fromLim
operator|&&
operator|*
name|toP
operator|!=
name|toLim
condition|)
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|latin1_encoding_ns
init|=
block|{
block|{
name|VTABLE1
block|,
name|latin1_toUtf8
block|,
name|latin1_toUtf16
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
include|#
directive|include
file|"asciitab.h"
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|latin1_encoding
init|=
block|{
block|{
name|VTABLE1
block|,
name|latin1_toUtf8
block|,
name|latin1_toUtf16
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"asciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|FASTCALL
name|ascii_toUtf8
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|char
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|char
modifier|*
name|toLim
parameter_list|)
block|{
while|while
condition|(
operator|*
name|fromP
operator|!=
name|fromLim
operator|&&
operator|*
name|toP
operator|!=
name|toLim
condition|)
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
operator|*
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|ascii_encoding_ns
init|=
block|{
block|{
name|VTABLE1
block|,
name|ascii_toUtf8
block|,
name|latin1_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
include|#
directive|include
file|"asciitab.h"
comment|/* BT_NONXML == 0 */
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|ascii_encoding
init|=
block|{
block|{
name|VTABLE1
block|,
name|ascii_toUtf8
block|,
name|latin1_toUtf16
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"asciitab.h"
undef|#
directive|undef
name|BT_COLON
comment|/* BT_NONXML == 0 */
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|sb_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|FASTCALL
name|unicode_byte_type
parameter_list|(
name|char
name|hi
parameter_list|,
name|char
name|lo
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|hi
condition|)
block|{
case|case
literal|0xD8
case|:
case|case
literal|0xD9
case|:
case|case
literal|0xDA
case|:
case|case
literal|0xDB
case|:
return|return
name|BT_LEAD4
return|;
case|case
literal|0xDC
case|:
case|case
literal|0xDD
case|:
case|case
literal|0xDE
case|:
case|case
literal|0xDF
case|:
return|return
name|BT_TRAIL
return|;
case|case
literal|0xFF
case|:
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|lo
condition|)
block|{
case|case
literal|0xFF
case|:
case|case
literal|0xFE
case|:
return|return
name|BT_NONXML
return|;
block|}
break|break;
block|}
return|return
name|BT_NONASCII
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DEFINE_UTF16_TO_UTF8
parameter_list|(
name|E
parameter_list|)
define|\
value|static void  FASTCALL \ E ## toUtf8(const ENCODING *enc, \             const char **fromP, const char *fromLim, \             char **toP, const char *toLim) \ { \   const char *from; \   for (from = *fromP; from != fromLim; from += 2) { \     int plane; \     unsigned char lo2; \     unsigned char lo = GET_LO(from); \     unsigned char hi = GET_HI(from); \     switch (hi) { \     case 0: \       if (lo< 0x80) { \         if (*toP == toLim) { \           *fromP = from; \           return; \         } \         *(*toP)++ = lo; \         break; \       } \
comment|/* fall through */
value|\     case 0x1: case 0x2: case 0x3: \     case 0x4: case 0x5: case 0x6: case 0x7: \       if (toLim -  *toP< 2) { \         *fromP = from; \         return; \       } \       *(*toP)++ = ((lo>> 6) | (hi<< 2) |  UTF8_cval2); \       *(*toP)++ = ((lo& 0x3f) | 0x80); \       break; \     default: \       if (toLim -  *toP< 3)  { \         *fromP = from; \         return; \       } \
comment|/* 16 bits divided 4, 6, 6 amongst 3 bytes */
value|\       *(*toP)++ = ((hi>> 4) | UTF8_cval3); \       *(*toP)++ = (((hi& 0xf)<< 2) | (lo>> 6) | 0x80); \       *(*toP)++ = ((lo& 0x3f) | 0x80); \       break; \     case 0xD8: case 0xD9: case 0xDA: case 0xDB: \       if (toLim -  *toP< 4) { \         *fromP = from; \         return; \       } \       plane = (((hi& 0x3)<< 2) | ((lo>> 6)& 0x3)) + 1; \       *(*toP)++ = ((plane>> 2) | UTF8_cval4); \       *(*toP)++ = (((lo>> 2)& 0xF) | ((plane& 0x3)<< 4) | 0x80); \       from += 2; \       lo2 = GET_LO(from); \       *(*toP)++ = (((lo& 0x3)<< 4) \                    | ((GET_HI(from)& 0x3)<< 2) \                    | (lo2>> 6) \                    | 0x80); \       *(*toP)++ = ((lo2& 0x3f) | 0x80); \       break; \     } \   } \   *fromP = from; \ }
end_define

begin_define
define|#
directive|define
name|DEFINE_UTF16_TO_UTF16
parameter_list|(
name|E
parameter_list|)
define|\
value|static void  FASTCALL \ E ## toUtf16(const ENCODING *enc, \              const char **fromP, const char *fromLim, \              unsigned short **toP, const unsigned short *toLim) \ { \
comment|/* Avoid copying first half only of surrogate */
value|\   if (fromLim - *fromP> ((toLim - *toP)<< 1) \&& (GET_HI(fromLim - 2)& 0xF8) == 0xD8) \     fromLim -= 2; \   for (; *fromP != fromLim&& *toP != toLim; *fromP += 2) \     *(*toP)++ = (GET_HI(*fromP)<< 8) | GET_LO(*fromP); \ }
end_define

begin_define
define|#
directive|define
name|SET2
parameter_list|(
name|ptr
parameter_list|,
name|ch
parameter_list|)
define|\
value|(((ptr)[0] = ((ch)& 0xff)), ((ptr)[1] = ((ch)>> 8)))
end_define

begin_define
define|#
directive|define
name|GET_LO
parameter_list|(
name|ptr
parameter_list|)
value|((unsigned char)(ptr)[0])
end_define

begin_define
define|#
directive|define
name|GET_HI
parameter_list|(
name|ptr
parameter_list|)
value|((unsigned char)(ptr)[1])
end_define

begin_macro
name|DEFINE_UTF16_TO_UTF8
argument_list|(
argument|little2_
argument_list|)
end_macro

begin_macro
name|DEFINE_UTF16_TO_UTF16
argument_list|(
argument|little2_
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|SET2
end_undef

begin_undef
undef|#
directive|undef
name|GET_LO
end_undef

begin_undef
undef|#
directive|undef
name|GET_HI
end_undef

begin_define
define|#
directive|define
name|SET2
parameter_list|(
name|ptr
parameter_list|,
name|ch
parameter_list|)
define|\
value|(((ptr)[0] = ((ch)>> 8)), ((ptr)[1] = ((ch)& 0xFF)))
end_define

begin_define
define|#
directive|define
name|GET_LO
parameter_list|(
name|ptr
parameter_list|)
value|((unsigned char)(ptr)[1])
end_define

begin_define
define|#
directive|define
name|GET_HI
parameter_list|(
name|ptr
parameter_list|)
value|((unsigned char)(ptr)[0])
end_define

begin_macro
name|DEFINE_UTF16_TO_UTF8
argument_list|(
argument|big2_
argument_list|)
end_macro

begin_macro
name|DEFINE_UTF16_TO_UTF16
argument_list|(
argument|big2_
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|SET2
end_undef

begin_undef
undef|#
directive|undef
name|GET_LO
end_undef

begin_undef
undef|#
directive|undef
name|GET_HI
end_undef

begin_define
define|#
directive|define
name|LITTLE2_BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|((p)[1] == 0 \   ? ((struct normal_encoding *)(enc))->type[(unsigned char)*(p)] \   : unicode_byte_type((p)[1], (p)[0]))
end_define

begin_define
define|#
directive|define
name|LITTLE2_BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|((p)[1] == 0 ? (p)[0] : -1)
end_define

begin_define
define|#
directive|define
name|LITTLE2_CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|((p)[1] == 0&& (p)[0] == c)
end_define

begin_define
define|#
directive|define
name|LITTLE2_IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])
end_define

begin_define
define|#
directive|define
name|LITTLE2_IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_function
specifier|static
name|int
name|FASTCALL
name|little2_byteType
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|LITTLE2_BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|little2_byteToAscii
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|LITTLE2_BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|little2_charMatches
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
return|return
name|LITTLE2_CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|p
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|little2_isNameMin
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|LITTLE2_IS_NAME_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|little2_isNmstrtMin
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|LITTLE2_IS_NMSTRT_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|VTABLE
end_undef

begin_define
define|#
directive|define
name|VTABLE
value|VTABLE1, little2_toUtf8, little2_toUtf16
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not XML_MIN_SIZE */
end_comment

begin_undef
undef|#
directive|undef
name|PREFIX
end_undef

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|ident
parameter_list|)
value|little2_ ## ident
end_define

begin_define
define|#
directive|define
name|MINBPC
parameter_list|(
name|enc
parameter_list|)
value|2
end_define

begin_comment
comment|/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
end_comment

begin_define
define|#
directive|define
name|BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|LITTLE2_BYTE_TYPE(enc, p)
end_define

begin_define
define|#
directive|define
name|BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|LITTLE2_BYTE_TO_ASCII(enc, p)
end_define

begin_define
define|#
directive|define
name|CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|LITTLE2_CHAR_MATCHES(enc, p, c)
end_define

begin_define
define|#
directive|define
name|IS_NAME_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|LITTLE2_IS_NAME_CHAR_MINBPC(enc, p)
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p)
end_define

begin_include
include|#
directive|include
file|"xmltok_impl.c"
end_include

begin_undef
undef|#
directive|undef
name|MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TYPE
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TO_ASCII
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MATCHES
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_INVALID_CHAR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not XML_MIN_SIZE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|little2_encoding_ns
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
if|#
directive|if
name|BYTEORDER
operator|==
literal|1234
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
block|,
block|{
include|#
directive|include
file|"asciitab.h"
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|little2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|little2_encoding
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
if|#
directive|if
name|BYTEORDER
operator|==
literal|1234
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"asciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|little2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|BYTEORDER
operator|!=
literal|4321
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_little2_encoding_ns
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
include|#
directive|include
file|"iasciitab.h"
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|little2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_little2_encoding
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"iasciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|little2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIG2_BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|((p)[0] == 0 \   ? ((struct normal_encoding *)(enc))->type[(unsigned char)(p)[1]] \   : unicode_byte_type((p)[0], (p)[1]))
end_define

begin_define
define|#
directive|define
name|BIG2_BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|((p)[0] == 0 ? (p)[1] : -1)
end_define

begin_define
define|#
directive|define
name|BIG2_CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|((p)[0] == 0&& (p)[1] == c)
end_define

begin_define
define|#
directive|define
name|BIG2_IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])
end_define

begin_define
define|#
directive|define
name|BIG2_IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
define|\
value|UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
end_ifdef

begin_function
specifier|static
name|int
name|FASTCALL
name|big2_byteType
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|BIG2_BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|big2_byteToAscii
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|BIG2_BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|big2_charMatches
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
return|return
name|BIG2_CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|p
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|big2_isNameMin
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|BIG2_IS_NAME_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|big2_isNmstrtMin
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|BIG2_IS_NMSTRT_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|VTABLE
end_undef

begin_define
define|#
directive|define
name|VTABLE
value|VTABLE1, big2_toUtf8, big2_toUtf16
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not XML_MIN_SIZE */
end_comment

begin_undef
undef|#
directive|undef
name|PREFIX
end_undef

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|ident
parameter_list|)
value|big2_ ## ident
end_define

begin_define
define|#
directive|define
name|MINBPC
parameter_list|(
name|enc
parameter_list|)
value|2
end_define

begin_comment
comment|/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
end_comment

begin_define
define|#
directive|define
name|BYTE_TYPE
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|BIG2_BYTE_TYPE(enc, p)
end_define

begin_define
define|#
directive|define
name|BYTE_TO_ASCII
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|BIG2_BYTE_TO_ASCII(enc, p)
end_define

begin_define
define|#
directive|define
name|CHAR_MATCHES
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|)
value|BIG2_CHAR_MATCHES(enc, p, c)
end_define

begin_define
define|#
directive|define
name|IS_NAME_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|IS_NAME_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|BIG2_IS_NAME_CHAR_MINBPC(enc, p)
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|IS_NMSTRT_CHAR_MINBPC
parameter_list|(
name|enc
parameter_list|,
name|p
parameter_list|)
value|BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p)
end_define

begin_include
include|#
directive|include
file|"xmltok_impl.c"
end_include

begin_undef
undef|#
directive|undef
name|MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TYPE
end_undef

begin_undef
undef|#
directive|undef
name|BYTE_TO_ASCII
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MATCHES
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NAME_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_NMSTRT_CHAR_MINBPC
end_undef

begin_undef
undef|#
directive|undef
name|IS_INVALID_CHAR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not XML_MIN_SIZE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|big2_encoding_ns
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
if|#
directive|if
name|BYTEORDER
operator|==
literal|4321
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
block|,
block|{
include|#
directive|include
file|"asciitab.h"
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|big2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|big2_encoding
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
if|#
directive|if
name|BYTEORDER
operator|==
literal|4321
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"asciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|big2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|BYTEORDER
operator|!=
literal|1234
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_big2_encoding_ns
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
include|#
directive|include
file|"iasciitab.h"
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|big2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|normal_encoding
name|internal_big2_encoding
init|=
block|{
block|{
name|VTABLE
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
define|#
directive|define
name|BT_COLON
value|BT_NMSTRT
include|#
directive|include
file|"iasciitab.h"
undef|#
directive|undef
name|BT_COLON
include|#
directive|include
file|"latin1tab.h"
block|}
block|,
name|STANDARD_VTABLE
argument_list|(
argument|big2_
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PREFIX
end_undef

begin_function
specifier|static
name|int
name|FASTCALL
name|streqci
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c1
init|=
operator|*
name|s1
operator|++
decl_stmt|;
name|char
name|c2
init|=
operator|*
name|s2
operator|++
decl_stmt|;
if|if
condition|(
name|ASCII_a
operator|<=
name|c1
operator|&&
name|c1
operator|<=
name|ASCII_z
condition|)
name|c1
operator|+=
name|ASCII_A
operator|-
name|ASCII_a
expr_stmt|;
if|if
condition|(
name|ASCII_a
operator|<=
name|c2
operator|&&
name|c2
operator|<=
name|ASCII_z
condition|)
name|c2
operator|+=
name|ASCII_A
operator|-
name|ASCII_a
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|c1
condition|)
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|initUpdatePosition
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|POSITION
modifier|*
name|pos
parameter_list|)
block|{
name|normal_updatePosition
argument_list|(
operator|&
name|utf8_encoding
operator|.
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|toAscii
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|XmlUtf8Convert
argument_list|(
name|enc
argument_list|,
operator|&
name|ptr
argument_list|,
name|end
argument_list|,
operator|&
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buf
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|isSpace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0x20
case|:
case|case
literal|0xD
case|:
case|case
literal|0xA
case|:
case|case
literal|0x9
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if there's just optional white space or there's an S    followed by name=val. */
end_comment

begin_function
specifier|static
name|int
name|FASTCALL
name|parsePseudoAttribute
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namePtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nameEndPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|valPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
name|open
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
block|{
operator|*
name|namePtr
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|isSpace
argument_list|(
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
do|do
block|{
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
block|}
do|while
condition|(
name|isSpace
argument_list|(
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
argument_list|)
condition|)
do|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
block|{
operator|*
name|namePtr
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|namePtr
operator|=
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
name|ASCII_EQUALS
condition|)
block|{
operator|*
name|nameEndPtr
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isSpace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|nameEndPtr
operator|=
name|ptr
expr_stmt|;
do|do
block|{
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
block|}
do|while
condition|(
name|isSpace
argument_list|(
name|c
operator|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|!=
name|ASCII_EQUALS
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
operator|*
name|namePtr
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
name|c
operator|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
while|while
condition|(
name|isSpace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
name|c
operator|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|ASCII_QUOT
operator|&&
name|c
operator|!=
name|ASCII_APOS
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
name|open
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
operator|*
name|valPtr
operator|=
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
control|)
block|{
name|c
operator|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|open
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|ASCII_a
operator|<=
name|c
operator|&&
name|c
operator|<=
name|ASCII_z
operator|)
operator|&&
operator|!
operator|(
name|ASCII_A
operator|<=
name|c
operator|&&
name|c
operator|<=
name|ASCII_Z
operator|)
operator|&&
operator|!
operator|(
name|ASCII_0
operator|<=
name|c
operator|&&
name|c
operator|<=
name|ASCII_9
operator|)
operator|&&
name|c
operator|!=
name|ASCII_PERIOD
operator|&&
name|c
operator|!=
name|ASCII_MINUS
operator|&&
name|c
operator|!=
name|ASCII_UNDERSCORE
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_version
index|[]
init|=
block|{
name|ASCII_v
block|,
name|ASCII_e
block|,
name|ASCII_r
block|,
name|ASCII_s
block|,
name|ASCII_i
block|,
name|ASCII_o
block|,
name|ASCII_n
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_encoding
index|[]
init|=
block|{
name|ASCII_e
block|,
name|ASCII_n
block|,
name|ASCII_c
block|,
name|ASCII_o
block|,
name|ASCII_d
block|,
name|ASCII_i
block|,
name|ASCII_n
block|,
name|ASCII_g
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_standalone
index|[]
init|=
block|{
name|ASCII_s
block|,
name|ASCII_t
block|,
name|ASCII_a
block|,
name|ASCII_n
block|,
name|ASCII_d
block|,
name|ASCII_a
block|,
name|ASCII_l
block|,
name|ASCII_o
block|,
name|ASCII_n
block|,
name|ASCII_e
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_yes
index|[]
init|=
block|{
name|ASCII_y
block|,
name|ASCII_e
block|,
name|ASCII_s
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_no
index|[]
init|=
block|{
name|ASCII_n
block|,
name|ASCII_o
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|doParseXmlDecl
parameter_list|(
specifier|const
name|ENCODING
modifier|*
function_decl|(
modifier|*
name|encodingFinder
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|int
name|isGeneralTextEntity
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|badPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionEndPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|encodingName
parameter_list|,
specifier|const
name|ENCODING
modifier|*
modifier|*
name|encoding
parameter_list|,
name|int
modifier|*
name|standalone
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|nameEnd
init|=
name|NULL
decl_stmt|;
name|ptr
operator|+=
literal|5
operator|*
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
name|end
operator|-=
literal|2
operator|*
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
if|if
condition|(
operator|!
name|parsePseudoAttribute
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|nameEnd
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|ptr
argument_list|)
operator|||
operator|!
name|name
condition|)
block|{
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|XmlNameMatchesAscii
argument_list|(
name|enc
argument_list|,
name|name
argument_list|,
name|nameEnd
argument_list|,
name|KW_version
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isGeneralTextEntity
condition|)
block|{
operator|*
name|badPtr
operator|=
name|name
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|versionPtr
condition|)
operator|*
name|versionPtr
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|versionEndPtr
condition|)
operator|*
name|versionEndPtr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|parsePseudoAttribute
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|nameEnd
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|name
condition|)
block|{
if|if
condition|(
name|isGeneralTextEntity
condition|)
block|{
comment|/* a TextDecl must have an EncodingDecl */
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|XmlNameMatchesAscii
argument_list|(
name|enc
argument_list|,
name|name
argument_list|,
name|nameEnd
argument_list|,
name|KW_encoding
argument_list|)
condition|)
block|{
name|int
name|c
init|=
name|toAscii
argument_list|(
name|enc
argument_list|,
name|val
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ASCII_a
operator|<=
name|c
operator|&&
name|c
operator|<=
name|ASCII_z
operator|)
operator|&&
operator|!
operator|(
name|ASCII_A
operator|<=
name|c
operator|&&
name|c
operator|<=
name|ASCII_Z
operator|)
condition|)
block|{
operator|*
name|badPtr
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|encodingName
condition|)
operator|*
name|encodingName
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|encoding
condition|)
operator|*
name|encoding
operator|=
name|encodingFinder
argument_list|(
name|enc
argument_list|,
name|val
argument_list|,
name|ptr
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parsePseudoAttribute
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|nameEnd
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|XmlNameMatchesAscii
argument_list|(
name|enc
argument_list|,
name|name
argument_list|,
name|nameEnd
argument_list|,
name|KW_standalone
argument_list|)
operator|||
name|isGeneralTextEntity
condition|)
block|{
operator|*
name|badPtr
operator|=
name|name
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|XmlNameMatchesAscii
argument_list|(
name|enc
argument_list|,
name|val
argument_list|,
name|ptr
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|KW_yes
argument_list|)
condition|)
block|{
if|if
condition|(
name|standalone
condition|)
operator|*
name|standalone
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XmlNameMatchesAscii
argument_list|(
name|enc
argument_list|,
name|val
argument_list|,
name|ptr
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|KW_no
argument_list|)
condition|)
block|{
if|if
condition|(
name|standalone
condition|)
operator|*
name|standalone
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|badPtr
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|isSpace
argument_list|(
name|toAscii
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
argument_list|)
condition|)
name|ptr
operator|+=
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|checkCharRefNumber
parameter_list|(
name|int
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|result
operator|>>
literal|8
condition|)
block|{
case|case
literal|0xD8
case|:
case|case
literal|0xD9
case|:
case|case
literal|0xDA
case|:
case|case
literal|0xDB
case|:
case|case
literal|0xDC
case|:
case|case
literal|0xDD
case|:
case|case
literal|0xDE
case|:
case|case
literal|0xDF
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
if|if
condition|(
name|latin1_encoding
operator|.
name|type
index|[
name|result
index|]
operator|==
name|BT_NONXML
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|0xFF
case|:
if|if
condition|(
name|result
operator|==
literal|0xFFFE
operator|||
name|result
operator|==
literal|0xFFFF
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|XmlUtf8Encode
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
enum|enum
block|{
comment|/* minN is minimum legal resulting value for N byte sequence */
name|min2
init|=
literal|0x80
block|,
name|min3
init|=
literal|0x800
block|,
name|min4
init|=
literal|0x10000
block|}
enum|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|<
name|min2
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|c
operator||
name|UTF8_cval1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|<
name|min3
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator||
name|UTF8_cval2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|c
operator|<
name|min4
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|>>
literal|12
operator|)
operator||
name|UTF8_cval3
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0x110000
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|>>
literal|18
operator|)
operator||
name|UTF8_cval4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|c
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|XmlUtf16Encode
parameter_list|(
name|int
name|charNum
parameter_list|,
name|unsigned
name|short
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|charNum
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|charNum
operator|<
literal|0x10000
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|charNum
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|charNum
operator|<
literal|0x110000
condition|)
block|{
name|charNum
operator|-=
literal|0x10000
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|charNum
operator|>>
literal|10
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|charNum
operator|&
literal|0x3FF
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|unknown_encoding
block|{
name|struct
name|normal_encoding
name|normal
decl_stmt|;
name|int
function_decl|(
modifier|*
name|convert
function_decl|)
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
name|void
modifier|*
name|userData
decl_stmt|;
name|unsigned
name|short
name|utf16
index|[
literal|256
index|]
decl_stmt|;
name|char
name|utf8
index|[
literal|256
index|]
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AS_UNKNOWN_ENCODING
parameter_list|(
name|enc
parameter_list|)
value|((const struct unknown_encoding *) (enc))
end_define

begin_function
name|int
name|XmlSizeOfUnknownEncoding
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|unknown_encoding
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|unknown_isName
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|unknown_encoding
modifier|*
name|uenc
init|=
name|AS_UNKNOWN_ENCODING
argument_list|(
name|enc
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|uenc
operator|->
name|convert
argument_list|(
name|uenc
operator|->
name|userData
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|&
operator|~
literal|0xFFFF
condition|)
return|return
literal|0
return|;
return|return
name|UCS2_GET_NAMING
argument_list|(
name|namePages
argument_list|,
name|c
operator|>>
literal|8
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|unknown_isNmstrt
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|unknown_encoding
modifier|*
name|uenc
init|=
name|AS_UNKNOWN_ENCODING
argument_list|(
name|enc
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|uenc
operator|->
name|convert
argument_list|(
name|uenc
operator|->
name|userData
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|&
operator|~
literal|0xFFFF
condition|)
return|return
literal|0
return|;
return|return
name|UCS2_GET_NAMING
argument_list|(
name|nmstrtPages
argument_list|,
name|c
operator|>>
literal|8
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|unknown_isInvalid
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|unknown_encoding
modifier|*
name|uenc
init|=
name|AS_UNKNOWN_ENCODING
argument_list|(
name|enc
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|uenc
operator|->
name|convert
argument_list|(
name|uenc
operator|->
name|userData
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
operator|(
name|c
operator|&
operator|~
literal|0xFFFF
operator|)
operator|||
name|checkCharRefNumber
argument_list|(
name|c
argument_list|)
operator|<
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|unknown_toUtf8
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|char
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|char
modifier|*
name|toLim
parameter_list|)
block|{
specifier|const
name|struct
name|unknown_encoding
modifier|*
name|uenc
init|=
name|AS_UNKNOWN_ENCODING
argument_list|(
name|enc
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|XML_UTF8_ENCODE_MAX
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|utf8
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|fromP
operator|==
name|fromLim
condition|)
break|break;
name|utf8
operator|=
name|uenc
operator|->
name|utf8
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|fromP
index|]
expr_stmt|;
name|n
operator|=
operator|*
name|utf8
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|int
name|c
init|=
name|uenc
operator|->
name|convert
argument_list|(
name|uenc
operator|->
name|userData
argument_list|,
operator|*
name|fromP
argument_list|)
decl_stmt|;
name|n
operator|=
name|XmlUtf8Encode
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|toLim
operator|-
operator|*
name|toP
condition|)
break|break;
name|utf8
operator|=
name|buf
expr_stmt|;
operator|*
name|fromP
operator|+=
operator|(
name|AS_NORMAL_ENCODING
argument_list|(
name|enc
argument_list|)
operator|->
name|type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|fromP
index|]
operator|-
operator|(
name|BT_LEAD2
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>
name|toLim
operator|-
operator|*
name|toP
condition|)
break|break;
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
block|}
do|do
block|{
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
operator|*
name|utf8
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|unknown_toUtf16
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|unsigned
name|short
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|toLim
parameter_list|)
block|{
specifier|const
name|struct
name|unknown_encoding
modifier|*
name|uenc
init|=
name|AS_UNKNOWN_ENCODING
argument_list|(
name|enc
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|fromP
operator|!=
name|fromLim
operator|&&
operator|*
name|toP
operator|!=
name|toLim
condition|)
block|{
name|unsigned
name|short
name|c
init|=
name|uenc
operator|->
name|utf16
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|fromP
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|short
operator|)
name|uenc
operator|->
name|convert
argument_list|(
name|uenc
operator|->
name|userData
argument_list|,
operator|*
name|fromP
argument_list|)
expr_stmt|;
operator|*
name|fromP
operator|+=
operator|(
name|AS_NORMAL_ENCODING
argument_list|(
name|enc
argument_list|)
operator|->
name|type
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|fromP
index|]
operator|-
operator|(
name|BT_LEAD2
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|fromP
operator|)
operator|++
expr_stmt|;
operator|*
operator|(
operator|*
name|toP
operator|)
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ENCODING
modifier|*
name|XmlInitUnknownEncoding
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
modifier|*
name|table
parameter_list|,
name|int
function_decl|(
modifier|*
name|convert
function_decl|)
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|unknown_encoding
modifier|*
name|e
init|=
name|mem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|normal_encoding
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mem
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|latin1_encoding
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|latin1_encoding
operator|.
name|type
index|[
name|i
index|]
operator|!=
name|BT_OTHER
operator|&&
name|latin1_encoding
operator|.
name|type
index|[
name|i
index|]
operator|!=
name|BT_NONXML
operator|&&
name|table
index|[
name|i
index|]
operator|!=
name|i
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|BT_MALFORM
expr_stmt|;
comment|/* This shouldn't really get used. */
name|e
operator|->
name|utf16
index|[
name|i
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|<
operator|-
literal|4
condition|)
return|return
literal|0
return|;
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|BT_LEAD2
operator|-
operator|(
name|c
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|utf16
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
if|if
condition|(
name|latin1_encoding
operator|.
name|type
index|[
name|c
index|]
operator|!=
name|BT_OTHER
operator|&&
name|latin1_encoding
operator|.
name|type
index|[
name|c
index|]
operator|!=
name|BT_NONXML
operator|&&
name|c
operator|!=
name|i
condition|)
return|return
literal|0
return|;
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|latin1_encoding
operator|.
name|type
index|[
name|c
index|]
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|e
operator|->
name|utf16
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|c
operator|==
literal|0
condition|?
literal|0xFFFF
else|:
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkCharRefNumber
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|BT_NONXML
expr_stmt|;
comment|/* This shouldn't really get used. */
name|e
operator|->
name|utf16
index|[
name|i
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|>
literal|0xFFFF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|UCS2_GET_NAMING
argument_list|(
name|nmstrtPages
argument_list|,
name|c
operator|>>
literal|8
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
condition|)
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|BT_NMSTRT
expr_stmt|;
elseif|else
if|if
condition|(
name|UCS2_GET_NAMING
argument_list|(
name|namePages
argument_list|,
name|c
operator|>>
literal|8
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
condition|)
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|BT_NAME
expr_stmt|;
else|else
name|e
operator|->
name|normal
operator|.
name|type
index|[
name|i
index|]
operator|=
name|BT_OTHER
expr_stmt|;
name|e
operator|->
name|utf8
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|XmlUtf8Encode
argument_list|(
name|c
argument_list|,
name|e
operator|->
name|utf8
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e
operator|->
name|utf16
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|c
expr_stmt|;
block|}
block|}
name|e
operator|->
name|userData
operator|=
name|userData
expr_stmt|;
name|e
operator|->
name|convert
operator|=
name|convert
expr_stmt|;
if|if
condition|(
name|convert
condition|)
block|{
name|e
operator|->
name|normal
operator|.
name|isName2
operator|=
name|unknown_isName
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isName3
operator|=
name|unknown_isName
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isName4
operator|=
name|unknown_isName
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isNmstrt2
operator|=
name|unknown_isNmstrt
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isNmstrt3
operator|=
name|unknown_isNmstrt
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isNmstrt4
operator|=
name|unknown_isNmstrt
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isInvalid2
operator|=
name|unknown_isInvalid
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isInvalid3
operator|=
name|unknown_isInvalid
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|isInvalid4
operator|=
name|unknown_isInvalid
expr_stmt|;
block|}
name|e
operator|->
name|normal
operator|.
name|enc
operator|.
name|utf8Convert
operator|=
name|unknown_toUtf8
expr_stmt|;
name|e
operator|->
name|normal
operator|.
name|enc
operator|.
name|utf16Convert
operator|=
name|unknown_toUtf16
expr_stmt|;
return|return
operator|&
operator|(
name|e
operator|->
name|normal
operator|.
name|enc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If this enumeration is changed, getEncodingIndex and encodings must also be changed. */
end_comment

begin_enum
enum|enum
block|{
name|UNKNOWN_ENC
init|=
operator|-
literal|1
block|,
name|ISO_8859_1_ENC
init|=
literal|0
block|,
name|US_ASCII_ENC
block|,
name|UTF_8_ENC
block|,
name|UTF_16_ENC
block|,
name|UTF_16BE_ENC
block|,
name|UTF_16LE_ENC
block|,
comment|/* must match encodingNames up to here */
name|NO_ENC
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_ISO_8859_1
index|[]
init|=
block|{
name|ASCII_I
block|,
name|ASCII_S
block|,
name|ASCII_O
block|,
name|ASCII_MINUS
block|,
name|ASCII_8
block|,
name|ASCII_8
block|,
name|ASCII_5
block|,
name|ASCII_9
block|,
name|ASCII_MINUS
block|,
name|ASCII_1
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_US_ASCII
index|[]
init|=
block|{
name|ASCII_U
block|,
name|ASCII_S
block|,
name|ASCII_MINUS
block|,
name|ASCII_A
block|,
name|ASCII_S
block|,
name|ASCII_C
block|,
name|ASCII_I
block|,
name|ASCII_I
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_UTF_8
index|[]
init|=
block|{
name|ASCII_U
block|,
name|ASCII_T
block|,
name|ASCII_F
block|,
name|ASCII_MINUS
block|,
name|ASCII_8
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_UTF_16
index|[]
init|=
block|{
name|ASCII_U
block|,
name|ASCII_T
block|,
name|ASCII_F
block|,
name|ASCII_MINUS
block|,
name|ASCII_1
block|,
name|ASCII_6
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_UTF_16BE
index|[]
init|=
block|{
name|ASCII_U
block|,
name|ASCII_T
block|,
name|ASCII_F
block|,
name|ASCII_MINUS
block|,
name|ASCII_1
block|,
name|ASCII_6
block|,
name|ASCII_B
block|,
name|ASCII_E
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KW_UTF_16LE
index|[]
init|=
block|{
name|ASCII_U
block|,
name|ASCII_T
block|,
name|ASCII_F
block|,
name|ASCII_MINUS
block|,
name|ASCII_1
block|,
name|ASCII_6
block|,
name|ASCII_L
block|,
name|ASCII_E
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|FASTCALL
name|getEncodingIndex
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|encodingNames
index|[]
init|=
block|{
name|KW_ISO_8859_1
block|,
name|KW_US_ASCII
block|,
name|KW_UTF_8
block|,
name|KW_UTF_16
block|,
name|KW_UTF_16BE
block|,
name|KW_UTF_16LE
block|,   }
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NO_ENC
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|encodingNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|encodingNames
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streqci
argument_list|(
name|name
argument_list|,
name|encodingNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
return|return
name|UNKNOWN_ENC
return|;
block|}
end_function

begin_comment
comment|/* For binary compatibility, we store the index of the encoding    specified at initialization in the isUtf16 member. */
end_comment

begin_define
define|#
directive|define
name|INIT_ENC_INDEX
parameter_list|(
name|enc
parameter_list|)
value|((int)(enc)->initEnc.isUtf16)
end_define

begin_define
define|#
directive|define
name|SET_INIT_ENC_INDEX
parameter_list|(
name|enc
parameter_list|,
name|i
parameter_list|)
value|((enc)->initEnc.isUtf16 = (char)i)
end_define

begin_comment
comment|/* This is what detects the encoding.  encodingTable maps from    encoding indices to encodings; INIT_ENC_INDEX(enc) is the index of    the external (protocol) specified encoding; state is    XML_CONTENT_STATE if we're parsing an external text entity, and    XML_PROLOG_STATE otherwise. */
end_comment

begin_function
specifier|static
name|int
name|FASTCALL
name|initScan
parameter_list|(
specifier|const
name|ENCODING
modifier|*
modifier|*
name|encodingTable
parameter_list|,
specifier|const
name|INIT_ENCODING
modifier|*
name|enc
parameter_list|,
name|int
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
specifier|const
name|ENCODING
modifier|*
modifier|*
name|encPtr
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
name|encPtr
operator|=
name|enc
operator|->
name|encPtr
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
literal|1
operator|==
name|end
condition|)
block|{
comment|/* only a single byte available for auto-detection */
ifndef|#
directive|ifndef
name|XML_DTD
comment|/* FIXME */
comment|/* a well-formed document entity must have more than one byte */
if|if
condition|(
name|state
operator|!=
name|XML_CONTENT_STATE
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
endif|#
directive|endif
comment|/* so we're parsing an external text entity... */
comment|/* if UTF-16 was externally specified, then we need at least 2 bytes */
switch|switch
condition|(
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
condition|)
block|{
case|case
name|UTF_16_ENC
case|:
case|case
name|UTF_16LE_ENC
case|:
case|case
name|UTF_16BE_ENC
case|:
return|return
name|XML_TOK_PARTIAL
return|;
block|}
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
condition|)
block|{
case|case
literal|0xFE
case|:
case|case
literal|0xFF
case|:
case|case
literal|0xEF
case|:
comment|/* possibly first byte of UTF-8 BOM */
if|if
condition|(
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|ISO_8859_1_ENC
operator|&&
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
break|break;
comment|/* fall through */
case|case
literal|0x00
case|:
case|case
literal|0x3C
case|:
return|return
name|XML_TOK_PARTIAL
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xFEFF
case|:
if|if
condition|(
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|ISO_8859_1_ENC
operator|&&
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
break|break;
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
literal|2
expr_stmt|;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_16BE_ENC
index|]
expr_stmt|;
return|return
name|XML_TOK_BOM
return|;
comment|/* 00 3C is handled in the default case */
case|case
literal|0x3C00
case|:
if|if
condition|(
operator|(
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|UTF_16BE_ENC
operator|||
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|UTF_16_ENC
operator|)
operator|&&
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
break|break;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_16LE_ENC
index|]
expr_stmt|;
return|return
name|XmlTok
argument_list|(
operator|*
name|encPtr
argument_list|,
name|state
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
literal|0xFFFE
case|:
if|if
condition|(
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|ISO_8859_1_ENC
operator|&&
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
break|break;
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
literal|2
expr_stmt|;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_16LE_ENC
index|]
expr_stmt|;
return|return
name|XML_TOK_BOM
return|;
case|case
literal|0xEFBB
case|:
comment|/* Maybe a UTF-8 BOM (EF BB BF) */
comment|/* If there's an explicitly specified (external) encoding          of ISO-8859-1 or some flavour of UTF-16          and this is an external text entity,          don't look for the BOM,          because it might be a legal data.       */
if|if
condition|(
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
block|{
name|int
name|e
init|=
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|ISO_8859_1_ENC
operator|||
name|e
operator|==
name|UTF_16BE_ENC
operator|||
name|e
operator|==
name|UTF_16LE_ENC
operator|||
name|e
operator|==
name|UTF_16_ENC
condition|)
break|break;
block|}
if|if
condition|(
name|ptr
operator|+
literal|2
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|2
index|]
operator|==
literal|0xBF
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
literal|3
expr_stmt|;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_8_ENC
index|]
expr_stmt|;
return|return
name|XML_TOK_BOM
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 0 isn't a legal data character. Furthermore a document            entity can only start with ASCII characters.  So the only            way this can fail to be big-endian UTF-16 if it it's an            external parsed general entity that's labelled as            UTF-16LE.         */
if|if
condition|(
name|state
operator|==
name|XML_CONTENT_STATE
operator|&&
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
operator|==
name|UTF_16LE_ENC
condition|)
break|break;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_16BE_ENC
index|]
expr_stmt|;
return|return
name|XmlTok
argument_list|(
operator|*
name|encPtr
argument_list|,
name|state
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* We could recover here in the case:             - parsing an external entity             - second byte is 0             - no externally specified encoding             - no encoding declaration            by assuming UTF-16LE.  But we don't, because this would mean when            presented just with a single byte, we couldn't reliably determine            whether we needed further bytes.         */
if|if
condition|(
name|state
operator|==
name|XML_CONTENT_STATE
condition|)
break|break;
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|UTF_16LE_ENC
index|]
expr_stmt|;
return|return
name|XmlTok
argument_list|(
operator|*
name|encPtr
argument_list|,
name|state
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
block|}
break|break;
block|}
block|}
operator|*
name|encPtr
operator|=
name|encodingTable
index|[
name|INIT_ENC_INDEX
argument_list|(
name|enc
argument_list|)
index|]
expr_stmt|;
return|return
name|XmlTok
argument_list|(
operator|*
name|encPtr
argument_list|,
name|state
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NS
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|ns
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_include
include|#
directive|include
file|"xmltok_ns.c"
end_include

begin_undef
undef|#
directive|undef
name|NS
end_undef

begin_undef
undef|#
directive|undef
name|ns
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|XML_NS
end_ifdef

begin_define
define|#
directive|define
name|NS
parameter_list|(
name|x
parameter_list|)
value|x ## NS
end_define

begin_define
define|#
directive|define
name|ns
parameter_list|(
name|x
parameter_list|)
value|x ## _ns
end_define

begin_include
include|#
directive|include
file|"xmltok_ns.c"
end_include

begin_undef
undef|#
directive|undef
name|NS
end_undef

begin_undef
undef|#
directive|undef
name|ns
end_undef

begin_function
name|ENCODING
modifier|*
name|XmlInitUnknownEncodingNS
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
modifier|*
name|table
parameter_list|,
name|int
function_decl|(
modifier|*
name|convert
function_decl|)
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
block|{
name|ENCODING
modifier|*
name|enc
init|=
name|XmlInitUnknownEncoding
argument_list|(
name|mem
argument_list|,
name|table
argument_list|,
name|convert
argument_list|,
name|userData
argument_list|)
decl_stmt|;
if|if
condition|(
name|enc
condition|)
operator|(
operator|(
expr|struct
name|normal_encoding
operator|*
operator|)
name|enc
operator|)
operator|->
name|type
index|[
name|ASCII_COLON
index|]
operator|=
name|BT_COLON
expr_stmt|;
return|return
name|enc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_NS */
end_comment

end_unit

