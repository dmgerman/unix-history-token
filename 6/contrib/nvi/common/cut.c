begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cut.c	10.10 (Berkeley) 9/15/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|cb_rotate
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cut --  *	Put a range of lines/columns into a TEXT buffer.  *  * There are two buffer areas, both found in the global structure.  The first  * is the linked list of all the buffers the user has named, the second is the  * unnamed buffer storage.  There is a pointer, too, which is the current  * default buffer, i.e. it may point to the unnamed buffer or a named buffer  * depending on into what buffer the last text was cut.  Logically, in both  * delete and yank operations, if the user names a buffer, the text is cut  * into it.  If it's a delete of information on more than a single line, the  * contents of the numbered buffers are rotated up one, the contents of the  * buffer named '9' are discarded, and the text is cut into the buffer named  * '1'.  The text is always cut into the unnamed buffer.  *  * In all cases, upper-case buffer names are the same as lower-case names,  * with the exception that they cause the buffer to be appended to instead  * of replaced.  Note, however, that if text is appended to a buffer, the  * default buffer only contains the appended text, not the entire contents  * of the buffer.  *  * !!!  * The contents of the default buffer would disappear after most operations  * in historic vi.  It's unclear that this is useful, so we don't bother.  *  * When users explicitly cut text into the numeric buffers, historic vi became  * genuinely strange.  I've never been able to figure out what was supposed to  * happen.  It behaved differently if you deleted text than if you yanked text,  * and, in the latter case, the text was appended to the buffer instead of  * replacing the contents.  Hopefully it's not worth getting right, and here  * we just treat the numeric buffers like any other named buffer.  *  * PUBLIC: int cut __P((SCR *, CHAR_T *, MARK *, MARK *, int));  */
end_comment

begin_function
name|int
name|cut
parameter_list|(
name|sp
parameter_list|,
name|namep
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|namep
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CB
modifier|*
name|cbp
decl_stmt|;
name|CHAR_T
name|name
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|int
name|append
decl_stmt|,
name|copy_one
decl_stmt|,
name|copy_def
decl_stmt|;
comment|/* 	 * If the user specified a buffer, put it there.  (This may require 	 * a copy into the numeric buffers.  We do the copy so that we don't 	 * have to reference count and so we don't have to deal with things 	 * like appends to buffers that are used multiple times.) 	 * 	 * Otherwise, if it's supposed to be put in a numeric buffer (usually 	 * a delete) put it there.  The rules for putting things in numeric 	 * buffers were historically a little strange.  There were three cases. 	 * 	 *	1: Some motions are always line mode motions, which means 	 *	   that the cut always goes into the numeric buffers. 	 *	2: Some motions aren't line mode motions, e.g. d10w, but 	 *	   can cross line boundaries.  For these commands, if the 	 *	   cut crosses a line boundary, it goes into the numeric 	 *	   buffers.  This includes most of the commands. 	 *	3: Some motions aren't line mode motions, e.g. d`<char>, 	 *	   but always go into the numeric buffers, regardless.  This 	 *	   was the commands: % ` / ? ( ) N n { } -- and nvi adds ^A. 	 * 	 * Otherwise, put it in the unnamed buffer. 	 */
name|append
operator|=
name|copy_one
operator|=
name|copy_def
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namep
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
operator|*
name|namep
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|CUT_NUMREQ
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|CUT_NUMOPT
argument_list|)
operator|&&
operator|(
name|LF_ISSET
argument_list|(
name|CUT_LINEMODE
argument_list|)
operator|||
name|fm
operator|->
name|lno
operator|!=
name|tm
operator|->
name|lno
operator|)
condition|)
block|{
name|copy_one
operator|=
literal|1
expr_stmt|;
name|cb_rotate
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|append
operator|=
name|isupper
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|copy_one
condition|)
name|copy_def
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|tolower
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|namecb
label|:
name|CBNAME
argument_list|(
name|sp
argument_list|,
name|cbp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LF_ISSET
argument_list|(
name|CUT_NUMREQ
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|CUT_NUMOPT
argument_list|)
operator|&&
operator|(
name|LF_ISSET
argument_list|(
name|CUT_LINEMODE
argument_list|)
operator|||
name|fm
operator|->
name|lno
operator|!=
name|tm
operator|->
name|lno
operator|)
condition|)
block|{
name|name
operator|=
literal|'1'
expr_stmt|;
name|cb_rotate
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|namecb
goto|;
block|}
else|else
name|cbp
operator|=
operator|&
name|sp
operator|->
name|gp
operator|->
name|dcb_store
expr_stmt|;
name|copyloop
label|:
comment|/* 	 * If this is a new buffer, create it and add it into the list. 	 * Otherwise, if it's not an append, free its current contents. 	 */
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|cbp
argument_list|,
name|CB
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|CB
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|CIRCLEQ_INIT
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sp
operator|->
name|gp
operator|->
name|cutq
argument_list|,
name|cbp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|append
condition|)
block|{
name|text_lfree
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
define|#
directive|define
name|ENTIRE_LINE
value|0
comment|/* In line mode, it's pretty easy, just cut the lines. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|CUT_LINEMODE
argument_list|)
condition|)
block|{
name|cbp
operator|->
name|flags
operator||=
name|CB_LMODE
expr_stmt|;
for|for
control|(
name|lno
operator|=
name|fm
operator|->
name|lno
init|;
name|lno
operator|<=
name|tm
operator|->
name|lno
condition|;
operator|++
name|lno
control|)
if|if
condition|(
name|cut_line
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cbp
argument_list|)
condition|)
goto|goto
name|cut_line_err
goto|;
block|}
else|else
block|{
comment|/* 		 * Get the first line.  A length of 0 causes cut_line 		 * to cut from the MARK to the end of the line. 		 */
if|if
condition|(
name|cut_line
argument_list|(
name|sp
argument_list|,
name|fm
operator|->
name|lno
argument_list|,
name|fm
operator|->
name|cno
argument_list|,
name|fm
operator|->
name|lno
operator|!=
name|tm
operator|->
name|lno
condition|?
name|ENTIRE_LINE
else|:
operator|(
name|tm
operator|->
name|cno
operator|-
name|fm
operator|->
name|cno
operator|)
operator|+
literal|1
argument_list|,
name|cbp
argument_list|)
condition|)
goto|goto
name|cut_line_err
goto|;
comment|/* Get the intermediate lines. */
for|for
control|(
name|lno
operator|=
name|fm
operator|->
name|lno
init|;
operator|++
name|lno
operator|<
name|tm
operator|->
name|lno
condition|;
control|)
if|if
condition|(
name|cut_line
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
name|ENTIRE_LINE
argument_list|,
name|cbp
argument_list|)
condition|)
goto|goto
name|cut_line_err
goto|;
comment|/* Get the last line. */
if|if
condition|(
name|tm
operator|->
name|lno
operator|!=
name|fm
operator|->
name|lno
operator|&&
name|cut_line
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
name|tm
operator|->
name|cno
operator|+
literal|1
argument_list|,
name|cbp
argument_list|)
condition|)
goto|goto
name|cut_line_err
goto|;
block|}
name|append
operator|=
literal|0
expr_stmt|;
comment|/* Only append to the named buffer. */
name|sp
operator|->
name|gp
operator|->
name|dcbp
operator|=
name|cbp
expr_stmt|;
comment|/* Repoint the default buffer on each pass. */
if|if
condition|(
name|copy_one
condition|)
block|{
comment|/* Copy into numeric buffer 1. */
name|name
operator|=
literal|'1'
expr_stmt|;
name|CBNAME
argument_list|(
name|sp
argument_list|,
name|cbp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copy_one
operator|=
literal|0
expr_stmt|;
goto|goto
name|copyloop
goto|;
block|}
if|if
condition|(
name|copy_def
condition|)
block|{
comment|/* Copy into the default buffer. */
name|cbp
operator|=
operator|&
name|sp
operator|->
name|gp
operator|->
name|dcb_store
expr_stmt|;
name|copy_def
operator|=
literal|0
expr_stmt|;
goto|goto
name|copyloop
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cut_line_err
label|:
name|text_lfree
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cb_rotate --  *	Rotate the numbered buffers up one.  */
end_comment

begin_function
specifier|static
name|void
name|cb_rotate
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CB
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|del_cbp
decl_stmt|;
name|del_cbp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cbp
operator|=
name|sp
operator|->
name|gp
operator|->
name|cutq
operator|.
name|lh_first
init|;
name|cbp
operator|!=
name|NULL
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|q
operator|.
name|le_next
control|)
switch|switch
condition|(
name|cbp
operator|->
name|name
condition|)
block|{
case|case
literal|'1'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'5'
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'7'
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'8'
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|cbp
operator|->
name|name
operator|=
literal|'9'
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|del_cbp
operator|=
name|cbp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|del_cbp
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|del_cbp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|text_lfree
argument_list|(
operator|&
name|del_cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|del_cbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * cut_line --  *	Cut a portion of a single line.  *  * PUBLIC: int cut_line __P((SCR *, recno_t, size_t, size_t, CB *));  */
end_comment

begin_function
name|int
name|cut_line
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|fcno
parameter_list|,
name|clen
parameter_list|,
name|cbp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|fcno
decl_stmt|,
name|clen
decl_stmt|;
name|CB
modifier|*
name|cbp
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Get the line. */
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Create a TEXT structure that can hold the entire line. */
if|if
condition|(
operator|(
name|tp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If the line isn't empty and it's not the entire line, 	 * copy the portion we want, and reset the TEXT length. 	 */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
name|clen
operator|=
name|len
operator|-
name|fcno
expr_stmt|;
name|memcpy
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|p
operator|+
name|fcno
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|=
name|clen
expr_stmt|;
block|}
comment|/* Append to the end of the cut buffer. */
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|len
operator|+=
name|tp
operator|->
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cut_close --  *	Discard all cut buffers.  *  * PUBLIC: void cut_close __P((GS *));  */
end_comment

begin_function
name|void
name|cut_close
parameter_list|(
name|gp
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
block|{
name|CB
modifier|*
name|cbp
decl_stmt|;
comment|/* Free cut buffer list. */
while|while
condition|(
operator|(
name|cbp
operator|=
name|gp
operator|->
name|cutq
operator|.
name|lh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|textq
operator|.
name|cqh_first
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|cbp
operator|->
name|textq
condition|)
name|text_lfree
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cbp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
comment|/* Free default cut storage. */
name|cbp
operator|=
operator|&
name|gp
operator|->
name|dcb_store
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|textq
operator|.
name|cqh_first
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|cbp
operator|->
name|textq
condition|)
name|text_lfree
argument_list|(
operator|&
name|cbp
operator|->
name|textq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * text_init --  *	Allocate a new TEXT structure.  *  * PUBLIC: TEXT *text_init __P((SCR *, const char *, size_t, size_t));  */
end_comment

begin_function
name|TEXT
modifier|*
name|text_init
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|,
name|total_len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|total_len
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
name|TEXT
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* ANSI C doesn't define a call to malloc(3) for 0 bytes. */
if|if
condition|(
operator|(
name|tp
operator|->
name|lb_len
operator|=
name|total_len
operator|)
operator|!=
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|CHAR_T
operator|*
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|lb
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|len
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * text_lfree --  *	Free a chain of text structures.  *  * PUBLIC: void text_lfree __P((TEXTH *));  */
end_comment

begin_function
name|void
name|text_lfree
parameter_list|(
name|headp
parameter_list|)
name|TEXTH
modifier|*
name|headp
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
name|headp
operator|->
name|cqh_first
operator|)
operator|!=
operator|(
name|void
operator|*
operator|)
name|headp
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
name|headp
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * text_free --  *	Free a text structure.  *  * PUBLIC: void text_free __P((TEXT *));  */
end_comment

begin_function
name|void
name|text_free
parameter_list|(
name|tp
parameter_list|)
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|tp
operator|->
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tp
operator|->
name|lb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

