begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)v_txt.c	10.87 (Berkeley) 10/13/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|txt_abbrev
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|CHAR_T
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_ai_resolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TEXT
modifier|*
name|txt_backup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXTH
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_dent
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_emark
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_err
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXTH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_fc
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_fc_col
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|,
name|ARGS
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_hex
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_insch
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|CHAR_T
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_isrch
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_map_end
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_map_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_margin
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_nomorech
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_Rresolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXTH
operator|*
operator|,
name|TEXT
operator|*
operator|,
specifier|const
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_resolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXTH
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_showmatch
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_unmap
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor character (space is hard to track on the screen). */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
end_if

begin_undef
undef|#
directive|undef
name|CH_CURSOR
end_undef

begin_define
define|#
directive|define
name|CH_CURSOR
value|'+'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * v_tcmd --  *	Fill a buffer from the terminal for vi.  *  * PUBLIC: int v_tcmd __P((SCR *, VICMD *, ARG_CHAR_T, u_int));  */
end_comment

begin_function
name|int
name|v_tcmd
parameter_list|(
name|sp
parameter_list|,
name|vp
parameter_list|,
name|prompt
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|VICMD
modifier|*
name|vp
decl_stmt|;
name|ARG_CHAR_T
name|prompt
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
comment|/* Normally, we end up where we started. */
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* Initialize the map. */
if|if
condition|(
name|txt_map_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Move to the last line. */
name|sp
operator|->
name|lno
operator|=
name|TMAP
index|[
literal|0
index|]
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* Don't update the modeline for now. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
comment|/* Set the input flags. */
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
operator||
name|TXT_CR
operator||
name|TXT_ESCAPE
operator||
name|TXT_INFOLINE
operator||
name|TXT_MAPINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_ALTWERASE
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_ALTWERASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TTYWERASE
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_TTYWERASE
argument_list|)
expr_stmt|;
comment|/* Do the input thing. */
if|if
condition|(
name|v_txt
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Reenable the modeline updates. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
comment|/* Clean up the map. */
if|if
condition|(
name|txt_map_end
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* Set the cursor to the resulting position. */
name|sp
operator|->
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_map_init  *	Initialize the screen map for colon command-line input.  */
end_comment

begin_function
specifier|static
name|int
name|txt_map_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|SMAP
modifier|*
name|esmp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 		 * Fake like the user is doing input on the last line of the 		 * screen.  This makes all of the scrolling work correctly, 		 * and allows us the use of the vi text editing routines, not 		 * to mention practically infinite length ex commands. 		 * 		 * Save the current location. 		 */
name|vip
operator|->
name|sv_tm_lno
operator|=
name|TMAP
operator|->
name|lno
expr_stmt|;
name|vip
operator|->
name|sv_tm_soff
operator|=
name|TMAP
operator|->
name|soff
expr_stmt|;
name|vip
operator|->
name|sv_tm_coff
operator|=
name|TMAP
operator|->
name|coff
expr_stmt|;
name|vip
operator|->
name|sv_t_maxrows
operator|=
name|sp
operator|->
name|t_maxrows
expr_stmt|;
name|vip
operator|->
name|sv_t_minrows
operator|=
name|sp
operator|->
name|t_minrows
expr_stmt|;
name|vip
operator|->
name|sv_t_rows
operator|=
name|sp
operator|->
name|t_rows
expr_stmt|;
comment|/* 		 * If it's a small screen, TMAP may be small for the screen. 		 * Fix it, filling in fake lines as we go. 		 */
if|if
condition|(
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
name|esmp
operator|=
name|HMAP
operator|+
operator|(
name|sp
operator|->
name|t_maxrows
operator|-
literal|1
operator|)
init|;
name|TMAP
operator|<
name|esmp
condition|;
operator|++
name|TMAP
control|)
block|{
name|TMAP
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|TMAP
index|[
literal|0
index|]
operator|.
name|lno
operator|+
literal|1
expr_stmt|;
name|TMAP
index|[
literal|1
index|]
operator|.
name|coff
operator|=
name|HMAP
operator|->
name|coff
expr_stmt|;
name|TMAP
index|[
literal|1
index|]
operator|.
name|soff
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Build the fake entry. */
name|TMAP
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|TMAP
index|[
literal|0
index|]
operator|.
name|lno
operator|+
literal|1
expr_stmt|;
name|TMAP
index|[
literal|1
index|]
operator|.
name|soff
operator|=
literal|1
expr_stmt|;
name|TMAP
index|[
literal|1
index|]
operator|.
name|coff
operator|=
literal|0
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
operator|&
name|TMAP
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|TMAP
expr_stmt|;
comment|/* Reset the screen information. */
name|sp
operator|->
name|t_rows
operator|=
name|sp
operator|->
name|t_minrows
operator|=
operator|++
name|sp
operator|->
name|t_maxrows
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_map_end  *	Reset the screen map for colon command-line input.  */
end_comment

begin_function
specifier|static
name|int
name|txt_map_end
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* Restore the screen information. */
name|sp
operator|->
name|t_rows
operator|=
name|vip
operator|->
name|sv_t_rows
expr_stmt|;
name|sp
operator|->
name|t_minrows
operator|=
name|vip
operator|->
name|sv_t_minrows
expr_stmt|;
name|sp
operator|->
name|t_maxrows
operator|=
name|vip
operator|->
name|sv_t_maxrows
expr_stmt|;
comment|/* 		 * If it's a small screen, TMAP may be wrong.  Clear any 		 * lines that might have been overwritten. 		 */
if|if
condition|(
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
block|{
for|for
control|(
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|<=
name|sp
operator|->
name|t_maxrows
condition|;
operator|++
name|cnt
control|)
block|{
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|TMAP
operator|=
name|HMAP
operator|+
operator|(
name|sp
operator|->
name|t_rows
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
operator|--
name|TMAP
expr_stmt|;
comment|/* 		 * The map may be wrong if the user entered more than one 		 * (logical) line.  Fix it.  If the user entered a whole 		 * screen, this will be slow, but we probably don't care. 		 */
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
while|while
condition|(
name|vip
operator|->
name|sv_tm_lno
operator|!=
name|TMAP
operator|->
name|lno
operator|||
name|vip
operator|->
name|sv_tm_soff
operator|!=
name|TMAP
operator|->
name|soff
condition|)
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Invalidate the cursor and the line size cache, the line never 	 * really existed.  This fixes bugs where the user searches for 	 * the last line on the screen + 1 and the refresh routine thinks 	 * that's where we just were. 	 */
name|VI_SCR_CFLUSH
argument_list|(
name|vip
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If doing input mapping on the colon command line, may need to unmap  * based on the command.  */
end_comment

begin_define
define|#
directive|define
name|UNMAP_TST
define|\
value|FL_ISSET(ec_flags, EC_MAPINPUT)&& LF_ISSET(TXT_INFOLINE)
end_define

begin_comment
comment|/*   * Internally, we maintain tp->lno and tp->cno, externally, everyone uses  * sp->lno and sp->cno.  Make them consistent as necessary.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_POSITION
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
value|{					\ 	(sp)->lno = (tp)->lno;						\ 	(sp)->cno = (tp)->cno;						\ }
end_define

begin_comment
comment|/*  * v_txt --  *	Vi text input.  *  * PUBLIC: int v_txt __P((SCR *, VICMD *, MARK *,  * PUBLIC:    const char *, size_t, ARG_CHAR_T, recno_t, u_long, u_int32_t));  */
end_comment

begin_function
name|int
name|v_txt
parameter_list|(
name|sp
parameter_list|,
name|vp
parameter_list|,
name|tm
parameter_list|,
name|lp
parameter_list|,
name|len
parameter_list|,
name|prompt
parameter_list|,
name|ai_line
parameter_list|,
name|rcount
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|VICMD
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|tm
decl_stmt|;
comment|/* To MARK. */
specifier|const
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* Input line. */
name|size_t
name|len
decl_stmt|;
comment|/* Input line length. */
name|ARG_CHAR_T
name|prompt
decl_stmt|;
comment|/* Prompt to display. */
name|recno_t
name|ai_line
decl_stmt|;
comment|/* Line number to use for autoindent count. */
name|u_long
name|rcount
decl_stmt|;
comment|/* Replay count. */
name|u_int32_t
name|flags
decl_stmt|;
comment|/* TXT_* flags. */
block|{
name|EVENT
name|ev
decl_stmt|,
modifier|*
name|evp
decl_stmt|;
comment|/* Current event. */
name|EVENT
name|fc
decl_stmt|;
comment|/* File name completion event. */
name|GS
modifier|*
name|gp
decl_stmt|;
name|TEXT
modifier|*
name|ntp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
comment|/* Input text structures. */
name|TEXT
name|ait
decl_stmt|;
comment|/* Autoindent text structure. */
name|TEXT
name|wmt
decl_stmt|;
comment|/* Wrapmargin text structure. */
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|abb_t
name|abb
decl_stmt|;
comment|/* State of abbreviation checks. */
name|carat_t
name|carat
decl_stmt|;
comment|/* State of the "[^0]^D" sequences. */
name|quote_t
name|quote
decl_stmt|;
comment|/* State of quotation. */
name|size_t
name|owrite
decl_stmt|,
name|insert
decl_stmt|;
comment|/* Temporary copies of TEXT fields. */
name|size_t
name|margin
decl_stmt|;
comment|/* Wrapmargin value. */
name|size_t
name|rcol
decl_stmt|;
comment|/* 0-N: insert offset in the replay buffer. */
name|size_t
name|tcol
decl_stmt|;
comment|/* Temporary column. */
name|u_int32_t
name|ec_flags
decl_stmt|;
comment|/* Input mapping flags. */
define|#
directive|define
name|IS_RESTART
value|0x01
comment|/* Reset the incremental search. */
define|#
directive|define
name|IS_RUNNING
value|0x02
comment|/* Incremental search turned on. */
name|u_int8_t
name|is_flags
decl_stmt|;
name|int
name|abcnt
decl_stmt|,
name|ab_turnoff
decl_stmt|;
comment|/* Abbreviation character count, switch. */
name|int
name|filec_redraw
decl_stmt|;
comment|/* Redraw after the file completion routine. */
name|int
name|hexcnt
decl_stmt|;
comment|/* Hex character count. */
name|int
name|showmatch
decl_stmt|;
comment|/* Showmatch set on this character. */
name|int
name|wm_set
decl_stmt|,
name|wm_skip
decl_stmt|;
comment|/* Wrapmargin happened, blank skip flags. */
name|int
name|max
decl_stmt|,
name|tmp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the input flag, so tabs get displayed correctly 	 * and everyone knows that the text buffer is in use. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT
argument_list|)
expr_stmt|;
comment|/* 	 * Get one TEXT structure with some initial buffer space, reusing 	 * the last one if it's big enough.  (All TEXT bookkeeping fields 	 * default to 0 -- text_init() handles this.)  If changing a line, 	 * copy it into the TEXT buffer. 	 */
name|tiqh
operator|=
operator|&
name|sp
operator|->
name|tiq
expr_stmt|;
if|if
condition|(
name|tiqh
operator|->
name|cqh_first
operator|!=
operator|(
name|void
operator|*
operator|)
name|tiqh
condition|)
block|{
name|tp
operator|=
name|tiqh
operator|->
name|cqh_first
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
name|tiqh
operator|||
name|tp
operator|->
name|lb_len
operator|<
name|len
operator|+
literal|32
condition|)
block|{
name|text_lfree
argument_list|(
name|tiqh
argument_list|)
expr_stmt|;
goto|goto
name|newtp
goto|;
block|}
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|offset
operator|=
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|lp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newtp
label|:
if|if
condition|(
operator|(
name|tp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|lp
argument_list|,
name|len
argument_list|,
name|len
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|CIRCLEQ_INSERT_HEAD
argument_list|(
name|tiqh
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Set default termination condition. */
name|tp
operator|->
name|term
operator|=
name|TERM_OK
expr_stmt|;
comment|/* Set the starting line, column. */
name|tp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|tp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * Set the insert and overwrite counts.  If overwriting characters, 	 * do insertion afterward.  If not overwriting characters, assume 	 * doing insertion.  If change is to a mark, emphasize it with an 	 * CH_ENDMARK character. 	 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_OVERWRITE
argument_list|)
condition|)
block|{
name|tp
operator|->
name|owrite
operator|=
operator|(
name|tm
operator|->
name|cno
operator|-
name|tp
operator|->
name|cno
operator|)
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
operator|(
name|len
operator|-
name|tm
operator|->
name|cno
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|insert
operator|=
name|len
operator|-
name|tp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_EMARK
argument_list|)
operator|&&
name|txt_emark
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
name|tm
operator|->
name|cno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Many of the special cases in text input are to handle autoindent 	 * support.  Somebody decided that it would be a good idea if "^^D" 	 * and "0^D" deleted all of the autoindented characters.  In an editor 	 * that takes single character input from the user, this beggars the 	 * imagination.  Note also, "^^D" resets the next lines' autoindent, 	 * but "0^D" doesn't. 	 * 	 * We assume that autoindent only happens on empty lines, so insert 	 * and overwrite will be zero.  If doing autoindent, figure out how 	 * much indentation we need and fill it in.  Update input column and 	 * screen cursor as necessary. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|ai_line
operator|!=
name|OOBLNO
condition|)
block|{
if|if
condition|(
name|v_txt_auto
argument_list|(
name|sp
argument_list|,
name|ai_line
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tp
operator|->
name|cno
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The cc and S commands have a special feature -- leading 		 *<blank> characters are handled as autoindent characters. 		 * Beauty! 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AICHARS
argument_list|)
condition|)
block|{
name|tp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|offset
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* If getting a command buffer from the user, there may be a prompt. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_PROMPT
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|++
index|]
operator|=
name|prompt
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|offset
expr_stmt|;
block|}
comment|/* 	 * If appending after the end-of-line, add a space into the buffer 	 * and move the cursor right.  This space is inserted, i.e. pushed 	 * along, and then deleted when the line is resolved.  Assumes that 	 * the cursor is already positioned at the end of the line.  This 	 * avoids the nastiness of having the cursor reside on a magical 	 * column, i.e. a column that doesn't really exist.  The only down 	 * side is that we may wrap lines or scroll the screen before it's 	 * strictly necessary.  Not a big deal. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
name|CH_CURSOR
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
operator|(
name|void
operator|)
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Historic practice is that the wrapmargin value was a distance 	 * from the RIGHT-HAND margin, not the left.  It's more useful to 	 * us as a distance from the left-hand margin, i.e. the same as 	 * the wraplen value.  The wrapmargin option is historic practice. 	 * Nvi added the wraplen option so that it would be possible to 	 * edit files with consistent margins without knowing the number of 	 * columns in the window. 	 * 	 * XXX 	 * Setting margin causes a significant performance hit.  Normally 	 * we don't update the screen if there are keys waiting, but we 	 * have to if margin is set, otherwise the screen routines don't 	 * know where the cursor is. 	 * 	 * !!! 	 * Abbreviated keys were affected by the wrapmargin option in the 	 * historic 4BSD vi.  Mapped keys were usually, but sometimes not. 	 * See the comment in vi/v_text():set_txt_std for more information. 	 * 	 * !!! 	 * One more special case.  If an inserted<blank> character causes 	 * wrapmargin to split the line, the next user entered character is 	 * discarded if it's a<space> character. 	 */
name|wm_set
operator|=
name|wm_skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_WRAPMARGIN
argument_list|)
condition|)
if|if
condition|(
operator|(
name|margin
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_WRAPMARGIN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|margin
operator|=
name|sp
operator|->
name|cols
operator|-
name|margin
expr_stmt|;
else|else
name|margin
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_WRAPLEN
argument_list|)
expr_stmt|;
else|else
name|margin
operator|=
literal|0
expr_stmt|;
comment|/* Initialize abbreviation checks. */
name|abcnt
operator|=
name|ab_turnoff
operator|=
literal|0
expr_stmt|;
name|abb
operator|=
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_ABBREV
argument_list|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
condition|?
name|AB_INWORD
else|:
name|AB_NOTSET
expr_stmt|;
comment|/* 	 * Set up the dot command.  Dot commands are done by saving the actual 	 * characters and then reevaluating them so that things like wrapmargin 	 * can change between the insert and the replay. 	 * 	 * !!! 	 * Historically, vi did not remap or reabbreviate replayed input.  (It 	 * did beep at you if you changed an abbreviation and then replayed the 	 * input.  We're not that compatible.)  We don't have to do anything to 	 * avoid remapping, as we're not getting characters from the terminal 	 * routines.  Turn the abbreviation check off. 	 * 	 * XXX 	 * It would be nice if we could swallow backspaces and such, but it's 	 * not all that easy to do.  What we can do is turn off the common 	 * error messages during the replay.  Otherwise, when the user enters 	 * an illegal command, e.g., "Ia<erase><erase><erase><erase>b<escape>", 	 * and then does a '.', they get a list of error messages after command 	 * completion. 	 */
name|rcol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
block|{
name|abb
operator|=
name|AB_NOTSET
expr_stmt|;
name|LF_CLR
argument_list|(
name|TXT_RECORD
argument_list|)
expr_stmt|;
block|}
comment|/* Other text input mode setup. */
name|quote
operator|=
name|Q_NOTSET
expr_stmt|;
name|carat
operator|=
name|C_NOTSET
expr_stmt|;
name|FL_INIT
argument_list|(
name|is_flags
argument_list|,
name|LF_ISSET
argument_list|(
name|TXT_SEARCHINCR
argument_list|)
condition|?
name|IS_RESTART
operator||
name|IS_RUNNING
else|:
literal|0
argument_list|)
expr_stmt|;
name|filec_redraw
operator|=
name|hexcnt
operator|=
name|showmatch
operator|=
literal|0
expr_stmt|;
comment|/* Initialize input flags. */
name|ec_flags
operator|=
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
condition|?
name|EC_MAPINPUT
else|:
literal|0
expr_stmt|;
comment|/* Refresh the screen. */
name|UPDATE_POSITION
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If it's dot, just do it now. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
goto|goto
name|replay
goto|;
comment|/* Get an event. */
name|evp
operator|=
operator|&
name|ev
expr_stmt|;
name|next
label|:
if|if
condition|(
name|v_event_get
argument_list|(
name|sp
argument_list|,
name|evp
argument_list|,
literal|0
argument_list|,
name|ec_flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If file completion overwrote part of the screen and nothing else has 	 * been displayed, clean up.  We don't do this as part of the normal 	 * message resolution because we know the user is on the colon command 	 * line and there's no reason to enter explicit characters to continue. 	 */
if|if
condition|(
name|filec_redraw
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
name|filec_redraw
operator|=
literal|0
expr_stmt|;
name|fc
operator|.
name|e_event
operator|=
name|E_REPAINT
expr_stmt|;
name|fc
operator|.
name|e_flno
operator|=
name|vip
operator|->
name|totalcount
operator|>=
name|sp
operator|->
name|rows
condition|?
literal|1
else|:
name|sp
operator|->
name|rows
operator|-
name|vip
operator|->
name|totalcount
expr_stmt|;
name|fc
operator|.
name|e_tlno
operator|=
name|sp
operator|->
name|rows
expr_stmt|;
name|vip
operator|->
name|linecount
operator|=
name|vip
operator|->
name|lcontinue
operator|=
name|vip
operator|->
name|totalcount
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|vs_repaint
argument_list|(
name|sp
argument_list|,
operator|&
name|fc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with all non-character events. */
switch|switch
condition|(
name|evp
operator|->
name|e_event
condition|)
block|{
case|case
name|E_CHARACTER
case|:
break|break;
case|case
name|E_ERR
case|:
case|case
name|E_EOF
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT_FORCE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|E_INTERRUPT
case|:
comment|/* 		 * !!! 		 * Historically,<interrupt> exited the user from text input 		 * mode or cancelled a colon command, and returned to command 		 * mode.  It also beeped the terminal, but that seems a bit 		 * excessive. 		 */
goto|goto
name|k_escape
goto|;
case|case
name|E_REPAINT
case|:
if|if
condition|(
name|vs_repaint
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|next
goto|;
case|case
name|E_WRESIZE
case|:
comment|/*<resize> interrupts the input mode. */
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_WRESIZE
argument_list|)
expr_stmt|;
goto|goto
name|k_escape
goto|;
default|default:
name|v_event_err
argument_list|(
name|sp
argument_list|,
name|evp
argument_list|)
expr_stmt|;
goto|goto
name|k_escape
goto|;
block|}
comment|/* 	 * !!! 	 * If the first character of the input is a nul, replay the previous 	 * input.  (Historically, it's okay to replay non-existent input.) 	 * This was not documented as far as I know, and is a great test of vi 	 * clones. 	 */
if|if
condition|(
name|rcol
operator|==
literal|0
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
operator|&&
name|evp
operator|->
name|e_c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|vip
operator|->
name|rep
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|abb
operator|=
name|AB_NOTSET
expr_stmt|;
name|LF_CLR
argument_list|(
name|TXT_RECORD
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_REPLAY
argument_list|)
expr_stmt|;
goto|goto
name|replay
goto|;
block|}
comment|/* 	 * File name completion and colon command-line editing.   We don't 	 * have enough meta characters, so we expect people to overload 	 * them.  If the two characters are the same, then we do file name 	 * completion if the cursor is past the first column, and do colon 	 * command-line editing if it's not. 	 */
if|if
condition|(
name|quote
operator|==
name|Q_NOTSET
condition|)
block|{
name|int
name|L__cedit
decl_stmt|,
name|L__filec
decl_stmt|;
name|L__cedit
operator|=
name|L__filec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_CEDIT
argument_list|)
operator|&&
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_CEDIT
argument_list|)
operator|!=
name|NULL
operator|&&
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_CEDIT
argument_list|)
index|[
literal|0
index|]
operator|==
name|evp
operator|->
name|e_c
condition|)
name|L__cedit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_FILEC
argument_list|)
operator|&&
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_FILEC
argument_list|)
operator|!=
name|NULL
operator|&&
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_FILEC
argument_list|)
index|[
literal|0
index|]
operator|==
name|evp
operator|->
name|e_c
condition|)
name|L__filec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|L__cedit
operator|==
literal|1
operator|&&
operator|(
name|L__filec
operator|==
literal|0
operator|||
name|tp
operator|->
name|cno
operator|==
name|tp
operator|->
name|offset
operator|)
condition|)
block|{
name|tp
operator|->
name|term
operator|=
name|TERM_CEDIT
expr_stmt|;
goto|goto
name|k_escape
goto|;
block|}
if|if
condition|(
name|L__filec
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|txt_fc
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|filec_redraw
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|resolve
goto|;
block|}
block|}
comment|/* Abbreviation overflow check.  See comment in txt_abbrev(). */
define|#
directive|define
name|MAX_ABBREVIATION_EXPANSION
value|256
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|evp
operator|->
name|e_ch
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|abcnt
operator|>
name|MAX_ABBREVIATION_EXPANSION
condition|)
block|{
if|if
condition|(
name|v_event_flush
argument_list|(
name|sp
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"191|Abbreviation exceeded expansion limit: characters discarded"
argument_list|)
expr_stmt|;
name|abcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
goto|goto
name|done
goto|;
goto|goto
name|resolve
goto|;
block|}
block|}
else|else
name|abcnt
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if the character fits into the replay buffers. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
block|{
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|rep
argument_list|,
name|vip
operator|->
name|rep_len
argument_list|,
operator|(
name|rcol
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EVENT
argument_list|)
argument_list|)
expr_stmt|;
name|vip
operator|->
name|rep
index|[
name|rcol
operator|++
index|]
operator|=
operator|*
name|evp
expr_stmt|;
block|}
name|replay
label|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
name|evp
operator|=
name|vip
operator|->
name|rep
operator|+
name|rcol
operator|++
expr_stmt|;
comment|/* Wrapmargin check for leading space. */
if|if
condition|(
name|wm_skip
condition|)
block|{
name|wm_skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evp
operator|->
name|e_c
operator|==
literal|' '
condition|)
goto|goto
name|resolve
goto|;
block|}
comment|/* If quoted by someone else, simply insert the character. */
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|evp
operator|->
name|e_ch
argument_list|,
name|CH_QUOTED
argument_list|)
condition|)
goto|goto
name|insq_ch
goto|;
comment|/* 	 * !!! 	 * If this character was quoted by a K_VLNEXT or a backslash, replace 	 * the placeholder (a carat or a backslash) with the new character. 	 * If it was quoted by a K_VLNEXT, we've already adjusted the cursor 	 * because it has to appear on top of the placeholder character.  If 	 * it was quoted by a backslash, adjust the cursor now, the cursor 	 * doesn't appear on top of it.  Historic practice in both cases. 	 * 	 * Skip tests for abbreviations; ":ab xa XA" followed by "ixa^V<space>" 	 * doesn't perform an abbreviation.  Special case, ^V^J (not ^V^M) is 	 * the same as ^J, historically. 	 */
if|if
condition|(
name|quote
operator|==
name|Q_BTHIS
operator|||
name|quote
operator|==
name|Q_VTHIS
condition|)
block|{
name|FL_CLR
argument_list|(
name|ec_flags
argument_list|,
name|EC_QUOTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
condition|)
name|FL_SET
argument_list|(
name|ec_flags
argument_list|,
name|EC_MAPINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
operator|==
name|Q_BTHIS
operator|&&
operator|(
name|evp
operator|->
name|e_value
operator|==
name|K_VERASE
operator|||
name|evp
operator|->
name|e_value
operator|==
name|K_VKILL
operator|)
condition|)
block|{
name|quote
operator|=
name|Q_NOTSET
expr_stmt|;
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
goto|goto
name|insl_ch
goto|;
block|}
if|if
condition|(
name|quote
operator|==
name|Q_VTHIS
operator|&&
name|evp
operator|->
name|e_value
operator|!=
name|K_NL
condition|)
block|{
name|quote
operator|=
name|Q_NOTSET
expr_stmt|;
goto|goto
name|insl_ch
goto|;
block|}
name|quote
operator|=
name|Q_NOTSET
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Translate "<CH_HEX>[isxdigit()]*" to a character with a hex value: 	 * this test delimits the value by any non-hex character.  Offset by 	 * one, we use 0 to mean that we've found<CH_HEX>. 	 */
if|if
condition|(
name|hexcnt
operator|>
literal|1
operator|&&
operator|!
name|isxdigit
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
condition|)
block|{
name|hexcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txt_hex
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|evp
operator|->
name|e_value
condition|)
block|{
case|case
name|K_CR
case|:
comment|/* Carriage return. */
case|case
name|K_NL
case|:
comment|/* New line. */
comment|/* Return in script windows and the command line. */
name|k_cr
label|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_CR
argument_list|)
condition|)
block|{
comment|/* 			 * If this was a map, we may have not displayed 			 * the line.  Display it, just in case. 			 * 			 * If a script window and not the colon line, 			 * push a<cr> so it gets executed. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCRIPT
argument_list|)
condition|)
operator|(
name|void
operator|)
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|,
name|CH_NOMAP
argument_list|)
expr_stmt|;
comment|/* Set term condition: if empty. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
name|tp
operator|->
name|term
operator|=
name|TERM_CR
expr_stmt|;
comment|/* 			 * Set term condition: if searching incrementally and 			 * the user entered a pattern, return a completed 			 * search, regardless if the entire pattern was found. 			 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
operator|&&
name|tp
operator|->
name|cno
operator|>=
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
name|tp
operator|->
name|term
operator|=
name|TERM_SEARCH
expr_stmt|;
goto|goto
name|k_escape
goto|;
block|}
define|#
directive|define
name|LINE_RESOLVE
value|{							\
comment|/*							\ 		 * Handle abbreviations.  If there was one, discard the	\ 		 * replay characters.					\ 		 */
value|\ 		if (abb == AB_INWORD&&					\ 		    !LF_ISSET(TXT_REPLAY)&& F_ISSET(gp, G_ABBREV)) {	\ 			if (txt_abbrev(sp, tp,&evp->e_c,		\ 			    LF_ISSET(TXT_INFOLINE),&tmp,		\&ab_turnoff))				\ 				goto err;				\ 			if (tmp) {					\ 				if (LF_ISSET(TXT_RECORD))		\ 					rcol -= tmp + 1;		\ 				goto resolve;				\ 			}						\ 		}							\ 		if (abb != AB_NOTSET)					\ 			abb = AB_NOTWORD;				\ 		if (UNMAP_TST)						\ 			txt_unmap(sp, tp,&ec_flags);			\
comment|/*							\ 		 * Delete any appended cursor.  It's possible to get in	\ 		 * situations where TXT_APPENDEOL is set but tp->insert	\ 		 * is 0 when using the R command and all the characters	\ 		 * are tp->owrite characters.				\ 		 */
value|\ 		if (LF_ISSET(TXT_APPENDEOL)&& tp->insert> 0) {	\ 			--tp->len;					\ 			--tp->insert;					\ 		}							\ }
name|LINE_RESOLVE
expr_stmt|;
comment|/* 		 * Save the current line information for restoration in 		 * txt_backup(), and set the line final length. 		 */
name|tp
operator|->
name|sv_len
operator|=
name|tp
operator|->
name|len
expr_stmt|;
name|tp
operator|->
name|sv_cno
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|len
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
comment|/* Update the old line. */
if|if
condition|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historic practice, when the autoindent edit option was set, 		 * was to delete<blank> characters following the inserted 		 * newline.  This affected the 'R', 'c', and 's' commands; 'c' 		 * and 's' retained the insert characters only, 'R' moved the 		 * overwrite and insert characters into the next TEXT structure. 		 * We keep track of the number of characters erased for the 'R' 		 * command so that the final resolution of the line is correct. 		 */
name|tp
operator|->
name|R_erase
operator|=
literal|0
expr_stmt|;
name|owrite
operator|=
name|tp
operator|->
name|owrite
expr_stmt|;
name|insert
operator|=
name|tp
operator|->
name|insert
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLACE
argument_list|)
operator|&&
name|owrite
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
init|;
name|owrite
operator|>
literal|0
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
operator|,
operator|--
name|owrite
operator|,
operator|++
name|tp
operator|->
name|R_erase
control|)
empty_stmt|;
if|if
condition|(
name|owrite
operator|==
literal|0
condition|)
for|for
control|(
init|;
name|insert
operator|>
literal|0
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
operator|,
operator|++
name|tp
operator|->
name|R_erase
operator|,
operator|--
name|insert
control|)
empty_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|owrite
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOINDENT
argument_list|)
condition|)
for|for
control|(
init|;
name|insert
operator|>
literal|0
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
operator|,
operator|--
name|insert
control|)
empty_stmt|;
name|owrite
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * !!! 		 * Create a new line and insert the new TEXT into the queue. 		 * DON'T insert until the old line has been updated, or the 		 * inserted line count in line.c:db_get() will be wrong. 		 */
if|if
condition|(
operator|(
name|ntp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|insert
operator|+
name|owrite
argument_list|,
name|insert
operator|+
name|owrite
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|ntp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Set up bookkeeping for the new line. */
name|ntp
operator|->
name|insert
operator|=
name|insert
expr_stmt|;
name|ntp
operator|->
name|owrite
operator|=
name|owrite
expr_stmt|;
name|ntp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Reset the autoindent line value.  0^D keeps the autoindent 		 * line from changing, ^D changes the level, even if there were 		 * no characters in the old line.  Note, if using the current 		 * tp structure, use the cursor as the length, the autoindent 		 * characters may have been erased. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|carat
operator|==
name|C_NOCHANGE
condition|)
block|{
if|if
condition|(
name|v_txt_auto
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
operator|&
name|ait
argument_list|,
name|ait
operator|.
name|ai
argument_list|,
name|ntp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|ait
operator|.
name|lb
argument_list|,
name|ait
operator|.
name|lb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v_txt_auto
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|cno
argument_list|,
name|ntp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|carat
operator|=
name|C_NOTSET
expr_stmt|;
block|}
comment|/* Reset the cursor. */
name|ntp
operator|->
name|cno
operator|=
name|ntp
operator|->
name|ai
expr_stmt|;
comment|/* 		 * If we're here because wrapmargin was set and we've broken a 		 * line, there may be additional information (i.e. the start of 		 * a line) in the wmt structure. 		 */
if|if
condition|(
name|wm_set
condition|)
block|{
if|if
condition|(
name|wmt
operator|.
name|offset
operator|!=
literal|0
operator|||
name|wmt
operator|.
name|owrite
operator|!=
literal|0
operator|||
name|wmt
operator|.
name|insert
operator|!=
literal|0
condition|)
block|{
define|#
directive|define
name|WMTSPACE
value|wmt.offset + wmt.owrite + wmt.insert
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|ntp
operator|->
name|lb
argument_list|,
name|ntp
operator|->
name|lb_len
argument_list|,
name|ntp
operator|->
name|len
operator|+
name|WMTSPACE
operator|+
literal|32
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ntp
operator|->
name|lb
operator|+
name|ntp
operator|->
name|cno
argument_list|,
name|wmt
operator|.
name|lb
argument_list|,
name|WMTSPACE
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|len
operator|+=
name|WMTSPACE
expr_stmt|;
name|ntp
operator|->
name|cno
operator|+=
name|wmt
operator|.
name|offset
expr_stmt|;
name|ntp
operator|->
name|owrite
operator|=
name|wmt
operator|.
name|owrite
expr_stmt|;
name|ntp
operator|->
name|insert
operator|=
name|wmt
operator|.
name|insert
expr_stmt|;
block|}
name|wm_set
operator|=
literal|0
expr_stmt|;
block|}
comment|/* New lines are TXT_APPENDEOL. */
if|if
condition|(
name|ntp
operator|->
name|owrite
operator|==
literal|0
operator|&&
name|ntp
operator|->
name|insert
operator|==
literal|0
condition|)
block|{
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|ntp
operator|->
name|lb
argument_list|,
name|ntp
operator|->
name|lb_len
argument_list|,
name|ntp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|lb
index|[
name|ntp
operator|->
name|cno
index|]
operator|=
name|CH_CURSOR
expr_stmt|;
operator|++
name|ntp
operator|->
name|insert
expr_stmt|;
operator|++
name|ntp
operator|->
name|len
expr_stmt|;
block|}
comment|/* Swap old and new TEXT's, and update the new line. */
name|tp
operator|=
name|ntp
expr_stmt|;
if|if
condition|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_INSERT
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|resolve
goto|;
case|case
name|K_ESCAPE
case|:
comment|/* Escape. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_ESCAPE
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
comment|/* If we have a count, start replaying the input. */
if|if
condition|(
name|rcount
operator|>
literal|1
condition|)
block|{
operator|--
name|rcount
expr_stmt|;
name|rcol
operator|=
literal|0
expr_stmt|;
name|abb
operator|=
name|AB_NOTSET
expr_stmt|;
name|LF_CLR
argument_list|(
name|TXT_RECORD
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_REPLAY
argument_list|)
expr_stmt|;
comment|/* 			 * Some commands (e.g. 'o') need a<newline> for each 			 * repetition. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_ADDNEWLINE
argument_list|)
condition|)
goto|goto
name|k_cr
goto|;
comment|/* 			 * The R command turns into the 'a' command after the 			 * first repetition. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLACE
argument_list|)
condition|)
block|{
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|owrite
expr_stmt|;
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
name|LF_CLR
argument_list|(
name|TXT_REPLACE
argument_list|)
expr_stmt|;
block|}
goto|goto
name|replay
goto|;
block|}
comment|/* Set term condition: if empty. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
name|tp
operator|->
name|term
operator|=
name|TERM_ESC
expr_stmt|;
comment|/* 		 * Set term condition: if searching incrementally and the user 		 * entered a pattern, return a completed search, regardless if 		 * the entire pattern was found. 		 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
operator|&&
name|tp
operator|->
name|cno
operator|>=
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
name|tp
operator|->
name|term
operator|=
name|TERM_SEARCH
expr_stmt|;
name|k_escape
label|:
name|LINE_RESOLVE
expr_stmt|;
comment|/* 		 * Clean up for the 'R' command, restoring overwrite 		 * characters, and making them into insert characters. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLACE
argument_list|)
condition|)
name|txt_Rresolve
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|tp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * If there are any overwrite characters, copy down 		 * any insert characters, and decrement the length. 		 */
if|if
condition|(
name|tp
operator|->
name|owrite
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|tp
operator|->
name|owrite
expr_stmt|;
block|}
comment|/* 		 * Optionally resolve the lines into the file.  If not 		 * resolving the lines into the file, end the line with 		 * a nul.  If the line is empty, then set the length to 		 * 0, the termination condition has already been set. 		 * 		 * XXX 		 * This is wrong, should pass back a length. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RESOLVE
argument_list|)
condition|)
block|{
if|if
condition|(
name|txt_resolve
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 		 * Set the return cursor position to rest on the last 		 * inserted character. 		 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|!=
literal|0
condition|)
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
comment|/* Update the last line. */
if|if
condition|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|done
goto|;
case|case
name|K_CARAT
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
name|carat
operator|=
name|C_CARATSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_ZERO
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
name|carat
operator|=
name|C_ZEROSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_CNTRLD
case|:
comment|/* Delete autoindent char. */
comment|/* 		 * If in the first column or no characters to erase, ignore 		 * the ^D (this matches historic practice).  If not doing 		 * autoindent or already inserted non-ai characters, it's a 		 * literal.  The latter test is done in the switch, as the 		 * CARAT forms are N + 1, not N. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
literal|0
condition|)
goto|goto
name|resolve
goto|;
switch|switch
condition|(
name|carat
condition|)
block|{
case|case
name|C_CARATSET
case|:
comment|/* ^^D */
if|if
condition|(
name|tp
operator|->
name|ai
operator|==
literal|0
operator|||
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
comment|/* Save the ai string for later. */
name|ait
operator|.
name|lb
operator|=
name|NULL
expr_stmt|;
name|ait
operator|.
name|lb_len
operator|=
literal|0
expr_stmt|;
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|ait
operator|.
name|lb
argument_list|,
name|ait
operator|.
name|lb_len
argument_list|,
name|tp
operator|->
name|ai
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ait
operator|.
name|lb
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|ai
argument_list|)
expr_stmt|;
name|ait
operator|.
name|ai
operator|=
name|ait
operator|.
name|len
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
name|carat
operator|=
name|C_NOCHANGE
expr_stmt|;
goto|goto
name|leftmargin
goto|;
case|case
name|C_ZEROSET
case|:
comment|/* 0^D */
if|if
condition|(
name|tp
operator|->
name|ai
operator|==
literal|0
operator|||
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
name|carat
operator|=
name|C_NOTSET
expr_stmt|;
name|leftmargin
label|:
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|tp
operator|->
name|cno
operator|-
name|tp
operator|->
name|offset
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|cno
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|C_NOTSET
case|:
comment|/* ^D */
if|if
condition|(
name|tp
operator|->
name|ai
operator|==
literal|0
operator|||
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
condition|)
goto|goto
name|ins_ch
goto|;
operator|(
name|void
operator|)
name|txt_dent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|K_VERASE
case|:
comment|/* Erase the last character. */
comment|/* If can erase over the prompt, return. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_BS
argument_list|)
condition|)
block|{
name|tp
operator|->
name|term
operator|=
name|TERM_BS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * If at the beginning of the line, try and drop back to a 		 * previously inserted line. 		 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|tp
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
break|break;
block|}
comment|/* If nothing to erase, bell the user. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
name|txt_nomorech
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Drop back one character. */
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
comment|/* 		 * Historically, vi didn't replace the erased characters with 		 *<blank>s, presumably because it's easier to fix a minor 		 * typing mistake and continue on if the previous letters are 		 * already there.  This is a problem for incremental searching, 		 * because the user can no longer tell where they are in the 		 * colon command line because the cursor is at the last search 		 * point in the screen.  So, if incrementally searching, erase 		 * the erased characters from the screen. 		 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* 		 * Increment overwrite, decrement ai if deleted. 		 * 		 * !!! 		 * Historic vi did not permit users to use erase characters 		 * to delete autoindent characters.  We do.  Eat hot death, 		 * POSIX. 		 */
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|cno
operator|<
name|tp
operator|->
name|ai
condition|)
operator|--
name|tp
operator|->
name|ai
expr_stmt|;
comment|/* Reset if we deleted an incremental search character. */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|FL_SET
argument_list|(
name|is_flags
argument_list|,
name|IS_RESTART
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_VWERASE
case|:
comment|/* Skip back one word. */
comment|/* 		 * If at the beginning of the line, try and drop back to a 		 * previously inserted line. 		 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|tp
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* 		 * If at offset, nothing to erase so bell the user. 		 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
name|txt_nomorech
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The first werase goes back to any autoindent column and the 		 * second werase goes back to the offset. 		 * 		 * !!! 		 * Historic vi did not permit users to use erase characters to 		 * delete autoindent characters. 		 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
block|}
comment|/* Skip over trailing space characters. */
while|while
condition|(
name|tp
operator|->
name|cno
operator|>
name|max
operator|&&
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
name|max
condition|)
break|break;
comment|/* 		 * There are three types of word erase found on UNIX systems. 		 * They can be identified by how the string /a/b/c is treated 		 * -- as 1, 3, or 6 words.  Historic vi had two classes of 		 * characters, and strings were delimited by them and 		 *<blank>'s, so, 6 words.  The historic tty interface used 		 *<blank>'s to delimit strings, so, 1 word.  The algorithm 		 * offered in the 4.4BSD tty interface (as stty altwerase) 		 * treats it as 3 words -- there are two classes of 		 * characters, and strings are delimited by them and 		 *<blank>'s.  The difference is that the type of the first 		 * erased character erased is ignored, which is exactly right 		 * when erasing pathname components.  The edit options 		 * TXT_ALTWERASE and TXT_TTYWERASE specify the 4.4BSD tty 		 * interface and the historic tty driver behavior, 		 * respectively, and the default is the same as the historic 		 * vi behavior. 		 * 		 * Overwrite erased characters if doing incremental search; 		 * see comment above. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_TTYWERASE
argument_list|)
condition|)
while|while
condition|(
name|tp
operator|->
name|cno
operator|>
name|max
condition|)
block|{
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_ALTWERASE
argument_list|)
condition|)
block|{
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|cno
operator|>
name|max
condition|)
name|tmp
operator|=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|cno
operator|>
name|max
condition|)
block|{
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Reset if we deleted an incremental search character. */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|FL_SET
argument_list|(
name|is_flags
argument_list|,
name|IS_RESTART
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_VKILL
case|:
comment|/* Restart this line. */
comment|/* 		 * !!! 		 * If at the beginning of the line, try and drop back to a 		 * previously inserted line.  Historic vi did not permit 		 * users to go back to previous lines. 		 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
name|tp
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* If at offset, nothing to erase so bell the user. */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
name|txt_nomorech
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * First kill goes back to any autoindent and second kill goes 		 * back to the offset. 		 * 		 * !!! 		 * Historic vi did not permit users to use erase characters to 		 * delete autoindent characters. 		 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
block|}
name|tp
operator|->
name|owrite
operator|+=
name|tp
operator|->
name|cno
operator|-
name|max
expr_stmt|;
comment|/* 		 * Overwrite erased characters if doing incremental search; 		 * see comment above. 		 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
do|do
block|{
name|tp
operator|->
name|lb
index|[
operator|--
name|tp
operator|->
name|cno
index|]
operator|=
literal|' '
expr_stmt|;
block|}
do|while
condition|(
name|tp
operator|->
name|cno
operator|>
name|max
condition|)
do|;
else|else
name|tp
operator|->
name|cno
operator|=
name|max
expr_stmt|;
comment|/* Reset if we deleted an incremental search character. */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
condition|)
name|FL_SET
argument_list|(
name|is_flags
argument_list|,
name|IS_RESTART
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_CNTRLT
case|:
comment|/* Add autoindent characters. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_CNTRLT
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
if|if
condition|(
name|txt_dent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|ebuf_chk
goto|;
case|case
name|K_RIGHTBRACE
case|:
case|case
name|K_RIGHTPAREN
case|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_SHOWMATCH
argument_list|)
condition|)
name|showmatch
operator|=
literal|1
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_BACKSLASH
case|:
comment|/* Quote next erase/kill. */
comment|/* 		 * !!! 		 * Historic vi tried to make abbreviations after a backslash 		 * escape work.  If you did ":ab x y", and inserted "x\^H", 		 * (assuming the erase character was ^H) you got "x^H", and 		 * no abbreviation was done.  If you inserted "x\z", however, 		 * it tried to back up and do the abbreviation, i.e. replace 		 * 'x' with 'y'.  The problem was it got it wrong, and you 		 * ended up with "zy\". 		 * 		 * This is really hard to do (you have to remember the 		 * word/non-word state, for example), and doesn't make any 		 * sense to me.  Both backslash and the characters it 		 * (usually) escapes will individually trigger the 		 * abbreviation, so I don't see why the combination of them 		 * wouldn't.  I don't expect to get caught on this one, 		 * particularly since it never worked right, but I've been 		 * wrong before. 		 * 		 * Do the tests for abbreviations, so ":ab xa XA", 		 * "ixa\<K_VERASE>" performs the abbreviation. 		 */
name|quote
operator|=
name|Q_BNEXT
expr_stmt|;
goto|goto
name|insq_ch
goto|;
case|case
name|K_VLNEXT
case|:
comment|/* Quote next character. */
name|evp
operator|->
name|e_c
operator|=
literal|'^'
expr_stmt|;
name|quote
operator|=
name|Q_VNEXT
expr_stmt|;
comment|/* 		 * Turn on the quote flag so that the underlying routines 		 * quote the next character where it's possible. Turn off 		 * the input mapbiting flag so that we don't remap the next 		 * character. 		 */
name|FL_SET
argument_list|(
name|ec_flags
argument_list|,
name|EC_QUOTED
argument_list|)
expr_stmt|;
name|FL_CLR
argument_list|(
name|ec_flags
argument_list|,
name|EC_MAPINPUT
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * Skip the tests for abbreviations, so ":ab xa XA", 		 * "ixa^V<space>" doesn't perform the abbreviation. 		 */
goto|goto
name|insl_ch
goto|;
case|case
name|K_HEXCHAR
case|:
name|hexcnt
operator|=
literal|1
expr_stmt|;
goto|goto
name|insq_ch
goto|;
default|default:
comment|/* Insert the character. */
name|ins_ch
label|:
comment|/* 		 * Historically, vi eliminated nul's out of hand.  If the 		 * beautify option was set, it also deleted any unknown 		 * ASCII value less than space (040) and the del character 		 * (0177), except for tabs.  Unknown is a key word here. 		 * Most vi documentation claims that it deleted everything 		 * but<tab>,<nl> and<ff>, as that's what the original 		 * 4BSD documentation said.  This is obviously wrong, 		 * however, as<esc> would be included in that list.  What 		 * we do is eliminate any unquoted, iscntrl() character that 		 * wasn't a replay and wasn't handled specially, except 		 *<tab> or<ff>. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
operator|&&
name|iscntrl
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
operator|&&
name|evp
operator|->
name|e_value
operator|!=
name|K_FORMFEED
operator|&&
name|evp
operator|->
name|e_value
operator|!=
name|K_TAB
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"192|Illegal character; quote to enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
block|}
name|insq_ch
label|:
comment|/* 		 * If entering a non-word character after a word, check for 		 * abbreviations.  If there was one, discard replay characters. 		 * If entering a blank character, check for unmap commands, 		 * as well. 		 */
if|if
condition|(
operator|!
name|inword
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
condition|)
block|{
if|if
condition|(
name|abb
operator|==
name|AB_INWORD
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_ABBREV
argument_list|)
condition|)
block|{
if|if
condition|(
name|txt_abbrev
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|evp
operator|->
name|e_c
argument_list|,
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ab_turnoff
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
name|rcol
operator|-=
name|tmp
operator|+
literal|1
expr_stmt|;
goto|goto
name|resolve
goto|;
block|}
block|}
if|if
condition|(
name|isblank
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
operator|&&
name|UNMAP_TST
condition|)
name|txt_unmap
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|ec_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abb
operator|!=
name|AB_NOTSET
condition|)
name|abb
operator|=
name|inword
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
condition|?
name|AB_INWORD
else|:
name|AB_NOTWORD
expr_stmt|;
name|insl_ch
label|:
if|if
condition|(
name|txt_insch
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|evp
operator|->
name|e_c
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * If we're using K_VLNEXT to quote the next character, then 		 * we want the cursor to position itself on the ^ placeholder 		 * we're displaying, to match historic practice. 		 */
if|if
condition|(
name|quote
operator|==
name|Q_VNEXT
condition|)
block|{
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
block|}
comment|/* 		 * !!! 		 * Translate "<CH_HEX>[isxdigit()]*" to a character with 		 * a hex value: this test delimits the value by the max 		 * number of hex bytes.  Offset by one, we use 0 to mean 		 * that we've found<CH_HEX>. 		 */
if|if
condition|(
name|hexcnt
operator|!=
literal|0
operator|&&
name|hexcnt
operator|++
operator|==
sizeof|sizeof
argument_list|(
name|CHAR_T
argument_list|)
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|hexcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txt_hex
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Check to see if we've crossed the margin. 		 * 		 * !!! 		 * In the historic vi, the wrapmargin value was figured out 		 * using the display widths of the characters, i.e.<tab> 		 * characters were counted as two characters if the list edit 		 * option is set, but as the tabstop edit option number of 		 * characters otherwise.  That's what the vs_column() function 		 * gives us, so we use it. 		 */
if|if
condition|(
name|margin
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vs_column
argument_list|(
name|sp
argument_list|,
operator|&
name|tcol
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tcol
operator|>=
name|margin
condition|)
block|{
if|if
condition|(
name|txt_margin
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|wmt
argument_list|,
operator|&
name|tmp
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|isblank
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
condition|)
name|wm_skip
operator|=
literal|1
expr_stmt|;
name|wm_set
operator|=
literal|1
expr_stmt|;
goto|goto
name|k_cr
goto|;
block|}
block|}
block|}
comment|/* 		 * If we've reached the end of the buffer, then we need to 		 * switch into insert mode.  This happens when there's a 		 * change to a mark and the user puts in more characters than 		 * the length of the motion. 		 */
name|ebuf_chk
label|:
if|if
condition|(
name|tp
operator|->
name|cno
operator|>=
name|tp
operator|->
name|len
condition|)
block|{
name|BINC_GOTO
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
name|CH_CURSOR
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
block|}
comment|/* Step the quote state forward. */
if|if
condition|(
name|quote
operator|!=
name|Q_NOTSET
condition|)
block|{
if|if
condition|(
name|quote
operator|==
name|Q_BNEXT
condition|)
name|quote
operator|=
name|Q_BTHIS
expr_stmt|;
if|if
condition|(
name|quote
operator|==
name|Q_VNEXT
condition|)
name|quote
operator|=
name|Q_VTHIS
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|owrite
operator|!=
name|tp
operator|->
name|len
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"len %u != cno: %u ai: %u insert %u overwrite %u"
argument_list|,
name|tp
operator|->
name|len
argument_list|,
name|tp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|ai
argument_list|,
name|tp
operator|->
name|insert
argument_list|,
name|tp
operator|->
name|owrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|tp
operator|->
name|len
operator|=
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|owrite
expr_stmt|;
block|}
endif|#
directive|endif
name|resolve
label|:
comment|/* 	 * 1: If we don't need to know where the cursor really is and we're 	 *    replaying text, keep going. 	 */
if|if
condition|(
name|margin
operator|==
literal|0
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
goto|goto
name|replay
goto|;
comment|/* 	 * 2: Reset the line.  Don't bother unless we're about to wait on 	 *    a character or we need to know where the cursor really is. 	 *    We have to do this before showing matching characters so the 	 *    user can see what they're matching. 	 */
if|if
condition|(
operator|(
name|margin
operator|!=
literal|0
operator|||
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * 3: If there aren't keys waiting, display the matching character. 	 *    We have to do this before resolving any messages, otherwise 	 *    the error message from a missing match won't appear correctly. 	 */
if|if
condition|(
name|showmatch
condition|)
block|{
if|if
condition|(
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|&&
name|txt_showmatch
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|showmatch
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * 4: If there have been messages and we're not editing on the colon 	 *    command line or doing file name completion, resolve them. 	 */
if|if
condition|(
operator|(
name|vip
operator|->
name|totalcount
operator|!=
literal|0
operator|||
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
operator|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
operator|&&
operator|!
name|filec_redraw
operator|&&
name|vs_resolve
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * 5: Refresh the screen if we're about to wait on a character or we 	 *    need to know where the cursor really is. 	 */
if|if
condition|(
name|margin
operator|!=
literal|0
operator|||
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|UPDATE_POSITION
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
name|margin
operator|!=
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 6: Proceed with the incremental search. */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|is_flags
argument_list|,
name|IS_RUNNING
argument_list|)
operator|&&
name|txt_isrch
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
name|tp
argument_list|,
operator|&
name|is_flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 7: Next character... */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
goto|goto
name|replay
goto|;
goto|goto
name|next
goto|;
name|done
label|:
comment|/* Leave input mode. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT
argument_list|)
expr_stmt|;
comment|/* If recording for playback, save it. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
name|vip
operator|->
name|rep_cnt
operator|=
name|rcol
expr_stmt|;
comment|/* 	 * If not working on the colon command line, set the final cursor 	 * position. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
condition|)
block|{
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|alloc_err
label|:
name|txt_err
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_abbrev --  *	Handle abbreviations.  */
end_comment

begin_function
specifier|static
name|int
name|txt_abbrev
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|pushcp
parameter_list|,
name|isinfoline
parameter_list|,
name|didsubp
parameter_list|,
name|turnoffp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|CHAR_T
modifier|*
name|pushcp
decl_stmt|;
name|int
name|isinfoline
decl_stmt|,
decl|*
name|didsubp
decl_stmt|,
modifier|*
name|turnoffp
decl_stmt|;
end_function

begin_block
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
comment|/* Check to make sure we're not at the start of an append. */
operator|*
name|didsubp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
name|tp
operator|->
name|offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Find the start of the "word". 	 * 	 * !!! 	 * We match historic practice, which, as far as I can tell, had an 	 * off-by-one error.  The way this worked was that when the inserted 	 * text switched from a "word" character to a non-word character, 	 * vi would check for possible abbreviations.  It would then take the 	 * type (i.e. word/non-word) of the character entered TWO characters 	 * ago, and move backward in the text until reaching a character that 	 * was not that type, or the beginning of the insert, the line, or 	 * the file.  For example, in the string "abc<space>", when the<space> 	 * character triggered the abbreviation check, the type of the 'b' 	 * character was used for moving through the string.  Maybe there's a 	 * reason for not using the first (i.e. 'c') character, but I can't 	 * think of one. 	 * 	 * Terminate at the beginning of the insert or the character after the 	 * offset character -- both can be tested for using tp->offset. 	 */
name|off
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
expr_stmt|;
comment|/* Previous character. */
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
comment|/* One character test. */
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|offset
operator|||
name|isblank
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|search
goto|;
if|if
condition|(
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
comment|/* Move backward to change. */
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|off
expr_stmt|;
operator|--
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|offset
operator|||
operator|!
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|off
expr_stmt|;
operator|--
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|offset
operator|||
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isblank
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * !!! 	 * Historic vi exploded abbreviations on the command line.  This has 	 * obvious problems in that unabbreviating the string can be extremely 	 * tricky, particularly if the string has, say, an embedded escape 	 * character.  Personally, I think it's a stunningly bad idea.  Other 	 * examples of problems this caused in historic vi are: 	 *	:ab foo bar 	 *	:ab foo baz 	 * results in "bar" being abbreviated to "baz", which wasn't what the 	 * user had in mind at all.  Also, the commands: 	 *	:ab foo bar 	 *	:unab foo<space> 	 * resulted in an error message that "bar" wasn't mapped.  Finally, 	 * since the string was already exploded by the time the unabbreviate 	 * command got it, all it knew was that an abbreviation had occurred. 	 * Cleverly, it checked the replacement string for its unabbreviation 	 * match, which meant that the commands: 	 *	:ab foo1 bar 	 *	:ab foo2 bar 	 *	:unab foo2 	 * unabbreviate "foo1", and the commands: 	 *	:ab foo bar 	 *	:ab bar baz 	 * unabbreviate "foo"! 	 * 	 * Anyway, people neglected to first ask my opinion before they wrote 	 * macros that depend on this stuff, so, we make this work as follows. 	 * When checking for an abbreviation on the command line, if we get a 	 * string which is<blank> terminated and which starts at the beginning 	 * of the line, we check to see it is the abbreviate or unabbreviate 	 * commands.  If it is, turn abbreviations off and return as if no 	 * abbreviation was found.  Note also, minor trickiness, so that if 	 * the user erases the line and starts another command, we turn the 	 * abbreviations back on. 	 * 	 * This makes the layering look like a Nachos Supreme. 	 */
name|search
label|:
if|if
condition|(
name|isinfoline
condition|)
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
if|if
condition|(
name|ex_is_abbrev
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|turnoffp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
operator|*
name|turnoffp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|turnoffp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check for any abbreviations. */
if|if
condition|(
operator|(
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|SEQ_ABBREV
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Push the abbreviation onto the tty stack.  Historically, characters 	 * resulting from an abbreviation expansion were themselves subject to 	 * map expansions, O_SHOWMATCH matching etc.  This means the expanded 	 * characters will be re-tested for abbreviations.  It's difficult to 	 * know what historic practice in this case was, since abbreviations 	 * were applied to :colon command lines, so entering abbreviations that 	 * looped was tricky, although possible.  In addition, obvious loops 	 * didn't work as expected.  (The command ':ab a b|ab b c|ab c a' will 	 * silently only implement and/or display the last abbreviation.) 	 * 	 * This implementation doesn't recover well from such abbreviations. 	 * The main input loop counts abbreviated characters, and, when it 	 * reaches a limit, discards any abbreviated characters on the queue. 	 * It's difficult to back up to the original position, as the replay 	 * queue would have to be adjusted, and the line state when an initial 	 * abbreviated character was received would have to be saved. 	 */
name|ch
operator|=
operator|*
name|pushcp
expr_stmt|;
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If the size of the abbreviation is larger than or equal to the size 	 * of the original text, move to the start of the replaced characters, 	 * and add their length to the overwrite count. 	 * 	 * If the abbreviation is smaller than the original text, we have to 	 * delete the additional overwrite characters and copy down any insert 	 * characters. 	 */
name|tp
operator|->
name|cno
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|olen
operator|>=
name|len
condition|)
name|tp
operator|->
name|owrite
operator|+=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|qp
operator|->
name|olen
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
operator|+
name|len
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|qp
operator|->
name|olen
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|len
operator|-
name|qp
operator|->
name|olen
expr_stmt|;
block|}
comment|/* 	 * We return the length of the abbreviated characters.  This is so 	 * the calling routine can replace the replay characters with the 	 * abbreviation.  This means that subsequent '.' commands will produce 	 * the same text, regardless of intervening :[un]abbreviate commands. 	 * This is historic practice. 	 */
operator|*
name|didsubp
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_unmap --  *	Handle the unmap command.  */
end_comment

begin_function
specifier|static
name|void
name|txt_unmap
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|ec_flagsp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int32_t
modifier|*
name|ec_flagsp
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find the beginning of this "word". */
for|for
control|(
name|off
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
comment|/* 	 * !!! 	 * Historic vi exploded input mappings on the command line.  See the 	 * txt_abbrev() routine for an explanation of the problems inherent 	 * in this. 	 * 	 * We make this work as follows.  If we get a string which is<blank> 	 * terminated and which starts at the beginning of the line, we check 	 * to see it is the unmap command.  If it is, we return that the input 	 * mapping should be turned off.  Note also, minor trickiness, so that 	 * if the user erases the line and starts another command, we go ahead 	 * an turn mapping back on. 	 */
if|if
condition|(
operator|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
operator|)
operator|&&
name|ex_is_unmap
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
condition|)
name|FL_CLR
argument_list|(
operator|*
name|ec_flagsp
argument_list|,
name|EC_MAPINPUT
argument_list|)
expr_stmt|;
else|else
name|FL_SET
argument_list|(
operator|*
name|ec_flagsp
argument_list|,
name|EC_MAPINPUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * txt_ai_resolve --  *	When a line is resolved by<esc>, review autoindent characters.  */
end_comment

begin_function
specifier|static
name|void
name|txt_ai_resolve
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|changedp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|changedp
decl_stmt|;
block|{
name|u_long
name|ts
decl_stmt|;
name|int
name|del
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|len
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|,
name|tab_after_sp
decl_stmt|,
name|tabs
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
operator|*
name|changedp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the line is empty, has an offset, or no autoindent 	 * characters, we're done. 	 */
if|if
condition|(
operator|!
name|tp
operator|->
name|len
operator|||
name|tp
operator|->
name|offset
operator|||
operator|!
name|tp
operator|->
name|ai
condition|)
return|return;
comment|/* 	 * If the length is less than or equal to the autoindent 	 * characters, delete them. 	 */
if|if
condition|(
name|tp
operator|->
name|len
operator|<=
name|tp
operator|->
name|ai
condition|)
block|{
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|cno
operator|=
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * The autoindent characters plus any leading<blank> characters 	 * in the line are resolved into the minimum number of characters. 	 * Historic practice. 	 */
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
comment|/* Figure out the last<blank> screen column. */
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
operator|,
name|scno
operator|=
literal|0
operator|,
name|len
operator|=
name|tp
operator|->
name|len
operator|,
name|spaces
operator|=
name|tab_after_sp
operator|=
literal|0
init|;
name|len
operator|--
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|tab_after_sp
operator|=
literal|1
expr_stmt|;
name|scno
operator|+=
name|COL_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|spaces
expr_stmt|;
operator|++
name|scno
expr_stmt|;
block|}
comment|/* 	 * If there are no spaces, or no tabs after spaces and less than 	 * ts spaces, it's already minimal. 	 */
if|if
condition|(
operator|!
name|spaces
operator|||
operator|!
name|tab_after_sp
operator|&&
name|spaces
operator|<
name|ts
condition|)
return|return;
comment|/* Count up spaces/tabs needed to get to the target. */
for|for
control|(
name|cno
operator|=
literal|0
operator|,
name|tabs
operator|=
literal|0
init|;
name|cno
operator|+
name|COL_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
operator|<=
name|scno
condition|;
operator|++
name|tabs
control|)
name|cno
operator|+=
name|COL_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* 	 * Figure out how many characters we're dropping -- if we're not 	 * dropping any, it's already minimal, we're done. 	 */
name|old
operator|=
name|p
operator|-
name|tp
operator|->
name|lb
expr_stmt|;
name|new
operator|=
name|spaces
operator|+
name|tabs
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
return|return;
comment|/* Shift the rest of the characters down, adjust the counts. */
name|del
operator|=
name|old
operator|-
name|new
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|-
name|del
argument_list|,
name|p
argument_list|,
name|tp
operator|->
name|len
operator|-
name|old
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|del
expr_stmt|;
name|tp
operator|->
name|cno
operator|-=
name|del
expr_stmt|;
comment|/* Fill in space/tab characters. */
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
init|;
name|tabs
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|changedp
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * v_txt_auto --  *	Handle autoindent.  If aitp isn't NULL, use it, otherwise,  *	retrieve the line.  *  * PUBLIC: int v_txt_auto __P((SCR *, recno_t, TEXT *, size_t, TEXT *));  */
end_comment

begin_function
name|int
name|v_txt_auto
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|aitp
parameter_list|,
name|len
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|TEXT
modifier|*
name|aitp
decl_stmt|,
decl|*
name|tp
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size_t
name|nlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|aitp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If the ex append command is executed with an address of 0, 		 * it's possible to get here with a line number of 0.  Return 		 * an indent of 0. 		 */
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|t
operator|=
name|aitp
operator|->
name|lb
expr_stmt|;
comment|/* Count whitespace characters. */
for|for
control|(
name|p
operator|=
name|t
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
comment|/* Set count, check for no indentation. */
if|if
condition|(
operator|(
name|nlen
operator|=
operator|(
name|p
operator|-
name|t
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure the buffer's big enough. */
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|nlen
argument_list|)
expr_stmt|;
comment|/* Copy the buffer's current contents up. */
if|if
condition|(
name|tp
operator|->
name|len
operator|!=
literal|0
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|nlen
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|nlen
expr_stmt|;
comment|/* Copy the indentation into the new buffer. */
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|t
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* Set the autoindent count. */
name|tp
operator|->
name|ai
operator|=
name|nlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_backup --  *	Back up to the previously edited line.  */
end_comment

begin_function
specifier|static
name|TEXT
modifier|*
name|txt_backup
parameter_list|(
name|sp
parameter_list|,
name|tiqh
parameter_list|,
name|tp
parameter_list|,
name|flagsp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int32_t
modifier|*
name|flagsp
decl_stmt|;
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|TEXT
modifier|*
name|ntp
decl_stmt|;
comment|/* Get a handle on the previous TEXT structure. */
if|if
condition|(
operator|(
name|ntp
operator|=
name|tp
operator|->
name|q
operator|.
name|cqe_prev
operator|)
operator|==
operator|(
name|void
operator|*
operator|)
name|tiqh
condition|)
block|{
if|if
condition|(
operator|!
name|FL_ISSET
argument_list|(
operator|*
name|flagsp
argument_list|,
name|TXT_REPLAY
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"193|Already at the beginning of the insert"
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
comment|/* Bookkeeping. */
name|ntp
operator|->
name|len
operator|=
name|ntp
operator|->
name|sv_len
expr_stmt|;
comment|/* Handle appending to the line. */
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp
operator|->
name|owrite
operator|==
literal|0
operator|&&
name|ntp
operator|->
name|insert
operator|==
literal|0
condition|)
block|{
name|ntp
operator|->
name|lb
index|[
name|ntp
operator|->
name|len
index|]
operator|=
name|CH_CURSOR
expr_stmt|;
operator|++
name|ntp
operator|->
name|insert
expr_stmt|;
operator|++
name|ntp
operator|->
name|len
expr_stmt|;
name|FL_SET
argument_list|(
operator|*
name|flagsp
argument_list|,
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
block|}
else|else
name|FL_CLR
argument_list|(
operator|*
name|flagsp
argument_list|,
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
comment|/* Release the current TEXT. */
name|CIRCLEQ_REMOVE
argument_list|(
name|tiqh
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Update the old line on the screen. */
if|if
condition|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|ntp
operator|->
name|lno
operator|+
literal|1
argument_list|,
name|LINE_DELETE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Return the new/current TEXT. */
return|return
operator|(
name|ntp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Text indentation is truly strange.  ^T and ^D do movements to the next or  * previous shiftwidth value, i.e. for a 1-based numbering, with shiftwidth=3,  * ^T moves a cursor on the 7th, 8th or 9th column to the 10th column, and ^D  * moves it back.  *  * !!!  * The ^T and ^D characters in historical vi had special meaning only when they  * were the first characters entered after entering text input mode.  As normal  * erase characters couldn't erase autoindent characters (^T in this case), it  * meant that inserting text into previously existing text was strange -- ^T  * only worked if it was the first keystroke(s), and then could only be erased  * using ^D.  This implementation treats ^T specially anywhere it occurs in the  * input, and permits the standard erase characters to erase the characters it  * inserts.  *  * !!!  * A fun test is to try:  *	:se sw=4 ai list  *	i<CR>^Tx<CR>^Tx<CR>^Tx<CR>^Dx<CR>^Dx<CR>^Dx<esc>  * Historic vi loses some of the '$' marks on the line ends, but otherwise gets  * it right.  *  * XXX  * Technically, txt_dent should be part of the screen interface, as it requires  * knowledge of character sizes, including<space>s, on the screen.  It's here  * because it's a complicated little beast, and I didn't want to shove it down  * into the screen.  It's probable that KEY_LEN will call into the screen once  * there are screens with different character representations.  *  * txt_dent --  *	Handle ^T indents, ^D outdents.  *  * If anything changes here, check the ex version to see if it needs similar  * changes.  */
end_comment

begin_function
specifier|static
name|int
name|txt_dent
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|isindent
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
name|isindent
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|;
name|u_long
name|sw
decl_stmt|,
name|ts
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|current
decl_stmt|,
name|spaces
decl_stmt|,
name|target
decl_stmt|,
name|tabs
decl_stmt|,
name|off
decl_stmt|;
name|int
name|ai_reset
decl_stmt|;
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
name|sw
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SHIFTWIDTH
argument_list|)
expr_stmt|;
comment|/* 	 * Since we don't know what precedes the character(s) being inserted 	 * (or deleted), the preceding whitespace characters must be resolved. 	 * An example is a<tab>, which doesn't need a full shiftwidth number 	 * of columns because it's preceded by<space>s.  This is easy to get 	 * if the user sets shiftwidth to a value less than tabstop (or worse, 	 * something for which tabstop isn't a multiple) and then uses ^T to 	 * indent, and ^D to outdent. 	 * 	 * Figure out the current and target screen columns.  In the historic 	 * vi, the autoindent column was NOT determined using display widths 	 * of characters as was the wrapmargin column.  For that reason, we 	 * can't use the vs_column() function, but have to calculate it here. 	 * This is slow, but it's normally only on the first few characters of 	 * a line. 	 */
for|for
control|(
name|current
operator|=
name|cno
operator|=
literal|0
init|;
name|cno
operator|<
name|tp
operator|->
name|cno
condition|;
operator|++
name|cno
control|)
name|current
operator|+=
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|?
name|COL_OFF
argument_list|(
name|current
argument_list|,
name|ts
argument_list|)
else|:
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
expr_stmt|;
name|target
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|isindent
condition|)
name|target
operator|+=
name|COL_OFF
argument_list|(
name|target
argument_list|,
name|sw
argument_list|)
expr_stmt|;
else|else
name|target
operator|-=
operator|--
name|target
operator|%
name|sw
expr_stmt|;
comment|/* 	 * The AI characters will be turned into overwrite characters if the 	 * cursor immediately follows them.  We test both the cursor position 	 * and the indent flag because there's no single test.  (^T can only 	 * be detected by the cursor position, and while we know that the test 	 * is always true for ^D, the cursor can be in more than one place, as 	 * "0^D" and "^D" are different.) 	 */
name|ai_reset
operator|=
operator|!
name|isindent
operator|||
name|tp
operator|->
name|cno
operator|==
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
expr_stmt|;
comment|/* 	 * Back up over any previous<blank> characters, changing them into 	 * overwrite characters (including any ai characters).  Then figure 	 * out the current screen column. 	 */
for|for
control|(
init|;
name|tp
operator|->
name|cno
operator|>
name|tp
operator|->
name|offset
operator|&&
operator|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|;
operator|--
name|tp
operator|->
name|cno
operator|,
operator|++
name|tp
operator|->
name|owrite
control|)
empty_stmt|;
for|for
control|(
name|current
operator|=
name|cno
operator|=
literal|0
init|;
name|cno
operator|<
name|tp
operator|->
name|cno
condition|;
operator|++
name|cno
control|)
name|current
operator|+=
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|?
name|COL_OFF
argument_list|(
name|current
argument_list|,
name|ts
argument_list|)
else|:
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't move up to or past the target, it's because there 	 * weren't enough characters to delete, e.g. the first character 	 * of the line was a tp->offset character, and the user entered 	 * ^D to move to the beginning of a line.  An example of this is: 	 * 	 *	:set ai sw=4<cr>i<space>a<esc>i^T^D 	 * 	 * Otherwise, count up the total spaces/tabs needed to get from the 	 * beginning of the line (or the last non-<blank> character) to the 	 * target. 	 */
if|if
condition|(
name|current
operator|>=
name|target
condition|)
name|spaces
operator|=
name|tabs
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|cno
operator|=
name|current
operator|,
name|tabs
operator|=
literal|0
init|;
name|cno
operator|+
name|COL_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
operator|<=
name|target
condition|;
operator|++
name|tabs
control|)
name|cno
operator|+=
name|COL_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|target
operator|-
name|cno
expr_stmt|;
block|}
comment|/* If we overwrote ai characters, reset the ai count. */
if|if
condition|(
name|ai_reset
condition|)
name|tp
operator|->
name|ai
operator|=
name|tabs
operator|+
name|spaces
expr_stmt|;
comment|/* 	 * Call txt_insch() to insert each character, so that we get the 	 * correct effect when we add a<tab> to replace N<spaces>. 	 */
for|for
control|(
name|ch
operator|=
literal|'\t'
init|;
name|tabs
operator|>
literal|0
condition|;
operator|--
name|tabs
control|)
operator|(
name|void
operator|)
name|txt_insch
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|' '
init|;
name|spaces
operator|>
literal|0
condition|;
operator|--
name|spaces
control|)
operator|(
name|void
operator|)
name|txt_insch
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_fc --  *	File name completion.  */
end_comment

begin_function
specifier|static
name|int
name|txt_fc
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|redrawp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|redrawp
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|ARGS
modifier|*
modifier|*
name|argv
decl_stmt|;
name|CHAR_T
name|s_ch
decl_stmt|;
name|EXCMD
name|cmd
decl_stmt|;
name|size_t
name|indx
decl_stmt|,
name|len
decl_stmt|,
name|nlen
decl_stmt|,
name|off
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|trydir
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|trydir
operator|=
literal|0
expr_stmt|;
operator|*
name|redrawp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find the beginning of this "word" -- if we're at the beginning 	 * of the line, it's a special case. 	 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|==
literal|1
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|lb
expr_stmt|;
block|}
else|else
name|retry
label|:
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|off
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
init|;
condition|;
operator|--
name|off
operator|,
operator|--
name|p
control|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
comment|/* 	 * Get enough space for a wildcard character. 	 * 	 * XXX 	 * This won't work for "foo\", since the \ will escape the expansion 	 * character.  I'm not sure if that's a bug or not... 	 */
name|off
operator|=
name|p
operator|-
name|tp
operator|->
name|lb
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
expr_stmt|;
name|s_ch
operator|=
name|p
index|[
name|len
index|]
expr_stmt|;
name|p
index|[
name|len
index|]
operator|=
literal|'*'
expr_stmt|;
comment|/* Build an ex command, and call the ex expansion routines. */
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv_init
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|p
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|p
index|[
name|len
index|]
operator|=
name|s_ch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|argc
operator|=
name|cmd
operator|.
name|argc
expr_stmt|;
name|argv
operator|=
name|cmd
operator|.
name|argv
expr_stmt|;
name|p
index|[
name|len
index|]
operator|=
name|s_ch
expr_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
case|case
literal|0
case|:
comment|/* No matches. */
if|if
condition|(
operator|!
name|trydir
condition|)
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
comment|/* One match. */
comment|/* If something changed, do the exchange. */
name|nlen
operator|=
name|strlen
argument_list|(
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|nlen
operator|||
name|memcmp
argument_list|(
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
condition|)
break|break;
comment|/* If haven't done a directory test, do it now. */
if|if
condition|(
operator|!
name|trydir
operator|&&
operator|!
name|stat
argument_list|(
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
operator|&
name|sb
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|p
operator|+=
name|len
expr_stmt|;
goto|goto
name|isdir
goto|;
block|}
comment|/* If nothing changed, period, ring the bell. */
if|if
condition|(
operator|!
name|trydir
condition|)
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* Multiple matches. */
operator|*
name|redrawp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|txt_fc_col
argument_list|(
name|sp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Find the length of the shortest match. */
for|for
control|(
name|nlen
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|len
init|;
operator|--
name|argc
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|argv
index|[
name|argc
index|]
operator|->
name|len
operator|<
name|nlen
condition|)
name|nlen
operator|=
name|cmd
operator|.
name|argv
index|[
name|argc
index|]
operator|->
name|len
expr_stmt|;
for|for
control|(
name|indx
operator|=
literal|0
init|;
name|indx
operator|<
name|nlen
operator|&&
name|cmd
operator|.
name|argv
index|[
name|argc
index|]
operator|->
name|bp
index|[
name|indx
index|]
operator|==
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
index|[
name|indx
index|]
condition|;
operator|++
name|indx
control|)
empty_stmt|;
name|nlen
operator|=
name|indx
expr_stmt|;
block|}
break|break;
block|}
comment|/* Overwrite the expanded text first. */
for|for
control|(
name|t
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
init|;
name|len
operator|>
literal|0
operator|&&
name|nlen
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|--
name|nlen
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
comment|/* If lost text, make the remaining old text overwrite characters. */
if|if
condition|(
name|len
condition|)
block|{
name|tp
operator|->
name|cno
operator|-=
name|len
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Overwrite any overwrite characters next. */
for|for
control|(
init|;
name|nlen
operator|>
literal|0
operator|&&
name|tp
operator|->
name|owrite
operator|>
literal|0
condition|;
operator|--
name|nlen
operator|,
operator|--
name|tp
operator|->
name|owrite
operator|,
operator|++
name|tp
operator|->
name|cno
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
comment|/* Shift remaining text up, and move the cursor to the end. */
if|if
condition|(
name|nlen
condition|)
block|{
name|off
operator|=
name|p
operator|-
name|tp
operator|->
name|lb
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|nlen
argument_list|)
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
expr_stmt|;
name|tp
operator|->
name|cno
operator|+=
name|nlen
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|nlen
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|p
operator|+
name|nlen
argument_list|,
name|p
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlen
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
comment|/* If a single match and it's a directory, retry it. */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|stat
argument_list|(
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
operator|&
name|sb
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|isdir
label|:
if|if
condition|(
name|tp
operator|->
name|owrite
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|p
operator|-
name|tp
operator|->
name|lb
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
block|}
else|else
operator|--
name|tp
operator|->
name|owrite
expr_stmt|;
operator|++
name|tp
operator|->
name|cno
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|trydir
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_fc_col --  *	Display file names for file name completion.  */
end_comment

begin_function
specifier|static
name|int
name|txt_fc_col
parameter_list|(
name|sp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|ARGS
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|ARGS
modifier|*
modifier|*
name|av
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|base
decl_stmt|,
name|cnt
decl_stmt|,
name|col
decl_stmt|,
name|colwidth
decl_stmt|,
name|numrows
decl_stmt|,
name|numcols
decl_stmt|,
name|prefix
decl_stmt|,
name|row
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|nf
decl_stmt|,
name|reset
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* Trim any directory prefix common to all of the files. */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|prefix
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|prefix
operator|=
operator|(
name|p
operator|-
name|argv
index|[
literal|0
index|]
operator|->
name|bp
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|argc
operator|-
literal|1
operator|,
name|av
operator|=
name|argv
operator|+
literal|1
init|;
name|ac
operator|>
literal|0
condition|;
operator|--
name|ac
operator|,
operator|++
name|av
control|)
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|->
name|len
operator|<
name|prefix
operator|||
name|memcmp
argument_list|(
name|av
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|prefix
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Figure out the column width for the longest name.  Output is done on 	 * 6 character "tab" boundaries for no particular reason.  (Since we 	 * don't output tab characters, we ignore the terminal's tab settings.) 	 * Ignore the user's tab setting because we have no idea how reasonable 	 * it is. 	 */
for|for
control|(
name|ac
operator|=
name|argc
operator|,
name|av
operator|=
name|argv
operator|,
name|colwidth
operator|=
literal|0
init|;
name|ac
operator|>
literal|0
condition|;
operator|--
name|ac
operator|,
operator|++
name|av
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|p
operator|=
name|av
index|[
literal|0
index|]
operator|->
name|bp
operator|+
name|prefix
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
name|col
operator|+=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|>
name|colwidth
condition|)
name|colwidth
operator|=
name|col
expr_stmt|;
block|}
name|colwidth
operator|+=
name|COL_OFF
argument_list|(
name|colwidth
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * Writing to the bottom line of the screen is always turned off when 	 * SC_TINPUT_INFO is set.  Turn it back on, we know what we're doing. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
condition|)
block|{
name|reset
operator|=
literal|1
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
block|}
else|else
name|reset
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CHK_INTR
define|\
value|if (F_ISSET(gp, G_INTERRUPTED))					\ 		goto intr;
comment|/* If the largest file name is too large, just print them. */
if|if
condition|(
name|colwidth
operator|>
name|sp
operator|->
name|cols
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|av
index|[
literal|0
index|]
operator|->
name|bp
operator|+
name|prefix
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|argc
operator|,
name|av
operator|=
name|argv
init|;
name|ac
operator|>
literal|0
condition|;
operator|--
name|ac
operator|,
operator|++
name|av
control|)
block|{
operator|(
name|void
operator|)
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHK_INTR
expr_stmt|;
block|}
else|else
block|{
comment|/* Figure out the number of columns. */
name|numcols
operator|=
operator|(
name|sp
operator|->
name|cols
operator|-
literal|1
operator|)
operator|/
name|colwidth
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|numcols
condition|)
block|{
name|numrows
operator|=
name|argc
operator|/
name|numcols
expr_stmt|;
if|if
condition|(
name|argc
operator|%
name|numcols
condition|)
operator|++
name|numrows
expr_stmt|;
block|}
else|else
name|numrows
operator|=
literal|1
expr_stmt|;
comment|/* Display the files in sorted order. */
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|numrows
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|base
operator|=
name|row
operator|,
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|numcols
condition|;
operator|++
name|col
control|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|argv
index|[
name|base
index|]
operator|->
name|bp
operator|+
name|prefix
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHK_INTR
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|+=
name|numrows
operator|)
operator|>=
name|argc
condition|)
break|break;
operator|(
name|void
operator|)
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|colwidth
operator|-
name|cnt
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|CHK_INTR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|CHK_INTR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|CHK_INTR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|intr
label|:
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reset
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_emark --  *	Set the end mark on the line.  */
end_comment

begin_function
specifier|static
name|int
name|txt_emark
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|cno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|size_t
name|cno
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|size_t
name|chlen
decl_stmt|,
name|nlen
decl_stmt|,
name|olen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ch
operator|=
name|CH_ENDMARK
expr_stmt|;
comment|/* 	 * The end mark may not be the same size as the current character. 	 * Don't let the line shift. 	 */
name|nlen
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|)
operator|(
name|void
operator|)
name|vs_columns
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
operator|&
name|cno
argument_list|,
operator|&
name|olen
argument_list|)
expr_stmt|;
else|else
name|olen
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If the line got longer, well, it's weird, but it's easy.  If 	 * it's the same length, it's easy.  If it got shorter, we have 	 * to fix it up. 	 */
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|olen
argument_list|)
expr_stmt|;
name|chlen
operator|=
name|olen
operator|-
name|nlen
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
operator|!=
literal|0
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
operator|+
name|chlen
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|chlen
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|chlen
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|cno
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|)
for|for
control|(
name|cno
operator|+=
name|chlen
init|;
name|chlen
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
for|for
control|(
name|kp
operator|=
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
operator|,
name|cno
operator|+=
name|chlen
init|;
name|chlen
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
block|}
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|=
name|ch
expr_stmt|;
return|return
operator|(
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_err --  *	Handle an error during input processing.  */
end_comment

begin_function
specifier|static
name|void
name|txt_err
parameter_list|(
name|sp
parameter_list|,
name|tiqh
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
comment|/* 	 * The problem with input processing is that the cursor is at an 	 * indeterminate position since some input may have been lost due 	 * to a malloc error.  So, try to go back to the place from which 	 * the cursor started, knowing that it may no longer be available. 	 * 	 * We depend on at least one line number being set in the text 	 * chain. 	 */
for|for
control|(
name|lno
operator|=
name|tiqh
operator|->
name|cqh_first
operator|->
name|lno
init|;
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
operator|&&
name|lno
operator|>
literal|0
condition|;
operator|--
name|lno
control|)
empty_stmt|;
name|sp
operator|->
name|lno
operator|=
name|lno
operator|==
literal|0
condition|?
literal|1
else|:
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* Redraw the screen, just in case. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * txt_hex --  *	Let the user insert any character value they want.  *  * !!!  * This is an extension.  The pattern "^X[0-9a-fA-F]*" is a way  * for the user to specify a character value which their keyboard  * may not be able to enter.  */
end_comment

begin_function
specifier|static
name|int
name|txt_hex
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|CHAR_T
name|savec
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|u_long
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
comment|/* 	 * Null-terminate the string.  Since nul isn't a legal hex value, 	 * this should be okay, and lets us use a local routine, which 	 * presumably understands the character set, to convert the value. 	 */
name|savec
operator|=
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find the previous CH_HEX character. */
for|for
control|(
name|off
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
operator|,
operator|++
name|len
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|CH_HEX
condition|)
block|{
name|wp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Not on this line?  Shouldn't happen. */
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
goto|goto
name|nothex
goto|;
block|}
comment|/* If length of 0, then it wasn't a hex value. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|nothex
goto|;
comment|/* Get the value. */
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|wp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
name|value
operator|>
name|MAX_CHAR_T
condition|)
block|{
name|nothex
label|:
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
name|savec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Restore the original character. */
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
operator|=
name|savec
expr_stmt|;
comment|/* Adjust the bookkeeping. */
name|tp
operator|->
name|cno
operator|-=
name|len
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|len
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
comment|/* Copy down any overwrite characters. */
if|if
condition|(
name|tp
operator|->
name|owrite
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|len
argument_list|,
name|tp
operator|->
name|owrite
argument_list|)
expr_stmt|;
comment|/* Copy down any insert characters. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
operator|+
name|len
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_insch --  *  * !!!  * Historic vi did a special screen optimization for tab characters.  As an  * example, for the keystrokes "iabcd<esc>0C<tab>", the tab overwrote the  * rest of the string when it was displayed.  *  * Because early versions of this implementation redisplayed the entire line  * on each keystroke, the "bcd" was pushed to the right as it ignored that  * the user had "promised" to change the rest of the characters.  However,  * the historic vi implementation had an even worse bug: given the keystrokes  * "iabcd<esc>0R<tab><esc>", the "bcd" disappears, and magically reappears  * on the second<esc> key.  *  * POSIX 1003.2 requires (will require) that this be fixed, specifying that  * vi overwrite characters the user has committed to changing, on the basis  * of the screen space they require, but that it not overwrite other characters.  */
end_comment

begin_function
specifier|static
name|int
name|txt_insch
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|chp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|CHAR_T
modifier|*
name|chp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|CHAR_T
modifier|*
name|kp
decl_stmt|,
name|savech
decl_stmt|;
name|size_t
name|chlen
decl_stmt|,
name|cno
decl_stmt|,
name|copydown
decl_stmt|,
name|olen
decl_stmt|,
name|nlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * The 'R' command does one-for-one replacement, because there's 	 * no way to know how many characters the user intends to replace. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLACE
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|owrite
condition|)
block|{
operator|--
name|tp
operator|->
name|owrite
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|++
index|]
operator|=
operator|*
name|chp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|owrite
condition|)
block|{
comment|/* Overwrite a character. */
name|cno
operator|=
name|tp
operator|->
name|cno
expr_stmt|;
comment|/* 		 * If the old or new characters are tabs, then the length of the 		 * display depends on the character position in the display.  We 		 * don't even try to handle this here, just ask the screen. 		 */
if|if
condition|(
operator|*
name|chp
operator|==
literal|'\t'
condition|)
block|{
name|savech
operator|=
name|tp
operator|->
name|lb
index|[
name|cno
index|]
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|=
literal|'\t'
expr_stmt|;
operator|(
name|void
operator|)
name|vs_columns
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
operator|&
name|cno
argument_list|,
operator|&
name|nlen
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|=
name|savech
expr_stmt|;
block|}
else|else
name|nlen
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
operator|*
name|chp
argument_list|)
expr_stmt|;
comment|/* 		 * Eat overwrite characters until we run out of them or we've 		 * handled the length of the new character.  If we only eat 		 * part of an overwrite character, break it into its component 		 * elements and display the remaining components. 		 */
for|for
control|(
name|copydown
operator|=
literal|0
init|;
name|nlen
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|owrite
operator|!=
literal|0
condition|;
control|)
block|{
operator|--
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|)
operator|(
name|void
operator|)
name|vs_columns
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
operator|&
name|cno
argument_list|,
operator|&
name|olen
argument_list|)
expr_stmt|;
else|else
name|olen
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|==
name|nlen
condition|)
block|{
name|nlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|olen
operator|<
name|nlen
condition|)
block|{
operator|++
name|copydown
expr_stmt|;
name|nlen
operator|-=
name|olen
expr_stmt|;
block|}
else|else
block|{
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|olen
argument_list|)
expr_stmt|;
name|chlen
operator|=
name|olen
operator|-
name|nlen
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
operator|+
name|chlen
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|owrite
operator|+
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|chlen
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|chlen
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|cno
index|]
operator|==
literal|'\t'
condition|)
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
init|;
name|chlen
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
for|for
control|(
name|kp
operator|=
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
index|[
name|cno
index|]
argument_list|)
operator|+
name|nlen
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
literal|1
init|;
name|chlen
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
name|nlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If had to erase several characters, we adjust the total 		 * count, and if there are any characters left, shift them 		 * into position. 		 */
if|if
condition|(
name|copydown
operator|!=
literal|0
operator|&&
operator|(
name|tp
operator|->
name|len
operator|-=
name|copydown
operator|)
operator|!=
literal|0
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|cno
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|cno
operator|+
name|copydown
argument_list|,
name|tp
operator|->
name|owrite
operator|+
name|tp
operator|->
name|insert
operator|+
name|copydown
argument_list|)
expr_stmt|;
comment|/* If we had enough overwrite characters, we're done. */
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|++
index|]
operator|=
operator|*
name|chp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Check to see if the character fits into the input buffer. */
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
block|{
comment|/* Insert a character. */
if|if
condition|(
name|tp
operator|->
name|insert
operator|==
literal|1
condition|)
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|+
literal|1
index|]
operator|=
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
index|]
expr_stmt|;
else|else
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|owrite
operator|+
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|++
index|]
operator|=
operator|*
name|chp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_isrch --  *	Do an incremental search.  */
end_comment

begin_function
specifier|static
name|int
name|txt_isrch
parameter_list|(
name|sp
parameter_list|,
name|vp
parameter_list|,
name|tp
parameter_list|,
name|is_flagsp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|VICMD
modifier|*
name|vp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int8_t
modifier|*
name|is_flagsp
decl_stmt|;
block|{
name|MARK
name|start
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|u_int
name|sf
decl_stmt|;
comment|/* If it's a one-line screen, we don't do incrementals. */
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|FL_CLR
argument_list|(
operator|*
name|is_flagsp
argument_list|,
name|IS_RUNNING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the user erases back to the beginning of the buffer, there's 	 * nothing to search for.  Reset the cursor to the starting point. 	 */
if|if
condition|(
name|tp
operator|->
name|cno
operator|<=
literal|1
condition|)
block|{
name|vp
operator|->
name|m_final
operator|=
name|vp
operator|->
name|m_start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If it's an RE quote character, and not quoted, ignore it until 	 * we get another character. 	 */
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|tp
operator|->
name|cno
operator|==
literal|2
operator|||
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If it's a magic shell character, and not quoted, reset the cursor 	 * to the starting point. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_SHELLMETA
argument_list|)
argument_list|,
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|tp
operator|->
name|cno
operator|==
literal|2
operator|||
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
condition|)
name|vp
operator|->
name|m_final
operator|=
name|vp
operator|->
name|m_start
expr_stmt|;
comment|/* 	 * If we see the search pattern termination character, then quit doing 	 * an incremental search.  There may be more, e.g., ":/foo/;/bar/", 	 * and we can't handle that incrementally.  Also, reset the cursor to 	 * the original location, the ex search routines don't know anything 	 * about incremental searches. 	 */
if|if
condition|(
name|tp
operator|->
name|lb
index|[
literal|0
index|]
operator|==
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|1
index|]
operator|&&
operator|(
name|tp
operator|->
name|cno
operator|==
literal|2
operator|||
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|cno
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
condition|)
block|{
name|vp
operator|->
name|m_final
operator|=
name|vp
operator|->
name|m_start
expr_stmt|;
name|FL_CLR
argument_list|(
operator|*
name|is_flagsp
argument_list|,
name|IS_RUNNING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Remember the input line and discard the special input map, 	 * but don't overwrite the input line on the screen. 	 */
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|VIP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|VIP_S_MODELINE
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT
operator||
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt_map_end
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Specify a starting point and search.  If we find a match, move to 	 * it and refresh the screen.  If we didn't find the match, then we 	 * beep the screen.  When searching from the original cursor position,  	 * we have to move the cursor, otherwise, we don't want to move the 	 * cursor in case the text at the current position continues to match. 	 */
if|if
condition|(
name|FL_ISSET
argument_list|(
operator|*
name|is_flagsp
argument_list|,
name|IS_RESTART
argument_list|)
condition|)
block|{
name|start
operator|=
name|vp
operator|->
name|m_start
expr_stmt|;
name|sf
operator|=
name|SEARCH_SET
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|vp
operator|->
name|m_final
expr_stmt|;
name|sf
operator|=
name|SEARCH_INCR
operator||
name|SEARCH_SET
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|lb
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
operator|!
name|f_search
argument_list|(
name|sp
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|vp
operator|->
name|m_final
argument_list|,
name|tp
operator|->
name|lb
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|cno
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|sf
argument_list|)
else|:
operator|!
name|b_search
argument_list|(
name|sp
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|vp
operator|->
name|m_final
argument_list|,
name|tp
operator|->
name|lb
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|cno
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|sf
argument_list|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
expr_stmt|;
name|FL_CLR
argument_list|(
operator|*
name|is_flagsp
argument_list|,
name|IS_RESTART
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|&&
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|FL_SET
argument_list|(
operator|*
name|is_flagsp
argument_list|,
name|IS_RESTART
argument_list|)
expr_stmt|;
comment|/* Reinstantiate the special input map. */
if|if
condition|(
name|txt_map_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|VIP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|VIP_S_MODELINE
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT
operator||
name|SC_TINPUT_INFO
argument_list|)
expr_stmt|;
comment|/* Reset the line number of the input line. */
name|tp
operator|->
name|lno
operator|=
name|TMAP
index|[
literal|0
index|]
operator|.
name|lno
expr_stmt|;
comment|/* 	 * If the colon command-line moved, i.e. the screen scrolled, 	 * refresh the input line. 	 * 	 * XXX 	 * We shouldn't be calling vs_line, here -- we need dirty bits 	 * on entries in the SMAP array. 	 */
if|if
condition|(
name|lno
operator|!=
name|TMAP
index|[
literal|0
index|]
operator|.
name|lno
condition|)
block|{
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
operator|&
name|TMAP
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_resolve --  *	Resolve the input text chain into the file.  */
end_comment

begin_function
specifier|static
name|int
name|txt_resolve
parameter_list|(
name|sp
parameter_list|,
name|tiqh
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|int
name|changed
decl_stmt|;
comment|/* 	 * The first line replaces a current line, and all subsequent lines 	 * are appended into the file.  Resolve autoindented characters for 	 * each line before committing it.  If the latter causes the line to 	 * change, we have to redisplay it, otherwise the information cached 	 * about the line will be wrong. 	 */
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tiqh
operator|->
name|cqh_first
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
name|txt_ai_resolve
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
else|else
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
operator|||
name|changed
operator|&&
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|lno
operator|=
name|tp
operator|->
name|lno
init|;
operator|(
name|tp
operator|=
name|tp
operator|->
name|q
operator|.
name|cqe_next
operator|)
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|tiq
condition|;
operator|++
name|lno
control|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
name|txt_ai_resolve
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
else|else
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db_append
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
operator|||
name|changed
operator|&&
name|vs_change
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Clear the input flag, the look-aside buffer is no longer valid. 	 * Has to be done as part of text resolution, or upon return we'll 	 * be looking at incorrect data. 	 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_showmatch --  *	Show a character match.  *  * !!!  * Historic vi tried to display matches even in the :colon command line.  * I think not.  */
end_comment

begin_function
specifier|static
name|int
name|txt_showmatch
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|VCS
name|cs
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|endc
decl_stmt|,
name|startc
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* 	 * Do a refresh first, in case we haven't done one in awhile, 	 * so the user can see what we're complaining about. 	 */
name|UPDATE_POSITION
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * We don't display the match if it's not on the screen.  Find 	 * out what the first character on the screen is. 	 */
if|if
condition|(
name|vs_sm_position
argument_list|(
name|sp
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Initialize the getc() interface. */
name|cs
operator|.
name|cs_lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|cs
operator|.
name|cs_cno
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cs_init
argument_list|(
name|sp
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|startc
operator|=
operator|(
name|endc
operator|=
name|cs
operator|.
name|cs_ch
operator|)
operator|==
literal|')'
condition|?
literal|'('
else|:
literal|'{'
expr_stmt|;
comment|/* Search for the match. */
for|for
control|(
name|cnt
operator|=
literal|1
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cs_prev
argument_list|(
name|sp
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
operator|||
name|cs
operator|.
name|cs_flags
operator|==
name|CS_SOF
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Unmatched %s"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|endc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cs
operator|.
name|cs_ch
operator|==
name|endc
condition|)
operator|++
name|cnt
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|.
name|cs_ch
operator|==
name|startc
operator|&&
operator|--
name|cnt
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* If the match is on the screen, move to it. */
if|if
condition|(
name|cs
operator|.
name|cs_lno
operator|<
name|m
operator|.
name|lno
operator|||
name|cs
operator|.
name|cs_lno
operator|==
name|m
operator|.
name|lno
operator|&&
name|cs
operator|.
name|cs_cno
operator|<
name|m
operator|.
name|cno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|lno
operator|=
name|cs
operator|.
name|cs_lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|cs
operator|.
name|cs_cno
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Wait for timeout or character arrival. */
return|return
operator|(
name|v_event_get
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_MATCHTIME
argument_list|)
operator|*
literal|100
argument_list|,
name|EC_TIMEOUT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_margin --  *	Handle margin wrap.  */
end_comment

begin_function
specifier|static
name|int
name|txt_margin
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|wmtp
parameter_list|,
name|didbreak
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|,
decl|*
name|wmtp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|didbreak
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
comment|/* Find the nearest previous blank. */
for|for
control|(
name|off
operator|=
name|tp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|off
operator|,
operator|--
name|p
operator|,
operator|++
name|len
control|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|wp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * If reach the start of the line, there's nowhere to break. 		 * 		 * !!! 		 * Historic vi belled each time a character was entered after 		 * crossing the margin until a space was entered which could 		 * be used to break the line.  I don't as it tends to wake the 		 * cats. 		 */
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
block|{
operator|*
name|didbreak
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Store saved information about the rest of the line in the 	 * wrapmargin TEXT structure. 	 * 	 * !!! 	 * The offset field holds the length of the current characters 	 * that the user entered, but which are getting split to the new 	 * line -- it's going to be used to set the cursor value when we 	 * move to the new line. 	 */
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|wmtp
operator|->
name|lb
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|wmtp
operator|->
name|offset
operator|=
name|len
expr_stmt|;
name|wmtp
operator|->
name|insert
operator|=
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|?
name|tp
operator|->
name|insert
operator|-
literal|1
else|:
name|tp
operator|->
name|insert
expr_stmt|;
name|wmtp
operator|->
name|owrite
operator|=
name|tp
operator|->
name|owrite
expr_stmt|;
comment|/* Correct current bookkeeping information. */
name|tp
operator|->
name|cno
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|len
operator|-=
name|len
operator|+
name|tp
operator|->
name|owrite
operator|+
operator|(
name|tp
operator|->
name|insert
operator|-
literal|1
operator|)
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|len
operator|-=
name|len
operator|+
name|tp
operator|->
name|owrite
operator|+
name|tp
operator|->
name|insert
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
literal|0
expr_stmt|;
block|}
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
comment|/* 	 * !!! 	 * Delete any trailing whitespace from the current line. 	 */
for|for
control|(
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|--
name|tp
operator|->
name|cno
expr_stmt|;
operator|--
name|tp
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
operator|*
name|didbreak
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_Rresolve --  *	Resolve the input line for the 'R' command.  */
end_comment

begin_function
specifier|static
name|void
name|txt_Rresolve
parameter_list|(
name|sp
parameter_list|,
name|tiqh
parameter_list|,
name|tp
parameter_list|,
name|orig_len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
specifier|const
name|size_t
name|orig_len
decl_stmt|;
block|{
name|TEXT
modifier|*
name|ttp
decl_stmt|;
name|size_t
name|input_len
decl_stmt|,
name|retain
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Check to make sure that the cursor hasn't moved beyond 	 * the end of the line. 	 */
if|if
condition|(
name|tp
operator|->
name|owrite
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Calculate how many characters the user has entered, 	 * plus the blanks erased by<carriage-return>/<newline>s. 	 */
for|for
control|(
name|ttp
operator|=
name|tiqh
operator|->
name|cqh_first
operator|,
name|input_len
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|input_len
operator|+=
name|ttp
operator|==
name|tp
condition|?
name|tp
operator|->
name|cno
else|:
name|ttp
operator|->
name|len
operator|+
name|ttp
operator|->
name|R_erase
expr_stmt|;
if|if
condition|(
operator|(
name|ttp
operator|=
name|ttp
operator|->
name|q
operator|.
name|cqe_next
operator|)
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|tiq
condition|)
break|break;
block|}
comment|/* 	 * If the user has entered less characters than the original line 	 * was long, restore any overwriteable characters to the original 	 * characters.  These characters are entered as "insert characters", 	 * because they're after the cursor and we don't want to lose them. 	 * (This is okay because the R command has no insert characters.) 	 * We set owrite to 0 so that the insert characters don't get copied 	 * to somewhere else, which means that the line and the length have 	 * to be adjusted here as well. 	 * 	 * We have to retrieve the original line because the original pinned 	 * page has long since been discarded.  If it doesn't exist, that's 	 * okay, the user just extended the file. 	 */
if|if
condition|(
name|input_len
operator|<
name|orig_len
condition|)
block|{
name|retain
operator|=
name|MIN
argument_list|(
name|tp
operator|->
name|owrite
argument_list|,
name|orig_len
operator|-
name|input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|tiqh
operator|->
name|cqh_first
operator|->
name|lno
argument_list|,
name|DBG_FATAL
operator||
name|DBG_NOCACHE
argument_list|,
operator|&
name|p
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|cno
argument_list|,
name|p
operator|+
name|input_len
argument_list|,
name|retain
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|tp
operator|->
name|owrite
operator|-
name|retain
expr_stmt|;
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|insert
operator|+=
name|retain
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * txt_nomorech --  *	No more characters message.  */
end_comment

begin_function
specifier|static
name|void
name|txt_nomorech
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"194|No more characters to erase"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

