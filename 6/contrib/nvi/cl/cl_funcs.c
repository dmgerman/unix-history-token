begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cl_funcs.c	10.50 (Berkeley) 9/24/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_comment
comment|/*  * cl_addstr --  *	Add len bytes from the string at the cursor, advancing the cursor.  *  * PUBLIC: int cl_addstr __P((SCR *, const char *, size_t));  */
end_comment

begin_function
name|int
name|cl_addstr
parameter_list|(
name|sp
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If ex isn't in control, it's the last line of the screen and 	 * it's a split screen, use inverse video. 	 */
name|iv
operator|=
literal|0
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
operator|&&
name|oldy
operator|==
name|RLNO
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|&&
name|IS_SPLIT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|iv
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|addnstr
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|iv
condition|)
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_attr --  *	Toggle a screen attribute on/off.  *  * PUBLIC: int cl_attr __P((SCR *, scr_attr_t, int));  */
end_comment

begin_function
name|int
name|cl_attr
parameter_list|(
name|sp
parameter_list|,
name|attribute
parameter_list|,
name|on
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|scr_attr_t
name|attribute
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|SA_ALTERNATE
case|:
comment|/* 	 * !!! 	 * There's a major layering violation here.  The problem is that the 	 * X11 xterm screen has what's known as an "alternate" screen.  Some 	 * xterm termcap/terminfo entries include sequences to switch to/from 	 * that alternate screen as part of the ti/te (smcup/rmcup) strings. 	 * Vi runs in the alternate screen, so that you are returned to the 	 * same screen contents on exit from vi that you had when you entered 	 * vi.  Further, when you run :shell, or :!date or similar ex commands, 	 * you also see the original screen contents.  This wasn't deliberate 	 * on vi's part, it's just that it historically sent terminal init/end 	 * sequences at those times, and the addition of the alternate screen 	 * sequences to the strings changed the behavior of vi.  The problem 	 * caused by this is that we don't want to switch back to the alternate 	 * screen while getting a new command from the user, when the user is 	 * continuing to enter ex commands, e.g.: 	 * 	 *	:!date<<< switch to original screen 	 *	[Hit return to continue]<<< prompt user to continue 	 *	:command<<< get command from user 	 * 	 * Note that the :command input is a true vi input mode, e.g., input 	 * maps and abbreviations are being done.  So, we need to be able to 	 * switch back into the vi screen mode, without flashing the screen.  	 * 	 * To make matters worse, the curses initscr() and endwin() calls will 	 * do this automatically -- so, this attribute isn't as controlled by 	 * the higher level screen as closely as one might like. 	 */
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|ti_te
operator|!=
name|TI_SENT
condition|)
block|{
name|clp
operator|->
name|ti_te
operator|=
name|TI_SENT
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|smcup
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"smcup"
argument_list|,
operator|&
name|clp
operator|->
name|smcup
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|smcup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|smcup
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clp
operator|->
name|ti_te
operator|!=
name|TE_SENT
condition|)
block|{
name|clp
operator|->
name|ti_te
operator|=
name|TE_SENT
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|rmcup
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"rmcup"
argument_list|,
operator|&
name|clp
operator|->
name|rmcup
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|rmcup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|rmcup
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SA_INVERSE
case|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|smso
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|on
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|smso
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|rmso
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
condition|)
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_baud --  *	Return the baud rate.  *  * PUBLIC: int cl_baud __P((SCR *, u_long *));  */
end_comment

begin_function
name|int
name|cl_baud
parameter_list|(
name|sp
parameter_list|,
name|ratep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|u_long
modifier|*
name|ratep
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * XXX 	 * There's no portable way to get a "baud rate" -- cfgetospeed(3) 	 * returns the value associated with some #define, which we may 	 * never have heard of, or which may be a purely local speed.  Vi 	 * only cares if it's SLOW (w300), slow (w1200) or fast (w9600). 	 * Try and detect the slow ones, and default to fast. 	 */
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfgetospeed
argument_list|(
operator|&
name|clp
operator|->
name|orig
argument_list|)
condition|)
block|{
case|case
name|B50
case|:
case|case
name|B75
case|:
case|case
name|B110
case|:
case|case
name|B134
case|:
case|case
name|B150
case|:
case|case
name|B200
case|:
case|case
name|B300
case|:
case|case
name|B600
case|:
operator|*
name|ratep
operator|=
literal|600
expr_stmt|;
break|break;
case|case
name|B1200
case|:
operator|*
name|ratep
operator|=
literal|1200
expr_stmt|;
break|break;
default|default:
operator|*
name|ratep
operator|=
literal|9600
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_bell --  *	Ring the bell/flash the screen.  *  * PUBLIC: int cl_bell __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_bell
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|"\07"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* \a */
else|else
block|{
comment|/* 		 * Vi has an edit option which determines if the terminal 		 * should be beeped or the screen flashed. 		 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_FLASH
argument_list|)
condition|)
operator|(
name|void
operator|)
name|flash
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_clrtoeol --  *	Clear from the current cursor to the end of the line.  *  * PUBLIC: int cl_clrtoeol __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_clrtoeol
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
return|return
operator|(
name|clrtoeol
argument_list|()
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_cursor --  *	Return the current cursor position.  *  * PUBLIC: int cl_cursor __P((SCR *, size_t *, size_t *));  */
end_comment

begin_function
name|int
name|cl_cursor
parameter_list|(
name|sp
parameter_list|,
name|yp
parameter_list|,
name|xp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|size_t
modifier|*
name|yp
decl_stmt|,
decl|*
name|xp
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * The curses screen support splits a single underlying curses screen 	 * into multiple screens to support split screen semantics.  For this 	 * reason the returned value must be adjusted to be relative to the 	 * current screen, and not absolute.  Screens that implement the split 	 * using physically distinct screens won't need this hack. 	 */
name|getyx
argument_list|(
name|stdscr
argument_list|,
operator|*
name|yp
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
operator|*
name|yp
operator|-=
name|sp
operator|->
name|woff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cl_deleteln --  *	Delete the current line, scrolling all lines below it.  *  * PUBLIC: int cl_deleteln __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_deleteln
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|size_t
name|col
decl_stmt|,
name|lno
decl_stmt|,
name|spcnt
decl_stmt|,
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * This clause is required because the curses screen uses reverse 	 * video to delimit split screens.  If the screen does not do this, 	 * this code won't be necessary. 	 * 	 * If the bottom line was in reverse video, rewrite it in normal 	 * video before it's scrolled. 	 * 	 * Check for the existence of a chgat function; XSI requires it, but 	 * historic implementations of System V curses don't.   If it's not 	 * a #define, we'll fall back to doing it by hand, which is slow but 	 * acceptable. 	 * 	 * By hand means walking through the line, retrieving and rewriting 	 * each character.  Curses has no EOL marker, so track strings of 	 * spaces, and copy the trailing spaces only if there's a non-space 	 * character following. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
operator|&&
name|IS_SPLIT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|mvchgat
name|mvchgat
argument_list|(
name|RLNO
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|A_NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|lno
operator|=
name|RLNO
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|,
name|col
operator|=
name|spcnt
operator|=
literal|0
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|lno
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ch
operator|=
name|winch
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
operator|++
name|spcnt
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|lno
argument_list|,
name|col
operator|-
name|spcnt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|spcnt
operator|>
literal|0
condition|;
operator|--
name|spcnt
control|)
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|col
operator|>=
name|sp
operator|->
name|cols
condition|)
break|break;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|move
argument_list|(
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bottom line is expected to be blank after this operation, 	 * and other screens must support that semantic. 	 */
return|return
operator|(
name|deleteln
argument_list|()
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * cl_ex_adjust --  *	Adjust the screen for ex.  This routine is purely for standalone  *	ex programs.  All special purpose, all special case.  *  * PUBLIC: int cl_ex_adjust __P((SCR *, exadj_t));  */
end_comment

begin_function
name|int
name|cl_ex_adjust
parameter_list|(
name|sp
parameter_list|,
name|action
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|exadj_t
name|action
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EX_TERM_SCROLL
case|:
comment|/* Move the cursor up one line if that's possible. */
if|if
condition|(
name|clp
operator|->
name|cuu1
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|cuu1
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clp
operator|->
name|cup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|clp
operator|->
name|cup
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|EX_TERM_CE
case|:
comment|/* Clear the line. */
if|if
condition|(
name|clp
operator|->
name|el
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|el
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Historically, ex didn't erase the line, so, if the 			 * displayed line was only a single glyph, and<eof> 			 * was more than one glyph, the output would not fully 			 * overwrite the user's input.  To fix this, output 			 * the maxiumum character number of spaces.  Note, 			 * this won't help if the user entered extra prompt 			 * or<blank> characters before the command character. 			 * We'd have to do a lot of work to make that work, and 			 * it's almost certainly not worth the effort. 			 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MAX_CHARACTER_COLUMNS
condition|;
operator|++
name|cnt
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MAX_CHARACTER_COLUMNS
condition|;
operator|++
name|cnt
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_insertln --  *	Push down the current line, discarding the bottom line.  *  * PUBLIC: int cl_insertln __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_insertln
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * The current line is expected to be blank after this operation, 	 * and the screen must support that semantic. 	 */
return|return
operator|(
name|insertln
argument_list|()
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_keyval --  *	Return the value for a special key.  *  * PUBLIC: int cl_keyval __P((SCR *, scr_keyval_t, CHAR_T *, int *));  */
end_comment

begin_function
name|int
name|cl_keyval
parameter_list|(
name|sp
parameter_list|,
name|val
parameter_list|,
name|chp
parameter_list|,
name|dnep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|scr_keyval_t
name|val
decl_stmt|;
name|CHAR_T
modifier|*
name|chp
decl_stmt|;
name|int
modifier|*
name|dnep
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * VEOF, VERASE and VKILL are required by POSIX 1003.1-1990, 	 * VWERASE is a 4BSD extension. 	 */
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|KEY_VEOF
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
case|case
name|KEY_VERASE
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
case|case
name|KEY_VKILL
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VWERASE
case|case
name|KEY_VWERASE
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VWERASE
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
operator|*
name|dnep
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_move --  *	Move the cursor.  *  * PUBLIC: int cl_move __P((SCR *, size_t, size_t));  */
end_comment

begin_function
name|int
name|cl_move
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|cno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|size_t
name|lno
decl_stmt|,
name|cno
decl_stmt|;
block|{
comment|/* See the comment in cl_cursor. */
if|if
condition|(
name|move
argument_list|(
name|RLNO
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
argument_list|,
name|cno
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: move: l(%u) c(%u) o(%u)"
argument_list|,
name|lno
argument_list|,
name|cno
argument_list|,
name|sp
operator|->
name|woff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_refresh --  *	Refresh the screen.  *  * PUBLIC: int cl_refresh __P((SCR *, int));  */
end_comment

begin_function
name|int
name|cl_refresh
parameter_list|(
name|sp
parameter_list|,
name|repaint
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|repaint
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If we received a killer signal, we're done, there's no point 	 * in refreshing the screen. 	 */
if|if
condition|(
name|clp
operator|->
name|killersig
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If repaint is set, the editor is telling us that we don't know 	 * what's on the screen, so we have to repaint from scratch. 	 * 	 * In the curses library, doing wrefresh(curscr) is okay, but the 	 * screen flashes when we then apply the refresh() to bring it up 	 * to date.  So, use clearok(). 	 */
if|if
condition|(
name|repaint
condition|)
name|clearok
argument_list|(
name|curscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|refresh
argument_list|()
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_rename --  *	Rename the file.  *  * PUBLIC: int cl_rename __P((SCR *, char *, int));  */
end_comment

begin_function
name|int
name|cl_rename
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|on
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|char
modifier|*
name|ttype
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|OG_STR
argument_list|(
name|gp
argument_list|,
name|GO_TERM
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * We can only rename windows for xterm. 	 */
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME_OK
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|ttype
argument_list|,
literal|"xterm"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"xterm"
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|XTERM_RENAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|XTERM_RENAME
argument_list|,
name|ttype
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_suspend --  *	Suspend a screen.  *  * PUBLIC: int cl_suspend __P((SCR *, int *));  */
end_comment

begin_function
name|int
name|cl_suspend
parameter_list|(
name|sp
parameter_list|,
name|allowedp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
modifier|*
name|allowedp
decl_stmt|;
block|{
name|struct
name|termios
name|t
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|allowedp
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The ex implementation of this function isn't needed by screens not 	 * supporting ex commands that require full terminal canonical mode 	 * (e.g. :suspend). 	 * 	 * The vi implementation of this function isn't needed by screens not 	 * supporting vi process suspension, i.e. any screen that isn't backed 	 * by a UNIX shell. 	 * 	 * Setting allowedp to 0 will cause the editor to reject the command. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
comment|/* Save the terminal settings, and restore the original ones. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|clp
operator|->
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the process group. */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Time passes ... */
comment|/* Restore terminal settings. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Move to the lower left-hand corner of the screen. 	 * 	 * XXX 	 * Not sure this is necessary in System V implementations, but it 	 * shouldn't hurt. 	 */
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
comment|/* 	 * Temporarily end the screen.  System V introduced a semantic where 	 * endwin() could be restarted.  We use it because restarting curses 	 * from scratch often fails in System V.  4BSD curses didn't support 	 * restarting after endwin(), so we have to do what clean up we can 	 * without calling it. 	 */
ifdef|#
directive|ifdef
name|HAVE_BSD_CURSES
comment|/* Save the terminal settings. */
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Restore the cursor keys to normal mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Restore the window name. */
operator|(
name|void
operator|)
name|cl_rename
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BSD_CURSES
operator|(
name|void
operator|)
name|cl_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|endwin
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX 	 * Restore the original terminal settings.  This is bad -- the 	 * reset can cause character loss from the tty queue.  However, 	 * we can't call endwin() in BSD curses implementations, and too 	 * many System V curses implementations don't get it right. 	 */
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSADRAIN
operator||
name|TCSASOFT
argument_list|,
operator|&
name|clp
operator|->
name|orig
argument_list|)
expr_stmt|;
comment|/* Stop the process group. */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Time passes ... */
comment|/* 	 * If we received a killer signal, we're done.  Leave everything 	 * unchanged.  In addition, the terminal has already been reset 	 * correctly, so leave it alone. 	 */
if|if
condition|(
name|clp
operator|->
name|killersig
condition|)
block|{
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
operator||
name|CL_SCR_VI_INIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_BSD_CURSES
comment|/* Restore terminal settings. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the window name. */
operator|(
name|void
operator|)
name|cl_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Put the cursor keys into application mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Refresh and repaint the screen. */
operator|(
name|void
operator|)
name|move
argument_list|(
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the screen changed size, set the SIGWINCH bit. */
if|if
condition|(
name|cl_ssize
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|changed
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|changed
condition|)
name|F_SET
argument_list|(
name|CLP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|CL_SIGWINCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_usage --  *	Print out the curses usage messages.  *   * PUBLIC: void cl_usage __P((void));  */
end_comment

begin_function
name|void
name|cl_usage
parameter_list|()
block|{
define|#
directive|define
name|USAGE
value|"\ usage: ex [-eFRrSsv] [-c command] [-t tag] [-w size] [file ...]\n\ usage: vi [-eFlRrSv] [-c command] [-t tag] [-w size] [file ...]\n"
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|USAGE
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|USAGE
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * gdbrefresh --  *	Stub routine so can flush out curses screen changes using gdb.  */
end_comment

begin_function
name|int
name|gdbrefresh
parameter_list|()
block|{
name|refresh
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Convince gdb to run it. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

