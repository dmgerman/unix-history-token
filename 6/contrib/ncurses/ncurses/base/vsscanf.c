begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2003,2004 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  State-machine fallback written by Thomas E. Dickey 2002                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * This function is needed to support vwscanw  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_if
if|#
directive|if
operator|!
name|HAVE_VSSCANF
end_if

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: vsscanf.c,v 1.18 2004/04/03 20:27:02 tom Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
operator|!
operator|(
name|HAVE_VFSCANF
operator|||
name|HAVE__DOSCAN
operator|)
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|L_SQUARE
value|'['
end_define

begin_define
define|#
directive|define
name|R_SQUARE
value|']'
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|cUnknown
block|,
name|cError
comment|/* anything that isn't ANSI */
block|,
name|cAssigned
block|,
name|cChar
block|,
name|cInt
block|,
name|cFloat
block|,
name|cDouble
block|,
name|cPointer
block|,
name|cLong
block|,
name|cShort
block|,
name|cRange
block|,
name|cString
block|}
name|ChunkType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|oUnknown
block|,
name|oShort
block|,
name|oLong
block|}
name|OtherType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|sUnknown
block|,
name|sPercent
comment|/* last was '%' beginning a format */
block|,
name|sNormal
comment|/* ...somewhere in the middle */
block|,
name|sLeft
comment|/* last was left square bracket beginning a range */
block|,
name|sRange
comment|/* ...somewhere in the middle */
block|,
name|sFinal
comment|/* last finished a format */
block|}
name|ScanState
typedef|;
end_typedef

begin_function
specifier|static
name|ChunkType
name|final_ch
parameter_list|(
name|int
name|ch
parameter_list|,
name|OtherType
name|other
parameter_list|)
block|{
name|ChunkType
name|result
init|=
name|cUnknown
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|other
operator|==
name|oUnknown
condition|)
name|result
operator|=
name|cChar
expr_stmt|;
else|else
name|result
operator|=
name|cError
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|oUnknown
case|:
name|result
operator|=
name|cInt
expr_stmt|;
break|break;
case|case
name|oShort
case|:
name|result
operator|=
name|cShort
expr_stmt|;
break|break;
case|case
name|oLong
case|:
name|result
operator|=
name|cLong
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|oUnknown
case|:
name|result
operator|=
name|cFloat
expr_stmt|;
break|break;
case|case
name|oShort
case|:
name|result
operator|=
name|cError
expr_stmt|;
break|break;
case|case
name|oLong
case|:
name|result
operator|=
name|cDouble
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|other
operator|==
name|oUnknown
condition|)
name|result
operator|=
name|cAssigned
expr_stmt|;
else|else
name|result
operator|=
name|cError
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|other
operator|==
name|oUnknown
condition|)
name|result
operator|=
name|cPointer
expr_stmt|;
else|else
name|result
operator|=
name|cError
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|other
operator|==
name|oUnknown
condition|)
name|result
operator|=
name|cString
expr_stmt|;
else|else
name|result
operator|=
name|cError
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|OtherType
name|other_ch
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|OtherType
name|result
init|=
name|oUnknown
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|result
operator|=
name|oShort
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|result
operator|=
name|oLong
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|vsscanf
argument_list|(
argument|const char *str
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|HAVE_VFSCANF
operator|||
name|HAVE__DOSCAN
comment|/*      * This code should work on anything descended from AT&T SVr1.      */
name|FILE
name|strbuf
decl_stmt|;
name|strbuf
operator|.
name|_flag
operator|=
name|_IOREAD
expr_stmt|;
name|strbuf
operator|.
name|_ptr
operator|=
name|strbuf
operator|.
name|_base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|strbuf
operator|.
name|_cnt
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|strbuf
operator|.
name|_file
operator|=
name|_NFILE
expr_stmt|;
if|#
directive|if
name|HAVE_VFSCANF
return|return
operator|(
name|vfscanf
argument_list|(
operator|&
name|strbuf
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|_doscan
argument_list|(
operator|&
name|strbuf
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
specifier|static
name|int
name|can_convert
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|int
name|consumed
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"vsscanf(%s,%s,...)"
argument_list|)
operator|,
name|_nc_visbuf2
argument_list|(
literal|1
argument_list|,
name|str
argument_list|)
operator|,
name|_nc_visbuf2
argument_list|(
literal|2
argument_list|,
name|format
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * This relies on having a working "%n" format conversion.  Check if it      * works.  Only very old C libraries do not support it.      *      * FIXME: move this check into the configure script.      */
if|if
condition|(
name|can_convert
operator|<
literal|0
condition|)
block|{
name|int
name|check1
decl_stmt|;
name|int
name|check2
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
literal|"123"
argument_list|,
literal|"%d%n"
argument_list|,
operator|&
name|check1
argument_list|,
operator|&
name|check2
argument_list|)
operator|>
literal|0
operator|&&
name|check1
operator|==
literal|123
operator|&&
name|check2
operator|==
literal|3
condition|)
block|{
name|can_convert
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|can_convert
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|can_convert
condition|)
block|{
name|size_t
name|len_fmt
init|=
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
literal|32
decl_stmt|;
name|char
modifier|*
name|my_fmt
init|=
name|malloc
argument_list|(
name|len_fmt
argument_list|)
decl_stmt|;
name|ChunkType
name|chunk
decl_stmt|,
name|ctest
decl_stmt|;
name|OtherType
name|other
decl_stmt|,
name|otest
decl_stmt|;
name|ScanState
name|state
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|int
name|eaten
decl_stmt|;
name|void
modifier|*
name|pointer
decl_stmt|;
if|if
condition|(
name|my_fmt
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * Split the original format into chunks, adding a "%n" to the end 	     * of each (except of course if it used %n), and use that 	     * information to decide where to start scanning the next chunk. 	     * 	     * FIXME:  does %n count bytes or characters?  If the latter, this 	     * will require further work for multibyte strings. 	     */
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
condition|)
block|{
comment|/* find a chunk */
name|state
operator|=
name|sUnknown
expr_stmt|;
name|chunk
operator|=
name|cUnknown
expr_stmt|;
name|other
operator|=
name|oUnknown
expr_stmt|;
name|pointer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|format
index|[
name|n
index|]
operator|!=
literal|0
operator|&&
name|state
operator|!=
name|sFinal
condition|;
operator|++
name|n
control|)
block|{
name|my_fmt
index|[
name|n
index|]
operator|=
name|format
index|[
name|n
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|sUnknown
case|:
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
literal|'%'
condition|)
name|state
operator|=
name|sPercent
expr_stmt|;
break|break;
case|case
name|sPercent
case|:
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
literal|'%'
condition|)
block|{
name|state
operator|=
name|sUnknown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
name|L_SQUARE
condition|)
block|{
name|state
operator|=
name|sLeft
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|sNormal
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
break|break;
case|case
name|sLeft
case|:
name|state
operator|=
name|sRange
expr_stmt|;
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
literal|'^'
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|my_fmt
index|[
name|n
index|]
operator|=
name|format
index|[
name|n
index|]
expr_stmt|;
block|}
break|break;
case|case
name|sRange
case|:
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
name|R_SQUARE
condition|)
block|{
name|state
operator|=
name|sFinal
expr_stmt|;
name|chunk
operator|=
name|cRange
expr_stmt|;
block|}
break|break;
case|case
name|sNormal
case|:
if|if
condition|(
name|format
index|[
name|n
index|]
operator|==
literal|'*'
condition|)
block|{
name|state
operator|=
name|sUnknown
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ctest
operator|=
name|final_ch
argument_list|(
name|format
index|[
name|n
index|]
argument_list|,
name|other
argument_list|)
operator|)
operator|!=
name|cUnknown
condition|)
block|{
name|state
operator|=
name|sFinal
expr_stmt|;
name|chunk
operator|=
name|ctest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|otest
operator|=
name|other_ch
argument_list|(
name|format
index|[
name|n
index|]
argument_list|)
operator|)
operator|!=
name|oUnknown
condition|)
block|{
name|other
operator|=
name|otest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|UChar
argument_list|(
name|format
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|state
operator|=
name|sFinal
expr_stmt|;
name|chunk
operator|=
name|cError
expr_stmt|;
block|}
block|}
break|break;
case|case
name|sFinal
case|:
break|break;
block|}
block|}
name|my_fmt
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|cUnknown
operator|||
name|chunk
operator|==
name|cError
condition|)
block|{
if|if
condition|(
name|assigned
operator|==
literal|0
condition|)
name|assigned
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
comment|/* add %n, if the format was not that */
if|if
condition|(
name|chunk
operator|!=
name|cAssigned
condition|)
block|{
name|strcat
argument_list|(
name|my_fmt
argument_list|,
literal|"%n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|chunk
condition|)
block|{
case|case
name|cAssigned
case|:
name|strcat
argument_list|(
name|my_fmt
argument_list|,
literal|"%n"
argument_list|)
expr_stmt|;
name|pointer
operator|=
operator|&
name|eaten
expr_stmt|;
break|break;
case|case
name|cInt
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cShort
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cFloat
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cDouble
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cLong
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cPointer
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cChar
case|:
case|case
name|cRange
case|:
case|case
name|cString
case|:
name|pointer
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|cError
case|:
case|case
name|cUnknown
case|:
break|break;
block|}
comment|/* do the conversion */
name|T
argument_list|(
operator|(
literal|"...converting chunk #%d type %d(%s,%s)"
operator|,
name|assigned
operator|+
literal|1
operator|,
name|chunk
operator|,
name|_nc_visbuf2
argument_list|(
literal|1
argument_list|,
name|str
operator|+
name|consumed
argument_list|)
operator|,
name|_nc_visbuf2
argument_list|(
literal|2
argument_list|,
name|my_fmt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|str
operator|+
name|consumed
argument_list|,
name|my_fmt
argument_list|,
name|pointer
argument_list|,
operator|&
name|eaten
argument_list|)
operator|>
literal|0
condition|)
name|consumed
operator|+=
name|eaten
expr_stmt|;
else|else
break|break;
operator|++
name|assigned
expr_stmt|;
block|}
name|free
argument_list|(
name|my_fmt
argument_list|)
expr_stmt|;
block|}
block|}
name|returnCode
argument_list|(
name|assigned
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_extern
extern|extern NCURSES_EXPORT(void
end_extern

begin_expr_stmt
unit|)
name|_nc_vsscanf
argument_list|(
name|void
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* quiet's gcc warning */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_vsscanf
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/* nonempty for strict ANSI compilers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VSSCANF */
end_comment

end_unit

