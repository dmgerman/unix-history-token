begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Renesas E7000 ICE, for GDB     Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003 Free Software Foundation, Inc.     Contributed by Cygnus Support.      Written by Steve Chamberlain for Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and    Renesas-SH processor.  It has serial port and a lan port.       The monitor command set makes it difficult to load large ammounts of    data over the lan without using ftp - so try not to issue load    commands when communicating over ethernet; use the ftpload command.     The monitor pauses for a second when dumping srecords to the serial    line too, so we use a slower per byte mechanism but without the    startup overhead.  Even so, it's pretty slow... */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|HARD_BREAKPOINTS
end_define

begin_comment
comment|/* Now handled by set option. */
end_comment

begin_define
define|#
directive|define
name|BC_BREAKPOINTS
value|use_hard_breakpoints
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CTRLC
value|0x03
end_define

begin_define
define|#
directive|define
name|ENQ
value|0x05
end_define

begin_define
define|#
directive|define
name|ACK
value|0x06
end_define

begin_define
define|#
directive|define
name|CTRLZ
value|0x1a
end_define

begin_comment
comment|/* This file is used by 2 different targets, sh-elf and h8300. The    h8300 is not multiarched and doesn't use the registers defined in    tm-sh.h. To avoid using a macro GDB_TARGET_IS_SH, we do runtime check    of the target, which requires that these namse below are always    defined also in the h8300 case. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PR_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|PR_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GBR_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|GBR_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VBR_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|VBR_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MACH_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|MACH_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MACL_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|MACL_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SR_REGNUM
argument_list|)
end_if

begin_define
define|#
directive|define
name|SR_REGNUM
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|time_t
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sh_processor_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|e7000_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_fetch_register
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_store_register
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_login_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_ftp_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000_drain_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expect
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expect_full_prompt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e7000_parse_device
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|baudrate
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Variables. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|e7000_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allow user to chose between using hardware breakpoints or memory. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_hard_breakpoints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use sw breakpoints by default */
end_comment

begin_comment
comment|/* Nonzero if using the tcp serial driver.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_tcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* direct tcp connection to target */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_tcp_remote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indirect connection to target  				   via tcp to controller */
end_comment

begin_comment
comment|/* Nonzero if using the pc isa card.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|e7000_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ENQSTRING
init|=
literal|"\005"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if some routine (as opposed to the user) wants echoing.    FIXME: Do this reentrantly with an extra parameter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|echo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctrl_c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send data to e7000debug.  */
end_comment

begin_function
specifier|static
name|void
name|puts_e7000debug
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|error
argument_list|(
literal|"Use \"target e7000 ...\" first."
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Sending %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_write
argument_list|(
name|e7000_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"serial_write failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And expect to see it echoed, unless using the pc interface */
if|#
directive|if
literal|0
block|if (!using_pc)
endif|#
directive|endif
name|expect
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putchar_e7000
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|char
name|b
index|[
literal|1
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|serial_write
argument_list|(
name|e7000_desc
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_e7000
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|serial_write
argument_list|(
name|e7000_desc
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|normal
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
literal|'\n'
condition|)
return|return
literal|'\r'
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy timeout    stuff.  Handles serial errors and EOF.  If TIMEOUT == 0, and no chars,    returns -1, else returns next char.  Discards chars> 127.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|serial_readchar
argument_list|(
name|e7000_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|127
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|echo
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Serial communication error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|putchar_unfiltered
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|normal
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|char * tl (int x) {   static char b[8][10];   static int p;    p++;   p&= 7;   if (x>= ' ')     {       b[p][0] = x;       b[p][1] = 0;     }   else     {       sprintf (b[p], "<%d>", x);     }    return b[p]; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If    DISCARD is non-zero, then discard non-matching input, else print it    out.  Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|nl
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|nl
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|nl
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nl
operator|=
literal|0
expr_stmt|;
name|putchar_unfiltered
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|normal
argument_list|(
name|c
argument_list|)
operator|==
name|normal
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return;
block|}
else|else
block|{
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|normal
argument_list|(
name|c
argument_list|)
operator|==
name|normal
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the e7000 prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line will    be an expect_prompt().  Exception: e7000_resume does not wait for    the prompt, because the terminal is being handed over to the    inferior.  However, the next thing which happens after that is a    e7000_wait which does wait for the prompt.  Note that this includes    abnormal exit, e.g. error().  This is necessary to prevent getting    into states from which we can't recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|void
parameter_list|)
block|{
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expect_full_prompt
parameter_list|(
name|void
parameter_list|)
block|{
name|expect
argument_list|(
literal|"\r:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_hex_digit
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_hex
parameter_list|(
name|int
modifier|*
name|start
parameter_list|)
block|{
name|int
name|value
init|=
name|convert_hex_digit
argument_list|(
operator|*
name|start
argument_list|)
decl_stmt|;
name|int
name|try
decl_stmt|;
operator|*
name|start
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|try
operator|=
name|convert_hex_digit
argument_list|(
operator|*
name|start
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|<<=
literal|4
expr_stmt|;
name|value
operator|+=
name|try
expr_stmt|;
operator|*
name|start
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space, and put    them in registers starting at REGNO.  */
end_comment

begin_endif
unit|static void get_hex_regs (int n, int regno) {   long val;   int i;    for (i = 0; i< n; i++)     {       int j;        val = 0;       for (j = 0; j< 8; j++) 	val = (val<< 4) + get_hex_digit (j == 0);       supply_register (regno++, (char *)&val);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote E7000DEBUG process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CREATE_INFERIOR_HOOK
name|CREATE_INFERIOR_HOOK
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* No process-ID */
endif|#
directive|endif
comment|/* The "process" (board) is already stopped awaiting our commands, and      the program is already downloaded.  We just set its PC and go.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let 'er rip... */
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.  NAME is the filename used    for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|machine
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|passwd
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grab the next token and buy some space for it */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|)
condition|)
block|{
name|l
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|r
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_login_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
block|{
name|machine
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|user
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|passwd
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|dir
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Set info to %s %s %s %s\n"
argument_list|,
name|machine
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Syntax is ftplogin<machine><user><passwd><directory>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start an ftp transfer from the E7000 to a host */
end_comment

begin_function
specifier|static
name|void
name|e7000_ftp_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: arbitrary limit on machine names and such.  */
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|oldtimeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ftp %s\r"
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" Username : "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\r"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" Password : "
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"success\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cd %s\r"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ll 0;s:%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"bye\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|oldtimeout
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000_parse_device
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|baudrate
parameter_list|)
block|{
name|char
name|junk
index|[
literal|128
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|&&
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|dev_name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|using_pc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME! temp hack to allow use with port master -          target tcp_remote<device> */
if|if
condition|(
name|args
operator|&&
name|strncmp
argument_list|(
name|args
argument_list|,
literal|"tcp"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|com_type
index|[
literal|128
index|]
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|args
argument_list|,
literal|" %s %s %d %s"
argument_list|,
name|com_type
argument_list|,
name|dev_name
argument_list|,
operator|&
name|baudrate
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|using_tcp_remote
operator|=
literal|1
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
condition|)
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|args
argument_list|,
literal|" %s %d %s"
argument_list|,
name|dev_name
argument_list|,
operator|&
name|baudrate
argument_list|,
name|junk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|1
operator|&&
name|n
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Bad arguments.  Usage:\ttarget e7000<device><speed>\n\ or \t\ttarget e7000<host>[:<port>]\n\ or \t\ttarget e7000 tcp_remote<host>[:<port>]\n\ or \t\ttarget e7000 pc\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* FIXME!  test for ':' is ambiguous */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|strchr
argument_list|(
name|dev_name
argument_list|,
literal|':'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Default to normal telnet port */
comment|/* serial_open will use this to determine tcp communication */
name|strcat
argument_list|(
name|dev_name
argument_list|,
literal|":23"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|using_tcp_remote
operator|&&
name|strchr
argument_list|(
name|dev_name
argument_list|,
literal|':'
argument_list|)
condition|)
name|using_tcp
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|e7000_start_remote
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|loop
decl_stmt|;
name|int
name|sync
decl_stmt|;
name|int
name|try
decl_stmt|;
name|int
name|quit_trying
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Hello?  Are you there?  */
name|sync
operator|=
literal|0
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
name|try
operator|=
literal|0
expr_stmt|;
name|quit_trying
operator|=
literal|20
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sync
operator|&&
operator|++
name|try
operator|<=
name|quit_trying
condition|)
block|{
name|int
name|c
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[waiting for e7000...]\n"
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME!  this didn't seem right->  while (c != SERIAL_TIMEOUT)        * we get stuck in this loop ...        * We may never timeout, and never sync up :-(        */
while|while
condition|(
operator|!
name|sync
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Dont echo cr's */
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|putchar_unfiltered
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* Shouldn't we either break here, or check for sync in inner loop? */
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
name|sync
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|==
literal|20
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
comment|/* Was-> quit_flag = 0; */
name|c
operator|=
operator|-
literal|1
expr_stmt|;
name|quit_trying
operator|=
name|try
operator|+
literal|1
expr_stmt|;
comment|/* we don't want to try anymore */
block|}
else|else
block|{
name|c
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sync
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Giving up after %d tries...\n"
argument_list|,
name|try
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Unable to synchronize with target.\n"
argument_list|)
expr_stmt|;
block|}
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"b -\r"
argument_list|)
expr_stmt|;
comment|/* Clear breakpoints */
name|expect_prompt
argument_list|()
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
comment|/* This is really the job of start_remote however, that makes an assumption    that the target is about to print out a status message of some sort.  That    doesn't happen here. */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|print_stack_frame
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|n
operator|=
name|e7000_parse_device
argument_list|(
name|args
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|e7000_desc
operator|=
name|serial_open
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|e7000_desc
argument_list|,
name|baudrate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|e7000_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
block|}
name|serial_raw
argument_list|(
name|e7000_desc
argument_list|)
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|e7000_start_remote
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Remote target %s connected to %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|e7000_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|e7000_desc
condition|)
block|{
name|serial_close
argument_list|(
name|e7000_desc
argument_list|)
expr_stmt|;
name|e7000_desc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.  Use this    when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_detach
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls e7000_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sigal
parameter_list|)
block|{
if|if
condition|(
name|step
condition|)
name|puts_e7000debug
argument_list|(
literal|"S\r"
argument_list|)
expr_stmt|;
else|else
name|puts_e7000debug
argument_list|(
literal|"G\r"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.       For the H8/300 a register dump looks like:     PC=00021A  CCR=80:I*******    ER0 - ER3  0000000A 0000002E 0000002E 00000000    ER4 - ER7  00000000 00000000 00000000 00FFEFF6    000218           MOV.B     R1L,R2L    STEP NORMAL END or    BREAK POINT  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|want_h8300h
init|=
literal|"PC=%p CCR=%c\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc_h8300h
init|=
literal|"%p CCR=%c\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_h8300s
init|=
literal|"PC=%p CCR=%c\n\  MACH=\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc_h8300s
init|=
literal|"%p CCR=%c EXR=%9\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_sh
init|=
literal|"PC=%16 SR=%22\n\ PR=%17 GBR=%18 VBR=%19\n\ MACH=%20 MACL=%21\n\ R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\ R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc_sh
init|=
literal|"%16 SR=%22\n\  PR=%17 GBR=%18 VBR=%19\n\  MACH=%20 MACL=%21\n\  R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\  R8-15 %8 %9 %10 %11 %12 %13 %14 %15"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_sh3
init|=
literal|"PC=%16 SR=%22\n\ PR=%17 GBR=%18 VBR=%19\n\ MACH=%20 MACL=%21 SSR=%23 SPC=%24\n\ R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\ R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\ R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\ R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\ R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\ R4_BANK1-R7_BANK1 %37 %38 %39 %40"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc_sh3
init|=
literal|"%16 SR=%22\n\  PR=%17 GBR=%18 VBR=%19\n\  MACH=%20 MACL=%21 SSR=%22 SPC=%23\n\  R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\  R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\  R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\  R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\  R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\  R4_BANK1-R7_BANK1 %37 %38 %39 %40"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|gch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|readchar
argument_list|(
name|timeout
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|gbyte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|high
init|=
name|convert_hex_digit
argument_list|(
name|gch
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|low
init|=
name|convert_hex_digit
argument_list|(
name|gch
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|high
operator|<<
literal|4
operator|)
operator|+
name|low
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_regs_from_dump
parameter_list|(
name|int
function_decl|(
modifier|*
name|nextchar
function_decl|)
parameter_list|()
parameter_list|,
name|char
modifier|*
name|want
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|thischar
init|=
name|nextchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Register set not selected."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|want
condition|)
block|{
switch|switch
condition|(
operator|*
name|want
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Skip to end of line and then eat all new line type stuff */
while|while
condition|(
name|thischar
operator|!=
literal|'\n'
operator|&&
name|thischar
operator|!=
literal|'\r'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|thischar
operator|==
literal|'\n'
operator|||
name|thischar
operator|==
literal|'\r'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
while|while
condition|(
name|thischar
operator|==
literal|' '
operator|||
name|thischar
operator|==
literal|'\t'
operator|||
name|thischar
operator|==
literal|'\r'
operator|||
name|thischar
operator|==
literal|'\n'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|want
operator|==
name|thischar
condition|)
block|{
name|want
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|want
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thischar
operator|==
literal|' '
operator|||
name|thischar
operator|==
literal|'\n'
operator|||
name|thischar
operator|==
literal|'\r'
condition|)
block|{
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"out of sync in fetch registers wanted<%s>, got<%c 0x%x>"
argument_list|,
name|want
argument_list|,
name|thischar
argument_list|,
name|thischar
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
comment|/* Got a register command */
name|want
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|want
condition|)
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
case|case
literal|'p'
case|:
name|regno
operator|=
name|PC_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CCR_REGNUM
case|case
literal|'c'
case|:
name|regno
operator|=
name|CCR_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SP_REGNUM
case|case
literal|'s'
case|:
name|regno
operator|=
name|SP_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEPRECATED_FP_REGNUM
case|case
literal|'f'
case|:
name|regno
operator|=
name|DEPRECATED_FP_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|want
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|want
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|regno
operator|=
operator|(
name|want
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|want
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|want
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|regno
operator|=
name|want
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|want
operator|++
expr_stmt|;
block|}
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|get_hex
argument_list|(
operator|&
name|thischar
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_fetch_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|wanted
init|=
name|NULL
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"R\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_sh
condition|)
block|{
name|wanted
operator|=
name|want_sh
expr_stmt|;
switch|switch
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_sh3
case|:
case|case
name|bfd_mach_sh3e
case|:
case|case
name|bfd_mach_sh4
case|:
name|wanted
operator|=
name|want_sh3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_h8300
condition|)
block|{
name|wanted
operator|=
name|want_h8300h
expr_stmt|;
switch|switch
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_h8300s
case|:
case|case
name|bfd_mach_h8300sn
case|:
case|case
name|bfd_mach_h8300sx
case|:
case|case
name|bfd_mach_h8300sxn
case|:
name|wanted
operator|=
name|want_h8300s
expr_stmt|;
block|}
block|}
name|fetch_regs_from_dump
argument_list|(
name|gch
argument_list|,
name|wanted
argument_list|)
expr_stmt|;
comment|/* And supply the extra ones the simulator uses */
for|for
control|(
name|regno
operator|=
name|NUM_REALREGS
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|buf
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.  Returns    errno value.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|e7000_fetch_registers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_store_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REALREGS
condition|;
name|regno
operator|++
control|)
name|e7000_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|e7000_store_registers
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_h8300
condition|)
block|{
if|if
condition|(
name|regno
operator|<=
literal|7
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ER%d %s\r"
argument_list|,
name|regno
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PC %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CCR_REGNUM
elseif|else
if|if
condition|(
name|regno
operator|==
name|CCR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".CCR %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_sh
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PC %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".SR %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PR %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|GBR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".GBR %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|VBR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".VBR %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|MACH_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".MACH %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|MACL_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".MACL %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".R%d %s\r"
argument_list|,
name|regno
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stickbyte
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|unsigned
name|int
name|what
parameter_list|)
block|{
specifier|static
name|CONST
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|digs
index|[
operator|(
name|what
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
name|digs
index|[
operator|(
name|what
operator|&
literal|0xf
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
return|return
name|what
return|;
block|}
end_function

begin_comment
comment|/* Write a small ammount of memory. */
end_comment

begin_function
specifier|static
name|int
name|write_small
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|+
name|i
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|+
literal|3
operator|<
name|len
operator|)
condition|)
block|{
comment|/* Can be done with a long word */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %s %x%02x%02x%02x;l\r"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
operator|+
name|i
argument_list|)
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %s %x\r"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
operator|+
name|i
argument_list|)
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Write a large ammount of memory, this only works with the serial    mode enabled.  Command is sent as     il ;s:s\r     -><- il ;s:s\r<-   ENQ    ACK          -><- LO s\r    Srecords...    ^Z           -><-   ENQ    ACK          -><-   :         */
end_comment

begin_function
specifier|static
name|int
name|write_large
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|maxstride
value|128
name|int
name|stride
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"IL ;S:FK\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|ENQSTRING
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"LO FK\r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|stride
control|)
block|{
name|char
name|compose
index|[
name|maxstride
operator|*
literal|2
operator|+
literal|50
index|]
decl_stmt|;
name|int
name|address
init|=
name|i
operator|+
name|memaddr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|check_sum
decl_stmt|;
name|int
name|where
init|=
literal|0
decl_stmt|;
name|int
name|alen
decl_stmt|;
name|stride
operator|=
name|len
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|stride
operator|>
name|maxstride
condition|)
name|stride
operator|=
name|maxstride
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'S'
expr_stmt|;
name|check_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|>=
literal|0xffffff
condition|)
name|alen
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|address
operator|>=
literal|0xffff
condition|)
name|alen
operator|=
literal|3
expr_stmt|;
else|else
name|alen
operator|=
literal|2
expr_stmt|;
comment|/* Insert type. */
name|compose
index|[
name|where
operator|++
index|]
operator|=
name|alen
operator|-
literal|1
operator|+
literal|'0'
expr_stmt|;
comment|/* Insert length. */
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|alen
operator|+
name|stride
operator|+
literal|1
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|alen
operator|>
literal|0
condition|)
block|{
name|alen
operator|--
expr_stmt|;
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|address
operator|>>
operator|(
literal|8
operator|*
operator|(
name|alen
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|stride
condition|;
name|j
operator|++
control|)
block|{
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|myaddr
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
block|}
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
operator|~
name|check_sum
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|serial_write
argument_list|(
name|e7000_desc
argument_list|,
name|compose
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|j
operator|=
name|readchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This is ok - nothing there */
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|ENQ
condition|)
block|{
comment|/* Hmm, it's trying to tell us something */
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error writing memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"@%d}@"
argument_list|,
name|j
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|readchar
argument_list|(
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"@{%d}@"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Send the trailer record */
name|write_e7000
argument_list|(
literal|"S70500000000FA\r"
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLZ
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|ENQSTRING
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's    memory at MEMADDR.  Returns length moved.     Can't use the Srecord load over ethernet, so don't use fast method    then.  */
end_comment

begin_function
specifier|static
name|int
name|e7000_write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|16
operator|||
name|using_tcp
operator|||
name|using_pc
condition|)
return|return
name|write_small
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|write_large
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.      Small transactions we send    m<addr>;l    and receive    00000000 12345678 ?  */
end_comment

begin_function
specifier|static
name|int
name|e7000_read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
comment|/* Starting address of this pass.  */
comment|/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len); */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %s;l\r"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len
condition|;
name|count
operator|+=
literal|4
control|)
block|{
comment|/* Suck away the address */
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
comment|/* Some kind of error */
name|puts_e7000debug
argument_list|(
literal|".\r"
argument_list|)
expr_stmt|;
comment|/* Some errors leave us in memory input mode */
name|expect_full_prompt
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|c
operator|!=
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
comment|/* Now read in the data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|gbyte
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|+
name|i
operator|<
name|len
condition|)
block|{
name|myaddr
index|[
name|count
operator|+
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/* Skip the trailing ? and send a . to end and a cr for more */
name|gch
argument_list|()
expr_stmt|;
name|gch
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|4
operator|>=
name|len
condition|)
name|puts_e7000debug
argument_list|(
literal|".\r"
argument_list|)
expr_stmt|;
else|else
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*    For large transfers we used to send      d<addr><endaddr>\r     and receive<ADDRESS><    D   A   T   A><   ASCII CODE>    00000000 5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."    00000010 FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@."    00000020 7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"     A cost in chars for each transaction of 80 + 5*n-bytes.      Large transactions could be done with the srecord load code, but    there is a pause for a second before dumping starts, which slows the    average rate down!  */
end_comment

begin_function
specifier|static
name|int
name|e7000_read_inferior_memory_large
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
comment|/* Starting address of this pass.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"d %s %s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
operator|+
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
comment|/* skip down to the first ">" */
while|while
condition|(
name|c
operator|!=
literal|'>'
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
comment|/* now skip to the end of that line */
while|while
condition|(
name|c
operator|!=
literal|'\r'
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|len
condition|)
block|{
comment|/* get rid of any white space before the address */
while|while
condition|(
name|c
operator|<=
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
comment|/* Skip the address */
name|get_hex
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
comment|/* read in the bytes on the line */
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|count
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
else|else
block|{
name|myaddr
index|[
name|count
operator|++
index|]
operator|=
name|get_hex
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* throw out the rest of the line */
while|while
condition|(
name|c
operator|!=
literal|'\r'
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
block|}
comment|/* wait for the ":" prompt */
while|while
condition|(
name|c
operator|!=
literal|':'
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int fast_but_for_the_pause_e7000_read_inferior_memory (CORE_ADDR memaddr, 						   char *myaddr, int len) {   int loop;   int c;   char buf[200];    if (((memaddr - 1) + len)< memaddr)     {       errno = EIO;       return 0;     }    sprintf (buf, "is %x@%x:s\r", memaddr, len);   puts_e7000debug (buf);   gch ();   c = gch ();   if (c != ENQ)     {
comment|/* Got an error */
end_comment

begin_comment
unit|error ("Memory read error");     }   putchar_e7000 (ACK);   expect ("SV s");   loop = 1;   while (loop)     {       int type;       int length;       int addr;       int i;        c = gch ();       switch (c) 	{ 	case ENQ:
comment|/* ENQ, at the end */
end_comment

begin_comment
unit|loop = 0; 	  break; 	case 'S':
comment|/* Start of an Srecord */
end_comment

begin_comment
unit|type = gch (); 	  length = gbyte (); 	  switch (type) 	    { 	    case '7':
comment|/* Termination record, ignore */
end_comment

begin_comment
unit|case '0': 	    case '8': 	    case '9':
comment|/* Header record - ignore it */
end_comment

begin_comment
unit|while (length--) 		{ 		  gbyte (); 		} 	      break; 	    case '1': 	    case '2': 	    case '3': 	      { 		int alen;  		alen = type - '0' + 1; 		addr = 0; 		while (alen--) 		  { 		    addr = (addr<< 8) + gbyte (); 		    length--; 		  }  		for (i = 0; i< length - 1; i++) 		  myaddr[i + addr - memaddr] = gbyte ();  		gbyte ();
comment|/* Ignore checksum */
end_comment

begin_endif
unit|} 	    } 	}     }    putchar_e7000 (ACK);   expect ("TOP ADDRESS =");   expect ("END ADDRESS =");   expect (":");    return len; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If WRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
specifier|static
name|int
name|e7000_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|write
condition|)
return|return
name|e7000_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|len
operator|<
literal|16
condition|)
return|return
name|e7000_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|e7000_read_inferior_memory_large
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_kill
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|e7000_load
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd
modifier|*
name|pbfd
decl_stmt|;
name|bfd_vma
name|entry
decl_stmt|;
define|#
directive|define
name|WRITESIZE
value|0x1000
name|char
name|buf
index|[
literal|2
operator|+
literal|4
operator|+
literal|4
operator|+
name|WRITESIZE
index|]
decl_stmt|;
comment|/* `DT' +<addr> +<len> +<data> */
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|quiet
decl_stmt|;
name|int
name|nostart
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* Start and end times of download */
name|unsigned
name|long
name|data_count
decl_stmt|;
comment|/* Number of bytes transferred to memory */
name|int
name|oldtimeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
comment|/* FIXME! change test to test for type of download */
if|if
condition|(
operator|!
name|using_tcp
condition|)
block|{
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* for direct tcp connections, we can do a fast binary download */
name|buf
index|[
literal|0
index|]
operator|=
literal|'D'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'T'
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|nostart
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
name|filename
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-quiet"
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-nostart"
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nostart
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pbfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|old_chain
operator|=
name|make_cleanup_bfd_close
argument_list|(
name|pbfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|pbfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|data_count
operator|=
literal|0
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"mw\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\nOK"
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|pbfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_vma
name|section_address
decl_stmt|;
name|bfd_size_type
name|section_size
decl_stmt|;
name|file_ptr
name|fptr
decl_stmt|;
name|section_address
operator|=
name|bfd_get_section_vma
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|section_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"[Loading section %s at 0x%s (%s bytes)]\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|section_address
argument_list|)
argument_list|,
name|paddr_u
argument_list|(
name|section_size
argument_list|)
argument_list|)
expr_stmt|;
name|fptr
operator|=
literal|0
expr_stmt|;
name|data_count
operator|+=
name|section_size
expr_stmt|;
while|while
condition|(
name|section_size
operator|>
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|char
name|inds
index|[]
init|=
literal|"|/-\\"
decl_stmt|;
specifier|static
name|int
name|k
init|=
literal|0
decl_stmt|;
name|QUIT
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|section_size
argument_list|,
name|WRITESIZE
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|section_address
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|section_address
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|section_address
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|section_address
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|count
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|count
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
name|count
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
name|count
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|,
name|buf
operator|+
literal|10
argument_list|,
name|fptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_write
argument_list|(
name|e7000_desc
argument_list|,
name|buf
argument_list|,
name|count
operator|+
literal|10
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"e7000_load: serial_write failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\r%c"
argument_list|,
name|inds
index|[
name|k
operator|++
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|section_address
operator|+=
name|count
expr_stmt|;
name|fptr
operator|+=
name|count
expr_stmt|;
name|section_size
operator|-=
name|count
expr_stmt|;
block|}
block|}
block|}
name|write_e7000
argument_list|(
literal|"ED"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nostart
condition|)
block|{
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|pbfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_unfiltered
argument_list|(
literal|"[Starting %s at 0x%s]\n"
argument_list|,
name|filename
argument_list|,
name|paddr_nz
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      start_routine (entry); */
block|}
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|oldtimeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|MAX_BREAKPOINTS
value|200
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
end_ifdef

begin_define
define|#
directive|define
name|MAX_E7000DEBUG_BREAKPOINTS
value|(BC_BREAKPOINTS ? 5 :  MAX_BREAKPOINTS)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_E7000DEBUG_BREAKPOINTS
value|MAX_BREAKPOINTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Since we can change to soft breakpoints dynamically, we must define     more than enough.  Was breakaddr[MAX_E7000DEBUG_BREAKPOINTS]. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|e7000_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|static char nop[2] = NOP;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_E7000DEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
comment|/* Save old contents, and insert a nop in the space */
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
if|if
condition|(
name|BC_BREAKPOINTS
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"BC%d A=%s\r"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B %s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
literal|0
block|e7000_read_inferior_memory (addr, shadow, 2); 	e7000_write_inferior_memory (addr, nop, 2);
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B %x\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
argument_list|(
literal|"Too many breakpoints (> %d) for the E7000\n"
argument_list|,
name|MAX_E7000DEBUG_BREAKPOINTS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_E7000DEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
if|if
condition|(
name|BC_BREAKPOINTS
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"BC%d - \r"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B - %s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B - %s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Replace the insn under the break */
block|e7000_write_inferior_memory (addr, shadow, 2);
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|warning
argument_list|(
literal|"Can't find breakpoint associated with 0x%s\n"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to STDBUG.  Output from STDBUG    is placed on the users terminal until the prompt is seen. */
end_comment

begin_function
specifier|static
name|void
name|e7000_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
comment|/* FIXME: arbitrary limit on length of args.  */
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|echo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|error
argument_list|(
literal|"e7000 target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|echo
operator|++
expr_stmt|;
name|ctrl_c
operator|=
literal|2
expr_stmt|;
name|expect_full_prompt
argument_list|()
expr_stmt|;
name|echo
operator|--
expr_stmt|;
name|ctrl_c
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Who knows what the command did... */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_drain_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"end\r"
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|' '
operator|&&
name|c
operator|<
literal|127
condition|)
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"<%x>"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NITEMS
value|7
end_define

begin_function
specifier|static
name|int
name|why_stop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|strings
index|[
name|NITEMS
index|]
init|=
block|{
literal|"STEP NORMAL"
block|,
literal|"BREAK POINT"
block|,
literal|"BREAK KEY"
block|,
literal|"BREAK CONDI"
block|,
literal|"CYCLE ACCESS"
block|,
literal|"ILLEGAL INSTRUCTION"
block|,
literal|"WRITE PROTECT"
block|,   }
decl_stmt|;
name|char
modifier|*
name|p
index|[
name|NITEMS
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NITEMS
condition|;
operator|++
name|i
control|)
name|p
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NITEMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
operator|(
name|p
index|[
name|i
index|]
operator|)
condition|)
block|{
name|p
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* found one of the choices */
return|return
name|i
return|;
block|}
block|}
else|else
name|p
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
block|}
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Suck characters, if a string match, then return the strings index    otherwise echo them.  */
end_comment

begin_function
specifier|static
name|int
name|expect_n
parameter_list|(
name|char
modifier|*
modifier|*
name|strings
parameter_list|)
block|{
name|char
argument_list|*
operator|(
name|ptr
index|[
literal|10
index|]
operator|)
argument_list|;
name|int
name|n
argument_list|;
name|int
name|c
argument_list|;
name|char
name|saveaway
index|[
literal|100
index|]
argument_list|;
name|char
operator|*
name|buffer
operator|=
name|saveaway
argument_list|;
comment|/* Count number of expect strings  */
argument_list|for
operator|(
name|n
operator|=
literal|0
expr|;
name|strings
index|[
name|n
index|]
expr|;
name|n
operator|++
operator|)
block|{
name|ptr
index|[
name|n
index|]
operator|=
name|strings
index|[
name|n
index|]
block|;     }
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|gotone
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[waiting for e7000...]\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GO32__
if|if
condition|(
name|kbhit
argument_list|()
condition|)
block|{
name|int
name|k
init|=
name|getkey
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
name|quit_flag
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
comment|/* interrupt the running program */
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|ptr
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
name|ptr
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Gone all the way */
return|return
name|i
return|;
block|}
name|gotone
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotone
condition|)
block|{
comment|/* Save it up incase we find that there was no match */
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer
operator|!=
name|saveaway
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|saveaway
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|putchar_unfiltered
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* We subtract two from the pc here rather than use    DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the    pc, and the simulators never do. */
end_comment

begin_function
specifier|static
name|void
name|sub2_from_pc
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|200
index|]
decl_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|".PC %s\r"
argument_list|,
name|phex_nz
argument_list|(
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|WAS_SLEEP
value|0
end_define

begin_define
define|#
directive|define
name|WAS_INT
value|1
end_define

begin_define
define|#
directive|define
name|WAS_RUNNING
value|2
end_define

begin_define
define|#
directive|define
name|WAS_OTHER
value|3
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|estrings
index|[]
init|=
block|{
literal|"** SLEEP"
block|,
literal|"BREAK !"
block|,
literal|"** PC"
block|,
literal|"PC"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    STATUS just as `wait' would.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|e7000_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|stop_reason
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|running_count
init|=
literal|0
decl_stmt|;
name|int
name|had_sleep
init|=
literal|0
decl_stmt|;
name|int
name|loop
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|wanted_nopc
init|=
name|NULL
decl_stmt|;
comment|/* Then echo chars until PC= string seen */
name|gch
argument_list|()
expr_stmt|;
comment|/* Drop cr */
name|gch
argument_list|()
expr_stmt|;
comment|/* and space */
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|expect_n
argument_list|(
name|estrings
argument_list|)
condition|)
block|{
case|case
name|WAS_OTHER
case|:
comment|/* how did this happen ? */
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_SLEEP
case|:
name|had_sleep
operator|=
literal|1
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_INT
case|:
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_RUNNING
case|:
name|running_count
operator|++
expr_stmt|;
if|if
condition|(
name|running_count
operator|==
literal|20
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[running...]\n"
argument_list|)
expr_stmt|;
name|running_count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error? */
break|break;
block|}
block|}
comment|/* Skip till the PC= */
name|expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_sh
condition|)
block|{
name|wanted_nopc
operator|=
name|want_nopc_sh
expr_stmt|;
switch|switch
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_sh3
case|:
case|case
name|bfd_mach_sh3e
case|:
case|case
name|bfd_mach_sh4
case|:
name|wanted_nopc
operator|=
name|want_nopc_sh3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_h8300
condition|)
block|{
name|wanted_nopc
operator|=
name|want_nopc_h8300h
expr_stmt|;
switch|switch
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_h8300s
case|:
case|case
name|bfd_mach_h8300sn
case|:
case|case
name|bfd_mach_h8300sx
case|:
case|case
name|bfd_mach_h8300sxn
case|:
name|wanted_nopc
operator|=
name|want_nopc_h8300s
expr_stmt|;
block|}
block|}
name|fetch_regs_from_dump
argument_list|(
name|gch
argument_list|,
name|wanted_nopc
argument_list|)
expr_stmt|;
comment|/* And supply the extra ones the simulator uses */
for|for
control|(
name|regno
operator|=
name|NUM_REALREGS
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|buf
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
name|stop_reason
operator|=
name|why_stop
argument_list|()
expr_stmt|;
name|expect_full_prompt
argument_list|()
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
switch|switch
condition|(
name|stop_reason
condition|)
block|{
case|case
literal|1
case|:
comment|/* Breakpoint */
name|write_pc
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* PC is always off by 2 for breakpoints */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Single step */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Interrupt */
if|if
condition|(
name|had_sleep
condition|)
block|{
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|sub2_from_pc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
break|break;
case|case
literal|4
case|:
name|printf_unfiltered
argument_list|(
literal|"a cycle address error?\n"
argument_list|)
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_ILL
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Anything else (NITEMS + 1) */
name|printf_unfiltered
argument_list|(
literal|"a write protect error?\n"
argument_list|)
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
default|default:
comment|/* Get the user's attention - this should never happen. */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Stop the running program.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_stop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Sending a ^C is supposed to stop the running program.  */
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names. */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|e7000_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_e7000_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|e7000_ops
operator|.
name|to_shortname
operator|=
literal|"e7000"
expr_stmt|;
name|e7000_ops
operator|.
name|to_longname
operator|=
literal|"Remote Renesas e7000 target"
expr_stmt|;
name|e7000_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote Renesas e7000 ICE connected by a serial line;\n\ or a network connection.\n\ Arguments are the name of the device for the serial line,\n\ the speed to connect at in bits per second.\n\ eg\n\ target e7000 /dev/ttya 9600\n\ target e7000 foobar"
expr_stmt|;
name|e7000_ops
operator|.
name|to_open
operator|=
name|e7000_open
expr_stmt|;
name|e7000_ops
operator|.
name|to_close
operator|=
name|e7000_close
expr_stmt|;
name|e7000_ops
operator|.
name|to_detach
operator|=
name|e7000_detach
expr_stmt|;
name|e7000_ops
operator|.
name|to_resume
operator|=
name|e7000_resume
expr_stmt|;
name|e7000_ops
operator|.
name|to_wait
operator|=
name|e7000_wait
expr_stmt|;
name|e7000_ops
operator|.
name|to_fetch_registers
operator|=
name|e7000_fetch_register
expr_stmt|;
name|e7000_ops
operator|.
name|to_store_registers
operator|=
name|e7000_store_register
expr_stmt|;
name|e7000_ops
operator|.
name|to_prepare_to_store
operator|=
name|e7000_prepare_to_store
expr_stmt|;
name|e7000_ops
operator|.
name|to_xfer_memory
operator|=
name|e7000_xfer_inferior_memory
expr_stmt|;
name|e7000_ops
operator|.
name|to_files_info
operator|=
name|e7000_files_info
expr_stmt|;
name|e7000_ops
operator|.
name|to_insert_breakpoint
operator|=
name|e7000_insert_breakpoint
expr_stmt|;
name|e7000_ops
operator|.
name|to_remove_breakpoint
operator|=
name|e7000_remove_breakpoint
expr_stmt|;
name|e7000_ops
operator|.
name|to_kill
operator|=
name|e7000_kill
expr_stmt|;
name|e7000_ops
operator|.
name|to_load
operator|=
name|e7000_load
expr_stmt|;
name|e7000_ops
operator|.
name|to_create_inferior
operator|=
name|e7000_create_inferior
expr_stmt|;
name|e7000_ops
operator|.
name|to_mourn_inferior
operator|=
name|e7000_mourn_inferior
expr_stmt|;
name|e7000_ops
operator|.
name|to_stop
operator|=
name|e7000_stop
expr_stmt|;
name|e7000_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|e7000_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|e7000_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|e7000_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|e7000_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|e7000_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|e7000_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_remote_e7000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_remote_e7000
parameter_list|(
name|void
parameter_list|)
block|{
name|init_e7000_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"e7000"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_command
argument_list|,
literal|"Send a command to the e7000 monitor."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"ftplogin"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_login_command
argument_list|,
literal|"Login to machine and change to directory."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"ftpload"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_ftp_command
argument_list|,
literal|"Fetch and load a file from previously described place."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"drain"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_drain_command
argument_list|,
literal|"Drain pending e7000 text buffers."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"usehardbreakpoints"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|use_hard_breakpoints
argument_list|,
literal|"Set use of hardware breakpoints for all breakpoints.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

