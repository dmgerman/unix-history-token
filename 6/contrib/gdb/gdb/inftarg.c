begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-vector operations for controlling Unix child processes, for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,    2000, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Cygnus Support.     ## Contains temporary hacks..     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"inflow.h"
end_include

begin_function_decl
specifier|extern
name|struct
name|symtab_and_line
modifier|*
name|child_enable_exception_callback
parameter_list|(
name|enum
name|exception_event_kind
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|exception_event_record
modifier|*
name|child_get_current_exception_event
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_initialize_inftarg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_WAIT
end_ifndef

begin_function_decl
specifier|static
name|ptid_t
name|child_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHILD_WAIT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_WAIT
argument_list|)
end_if

begin_function_decl
name|void
name|child_post_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|child_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_detach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_attach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_ATTACH
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
name|child_post_attach
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ptrace_me
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ptrace_him
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|child_can_run
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|child_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_THREAD_ALIVE
end_ifndef

begin_function_decl
name|int
name|child_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|init_child_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|child_suppress_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inftarg should pretend not to 				   be a runnable target.  Used by targets 				   that can sit atop inftarg, such as HPUX 				   thread support.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_WAIT
end_ifndef

begin_comment
comment|/* Wait for child to do something.  Return pid of child, or -1 in case    of error; store status through argument pointer OURSTATUS.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|child_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|int
name|save_errno
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|execd_pathname
init|=
name|NULL
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
name|int
name|related_pid
decl_stmt|;
name|int
name|syscall_id
decl_stmt|;
name|enum
name|target_waitkind
name|kind
decl_stmt|;
name|int
name|pid
decl_stmt|;
do|do
block|{
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 				   attached process. */
name|set_sigio_trap
argument_list|()
expr_stmt|;
name|pid
operator|=
name|ptrace_wait
argument_list|(
name|inferior_ptid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|clear_sigio_trap
argument_list|()
expr_stmt|;
name|clear_sigint_trap
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Child process unexpectedly missing: %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Claim it exited with unknown signal.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/* Did it exit?        */
if|if
condition|(
name|target_has_exited
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
operator|&
name|exit_status
argument_list|)
condition|)
block|{
comment|/* ??rehrauer: For now, ignore this. */
continue|continue;
block|}
if|if
condition|(
operator|!
name|target_thread_alive
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
return|;
block|}
block|}
do|while
condition|(
name|pid
operator|!=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
do|;
comment|/* Some other child died or stopped */
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHILD_WAIT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_WAIT
argument_list|)
end_if

begin_function
name|void
name|child_post_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|wait_status
parameter_list|)
block|{
comment|/* This version of Unix doesn't require a meaningful "post wait"      operation.    */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_THREAD_ALIVE
end_ifndef

begin_comment
comment|/* Check to see if the given thread is alive.     FIXME: Is kill() ever the right way to do this?  I doubt it, but    for now we're going to try and be compatable with the old thread    code.  */
end_comment

begin_function
name|int
name|child_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|pid_t
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
return|return
operator|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Attach to process PID, then initialize for debugging it.  */
end_comment

begin_function
specifier|static
name|void
name|child_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ATTACH_DETACH
name|error
argument_list|(
literal|"Can't attach to a process on this machine."
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|dummy
decl_stmt|;
name|dummy
operator|=
name|args
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
operator|&
name|dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Some targets don't set errno on errors, grrr! */
if|if
condition|(
operator|(
name|pid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|args
operator|==
name|dummy
operator|)
condition|)
name|error
argument_list|(
literal|"Illegal process-id: %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program: %s, %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATTACH_DETACH */
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_ATTACH
argument_list|)
end_if

begin_function
name|void
name|child_post_attach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't require a meaningful "post attach"      operation by a debugger.  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|child_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATTACH_DETACH
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s, %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|error
argument_list|(
literal|"This version of Unix does not support detaching a process."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|child_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|child_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_open
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub function which causes the inferior that runs it, to be ptrace-able    by its parent process.  */
end_comment

begin_function
specifier|static
name|void
name|ptrace_me
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* "Trace me, Dr. Memory!" */
name|call_ptrace
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub function which causes the GDB that runs it, to start ptrace-ing    the child process.  */
end_comment

begin_function
specifier|static
name|void
name|ptrace_him
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
comment|/* On some targets, there must be some explicit synchronization      between the parent and child processes after the debugger      forks, and before the child execs the debuggee program.  This      call basically gives permission for the child to exec.    */
name|target_acknowledge_created_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* START_INFERIOR_TRAPS_EXPECTED is defined in inferior.h,    * and will be 1 or 2 depending on whether we're starting    * without or with a shell.    */
name|startup_inferior
argument_list|(
name|START_INFERIOR_TRAPS_EXPECTED
argument_list|)
expr_stmt|;
comment|/* On some targets, there must be some explicit actions taken after      the inferior has been started up.    */
name|target_post_startup_inferior
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior Unix child process and sets inferior_ptid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().  */
end_comment

begin_function
specifier|static
name|void
name|child_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HPUXHPPA
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|ptrace_me
argument_list|,
name|ptrace_him
argument_list|,
name|pre_fork_inferior
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|ptrace_me
argument_list|,
name|ptrace_him
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_STARTUP_INFERIOR
argument_list|)
end_if

begin_function
name|void
name|child_post_startup_inferior
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
comment|/* This version of Unix doesn't require a meaningful "post startup inferior"      operation by a debugger.    */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_ACKNOWLEDGE_CREATED_INFERIOR
argument_list|)
end_if

begin_function
name|void
name|child_acknowledge_created_inferior
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't require a meaningful "acknowledge created inferior"      operation by a debugger.    */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_fork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of fork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_fork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of fork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_vfork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of vfork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_vfork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of vfork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_FOLLOW_FORK
argument_list|)
end_if

begin_function
name|int
name|child_follow_fork
parameter_list|(
name|int
name|follow_child
parameter_list|)
block|{
comment|/* This version of Unix doesn't support following fork or vfork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_exec_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of exec events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_exec_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of exec events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL
argument_list|)
end_if

begin_function
name|int
name|child_reported_exec_events_per_exec_call
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This version of Unix doesn't support notification of exec events.    */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_EXITED
argument_list|)
end_if

begin_function
name|int
name|child_has_exited
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|wait_status
parameter_list|,
name|int
modifier|*
name|exit_status
parameter_list|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
operator|*
name|exit_status
operator|=
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
operator|*
name|exit_status
operator|=
literal|0
expr_stmt|;
comment|/* ?? Don't know what else to say here. */
return|return
literal|1
return|;
block|}
comment|/* ?? Do we really need to consult the event state, too?  Assume the      wait_state alone suffices.    */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|child_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|child_can_run
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This variable is controlled by modules that sit atop inftarg that may layer      their own process structure atop that provided here.  hpux-thread.c does      this because of the Hpux user-mode level thread model.  */
return|return
operator|!
name|child_suppress_run
return|;
block|}
end_function

begin_comment
comment|/* Send a SIGINT to the process group.  This acts just like the user typed a    ^C on the controlling terminal.     XXX - This may not be correct for all systems.  Some may want to use    killpg() instead of kill (-pgrp). */
end_comment

begin_function
specifier|static
name|void
name|child_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|kill
argument_list|(
operator|-
name|inferior_process_group
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_ENABLE_EXCEPTION_CALLBACK
argument_list|)
end_if

begin_function
name|struct
name|symtab_and_line
modifier|*
name|child_enable_exception_callback
parameter_list|(
name|enum
name|exception_event_kind
name|kind
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_GET_CURRENT_EXCEPTION_EVENT
argument_list|)
end_if

begin_function
name|struct
name|exception_event_record
modifier|*
name|child_get_current_exception_event
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|exception_event_record
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_PID_TO_EXEC_FILE
argument_list|)
end_if

begin_function
name|char
modifier|*
name|child_pid_to_exec_file
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* This version of Unix doesn't support translation of a process ID      to the filename of the executable file.    */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|child_core_file_to_sym_file
parameter_list|(
name|char
modifier|*
name|core
parameter_list|)
block|{
comment|/* The target stratum for a running executable need not support      this operation.    */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Perform a partial transfer to/from the specified object.  For    memory transfers, fall back to the old memory xfer functions.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|child_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|object
condition|)
block|{
case|case
name|TARGET_OBJECT_MEMORY
case|:
if|if
condition|(
name|readbuf
condition|)
return|return
name|child_xfer_memory
argument_list|(
name|offset
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|,
literal|0
comment|/*write*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
if|if
condition|(
name|writebuf
condition|)
return|return
name|child_xfer_memory
argument_list|(
name|offset
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|,
literal|1
comment|/*write*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
case|case
name|TARGET_OBJECT_UNWIND_TABLE
case|:
ifndef|#
directive|ifndef
name|NATIVE_XFER_UNWIND_TABLE
define|#
directive|define
name|NATIVE_XFER_UNWIND_TABLE
parameter_list|(
name|OPS
parameter_list|,
name|OBJECT
parameter_list|,
name|ANNEX
parameter_list|,
name|WRITEBUF
parameter_list|,
name|READBUF
parameter_list|,
name|OFFSET
parameter_list|,
name|LEN
parameter_list|)
value|(-1)
endif|#
directive|endif
return|return
name|NATIVE_XFER_UNWIND_TABLE
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TARGET_OBJECT_AUXV
case|:
ifndef|#
directive|ifndef
name|NATIVE_XFER_AUXV
define|#
directive|define
name|NATIVE_XFER_AUXV
parameter_list|(
name|OPS
parameter_list|,
name|OBJECT
parameter_list|,
name|ANNEX
parameter_list|,
name|WRITEBUF
parameter_list|,
name|READBUF
parameter_list|,
name|OFFSET
parameter_list|,
name|LEN
parameter_list|)
value|(-1)
endif|#
directive|endif
return|return
name|NATIVE_XFER_AUXV
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TARGET_OBJECT_WCOOKIE
case|:
ifndef|#
directive|ifndef
name|NATIVE_XFER_WCOOKIE
define|#
directive|define
name|NATIVE_XFER_WCOOKIE
parameter_list|(
name|OPS
parameter_list|,
name|OBJECT
parameter_list|,
name|ANNEX
parameter_list|,
name|WRITEBUF
parameter_list|,
name|READBUF
parameter_list|,
name|OFFSET
parameter_list|,
name|LEN
parameter_list|)
value|(-1)
endif|#
directive|endif
return|return
name|NATIVE_XFER_WCOOKIE
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TARGET_OBJECT_DIRTY
case|:
ifndef|#
directive|ifndef
name|NATIVE_XFER_DIRTY
define|#
directive|define
name|NATIVE_XFER_DIRTY
parameter_list|(
name|OPS
parameter_list|,
name|OBJECT
parameter_list|,
name|ANNEX
parameter_list|,
name|WRITEBUF
parameter_list|,
name|READBUF
parameter_list|,
name|OFFSET
parameter_list|,
name|LEN
parameter_list|)
value|(-1)
endif|#
directive|endif
return|return
name|NATIVE_XFER_DIRTY
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_PID_TO_STR
argument_list|)
end_if

begin_function
name|char
modifier|*
name|child_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
return|return
name|normal_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_child_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|child_ops
operator|.
name|to_shortname
operator|=
literal|"child"
expr_stmt|;
name|child_ops
operator|.
name|to_longname
operator|=
literal|"Unix child process"
expr_stmt|;
name|child_ops
operator|.
name|to_doc
operator|=
literal|"Unix child process (started by the \"run\" command)."
expr_stmt|;
name|child_ops
operator|.
name|to_open
operator|=
name|child_open
expr_stmt|;
name|child_ops
operator|.
name|to_attach
operator|=
name|child_attach
expr_stmt|;
name|child_ops
operator|.
name|to_post_attach
operator|=
name|child_post_attach
expr_stmt|;
name|child_ops
operator|.
name|to_detach
operator|=
name|child_detach
expr_stmt|;
name|child_ops
operator|.
name|to_resume
operator|=
name|child_resume
expr_stmt|;
name|child_ops
operator|.
name|to_wait
operator|=
name|child_wait
expr_stmt|;
name|child_ops
operator|.
name|to_post_wait
operator|=
name|child_post_wait
expr_stmt|;
name|child_ops
operator|.
name|to_fetch_registers
operator|=
name|fetch_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_store_registers
operator|=
name|store_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_prepare_to_store
operator|=
name|child_prepare_to_store
expr_stmt|;
name|child_ops
operator|.
name|to_xfer_memory
operator|=
name|child_xfer_memory
expr_stmt|;
name|child_ops
operator|.
name|to_xfer_partial
operator|=
name|child_xfer_partial
expr_stmt|;
name|child_ops
operator|.
name|to_files_info
operator|=
name|child_files_info
expr_stmt|;
name|child_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_save_ours
operator|=
name|terminal_save_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|child_ops
operator|.
name|to_kill
operator|=
name|kill_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_create_inferior
operator|=
name|child_create_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_post_startup_inferior
operator|=
name|child_post_startup_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|child_acknowledge_created_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|child_insert_fork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|child_remove_fork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|child_insert_vfork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|child_remove_vfork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_follow_fork
operator|=
name|child_follow_fork
expr_stmt|;
name|child_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|child_insert_exec_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|child_remove_exec_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|child_reported_exec_events_per_exec_call
expr_stmt|;
name|child_ops
operator|.
name|to_has_exited
operator|=
name|child_has_exited
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
operator|=
name|child_mourn_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_can_run
operator|=
name|child_can_run
expr_stmt|;
name|child_ops
operator|.
name|to_thread_alive
operator|=
name|child_thread_alive
expr_stmt|;
name|child_ops
operator|.
name|to_pid_to_str
operator|=
name|child_pid_to_str
expr_stmt|;
name|child_ops
operator|.
name|to_stop
operator|=
name|child_stop
expr_stmt|;
name|child_ops
operator|.
name|to_enable_exception_callback
operator|=
name|child_enable_exception_callback
expr_stmt|;
name|child_ops
operator|.
name|to_get_current_exception_event
operator|=
name|child_get_current_exception_event
expr_stmt|;
name|child_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|child_pid_to_exec_file
expr_stmt|;
name|child_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|child_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take over the 'find_mapped_memory' vector from inftarg.c. */
end_comment

begin_function
specifier|extern
name|void
name|inftarg_set_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|child_ops
operator|.
name|to_find_memory_regions
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take over the 'make_corefile_notes' vector from inftarg.c. */
end_comment

begin_function
specifier|extern
name|void
name|inftarg_set_make_corefile_notes
parameter_list|(
name|char
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|)
block|{
name|child_ops
operator|.
name|to_make_corefile_notes
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_inftarg
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_OPTIONAL_PROC_FS
name|char
name|procname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* If we have an optional /proc filesystem (e.g. under OSF/1),      don't add ptrace support if we can access the running GDB via /proc.  */
ifndef|#
directive|ifndef
name|PROC_NAME_FMT
define|#
directive|define
name|PROC_NAME_FMT
value|"/proc/%05d"
endif|#
directive|endif
name|sprintf
argument_list|(
name|procname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|init_child_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

