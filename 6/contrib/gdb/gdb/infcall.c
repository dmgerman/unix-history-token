begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform an inferior function call, for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_comment
comment|/* NOTE: cagney/2003-04-16: What's the future of this code?     GDB needs an asynchronous expression evaluator, that means an    asynchronous inferior function call implementation, and that in    turn means restructuring the code so that it is event driven.  */
end_comment

begin_comment
comment|/* How you should pass arguments to a function depends on whether it    was defined in K&R style or prototype style.  If you define a    function using the K&R syntax that takes a `float' argument, then    callers must pass that argument as a `double'.  If you define the    function using the prototype syntax, then you must pass the    argument as a `float', with no promotion.     Unfortunately, on certain older platforms, the debug info doesn't    indicate reliably how each function was defined.  A function type's    TYPE_FLAG_PROTOTYPED flag may be clear, even if the function was    defined in prototype style.  When calling a function whose    TYPE_FLAG_PROTOTYPED flag is clear, GDB consults this flag to    decide what to do.     For modern targets, it is proper to assume that, if the prototype    flag is clear, that can be trusted: `float' arguments should be    promoted to `double'.  For some older targets, if the prototype    flag is clear, that doesn't tell us anything.  The default is to    trust the debug information; the user can override this behavior    with "set coerce-float-to-double 0".  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|coerce_float_to_double_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This boolean tells what gdb should do if a signal is received while    in a function called from gdb (call dummy).  If set, gdb unwinds    the stack and restore the context to what as it was before the    call.     The default is to stop in the frame where the signal was received. */
end_comment

begin_decl_stmt
name|int
name|unwind_on_signal_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform the standard coercions that are specified    for arguments to be passed to C functions.     If PARAM_TYPE is non-NULL, it is the expected parameter type.    IS_PROTOTYPED is non-zero if the function declaration is prototyped.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_arg_coerce
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|,
name|struct
name|type
modifier|*
name|param_type
parameter_list|,
name|int
name|is_prototyped
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|param_type
condition|?
name|check_typedef
argument_list|(
name|param_type
argument_list|)
else|:
name|arg_type
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_REF
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|!=
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
block|{
name|arg
operator|=
name|value_addr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|param_type
expr_stmt|;
return|return
name|arg
return|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
comment|/* If we don't have a prototype, coerce to integer type if necessary.  */
if|if
condition|(
operator|!
name|is_prototyped
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
comment|/* Currently all target ABIs require at least the width of an integer          type for an argument.  We may have to conditionalize the following          type coercion for future targets.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_int
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
operator|!
name|is_prototyped
operator|&&
name|coerce_float_to_double_p
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_double
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_long_double
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
comment|/* Arrays are coerced to pointers to their first element, unless          they are vectors, in which case we want to leave them alone,          because they are passed by value.  */
if|if
condition|(
name|current_language
operator|->
name|c_style_arrays
condition|)
if|if
condition|(
operator|!
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
default|default:
break|break;
block|}
return|return
name|value_cast
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine a function's address and its return type from its value.    Calls error() if the function is not valid for calling.  */
end_comment

begin_function
name|CORE_ADDR
name|find_function_addr
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|retval_type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ftype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
comment|/* If it's a member function, just look at the function      part of it.  */
comment|/* Determine address to call.  */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|funaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|funaddr
operator|=
name|value_as_address
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|||
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|funaddr
operator|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|funaddr
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
else|else
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* Handle the case of functions lacking debugging info.          Their values are characters since their addresses are char */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|ftype
argument_list|)
operator|==
literal|1
condition|)
name|funaddr
operator|=
name|value_as_address
argument_list|(
name|value_addr
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Handle integer used as address of a function.  */
name|funaddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid data type for function to be called."
argument_list|)
expr_stmt|;
operator|*
name|retval_type
operator|=
name|value_type
expr_stmt|;
return|return
name|funaddr
return|;
block|}
end_function

begin_comment
comment|/* Call breakpoint_auto_delete on the current contents of the bpstat    pointed to by arg (which is really a bpstat *).  */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_auto_delete_contents
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|breakpoint_auto_delete
argument_list|(
operator|*
operator|(
name|bpstat
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|legacy_push_dummy_code
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|funaddr
parameter_list|,
name|int
name|using_gcc
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|CORE_ADDR
modifier|*
name|real_pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp_addr
parameter_list|)
block|{
comment|/* CALL_DUMMY is an array of words (DEPRECATED_REGISTER_SIZE), but      each word is in host byte order.  Before calling      DEPRECATED_FIX_CALL_DUMMY, we byteswap it and remove any extra      bytes which might exist because ULONGEST is bigger than      DEPRECATED_REGISTER_SIZE.  */
comment|/* NOTE: This is pretty wierd, as the call dummy is actually a      sequence of instructions.  But CISC machines will have to pack      the instructions into DEPRECATED_REGISTER_SIZE units (and so will      RISC machines for which INSTRUCTION_SIZE is not      DEPRECATED_REGISTER_SIZE).  */
comment|/* NOTE: This is pretty stupid.  CALL_DUMMY should be in strict      target byte order. */
name|CORE_ADDR
name|start_sp
decl_stmt|;
name|ULONGEST
modifier|*
name|dummy
init|=
name|alloca
argument_list|(
name|DEPRECATED_SIZEOF_CALL_DUMMY_WORDS
argument_list|)
decl_stmt|;
name|int
name|sizeof_dummy1
init|=
operator|(
name|DEPRECATED_REGISTER_SIZE
operator|*
name|DEPRECATED_SIZEOF_CALL_DUMMY_WORDS
operator|/
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|dummy1
init|=
name|alloca
argument_list|(
name|sizeof_dummy1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dummy
argument_list|,
name|DEPRECATED_CALL_DUMMY_WORDS
argument_list|,
name|DEPRECATED_SIZEOF_CALL_DUMMY_WORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* Stack grows down */
name|sp
operator|-=
name|sizeof_dummy1
expr_stmt|;
name|start_sp
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* Stack grows up */
name|start_sp
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|sizeof_dummy1
expr_stmt|;
block|}
comment|/* NOTE: cagney/2002-09-10: Don't bother re-adjusting the stack      after allocating space for the call dummy.  A target can specify      a SIZEOF_DUMMY1 (via DEPRECATED_SIZEOF_CALL_DUMMY_WORDS) such      that all local alignment requirements are met.  */
comment|/* Create a call sequence customized for this function and the      number of arguments for it.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|DEPRECATED_SIZEOF_CALL_DUMMY_WORDS
operator|/
sizeof|sizeof
argument_list|(
name|dummy
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|store_unsigned_integer
argument_list|(
operator|&
name|dummy1
index|[
name|i
operator|*
name|DEPRECATED_REGISTER_SIZE
index|]
argument_list|,
name|DEPRECATED_REGISTER_SIZE
argument_list|,
operator|(
name|ULONGEST
operator|)
name|dummy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: cagney/2003-04-22: This computation of REAL_PC, BP_ADDR and      DUMMY_ADDR is pretty messed up.  It comes from constant tinkering      with the values.  Instead a DEPRECATED_FIX_CALL_DUMMY replacement      (PUSH_DUMMY_BREAKPOINT?) should just do everything.  */
if|if
condition|(
operator|!
name|gdbarch_push_dummy_call_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
operator|(
operator|*
name|real_pc
operator|)
operator|=
name|DEPRECATED_FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|start_sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|DEPRECATED_FIX_CALL_DUMMY_P
argument_list|()
condition|)
block|{
comment|/* gdb_assert (CALL_DUMMY_LOCATION == ON_STACK) true?  */
name|DEPRECATED_FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|start_sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|real_pc
operator|)
operator|=
name|start_sp
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Yes, the offset is applied to the real_pc and not the dummy addr.      Ulgh!  Blame the HP/UX target.  */
operator|(
operator|*
name|bp_addr
operator|)
operator|=
operator|(
operator|*
name|real_pc
operator|)
operator|+
name|DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET
expr_stmt|;
comment|/* Yes, the offset is applied to the real_pc and not the      dummy_addr.  Ulgh!  Blame the HP/UX target.  */
operator|(
operator|*
name|real_pc
operator|)
operator|+=
name|DEPRECATED_CALL_DUMMY_START_OFFSET
expr_stmt|;
name|write_memory
argument_list|(
name|start_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
name|sizeof_dummy1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
condition|)
name|generic_save_call_dummy_addr
argument_list|(
name|start_sp
argument_list|,
name|start_sp
operator|+
name|sizeof_dummy1
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|generic_push_dummy_code
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|funaddr
parameter_list|,
name|int
name|using_gcc
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|CORE_ADDR
modifier|*
name|real_pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp_addr
parameter_list|)
block|{
comment|/* Something here to findout the size of a breakpoint and then      allocate space for it on the stack.  */
name|int
name|bplen
decl_stmt|;
comment|/* This code assumes frame align.  */
name|gdb_assert
argument_list|(
name|gdbarch_frame_align_p
argument_list|(
name|gdbarch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Force the stack's alignment.  The intent is to ensure that the SP      is aligned to at least a breakpoint instruction's boundary.  */
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Allocate space for, and then position the breakpoint on the      stack.  */
if|if
condition|(
name|gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|bppc
init|=
name|sp
decl_stmt|;
name|gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|bppc
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|sp
operator|-
name|bplen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bp_addr
operator|)
operator|=
name|sp
expr_stmt|;
comment|/* Should the breakpoint size/location be re-computed here?  */
block|}
else|else
block|{
operator|(
operator|*
name|bp_addr
operator|)
operator|=
name|sp
expr_stmt|;
name|gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|bp_addr
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|sp
operator|+
name|bplen
argument_list|)
expr_stmt|;
block|}
comment|/* Inferior resumes at the function entry point.  */
operator|(
operator|*
name|real_pc
operator|)
operator|=
name|funaddr
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Provide backward compatibility.  Once DEPRECATED_FIX_CALL_DUMMY is    eliminated, this can be simplified.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|push_dummy_code
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|funaddr
parameter_list|,
name|int
name|using_gcc
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|CORE_ADDR
modifier|*
name|real_pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp_addr
parameter_list|)
block|{
if|if
condition|(
name|gdbarch_push_dummy_code_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
return|return
name|gdbarch_push_dummy_code
argument_list|(
name|gdbarch
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|using_gcc
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|value_type
argument_list|,
name|real_pc
argument_list|,
name|bp_addr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DEPRECATED_FIX_CALL_DUMMY_P
argument_list|()
operator|&&
operator|!
name|gdbarch_push_dummy_call_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
return|return
name|legacy_push_dummy_code
argument_list|(
name|gdbarch
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|using_gcc
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|value_type
argument_list|,
name|real_pc
argument_list|,
name|bp_addr
argument_list|)
return|;
else|else
return|return
name|generic_push_dummy_code
argument_list|(
name|gdbarch
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|using_gcc
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|value_type
argument_list|,
name|real_pc
argument_list|,
name|bp_addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* All this stuff with a dummy frame may seem unnecessarily complicated    (why not just save registers in GDB?).  The purpose of pushing a dummy    frame which looks just like a real frame is so that if you call a    function and then hit a breakpoint (get a signal, etc), "backtrace"    will look right.  Whether the backtrace needs to actually show the    stack at the time the inferior function was called is debatable, but    it certainly needs to not display garbage.  So if you are contemplating    making dummy frames be different from normal frames, consider that.  */
end_comment

begin_comment
comment|/* Perform a function call in the inferior.    ARGS is a vector of values of arguments (NARGS of them).    FUNCTION is a value, the function to be called.    Returns a value representing what the function returned.    May fail to return, if a breakpoint or signal is hit    during the execution of the function.     ARGS is modified to contain coerced values. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|call_function_by_hand
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|dummy_addr
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|unsigned
name|char
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
init|=
literal|0
decl_stmt|;
name|struct
name|regcache
modifier|*
name|retbuf
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|retbuf_cleanup
decl_stmt|;
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|inf_status_cleanup
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|int
name|using_gcc
decl_stmt|;
comment|/* Set to version of gcc in use, or zero if not gcc */
name|CORE_ADDR
name|real_pc
decl_stmt|;
name|struct
name|type
modifier|*
name|ftype
init|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|bp_addr
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|noprocess
argument_list|()
expr_stmt|;
comment|/* Create a cleanup chain that contains the retbuf (buffer      containing the register values).  This chain is create BEFORE the      inf_status chain so that the inferior status can cleaned up      (restored or discarded) without having the retbuf freed.  */
name|retbuf
operator|=
name|regcache_xmalloc
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
name|retbuf_cleanup
operator|=
name|make_cleanup_regcache_xfree
argument_list|(
name|retbuf
argument_list|)
expr_stmt|;
comment|/* A cleanup for the inferior status.  Create this AFTER the retbuf      so that this can be discarded or applied without interfering with      the regbuf.  */
name|inf_status
operator|=
name|save_inferior_status
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|inf_status_cleanup
operator|=
name|make_cleanup_restore_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_PUSH_DUMMY_FRAME_P
argument_list|()
condition|)
block|{
comment|/* DEPRECATED_PUSH_DUMMY_FRAME is responsible for saving the 	 inferior registers (and frame_pop() for restoring them).  (At 	 least on most machines) they are saved on the stack in the 	 inferior.  */
name|DEPRECATED_PUSH_DUMMY_FRAME
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: cagney/2003-02-26: Step zero of this little tinker is       to extract the generic dummy frame code from the architecture       vector.  Hence this direct call.        A follow-on change is to modify this interface so that it takes       thread OR frame OR ptid as a parameter, and returns a dummy       frame handle.  The handle can then be used further down as a       parameter to generic_save_dummy_frame_tos().  Hmm, thinking       about it, since everything is ment to be using generic dummy       frames, why not even use some of the dummy frame code to here -       do a regcache dup and then pass the duped regcache, along with       all the other stuff, at one single point.        In fact, you can even save the structure's return address in the       dummy frame and fix one of those nasty lost struct return edge       conditions.  */
name|generic_push_dummy_frame
argument_list|()
expr_stmt|;
block|}
comment|/* Ensure that the initial SP is correctly aligned.  */
block|{
name|CORE_ADDR
name|old_sp
init|=
name|read_sp
argument_list|()
decl_stmt|;
if|if
condition|(
name|gdbarch_frame_align_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|old_sp
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-08-13: Skip the "red zone".  For some 	   ABIs, a function can use memory beyond the inner most stack 	   address.  AMD64 called that region the "red zone".  Skip at 	   least the "red zone" size before allocating any space on 	   the stack.  */
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
name|sp
operator|-=
name|gdbarch_frame_red_zone_size
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
else|else
name|sp
operator|+=
name|gdbarch_frame_red_zone_size
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
comment|/* Still aligned?  */
name|gdb_assert
argument_list|(
name|sp
operator|==
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2002-09-18: 	    	   On a RISC architecture, a void parameterless generic dummy 	   frame (i.e., no parameters, no result) typically does not 	   need to push anything the stack and hence can leave SP and 	   FP.  Similarly, a frameless (possibly leaf) function does 	   not push anything on the stack and, hence, that too can 	   leave FP and SP unchanged.  As a consequence, a sequence of 	   void parameterless generic dummy frame calls to frameless 	   functions will create a sequence of effectively identical 	   frames (SP, FP and TOS and PC the same).  This, not 	   suprisingly, results in what appears to be a stack in an 	   infinite loop --- when GDB tries to find a generic dummy 	   frame on the internal dummy frame stack, it will always 	   find the first one.  	   To avoid this problem, the code below always grows the 	   stack.  That way, two dummy frames can never be identical. 	   It does burn a few bytes of stack but that is a small price 	   to pay :-).  */
if|if
condition|(
name|sp
operator|==
name|old_sp
condition|)
block|{
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* Stack grows down.  */
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|old_sp
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Stack grows up.  */
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|old_sp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
operator|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|&&
name|sp
operator|<=
name|old_sp
operator|)
operator|||
operator|(
name|INNER_THAN
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|&&
name|sp
operator|>=
name|old_sp
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* FIXME: cagney/2002-09-18: Hey, you loose!  	 Who knows how badly aligned the SP is!  	 If the generic dummy frame ends up empty (because nothing is 	 pushed) GDB won't be able to correctly perform back traces. 	 If a target is having trouble with backtraces, first thing to 	 do is add FRAME_ALIGN() to the architecture vector. If that 	 fails, try unwind_dummy_id().           If the ABI specifies a "Red Zone" (see the doco) the code          below will quietly trash it.  */
name|sp
operator|=
name|old_sp
expr_stmt|;
block|}
name|funaddr
operator|=
name|find_function_addr
argument_list|(
name|function
argument_list|,
operator|&
name|value_type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
comment|/* If compiled without -g, assume GCC 2.  */
name|using_gcc
operator|=
operator|(
name|b
operator|==
name|NULL
condition|?
literal|2
else|:
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Are we returning a value using a structure return or a normal      value return? */
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
comment|/* Determine the location of the breakpoint (and possibly other      stuff) that the called function will return to.  The SPARC, for a      function returning a structure or union, needs to make space for      not just the breakpoint but also an extra word containing the      size (?) of the structure being passed.  */
comment|/* The actual breakpoint (at BP_ADDR) is inserted separatly so there      is no need to write that out.  */
switch|switch
condition|(
name|CALL_DUMMY_LOCATION
condition|)
block|{
case|case
name|ON_STACK
case|:
comment|/* "dummy_addr" is here just to keep old targets happy.  New 	 targets return that same information via "sp" and "bp_addr".  */
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|sp
operator|=
name|push_dummy_code
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|using_gcc
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|value_type
argument_list|,
operator|&
name|real_pc
argument_list|,
operator|&
name|bp_addr
argument_list|)
expr_stmt|;
name|dummy_addr
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
name|dummy_addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|push_dummy_code
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|using_gcc
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|value_type
argument_list|,
operator|&
name|real_pc
argument_list|,
operator|&
name|bp_addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AT_ENTRY_POINT
case|:
if|if
condition|(
name|DEPRECATED_FIX_CALL_DUMMY_P
argument_list|()
operator|&&
operator|!
name|gdbarch_push_dummy_call_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Sigh.  Some targets use DEPRECATED_FIX_CALL_DUMMY to              shove extra stuff onto the stack or into registers.  That              code should be in PUSH_DUMMY_CALL, however, in the mean              time ...  */
comment|/* If the target is manipulating DUMMY1, it looses big time.  */
name|void
modifier|*
name|dummy1
init|=
name|NULL
decl_stmt|;
name|DEPRECATED_FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
block|}
name|real_pc
operator|=
name|funaddr
expr_stmt|;
name|dummy_addr
operator|=
name|entry_point_address
argument_list|()
expr_stmt|;
comment|/* Make certain that the address points at real code, and not a          function descriptor.  */
name|dummy_addr
operator|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|dummy_addr
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
comment|/* A call dummy always consists of just a single breakpoint, so          it's address is the same as the address of the dummy.  */
name|bp_addr
operator|=
name|dummy_addr
expr_stmt|;
break|break;
case|case
name|AT_SYMBOL
case|:
comment|/* Some executables define a symbol __CALL_DUMMY_ADDRESS whose 	 address is the location where the breakpoint should be 	 placed.  Once all targets are using the overhauled frame code 	 this can be deleted - ON_STACK is a better option.  */
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__CALL_DUMMY_ADDRESS"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|real_pc
operator|=
name|funaddr
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|dummy_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|dummy_addr
operator|=
name|entry_point_address
argument_list|()
expr_stmt|;
comment|/* Make certain that the address points at real code, and not 	   a function descriptor.  */
name|dummy_addr
operator|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|dummy_addr
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
comment|/* A call dummy always consists of just a single breakpoint, 	   so it's address is the same as the address of the dummy.  */
name|bp_addr
operator|=
name|dummy_addr
expr_stmt|;
break|break;
block|}
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
condition|)
comment|/* Save where the breakpoint is going to be inserted so that the        dummy-frame code is later able to re-identify it.  */
name|generic_save_call_dummy_addr
argument_list|(
name|bp_addr
argument_list|,
name|bp_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
condition|)
name|error
argument_list|(
literal|"too few arguments in function call"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|prototyped
decl_stmt|;
name|struct
name|type
modifier|*
name|param_type
decl_stmt|;
comment|/* FIXME drow/2002-05-31: Should just always mark methods as 	   prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
name|prototyped
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
condition|)
name|prototyped
operator|=
name|TYPE_PROTOTYPED
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
else|else
name|prototyped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
condition|)
name|param_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|param_type
operator|=
name|NULL
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|param_type
argument_list|,
name|prototyped
argument_list|)
expr_stmt|;
comment|/* elz: this code is to handle the case in which the function 	   to be called has a pointer to function as parameter and the 	   corresponding actual argument is the address of a function 	   and not a pointer to function variable.  In aCC compiled 	   code, the calls through pointers to functions (in the body 	   of the function called by hand) are made via 	   $$dyncall_external which requires some registers setting, 	   this is taken care of if we call via a function pointer 	   variable, but not via a function address.  In cc this is 	   not a problem. */
if|if
condition|(
name|using_gcc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|param_type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|!=
name|TYPE_CODE_METHOD
condition|)
block|{
comment|/* if this parameter is a pointer to function.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|param_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|param_type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
comment|/* elz: FIXME here should go the test about the 		       compiler used to compile the target. We want to 		       issue the error message only if the compiler 		       used was HP's aCC.  If we used HP's cc, then 		       there is no problem and no need to return at 		       this point.  */
comment|/* Go see if the actual parameter is a variable of 		       type pointer to function or just a function.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|lval
operator|==
name|not_lval
condition|)
block|{
name|char
modifier|*
name|arg_name
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|args
index|[
name|i
index|]
operator|->
name|aligner
operator|.
name|contents
index|[
literal|0
index|]
argument_list|,
operator|&
name|arg_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|error
argument_list|(
literal|"\ You cannot use function<%s> as argument. \n\ You must use a pointer to function type variable. Command ignored."
argument_list|,
name|arg_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|DEPRECATED_REG_STRUCT_HAS_ADDR_P
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is a machine like the sparc, where we may need to pass a 	 pointer to the structure, not the structure itself.  */
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_SET
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|>
literal|8
operator|)
operator|)
operator|&&
name|DEPRECATED_REG_STRUCT_HAS_ADDR
argument_list|(
name|using_gcc
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*  = TYPE_LENGTH (arg_type); */
name|int
name|aligned_len
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_STACK_ALIGN_P
argument_list|()
condition|)
comment|/* MVS 11/22/96: I think at least some of this 		   stack_align code is really broken.  Better to let 		   PUSH_ARGUMENTS adjust the stack in a target-defined 		   manner.  */
name|aligned_len
operator|=
name|DEPRECATED_STACK_ALIGN
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|aligned_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|aligned_len
expr_stmt|;
comment|/* ... so the address of the thing we push is the 		     stack pointer after we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* The stack grows up, so the address of the thing 		     we push is the stack pointer before we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|aligned_len
expr_stmt|;
block|}
comment|/* Push the structure.  */
name|write_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* The value we're going to pass is the address of the 		 thing we just pushed.  */
comment|/*args[i] = value_from_longest (lookup_pointer_type (value_type), 		(LONGEST) addr); */
name|args
index|[
name|i
index|]
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|arg_type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reserve space for the return structure to be written on the      stack, if necessary.  Make certain that the value is correctly      aligned. */
if|if
condition|(
name|struct_return
condition|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEPRECATED_STACK_ALIGN_P
argument_list|()
condition|)
comment|/* NOTE: cagney/2003-03-22: Should rely on frame align, rather            than stack align to force the alignment of the stack.  */
name|len
operator|=
name|DEPRECATED_STACK_ALIGN
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* Stack grows downward.  Align STRUCT_ADDR and SP after              making space for the return value.  */
name|sp
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|gdbarch_frame_align_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* Stack grows upward.  Align the frame, allocate space, and              then again, re-align the frame??? */
if|if
condition|(
name|gdbarch_frame_align_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|gdbarch_frame_align_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
name|sp
operator|=
name|gdbarch_frame_align
argument_list|(
name|current_gdbarch
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create the dummy stack frame.  Pass in the call dummy address as,      presumably, the ABI code knows where, in the call dummy, the      return address should be pointed.  */
if|if
condition|(
name|gdbarch_push_dummy_call_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
comment|/* When there is no push_dummy_call method, should this code        simply error out.  That would the implementation of this method        for all ABIs (which is probably a good thing).  */
name|sp
operator|=
name|gdbarch_push_dummy_call
argument_list|(
name|current_gdbarch
argument_list|,
name|funaddr
argument_list|,
name|current_regcache
argument_list|,
name|bp_addr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_PUSH_ARGUMENTS_P
argument_list|()
condition|)
comment|/* Keep old targets working.  */
name|sp
operator|=
name|DEPRECATED_PUSH_ARGUMENTS
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
name|legacy_push_arguments
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_PUSH_RETURN_ADDRESS_P
argument_list|()
condition|)
comment|/* for targets that use no CALL_DUMMY */
comment|/* There are a number of targets now which actually don't write        any CALL_DUMMY instructions into the target, but instead just        save the machine state, push the arguments, and jump directly        to the callee function.  Since this doesn't actually involve        executing a JSR/BSR instruction, the return address must be set        up by hand, either by pushing onto the stack or copying into a        return-address register as appropriate.  Formerly this has been        done in PUSH_ARGUMENTS, but that's overloading its        functionality a bit, so I'm making it explicit to do it here.  */
comment|/* NOTE: cagney/2003-04-22: The first parameter ("real_pc") has        been replaced with zero, it turns out that no implementation        used that parameter.  This occured because the value being        supplied - the address of the called function's entry point        instead of the address of the breakpoint that the called        function should return to - wasn't useful.  */
name|sp
operator|=
name|DEPRECATED_PUSH_RETURN_ADDRESS
argument_list|(
literal|0
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-03-23: Diable this code when there is a      push_dummy_call() method.  Since that method will have already      handled any alignment issues, the code below is entirely      redundant.  */
if|if
condition|(
operator|!
name|gdbarch_push_dummy_call_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
name|DEPRECATED_STACK_ALIGN_P
argument_list|()
operator|&&
operator|!
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* If stack grows up, we must leave a hole at the bottom, note          that sp already has been advanced for the arguments!  */
name|sp
operator|=
name|DEPRECATED_STACK_ALIGN
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Store the address at which the structure is supposed to be      written.  */
comment|/* NOTE: 2003-03-24: Since PUSH_ARGUMENTS can (and typically does)      store the struct return address, this call is entirely redundant.  */
if|if
condition|(
name|struct_return
operator|&&
name|DEPRECATED_STORE_STRUCT_RETURN_P
argument_list|()
condition|)
name|DEPRECATED_STORE_STRUCT_RETURN
argument_list|(
name|struct_addr
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Write the stack pointer.  This is here because the statements      above might fool with it.  On SPARC, this write also stores the      register window into the right place in the new stack frame,      which otherwise wouldn't happen (see store_inferior_registers in      sparc-nat.c).  */
comment|/* NOTE: cagney/2003-03-23: Since the architecture method      push_dummy_call() should have already stored the stack pointer      (as part of creating the fake call frame), and none of the code      following that call adjusts the stack-pointer value, the below      call is entirely redundant.  */
if|if
condition|(
name|DEPRECATED_DUMMY_WRITE_SP_P
argument_list|()
condition|)
name|DEPRECATED_DUMMY_WRITE_SP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_unwind_dummy_id_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Sanity.  The exact same SP value is returned by 	 PUSH_DUMMY_CALL, saved as the dummy-frame TOS, and used by 	 unwind_dummy_id to form the frame ID's stack address.  */
name|gdb_assert
argument_list|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
argument_list|)
expr_stmt|;
name|generic_save_dummy_frame_tos
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_SAVE_DUMMY_FRAME_TOS_P
argument_list|()
condition|)
name|DEPRECATED_SAVE_DUMMY_FRAME_TOS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Now proceed, having reached the desired place.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Create a momentary breakpoint at the return address of the      inferior.  That way it breaks when it returns.  */
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_id
name|frame
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sal
operator|.
name|pc
operator|=
name|bp_addr
expr_stmt|;
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* Set up a frame ID for the dummy frame so we can pass it to        set_momentary_breakpoint.  We need to give the breakpoint a        frame ID so that the breakpoint code can correctly re-identify        the dummy breakpoint.  */
if|if
condition|(
name|gdbarch_unwind_dummy_id_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Sanity.  The exact same SP value is returned by 	 PUSH_DUMMY_CALL, saved as the dummy-frame TOS, and used by 	 unwind_dummy_id to form the frame ID's stack address.  */
name|gdb_assert
argument_list|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
argument_list|)
expr_stmt|;
name|frame
operator|=
name|frame_id_build
argument_list|(
name|sp
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The assumption here is that push_dummy_call() returned the 	   stack part of the frame ID.  Unfortunately, many older 	   architectures were, via a convoluted mess, relying on the 	   poorly defined and greatly overloaded 	   DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM to supply 	   the value.  */
if|if
condition|(
name|DEPRECATED_TARGET_READ_FP_P
argument_list|()
condition|)
name|frame
operator|=
name|frame_id_build
argument_list|(
name|DEPRECATED_TARGET_READ_FP
argument_list|()
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DEPRECATED_FP_REGNUM
operator|>=
literal|0
condition|)
name|frame
operator|=
name|frame_id_build
argument_list|(
name|read_register
argument_list|(
name|DEPRECATED_FP_REGNUM
argument_list|)
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
else|else
name|frame
operator|=
name|frame_id_build
argument_list|(
name|sp
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|bpt
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|frame
argument_list|,
name|bp_call_dummy
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disp_del
expr_stmt|;
block|}
comment|/* Execute a "stack dummy", a piece of code stored in the stack by      the debugger to be executed in the inferior.       The dummy's frame is automatically popped whenever that break is      hit.  If that is the first time the program stops,      call_function_by_hand returns to its caller with that frame      already gone and sets RC to 0.          Otherwise, set RC to a non-zero value.  If the called function      receives a random signal, we do not allow the user to continue      executing it as this may not work.  The dummy frame is poped and      we return 1.  If we hit a breakpoint, we leave the frame in place      and return 2 (the frame will eventually be popped when we do hit      the dummy end breakpoint).  */
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|saved_async
init|=
literal|0
decl_stmt|;
comment|/* If all error()s out of proceed ended up calling normal_stop        (and perhaps they should; it already does in the special case        of error out of resume()), then we wouldn't need this.  */
name|make_cleanup
argument_list|(
name|breakpoint_auto_delete_contents
argument_list|,
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|disable_watchpoints_before_interactive_call_start
argument_list|()
expr_stmt|;
name|proceed_to_finish
operator|=
literal|1
expr_stmt|;
comment|/* We want stop_registers, please... */
if|if
condition|(
name|target_can_async_p
argument_list|()
condition|)
name|saved_async
operator|=
name|target_async_mask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|proceed
argument_list|(
name|real_pc
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_async
condition|)
name|target_async_mask
argument_list|(
name|saved_async
argument_list|)
expr_stmt|;
name|enable_watchpoints_after_interactive_call_stop
argument_list|()
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stopped_by_random_signal
operator|||
operator|!
name|stop_stack_dummy
condition|)
block|{
comment|/* Find the name of the function we're about to complain about.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|symbol
init|=
name|find_pc_function
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
name|name
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the minimal symbols.  */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
condition|)
name|name
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Can't use a cleanup here.  It is discarded, instead use                an alloca.  */
name|char
modifier|*
name|tmp
init|=
name|xstrprintf
argument_list|(
literal|"at %s"
argument_list|,
name|local_hex_string
argument_list|(
name|funaddr
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|a
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|a
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|name
operator|=
name|a
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stopped_by_random_signal
condition|)
block|{
comment|/* We stopped inside the FUNCTION because of a random 	     signal.  Further execution of the FUNCTION is not 	     allowed. */
if|if
condition|(
name|unwind_on_signal_p
condition|)
block|{
comment|/* The user wants the context restored. */
comment|/* We must get back to the frame we were before the 		 dummy call. */
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* FIXME: Insert a bunch of wrap_here; name can be very 		 long if it's a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged was signaled while in a function called from GDB.\n\ GDB has restored the context to what it was before the call.\n\ To change this behavior use \"set unwindonsignal off\"\n\ Evaluation of the expression containing the function (%s) will be abandoned."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The user wants to stay in the frame where we stopped                  (default).*/
comment|/* If we restored the inferior status (via the cleanup), 		 we would print a spurious error message (Unable to 		 restore previously selected frame), would write the 		 registers from the inf_status (which is wrong), and 		 would do other wrong things.  */
name|discard_cleanups
argument_list|(
name|inf_status_cleanup
argument_list|)
expr_stmt|;
name|discard_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
comment|/* FIXME: Insert a bunch of wrap_here; name can be very 		 long if it's a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged was signaled while in a function called from GDB.\n\ GDB remains in the frame where the signal was received.\n\ To change this behavior use \"set unwindonsignal on\"\n\ Evaluation of the expression containing the function (%s) will be abandoned."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
comment|/* We hit a breakpoint inside the FUNCTION. */
comment|/* If we restored the inferior status (via the cleanup), we 	     would print a spurious error message (Unable to restore 	     previously selected frame), would write the registers 	     from the inf_status (which is wrong), and would do other 	     wrong things.  */
name|discard_cleanups
argument_list|(
name|inf_status_cleanup
argument_list|)
expr_stmt|;
name|discard_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
comment|/* The following error message used to say "The expression 	     which contained the function call has been discarded." 	     It is a hard concept to explain in a few words.  Ideally, 	     GDB would be able to resume evaluation of the expression 	     when the function finally is done executing.  Perhaps 	     someday this will be implemented (it would not be easy).  */
comment|/* FIXME: Insert a bunch of wrap_here; name can be very long if it's 	     a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged stopped while in a function called from GDB.\n\ When the function (%s) is done executing, GDB will silently\n\ stop (instead of continuing to evaluate the expression containing\n\ the function call)."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* The above code errors out, so ...  */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"... should not be here"
argument_list|)
expr_stmt|;
block|}
comment|/* If we get here the called FUNCTION run to completion. */
comment|/* On normal return, the stack dummy has been popped already.  */
name|regcache_cpy_no_passthrough
argument_list|(
name|retbuf
argument_list|,
name|stop_registers
argument_list|)
expr_stmt|;
comment|/* Restore the inferior status, via its cleanup.  At this stage,      leave the RETBUF alone.  */
name|do_cleanups
argument_list|(
name|inf_status_cleanup
argument_list|)
expr_stmt|;
comment|/* Figure out the value returned by the function.  */
if|if
condition|(
name|struct_return
condition|)
block|{
comment|/* NOTE: cagney/2003-09-27: This assumes that PUSH_DUMMY_CALL 	 has correctly stored STRUCT_ADDR in the target.  In the past 	 that hasn't been the case, the old MIPS PUSH_ARGUMENTS 	 (PUSH_DUMMY_CALL precursor) would silently move the location 	 of the struct return value making STRUCT_ADDR bogus.  If 	 you're seeing problems with values being returned using the 	 "struct return convention", check that PUSH_DUMMY_CALL isn't 	 playing tricks.  */
name|struct
name|value
modifier|*
name|retval
init|=
name|value_at
argument_list|(
name|value_type
argument_list|,
name|struct_addr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|do_cleanups
argument_list|(
name|retbuf_cleanup
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
else|else
block|{
comment|/* The non-register case was handled above.  */
name|struct
name|value
modifier|*
name|retval
init|=
name|register_value_being_returned
argument_list|(
name|value_type
argument_list|,
name|retbuf
argument_list|)
decl_stmt|;
name|do_cleanups
argument_list|(
name|retbuf_cleanup
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
end_function

begin_function_decl
name|void
name|_initialize_infcall
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_infcall
parameter_list|(
name|void
parameter_list|)
block|{
name|add_setshow_boolean_cmd
argument_list|(
literal|"coerce-float-to-double"
argument_list|,
name|class_obscure
argument_list|,
operator|&
name|coerce_float_to_double_p
argument_list|,
literal|"\ Set coercion of floats to doubles when calling functions\n\ Variables of type float should generally be converted to doubles before\n\ calling an unprototyped function, and left alone when calling a prototyped\n\ function.  However, some older debug info formats do not provide enough\n\ information to determine that a function is prototyped.  If this flag is\n\ set, GDB will perform the conversion for a function it considers\n\ unprototyped.\n\ The default is to perform the conversion.\n"
argument_list|,
literal|"\ Show coercion of floats to doubles when calling functions\n\ Variables of type float should generally be converted to doubles before\n\ calling an unprototyped function, and left alone when calling a prototyped\n\ function.  However, some older debug info formats do not provide enough\n\ information to determine that a function is prototyped.  If this flag is\n\ set, GDB will perform the conversion for a function it considers\n\ unprototyped.\n\ The default is to perform the conversion.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"unwindonsignal"
argument_list|,
name|no_class
argument_list|,
operator|&
name|unwind_on_signal_p
argument_list|,
literal|"\ Set unwinding of stack if a signal is received while in a call dummy.\n\ The unwindonsignal lets the user determine what gdb should do if a signal\n\ is received while in a function called from gdb (call dummy).  If set, gdb\n\ unwinds the stack and restore the context to what as it was before the call.\n\ The default is to stop in the frame where the signal was received."
argument_list|,
literal|"\ Set unwinding of stack if a signal is received while in a call dummy.\n\ The unwindonsignal lets the user determine what gdb should do if a signal\n\ is received while in a function called from gdb (call dummy).  If set, gdb\n\ unwinds the stack and restore the context to what as it was before the call.\n\ The default is to stop in the frame where the signal was received."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

