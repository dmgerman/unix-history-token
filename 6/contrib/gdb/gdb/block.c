begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Block-related functions for the GNU debugger, GDB.     Copyright 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_comment
comment|/* This is used by struct block to store namespace-related info for    C++ files, namely using declarations and the current namespace in    scope.  */
end_comment

begin_struct
struct|struct
name|block_namespace_info
block|{
specifier|const
name|char
modifier|*
name|scope
decl_stmt|;
name|struct
name|using_direct
modifier|*
name|using
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|block_initialize_namespace
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|BLOCK_START
argument_list|(
name|a
argument_list|)
operator|>=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|a
argument_list|)
operator|<=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|bl
parameter_list|)
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the blockvector immediately containing the innermost lexical block    containing the specified pc value and section, or 0 if there is none.    PINDEX is a pointer to the index value of the block.  If PINDEX    is NULL, we don't pass this information back to the caller.  */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|blockvector_for_pc_sect
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|,
name|int
modifier|*
name|pindex
parameter_list|,
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
comment|/* if no symtab specified by caller */
block|{
comment|/* First search all symtabs for one whose file contains our pc */
name|symtab
operator|=
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|bl
operator|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then search that symtab for the smallest block that wins.  */
comment|/* Use binary search to find the last block that starts before PC.  */
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
operator|+
name|half
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
comment|/* Now search backward for a block that ends after PC.  */
while|while
condition|(
name|bot
operator|>=
literal|0
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
block|{
if|if
condition|(
name|pindex
condition|)
operator|*
name|pindex
operator|=
name|bot
expr_stmt|;
return|return
name|bl
return|;
block|}
name|bot
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the blockvector immediately containing the innermost lexical block    containing the specified pc value, or 0 if there is none.    Backward compatibility, no section.  */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|blockvector_for_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
modifier|*
name|pindex
parameter_list|)
block|{
return|return
name|blockvector_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|,
name|pindex
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value    in the specified section, or 0 if there is none.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|block_for_pc_sect
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
name|int
name|index
decl_stmt|;
name|bl
operator|=
name|blockvector_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
operator|&
name|index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
return|return
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value,    or 0 if there is none.  Backward compatibility, no section.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|block_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now come some functions designed to deal with C++ namespace issues.    The accessors are safe to use even in the non-C++ case.  */
end_comment

begin_comment
comment|/* This returns the namespace that BLOCK is enclosed in, or "" if it    isn't enclosed in a namespace at all.  This travels the chain of    superblocks looking for a scope, if necessary.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|block_scope
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
for|for
control|(
init|;
name|block
operator|!=
name|NULL
condition|;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
control|)
block|{
if|if
condition|(
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|!=
name|NULL
operator|&&
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|scope
operator|!=
name|NULL
condition|)
return|return
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|scope
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Set BLOCK's scope member to SCOPE; if needed, allocate memory via    OBSTACK.  (It won't make a copy of SCOPE, however, so that already    has to be allocated correctly.)  */
end_comment

begin_function
name|void
name|block_set_scope
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|char
modifier|*
name|scope
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|block_initialize_namespace
argument_list|(
name|block
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This returns the first using directives associated to BLOCK, if    any.  */
end_comment

begin_comment
comment|/* FIXME: carlton/2003-04-23: This uses the fact that we currently    only have using directives in static blocks, because we only    generate using directives from anonymous namespaces.  Eventually,    when we support using directives everywhere, we'll want to replace    this by some iterator functions.  */
end_comment

begin_function
name|struct
name|using_direct
modifier|*
name|block_using
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
specifier|const
name|struct
name|block
modifier|*
name|static_block
init|=
name|block_static_block
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|static_block
operator|==
name|NULL
operator|||
name|BLOCK_NAMESPACE
argument_list|(
name|static_block
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|BLOCK_NAMESPACE
argument_list|(
name|static_block
argument_list|)
operator|->
name|using
return|;
block|}
end_function

begin_comment
comment|/* Set BLOCK's using member to USING; if needed, allocate memory via    OBSTACK.  (It won't make a copy of USING, however, so that already    has to be allocated correctly.)  */
end_comment

begin_function
name|void
name|block_set_using
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|using_direct
modifier|*
name|using
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|block_initialize_namespace
argument_list|(
name|block
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|using
operator|=
name|using
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If BLOCK_NAMESPACE (block) is NULL, allocate it via OBSTACK and    ititialize its members to zero.  */
end_comment

begin_function
specifier|static
name|void
name|block_initialize_namespace
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
if|if
condition|(
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block_namespace_info
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|scope
operator|=
name|NULL
expr_stmt|;
name|BLOCK_NAMESPACE
argument_list|(
name|block
argument_list|)
operator|->
name|using
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the static block associated to BLOCK.  Return NULL if block    is NULL or if block is a global block.  */
end_comment

begin_function
specifier|const
name|struct
name|block
modifier|*
name|block_static_block
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
name|NULL
operator|||
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Return the static block associated to BLOCK.  Return NULL if block    is NULL.  */
end_comment

begin_function
specifier|const
name|struct
name|block
modifier|*
name|block_global_block
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|!=
name|NULL
condition|)
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Allocate a block on OBSTACK, and initialize its elements to    zero/NULL.  This is useful for creating "dummy" blocks that don't    correspond to actual source files.     Warning: it sets the block's BLOCK_DICT to NULL, which isn't a    valid value.  If you really don't want the block to have a    dictionary, then you should subsequently set its BLOCK_DICT to    dict_create_linear (obstack, NULL).  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|allocate_block
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|bl
init|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
argument_list|)
decl_stmt|;
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_END
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_NAMESPACE
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_GCC_COMPILED
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|bl
return|;
block|}
end_function

end_unit

