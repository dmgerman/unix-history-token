begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read hp debug symbols and convert to internal format, for GDB.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"hp-symtab.h"
end_include

begin_include
include|#
directive|include
file|"syms.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"somsolib.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Private information attached to an objfile which we use to find    and internalize the HP C debug symbols within that objfile.  */
end_comment

begin_struct
struct|struct
name|hpread_symfile_info
block|{
comment|/* The contents of each of the debug sections (there are 4 of them).  */
name|char
modifier|*
name|gntt
decl_stmt|;
name|char
modifier|*
name|lntt
decl_stmt|;
name|char
modifier|*
name|slt
decl_stmt|;
name|char
modifier|*
name|vt
decl_stmt|;
comment|/* We keep the size of the $VT$ section for range checking.  */
name|unsigned
name|int
name|vt_size
decl_stmt|;
comment|/* Some routines still need to know the number of symbols in the        main debug sections ($LNTT$ and $GNTT$). */
name|unsigned
name|int
name|lntt_symcount
decl_stmt|;
name|unsigned
name|int
name|gntt_symcount
decl_stmt|;
comment|/* To keep track of all the types we've processed.  */
name|struct
name|type
modifier|*
modifier|*
name|dntt_type_vector
decl_stmt|;
name|int
name|dntt_type_vector_length
decl_stmt|;
comment|/* Keeps track of the beginning of a range of source lines.  */
name|sltpointer
name|sl_index
decl_stmt|;
comment|/* Some state variables we'll need.  */
name|int
name|within_function
decl_stmt|;
comment|/* Keep track of the current function's address.  We may need to look        up something based on this address.  */
name|unsigned
name|int
name|current_function_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Accessor macros to get at the fields.  */
end_comment

begin_define
define|#
directive|define
name|HPUX_SYMFILE_INFO
parameter_list|(
name|o
parameter_list|)
define|\
value|((struct hpread_symfile_info *)((o)->sym_private))
end_define

begin_define
define|#
directive|define
name|GNTT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->gntt)
end_define

begin_define
define|#
directive|define
name|LNTT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->lntt)
end_define

begin_define
define|#
directive|define
name|SLT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->slt)
end_define

begin_define
define|#
directive|define
name|VT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->vt)
end_define

begin_define
define|#
directive|define
name|VT_SIZE
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->vt_size)
end_define

begin_define
define|#
directive|define
name|LNTT_SYMCOUNT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->lntt_symcount)
end_define

begin_define
define|#
directive|define
name|GNTT_SYMCOUNT
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->gntt_symcount)
end_define

begin_define
define|#
directive|define
name|DNTT_TYPE_VECTOR
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->dntt_type_vector)
end_define

begin_define
define|#
directive|define
name|DNTT_TYPE_VECTOR_LENGTH
parameter_list|(
name|o
parameter_list|)
define|\
value|(HPUX_SYMFILE_INFO(o)->dntt_type_vector_length)
end_define

begin_define
define|#
directive|define
name|SL_INDEX
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->sl_index)
end_define

begin_define
define|#
directive|define
name|WITHIN_FUNCTION
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->within_function)
end_define

begin_define
define|#
directive|define
name|CURRENT_FUNCTION_VALUE
parameter_list|(
name|o
parameter_list|)
value|(HPUX_SYMFILE_INFO(o)->current_function_value)
end_define

begin_escape
end_escape

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|symloc
block|{
comment|/* The offset within the file symbol table of first local symbol for        this file.  */
name|int
name|ldsymoff
decl_stmt|;
comment|/* Length (in bytes) of the section of the symbol table devoted to        this file's symbols (actually, the section bracketed may contain        more than just this file's symbols).  If ldsymlen is 0, the only        reason for this thing's existence is the dependency list.        Nothing else will happen when it is read in.  */
name|int
name|ldsymlen
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LDSYMOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymoff)
end_define

begin_define
define|#
directive|define
name|LDSYMLEN
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymlen)
end_define

begin_define
define|#
directive|define
name|SYMLOC
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)((p)->read_symtab_private))
end_define

begin_escape
end_escape

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_function
specifier|static
name|void
name|lbrac_unmatched_complaint
parameter_list|(
name|int
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unmatched N_LBRAC before symtab pos %d"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lbrac_mismatch_complaint
parameter_list|(
name|int
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* To generate dumping code, uncomment this define.  The dumping    itself is controlled by routine-local statics called "dumping". */
end_comment

begin_comment
comment|/* #define DUMPING         1 */
end_comment

begin_comment
comment|/* To use the quick look-up tables, uncomment this define. */
end_comment

begin_define
define|#
directive|define
name|QUICK_LOOK_UP
value|1
end_define

begin_comment
comment|/* To call PXDB to process un-processed files, uncomment this define. */
end_comment

begin_define
define|#
directive|define
name|USE_PXDB
value|1
end_define

begin_comment
comment|/* Forward procedure declarations */
end_comment

begin_comment
comment|/* Used in somread.c.  */
end_comment

begin_function_decl
name|void
name|hpread_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_pxdb
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hpread_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hpread_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_namestring
parameter_list|(
name|union
name|dnttentry
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_gntt
parameter_list|(
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_lntt
parameter_list|(
name|int
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|hpread_get_textlow
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_start_psymtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_end_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|partial_symtab
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|hpread_get_scope_start
parameter_list|(
name|sltpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|hpread_get_line
parameter_list|(
name|sltpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|hpread_get_location
parameter_list|(
name|sltpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpread_has_name
parameter_list|(
name|enum
name|dntt_entry_type
name|kind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpread_psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpread_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtab
modifier|*
name|hpread_expand_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|section_offsets
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpread_type_translate
parameter_list|(
name|dnttpointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|hpread_lookup_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_alloc_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_enum_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_function_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_doc_function_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_struct_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_get_nth_template_arg
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_templ_arg_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_set_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_array_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_subrange_type
parameter_list|(
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|hpread_type_lookup
parameter_list|(
name|dnttpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sltpointer
name|hpread_record_lines
parameter_list|(
name|struct
name|subfile
modifier|*
parameter_list|,
name|sltpointer
parameter_list|,
name|sltpointer
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpread_process_one_debug_symbol
parameter_list|(
name|union
name|dnttentry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|section_offsets
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpread_get_scope_depth
parameter_list|(
name|union
name|dnttentry
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_static_member_physnames
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_class_method_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpread_adjust_bitoffsets
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dnttpointer
name|hpread_get_next_skip_over_anon_unions
parameter_list|(
name|int
parameter_list|,
name|dnttpointer
parameter_list|,
name|union
name|dnttentry
modifier|*
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Global to indicate presence of HP-compiled objects,    in particular, SOM executable file with SOM debug info     Defined in symtab.c, used in hppa-tdep.c. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static used to indicate a class type that requires a    fix-up of one of its method types */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|fixup_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static used to indicate the method type that is to be    used to fix-up the type for fixup_class */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|fixup_method
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PXDB
end_ifdef

begin_comment
comment|/* NOTE use of system files!  May not be portable. */
end_comment

begin_define
define|#
directive|define
name|PXDB_SVR4
value|"/opt/langtools/bin/pxdb"
end_define

begin_define
define|#
directive|define
name|PXDB_BSD
value|"/usr/bin/pxdb"
end_define

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* check for the existence of a file, given its full pathname */
end_comment

begin_function
specifier|static
name|int
name|file_exists
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|filename
condition|)
return|return
operator|(
name|access
argument_list|(
name|filename
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate from the "hp_language" enumeration in hp-symtab.h    used in the debug info to gdb's generic enumeration in defs.h. */
end_comment

begin_function
specifier|static
name|enum
name|language
name|trans_lang
parameter_list|(
name|enum
name|hp_language
name|in_lang
parameter_list|)
block|{
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_C
condition|)
return|return
name|language_c
return|;
elseif|else
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
return|return
name|language_cplus
return|;
elseif|else
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_FORTRAN
condition|)
return|return
name|language_fortran
return|;
else|else
return|return
name|language_unknown
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|main_string
index|[]
init|=
literal|"main"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given the native debug symbol SYM, set NAMEP to the name associated    with the debug symbol.  Note we may be called with a debug symbol which    has no associated name, in that case we return an empty string.  */
end_comment

begin_function
specifier|static
name|void
name|set_namestring
parameter_list|(
name|union
name|dnttentry
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Note that we "know" that the name for any symbol is always in the same      place.  Hence we don't have to conditionalize on the symbol type.  */
if|if
condition|(
operator|!
name|hpread_has_name
argument_list|(
name|sym
operator|->
name|dblock
operator|.
name|kind
argument_list|)
condition|)
operator|*
name|namep
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sym
operator|->
name|dsfile
operator|.
name|name
operator|>=
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"bad string table offset in symbol %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
operator|*
name|namep
operator|=
literal|""
expr_stmt|;
block|}
else|else
operator|*
name|namep
operator|=
name|sym
operator|->
name|dsfile
operator|.
name|name
operator|+
name|VT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call PXDB to process our file.     Approach copied from DDE's "dbgk_run_pxdb".  Note: we    don't check for BSD location of pxdb, nor for existence    of pxdb itself, etc.     NOTE: uses system function and string functions directly.     Return value: 1 if ok, 0 if not */
end_comment

begin_function
specifier|static
name|int
name|hpread_call_pxdb
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|PXDB_SVR4
argument_list|)
condition|)
block|{
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|PXDB_SVR4
argument_list|)
operator|+
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|PXDB_SVR4
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"File not processed by pxdb--about to process now.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|system
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|status
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"pxdb not found at standard location: /opt/langtools/bin\ngdb will not be able to debug %s.\nPlease install pxdb at the above location and then restart gdb.\nYou can also run pxdb on %s with the command\n\"pxdb %s\" and then restart gdb."
argument_list|,
name|file_name
argument_list|,
name|file_name
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* hpread_call_pxdb */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the file turns out to need pre-processing    by PXDB, and we have thus called PXDB to do this processing    and the file therefore needs to be re-loaded.  Otherwise    return 0. */
end_comment

begin_function
specifier|static
name|int
name|hpread_pxdb_needed
parameter_list|(
name|bfd
modifier|*
name|sym_bfd
parameter_list|)
block|{
name|asection
modifier|*
name|pinfo_section
decl_stmt|,
modifier|*
name|debug_section
decl_stmt|,
modifier|*
name|header_section
decl_stmt|;
name|unsigned
name|int
name|do_pxdb
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|bfd_size_type
name|header_section_size
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
name|unsigned
name|int
name|pxdbed
decl_stmt|;
name|header_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$HEADER$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_section
condition|)
block|{
return|return
literal|0
return|;
comment|/* No header at all, can't recover... */
block|}
name|debug_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$DEBUG$"
argument_list|)
expr_stmt|;
name|pinfo_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$PINFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo_section
operator|&&
operator|!
name|debug_section
condition|)
block|{
comment|/* Debug info with DOC, has different header format.           this only happens if the file was pxdbed and compiled optimized          otherwise the PINFO section is not there. */
name|header_section_size
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_section_size
operator|==
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
condition|)
block|{
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
name|header_section
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|header_section_size
argument_list|)
condition|)
name|error
argument_list|(
literal|"bfd_get_section_contents\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|sym_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pxdbed
operator|=
operator|(
name|tmp
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
operator|!
name|pxdbed
condition|)
name|error
argument_list|(
literal|"file debug header info invalid\n"
argument_list|)
expr_stmt|;
name|do_pxdb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid $HEADER$ size in executable \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this can be three different cases:          1. pxdbed and not doc          - DEBUG and HEADER sections are there          - header is PXDB_header type          - pxdbed flag is set to 1           2. not pxdbed and doc          - DEBUG and HEADER  sections are there          - header is DOC_info_header type          - pxdbed flag is set to 0           3. not pxdbed and not doc          - DEBUG and HEADER sections are there          - header is XDB_header type          - pxdbed flag is set to 0           NOTE: the pxdbed flag is meaningful also in the not          already pxdb processed version of the header,          because in case on non-already processed by pxdb files          that same bit in the header would be always zero.          Why? Because the bit is the leftmost bit of a word          which contains a 'length' which is always a positive value          so that bit is never set to 1 (otherwise it would be negative)           Given the above, we have two choices : either we ignore the          size of the header itself and just look at the pxdbed field,          or we check the size and then we (for safety and paranoia related          issues) check the bit.          The first solution is used by DDE, the second by PXDB itself.          I am using the second one here, because I already wrote it,          and it is the end of a long day.          Also, using the first approach would still involve size issues          because we need to read in the contents of the header section, and          give the correct amount of stuff we want to read to the          get_bfd_section_contents function.  */
comment|/* decide which case depending on the size of the header section.          The size is as defined in hp-symtab.h  */
name|header_section_size
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_section_size
operator|==
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
condition|)
comment|/* pxdb and not doc */
block|{
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
name|header_section
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|header_section_size
argument_list|)
condition|)
name|error
argument_list|(
literal|"bfd_get_section_contents\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|sym_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|3
operator|)
argument_list|)
expr_stmt|;
name|pxdbed
operator|=
operator|(
name|tmp
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|pxdbed
condition|)
name|do_pxdb
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"file debug header invalid\n"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*not pxdbed and doc OR not pxdbed and non doc */
name|do_pxdb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_pxdb
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* hpread_pxdb_needed */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Check whether the file needs to be preprocessed by pxdb.     If so, call pxdb. */
end_comment

begin_function
name|void
name|do_pxdb
parameter_list|(
name|bfd
modifier|*
name|sym_bfd
parameter_list|)
block|{
comment|/* The following code is HP-specific.  The "right" way of      doing this is unknown, but we bet would involve a target-      specific pre-file-load check using a generic mechanism. */
comment|/* This code will not be executed if the file is not in SOM      format (i.e. if compiled with gcc) */
if|if
condition|(
name|hpread_pxdb_needed
argument_list|(
name|sym_bfd
argument_list|)
condition|)
block|{
comment|/*This file has not been pre-processed. Preprocess now */
if|if
condition|(
name|hpread_call_pxdb
argument_list|(
name|sym_bfd
operator|->
name|filename
argument_list|)
condition|)
block|{
comment|/* The call above has changed the on-disk file,  	     we can close the file anyway, because the 	     symbols will be reread in when the target is run */
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
end_ifdef

begin_comment
comment|/* Code to handle quick lookup-tables follows. */
end_comment

begin_comment
comment|/* Some useful macros */
end_comment

begin_define
define|#
directive|define
name|VALID_FILE
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->fd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_MODULE
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->md_entries)
end_define

begin_define
define|#
directive|define
name|VALID_PROC
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->pd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CLASS
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->cd_entries)
end_define

begin_define
define|#
directive|define
name|FILE_START
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|MODULE_START
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|PROC_START
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|FILE_END
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|MODULE_END
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|PROC_END
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|FILE_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].isym)
end_define

begin_define
define|#
directive|define
name|MODULE_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].isym)
end_define

begin_define
define|#
directive|define
name|PROC_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].isym)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_FILE
value|(curr_fd< pxdb_header_p->fd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_MODULE
value|(curr_md< pxdb_header_p->md_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_PROC
value|(curr_pd< pxdb_header_p->pd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_CLASS
value|(curr_cd< pxdb_header_p->cd_entries)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_START
value|(qFD[curr_fd].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_START
value|(qMD[curr_md].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_START
value|(qPD[curr_pd].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_END
value|(qFD[curr_fd].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_END
value|(qMD[curr_md].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_END
value|(qPD[curr_pd].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_ISYM
value|(qFD[curr_fd].isym)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_ISYM
value|(qMD[curr_md].isym)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_ISYM
value|(qPD[curr_pd].isym)
end_define

begin_define
define|#
directive|define
name|TELL_OBJFILE
define|\
value|do {                                          \                if( !told_objfile ) {                      \                    told_objfile = 1;                      \                    warning ("\nIn object file \"%s\":\n", \                             objfile->name);               \                }                                          \             } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Keeping track of the start/end symbol table (LNTT) indices of    psymtabs created so far */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
block|}
name|pst_syms_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pst_syms_struct
modifier|*
name|pst_syms_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_syms_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_syms_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by the TELL_OBJFILE macro */
end_comment

begin_decl_stmt
specifier|static
name|int
name|told_objfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up psymtab symbol index stuff */
end_comment

begin_function
specifier|static
name|void
name|init_pst_syms
parameter_list|(
name|void
parameter_list|)
block|{
name|pst_syms_count
operator|=
literal|0
expr_stmt|;
name|pst_syms_size
operator|=
literal|20
expr_stmt|;
name|pst_syms_array
operator|=
operator|(
name|pst_syms_struct
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|pst_syms_struct
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up psymtab symbol index stuff */
end_comment

begin_function
specifier|static
name|void
name|clear_pst_syms
parameter_list|(
name|void
parameter_list|)
block|{
name|pst_syms_count
operator|=
literal|0
expr_stmt|;
name|pst_syms_size
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
name|pst_syms_array
argument_list|)
expr_stmt|;
name|pst_syms_array
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add information about latest psymtab to symbol index table */
end_comment

begin_function
specifier|static
name|void
name|record_pst_syms
parameter_list|(
name|int
name|start_sym
parameter_list|,
name|int
name|end_sym
parameter_list|)
block|{
if|if
condition|(
operator|++
name|pst_syms_count
operator|>
name|pst_syms_size
condition|)
block|{
name|pst_syms_array
operator|=
operator|(
name|pst_syms_struct
operator|*
operator|)
name|xrealloc
argument_list|(
name|pst_syms_array
argument_list|,
literal|2
operator|*
name|pst_syms_size
operator|*
sizeof|sizeof
argument_list|(
name|pst_syms_struct
argument_list|)
argument_list|)
expr_stmt|;
name|pst_syms_size
operator|*=
literal|2
expr_stmt|;
block|}
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|start
operator|=
name|start_sym
expr_stmt|;
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
operator|=
name|end_sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a suitable symbol table index which can serve as the upper    bound of a psymtab that starts at INDEX     This scans backwards in the psymtab symbol index table to find a    "hole" in which the given index can fit.  This is a heuristic!!    We don't search the entire table to check for multiple holes,    we don't care about overlaps, etc.      Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_pst_start
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|pst_syms_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|pst_syms_array
index|[
name|i
index|]
operator|.
name|end
operator|<=
name|index
condition|)
return|return
operator|(
name|i
operator|==
name|pst_syms_count
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|pst_syms_array
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
operator|-
literal|1
return|;
if|if
condition|(
name|pst_syms_array
index|[
literal|0
index|]
operator|.
name|start
operator|>
name|index
condition|)
return|return
name|pst_syms_array
index|[
literal|0
index|]
operator|.
name|start
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility functions to find the ending symbol index for a psymtab */
end_comment

begin_comment
comment|/* Find the next file entry that begins beyond INDEX, and return    its starting symbol index - 1.    QFD is the file table, CURR_FD is the file entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_file_isym
parameter_list|(
name|int
name|index
parameter_list|,
name|quick_file_entry
modifier|*
name|qFD
parameter_list|,
name|int
name|curr_fd
parameter_list|,
name|PXDB_header_ptr
name|pxdb_header_p
parameter_list|)
block|{
while|while
condition|(
name|VALID_CURR_FILE
condition|)
block|{
if|if
condition|(
name|CURR_FILE_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_FILE_ISYM
operator|-
literal|1
return|;
name|curr_fd
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the next procedure entry that begins beyond INDEX, and return    its starting symbol index - 1.    QPD is the procedure table, CURR_PD is the proc entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_proc_isym
parameter_list|(
name|int
name|index
parameter_list|,
name|quick_procedure_entry
modifier|*
name|qPD
parameter_list|,
name|int
name|curr_pd
parameter_list|,
name|PXDB_header_ptr
name|pxdb_header_p
parameter_list|)
block|{
while|while
condition|(
name|VALID_CURR_PROC
condition|)
block|{
if|if
condition|(
name|CURR_PROC_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_PROC_ISYM
operator|-
literal|1
return|;
name|curr_pd
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the next module entry that begins beyond INDEX, and return    its starting symbol index - 1.    QMD is the module table, CURR_MD is the modue entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_module_isym
parameter_list|(
name|int
name|index
parameter_list|,
name|quick_module_entry
modifier|*
name|qMD
parameter_list|,
name|int
name|curr_md
parameter_list|,
name|PXDB_header_ptr
name|pxdb_header_p
parameter_list|)
block|{
while|while
condition|(
name|VALID_CURR_MODULE
condition|)
block|{
if|if
condition|(
name|CURR_MODULE_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_MODULE_ISYM
operator|-
literal|1
return|;
name|curr_md
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan and record partial symbols for all functions starting from index    pointed to by CURR_PD_P, and between code addresses START_ADR and END_ADR.    Other parameters are explained in comments below. */
end_comment

begin_comment
comment|/* This used to be inline in hpread_quick_traverse, but now that we do    essentially the same thing for two different cases (modules and    module-less files), it's better organized in a separate routine,    although it does take lots of arguments.  pai/1997-10-08        CURR_PD_P is the pointer to the current proc index. QPD is the    procedure quick lookup table.  MAX_PROCS is the number of entries    in the proc. table.  START_ADR is the beginning of the code range    for the current psymtab.  end_adr is the end of the code range for    the current psymtab.  PST is the current psymtab.  VT_bits is    a pointer to the strings table of SOM debug space.  OBJFILE is    the current object file. */
end_comment

begin_function
specifier|static
name|int
name|scan_procs
parameter_list|(
name|int
modifier|*
name|curr_pd_p
parameter_list|,
name|quick_procedure_entry
modifier|*
name|qPD
parameter_list|,
name|int
name|max_procs
parameter_list|,
name|CORE_ADDR
name|start_adr
parameter_list|,
name|CORE_ADDR
name|end_adr
parameter_list|,
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
name|char
modifier|*
name|vt_bits
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|int
name|symbol_count
init|=
literal|0
decl_stmt|;
comment|/* Total number of symbols in this psymtab */
name|int
name|curr_pd
init|=
operator|*
name|curr_pd_p
decl_stmt|;
comment|/* Convenience variable -- avoid dereferencing pointer all the time */
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on for lots of debugging information in this routine */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Scan_procs called, addresses %x to %x, proc %x\n"
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|CURR_PROC_START
operator|<=
name|end_adr
operator|)
operator|&&
operator|(
name|curr_pd
operator|<
name|max_procs
operator|)
condition|)
block|{
name|char
modifier|*
name|rtn_name
decl_stmt|;
comment|/* mangled name */
name|char
modifier|*
name|rtn_dem_name
decl_stmt|;
comment|/* qualified demangled name */
name|char
modifier|*
name|class_name
decl_stmt|;
name|int
name|class
decl_stmt|;
if|if
condition|(
operator|(
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
operator|==
name|language_cplus
operator|)
operator|&&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbAlias
index|]
condition|)
comment|/* not a null string */
block|{
comment|/* Get mangled name for the procedure, and demangle it */
name|rtn_name
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbAlias
index|]
expr_stmt|;
name|rtn_dem_name
operator|=
name|cplus_demangle
argument_list|(
name|rtn_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtn_name
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
expr_stmt|;
name|rtn_dem_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Hack to get around HP C/C++ compilers' insistence on providing          "_MAIN_" as an alternate name for "main" */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|rtn_name
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|rtn_dem_name
operator|=
name|rtn_name
operator|=
name|main_string
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"..add %s (demangled %s), index %x to this psymtab\n"
argument_list|,
name|rtn_name
argument_list|,
name|rtn_dem_name
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check for module-spanning routines. */
if|if
condition|(
name|CURR_PROC_END
operator|>
name|end_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Procedure \"%s\" [0x%x] spans file or module boundaries."
argument_list|,
name|rtn_name
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
comment|/* Add this routine symbol to the list in the objfile.           Unfortunately we have to go to the LNTT to determine the          correct list to put it on. An alternative (which the          code used to do) would be to not check and always throw          it on the "static" list. But if we go that route, then          symbol_lookup() needs to be tweaked a bit to account          for the fact that the function might not be found on          the correct list in the psymtab. - RT */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|isym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_psymbol_with_dem_name_to_list
argument_list|(
name|rtn_name
argument_list|,
name|strlen
argument_list|(
name|rtn_name
argument_list|)
argument_list|,
name|rtn_dem_name
argument_list|,
name|strlen
argument_list|(
name|rtn_dem_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
comment|/* "I am a routine"        */
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
operator|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|adrStart
operator|+
comment|/* Starting address of rtn */
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
comment|/* core addr?? */
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_with_dem_name_to_list
argument_list|(
name|rtn_name
argument_list|,
name|strlen
argument_list|(
name|rtn_name
argument_list|)
argument_list|,
name|rtn_dem_name
argument_list|,
name|strlen
argument_list|(
name|rtn_dem_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
comment|/* "I am a routine"        */
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
operator|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|adrStart
operator|+
comment|/* Starting address of rtn */
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
comment|/* core addr?? */
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|symbol_count
operator|++
expr_stmt|;
operator|*
name|curr_pd_p
operator|=
operator|++
name|curr_pd
expr_stmt|;
comment|/* bump up count& reflect in caller */
block|}
comment|/* loop over procedures */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
if|if
condition|(
name|symbol_count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Scan_procs: no symbols found!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|symbol_count
return|;
block|}
end_function

begin_comment
comment|/* Traverse the quick look-up tables, building a set of psymtabs.     This constructs a psymtab for modules and files in the quick lookup    tables.     Mostly, modules correspond to compilation units, so we try to    create psymtabs that correspond to modules; however, in some cases    a file can result in a compiled object which does not have a module    entry for it, so in such cases we create a psymtab for the file.  */
end_comment

begin_function
specifier|static
name|int
name|hpread_quick_traverse
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|gntt_bits
parameter_list|,
name|char
modifier|*
name|vt_bits
parameter_list|,
name|PXDB_header_ptr
name|pxdb_header_p
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|quick_procedure_entry
modifier|*
name|qPD
decl_stmt|;
name|quick_file_entry
modifier|*
name|qFD
decl_stmt|;
name|quick_module_entry
modifier|*
name|qMD
decl_stmt|;
name|quick_class_entry
modifier|*
name|qCD
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|start_adr
decl_stmt|;
comment|/* current psymtab's starting code addr   */
name|CORE_ADDR
name|end_adr
decl_stmt|;
comment|/* current psymtab's ending code addr     */
name|CORE_ADDR
name|next_mod_adr
decl_stmt|;
comment|/* next module's starting code addr    */
name|int
name|curr_pd
decl_stmt|;
comment|/* current procedure */
name|int
name|curr_fd
decl_stmt|;
comment|/* current file      */
name|int
name|curr_md
decl_stmt|;
comment|/* current module    */
name|int
name|start_sym
decl_stmt|;
comment|/* current psymtab's starting symbol index */
name|int
name|end_sym
decl_stmt|;
comment|/* current psymtab's ending symbol index   */
name|int
name|max_LNTT_sym_index
decl_stmt|;
name|int
name|syms_in_pst
decl_stmt|;
name|B_TYPE
modifier|*
name|class_entered
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
comment|/* We'll be filling in the "global"   */
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
comment|/* and "static" tables in the objfile 					   as we go, so we need a pair of      					   current pointers. */
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on for lots of debugging information in this routine.      You get a blow-by-blow account of quick lookup table reading */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Clear out some globals */
name|init_pst_syms
argument_list|()
expr_stmt|;
name|told_objfile
operator|=
literal|0
expr_stmt|;
comment|/* Demangling style -- if EDG style already set, don't change it,      as HP style causes some problems with the KAI EDG compiler */
if|if
condition|(
name|current_demangling_style
operator|!=
name|edg_demangling
condition|)
block|{
comment|/* Otherwise, ensure that we are using HP style demangling */
name|set_demangling_style
argument_list|(
name|HP_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
comment|/* First we need to find the starting points of the quick      look-up tables in the GNTT. */
name|addr
operator|=
name|gntt_bits
expr_stmt|;
name|qPD
operator|=
operator|(
name|quick_procedure_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|pd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_procedure_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing routines as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_PROC
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qPD
index|[
name|i
index|]
operator|.
name|sbProc
expr_stmt|;
name|printf
argument_list|(
literal|"%s %x..%x\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|PROC_START
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|PROC_END
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qFD
operator|=
operator|(
name|quick_file_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|fd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_file_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing files as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_FILE
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qFD
index|[
name|i
index|]
operator|.
name|sbFile
expr_stmt|;
name|printf
argument_list|(
literal|"%s %x..%x\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|FILE_START
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FILE_END
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qMD
operator|=
operator|(
name|quick_module_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|md_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_module_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing modules as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pxdb_header_p
operator|->
name|md_entries
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qMD
index|[
name|i
index|]
operator|.
name|sbMod
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qCD
operator|=
operator|(
name|quick_class_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|cd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_class_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing classes as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_CLASS
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qCD
index|[
name|i
index|]
operator|.
name|sbClass
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n Done with dump, on to build!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We need this index only while hp-symtab-read.c expects      a byte offset to the end of the LNTT entries for a given      psymtab.  Thus the need for it should go away someday.       When it goes away, then we won't have any need to load the      LNTT from the objfile at psymtab-time, and start-up will be      faster.  To make that work, we'll need some way to create      a null pst for the "globals" pseudo-module. */
name|max_LNTT_sym_index
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Scan the module descriptors and make a psymtab for each.       We know the MDs, FDs and the PDs are in order by starting      address.  We use that fact to traverse all three arrays in      parallel, knowing when the next PD is in a new file      and we need to create a new psymtab. */
name|curr_pd
operator|=
literal|0
expr_stmt|;
comment|/* Current procedure entry */
name|curr_fd
operator|=
literal|0
expr_stmt|;
comment|/* Current file entry */
name|curr_md
operator|=
literal|0
expr_stmt|;
comment|/* Current module entry */
name|start_adr
operator|=
literal|0
expr_stmt|;
comment|/* Current psymtab code range */
name|end_adr
operator|=
literal|0
expr_stmt|;
name|start_sym
operator|=
literal|0
expr_stmt|;
comment|/* Current psymtab symbol range */
name|end_sym
operator|=
literal|0
expr_stmt|;
name|syms_in_pst
operator|=
literal|0
expr_stmt|;
comment|/* Symbol count for psymtab */
comment|/* Psts actually just have pointers into the objfile's      symbol table, not their own symbol tables. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
comment|/* First skip over pseudo-entries with address 0.  These represent inlined      routines and abstract (uninstantiated) template routines.      FIXME: These should be read in and available -- even if we can't set      breakpoints, etc., there's some information that can be presented      to the user. pai/1997-10-08  */
while|while
condition|(
name|VALID_CURR_PROC
operator|&&
operator|(
name|CURR_PROC_START
operator|==
literal|0
operator|)
condition|)
name|curr_pd
operator|++
expr_stmt|;
comment|/* Loop over files, modules, and procedures in code address order. Each      time we enter an iteration of this loop, curr_pd points to the first      unprocessed procedure, curr_fd points to the first unprocessed file, and      curr_md to the first unprocessed module.  Each iteration of this loop      updates these as required -- any or all of them may be bumpd up      each time around.  When we exit this loop, we are done with all files      and modules in the tables -- there may still be some procedures, however.       Note: This code used to loop only over module entries, under the assumption      that files can occur via inclusions and are thus unreliable, while a      compiled object always corresponds to a module.  With CTTI in the HP aCC      compiler, it turns out that compiled objects may have only files and no      modules; so we have to loop over files and modules, creating psymtabs for      either as appropriate.  Unfortunately there are some problems (notably:      1. the lack of "SRC_FILE_END" entries in the LNTT, 2. the lack of pointers      to the ending symbol indices of a module or a file) which make it quite hard      to do this correctly.  Currently it uses a bunch of heuristics to start and      end psymtabs; they seem to work well with most objects generated by aCC, but      who knows when that will change...   */
while|while
condition|(
name|VALID_CURR_FILE
operator|||
name|VALID_CURR_MODULE
condition|)
block|{
name|char
modifier|*
name|mod_name_string
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|full_name_string
decl_stmt|;
comment|/* First check for modules like "version.c", which have no code          in them but still have qMD entries.  They also have no qFD or          qPD entries.  Their start address is -1 and their end address          is 0.  */
if|if
condition|(
name|VALID_CURR_MODULE
operator|&&
operator|(
name|CURR_MODULE_START
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|CURR_MODULE_END
operator|==
literal|0
operator|)
condition|)
block|{
name|mod_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qMD
index|[
name|curr_md
index|]
operator|.
name|sbMod
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"Module with data only %s\n"
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We'll skip the rest (it makes error-checking easier), and 	     just make an empty pst.  Right now empty psts are not put 	     in the pst chain, so all this is for naught, but later it 	     might help.  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|mod_name_string
argument_list|,
name|CURR_MODULE_START
argument_list|,
comment|/* Low text address: bogus! */
operator|(
name|CURR_MODULE_ISYM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  	     = capping symbol offset   	     = LDSYMOFF of nextfile */
literal|0
argument_list|,
comment|/* text high            */
name|NULL
argument_list|,
comment|/* dependency_list      */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used    */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|curr_md
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VALID_CURR_MODULE
operator|&&
operator|(
operator|(
name|CURR_MODULE_START
operator|==
literal|0
operator|)
operator|||
operator|(
name|CURR_MODULE_START
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|CURR_MODULE_END
operator|==
literal|0
operator|)
operator|||
operator|(
name|CURR_MODULE_END
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%s] has non-standard addresses.  It starts at 0x%s, ends at 0x%s, and will be skipped."
argument_list|,
name|mod_name_string
argument_list|,
name|paddr_nz
argument_list|(
name|curr_md
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|start_adr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|end_adr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On to next module */
name|curr_md
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* First check if we are looking at a file with code in it 	     that does not overlap the current module's code range */
if|if
condition|(
name|VALID_CURR_FILE
condition|?
operator|(
name|VALID_CURR_MODULE
condition|?
operator|(
name|CURR_FILE_END
operator|<
name|CURR_MODULE_START
operator|)
else|:
literal|1
operator|)
else|:
literal|0
condition|)
block|{
comment|/* Looking at file not corresponding to any module, 	         create a psymtab for it */
name|full_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
expr_stmt|;
name|start_adr
operator|=
name|CURR_FILE_START
expr_stmt|;
name|end_adr
operator|=
name|CURR_FILE_END
expr_stmt|;
name|start_sym
operator|=
name|CURR_FILE_ISYM
expr_stmt|;
comment|/* Check if there are any procedures not handled until now, that 	         begin before the start address of this file, and if so, adjust 	         this module's start address to include them.  This handles routines that 	         are in between file or module ranges for some reason (probably 	         indicates a compiler bug */
if|if
condition|(
name|CURR_PROC_START
operator|<
name|start_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found procedure \"%s\" [0x%x] that is not in any file or module."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
if|if
condition|(
name|CURR_PROC_ISYM
operator|<
name|start_sym
condition|)
name|start_sym
operator|=
name|CURR_PROC_ISYM
expr_stmt|;
block|}
comment|/* Sometimes (compiler bug -- COBOL) the module end address is higher 	         than the start address of the next module, so check for that and 	         adjust accordingly */
if|if
condition|(
name|VALID_FILE
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] has ending address after starting address of next file; adjusting ending address down."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
if|if
condition|(
name|VALID_MODULE
argument_list|(
name|curr_md
argument_list|)
operator|&&
operator|(
name|CURR_MODULE_START
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] has ending address after starting address of next module; adjusting ending address down."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|CURR_MODULE_START
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Make new psymtab for file %s (%x to %x).\n"
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Create the basic psymtab, connecting it in the list 	         for this objfile and pointing its symbol entries 	         to the current end of the symbol areas in the objfile.  	         The "ldsymoff" parameter is the byte offset in the LNTT 	         of the first symbol in this file.  Some day we should 	         turn this into an index (fix in hp-symtab-read.c as well). 	         And it's not even the right byte offset, as we're using 	         the size of a union! FIXME!  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|start_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
comment|/* Set up to only enter each class referenced in this module once.  */
name|class_entered
operator|=
name|xmalloc
argument_list|(
name|B_BYTES
argument_list|(
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|class_entered
argument_list|,
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
expr_stmt|;
comment|/* Scan the procedure descriptors for procedures in the current 	         file, based on the starting addresses. */
name|syms_in_pst
operator|=
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get ending symbol offset */
name|end_sym
operator|=
literal|0
expr_stmt|;
comment|/* First check for starting index before previous psymtab */
if|if
condition|(
name|pst_syms_count
operator|&&
name|start_sym
operator|<
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
condition|)
block|{
name|end_sym
operator|=
name|find_next_pst_start
argument_list|(
name|start_sym
argument_list|)
expr_stmt|;
block|}
comment|/* Look for next start index of a file or module, or procedure */
if|if
condition|(
operator|!
name|end_sym
condition|)
block|{
name|int
name|next_file_isym
init|=
name|find_next_file_isym
argument_list|(
name|start_sym
argument_list|,
name|qFD
argument_list|,
name|curr_fd
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_module_isym
init|=
name|find_next_module_isym
argument_list|(
name|start_sym
argument_list|,
name|qMD
argument_list|,
name|curr_md
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_proc_isym
init|=
name|find_next_proc_isym
argument_list|(
name|start_sym
argument_list|,
name|qPD
argument_list|,
name|curr_pd
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_file_isym
operator|&&
name|next_module_isym
condition|)
block|{
comment|/* pick lower of next file or module start index */
name|end_sym
operator|=
name|min
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one of them is zero, pick the other */
name|end_sym
operator|=
name|max
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
comment|/* As a precaution, check next procedure index too */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|next_proc_isym
expr_stmt|;
else|else
name|end_sym
operator|=
name|min
argument_list|(
name|end_sym
argument_list|,
name|next_proc_isym
argument_list|)
expr_stmt|;
block|}
comment|/* Couldn't find procedure, file, or module, use globals as default */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|pxdb_header_p
operator|->
name|globals
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"File psymtab indices: %x to %x\n"
argument_list|,
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  	         = capping symbol offset    	         = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high */
name|NULL
argument_list|,
comment|/* dependency_list */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used */
name|record_pst_syms
argument_list|(
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pst
condition|)
name|warning
argument_list|(
literal|"No symbols in psymtab for file \"%s\" [0x%x]."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Made new psymtab for file %s (%x to %x), sym %x to %x.\n"
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|CURR_FILE_ISYM
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Prepare for the next psymtab. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|xfree
argument_list|(
name|class_entered
argument_list|)
expr_stmt|;
name|curr_fd
operator|++
expr_stmt|;
block|}
comment|/* Psymtab for file */
else|else
block|{
comment|/* We have a module for which we create a psymtab */
name|mod_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qMD
index|[
name|curr_md
index|]
operator|.
name|sbMod
index|]
expr_stmt|;
comment|/* We will include the code ranges of any files that happen to 	         overlap with this module */
comment|/* So, first pick the lower of the file's and module's start addresses */
name|start_adr
operator|=
name|CURR_MODULE_START
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
condition|)
block|{
if|if
condition|(
name|CURR_FILE_START
operator|<
name|CURR_MODULE_START
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] crosses beginning of module \"%s\"."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|curr_fd
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_FILE_START
expr_stmt|;
block|}
block|}
comment|/* Also pick the lower of the file's and the module's start symbol indices */
name|start_sym
operator|=
name|CURR_MODULE_ISYM
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
operator|&&
operator|(
name|CURR_FILE_ISYM
operator|<
name|CURR_MODULE_ISYM
operator|)
condition|)
name|start_sym
operator|=
name|CURR_FILE_ISYM
expr_stmt|;
comment|/* For the end address, we scan through the files till we find one 	         that overlaps the current module but ends beyond it; if no such file exists we 	         simply use the module's start address.   	         (Note, if file entries themselves overlap 	         we take the longest overlapping extension beyond the end of the module...) 	         We assume that modules never overlap. */
name|end_adr
operator|=
name|CURR_MODULE_END
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
condition|)
block|{
while|while
condition|(
name|VALID_CURR_FILE
operator|&&
operator|(
name|CURR_FILE_START
operator|<
name|end_adr
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"Maybe skipping file %s which overlaps with module %s\n"
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CURR_FILE_END
operator|>
name|end_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] crosses end of module \"%s\"."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|curr_fd
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|CURR_FILE_END
expr_stmt|;
block|}
name|curr_fd
operator|++
expr_stmt|;
block|}
name|curr_fd
operator|--
expr_stmt|;
comment|/* back up after going too far */
block|}
comment|/* Sometimes (compiler bug -- COBOL) the module end address is higher 	         than the start address of the next module, so check for that and 	         adjust accordingly */
if|if
condition|(
name|VALID_MODULE
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|MODULE_START
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%x] has ending address after starting address of next module; adjusting ending address down."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|MODULE_START
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
if|if
condition|(
name|VALID_FILE
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%x] has ending address after starting address of next file; adjusting ending address down."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
comment|/* Use one file to get the full name for the module.  This 	         situation can arise if there is executable code in a #include 	         file.  Each file with code in it gets a qFD.  Files which don't 	         contribute code don't get a qFD, even if they include files 	         which do, e.g.:   	         body.c:                    rtn.h: 	         int x;                     int main() { 	         #include "rtn.h"               return x; 	         }  	         There will a qFD for "rtn.h",and a qMD for "body.c", 	         but no qMD for "rtn.h" or qFD for "body.c"!  	         We pick the name of the last file to overlap with this 	         module.  C convention is to put include files first.  In a 	         perfect world, we could check names and use the file whose full 	         path name ends with the module name. */
if|if
condition|(
name|VALID_CURR_FILE
condition|)
name|full_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
expr_stmt|;
else|else
name|full_name_string
operator|=
name|mod_name_string
expr_stmt|;
comment|/* Check if there are any procedures not handled until now, that 	         begin before the start address we have now, and if so, adjust 	         this psymtab's start address to include them.  This handles routines that 	         are in between file or module ranges for some reason (probably 	         indicates a compiler bug */
if|if
condition|(
name|CURR_PROC_START
operator|<
name|start_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found procedure \"%s\" [0x%x] that is not in any file or module."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
if|if
condition|(
name|CURR_PROC_ISYM
operator|<
name|start_sym
condition|)
name|start_sym
operator|=
name|CURR_PROC_ISYM
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Make new psymtab for module %s (%x to %x), using file %s\n"
argument_list|,
name|mod_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|full_name_string
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Create the basic psymtab, connecting it in the list 	         for this objfile and pointing its symbol entries 	         to the current end of the symbol areas in the objfile.  	         The "ldsymoff" parameter is the byte offset in the LNTT 	         of the first symbol in this file.  Some day we should 	         turn this into an index (fix in hp-symtab-read.c as well). 	         And it's not even the right byte offset, as we're using 	         the size of a union! FIXME!  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|start_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
comment|/* Set up to only enter each class referenced in this module once.  */
name|class_entered
operator|=
name|xmalloc
argument_list|(
name|B_BYTES
argument_list|(
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|class_entered
argument_list|,
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
expr_stmt|;
comment|/* Scan the procedure descriptors for procedures in the current 	         module, based on the starting addresses. */
name|syms_in_pst
operator|=
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get ending symbol offset */
name|end_sym
operator|=
literal|0
expr_stmt|;
comment|/* First check for starting index before previous psymtab */
if|if
condition|(
name|pst_syms_count
operator|&&
name|start_sym
operator|<
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
condition|)
block|{
name|end_sym
operator|=
name|find_next_pst_start
argument_list|(
name|start_sym
argument_list|)
expr_stmt|;
block|}
comment|/* Look for next start index of a file or module, or procedure */
if|if
condition|(
operator|!
name|end_sym
condition|)
block|{
name|int
name|next_file_isym
init|=
name|find_next_file_isym
argument_list|(
name|start_sym
argument_list|,
name|qFD
argument_list|,
name|curr_fd
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_module_isym
init|=
name|find_next_module_isym
argument_list|(
name|start_sym
argument_list|,
name|qMD
argument_list|,
name|curr_md
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_proc_isym
init|=
name|find_next_proc_isym
argument_list|(
name|start_sym
argument_list|,
name|qPD
argument_list|,
name|curr_pd
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_file_isym
operator|&&
name|next_module_isym
condition|)
block|{
comment|/* pick lower of next file or module start index */
name|end_sym
operator|=
name|min
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one of them is zero, pick the other */
name|end_sym
operator|=
name|max
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
comment|/* As a precaution, check next procedure index too */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|next_proc_isym
expr_stmt|;
else|else
name|end_sym
operator|=
name|min
argument_list|(
name|end_sym
argument_list|,
name|next_proc_isym
argument_list|)
expr_stmt|;
block|}
comment|/* Couldn't find procedure, file, or module, use globals as default */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|pxdb_header_p
operator|->
name|globals
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Module psymtab indices: %x to %x\n"
argument_list|,
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  	         = capping symbol offset    	         = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high */
name|NULL
argument_list|,
comment|/* dependency_list      */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used    */
name|record_pst_syms
argument_list|(
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pst
condition|)
name|warning
argument_list|(
literal|"No symbols in psymtab for module \"%s\" [0x%x]."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Made new psymtab for module %s (%x to %x), sym %x to %x.\n"
argument_list|,
name|mod_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|CURR_MODULE_ISYM
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Prepare for the next psymtab. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|xfree
argument_list|(
name|class_entered
argument_list|)
expr_stmt|;
name|curr_md
operator|++
expr_stmt|;
name|curr_fd
operator|++
expr_stmt|;
block|}
comment|/* psymtab for module */
block|}
comment|/* psymtab for non-bogus file or module */
block|}
comment|/* End of while loop over all files& modules */
comment|/* There may be some routines after all files and modules -- these will get      inserted in a separate new module of their own */
if|if
condition|(
name|VALID_CURR_PROC
condition|)
block|{
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
name|end_adr
operator|=
name|qPD
index|[
name|pxdb_header_p
operator|->
name|pd_entries
operator|-
literal|1
index|]
operator|.
name|adrEnd
expr_stmt|;
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found functions beyond end of all files and modules [0x%x]."
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Orphan functions at end, PD %d and beyond (%x to %x)\n"
argument_list|,
name|curr_pd
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
literal|"orphans"
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|CURR_PROC_ISYM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used */
name|pxdb_header_p
operator|->
name|globals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end           = capping symbol offset             = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high  */
name|NULL
argument_list|,
comment|/* dependency_list */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used */
block|}
ifdef|#
directive|ifdef
name|NEVER_NEVER
comment|/* Now build psts for non-module things (in the tail of      the LNTT, after the last END MODULE entry).       If null psts were kept on the chain, this would be      a solution.  FIXME */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|pxdb_header_p
operator|->
name|globals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|max_LNTT_sym_index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear_pst_syms
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End of hpread_quick_traverse. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get appropriate header, based on pxdb type.     Return value: 1 if ok, 0 if not */
end_comment

begin_function
specifier|static
name|int
name|hpread_get_header
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|PXDB_header_ptr
name|pxdb_header_p
parameter_list|)
block|{
name|asection
modifier|*
name|pinfo_section
decl_stmt|,
modifier|*
name|debug_section
decl_stmt|,
modifier|*
name|header_section
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn on for debugging information */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|header_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$HEADER$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_section
condition|)
block|{
comment|/* We don't have either PINFO or DEBUG sections.  But          stuff like "libc.sl" has no debug info.  There's no          need to warn the user of this, as it may be ok. The          caller will figure it out and issue any needed          messages. */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"==No debug info at all for %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* We would like either a $DEBUG$ or $PINFO$ section.      Once we know which, we can understand the header      data (which we have defined to suit the more common      $DEBUG$ case). */
name|debug_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$DEBUG$"
argument_list|)
expr_stmt|;
name|pinfo_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$PINFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_section
condition|)
block|{
comment|/* The expected case: normal pxdb header. */
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|,
name|pxdb_header_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pxdb_header_p
operator|->
name|pxdbed
condition|)
block|{
comment|/* This shouldn't happen if we check in "symfile.c". */
return|return
literal|0
return|;
block|}
comment|/* DEBUG section */
block|}
elseif|else
if|if
condition|(
name|pinfo_section
condition|)
block|{
comment|/* The DOC case; we need to translate this into a          regular header. */
name|DOC_info_PXDB_header
name|doc_header
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"==OOps, PINFO, let's try to handle this, %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|,
operator|&
name|doc_header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doc_header
operator|.
name|pxdbed
condition|)
block|{
comment|/* This shouldn't happen if we check in "symfile.c". */
name|warning
argument_list|(
literal|"File \"%s\" not processed by pxdb!"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Copy relevent fields to standard header passed in. */
name|pxdb_header_p
operator|->
name|pd_entries
operator|=
name|doc_header
operator|.
name|pd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|fd_entries
operator|=
name|doc_header
operator|.
name|fd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|md_entries
operator|=
name|doc_header
operator|.
name|md_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|pxdbed
operator|=
name|doc_header
operator|.
name|pxdbed
expr_stmt|;
name|pxdb_header_p
operator|->
name|bighdr
operator|=
name|doc_header
operator|.
name|bighdr
expr_stmt|;
name|pxdb_header_p
operator|->
name|sa_header
operator|=
name|doc_header
operator|.
name|sa_header
expr_stmt|;
name|pxdb_header_p
operator|->
name|inlined
operator|=
name|doc_header
operator|.
name|inlined
expr_stmt|;
name|pxdb_header_p
operator|->
name|globals
operator|=
name|doc_header
operator|.
name|globals
expr_stmt|;
name|pxdb_header_p
operator|->
name|time
operator|=
name|doc_header
operator|.
name|time
expr_stmt|;
name|pxdb_header_p
operator|->
name|pg_entries
operator|=
name|doc_header
operator|.
name|pg_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|functions
operator|=
name|doc_header
operator|.
name|functions
expr_stmt|;
name|pxdb_header_p
operator|->
name|files
operator|=
name|doc_header
operator|.
name|files
expr_stmt|;
name|pxdb_header_p
operator|->
name|cd_entries
operator|=
name|doc_header
operator|.
name|cd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|aa_entries
operator|=
name|doc_header
operator|.
name|aa_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|oi_entries
operator|=
name|doc_header
operator|.
name|oi_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|version
operator|=
name|doc_header
operator|.
name|version
expr_stmt|;
block|}
comment|/* PINFO section */
else|else
block|{
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"==No debug info at all for %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End of hpread_get_header */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUICK_LOOK_UP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Initialization for reading native HP C debug symbols from OBJFILE.     Its only purpose in life is to set up the symbol reader's private    per-objfile data structures, and read in the raw contents of the debug    sections (attaching pointers to the debug info into the private data    structures).     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  Note we may    be called on a file without native HP C debugging symbols.     FIXME, there should be a cleaner peephole into the BFD environment    here. */
end_comment

begin_function
name|void
name|hpread_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|asection
modifier|*
name|vt_section
decl_stmt|,
modifier|*
name|slt_section
decl_stmt|,
modifier|*
name|lntt_section
decl_stmt|,
modifier|*
name|gntt_section
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpread_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpread_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We haven't read in any types yet.  */
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Read in data from the $GNTT$ subspace.  */
name|gntt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$GNTT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gntt_section
condition|)
return|return;
name|GNTT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|,
name|GNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* Read in data from the $LNTT$ subspace.   Also keep track of the number      of LNTT symbols.       FIXME: this could be moved into the psymtab-to-symtab expansion      code, and save startup time.  At the moment this data is      still used, though.  We'd need a way to tell hp-symtab-read.c      whether or not to load the LNTT. */
name|lntt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$LNTT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lntt_section
condition|)
return|return;
name|LNTT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|,
name|LNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* Read in data from the $SLT$ subspace.  $SLT$ contains information      on source line numbers.  */
name|slt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$SLT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slt_section
condition|)
return|return;
name|SLT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|,
name|SLT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in data from the $VT$ subspace.  $VT$ contains things like      names and constants.  Keep track of the number of symbols in the VT.  */
name|vt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$VT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vt_section
condition|)
return|return;
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|vt_section
argument_list|)
expr_stmt|;
name|VT
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|vt_section
argument_list|,
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.     The minimal symbol table (either SOM or HP a.out) has already been    read in; all we need to do is setup partial symbols based on the    native debugging information.     Note that the minimal table is produced by the linker, and has    only global routines in it; the psymtab is based on compiler-    generated debug information and has non-global    routines in it as well as files and class information.     We assume hpread_symfile_init has been called to initialize the    symbol reader's private data structures.     MAINLINE is true if we are reading the main symbol table (as    opposed to a shared lib or dynamically loaded file). */
end_comment

begin_function
name|void
name|hpread_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on to get debugging output. */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|hp_symnum
decl_stmt|,
name|symcount
decl_stmt|,
name|i
decl_stmt|;
name|int
name|scan_start
init|=
literal|0
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|unsigned
name|long
name|valu
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|texthigh
init|=
literal|0
decl_stmt|;
name|int
name|have_name
init|=
literal|0
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
comment|/* Just in case the stabs reader left turds lying around.  */
name|free_pending_blocks
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* We shouldn't use alloca, instead use malloc/free.  Doing so avoids      a number of problems with cross compilation and creating useless holes      in the stack when we have to allocate new entries.  FIXME.  */
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
block|{
comment|/* Begin code for new-style loading of quick look-up tables. */
comment|/* elz: this checks whether the file has beeen processed by pxdb.        If not we would like to try to read the psymbols in        anyway, but it turns out to be not so easy. So this could         actually be commented out, but I leave it in, just in case        we decide to add support for non-pxdb-ed stuff in the future. */
name|PXDB_header
name|pxdb_header
decl_stmt|;
name|int
name|found_modules_in_program
decl_stmt|;
if|if
condition|(
name|hpread_get_header
argument_list|(
name|objfile
argument_list|,
operator|&
name|pxdb_header
argument_list|)
condition|)
block|{
comment|/* Build a minimal table.  No types, no global variables, 	   no include files.... */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"\nNew method for %s\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* elz: quick_traverse returns true if it found 	   some modules in the main source file, other 	   than those in end.c 	   In C and C++, all the files have MODULES entries 	   in the LNTT, and the quick table traverse is all  	   based on finding these MODULES entries. Without  	   those it cannot work.  	   It happens that F77 programs don't have MODULES 	   so the quick traverse gets confused. F90 programs 	   have modules, and the quick method still works. 	   So, if modules (other than those in end.c) are 	   not found we give up on the quick table stuff,  	   and fall back on the slower method  */
name|found_modules_in_program
operator|=
name|hpread_quick_traverse
argument_list|(
name|objfile
argument_list|,
name|GNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
operator|&
name|pxdb_header
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Set up to scan the global section of the LNTT.  	   This field is not always correct: if there are 	   no globals, it will point to the last record in 	   the regular LNTT, which is usually an END MODULE.  	   Since it might happen that there could be a file 	   with just one global record, there's no way to 	   tell other than by looking at the record, so that's 	   done below. */
if|if
condition|(
name|found_modules_in_program
condition|)
name|scan_start
operator|=
name|pxdb_header
operator|.
name|globals
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMPING
else|else
block|{
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"\nGoing on to old method for %s\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* Make two passes, one over the GNTT symbols, the other for the      LNTT symbols.       JB comment: above isn't true--they only make one pass, over      the LNTT.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|within_function
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|symcount
operator|=
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
for|for
control|(
name|hp_symnum
operator|=
name|scan_start
init|;
name|hp_symnum
operator|<
name|symcount
condition|;
name|hp_symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|dn_bufp
operator|=
name|hpread_get_gntt
argument_list|(
name|hp_symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|hp_symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
comment|/* Only handle things which are necessary for minimal symbols. 	     everything else is ignored.  */
switch|switch
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
block|{
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
if|if
condition|(
name|scan_start
operator|==
name|hp_symnum
operator|&&
name|symcount
operator|==
name|hp_symnum
operator|+
literal|1
condition|)
block|{
comment|/* If there are NO globals in an executable, 		       PXDB's index to the globals will point to 		       the last record in the file, which  		       could be this record. (this happened for F77 libraries) 		       ignore it and be done! */
continue|continue;
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* A source file of some kind.  Note this may simply 		   be an included file.  */
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Check if this is the source file we are already working 		   with.  */
if|if
condition|(
name|pst
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
comment|/* Check if this is an include file, if so check if we have 		   already seen it.  Add it to the include list */
name|p
operator|=
name|strrchr
argument_list|(
name|namestring
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".h"
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|includes_used
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* Add it to the list of includes seen so far and 		       allocate more include space if necessary.  */
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|psymtab_include_list
argument_list|,
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|pst
condition|)
block|{
if|if
condition|(
operator|!
name|have_name
condition|)
block|{
name|pst
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|pst
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
comment|/* This is a bonafide new source file. 		   End the current partial symtab and start a new one.  */
if|if
condition|(
name|pst
operator|&&
name|past_first_source_file
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|valu
operator|=
name|hpread_get_textlow
argument_list|(
name|i
argument_list|,
name|hp_symnum
argument_list|,
name|objfile
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|texthigh
operator|=
name|valu
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/* A source file.  It's still unclear to me what the 	         real difference between a DNTT_TYPE_SRCFILE and DNTT_TYPE_MODULE 	         is supposed to be.  */
comment|/* First end the previous psymtab */
if|if
condition|(
name|pst
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|(
operator|(
name|hp_symnum
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|have_name
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now begin a new module and a new psymtab for it */
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|=
name|hpread_get_textlow
argument_list|(
name|i
argument_list|,
name|hp_symnum
argument_list|,
name|objfile
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|texthigh
operator|=
name|valu
expr_stmt|;
name|have_name
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
comment|/* The beginning of a function.  DNTT_TYPE_ENTRY may also denote 	         a secondary entry point.  */
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|hiaddr
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valu
operator|>
name|texthigh
condition|)
name|texthigh
operator|=
name|valu
expr_stmt|;
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|hiaddr
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valu
operator|>
name|texthigh
condition|)
name|texthigh
operator|=
name|valu
expr_stmt|;
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|lowaddr
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
comment|/* We don't check MODULE end here, because there can be 	         symbols beyond the module end which properly belong to the 	         current psymtab -- so we wait till the next MODULE start */
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
if|if
condition|(
name|scan_start
operator|==
name|hp_symnum
operator|&&
name|symcount
operator|==
name|hp_symnum
operator|+
literal|1
condition|)
block|{
comment|/* If there are NO globals in an executable, 		     PXDB's index to the globals will point to 		     the last record in the file, which is 		     probably an END MODULE, i.e. this record. 		     ignore it and be done! */
continue|continue;
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* Scope block begin/end.  We only care about function 	         and file blocks right now.  */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
operator|==
name|DNTT_TYPE_FUNCTION
operator|)
operator|||
operator|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|)
condition|)
name|within_function
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_TYPEDEF
case|:
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
comment|/* Variables, typedefs an the like.  */
name|enum
name|address_class
name|storage
decl_stmt|;
name|domain_enum
name|domain
decl_stmt|;
comment|/* Don't add locals to the partial symbol table.  */
if|if
condition|(
name|within_function
operator|&&
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
operator|)
condition|)
continue|continue;
comment|/* TAGDEFs go into the structure domain.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
condition|)
name|domain
operator|=
name|STRUCT_DOMAIN
expr_stmt|;
else|else
name|domain
operator|=
name|VAR_DOMAIN
expr_stmt|;
comment|/* What kind of "storage" does this use?  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
name|storage
operator|=
name|LOC_STATIC
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
operator|&&
name|dn_bufp
operator|->
name|ddvar
operator|.
name|regvar
condition|)
name|storage
operator|=
name|LOC_REGISTER
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
condition|)
name|storage
operator|=
name|LOC_LOCAL
expr_stmt|;
else|else
name|storage
operator|=
name|LOC_UNDEF
expr_stmt|;
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Compute address of the data symbol */
name|valu
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
expr_stmt|;
comment|/* Relocate in case it's in a shared library */
if|if
condition|(
name|storage
operator|==
name|LOC_STATIC
condition|)
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Luckily, dvar, svar, typedef, and tagdef all 		   have their "global" bit in the same place, so it works 		   (though it's bad programming practice) to reference 		   "dsvar.global" even though we may be looking at 		   any of the above four types. */
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|global
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|domain
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|domain
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* For TAGDEF's, the above code added the tagname to the 		   struct domain. This will cause tag "t" to be found 		   on a reference of the form "(struct t) x". But for 		   C++ classes, "t" will also be a typename, which we 		   want to find on a reference of the form "ptype t". 		   Therefore, we also add "t" to the var domain. 		   Do the same for enum's due to the way aCC generates 		   debug info for these (see more extended comment 		   in hp-symtab-read.c). 		   We do the same for templates, so that "ptype t" 		   where "t" is a template also works. */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
operator|&&
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|int
name|global
init|=
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
decl_stmt|;
comment|/* Look ahead to see if it's a C++ class */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
if|if
condition|(
name|global
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
continue|continue;
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_CONST
case|:
comment|/* Constants and members of enumerated types.  */
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
block|}
block|}
comment|/* End any pending partial symbol table. */
if|if
condition|(
name|pst
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
name|void
name|hpread_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The remaining functions are all for internal use only.  */
end_comment

begin_comment
comment|/* Various small functions to get entries in the debug symbol sections.  */
end_comment

begin_function
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_lntt
parameter_list|(
name|int
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
return|return
operator|(
expr|union
name|dnttentry
operator|*
operator|)
operator|&
operator|(
name|LNTT
argument_list|(
name|objfile
argument_list|)
index|[
operator|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_gntt
parameter_list|(
name|int
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
return|return
operator|(
expr|union
name|dnttentry
operator|*
operator|)
operator|&
operator|(
name|GNTT
argument_list|(
name|objfile
argument_list|)
index|[
operator|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|sltentry
modifier|*
name|hpread_get_slt
parameter_list|(
name|int
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
return|return
operator|(
expr|union
name|sltentry
operator|*
operator|)
operator|&
operator|(
name|SLT
argument_list|(
name|objfile
argument_list|)
index|[
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|sltentry
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the low address associated with some symbol (typically the start    of a particular source file or module).  Since that information is not    stored as part of the DNTT_TYPE_MODULE or DNTT_TYPE_SRCFILE symbol we    must infer it from the existence of DNTT_TYPE_FUNCTION symbols.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_textlow
parameter_list|(
name|int
name|global
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|symcount
parameter_list|)
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Look for a DNTT_TYPE_FUNCTION symbol.  */
if|if
condition|(
name|index
operator|<
name|symcount
condition|)
comment|/* symcount is the number of symbols in */
block|{
comment|/*   the dbinfo, LNTT table */
do|do
block|{
if|if
condition|(
name|global
condition|)
name|dn_bufp
operator|=
name|hpread_get_gntt
argument_list|(
name|index
operator|++
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|index
operator|++
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_FUNCTION
operator|&&
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_DOC_FUNCTION
operator|&&
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_END
operator|&&
name|index
operator|<
name|symcount
condition|)
do|;
block|}
comment|/* NOTE: cagney/2003-03-29: If !(index< symcount), dn_bufp is left      undefined and that means that the test below is using a garbage      pointer from the stack.  */
name|gdb_assert
argument_list|(
name|dn_bufp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Avoid going past a DNTT_TYPE_END when looking for a DNTT_TYPE_FUNCTION.  This      might happen when a sourcefile has no functions.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_END
condition|)
return|return
literal|0
return|;
comment|/* Avoid going past the end of the LNTT file */
if|if
condition|(
name|index
operator|==
name|symcount
condition|)
return|return
literal|0
return|;
comment|/* The minimal symbols are typically more accurate for some reason.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
condition|)
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
operator|+
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
comment|/* must be a DNTT_TYPE_DOC_FUNCTION */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
operator|+
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
condition|)
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
return|;
else|else
return|return
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
return|;
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_start_psymtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|CORE_ADDR
name|textlow
parameter_list|,
name|int
name|ldsymoff
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
parameter_list|)
block|{
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|hpread_psymtab_to_symtab
parameter_list|()
function_decl|;
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|textlow
operator|+=
name|offset
expr_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|hpread_psymtab_to_symtab
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close off the current usage of PST.      Returns PST or NULL if the partial symtab was empty and thrown away.     capping_symbol_offset  --Byte index in LNTT or GNTT of the    last symbol processed during the build    of the previous pst.     FIXME:  List variables and peculiarities of same.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_end_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
name|char
modifier|*
modifier|*
name|include_list
parameter_list|,
name|int
name|num_includes
parameter_list|,
name|int
name|capping_symbol_offset
parameter_list|,
name|CORE_ADDR
name|capping_text
parameter_list|,
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
parameter_list|,
name|int
name|number_dependencies
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn on to see what kind of a psymtab we've built. */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|capping_symbol_offset
operator|!=
operator|-
literal|1
condition|)
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_offset
operator|-
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
else|else
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
operator|+
name|offset
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\nPst %s, LDSYMOFF %x (%x), LDSYMLEN %x (%x), globals %d, statics %d\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
name|pst
operator|->
name|n_static_syms
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMLEN
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these,          shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since          it is on the obstack, but we can forget to chain it on the list.           Empty psymtabs happen as a result of header files which don't have          any symbols in them.  There can be a lot of them.  But this check          is wrong, in that a psymtab with N_SLINE entries but nothing else          is not empty, but we don't realize that.  Fixing that without slowing          things down might be tricky.          It's also wrong if we're using the quick look-up tables, as          we can get empty psymtabs from modules with no routines in          them. */
name|discard_psymtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Indicate that psymtab was thrown away.  */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the nesting depth for the source line identified by INDEX.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_scope_start
parameter_list|(
name|sltpointer
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sl_bufp
operator|->
name|sspec
operator|.
name|backptr
operator|.
name|dnttp
operator|.
name|index
return|;
block|}
end_function

begin_comment
comment|/* Get the source line number the the line identified by INDEX.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_line
parameter_list|(
name|sltpointer
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|line
return|;
block|}
end_function

begin_comment
comment|/* Find the code address associated with a given sltpointer */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|hpread_get_location
parameter_list|(
name|sltpointer
name|index
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* code location of special sltentrys is determined from context */
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_END
condition|)
block|{
comment|/* find previous normal sltentry and get address */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL_OFFSET
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_EXIT
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
operator|-
name|i
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
return|return
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
return|;
else|else
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
return|;
block|}
comment|/* find next normal sltentry and get address */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL_OFFSET
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_EXIT
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
operator|+
name|i
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
return|return
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
return|;
else|else
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if an HP debug symbol of type KIND has a name associated with  * it, else return 0. (This function is not currently used, but I'll  * leave it here in case it proves useful later on. - RT).  */
end_comment

begin_function
specifier|static
name|int
name|hpread_has_name
parameter_list|(
name|enum
name|dntt_entry_type
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
case|case
name|DNTT_TYPE_MODULE
case|:
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
case|case
name|DNTT_TYPE_IMPORT
case|:
case|case
name|DNTT_TYPE_LABEL
case|:
case|case
name|DNTT_TYPE_FPARAM
case|:
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_CONST
case|:
case|case
name|DNTT_TYPE_TYPEDEF
case|:
case|case
name|DNTT_TYPE_TAGDEF
case|:
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_FIELD
case|:
case|case
name|DNTT_TYPE_SA
case|:
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
case|case
name|DNTT_TYPE_MEMFUNC
case|:
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
return|return
literal|1
return|;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
case|case
name|DNTT_TYPE_POINTER
case|:
case|case
name|DNTT_TYPE_ENUM
case|:
case|case
name|DNTT_TYPE_SET
case|:
case|case
name|DNTT_TYPE_ARRAY
case|:
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
case|case
name|DNTT_TYPE_VARIANT
case|:
case|case
name|DNTT_TYPE_FILE
case|:
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
case|case
name|DNTT_TYPE_SUBRANGE
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_COBSTRUCT
case|:
case|case
name|DNTT_TYPE_XREF
case|:
case|case
name|DNTT_TYPE_MACRO
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
case|case
name|DNTT_TYPE_REFERENCE
case|:
case|case
name|DNTT_TYPE_PTRMEM
case|:
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
case|case
name|DNTT_TYPE_CLASS
case|:
case|case
name|DNTT_TYPE_GENFIELD
case|:
case|case
name|DNTT_TYPE_VFUNC
case|:
case|case
name|DNTT_TYPE_MEMACCESS
case|:
case|case
name|DNTT_TYPE_INHERITANCE
case|:
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
case|case
name|DNTT_TYPE_MODIFIER
case|:
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
case|case
name|DNTT_TYPE_TEMPLATE
case|:
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* DNTT_TYPE_DYN_ARRAY_DESC ? */
comment|/* DNTT_TYPE_DESC_SUBRANGE ? */
comment|/* DNTT_TYPE_BEGIN_EXT ? */
comment|/* DNTT_TYPE_INLN ? */
comment|/* DNTT_TYPE_INLN_LIST ? */
comment|/* DNTT_TYPE_ALIAS ? */
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do the dirty work of reading in the full symbol from a partial symbol    table.  */
end_comment

begin_function
specifier|static
name|void
name|hpread_psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get out quick if passed junk.  */
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
comment|/* Complain if we've already read in this symbol table.  */
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in."
literal|"  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|hpread_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If it's real...  */
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
condition|)
block|{
comment|/* Init stuff necessary for reading in symbols */
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|hpread_expand_symtab
argument_list|(
name|pst
operator|->
name|objfile
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
argument_list|,
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|hpread_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
comment|/* Get out quick if given junk.  */
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
comment|/* Sanity check.  */
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in."
literal|"  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* elz: setting the flag to indicate that the code of the target      was compiled using an HP compiler (aCC, cc)       the processing_acc_compilation variable is declared in the       file buildsym.h, the HP_COMPILED_TARGET is defined to be equal      to 3 in the file tm_hppa.h */
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table,          to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|hpread_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols.     DESC is the file descriptor for the file, positioned at the    beginning of the symtab    SYM_OFFSET is the offset within the file of    the beginning of the symbols we want to read    SYM_SIZE is the size of the symbol info to read in.    TEXT_OFFSET is the beginning of the text segment we are reading symbols for    TEXT_SIZE is the size of the text segment read in.    SECTION_OFFSETS are the relocation offsets which get added to each symbol. */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|hpread_expand_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|sym_offset
parameter_list|,
name|int
name|sym_size
parameter_list|,
name|CORE_ADDR
name|text_offset
parameter_list|,
name|int
name|text_size
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|section_offsets
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|namestring
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
name|int
name|at_module_boundary
init|=
literal|0
decl_stmt|;
comment|/* 1 => at end, -1 => at beginning */
name|int
name|sym_index
init|=
name|sym_offset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
decl_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
literal|0
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
comment|/* Demangling style -- if EDG style already set, don't change it,      as HP style causes some problems with the KAI EDG compiler */
if|if
condition|(
name|current_demangling_style
operator|!=
name|edg_demangling
condition|)
block|{
comment|/* Otherwise, ensure that we are using HP style demangling */
name|set_demangling_style
argument_list|(
name|HP_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|sym_index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
operator|(
name|unsigned
name|char
operator|)
name|DNTT_TYPE_SRCFILE
operator|)
operator|||
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
operator|(
name|unsigned
name|char
operator|)
name|DNTT_TYPE_MODULE
operator|)
operator|)
condition|)
block|{
name|start_symtab
argument_list|(
literal|"globals"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"HP"
argument_list|)
expr_stmt|;
block|}
comment|/* The psymtab builder (hp-psymtab-read.c) is the one that    * determined the "sym_size" argument (i.e. how many DNTT symbols    * are in this symtab), which we use to compute "max_symnum"    * (point in DNTT to which we read).     *    * Perhaps this should be changed so that     * process_one_debug_symbol() "knows" when    * to stop reading (based on reading from the MODULE to the matching    * END), and take out this reliance on a #-syms being passed in...    * (I'm worried about the reliability of this number). But I'll    * leave it as-is, for now. - RT    *    * The change above has been made. I've left the "for" loop control    * in to prepare for backing this out again. -JB    */
name|max_symnum
operator|=
name|sym_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* No reason to multiply on pst side and divide on sym side... FIXME */
comment|/* Read in and process each debug symbol within the specified range.    */
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|sym_index
operator|+
name|symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
comment|/* Yow!  We call set_namestring on things without names!  */
name|set_namestring
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|hpread_process_one_debug_symbol
argument_list|(
name|dn_bufp
argument_list|,
name|namestring
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|,
name|text_offset
argument_list|,
name|text_size
argument_list|,
name|filename
argument_list|,
name|symnum
operator|+
name|sym_index
argument_list|,
operator|&
name|at_module_boundary
argument_list|)
expr_stmt|;
comment|/* OLD COMMENTS: This routine is only called for psts.  All psts        * correspond to MODULES.  If we ever do lazy-reading of globals        * from the LNTT, then there will be a pst which ends when the        * LNTT ends, and not at an END MODULE entry.  Then we'll have        * to re-visit this break.           if( at_end_of_module )        break;         */
comment|/* We no longer break out of the loop when we reach the end of a          module. The reason is that with CTTI, the compiler can generate          function symbols (for template function instantiations) which are not          in any module; typically they show up beyond a module's end, and          before the next module's start.  We include them in the current          module.  However, we still don't trust the MAX_SYMNUM value from          the psymtab, so we break out if we enter a new module. */
if|if
condition|(
name|at_module_boundary
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
name|hp_som_som_object_present
operator|=
literal|1
expr_stmt|;
comment|/* Indicate we've processed an HP SOM SOM file */
return|return
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert basic types from HP debug format into GDB internal format.  */
end_comment

begin_function
specifier|static
name|int
name|hpread_type_translate
parameter_list|(
name|dnttpointer
name|typep
parameter_list|)
block|{
if|if
condition|(
operator|!
name|typep
operator|.
name|dntti
operator|.
name|immediate
condition|)
block|{
name|error
argument_list|(
literal|"error in hpread_type_translate\n."
argument_list|)
expr_stmt|;
return|return
name|FT_VOID
return|;
block|}
switch|switch
condition|(
name|typep
operator|.
name|dntti
operator|.
name|type
condition|)
block|{
case|case
name|HP_TYPE_BOOLEAN
case|:
case|case
name|HP_TYPE_BOOLEAN_S300_COMPAT
case|:
case|case
name|HP_TYPE_BOOLEAN_VAX_COMPAT
case|:
return|return
name|FT_BOOLEAN
return|;
case|case
name|HP_TYPE_CHAR
case|:
comment|/* C signed char, C++ plain char */
case|case
name|HP_TYPE_WIDE_CHAR
case|:
return|return
name|FT_CHAR
return|;
case|case
name|HP_TYPE_INT
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_SIGNED_CHAR
return|;
comment|/* C++ signed char */
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_INTEGER
return|;
return|return
name|FT_LONG_LONG
return|;
case|case
name|HP_TYPE_LONG
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_SIGNED_CHAR
return|;
comment|/* C++ signed char. */
return|return
name|FT_LONG
return|;
case|case
name|HP_TYPE_UNSIGNED_LONG
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_UNSIGNED_CHAR
return|;
comment|/* C/C++ unsigned char */
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_UNSIGNED_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_UNSIGNED_LONG
return|;
return|return
name|FT_UNSIGNED_LONG_LONG
return|;
case|case
name|HP_TYPE_UNSIGNED_INT
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_UNSIGNED_CHAR
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_UNSIGNED_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_UNSIGNED_INTEGER
return|;
return|return
name|FT_UNSIGNED_LONG_LONG
return|;
case|case
name|HP_TYPE_REAL
case|:
case|case
name|HP_TYPE_REAL_3000
case|:
case|case
name|HP_TYPE_DOUBLE
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|64
condition|)
return|return
name|FT_DBL_PREC_FLOAT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|128
condition|)
return|return
name|FT_EXT_PREC_FLOAT
return|;
return|return
name|FT_FLOAT
return|;
case|case
name|HP_TYPE_COMPLEX
case|:
case|case
name|HP_TYPE_COMPLEXS3000
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|128
condition|)
return|return
name|FT_DBL_PREC_COMPLEX
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|192
condition|)
return|return
name|FT_EXT_PREC_COMPLEX
return|;
return|return
name|FT_COMPLEX
return|;
case|case
name|HP_TYPE_VOID
case|:
return|return
name|FT_VOID
return|;
case|case
name|HP_TYPE_STRING200
case|:
case|case
name|HP_TYPE_LONGSTRING200
case|:
case|case
name|HP_TYPE_FTN_STRING_SPEC
case|:
case|case
name|HP_TYPE_MOD_STRING_SPEC
case|:
case|case
name|HP_TYPE_MOD_STRING_3000
case|:
case|case
name|HP_TYPE_FTN_STRING_S300_COMPAT
case|:
case|case
name|HP_TYPE_FTN_STRING_VAX_COMPAT
case|:
return|return
name|FT_STRING
return|;
case|case
name|HP_TYPE_TEMPLATE_ARG
case|:
return|return
name|FT_TEMPLATE_ARG
return|;
case|case
name|HP_TYPE_TEXT
case|:
case|case
name|HP_TYPE_FLABEL
case|:
case|case
name|HP_TYPE_PACKED_DECIMAL
case|:
case|case
name|HP_TYPE_ANYPOINTER
case|:
case|case
name|HP_TYPE_GLOBAL_ANYPOINTER
case|:
case|case
name|HP_TYPE_LOCAL_ANYPOINTER
case|:
default|default:
name|warning
argument_list|(
literal|"hpread_type_translate: unhandled type code.\n"
argument_list|)
expr_stmt|;
return|return
name|FT_VOID
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a position in the DNTT, return a pointer to the   * already-built "struct type" (if any), for the type defined   * at that position.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|hpread_lookup_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|unsigned
name|old_len
decl_stmt|;
name|int
name|index
init|=
name|hp_type
operator|.
name|dnttp
operator|.
name|index
decl_stmt|;
name|int
name|size_changed
init|=
literal|0
decl_stmt|;
comment|/* The immediate flag indicates this doesn't actually point to    * a type DNTT.    */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|immediate
condition|)
return|return
name|NULL
return|;
comment|/* For each objfile, we maintain a "type vector".    * This an array of "struct type *"'s with one pointer per DNTT index.    * Given a DNTT index, we look in this array to see if we have    * already processed this DNTT and if it is a type definition.    * If so, then we can locate a pointer to the already-built    * "struct type", and not build it again.    *     * The need for this arises because our DNTT-walking code wanders    * around. In particular, it will encounter the same type multiple    * times (once for each object of that type). We don't want to     * built multiple "struct type"'s for the same thing.    *    * Having said this, I should point out that this type-vector is    * an expensive way to keep track of this. If most DNTT entries are     * 3 words, the type-vector will be 1/3 the size of the DNTT itself.    * Alternative solutions:    * - Keep a compressed or hashed table. Less memory, but more expensive    *   to search and update.    * - (Suggested by JB): Overwrite the DNTT entry itself    *   with the info. Create a new type code "ALREADY_BUILT", and modify    *   the DNTT to have that type code and point to the already-built entry.    * -RT    */
if|if
condition|(
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|old_len
operator|=
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* See if we need to allocate a type-vector. */
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
block|{
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if we need to resize type-vector. With my change to 	   * initially allocate a correct-size type-vector, this code 	   * should no longer trigger. 	   */
while|while
condition|(
name|index
operator|>=
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*=
literal|2
expr_stmt|;
name|size_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size_changed
condition|)
block|{
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmrealloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
argument_list|,
operator|(
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|DNTT_TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|&
name|DNTT_TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|index
index|]
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Possibly allocate a GDB internal type so we can internalize HP_TYPE.    Note we'll just return the address of a GDB internal type if we already    have it lying around.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_alloc_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
name|type_addr
operator|=
name|hpread_lookup_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type_addr
operator|==
literal|0
condition|)
block|{
operator|*
name|type_addr
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* A hack - if we really are a C++ class symbol, then this default        * will get overriden later on.        */
name|TYPE_CPLUS_SPECIFIC
argument_list|(
operator|*
name|type_addr
argument_list|)
operator|=
operator|(
expr|struct
name|cplus_struct_type
operator|*
operator|)
operator|&
name|cplus_struct_default
expr_stmt|;
block|}
return|return
operator|*
name|type_addr
return|;
block|}
end_function

begin_comment
comment|/* Read a native enumerated type and return it in GDB internal form.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_enum_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|,
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|,
name|nsyms
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|mem
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|memp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Allocate a GDB type. If we've already read in this enum type,    * it'll return the already built GDB type, so stop here.    * (Note: I added this check, to conform with what's done for     *  struct, union, class.    *  I assume this is OK. - RT)    */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
return|return
name|type
return|;
comment|/* HP C supports "sized enums", where a specifier such as "short" or      "char" can be used to get enums of different sizes. So don't assume      an enum is always 4 bytes long. pai/1997-08-21 */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|denum
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
comment|/* Get a name for each member and add it to our list of members.      * The list of "mem" SOM records we are walking should all be    * SOM type DNTT_TYPE_MEMENUM (not checked).    */
name|mem
operator|=
name|dn_bufp
operator|->
name|denum
operator|.
name|firstmem
expr_stmt|;
while|while
condition|(
name|mem
operator|.
name|word
operator|&&
name|mem
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|memp
operator|=
name|hpread_get_lntt
argument_list|(
name|mem
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|memp
operator|->
name|dmember
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|memp
operator|->
name|dmember
operator|.
name|value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|mem
operator|=
name|memp
operator|->
name|dmember
operator|.
name|nextmem
expr_stmt|;
block|}
comment|/* Now that we know more about the enum, fill in more info.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the members and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.       Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read and internalize a native function debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_function_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|newblock
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|type1
decl_stmt|;
name|struct
name|pending
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|param
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|paramp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|record_args
init|=
literal|1
decl_stmt|;
comment|/* See if we've already read in this type.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|record_args
operator|=
literal|0
expr_stmt|;
comment|/* already read in, don't modify type */
block|}
else|else
block|{
comment|/* Nope, so read it in and store it away.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTYPE
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunctype
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* expect DNTT_TYPE_FUNC_TEMPLATE */
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunc_template
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|replace_type
argument_list|(
name|type
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* Mark it -- in the middle of processing */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
comment|/* Now examine each parameter noting its type, location, and a      wealth of other information.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|firstparam
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTYPE
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|dfunctype
operator|.
name|firstparam
expr_stmt|;
else|else
comment|/* expect DNTT_TYPE_FUNC_TEMPLATE */
name|param
operator|=
name|dn_bufp
operator|->
name|dfunc_template
operator|.
name|firstparam
expr_stmt|;
while|while
condition|(
name|param
operator|.
name|word
operator|&&
name|param
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|paramp
operator|=
name|hpread_get_lntt
argument_list|(
name|param
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|param
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|nextparam
expr_stmt|;
comment|/* Get the name.  */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|paramp
operator|->
name|dfparam
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
comment|/* Figure out where it lives.  */
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|regparam
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
elseif|else
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|indirect
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|copyparam
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is likely a pass-by-invisible reference parameter, 	     Hack on the symbol class to make GDB happy.  */
comment|/* ??rehrauer: This appears to be broken w/r/t to passing 	     C values of type float and struct.  Perhaps this ought 	     to be highighted as a special case, but for now, just 	     allowing these to be LOC_ARGs seems to work fine. 	   */
if|#
directive|if
literal|0
block|SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
endif|#
directive|endif
block|}
else|else
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
comment|/* Get its type.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|paramp
operator|->
name|dfparam
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Add it to the symbol list.  */
comment|/* Note 1 (RT) At the moment, add_symbol_to_list() is also being        * called on FPARAM symbols from the process_one_debug_symbol()        * level... so parameters are getting added twice! (this shows        * up in the symbol dump you get from "maint print symbols ...").        * Note 2 (RT) I took out the processing of FPARAM from the         * process_one_debug_symbol() level, so at the moment parameters are only        * being processed here. This seems to have no ill effect.        */
comment|/* Note 3 (pai/1997-08-11) I removed the add_symbol_to_list() which put          each fparam on the local_symbols list from here.  Now we use the          local_list to which fparams are added below, and set the param_symbols          global to point to that at the end of this routine. */
comment|/* elz: I added this new list of symbols which is local to the function.          this list is the one which is actually used to build the type for the          function rather than the gloabal list pointed to by symlist.          Using a global list to keep track of the parameters is wrong, because           this function is called recursively if one parameter happend to be          a function itself with more parameters in it. Adding parameters to the          same global symbol list would not work!                Actually it did work in case of cc compiled programs where you do           not check the parameter lists of the arguments. */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_list
argument_list|)
expr_stmt|;
block|}
comment|/* If type was read in earlier, don't bother with modifying      the type struct */
if|if
condition|(
operator|!
name|record_args
condition|)
goto|goto
name|finish
goto|;
comment|/* Note how many parameters we found.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the parameters and       use them to fill parameter-type information into the function-type.      The parameter symbols can be found in the local_list that we just put them on. */
comment|/* Note that we preserve the order of the parameters, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
comment|/* get the parameters types from the local list not the global list      so that the type can be correctly constructed for functions which      have function as parameters */
for|for
control|(
name|syms
operator|=
name|local_list
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Mark it as having been processed */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
operator|(
name|TYPE_FLAG_INCOMPLETE
operator|)
expr_stmt|;
comment|/* Check whether we need to fix-up a class type with this function's type */
if|if
condition|(
name|fixup_class
operator|&&
operator|(
name|fixup_method
operator|==
name|type
operator|)
condition|)
block|{
name|fixup_class_method_type
argument_list|(
name|fixup_class
argument_list|,
name|fixup_method
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|NULL
expr_stmt|;
name|fixup_method
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set the param list of this level of the context stack      to our local list.  Do this only if this function was      called for creating a new block, and not if it was called      simply to get the function type. This prevents recursive      invocations from trashing param_symbols. */
name|finish
label|:
if|if
condition|(
name|newblock
condition|)
name|param_symbols
operator|=
name|local_list
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read and internalize a native DOC function debug symbol.  */
end_comment

begin_comment
comment|/* This is almost identical to hpread_read_function_type(), except  * for references to dn_bufp->ddocfunc instead of db_bufp->dfunc.  * Since debug information for DOC functions is more likely to be  * volatile, please leave it this way.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_doc_function_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|newblock
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|dnttpointer
name|param
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|paramp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|record_args
init|=
literal|1
decl_stmt|;
comment|/* See if we've already read in this type.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|record_args
operator|=
literal|0
expr_stmt|;
comment|/* already read in, don't modify type */
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|type1
init|=
name|NULL
decl_stmt|;
comment|/* Nope, so read it in and store it away.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-03-29: Oh, no not again.  TYPE1 is          potentially left undefined here.  Assert it isn't and hope          the assert never fails ...  */
name|gdb_assert
argument_list|(
name|type1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|replace_type
argument_list|(
name|type
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* Mark it -- in the middle of processing */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
comment|/* Now examine each parameter noting its type, location, and a      wealth of other information.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|firstparam
expr_stmt|;
while|while
condition|(
name|param
operator|.
name|word
operator|&&
name|param
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|paramp
operator|=
name|hpread_get_lntt
argument_list|(
name|param
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|param
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|nextparam
expr_stmt|;
comment|/* Get the name.  */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|paramp
operator|->
name|dfparam
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* Figure out where it lives.  */
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|regparam
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
elseif|else
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|indirect
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|copyparam
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is likely a pass-by-invisible reference parameter, 	     Hack on the symbol class to make GDB happy.  */
comment|/* ??rehrauer: This appears to be broken w/r/t to passing 	     C values of type float and struct.  Perhaps this ought 	     to be highighted as a special case, but for now, just 	     allowing these to be LOC_ARGs seems to work fine. 	   */
if|#
directive|if
literal|0
block|SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
endif|#
directive|endif
block|}
else|else
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
comment|/* Get its type.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|paramp
operator|->
name|dfparam
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Add it to the symbol list.  */
comment|/* Note 1 (RT) At the moment, add_symbol_to_list() is also being        * called on FPARAM symbols from the process_one_debug_symbol()        * level... so parameters are getting added twice! (this shows        * up in the symbol dump you get from "maint print symbols ...").        * Note 2 (RT) I took out the processing of FPARAM from the         * process_one_debug_symbol() level, so at the moment parameters are only        * being processed here. This seems to have no ill effect.        */
comment|/* Note 3 (pai/1997-08-11) I removed the add_symbol_to_list() which put          each fparam on the local_symbols list from here.  Now we use the          local_list to which fparams are added below, and set the param_symbols          global to point to that at the end of this routine. */
comment|/* elz: I added this new list of symbols which is local to the function.          this list is the one which is actually used to build the type for the          function rather than the gloabal list pointed to by symlist.          Using a global list to keep track of the parameters is wrong, because           this function is called recursively if one parameter happend to be          a function itself with more parameters in it. Adding parameters to the          same global symbol list would not work!                Actually it did work in case of cc compiled programs where you do not check the          parameter lists of the arguments.  */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_list
argument_list|)
expr_stmt|;
block|}
comment|/* If type was read in earlier, don't bother with modifying      the type struct */
if|if
condition|(
operator|!
name|record_args
condition|)
goto|goto
name|finish
goto|;
comment|/* Note how many parameters we found.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the parameters and       use them to fill parameter-type information into the function-type.      The parameter symbols can be found in the local_list that we just put them on. */
comment|/* Note that we preserve the order of the parameters, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
comment|/* get the parameters types from the local list not the global list      so that the type can be correctly constructed for functions which      have function as parameters    */
for|for
control|(
name|syms
operator|=
name|local_list
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_STATIC_KIND
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Mark it as having been processed */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
operator|(
name|TYPE_FLAG_INCOMPLETE
operator|)
expr_stmt|;
comment|/* Check whether we need to fix-up a class type with this function's type */
if|if
condition|(
name|fixup_class
operator|&&
operator|(
name|fixup_method
operator|==
name|type
operator|)
condition|)
block|{
name|fixup_class_method_type
argument_list|(
name|fixup_class
argument_list|,
name|fixup_method
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|NULL
expr_stmt|;
name|fixup_method
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set the param list of this level of the context stack      to our local list.  Do this only if this function was      called for creating a new block, and not if it was called      simply to get the function type. This prevents recursive      invocations from trashing param_symbols. */
name|finish
label|:
if|if
condition|(
name|newblock
condition|)
name|param_symbols
operator|=
name|local_list
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A file-level variable which keeps track of the current-template  * being processed. Set in hpread_read_struct_type() while processing  * a template type. Referred to in hpread_get_nth_templ_arg().  * Yes, this is a kludge, but it arises from the kludge that already  * exists in symtab.h, namely the fact that they encode  * "template argument n" with fundamental type FT_TEMPLATE_ARG and  * bitlength n. This means that deep in processing fundamental types  * I need to ask the question "what template am I in the middle of?".  * The alternative to stuffing a global would be to pass an argument  * down the chain of calls just for this purpose.  *   * There may be problems handling nested templates... tough.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|current_template
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in and internalize a structure definition.    * This same routine is called for struct, union, and class types.  * Also called for templates, since they build a very similar  * type entry as for class types.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_struct_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* The data members get linked together into a list of struct nextfield's */
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
name|unsigned
name|char
name|attributes
decl_stmt|;
comment|/* store visibility and virtuality info */
define|#
directive|define
name|ATTR_VIRTUAL
value|1
define|#
directive|define
name|ATTR_PRIVATE
value|2
define|#
directive|define
name|ATTR_PROTECT
value|3
block|}
struct|;
comment|/* The methods get linked together into a list of struct next_fn_field's */
struct|struct
name|next_fn_field
block|{
name|struct
name|next_fn_field
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|field
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
name|int
name|num_fn_fields
decl_stmt|;
block|}
struct|;
comment|/* The template args get linked together into a list of struct next_template's */
struct|struct
name|next_template
block|{
name|struct
name|next_template
modifier|*
name|next
decl_stmt|;
name|struct
name|template_arg
name|arg
decl_stmt|;
block|}
struct|;
comment|/* The template instantiations get linked together into a list of these... */
struct|struct
name|next_instantiation
block|{
name|struct
name|next_instantiation
modifier|*
name|next
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
block|}
struct|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|,
modifier|*
name|tmp_list
init|=
literal|0
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_list
init|=
literal|0
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_p
decl_stmt|;
name|struct
name|next_template
modifier|*
name|t_new
decl_stmt|,
modifier|*
name|t_list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_new
decl_stmt|;
name|struct
name|next_instantiation
modifier|*
name|i_new
decl_stmt|,
modifier|*
name|i_list
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nfields
init|=
literal|0
decl_stmt|,
name|n_fn_fields
init|=
literal|0
decl_stmt|,
name|n_fn_fields_total
init|=
literal|0
decl_stmt|;
name|int
name|n_base_classes
init|=
literal|0
decl_stmt|,
name|n_templ_args
init|=
literal|0
decl_stmt|;
name|int
name|ninstantiations
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|field
decl_stmt|,
name|fn_field
decl_stmt|,
name|parent
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|fieldp
decl_stmt|,
modifier|*
name|fn_fieldp
decl_stmt|,
modifier|*
name|parentp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|static_member
init|=
literal|0
decl_stmt|;
name|int
name|const_member
init|=
literal|0
decl_stmt|;
name|int
name|volatile_member
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|vtbl_offset
decl_stmt|;
name|int
name|need_bitvectors
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|method_alias
init|=
name|NULL
decl_stmt|;
comment|/* Is it something we've already dealt with?  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE
operator|)
condition|)
return|return
name|type
return|;
comment|/* Get the basic type correct.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dstruct
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dunion
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_CLASS
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
comment|/* Overrides the TYPE_CPLUS_SPECIFIC(type) with allocated memory        * rather than&cplus_struct_default.        */
name|allocate_cplus_struct_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Fill in declared-type.        * (The C++ compiler will emit TYPE_CODE_CLASS         * for all 3 of "class", "struct"        * "union", and we have to look at the "class_decl" field if we        * want to know how it was really declared)        */
comment|/* (0==class, 1==union, 2==struct) */
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
comment|/* Get the basic type correct.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TEMPLATE
expr_stmt|;
name|allocate_cplus_struct_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|DECLARED_TYPE_TEMPLATE
expr_stmt|;
block|}
else|else
return|return
name|type
return|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
comment|/* For classes, read the parent list.    * Question (RT): Do we need to do this for templates also?    */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
comment|/* First read the parent-list (classes from which we derive fields) */
name|parent
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|parentlist
expr_stmt|;
while|while
condition|(
name|parent
operator|.
name|word
operator|&&
name|parent
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|parentp
operator|=
name|hpread_get_lntt
argument_list|(
name|parent
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* "parentp" should point to a DNTT_TYPE_INHERITANCE record */
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_STATIC_KIND
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The "classname" field is actually a DNTT pointer to the base class */
name|baseclass
operator|=
name|hpread_type_lookup
argument_list|(
name|parentp
operator|->
name|dinheritance
operator|.
name|classname
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|baseclass
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* Check for virtuality of base, and set the 	   * offset of the base subobject within the object. 	   * (Offset set to -1 for virtual bases (for now).) 	   */
if|if
condition|(
name|parentp
operator|->
name|dinheritance
operator|.
name|Virtual
condition|)
block|{
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_VIRTUAL
argument_list|)
expr_stmt|;
name|parentp
operator|->
name|dinheritance
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|parentp
operator|->
name|dinheritance
operator|.
name|offset
expr_stmt|;
comment|/* Check visibility */
switch|switch
condition|(
name|parentp
operator|->
name|dinheritance
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|n_base_classes
operator|++
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
name|parent
operator|=
name|parentp
operator|->
name|dinheritance
operator|.
name|next
expr_stmt|;
block|}
block|}
comment|/* For templates, read the template argument list.    * This must be done before processing the member list, because    * the member list may refer back to this. E.g.:    *   template<class T1, class T2> class q2 {    *     public:    *     T1 a;    *     T2 b;    *   };    * We need to read the argument list "T1", "T2" first.    */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
comment|/* Kludge alert: This stuffs a global "current_template" which        * is referred to by hpread_get_nth_templ_arg(). The global        * is cleared at the end of this routine.        */
name|current_template
operator|=
name|type
expr_stmt|;
comment|/* Read in the argument list */
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|arglist
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
comment|/* Get this template argument */
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_TEMPLATE_ARG
condition|)
block|{
name|warning
argument_list|(
literal|"Invalid debug info: Template argument entry is of wrong kind"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Bump the count */
name|n_templ_args
operator|++
expr_stmt|;
comment|/* Allocate and fill in a struct next_template */
name|t_new
operator|=
operator|(
expr|struct
name|next_template
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_template
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t_new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_template
argument_list|)
argument_list|)
expr_stmt|;
name|t_new
operator|->
name|next
operator|=
name|t_list
expr_stmt|;
name|t_list
operator|=
name|t_new
expr_stmt|;
name|t_list
operator|->
name|arg
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fieldp
operator|->
name|dtempl_arg
operator|.
name|name
expr_stmt|;
name|t_list
operator|->
name|arg
operator|.
name|type
operator|=
name|hpread_read_templ_arg_type
argument_list|(
name|field
argument_list|,
name|fieldp
argument_list|,
name|objfile
argument_list|,
name|t_list
operator|->
name|arg
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Walk to the next template argument */
name|field
operator|=
name|fieldp
operator|->
name|dtempl_arg
operator|.
name|nextarg
expr_stmt|;
block|}
block|}
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|=
name|n_templ_args
expr_stmt|;
if|if
condition|(
name|n_templ_args
operator|>
literal|0
condition|)
name|TYPE_TEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|template_arg
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_arg
argument_list|)
operator|*
name|n_templ_args
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n_templ_args
init|;
name|t_list
condition|;
name|t_list
operator|=
name|t_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_TEMPLATE_ARG
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|t_list
operator|->
name|arg
expr_stmt|;
block|}
comment|/* Next read in and internalize all the fields/members.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dstruct
operator|.
name|firstfield
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dunion
operator|.
name|firstfield
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|memberlist
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|memberlist
expr_stmt|;
else|else
name|field
operator|.
name|word
operator|=
name|DNTTNIL
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* At this point "fieldp" may point to either a DNTT_TYPE_FIELD        * or a DNTT_TYPE_GENFIELD record.         */
name|vtbl_offset
operator|=
literal|0
expr_stmt|;
name|static_member
operator|=
literal|0
expr_stmt|;
name|const_member
operator|=
literal|0
expr_stmt|;
name|volatile_member
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_GENFIELD
condition|)
block|{
comment|/* The type will be GENFIELD if the field is a method or 	   * a static member (or some other cases -- see below) 	   */
comment|/* Follow a link to get to the record for the field. */
name|fn_field
operator|=
name|fieldp
operator|->
name|dgenfield
operator|.
name|field
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Virtual funcs are indicated by a VFUNC which points to the 	   * real entry 	   */
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_VFUNC
condition|)
block|{
name|vtbl_offset
operator|=
name|fn_fieldp
operator|->
name|dvfunc
operator|.
name|vtbl_offset
expr_stmt|;
name|fn_field
operator|=
name|fn_fieldp
operator|->
name|dvfunc
operator|.
name|funcptr
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* A function's entry may be preceded by a modifier which 	   * labels it static/constant/volatile. 	   */
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MODIFIER
condition|)
block|{
name|static_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_static
expr_stmt|;
name|const_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_const
expr_stmt|;
name|volatile_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_volatile
expr_stmt|;
name|fn_field
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|type
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether we have a method */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|)
condition|)
block|{
comment|/* Method found */
name|short
name|ix
init|=
literal|0
decl_stmt|;
comment|/* Look up function type of method */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_field
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Methods can be seen before classes in the SOM records. 	         If we are processing this class because it's a parameter of a 	         method, at this point the method's type is actually incomplete; 	         we'll have to fix it up later; mark the class for this. */
if|if
condition|(
name|TYPE_INCOMPLETE
argument_list|(
name|memtype
argument_list|)
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|fixup_class
condition|)
name|warning
argument_list|(
literal|"Two classes to fix up for method??  Type information may be incorrect for some classes."
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup_method
condition|)
name|warning
argument_list|(
literal|"Two methods to be fixed up at once?? Type information may be incorrect for some classes."
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|type
expr_stmt|;
comment|/* remember this class has to be fixed up */
name|fixup_method
operator|=
name|memtype
expr_stmt|;
comment|/* remember the method type to be used in fixup */
block|}
comment|/* HP aCC generates operator names without the "operator" keyword, and 	         generates null strings as names for operators that are  	         user-defined type conversions to basic types (e.g. operator int ()). 	         So try to reconstruct name as best as possible. */
name|method_name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|name
operator|)
expr_stmt|;
name|method_alias
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|alias
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_name
operator|||
comment|/* no name */
operator|!
operator|*
name|method_name
operator|||
comment|/* or null name */
name|cplus_mangle_opname
argument_list|(
name|method_name
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
comment|/* or name is an operator like "<" */
block|{
name|char
modifier|*
name|tmp_name
init|=
name|cplus_demangle
argument_list|(
name|method_alias
argument_list|,
name|DMGL_ANSI
argument_list|)
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|strstr
argument_list|(
name|tmp_name
argument_list|,
literal|"operator"
argument_list|)
decl_stmt|;
name|method_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* don't overwrite VT! */
name|strcpy
argument_list|(
name|method_name
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
block|}
comment|/* First check if a method of the same name has already been seen. */
name|fn_p
operator|=
name|fn_list
expr_stmt|;
while|while
condition|(
name|fn_p
condition|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|fn_p
operator|->
name|field
operator|.
name|name
argument_list|,
name|method_name
argument_list|)
condition|)
break|break;
name|fn_p
operator|=
name|fn_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* If no such method was found, allocate a new entry in the list */
if|if
condition|(
operator|!
name|fn_p
condition|)
block|{
comment|/* Get space to record this member function */
comment|/* Note: alloca used; this will disappear on routine exit */
name|fn_new
operator|=
operator|(
expr|struct
name|next_fn_field
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fn_field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fn_new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fn_field
argument_list|)
argument_list|)
expr_stmt|;
name|fn_new
operator|->
name|next
operator|=
name|fn_list
expr_stmt|;
name|fn_list
operator|=
name|fn_new
expr_stmt|;
comment|/* Fill in the fields of the struct nextfield */
comment|/* Record the (unmangled) method name */
name|fn_list
operator|->
name|field
operator|.
name|name
operator|=
name|method_name
expr_stmt|;
comment|/* Initial space for overloaded methods */
comment|/* Note: xmalloc is used; this will persist after this routine exits */
name|fn_list
operator|->
name|field
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fn_list
operator|->
name|field
operator|.
name|length
operator|=
literal|1
expr_stmt|;
comment|/* Init # of overloaded instances */
name|fn_list
operator|->
name|num_fn_fields
operator|=
literal|5
expr_stmt|;
comment|/* # of entries for which space allocated */
name|fn_p
operator|=
name|fn_list
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
comment|/* array index for fn_field */
comment|/* Bump the total count of the distinctly named methods */
name|n_fn_fields
operator|++
expr_stmt|;
block|}
else|else
comment|/* Another overloaded instance of an already seen method name */
block|{
if|if
condition|(
operator|++
operator|(
name|fn_p
operator|->
name|field
operator|.
name|length
operator|)
operator|>
name|fn_p
operator|->
name|num_fn_fields
condition|)
block|{
comment|/* Increase space allocated for overloaded instances */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
argument_list|,
operator|(
name|fn_p
operator|->
name|num_fn_fields
operator|+
literal|5
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
argument_list|)
expr_stmt|;
name|fn_p
operator|->
name|num_fn_fields
operator|+=
literal|5
expr_stmt|;
block|}
name|ix
operator|=
name|fn_p
operator|->
name|field
operator|.
name|length
operator|-
literal|1
expr_stmt|;
comment|/* array index for fn_field */
block|}
comment|/* "physname" is intended to be the name of this overloaded instance. */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|method_alias
operator|&&
operator|*
name|method_alias
condition|)
comment|/* not a null string */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|physname
operator|=
name|method_alias
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|physname
operator|=
name|method_name
expr_stmt|;
comment|/* What's expected here is the function type */
comment|/* But mark it as NULL if the method was incompletely processed 	         We'll fix this up later when the method is fully processed */
if|if
condition|(
name|TYPE_INCOMPLETE
argument_list|(
name|memtype
argument_list|)
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|=
name|NULL
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
comment|/* For virtual functions, fill in the voffset field with the 	       * virtual table offset. (This is just copied over from the 	       * SOM record; not sure if it is what GDB expects here...). 	       * But if the function is a static method, set it to 1. 	       *  	       * Note that we have to add 1 because 1 indicates a static 	       * method, and 0 indicates a non-static, non-virtual method */
if|if
condition|(
name|static_member
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|voffset
operator|=
name|vtbl_offset
condition|?
name|vtbl_offset
operator|+
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Also fill in the fcontext field with the current 	       * class. (The latter isn't quite right: should be the baseclass 	       * that defines the virtual function... Note we do have 	       * a variable "baseclass" that we could stuff into the fcontext 	       * field, but "baseclass" isn't necessarily right either, 	       * since the virtual function could have been defined more 	       * than one level up). 	       */
if|if
condition|(
name|vtbl_offset
operator|!=
literal|0
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|fcontext
operator|=
name|type
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|fcontext
operator|=
name|NULL
expr_stmt|;
comment|/* Other random fields pertaining to this method */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_const
operator|=
name|const_member
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_volatile
operator|=
name|volatile_member
expr_stmt|;
comment|/* ?? */
switch|switch
condition|(
name|fieldp
operator|->
name|dgenfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|1
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* public */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|0
expr_stmt|;
block|}
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_stub
operator|=
literal|0
expr_stmt|;
comment|/* HP aCC emits both MEMFUNC and FUNCTION entries for a method; 	         if the class points to the FUNCTION, there is usually separate 	         code for the method; but if we have a MEMFUNC, the method has 	         been inlined (and there is usually no FUNCTION entry) 	         FIXME Not sure if this test is accurate. pai/1997-08-22 */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
operator|)
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_inlined
operator|=
literal|1
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_inlined
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|dummy
operator|=
literal|0
expr_stmt|;
comment|/* Bump the total count of the member functions */
name|n_fn_fields_total
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
block|{
comment|/* This case is for static data members of classes */
comment|/* pai:: FIXME -- check that "staticmem" bit is set */
comment|/* Get space to record this static member */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|name
expr_stmt|;
name|SET_FIELD_PHYSNAME
argument_list|(
name|list
operator|->
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize to empty */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fieldp
operator|->
name|dgenfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FIELD
condition|)
block|{
comment|/* FIELDs follow GENFIELDs for fields of anonymous unions. 	         Code below is replicated from the case for FIELDs further 	         below, except that fieldp is replaced by fn_fieldp */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|dfield
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: FIELD of anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
if|if
condition|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitlength
operator|%
literal|8
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitlength
expr_stmt|;
else|else
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
block|{
comment|/* Field of anonymous union; union is not inside a class */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: SVAR field in anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* FIXME is this always true? */
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* use length from type */
name|FIELD_STATIC_KIND
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* No info to set visibility -- always public */
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
condition|)
block|{
comment|/* Field of anonymous union; union is not inside a class */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: DVAR field in anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* FIXME is this always true? */
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* use length from type */
name|FIELD_STATIC_KIND
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* No info to set visibility -- always public */
name|nfields
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a method, nor a static data member, nor an anon union field */
comment|/* This case is for miscellaneous type entries (local enums, 	         local function templates, etc.) that can be present 	         inside a class. */
comment|/* Enums -- will be handled by other code that takes care 	         of DNTT_TYPE_ENUM; here we see only DNTT_TYPE_MEMENUM so 	         it's not clear we could have handled them here at all. */
comment|/* FUNC_TEMPLATE: is handled by other code (?). */
comment|/* MEMACCESS: modified access for inherited member. Not 	         sure what to do with this, ignoriing it at present. */
comment|/* What other entries can appear following a GENFIELD which 	         we do not handle above?  (MODIFIER, VFUNC handled above.) */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_MEMACCESS
operator|)
operator|&&
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_MEMENUM
operator|)
operator|&&
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_FUNC_TEMPLATE
operator|)
condition|)
name|warning
argument_list|(
literal|"Internal error: Unexpected debug record kind %d found following DNTT_GENFIELD"
argument_list|,
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
argument_list|)
expr_stmt|;
block|}
comment|/* walk to the next FIELD or GENFIELD */
name|field
operator|=
name|fieldp
operator|->
name|dgenfield
operator|.
name|nextfield
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FIELD
condition|)
block|{
comment|/* Ordinary structure/union/class field */
name|struct
name|type
modifier|*
name|anon_union_type
decl_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fieldp
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
comment|/* A FIELD by itself (without a GENFIELD) can also be a static 	     member.  Mark it as static with a physname of NULL. 	     fix_static_member_physnames will assign the physname later. */
if|if
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|staticmem
condition|)
block|{
name|SET_FIELD_PHYSNAME
argument_list|(
name|list
operator|->
name|field
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Non-static data member */
block|{
name|FIELD_STATIC_KIND
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fieldp
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|bitlength
operator|%
literal|8
condition|)
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fieldp
operator|->
name|dfield
operator|.
name|bitlength
expr_stmt|;
else|else
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fieldp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
comment|/* Note 1: First, we have to check if the current field is an anonymous 	     union. If it is, then *its* fields are threaded along in the 	     nextfield chain. :-( This was supposed to help debuggers, but is 	     really just a nuisance since we deal with anonymous unions anyway by 	     checking that the name is null.  So anyway, we skip over the fields 	     of the anonymous union. pai/1997-08-22 */
comment|/* Note 2: In addition, the bitoffsets for the fields of the anon union 	     are relative to the enclosing struct, *NOT* relative to the anon 	     union!  This is an even bigger nuisance -- we have to go in and munge 	     the anon union's type information appropriately. pai/1997-08-22 */
comment|/* Both tasks noted above are done by a separate function.  This takes us 	     to the next FIELD or GENFIELD, skipping anon unions, and recursively 	     processing intermediate types. */
name|field
operator|=
name|hpread_get_next_skip_over_anon_unions
argument_list|(
literal|1
argument_list|,
name|field
argument_list|,
operator|&
name|fieldp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* neither field nor genfield ?? is this possible?? */
comment|/* pai:: FIXME walk to the next -- how? */
name|warning
argument_list|(
literal|"Internal error: unexpected DNTT kind %d encountered as field of struct"
argument_list|,
name|fieldp
operator|->
name|dblock
operator|.
name|kind
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Skipping remaining fields of struct"
argument_list|)
expr_stmt|;
break|break;
comment|/* get out of loop of fields */
block|}
block|}
comment|/* If it's a template, read in the instantiation list */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|ninstantiations
operator|=
literal|0
expr_stmt|;
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|expansions
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The expansions or nextexp should point to a tagdef */
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_TAGDEF
condition|)
break|break;
name|i_new
operator|=
operator|(
expr|struct
name|next_instantiation
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_instantiation
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|i_new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_instantiation
argument_list|)
argument_list|)
expr_stmt|;
name|i_new
operator|->
name|next
operator|=
name|i_list
expr_stmt|;
name|i_list
operator|=
name|i_new
expr_stmt|;
name|i_list
operator|->
name|t
operator|=
name|hpread_type_lookup
argument_list|(
name|field
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|ninstantiations
operator|++
expr_stmt|;
comment|/* And the "type" field of that should point to a class */
name|field
operator|=
name|fieldp
operator|->
name|dtag
operator|.
name|type
expr_stmt|;
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_CLASS
condition|)
break|break;
comment|/* Get the next expansion */
name|field
operator|=
name|fieldp
operator|->
name|dclass
operator|.
name|nextexp
expr_stmt|;
block|}
block|}
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|=
name|ninstantiations
expr_stmt|;
if|if
condition|(
name|ninstantiations
operator|>
literal|0
condition|)
name|TYPE_INSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
name|ninstantiations
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ninstantiations
init|;
name|i_list
condition|;
name|i_list
operator|=
name|i_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_INSTANTIATION
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|i_list
operator|->
name|t
expr_stmt|;
block|}
comment|/* Copy the field-list to GDB's symbol table */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|n_base_classes
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
operator|,
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|tmp_list
operator|->
name|field
expr_stmt|;
block|}
comment|/* Copy the "function-field-list" (i.e., the list of member    * functions in the class) to GDB's symbol table     */
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|n_fn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|n_fn_fields_total
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|n_fn_fields
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n_fn_fields
init|;
name|fn_list
condition|;
name|fn_list
operator|=
name|fn_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_FN_FIELDLIST
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|fn_list
operator|->
name|field
expr_stmt|;
block|}
comment|/* pai:: FIXME -- perhaps each bitvector should be created individually */
for|for
control|(
name|n
operator|=
name|nfields
operator|,
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp_list
operator|->
name|attributes
condition|)
block|{
name|need_bitvectors
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|need_bitvectors
condition|)
block|{
comment|/* pai:: this step probably redundant */
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
comment|/* this field vector isn't actually used with HP aCC */
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_VIRTUAL
argument_list|)
condition|)
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
condition|)
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|has_vtable
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Allocate space for class runtime information */
name|TYPE_RUNTIME_PTR
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|runtime_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|runtime_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set flag for vtable */
name|TYPE_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The first non-virtual base class with a vtable. */
name|TYPE_PRIMARY_BASE
argument_list|(
name|type
argument_list|)
operator|=
name|primary_base_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The virtual base list. */
name|TYPE_VIRTUAL_BASE_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|virtual_base_list
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|TYPE_RUNTIME_PTR
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a local type (C++ - declared inside a function), record file name& line # */
if|if
condition|(
name|hpread_get_scope_depth
argument_list|(
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
comment|/* no need for real depth */
argument_list|)
condition|)
block|{
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|local_type_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|local_type_info
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_subfile
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_subfile
operator|->
name|line_vector
operator|&&
operator|(
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|>
literal|0
operator|)
condition|)
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|item
index|[
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|-
literal|1
index|]
operator|.
name|line
expr_stmt|;
else|else
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the global saying what template we are in the middle of processing */
name|current_template
operator|=
name|NULL
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Adjust the physnames for each static member of a struct    or class type to be something like "A::x"; then various    other pieces of code that do a lookup_symbol on the phyname    work correctly.    TYPE is a pointer to the struct/class type    NAME is a char * (string) which is the class/struct name    Void return */
end_comment

begin_function
specifier|static
name|void
name|fix_static_member_physnames
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|class_name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We fix the member names only for classes or structs */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
return|return;
comment|/* physnames are already set */
name|SET_FIELD_PHYSNAME
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
argument_list|,
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fix-up the type structure for a CLASS so that the type entry  * for a method (previously marked with a null type in hpread_read_struct_type()  * is set correctly to METHOD.  * OBJFILE is as for other such functions.   * Void return. */
end_comment

begin_function
specifier|static
name|void
name|fixup_class_method_type
parameter_list|(
name|struct
name|type
modifier|*
name|class
parameter_list|,
name|struct
name|type
modifier|*
name|method
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|class
operator|||
operator|!
name|method
operator|||
operator|!
name|objfile
condition|)
return|return;
comment|/* Only for types that have methods */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|class
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|class
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|)
condition|)
return|return;
comment|/* Loop over all methods and find the one marked with a NULL type */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|class
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Set the method type */
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|=
name|method
expr_stmt|;
comment|/* Break out of both loops -- only one method to fix up in a class */
goto|goto
name|finish
goto|;
block|}
name|finish
label|:
name|TYPE_FLAGS
argument_list|(
name|class
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we're in the middle of processing a template, get a pointer  * to the Nth template argument.  * An example may make this clearer:  *   template<class T1, class T2> class q2 {  *     public:  *     T1 a;  *     T2 b;  *   };  * The type for "a" will be "first template arg" and  * the type for "b" will be "second template arg".  * We need to look these up in order to fill in "a" and "b"'s type.  * This is called from hpread_type_lookup().  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_get_nth_template_arg
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|current_template
operator|!=
name|NULL
condition|)
return|return
name|TYPE_TEMPLATE_ARG
argument_list|(
name|current_template
argument_list|,
name|n
argument_list|)
operator|.
name|type
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_TEMPLATE_ARG
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a TEMPL_ARG (template arg) symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_templ_arg_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* See if it's something we've already deal with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE_ARG
condition|)
return|return
name|type
return|;
comment|/* Nope.  Fill in the appropriate fields.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TEMPLATE_ARG
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a set debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_set_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* See if it's something we've already deal with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
return|return
name|type
return|;
comment|/* Nope.  Fill in the appropriate fields.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_SET
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dset
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dset
operator|.
name|subtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize an array debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_array_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Allocate an array type symbol.    * Why no check for already-read here, like in the other    * hpread_read_xxx_type routines?  Because it kept us     * from properly determining the size of the array!      */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
comment|/* Although the hp-symtab.h does not *require* this to be the case,    * GDB is assuming that "arrayisbytes" and "elemisbytes" be consistent.    * I.e., express both array-length and element-length in bits,    * or express both array-length and element-length in bytes.    */
if|if
condition|(
operator|!
operator|(
operator|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
operator|&&
name|dn_bufp
operator|->
name|darray
operator|.
name|elemisbytes
operator|)
operator|||
operator|(
operator|!
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
operator|&&
operator|!
name|dn_bufp
operator|->
name|darray
operator|.
name|elemisbytes
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"error in hpread_array_type.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
operator|==
literal|0x7fffffff
condition|)
block|{
comment|/* The HP debug format represents char foo[]; as an array with        * length 0x7fffffff.  Internally GDB wants to represent this        *  as an array of length zero.          */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
expr_stmt|;
else|else
comment|/* arraylength is in bits */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
operator|/
literal|8
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|darray
operator|.
name|elemtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The one "field" is used to store the subscript type */
comment|/* Since C and C++ multi-dimensional arrays are simply represented    * as: array of array of ..., we only need one subscript-type    * per array. This subscript type is typically a subrange of integer.    * If this gets extended to support languages like Pascal, then    * we need to fix this to represent multi-dimensional arrays properly.    */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|darray
operator|.
name|indextype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a subrange debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_subrange_type
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Is it something we've already dealt with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
return|return
name|type
return|;
comment|/* Nope, internalize it.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|dyn_low
condition|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|lowbound
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|dyn_high
condition|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|highbound
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|subtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* struct type * hpread_type_lookup(hp_type, objfile)  *   Arguments:  *     hp_type: A pointer into the DNTT specifying what type we  *              are about to "look up"., or else [for fundamental types  *              like int, float, ...] an "immediate" structure describing  *              the type.  *     objfile: ?  *   Return value: A pointer to a "struct type" (representation of a  *                 type in GDB's internal symbol table - see gdbtypes.h)  *   Routine description:  *     There are a variety of places when scanning the DNTT when we  *     need to interpret a "type" field. The simplest and most basic   *     example is when we're processing the symbol table record  *     for a data symbol (a SVAR or DVAR record). That has  *     a "type" field specifying the type of the data symbol. That  *     "type" field is either an "immediate" type specification (for the  *     fundamental types) or a DNTT pointer (for more complicated types).   *     For the more complicated types, we may or may not have already  *     processed the pointed-to type. (Multiple data symbols can of course  *     share the same type).  *     The job of hpread_type_lookup() is to process this "type" field.  *     Most of the real work is done in subroutines. Here we interpret  *     the immediate flag. If not immediate, chase the DNTT pointer to  *     find our way to the SOM record describing the type, switch on  *     the SOM kind, and then call an appropriate subroutine depending  *     on what kind of type we are constructing. (e.g., an array type,  *     a struct/class type, etc).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_type_lookup
parameter_list|(
name|dnttpointer
name|hp_type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
comment|/* First see if it's a simple builtin type.  */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|immediate
condition|)
block|{
comment|/* If this is a template argument, the argument number is        * encoded in the bitlength. All other cases, just return        * GDB's representation of this fundamental type.        */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|type
operator|==
name|HP_TYPE_TEMPLATE_ARG
condition|)
return|return
name|hpread_get_nth_template_arg
argument_list|(
name|objfile
argument_list|,
name|hp_type
operator|.
name|dntti
operator|.
name|bitlength
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|hpread_type_translate
argument_list|(
name|hp_type
argument_list|)
argument_list|)
return|;
block|}
comment|/* Not a builtin type.  We'll have to read it in.  */
if|if
condition|(
name|hp_type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|hp_type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
comment|/* This is a fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
switch|switch
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
case|case
name|DNTT_TYPE_MODULE
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
case|case
name|DNTT_TYPE_IMPORT
case|:
case|case
name|DNTT_TYPE_LABEL
case|:
case|case
name|DNTT_TYPE_FPARAM
case|:
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_CONST
case|:
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_VARIANT
case|:
case|case
name|DNTT_TYPE_FILE
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_COBSTRUCT
case|:
case|case
name|DNTT_TYPE_XREF
case|:
case|case
name|DNTT_TYPE_SA
case|:
case|case
name|DNTT_TYPE_MACRO
case|:
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
case|case
name|DNTT_TYPE_MEMACCESS
case|:
case|case
name|DNTT_TYPE_INHERITANCE
case|:
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
comment|/* These are not types - something went wrong.  */
comment|/* This is a fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
case|case
name|DNTT_TYPE_FUNCTION
case|:
comment|/* We wind up here when dealing with class member functions         * (called from hpread_read_struct_type(), i.e. when processing        * the class definition itself).        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
return|return
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_TYPEDEF
case|:
block|{
comment|/* A typedef - chase it down by making a recursive call */
name|struct
name|type
modifier|*
name|structtype
init|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* The following came from the base hpread.c that we inherited. 	 * It is WRONG so I have commented it out. - RT 	 *...  	 char *suffix; 	 suffix = VT (objfile) + dn_bufp->dtype.name; 	 TYPE_NAME (structtype) = suffix;  	 * ... further explanation .... 	 * 	 * What we have here is a typedef pointing to a typedef. 	 * E.g., 	 * typedef int foo; 	 * typedef foo fum; 	 * 	 * What we desire to build is (these are pictures 	 * of "struct type"'s):  	 * 	 *  +---------+     +----------+     +------------+ 	 *  | typedef |     | typedef  |     | fund. type | 	 *  |     type| ->  |      type| ->  |            | 	 *  | "fum"   |     | "foo"    |     | "int"      | 	 *  +---------+     +----------+     +------------+ 	 * 	 * What this commented-out code is doing is smashing the 	 * name of pointed-to-type to be the same as the pointed-from 	 * type. So we wind up with something like: 	 * 	 *  +---------+     +----------+     +------------+ 	 *  | typedef |     | typedef  |     | fund. type | 	 *  |     type| ->  |      type| ->  |            | 	 *  | "fum"   |     | "fum"    |     | "fum"      | 	 *  +---------+     +----------+     +------------+ 	 *  	 */
return|return
name|structtype
return|;
block|}
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
comment|/* Just a little different from above.  We have to tack on 	 * an identifier of some kind (struct, union, enum, class, etc).   	 */
name|struct
name|type
modifier|*
name|structtype
init|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|suffix
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dtype
operator|.
name|name
expr_stmt|;
comment|/* Lookup the next type in the list.  It should be a structure, 	 * union, class, enum, or template type.   	 * We will need to attach that to our name.   	 */
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"error in hpread_type_lookup()."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
block|{
name|prefix
operator|=
literal|"struct "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
block|{
name|prefix
operator|=
literal|"union "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
comment|/* Further field for CLASS saying how it was really declared */
comment|/* 0==class, 1==union, 2==struct */
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|0
condition|)
name|prefix
operator|=
literal|"class "
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|1
condition|)
name|prefix
operator|=
literal|"union "
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|2
condition|)
name|prefix
operator|=
literal|"struct "
expr_stmt|;
else|else
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
condition|)
block|{
name|prefix
operator|=
literal|"enum "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|prefix
operator|=
literal|"template "
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Build the correct name.  */
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|strcpy
argument_list|(
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|strcat
argument_list|(
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|suffix
expr_stmt|;
comment|/* For classes/structs, we have to set the static member "physnames" 	   to point to strings like "Class::Member" */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|structtype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|fix_static_member_physnames
argument_list|(
name|structtype
argument_list|,
name|suffix
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|structtype
return|;
block|}
case|case
name|DNTT_TYPE_POINTER
case|:
comment|/* Pointer type - call a routine in gdbtypes.c that constructs        * the appropriate GDB type.        */
return|return
name|make_pointer_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptr
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|DNTT_TYPE_REFERENCE
case|:
comment|/* C++ reference type - call a routine in gdbtypes.c that constructs        * the appropriate GDB type.        */
return|return
name|make_reference_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dreference
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|DNTT_TYPE_ENUM
case|:
return|return
name|hpread_read_enum_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_SET
case|:
return|return
name|hpread_read_set_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_SUBRANGE
case|:
return|return
name|hpread_read_subrange_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_ARRAY
case|:
return|return
name|hpread_read_array_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_FIELD
case|:
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
comment|/* Here we want to read the function SOMs and return a         * type for it. We get here, for instance, when processing        * pointer-to-function type.        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_PTRMEM
case|:
comment|/* Declares a C++ pointer-to-data-member type.         * The "pointsto" field defines the class,        * while the "memtype" field defines the pointed-to-type.        */
block|{
name|struct
name|type
modifier|*
name|ptrmemtype
decl_stmt|;
name|struct
name|type
modifier|*
name|class_type
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|memtype
argument_list|,
name|objfile
argument_list|)
operator|,
name|class_type
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
operator|,
name|ptrmemtype
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|ptrmemtype
argument_list|,
name|class_type
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return
name|make_pointer_type
argument_list|(
name|ptrmemtype
argument_list|,
name|NULL
argument_list|)
return|;
block|}
break|break;
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
comment|/* Defines a C++ pointer-to-function-member type.         * The "pointsto" field defines the class,        * while the "memtype" field defines the pointed-to-type.        */
block|{
name|struct
name|type
modifier|*
name|ptrmemtype
decl_stmt|;
name|struct
name|type
modifier|*
name|class_type
decl_stmt|;
name|struct
name|type
modifier|*
name|functype
decl_stmt|;
name|struct
name|type
modifier|*
name|retvaltype
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|class_type
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|functype
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|memtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|retvaltype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|functype
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TYPE_NFIELDS
argument_list|(
name|functype
argument_list|)
expr_stmt|;
name|ptrmemtype
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|ptrmemtype
argument_list|,
name|class_type
argument_list|,
name|retvaltype
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|functype
argument_list|)
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|functype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_pointer_type
argument_list|(
name|ptrmemtype
argument_list|,
name|NULL
argument_list|)
return|;
block|}
break|break;
case|case
name|DNTT_TYPE_CLASS
case|:
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_GENFIELD
case|:
comment|/* Chase pointer from GENFIELD to FIELD, and make recursive        * call on that.        */
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dgenfield
operator|.
name|field
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_VFUNC
case|:
comment|/* C++ virtual function.        * We get here in the course of processing a class type which        * contains virtual functions. Just go through another level        * of indirection to get to the pointed-to function SOM.        */
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dvfunc
operator|.
name|funcptr
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_MODIFIER
case|:
comment|/* Check the modifiers and then just make a recursive call on        * the "type" pointed to by the modifier DNTT.        *         * pai:: FIXME -- do we ever want to handle "m_duplicate" and        * "m_void" modifiers?  Is static_flag really needed here?        * (m_static used for methods of classes, elsewhere).        */
name|tmp_type
operator|=
name|make_cv_type
argument_list|(
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|m_const
argument_list|,
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|m_volatile
argument_list|,
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tmp_type
return|;
case|case
name|DNTT_TYPE_MEMFUNC
case|:
comment|/* Member function. Treat like a function.        * I think we get here in the course of processing a         * pointer-to-member-function type...        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
return|return
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_TEMPLATE
case|:
comment|/* Template - sort of the header for a template definition,        * which like a class, points to a member list and also points        * to a TEMPLATE_ARG list of type-arguments.        */
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The TEMPLATE record points to an argument list of 	 * TEMPLATE_ARG records, each of which describes one 	 * of the type-arguments.  	 */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dtempl_arg
operator|.
name|name
expr_stmt|;
return|return
name|hpread_read_templ_arg_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
name|name
argument_list|)
return|;
block|}
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
comment|/* We wind up here when processing a TEMPLATE type,         * if the template has member function(s).        * Treat it like a FUNCTION.        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* The LINK record is used to link up templates with instantiations.        * There is no type associated with the LINK record per se.        */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
comment|/* Also not yet handled... */
comment|/* case DNTT_TYPE_DYN_ARRAY_DESC: */
comment|/* case DNTT_TYPE_DESC_SUBRANGE: */
comment|/* case DNTT_TYPE_BEGIN_EXT: */
comment|/* case DNTT_TYPE_INLN: */
comment|/* case DNTT_TYPE_INLN_LIST: */
comment|/* case DNTT_TYPE_ALIAS: */
default|default:
comment|/* A fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|sltpointer
name|hpread_record_lines
parameter_list|(
name|struct
name|subfile
modifier|*
name|subfile
parameter_list|,
name|sltpointer
name|s_idx
parameter_list|,
name|sltpointer
name|e_idx
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
while|while
condition|(
name|s_idx
operator|<=
name|e_idx
condition|)
block|{
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|s_idx
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Only record "normal" entries in the SLT.  */
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL
operator|||
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_EXIT
condition|)
name|record_line
argument_list|(
name|subfile
argument_list|,
name|sl_bufp
operator|->
name|snorm
operator|.
name|line
argument_list|,
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
operator|+
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
name|record_line
argument_list|(
name|subfile
argument_list|,
name|sl_bufp
operator|->
name|snormoff
operator|.
name|line
argument_list|,
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
operator|+
name|offset
argument_list|)
expr_stmt|;
name|s_idx
operator|++
expr_stmt|;
block|}
return|return
name|e_idx
return|;
block|}
end_function

begin_comment
comment|/* Given a function "f" which is a member of a class, find  * the classname that it is a member of. Used to construct  * the name (e.g., "c::f") which GDB will put in the  * "demangled name" field of the function's symbol.  * Called from hpread_process_one_debug_symbol()  * If "f" is not a member function, return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|class_of
parameter_list|(
name|struct
name|type
modifier|*
name|functype
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|first_param_type
decl_stmt|;
name|char
modifier|*
name|first_param_name
decl_stmt|;
name|struct
name|type
modifier|*
name|pointed_to_type
decl_stmt|;
name|char
modifier|*
name|class_name
decl_stmt|;
comment|/* Check that the function has a first argument "this",    * and that "this" is a pointer to a class. If not,    * functype is not a member function, so return NULL.    */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|functype
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|first_param_name
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|functype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_param_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|strcmp
argument_list|(
name|first_param_name
argument_list|,
literal|"this"
argument_list|)
condition|)
return|return
name|NULL
return|;
name|first_param_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|functype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_param_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|first_param_type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
return|return
name|NULL
return|;
comment|/* Get the thing that "this" points to, check that    * it's a class, and get its class name.    */
name|pointed_to_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|first_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointed_to_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|pointed_to_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
name|class_name
operator|=
name|TYPE_NAME
argument_list|(
name|pointed_to_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
comment|/* The class name may be of the form "class c", in which case    * we want to strip off the leading "class ".    */
if|if
condition|(
name|strncmp
argument_list|(
name|class_name
argument_list|,
literal|"class "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|class_name
operator|+=
literal|6
expr_stmt|;
return|return
name|class_name
return|;
block|}
end_function

begin_comment
comment|/* Internalize one native debug symbol.   * Called in a loop from hpread_expand_symtab().   * Arguments:  *   dn_bufp:   *   name:   *   section_offsets:  *   objfile:  *   text_offset:   *   text_size:   *   filename:   *   index:             Index of this symbol  *   at_module_boundary_p Pointer to boolean flag to control caller's loop.  */
end_comment

begin_function
specifier|static
name|void
name|hpread_process_one_debug_symbol
parameter_list|(
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|section_offsets
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|CORE_ADDR
name|text_offset
parameter_list|,
name|int
name|text_size
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|at_module_boundary_p
parameter_list|)
block|{
name|unsigned
name|long
name|desc
decl_stmt|;
name|int
name|type
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|data_offset
init|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_temp
decl_stmt|;
name|dnttpointer
name|hp_type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|class_scope_name
decl_stmt|;
comment|/* Allocate one GDB debug symbol and fill in some default values. */
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_auto
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
comment|/* Just a trick in case the SOM debug symbol is a type definition.    * There are routines that are set up to build a GDB type symbol, given    * a SOM dnttpointer. So we set up a dummy SOM dnttpointer "hp_type".    * This allows us to call those same routines.    */
name|hp_type
operator|.
name|dnttp
operator|.
name|extension
operator|=
literal|1
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|immediate
operator|=
literal|0
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|global
operator|=
literal|0
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|index
operator|=
name|index
expr_stmt|;
comment|/* This "type" is the type of SOM record.    * Switch on SOM type.    */
name|type
operator|=
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
comment|/* This type of symbol indicates from which source file or        * include file any following data comes. It may indicate:        *        * o   The start of an entirely new source file (and thus        *     a new module)        *        * o   The start of a different source file due to #include        *        * o   The end of an include file and the return to the original        *     file. Thus if "foo.c" includes "bar.h", we see first        *     a SRCFILE for foo.c, then one for bar.h, and then one for        *     foo.c again.        *        * If it indicates the start of a new module then we must        * finish the symbol table of the previous module         * (if any) and start accumulating a new symbol table.          */
name|valu
operator|=
name|text_offset
expr_stmt|;
if|if
condition|(
operator|!
name|last_source_file
condition|)
block|{
comment|/* 	   * A note on "last_source_file": this is a char* pointing 	   * to the actual file name.  "start_symtab" sets it, 	   * "end_symtab" clears it. 	   * 	   * So if "last_source_file" is NULL, then either this is 	   * the first record we are looking at, or a previous call 	   * to "end_symtab()" was made to close out the previous 	   * module.  Since we're now quitting the scan loop when we 	   * see a MODULE END record, we should never get here, except 	   * in the case that we're not using the quick look-up tables 	   * and have to use the old system as a fall-back. 	   */
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"HP"
argument_list|)
expr_stmt|;
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsfile
operator|.
name|address
expr_stmt|;
block|}
else|else
block|{
comment|/* Either a new include file, or a SRCFILE record 	   * saying we are back in the main source (or out of 	   * a nested include file) again. 	   */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dsfile
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* A note on "start_subfile".  This routine will check        * the name we pass it and look for an existing subfile        * of that name.  There's thus only one sub-file for the        * actual source (e.g. for "foo.c" in foo.c), despite the        * fact that we'll see lots of SRCFILE entries for foo.c        * inside foo.c.        */
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/*        * We no longer ignore DNTT_TYPE_MODULE symbols.  The module         * represents the meaningful semantic structure of a compilation        * unit.  We expect to start the psymtab-to-symtab expansion        * looking at a MODULE entry, and to end it at the corresponding        * END MODULE entry.        *        *--Begin outdated comments        *         * This record signifies the start of a new source module        * In C/C++ there is no explicit "module" construct in the language,        * but each compilation unit is implicitly a module and they        * do emit the DNTT_TYPE_MODULE records.        * The end of the module is marked by a matching DNTT_TYPE_END record.        *        * The reason GDB gets away with ignoring the DNTT_TYPE_MODULE record         * is it notices the DNTT_TYPE_END record for the previous         * module (see comments under DNTT_TYPE_END case), and then treats        * the next DNTT_TYPE_SRCFILE record as if it were the module-start record.        * (i.e., it makes a start_symtab() call).        * This scheme seems a little convoluted, but I'll leave it         * alone on the principle "if it ain't broke don't fix        * it". (RT).        *        *-- End outdated comments        */
name|valu
operator|=
name|text_offset
expr_stmt|;
if|if
condition|(
operator|!
name|last_source_file
condition|)
block|{
comment|/* Start of a new module. We know this because "last_source_file" 	   * is NULL, which can only happen the first time or if we just  	   * made a call to end_symtab() to close out the previous module. 	   */
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dmodule
operator|.
name|address
expr_stmt|;
block|}
else|else
block|{
comment|/* This really shouldn't happen if we're using the quick 	   * look-up tables, as it would mean we'd scanned past an 	   * END MODULE entry.  But if we're not using the tables, 	   * we started the module on the SRCFILE entry, so it's ok. 	   * For now, accept this. 	   */
comment|/* warning( "Error expanding psymtab, missed module end, found entry for %s", 	   *           name ); 	   */
operator|*
name|at_module_boundary_p
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
comment|/* A function or secondary entry point.  */
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
operator|+
name|offset
expr_stmt|;
comment|/* Record lines up to this point. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dfunc
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
operator|=
name|valu
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|lbrac_unmatched_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
comment|/* Built a type for the function. This includes processing        * the symbol records for the function parameters.        */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All functions in C++ have prototypes.  For C we don't have enough          information in the debug info.  */
if|if
condition|(
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_cplus
condition|)
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
comment|/* The "DEPRECATED_SYMBOL_NAME" field is expected to be the mangled name        * (if any), which we get from the "alias" field of the SOM record        * if that exists.        */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|&&
comment|/* has an alias */
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|)
condition|)
comment|/* not a null string */
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
expr_stmt|;
else|else
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
comment|/* Special hack to get around HP compilers' insistence on        * reporting "main" as "_MAIN_" for C/C++ */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
comment|/* The SYMBOL_CPLUS_DEMANGLED_NAME field is expected to        * be the demangled name.        */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
comment|/* SYMBOL_INIT_DEMANGLED_NAME is a macro which winds up 	   * calling the demangler in libiberty (cplus_demangle()) to 	   * do the job. This generally does the job, even though 	   * it's intended for the GNU compiler and not the aCC compiler 	   * Note that SYMBOL_INIT_DEMANGLED_NAME calls the 	   * demangler with arguments DMGL_PARAMS | DMGL_ANSI. 	   * Generally, we don't want params when we display 	   * a demangled name, but when I took out the DMGL_PARAMS, 	   * some things broke, so I'm leaving it in here, and 	   * working around the issue in stack.c. - RT 	   */
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|)
operator|&&
operator|(
operator|!
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
comment|/* Well, the symbol name is mangled, but the 	       * demangler in libiberty failed so the demangled 	       * field is still NULL. Try to 	       * do the job ourselves based on the "name" field 	       * in the SOM record. A complication here is that 	       * the name field contains only the function name 	       * (like "f"), whereas we want the class qualification 	       * (as in "c::f"). Try to reconstruct that. 	       */
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|classname
decl_stmt|;
name|char
modifier|*
name|dem_name
decl_stmt|;
name|basename
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
name|classname
operator|=
name|class_of
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|dem_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
name|strlen
argument_list|(
name|classname
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dem_name
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|dem_name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_cplus
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the function symbol to the list of symbols in this blockvector */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|sym
expr_stmt|;
comment|/* Search forward to the next BEGIN and also read        * in the line info up to that point.         * Not sure why this is needed.        * In HP FORTRAN this code is harmful since there           * may not be a BEGIN after the FUNCTION.        * So I made it C/C++ specific. - RT        */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_C
operator|||
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
while|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_BEGIN
condition|)
block|{
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
operator|++
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
block|}
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_get_line
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|lowaddr
operator|+
name|offset
expr_stmt|;
comment|/* Record lines up to this point. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
operator|=
name|valu
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|lbrac_unmatched_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
comment|/* Built a type for the function. This includes processing        * the symbol records for the function parameters.        */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "DEPRECATED_SYMBOL_NAME" field is expected to be the mangled name        * (if any), which we get from the "alias" field of the SOM record        * if that exists.        */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|&&
comment|/* has an alias */
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|)
condition|)
comment|/* not a null string */
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
expr_stmt|;
else|else
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
comment|/* Special hack to get around HP compilers' insistence on        * reporting "main" as "_MAIN_" for C/C++ */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
comment|/* SYMBOL_INIT_DEMANGLED_NAME is a macro which winds up 	   * calling the demangler in libiberty (cplus_demangle()) to 	   * do the job. This generally does the job, even though 	   * it's intended for the GNU compiler and not the aCC compiler 	   * Note that SYMBOL_INIT_DEMANGLED_NAME calls the 	   * demangler with arguments DMGL_PARAMS | DMGL_ANSI. 	   * Generally, we don't want params when we display 	   * a demangled name, but when I took out the DMGL_PARAMS, 	   * some things broke, so I'm leaving it in here, and 	   * working around the issue in stack.c. - RT  	   */
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|)
operator|&&
operator|(
operator|!
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
comment|/* Well, the symbol name is mangled, but the 	       * demangler in libiberty failed so the demangled 	       * field is still NULL. Try to 	       * do the job ourselves based on the "name" field 	       * in the SOM record. A complication here is that 	       * the name field contains only the function name 	       * (like "f"), whereas we want the class qualification 	       * (as in "c::f"). Try to reconstruct that. 	       */
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|classname
decl_stmt|;
name|char
modifier|*
name|dem_name
decl_stmt|;
name|basename
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
name|classname
operator|=
name|class_of
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|dem_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
name|strlen
argument_list|(
name|classname
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dem_name
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|dem_name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_cplus
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the function symbol to the list of symbols in this blockvector */
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|sym
expr_stmt|;
comment|/* Search forward to the next BEGIN and also read        * in the line info up to that point.         * Not sure why this is needed.        * In HP FORTRAN this code is harmful since there           * may not be a BEGIN after the FUNCTION.        * So I made it C/C++ specific. - RT        */
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_C
operator|||
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
while|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_BEGIN
condition|)
block|{
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
operator|++
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
block|}
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_get_line
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
comment|/* Begin a new scope. */
if|if
condition|(
name|context_stack_depth
operator|==
literal|1
comment|/* this means we're at function level */
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
comment|/* this means it's a function */
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|==
literal|0
comment|/* this means it's the first BEGIN  					   we've seen after the FUNCTION */
condition|)
block|{
comment|/* This is the first BEGIN after a FUNCTION. 	   * We ignore this one, since HP compilers always insert 	   * at least one BEGIN, i.e. it's: 	   *  	   *     FUNCTION 	   *     argument symbols 	   *     BEGIN 	   *     local symbols 	   *        (possibly nested BEGIN ... END's if there are inner { } blocks) 	   *     END 	   *     END 	   * 	   * By ignoring this first BEGIN, the local symbols get treated 	   * as belonging to the function scope, and "print func::local_sym" 	   * works (which is what we want). 	   */
comment|/* All we do here is increase the depth count associated with 	   * the FUNCTION entry in the context stack. This ensures that 	   * the next BEGIN we see (if any), representing a real nested { } 	   * block, will get processed. 	   */
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Record lines up to this SLT pointer. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Calculate start address of new scope */
name|valu
operator|=
name|hpread_get_location
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|offset
expr_stmt|;
comment|/* Relocate for dynamic loading */
comment|/* We use the scope start DNTT index as nesting depth identifier! */
name|desc
operator|=
name|hpread_get_scope_start
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DNTT_TYPE_END
case|:
comment|/* End a scope.  */
comment|/* Valid end kinds are:        *  MODULE        *  FUNCTION        *  WITH        *  COMMON        *  BEGIN        *  CLASS_SCOPE        */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dend
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
condition|)
block|{
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/* Ending a module ends the symbol table for that module.   	   * Calling end_symtab() has the side effect of clearing the 	   * last_source_file pointer, which in turn signals  	   * process_one_debug_symbol() to treat the next DNTT_TYPE_SRCFILE 	   * record as a module-begin. 	   */
name|valu
operator|=
name|text_offset
operator|+
name|text_size
operator|+
name|offset
expr_stmt|;
comment|/* Tell our caller that we're done with expanding the 	   * debug information for a module. 	   */
operator|*
name|at_module_boundary_p
operator|=
literal|1
expr_stmt|;
comment|/* Don't do this, as our caller will do it!  	   *      (void) end_symtab (valu, objfile, 0); 	   */
break|break;
case|case
name|DNTT_TYPE_FUNCTION
case|:
comment|/* Ending a function, well, ends the function's scope.  */
name|dn_temp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|=
name|dn_temp
operator|->
name|dfunc
operator|.
name|hiaddr
operator|+
name|offset
expr_stmt|;
comment|/* Insert func params into local list */
name|merge_symbol_lists
argument_list|(
operator|&
name|param_symbols
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* This may have to change for Pascal */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|param_symbols
operator|=
name|new
operator|->
name|params
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
if|if
condition|(
name|context_stack_depth
operator|==
literal|1
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* This is the END corresponding to the 	       * BEGIN which we ignored - see DNTT_TYPE_BEGIN case above. 	       */
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Ending a local scope.  */
name|valu
operator|=
name|hpread_get_location
argument_list|(
name|dn_bufp
operator|->
name|dend
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Why in the hell is this needed?  */
name|valu
operator|+=
name|offset
operator|+
literal|9
expr_stmt|;
comment|/* Relocate for dynamic loading */
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
name|desc
operator|=
name|dn_bufp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|lbrac_mismatch_complaint
argument_list|(
name|symnum
argument_list|)
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|param_symbols
operator|=
name|new
operator|->
name|params
expr_stmt|;
block|}
break|break;
case|case
name|DNTT_TYPE_WITH
case|:
comment|/* Since we ignore the DNTT_TYPE_WITH that starts the scope, 	   * we can ignore the DNTT_TYPE_END that ends it. 	   */
break|break;
case|case
name|DNTT_TYPE_COMMON
case|:
comment|/* End a FORTRAN common block. We don't currently handle these */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_COMMON/DNTT_TYPE_END.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
comment|/* pai: FIXME Not handling nested classes for now -- must 	     * maintain a stack */
name|class_scope_name
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* End a class scope */
block|valu = hpread_get_location (dn_bufp->dend.address, objfile);
comment|/* Why in the hell is this needed?  */
block|valu += offset + 9;
comment|/* Relocate for dynamic loading */
block|new = pop_context (); 	  desc = dn_bufp->dend.beginscope.dnttp.index; 	  if (desc != new->depth) 	    lbrac_mismatch_complaint ((char *) symnum);
comment|/* Make a block for the local symbols within.  */
block|finish_block (new->name,&local_symbols, new->old_blocks, 			new->start_addr, valu, objfile); 	  local_symbols = new->locals; 	  param_symbols = new->params;
endif|#
directive|endif
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"internal error in hp-symtab-read.c: Unexpected DNTT_TYPE_END kind."
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* DNTT_TYPE_IMPORT is not handled */
case|case
name|DNTT_TYPE_LABEL
case|:
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|LABEL_DOMAIN
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_FPARAM
case|:
comment|/* Function parameters.  */
comment|/* Note 1: This code was present in the 4.16 sources, and then          removed, because fparams are handled in          hpread_read_function_type().  However, while fparam symbols          are indeed handled twice, this code here cannot be removed          because then they don't get added to the local symbol list of          the function's code block, which leads to a failure to look          up locals, "this"-relative member names, etc.  So I've put          this code back in. pai/1997-07-21 */
comment|/* Note 2: To fix a defect, we stopped adding FPARAMS to local_symbols          in hpread_read_function_type(), so FPARAMS had to be handled          here.  I changed the location to be the appropriate argument          kinds rather than LOC_LOCAL. pai/1997-08-08 */
comment|/* Note 3: Well, the fix in Note 2 above broke argument printing          in traceback frames, and further it makes assumptions about the          order of the FPARAM entries from HP compilers (cc and aCC in particular          generate them in reverse orders -- fixing one breaks for the other).          So I've added code in hpread_read_function_type() to add fparams          to a param_symbols list for the current context level.  These are          then merged into local_symbols when a function end is reached.          pai/1997-08-11 */
break|break;
comment|/* do nothing; handled in hpread_read_function_type() */
if|#
directive|if
literal|0
comment|/* Old code */
block|if (dn_bufp->dfparam.regparam) 	SYMBOL_CLASS (sym) = LOC_REGISTER;       else if (dn_bufp->dfparam.indirect) 	SYMBOL_CLASS (sym) = LOC_REF_ARG;       else 	SYMBOL_CLASS (sym) = LOC_ARG;       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;       if (dn_bufp->dfparam.copyparam) 	{ 	  SYMBOL_VALUE (sym) = dn_bufp->dfparam.location;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
block|SYMBOL_VALUE (sym) 	    += HPREAD_ADJUST_STACK_ADDRESS (CURRENT_FUNCTION_VALUE (objfile));
endif|#
directive|endif
block|}       else 	SYMBOL_VALUE (sym) = dn_bufp->dfparam.location;       SYMBOL_TYPE (sym) = hpread_type_lookup (dn_bufp->dfparam.type, objfile);       add_symbol_to_list (sym,&fparam_symbols);       break;
endif|#
directive|endif
case|case
name|DNTT_TYPE_SVAR
case|:
comment|/* Static variables.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
comment|/* Note: There is a case that arises with globals in shared        * libraries where we need to set the address to LOC_INDIRECT.        * This case is if you have a global "g" in one library, and        * it is referenced "extern<type> g;" in another library.        * If we're processing the symbols for the referencing library,        * we'll see a global "g", but in this case the address given        * in the symbol table contains a pointer to the real "g".        * We use the storage class LOC_INDIRECT to indicate this. RT        */
if|if
condition|(
name|is_in_import_list
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|objfile
argument_list|)
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_INDIRECT
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
operator|+
name|data_offset
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|thread_specific
condition|)
block|{
comment|/* Thread-local variable. 	   */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_HP_THREAD_LOCAL_STATIC
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|CR27_REGNUM
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SHARED
condition|)
block|{
comment|/* 	       * This variable is not only thread local but 	       * in a shared library. 	       * 	       * Alas, the shared lib structures are private 	       * to "somsolib.c".  But C lets us point to one. 	       */
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|obj_private
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error in reading shared library information."
argument_list|)
expr_stmt|;
name|so
operator|=
operator|(
operator|(
name|obj_private_data_t
operator|*
operator|)
operator|(
name|objfile
operator|->
name|obj_private
operator|)
operator|)
operator|->
name|so_info
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error in reading shared library information."
argument_list|)
expr_stmt|;
comment|/* Thread-locals in shared libraries do NOT have the 	       * standard offset ("data_offset"), so we re-calculate 	       * where to look for this variable, using a call-back 	       * to interpret the private shared-library data. 	       */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
operator|+
name|so_lib_thread_start_addr
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DNTT_TYPE_DVAR
case|:
comment|/* Dynamic variables.  */
if|if
condition|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|regvar
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|ddvar
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CONST
case|:
comment|/* A constant (pascal?).  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dconst
operator|.
name|location
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_TYPEDEF
case|:
comment|/* A typedef. We do want to process these, since a name is        * added to the domain for the typedef'ed name.        */
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
name|int
name|global
init|=
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
decl_stmt|;
comment|/* Structure, union, enum, template, or class tag definition */
comment|/* We do want to process these, since a name is 	 * added to the domain for the tag name (and if C++ class, 	 * for the typename also). 	 */
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_DOMAIN
expr_stmt|;
comment|/* The tag contains in its "type" field a pointer to the 	 * DNTT_TYPE_STRUCT, DNTT_TYPE_UNION, DNTT_TYPE_ENUM,  	 * DNTT_TYPE_CLASS or DNTT_TYPE_TEMPLATE 	 * record that actually defines the type. 	 */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|sym
operator|->
name|type
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|sym
operator|->
name|type
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* If this is a C++ class, then we additionally  	 * need to define a typedef for the 	 * class type. E.g., so that the name "c" becomes visible as 	 * a type name when the user says "class c { ... }". 	 * In order to figure this out, we need to chase down the "type" 	 * field to get to the DNTT_TYPE_CLASS record.  	 * 	 * We also add the typename for ENUM. Though this isn't 	 * strictly correct, it is necessary because of the debug info 	 * generated by the aCC compiler, in which we cannot 	 * distinguish between: 	 *   enum e { ... }; 	 * and 	 *   typedef enum { ... } e; 	 * I.e., the compiler emits the same debug info for the above 	 * two cases, in both cases "e" appearing as a tagdef. 	 * Therefore go ahead and generate the typename so that 	 * "ptype e" will work in the above cases. 	 * 	 * We also add the typename for TEMPLATE, so as to allow "ptype t" 	 * when "t" is a template name.  	 */
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtag
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"error processing class tagdef"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|struct
name|symbol
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|newsym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|newsym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|newsym
argument_list|)
operator|=
name|language_auto
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|newsym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|newsym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|newsym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|newsym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|newsym
argument_list|)
operator|=
name|sym
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DNTT_TYPE_POINTER
case|:
comment|/* Declares a pointer type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_ENUM
case|:
comment|/* Declares an enum type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_MEMENUM
case|:
comment|/* Member of enum */
comment|/* Ignored at this level, but hpread_read_enum_type() will take        * care of walking the list of enumeration members.        */
break|break;
case|case
name|DNTT_TYPE_SET
case|:
comment|/* Declares a set type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_SUBRANGE
case|:
comment|/* Declares a subrange type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_ARRAY
case|:
comment|/* Declares an array type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
comment|/* Declares an struct/union type.         * Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_FIELD
case|:
comment|/* Structure/union/class field */
comment|/* Ignored at this level, but hpread_read_struct_type() will take        * care of walking the list of structure/union/class members.        */
break|break;
comment|/* DNTT_TYPE_VARIANT is not handled by GDB */
comment|/* DNTT_TYPE_FILE is not handled by GDB */
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
comment|/* Function type */
comment|/* Ignored at this level, handled within hpread_type_lookup() */
break|break;
case|case
name|DNTT_TYPE_WITH
case|:
comment|/* This is emitted within methods to indicate "with<class>"         * scoping rules (i.e., indicate that the class data members        * are directly visible).        * However, since GDB already infers this by looking at the        * "this" argument, interpreting the DNTT_TYPE_WITH         * symbol record is unnecessary.        */
break|break;
case|case
name|DNTT_TYPE_COMMON
case|:
comment|/* FORTRAN common. Not yet handled. */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_COMMON."
argument_list|)
expr_stmt|;
break|break;
comment|/* DNTT_TYPE_COBSTRUCT is not handled by GDB.  */
comment|/* DNTT_TYPE_XREF is not handled by GDB.  */
comment|/* DNTT_TYPE_SA is not handled by GDB.  */
comment|/* DNTT_TYPE_MACRO is not handled by GDB */
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
comment|/* Not sure what this is - part of FORTRAN support maybe?         * Anyway, not yet handled.        */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_BLOCKDATA."
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
comment|/* The compiler brackets member functions with a CLASS_SCOPE/END        * pair of records, presumably to put them in a different scope        * from the module scope where they are normally defined.        * E.g., in the situation:        *   void f() { ... }        *   void c::f() { ...}        * The member function "c::f" will be bracketed by a CLASS_SCOPE/END.        * This causes "break f" at the module level to pick the        * the file-level function f(), not the member function        * (which needs to be referenced via "break c::f").         *         * Here we record the class name to generate the demangled names of        * member functions later.        *        * FIXME Not being used now for anything -- cplus_demangle seems        * enough for getting the class-qualified names of functions. We        * may need this for handling nested classes and types.  */
comment|/* pai: FIXME Not handling nested classes for now -- need to        * maintain a stack */
name|dn_temp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dclass_scope
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_temp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
condition|)
name|class_scope_name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_temp
operator|->
name|dtag
operator|.
name|name
expr_stmt|;
else|else
name|class_scope_name
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Begin a new scope.  */
block|SL_INDEX (objfile) = hpread_record_lines (current_subfile, 						SL_INDEX (objfile), 					      dn_bufp->dclass_scope.address, 						objfile, offset);       valu = hpread_get_location (dn_bufp->dclass_scope.address, objfile);       valu += offset;
comment|/* Relocate for dynamic loading */
block|desc = hpread_get_scope_start (dn_bufp->dclass_scope.address, objfile);
comment|/* We use the scope start DNTT index as the nesting depth identifier! */
block|new = push_context (desc, valu);
endif|#
directive|endif
break|break;
case|case
name|DNTT_TYPE_REFERENCE
case|:
comment|/* Declares a C++ reference type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_PTRMEM
case|:
comment|/* Declares a C++ pointer-to-data-member type. This does not        * need to be handled at this level; being a type description it        * is instead handled at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
comment|/* Declares a C++ pointer-to-function-member type. This does not        * need to be handled at this level; being a type description it        * is instead handled at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_CLASS
case|:
comment|/* Declares a class type.         * Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_GENFIELD
case|:
comment|/* I believe this is used for class member functions */
comment|/* Ignored at this level, but hpread_read_struct_type() will take        * care of walking the list of class members.        */
break|break;
case|case
name|DNTT_TYPE_VFUNC
case|:
comment|/* Virtual function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_MEMACCESS
case|:
comment|/* DDE ignores this symbol table record.        * It has something to do with "modified access" to class members.        * I'll assume we can safely ignore it too.        */
break|break;
case|case
name|DNTT_TYPE_INHERITANCE
case|:
comment|/* These don't have to be handled here, since they are handled        * within hpread_read_struct_type() in the process of constructing        * a class type.        */
break|break;
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
comment|/* These can safely be ignored, as GDB doesn't need this        * info. DDE only uses it in "describe". We may later want        * to extend GDB's "ptype" to give this info, but for now        * it seems safe enough to ignore it.        */
break|break;
case|case
name|DNTT_TYPE_MODIFIER
case|:
comment|/* Intended to supply "modified access" to a type */
comment|/* From the way DDE handles this, it looks like it always        * modifies a type. Therefore it is safe to ignore it at this        * level, and handle it in hpread_type_lookup().        */
break|break;
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
comment|/* Just ignore this - that's all DDE does */
break|break;
case|case
name|DNTT_TYPE_MEMFUNC
case|:
comment|/* Member function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
comment|/* Member function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_TEMPLATE
case|:
comment|/* Template - sort of the header for a template definition,        * which like a class, points to a member list and also points        * to a TEMPLATE_ARG list of type-arguments.        * We do not need to process TEMPLATE records at this level though.        */
break|break;
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
comment|/* The TEMPLATE record points to an argument list of        * TEMPLATE_ARG records, each of which describes one        * of the type-arguments.        * We do not need to process TEMPLATE_ARG records at this level though.        */
break|break;
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
comment|/* This will get emitted for member functions of templates.        * But we don't need to process this record at this level though,        * we will process it in the course of processing a TEMPLATE        * record.        */
break|break;
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* The LINK record is used to link up templates with instantiations. */
comment|/* It is not clear why this is needed, and furthermore aCC does        * not appear to generate this, so I think we can safely ignore it. - RT        */
break|break;
comment|/* DNTT_TYPE_DYN_ARRAY_DESC is not handled by GDB */
comment|/* DNTT_TYPE_DESC_SUBRANGE is not handled by GDB */
comment|/* DNTT_TYPE_BEGIN_EXT is not handled by GDB */
comment|/* DNTT_TYPE_INLN is not handled by GDB */
comment|/* DNTT_TYPE_INLN_LIST is not handled by GDB */
comment|/* DNTT_TYPE_ALIAS is not handled by GDB */
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Get nesting depth for a DNTT entry.  * DN_BUFP points to a DNTT entry.  * OBJFILE is the object file.  * REPORT_NESTED is a flag; if 0, real nesting depth is  * reported, if it is 1, the function simply returns a   * non-zero value if the nesting depth is anything> 0.  *   * Return value is an integer.  0 => not a local type / name  * positive return => type or name is local to some   * block or function.  */
end_comment

begin_comment
comment|/* elz: ATTENTION: FIXME: NOTE: WARNING!!!!    this function now returns 0 right away. It was taking too much time    at start up. Now, though, the local types are not handled correctly.  */
end_comment

begin_function
specifier|static
name|int
name|hpread_get_scope_depth
parameter_list|(
name|union
name|dnttentry
modifier|*
name|dn_bufp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|report_nested
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_tmp
decl_stmt|;
name|short
name|depth
init|=
literal|0
decl_stmt|;
comment|/****************************/
return|return
literal|0
return|;
comment|/****************************/
name|index
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dn_bufp
operator|)
operator|-
name|LNTT
argument_list|(
name|objfile
argument_list|)
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
block|{
name|dn_tmp
operator|=
name|hpread_get_lntt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dn_tmp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_MODULE
case|:
return|return
name|depth
return|;
case|case
name|DNTT_TYPE_END
case|:
comment|/* index is signed int; dnttp.index is 29-bit unsigned int! */
name|index
operator|=
operator|(
name|int
operator|)
name|dn_tmp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|report_nested
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Adjust the bitoffsets for all fields of an anonymous union of    type TYPE by negative BITS.  This handles HP aCC's hideous habit    of giving members of anonymous unions bit offsets relative to the    enclosing structure instead of relative to the union itself. */
end_comment

begin_function
specifier|static
name|void
name|hpread_adjust_bitoffsets
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is done only for unions; caller had better check that      it is an anonymous one. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
return|return;
comment|/* Adjust each field; since this is a union, there are no base      classes. Also no static membes.  Also, no need for recursion as      the members of this union if themeselves structs or unions, have      the correct bitoffsets; if an anonymous union is a member of this      anonymous union, the code in hpread_read_struct_type() will      adjust for that. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|-=
name|bits
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Because of quirks in HP compilers' treatment of anonymous unions inside    classes, we have to chase through a chain of threaded FIELD entries.    If we encounter an anonymous union in the chain, we must recursively skip over    that too.     This function does a "next" in the chain of FIELD entries, but transparently    skips over anonymous unions' fields (recursively).     Inputs are the number of times to do "next" at the top level, the dnttpointer    (FIELD) and entry pointer (FIELDP) for the dntt record corresponding to it,    and the ubiquitous objfile parameter. (Note: FIELDP is a **.)  Return value    is a dnttpointer for the new field after all the skipped ones */
end_comment

begin_function
specifier|static
name|dnttpointer
name|hpread_get_next_skip_over_anon_unions
parameter_list|(
name|int
name|skip_fields
parameter_list|,
name|dnttpointer
name|field
parameter_list|,
name|union
name|dnttentry
modifier|*
modifier|*
name|fieldp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|anon_type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bitoffset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skip_fields
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get type of item we're looking at now; recursively processes the types          of these intermediate items we skip over, so they aren't lost. */
name|anon_type
operator|=
name|hpread_type_lookup
argument_list|(
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|anon_type
operator|=
name|CHECK_TYPEDEF
argument_list|(
name|anon_type
argument_list|)
expr_stmt|;
name|bitoffset
operator|=
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
comment|/* First skip over one item to avoid stack death on recursion */
name|field
operator|=
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|nextfield
expr_stmt|;
operator|*
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Do we have another anonymous union? If so, adjust the bitoffsets          of its members and skip over its members. */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|anon_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|(
operator|!
name|name
operator|||
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
block|{
name|hpread_adjust_bitoffsets
argument_list|(
name|anon_type
argument_list|,
name|bitoffset
argument_list|)
expr_stmt|;
name|field
operator|=
name|hpread_get_next_skip_over_anon_unions
argument_list|(
name|TYPE_NFIELDS
argument_list|(
name|anon_type
argument_list|)
argument_list|,
name|field
argument_list|,
name|fieldp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|field
return|;
block|}
end_function

end_unit

