begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for PowerPC systems using the SVR4 ABI    for GDB, the GNU debugger.     Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Pass the arguments in either registers, or in the stack. Using the    ppc sysv ABI, the first eight words of the argument list (that might    be less than eight parameters if some parameters occupy more than one    word) are passed in r3..r10 registers.  float and double parameters are    passed in fpr's, in addition to that. Rest of the parameters if any    are passed in user stack.      If the function is returning a structure, then the return address is passed    in r3, then the first 7 words of the parametes can be passed in registers,    starting from r4. */
end_comment

begin_function
name|CORE_ADDR
name|ppc_sysv_abi_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|const
name|CORE_ADDR
name|saved_sp
init|=
name|read_sp
argument_list|()
decl_stmt|;
name|int
name|argspace
init|=
literal|0
decl_stmt|;
comment|/* 0 is an initial wrong guess.  */
name|int
name|write_pass
decl_stmt|;
comment|/* Go through the argument list twice.       Pass 1: Figure out how much new stack space is required for      arguments and pushed values.  Unlike the PowerOpen ABI, the SysV      ABI doesn't reserve any extra space for parameters which are put      in registers, but does always push structures and then pass their      address.       Pass 2: Replay the same computation but this time also write the      values out to the target.  */
for|for
control|(
name|write_pass
operator|=
literal|0
init|;
name|write_pass
operator|<
literal|2
condition|;
name|write_pass
operator|++
control|)
block|{
name|int
name|argno
decl_stmt|;
comment|/* Next available floating point register for float and double          arguments.  */
name|int
name|freg
init|=
literal|1
decl_stmt|;
comment|/* Next available general register for non-float, non-vector          arguments.  */
name|int
name|greg
init|=
literal|3
decl_stmt|;
comment|/* Next available vector register for vector arguments.  */
name|int
name|vreg
init|=
literal|2
decl_stmt|;
comment|/* Arguments start above the "LR save word" and "Back chain".  */
name|int
name|argoffset
init|=
literal|2
operator|*
name|tdep
operator|->
name|wordsize
decl_stmt|;
comment|/* Structures start after the arguments.  */
name|int
name|structoffset
init|=
name|argoffset
operator|+
name|argspace
decl_stmt|;
comment|/* If the function is returning a `struct', then the first word          (which will be passed in r3) is used for struct return          address.  In that case we should advance one word and start          from r4 register to copy parameters.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
block|}
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argno
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
name|len
operator|<=
literal|8
condition|)
block|{
comment|/* Floating point value converted to "double" then 	         passed in an FP register, when the registers run out, 	         8 byte aligned stack is used.  */
if|if
condition|(
name|freg
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
block|{
comment|/* Always store the floating point value using 		         the register's floating-point format.  */
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|FP0_REGNUM
operator|+
name|freg
argument_list|)
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|val
argument_list|,
name|type
argument_list|,
name|regval
argument_list|,
name|regtype
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
name|freg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
name|freg
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* SysV ABI converts floats to doubles before 		     writing them to an 8 byte aligned stack location.  */
name|argoffset
operator|=
name|align_up
argument_list|(
name|argoffset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
block|{
name|char
name|memval
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
switch|switch
condition|(
name|TARGET_BYTE_ORDER
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|memtype
operator|=
name|builtin_type_ieee_double_big
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|memtype
operator|=
name|builtin_type_ieee_double_little
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|convert_typed_floating
argument_list|(
name|val
argument_list|,
name|type
argument_list|,
name|memval
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|argoffset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
comment|/* long long */
operator|||
operator|(
operator|!
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|)
operator|)
condition|)
comment|/* double */
block|{
comment|/* "long long" or "double" passed in an odd/even 	         register pair with the low addressed word in the odd 	         register and the high addressed word in the even 	         register, or when the registers run out an 8 byte 	         aligned stack location.  */
if|if
condition|(
name|greg
operator|>
literal|9
condition|)
block|{
comment|/* Just in case GREG was 10.  */
name|greg
operator|=
literal|11
expr_stmt|;
name|argoffset
operator|=
name|align_up
argument_list|(
name|argoffset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tdep
operator|->
name|wordsize
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|greg
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Must start on an odd register - r3/r4 etc.  */
if|if
condition|(
operator|(
name|greg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|greg
operator|++
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
block|{
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
operator|+
literal|0
argument_list|,
name|val
operator|+
literal|0
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
operator|+
literal|1
argument_list|,
name|val
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|greg
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|16
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|tdep
operator|->
name|ppc_vr0_regnum
operator|>=
literal|0
condition|)
block|{
comment|/* Vector parameter passed in an Altivec register, or 	         when that runs out, 16 byte aligned stack location.  */
if|if
condition|(
name|vreg
operator|<=
literal|13
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|vreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vreg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|argoffset
operator|=
name|align_up
argument_list|(
name|argoffset
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|val
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|16
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|tdep
operator|->
name|ppc_ev0_regnum
operator|>=
literal|0
condition|)
block|{
comment|/* Vector parameter passed in an e500 register, or when 	         that runs out, 8 byte aligned stack location.  Note 	         that since e500 vector and general purpose registers 	         both map onto the same underlying register set, a 	         "greg" and not a "vreg" is consumed here.  A cooked 	         write stores the value in the correct locations 	         within the raw register cache.  */
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_ev0_regnum
operator|+
name|greg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|argoffset
operator|=
name|align_up
argument_list|(
name|argoffset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|val
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reduce the parameter down to something that fits in a 	         "word".  */
name|char
name|word
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|memset
argument_list|(
name|word
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|tdep
operator|->
name|wordsize
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
comment|/* Structs and large values are put on an 8 byte 		     aligned stack ... */
name|structoffset
operator|=
name|align_up
argument_list|(
name|structoffset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|structoffset
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* ... and then a "word" pointing to that address is 		     passed as the parameter.  */
name|store_unsigned_integer
argument_list|(
name|word
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|,
name|sp
operator|+
name|structoffset
argument_list|)
expr_stmt|;
name|structoffset
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
comment|/* Sign or zero extend the "int" into a "word".  */
name|store_unsigned_integer
argument_list|(
name|word
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Always goes in the low address.  */
name|memcpy
argument_list|(
name|word
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Store that "word" in a register, or on the stack. 	         The words have "4" byte alignment.  */
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|argoffset
operator|=
name|align_up
argument_list|(
name|argoffset
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|word
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
name|tdep
operator|->
name|wordsize
expr_stmt|;
block|}
block|}
block|}
comment|/* Compute the actual stack space requirements.  */
if|if
condition|(
operator|!
name|write_pass
condition|)
block|{
comment|/* Remember the amount of space needed by the arguments.  */
name|argspace
operator|=
name|argoffset
expr_stmt|;
comment|/* Allocate space for both the arguments and the structures.  */
name|sp
operator|-=
operator|(
name|argoffset
operator|+
name|structoffset
operator|)
expr_stmt|;
comment|/* Ensure that the stack is still 16 byte aligned.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update %sp.   */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Write the backchain (it occupies WORDSIZED bytes).  */
name|write_memory_signed_integer
argument_list|(
name|sp
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|,
name|saved_sp
argument_list|)
expr_stmt|;
comment|/* Point the inferior function call's return address at the dummy's      breakpoint.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Handle the return-value conventions specified by the SysV 32-bit    PowerPC ABI (including all the supplements):     no floating-point: floating-point values returned using 32-bit    general-purpose registers.     Altivec: 128-bit vectors returned using vector registers.     e500: 64-bit vectors returned using the full full 64 bit EV    register, floating-point values returned using 32-bit    general-purpose registers.     GCC (broken): Small struct values right (instead of left) aligned    when returned in general-purpose registers.  */
end_comment

begin_function
specifier|static
name|enum
name|return_value_convention
name|do_ppc_sysv_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|int
name|broken_gcc
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|wordsize
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|8
operator|&&
name|ppc_floating_point_unit_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* Floats and doubles stored in "f1".  Convert the value to 	     the required type.  */
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
decl_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|regval
argument_list|,
name|regtype
argument_list|,
name|readbuf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* Floats and doubles stored in "f1".  Convert the value to 	     the register's "double" type.  */
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|FP0_REGNUM
argument_list|)
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|writebuf
argument_list|,
name|type
argument_list|,
name|regval
argument_list|,
name|regtype
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* A long long, or a double stored in the 32 bit r3/r4.  */
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
literal|0
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|4
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* A long long, or a double stored in the 32 bit r3/r4.  */
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
literal|0
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|4
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
name|tdep
operator|->
name|wordsize
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* Some sort of integer stored in r3.  Since TYPE isn't 	     bigger than the register, sign extension isn't a problem 	     - just do everything unsigned.  */
name|ULONGEST
name|regval
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
operator|&
name|regval
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|readbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* Some sort of integer stored in r3.  Use unpack_long since 	     that should handle any required sign extension.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|writebuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|tdep
operator|->
name|ppc_vr0_regnum
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* Altivec places the return value in "v2".  */
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|2
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* Altivec places the return value in "v2".  */
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|2
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|tdep
operator|->
name|ppc_ev0_regnum
operator|>=
literal|0
condition|)
block|{
comment|/* The e500 ABI places return values for the 64-bit DSP types 	 (__ev64_opaque__) in r3.  However, in GDB-speak, ev3 	 corresponds to the entire r3 value for e500, whereas GDB's r3 	 only corresponds to the least significant 32-bits.  So place 	 the 64-bit DSP type's value in ev3.  */
if|if
condition|(
name|readbuf
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_ev0_regnum
operator|+
literal|3
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_ev0_regnum
operator|+
literal|3
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|broken_gcc
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* GCC screwed up.  The last register isn't "left" aligned. 	     Need to extract the least significant part of each 	     register and then store that.  */
comment|/* Transfer any full words.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ULONGEST
name|reg
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|word
operator|*
name|tdep
operator|->
name|wordsize
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|tdep
operator|->
name|wordsize
condition|)
name|len
operator|=
name|tdep
operator|->
name|wordsize
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
operator|+
name|word
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
name|word
operator|*
name|tdep
operator|->
name|wordsize
operator|)
argument_list|,
name|len
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|word
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* GCC screwed up.  The last register isn't "left" aligned. 	     Need to extract the least significant part of each 	     register and then store that.  */
comment|/* Transfer any full words.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ULONGEST
name|reg
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|word
operator|*
name|tdep
operator|->
name|wordsize
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|tdep
operator|->
name|wordsize
condition|)
name|len
operator|=
name|tdep
operator|->
name|wordsize
expr_stmt|;
name|reg
operator|=
name|extract_unsigned_integer
argument_list|(
operator|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
name|word
operator|*
name|tdep
operator|->
name|wordsize
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
operator|+
name|word
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|word
operator|++
expr_stmt|;
block|}
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* This matches SVr4 PPC, it does not match GCC.  */
comment|/* The value is right-padded to 8 bytes and then loaded, as 	     two "words", into r3/r4.  */
name|char
name|regvals
index|[
name|MAX_REGISTER_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|regvals
operator|+
literal|0
operator|*
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|tdep
operator|->
name|wordsize
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|4
argument_list|,
name|regvals
operator|+
literal|1
operator|*
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|readbuf
argument_list|,
name|regvals
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writebuf
condition|)
block|{
comment|/* This matches SVr4 PPC, it does not match GCC.  */
comment|/* The value is padded out to 8 bytes and then loaded, as 	     two "words" into r3/r4.  */
name|char
name|regvals
index|[
name|MAX_REGISTER_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|memset
argument_list|(
name|regvals
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|regvals
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regvals
argument_list|,
name|writebuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|regvals
operator|+
literal|0
operator|*
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|tdep
operator|->
name|wordsize
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|4
argument_list|,
name|regvals
operator|+
literal|1
operator|*
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
block|}
end_function

begin_function
name|enum
name|return_value_convention
name|ppc_sysv_abi_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
return|return
name|do_ppc_sysv_return_value
argument_list|(
name|gdbarch
argument_list|,
name|valtype
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|return_value_convention
name|ppc_sysv_abi_broken_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
return|return
name|do_ppc_sysv_return_value
argument_list|(
name|gdbarch
argument_list|,
name|valtype
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pass the arguments in either registers, or in the stack. Using the    ppc 64 bit SysV ABI.     This implements a dumbed down version of the ABI.  It always writes    values to memory, GPR and FPR, even when not necessary.  Doing this    greatly simplifies the logic. */
end_comment

begin_function
name|CORE_ADDR
name|ppc64_sysv_abi_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* By this stage in the proceedings, SP has been decremented by "red      zone size" + "struct return size".  Fetch the stack-pointer from      before this and use that as the BACK_CHAIN.  */
specifier|const
name|CORE_ADDR
name|back_chain
init|=
name|read_sp
argument_list|()
decl_stmt|;
comment|/* See for-loop comment below.  */
name|int
name|write_pass
decl_stmt|;
comment|/* Size of the Altivec's vector parameter region, the final value is      computed in the for-loop below.  */
name|LONGEST
name|vparam_size
init|=
literal|0
decl_stmt|;
comment|/* Size of the general parameter region, the final value is computed      in the for-loop below.  */
name|LONGEST
name|gparam_size
init|=
literal|0
decl_stmt|;
comment|/* Kevin writes ... I don't mind seeing tdep->wordsize used in the      calls to align_up(), align_down(), etc.  because this makes it      easier to reuse this code (in a copy/paste sense) in the future,      but it is a 64-bit ABI and asserting that the wordsize is 8 bytes      at some point makes it easier to verify that this function is      correct without having to do a non-local analysis to figure out      the possible values of tdep->wordsize.  */
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|wordsize
operator|==
literal|8
argument_list|)
expr_stmt|;
comment|/* Go through the argument list twice.       Pass 1: Compute the function call's stack space and register      requirements.       Pass 2: Replay the same computation but this time also write the      values out to the target.  */
for|for
control|(
name|write_pass
operator|=
literal|0
init|;
name|write_pass
operator|<
literal|2
condition|;
name|write_pass
operator|++
control|)
block|{
name|int
name|argno
decl_stmt|;
comment|/* Next available floating point register for float and double          arguments.  */
name|int
name|freg
init|=
literal|1
decl_stmt|;
comment|/* Next available general register for non-vector (but possibly          float) arguments.  */
name|int
name|greg
init|=
literal|3
decl_stmt|;
comment|/* Next available vector register for vector arguments.  */
name|int
name|vreg
init|=
literal|2
decl_stmt|;
comment|/* The address, at which the next general purpose parameter          (integer, struct, float, ...) should be saved.  */
name|CORE_ADDR
name|gparam
decl_stmt|;
comment|/* Address, at which the next Altivec vector parameter should be          saved.  */
name|CORE_ADDR
name|vparam
decl_stmt|;
if|if
condition|(
operator|!
name|write_pass
condition|)
block|{
comment|/* During the first pass, GPARAM and VPARAM are more like 	     offsets (start address zero) than addresses.  That way 	     the accumulate the total stack space each region 	     requires.  */
name|gparam
operator|=
literal|0
expr_stmt|;
name|vparam
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Decrement the stack pointer making space for the Altivec 	     and general on-stack parameters.  Set vparam and gparam 	     to their corresponding regions.  */
name|vparam
operator|=
name|align_down
argument_list|(
name|sp
operator|-
name|vparam_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|gparam
operator|=
name|align_down
argument_list|(
name|vparam
operator|-
name|gparam_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Add in space for the TOC, link editor double word, 	     compiler double word, LR save area, CR save area.  */
name|sp
operator|=
name|align_down
argument_list|(
name|gparam
operator|-
literal|48
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* If the function is returning a `struct', then there is an          extra hidden parameter (which will be passed in r3)          containing the address of that struct..  In that case we          should advance one word and start from r4 register to copy          parameters.  This also consumes one on-stack parameter slot.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
name|gparam
operator|=
name|align_up
argument_list|(
name|gparam
operator|+
name|tdep
operator|->
name|wordsize
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argno
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|8
condition|)
block|{
comment|/* Floats and Doubles go in f1 .. f13.  They also 	         consume a left aligned GREG,, and can end up in 	         memory.  */
if|if
condition|(
name|write_pass
condition|)
block|{
if|if
condition|(
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
name|freg
operator|<=
literal|13
condition|)
block|{
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|FP0_REGNUM
argument_list|)
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|val
argument_list|,
name|type
argument_list|,
name|regval
argument_list|,
name|regtype
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
name|freg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
block|{
comment|/* The ABI states "Single precision floating 		         point values are mapped to the first word in 		         a single doubleword" and "... floating point 		         values mapped to the first eight doublewords 		         of the parameter save area are also passed in 		         general registers").  		         This code interprets that to mean: store it, 		         left aligned, in the general register.  */
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|memset
argument_list|(
name|regval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|regval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regval
argument_list|,
name|val
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
name|write_memory
argument_list|(
name|gparam
argument_list|,
name|val
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Always consume parameter stack space.  */
name|freg
operator|++
expr_stmt|;
name|greg
operator|++
expr_stmt|;
name|gparam
operator|=
name|align_up
argument_list|(
name|gparam
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|tdep
operator|->
name|ppc_vr0_regnum
operator|>=
literal|0
condition|)
block|{
comment|/* In the Altivec ABI, vectors go in the vector 	         registers v2 .. v13, or when that runs out, a vector 	         annex which goes above all the normal parameters. 	         NOTE: cagney/2003-09-21: This is a guess based on the 	         PowerOpen Altivec ABI.  */
if|if
condition|(
name|vreg
operator|<=
literal|13
condition|)
block|{
if|if
condition|(
name|write_pass
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|vreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vreg
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|write_pass
condition|)
name|write_memory
argument_list|(
name|vparam
argument_list|,
name|val
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|vparam
operator|=
name|align_up
argument_list|(
name|vparam
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|8
condition|)
block|{
comment|/* Scalars get sign[un]extended and go in gpr3 .. gpr10. 	         They can also end up in memory.  */
if|if
condition|(
name|write_pass
condition|)
block|{
comment|/* Sign extend the value, then store it unsigned.  */
name|ULONGEST
name|word
init|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|greg
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|write_memory_unsigned_integer
argument_list|(
name|gparam
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
name|greg
operator|++
expr_stmt|;
name|gparam
operator|=
name|align_up
argument_list|(
name|gparam
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|byte
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|;
name|byte
operator|+=
name|tdep
operator|->
name|wordsize
control|)
block|{
if|if
condition|(
name|write_pass
operator|&&
name|greg
operator|<=
literal|10
condition|)
block|{
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|byte
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|tdep
operator|->
name|wordsize
condition|)
name|len
operator|=
name|tdep
operator|->
name|wordsize
expr_stmt|;
name|memset
argument_list|(
name|regval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|regval
argument_list|)
expr_stmt|;
comment|/* WARNING: cagney/2003-09-21: As best I can 		         tell, the ABI specifies that the value should 		         be left aligned.  Unfortunately, GCC doesn't 		         do this - it instead right aligns even sized 		         values and puts odd sized values on the 		         stack.  Work around that by putting both a 		         left and right aligned value into the 		         register (hopefully no one notices :-^). 		         Arrrgh!  */
comment|/* Left aligned (8 byte values such as pointers 		         fill the buffer).  */
name|memcpy
argument_list|(
name|regval
argument_list|,
name|val
operator|+
name|byte
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Right aligned (but only if even).  */
if|if
condition|(
name|len
operator|==
literal|1
operator|||
name|len
operator|==
literal|2
operator|||
name|len
operator|==
literal|4
condition|)
name|memcpy
argument_list|(
name|regval
operator|+
name|tdep
operator|->
name|wordsize
operator|-
name|len
argument_list|,
name|val
operator|+
name|byte
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|greg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
name|greg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|write_pass
condition|)
comment|/* WARNING: cagney/2003-09-21: Strictly speaking, this 		   isn't necessary, unfortunately, GCC appears to get 		   "struct convention" parameter passing wrong putting 		   odd sized structures in memory instead of in a 		   register.  Work around this by always writing the 		   value to memory.  Fortunately, doing this 		   simplifies the code.  */
name|write_memory
argument_list|(
name|gparam
argument_list|,
name|val
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always consume parameter stack space.  */
name|gparam
operator|=
name|align_up
argument_list|(
name|gparam
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|write_pass
condition|)
block|{
comment|/* Save the true region sizes ready for the second pass.  */
name|vparam_size
operator|=
name|vparam
expr_stmt|;
comment|/* Make certain that the general parameter save area is at 	     least the minimum 8 registers (or doublewords) in size.  */
if|if
condition|(
name|greg
operator|<
literal|8
condition|)
name|gparam_size
operator|=
literal|8
operator|*
name|tdep
operator|->
name|wordsize
expr_stmt|;
else|else
name|gparam_size
operator|=
name|gparam
expr_stmt|;
block|}
block|}
comment|/* Update %sp.   */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Write the backchain (it occupies WORDSIZED bytes).  */
name|write_memory_signed_integer
argument_list|(
name|sp
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|,
name|back_chain
argument_list|)
expr_stmt|;
comment|/* Point the inferior function call's return address at the dummy's      breakpoint.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* Find a value for the TOC register.  Every symbol should have both      ".FN" and "FN" in the minimal symbol table.  "FN" points at the      FN's descriptor, while ".FN" points at the entry point (which      matches FUNC_ADDR).  Need to reverse from FUNC_ADDR back to the      FN's descriptor address (while at the same time being careful to      find "FN" in the same object file as ".FN").  */
block|{
comment|/* Find the minimal symbol that corresponds to FUNC_ADDR (should        have the name ".FN").  */
name|struct
name|minimal_symbol
modifier|*
name|dot_fn
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|func_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot_fn
operator|!=
name|NULL
operator|&&
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|dot_fn
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Get the section that contains FUNC_ADR.  Need this for the            "objfile" that it contains.  */
name|struct
name|obj_section
modifier|*
name|dot_fn_section
init|=
name|find_pc_section
argument_list|(
name|func_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot_fn_section
operator|!=
name|NULL
operator|&&
name|dot_fn_section
operator|->
name|objfile
operator|!=
name|NULL
condition|)
block|{
comment|/* Now find the corresponding "FN" (dropping ".") minimal 	       symbol's address.  Only look for the minimal symbol in 	       ".FN"'s object file - avoids problems when two object 	       files (i.e., shared libraries) contain a minimal symbol 	       with the same name.  */
name|struct
name|minimal_symbol
modifier|*
name|fn
init|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|dot_fn
argument_list|)
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|dot_fn_section
operator|->
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
block|{
comment|/* Got the address of that descriptor.  The TOC is the 		   second double word.  */
name|CORE_ADDR
name|toc
init|=
name|read_memory_unsigned_integer
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fn
argument_list|)
operator|+
name|tdep
operator|->
name|wordsize
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
decl_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|2
argument_list|,
name|toc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* The 64 bit ABI retun value convention.     Return non-zero if the return-value is stored in a register, return    0 if the return-value is instead stored on the stack (a.k.a.,    struct return convention).     For a return-value stored in a register: when WRITEBUF is non-NULL,    copy the buffer to the corresponding register return-value location    location; when READBUF is non-NULL, fill the buffer from the    corresponding register return-value location.  */
end_comment

begin_function
name|enum
name|return_value_convention
name|ppc64_sysv_abi_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* Floats and doubles in F1.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<=
literal|8
condition|)
block|{
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|FP0_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
block|{
name|convert_typed_floating
argument_list|(
name|writebuf
argument_list|,
name|valtype
argument_list|,
name|regval
argument_list|,
name|regtype
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|regval
argument_list|,
name|regtype
argument_list|,
name|readbuf
argument_list|,
name|valtype
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<=
literal|8
condition|)
block|{
comment|/* Integers in r3.  */
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
block|{
comment|/* Be careful to sign extend the value.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|unpack_long
argument_list|(
name|valtype
argument_list|,
name|writebuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
block|{
comment|/* Extract the integer from r3.  Since this is truncating the 	     value, there isn't a sign extension problem.  */
name|ULONGEST
name|regval
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
operator|&
name|regval
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|readbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
comment|/* All pointers live in r3.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
comment|/* All pointers live in r3.  */
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<=
literal|8
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|valtype
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|valtype
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Small character arrays are returned, right justified, in r3.  */
name|int
name|offset
init|=
operator|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_write_part
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_read_part
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
comment|/* Big floating point values get stored in adjacent floating      point registers.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|16
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|32
operator|)
condition|)
block|{
if|if
condition|(
name|writebuf
operator|||
name|readbuf
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|/
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
comment|/* Complex values get returned in f1:f2, need to convert.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_COMPLEX
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|8
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|regcache
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|char
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|regtype
init|=
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|FP0_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
block|{
name|convert_typed_floating
argument_list|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
name|i
operator|*
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|/
literal|2
operator|)
argument_list|,
name|valtype
argument_list|,
name|regval
argument_list|,
name|regtype
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|regval
argument_list|,
name|regtype
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
name|i
operator|*
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|/
literal|2
operator|)
argument_list|,
name|valtype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
comment|/* Big complex values get stored in f1:f4.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_COMPLEX
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|32
condition|)
block|{
if|if
condition|(
name|regcache
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|writebuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|i
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|readbuf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ppc64_sysv_abi_adjust_breakpoint_address
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|bpaddr
parameter_list|)
block|{
comment|/* PPC64 SYSV specifies that the minimal-symbol "FN" should point at      a function-descriptor while the corresponding minimal-symbol      ".FN" should point at the entry point.  Consequently, a command      like "break FN" applied to an object file with only minimal      symbols, will insert the breakpoint into the descriptor at "FN"      and not the function at ".FN".  Avoid this confusion by adjusting      any attempt to set a descriptor breakpoint into a corresponding      function breakpoint.  Note that GDB warns the user when this      adjustment is applied - that's ok as otherwise the user will have      no way of knowing why their breakpoint at "FN" resulted in the      program stopping at ".FN".  */
return|return
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|gdbarch
argument_list|,
name|bpaddr
argument_list|,
operator|&
name|current_target
argument_list|)
return|;
block|}
end_function

end_unit

