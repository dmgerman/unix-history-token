begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Manages interpreters for GDB, the GNU debugger.     Copyright 2000, 2002, 2003 Free Software Foundation, Inc.     Written by Jim Ingham<jingham@apple.com> of Apple Computer, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* This is just a first cut at separating out the "interpreter"    functions of gdb into self-contained modules.  There are a couple    of open areas that need to be sorted out:     1) The interpreter explicitly contains a UI_OUT, and can insert itself    into the event loop, but it doesn't explicitly contain hooks for readline.    I did this because it seems to me many interpreters won't want to use    the readline command interface, and it is probably simpler to just let    them take over the input in their resume proc.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb-events.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_comment
comment|/* For command_loop.  */
end_comment

begin_struct
struct|struct
name|interp
block|{
comment|/* This is the name in "-i=" and set interpreter. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Interpreters are stored in a linked list, this is the next      one...  */
name|struct
name|interp
modifier|*
name|next
decl_stmt|;
comment|/* This is a cookie that an instance of the interpreter can use.      This is a bit confused right now as the exact initialization      sequence for it, and how it relates to the interpreter's uiout      object is a bit confused.  */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* Has the init_proc been run? */
name|int
name|inited
decl_stmt|;
comment|/* This is the ui_out used to collect results for this interpreter.      It can be a formatter for stdout, as is the case for the console& mi outputs, or it might be a result formatter.  */
name|struct
name|ui_out
modifier|*
name|interpreter_out
decl_stmt|;
specifier|const
name|struct
name|interp_procs
modifier|*
name|procs
decl_stmt|;
name|int
name|quiet_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Functions local to this file. */
end_comment

begin_function_decl
specifier|static
name|void
name|initialize_interps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|interpreter_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The magic initialization routine for this module. */
end_comment

begin_function_decl
name|void
name|_initialize_interpreter
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Variables local to this file: */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|interp
modifier|*
name|interp_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interp
modifier|*
name|current_interpreter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interpreter_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interp_new - This allocates space for a new interpreter,    fills the fields from the inputs, and returns a pointer to the    interpreter. */
end_comment

begin_function
name|struct
name|interp
modifier|*
name|interp_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|struct
name|interp_procs
modifier|*
name|procs
parameter_list|)
block|{
name|struct
name|interp
modifier|*
name|new_interp
decl_stmt|;
name|new_interp
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|interp
argument_list|)
expr_stmt|;
name|new_interp
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new_interp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|new_interp
operator|->
name|interpreter_out
operator|=
name|uiout
expr_stmt|;
name|new_interp
operator|->
name|quiet_p
operator|=
literal|0
expr_stmt|;
name|new_interp
operator|->
name|procs
operator|=
name|procs
expr_stmt|;
name|new_interp
operator|->
name|inited
operator|=
literal|0
expr_stmt|;
return|return
name|new_interp
return|;
block|}
end_function

begin_comment
comment|/* Add interpreter INTERP to the gdb interpreter list.  The    interpreter must not have previously been added.  */
end_comment

begin_function
name|void
name|interp_add
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|interpreter_initialized
condition|)
name|initialize_interps
argument_list|()
expr_stmt|;
name|gdb_assert
argument_list|(
name|interp_lookup
argument_list|(
name|interp
operator|->
name|name
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|interp
operator|->
name|next
operator|=
name|interp_list
expr_stmt|;
name|interp_list
operator|=
name|interp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This sets the current interpreter to be INTERP.  If INTERP has not    been initialized, then this will also run the init proc.  If the    init proc is successful, return 1, if it fails, set the old    interpreter back in place and return 0.  If we can't restore the    old interpreter, then raise an internal error, since we are in    pretty bad shape at this point. */
end_comment

begin_function
name|int
name|interp_set
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|)
block|{
name|struct
name|interp
modifier|*
name|old_interp
init|=
name|current_interpreter
decl_stmt|;
name|int
name|first_time
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|current_interpreter
operator|!=
name|NULL
condition|)
block|{
name|do_all_continuations
argument_list|()
expr_stmt|;
name|ui_out_flush
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_interpreter
operator|->
name|procs
operator|->
name|suspend_proc
operator|&&
operator|!
name|current_interpreter
operator|->
name|procs
operator|->
name|suspend_proc
argument_list|(
name|current_interpreter
operator|->
name|data
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Could not suspend interpreter \"%s\"\n"
argument_list|,
name|current_interpreter
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|first_time
operator|=
literal|1
expr_stmt|;
block|}
name|current_interpreter
operator|=
name|interp
expr_stmt|;
comment|/* We use interpreter_p for the "set interpreter" variable, so we need      to make sure we have a malloc'ed copy for the set command to free. */
if|if
condition|(
name|interpreter_p
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|current_interpreter
operator|->
name|name
argument_list|,
name|interpreter_p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|interpreter_p
argument_list|)
expr_stmt|;
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
name|current_interpreter
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|uiout
operator|=
name|interp
operator|->
name|interpreter_out
expr_stmt|;
comment|/* Run the init proc.  If it fails, try to restore the old interp. */
if|if
condition|(
operator|!
name|interp
operator|->
name|inited
condition|)
block|{
if|if
condition|(
name|interp
operator|->
name|procs
operator|->
name|init_proc
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|data
operator|=
name|interp
operator|->
name|procs
operator|->
name|init_proc
argument_list|()
expr_stmt|;
block|}
name|interp
operator|->
name|inited
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Clear out any installed interpreter hooks/event handlers. */
name|clear_interpreter_hooks
argument_list|()
expr_stmt|;
if|if
condition|(
name|interp
operator|->
name|procs
operator|->
name|resume_proc
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|interp
operator|->
name|procs
operator|->
name|resume_proc
argument_list|(
name|interp
operator|->
name|data
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|old_interp
operator|==
name|NULL
operator|||
operator|!
name|interp_set
argument_list|(
name|old_interp
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Failed to initialize new interp \"%s\" %s"
argument_list|,
name|interp
operator|->
name|name
argument_list|,
literal|"and could not restore old interp!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Finally, put up the new prompt to show that we are indeed here.       Also, display_gdb_prompt for the console does some readline magic      which is needed for the console interpreter, at least... */
if|if
condition|(
operator|!
name|first_time
condition|)
block|{
if|if
condition|(
operator|!
name|interp_quiet_p
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Switching to interpreter \"%.24s\".\n"
argument_list|,
name|interp
operator|->
name|name
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|display_gdb_prompt
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* interp_lookup - Looks up the interpreter for NAME.  If no such    interpreter exists, return NULL, otherwise return a pointer to the    interpreter.  */
end_comment

begin_function
name|struct
name|interp
modifier|*
name|interp_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|interp
modifier|*
name|interp
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|interp
operator|=
name|interp_list
init|;
name|interp
operator|!=
name|NULL
condition|;
name|interp
operator|=
name|interp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|interp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|interp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the current interpreter. */
end_comment

begin_function
name|struct
name|ui_out
modifier|*
name|interp_ui_out
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
return|return
name|interp
operator|->
name|interpreter_out
return|;
return|return
name|current_interpreter
operator|->
name|interpreter_out
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the current interp is the passed in name. */
end_comment

begin_function
name|int
name|current_interp_named_p
parameter_list|(
specifier|const
name|char
modifier|*
name|interp_name
parameter_list|)
block|{
if|if
condition|(
name|current_interpreter
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|current_interpreter
operator|->
name|name
argument_list|,
name|interp_name
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is called in display_gdb_prompt.  If the proc returns a zero    value, display_gdb_prompt will return without displaying the    prompt.  */
end_comment

begin_function
name|int
name|current_interp_display_prompt_p
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_interpreter
operator|==
name|NULL
operator|||
name|current_interpreter
operator|->
name|procs
operator|->
name|prompt_proc_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
return|return
name|current_interpreter
operator|->
name|procs
operator|->
name|prompt_proc_p
argument_list|(
name|current_interpreter
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run the current command interpreter's main loop.  */
end_comment

begin_function
name|void
name|current_interp_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Somewhat messy.  For the moment prop up all the old ways of      selecting the command loop.  `command_loop_hook' should be      deprecated.  */
if|if
condition|(
name|command_loop_hook
operator|!=
name|NULL
condition|)
name|command_loop_hook
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|current_interpreter
operator|!=
name|NULL
operator|&&
name|current_interpreter
operator|->
name|procs
operator|->
name|command_loop_proc
operator|!=
name|NULL
condition|)
name|current_interpreter
operator|->
name|procs
operator|->
name|command_loop_proc
argument_list|(
name|current_interpreter
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event_loop_p
condition|)
name|cli_command_loop
argument_list|()
expr_stmt|;
else|else
name|command_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|interp_quiet_p
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
return|return
name|interp
operator|->
name|quiet_p
return|;
else|else
return|return
name|current_interpreter
operator|->
name|quiet_p
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|interp_set_quiet
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|old_val
init|=
name|interp
operator|->
name|quiet_p
decl_stmt|;
name|interp
operator|->
name|quiet_p
operator|=
name|quiet
expr_stmt|;
return|return
name|old_val
return|;
block|}
end_function

begin_comment
comment|/* interp_exec - This executes COMMAND_STR in the current     interpreter. */
end_comment

begin_function
name|int
name|interp_exec_p
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|)
block|{
return|return
name|interp
operator|->
name|procs
operator|->
name|exec_proc
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|interp_exec
parameter_list|(
name|struct
name|interp
modifier|*
name|interp
parameter_list|,
specifier|const
name|char
modifier|*
name|command_str
parameter_list|)
block|{
if|if
condition|(
name|interp
operator|->
name|procs
operator|->
name|exec_proc
operator|!=
name|NULL
condition|)
block|{
return|return
name|interp
operator|->
name|procs
operator|->
name|exec_proc
argument_list|(
name|interp
operator|->
name|data
argument_list|,
name|command_str
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A convenience routine that nulls out all the    common command hooks.  Use it when removing your interpreter in its     suspend proc. */
end_comment

begin_function
name|void
name|clear_interpreter_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|init_ui_hook
operator|=
literal|0
expr_stmt|;
name|print_frame_info_listing_hook
operator|=
literal|0
expr_stmt|;
comment|/*print_frame_more_info_hook = 0; */
name|query_hook
operator|=
literal|0
expr_stmt|;
name|warning_hook
operator|=
literal|0
expr_stmt|;
name|create_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|delete_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|modify_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|interactive_hook
operator|=
literal|0
expr_stmt|;
name|registers_changed_hook
operator|=
literal|0
expr_stmt|;
name|readline_begin_hook
operator|=
literal|0
expr_stmt|;
name|readline_hook
operator|=
literal|0
expr_stmt|;
name|readline_end_hook
operator|=
literal|0
expr_stmt|;
name|register_changed_hook
operator|=
literal|0
expr_stmt|;
name|memory_changed_hook
operator|=
literal|0
expr_stmt|;
name|context_hook
operator|=
literal|0
expr_stmt|;
name|target_wait_hook
operator|=
literal|0
expr_stmt|;
name|call_command_hook
operator|=
literal|0
expr_stmt|;
name|error_hook
operator|=
literal|0
expr_stmt|;
name|error_begin_hook
operator|=
literal|0
expr_stmt|;
name|command_loop_hook
operator|=
literal|0
expr_stmt|;
name|clear_gdb_event_hooks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a lazy init routine, called the first time    the interpreter module is used.  I put it here just in case, but I haven't    thought of a use for it yet.  I will probably bag it soon, since I don't    think it will be necessary. */
end_comment

begin_function
specifier|static
name|void
name|initialize_interps
parameter_list|(
name|void
parameter_list|)
block|{
name|interpreter_initialized
operator|=
literal|1
expr_stmt|;
comment|/* Don't know if anything needs to be done here... */
block|}
end_function

begin_function
specifier|static
name|void
name|interpreter_exec_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|interp
modifier|*
name|old_interp
decl_stmt|,
modifier|*
name|interp_to_use
decl_stmt|;
name|char
modifier|*
modifier|*
name|prules
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|trule
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|nrules
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|old_quiet
decl_stmt|,
name|use_quiet
decl_stmt|;
name|prules
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|prules
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"unable to parse arguments"
argument_list|)
expr_stmt|;
block|}
name|nrules
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prules
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|trule
operator|=
name|prules
init|;
operator|*
name|trule
operator|!=
name|NULL
condition|;
name|trule
operator|++
control|)
block|{
name|nrules
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrules
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"usage: interpreter-exec<interpreter> [<command> ... ]"
argument_list|)
expr_stmt|;
name|old_interp
operator|=
name|current_interpreter
expr_stmt|;
name|interp_to_use
operator|=
name|interp_lookup
argument_list|(
name|prules
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_to_use
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Could not find interpreter \"%s\"."
argument_list|,
name|prules
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Temporarily set interpreters quiet */
name|old_quiet
operator|=
name|interp_set_quiet
argument_list|(
name|old_interp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|use_quiet
operator|=
name|interp_set_quiet
argument_list|(
name|interp_to_use
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interp_set
argument_list|(
name|interp_to_use
argument_list|)
condition|)
name|error
argument_list|(
literal|"Could not switch to interpreter \"%s\"."
argument_list|,
name|prules
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|interp_exec
argument_list|(
name|interp_to_use
argument_list|,
name|prules
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|interp_set
argument_list|(
name|old_interp
argument_list|)
expr_stmt|;
name|interp_set_quiet
argument_list|(
name|interp_to_use
argument_list|,
name|old_quiet
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"error in command: \"%s\"."
argument_list|,
name|prules
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|interp_set
argument_list|(
name|old_interp
argument_list|)
expr_stmt|;
name|interp_set_quiet
argument_list|(
name|interp_to_use
argument_list|,
name|use_quiet
argument_list|)
expr_stmt|;
name|interp_set_quiet
argument_list|(
name|old_interp
argument_list|,
name|old_quiet
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List the possible interpreters which could complete the given text. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|interpreter_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|int
name|alloced
init|=
literal|0
decl_stmt|;
name|int
name|textlen
decl_stmt|;
name|int
name|num_matches
decl_stmt|;
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|struct
name|interp
modifier|*
name|interp
decl_stmt|;
comment|/* We expect only a very limited number of interpreters, so just      allocate room for all of them. */
for|for
control|(
name|interp
operator|=
name|interp_list
init|;
name|interp
operator|!=
name|NULL
condition|;
name|interp
operator|=
name|interp
operator|->
name|next
control|)
operator|++
name|alloced
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|num_matches
operator|=
literal|0
expr_stmt|;
name|textlen
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|interp
operator|=
name|interp_list
init|;
name|interp
operator|!=
name|NULL
condition|;
name|interp
operator|=
name|interp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|interp
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|matches
index|[
name|num_matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|+
name|strlen
argument_list|(
name|interp
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
name|strcpy
argument_list|(
name|matches
index|[
name|num_matches
index|]
argument_list|,
name|interp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of interp->name */
name|strcpy
argument_list|(
name|matches
index|[
name|num_matches
index|]
argument_list|,
name|interp
operator|->
name|name
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of text plus interp->name */
name|strncpy
argument_list|(
name|matches
index|[
name|num_matches
index|]
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|matches
index|[
name|num_matches
index|]
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|matches
index|[
name|num_matches
index|]
argument_list|,
name|interp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|num_matches
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_matches
operator|<
name|alloced
condition|)
block|{
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matches
argument_list|,
operator|(
operator|(
name|num_matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matches
index|[
name|num_matches
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|matches
return|;
block|}
end_function

begin_comment
comment|/* This just adds the "interpreter-exec" command.  */
end_comment

begin_function
name|void
name|_initialize_interpreter
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"interpreter-exec"
argument_list|,
name|class_support
argument_list|,
name|interpreter_exec_cmd
argument_list|,
literal|"Execute a command in an interpreter.  It takes two arguments:\n\ The first argument is the name of the interpreter to use.\n\ The second argument is the command to execute.\n"
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|interpreter_completer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

