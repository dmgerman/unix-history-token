begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-vector operations for controlling Windows CE child processes, for GDB.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Cygnus Solutions, A Red Hat Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* by Christopher Faylor (cgf@cygnus.com) */
end_comment

begin_comment
comment|/* We assume we're being built with and will be used for cygwin.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SHx
end_ifdef

begin_undef
undef|#
directive|undef
name|SH4
end_undef

begin_define
define|#
directive|define
name|SH4
end_define

begin_comment
comment|/* Just to get all of the CONTEXT defines. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<rapi.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<cygwin/in.h>
end_include

begin_include
include|#
directive|include
file|<cygwin/socket.h>
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"wince-stub.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MIPS
end_ifdef

begin_include
include|#
directive|include
file|"mips-tdep.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The ui's event loop. */
end_comment

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_loop_hook
function_decl|)
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If we're not using the old Cygwin header file set, define the    following which never should have been in the generic Win32 API    headers in the first place since they were our own invention... */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_H_WINDOWS_H
end_ifndef

begin_define
define|#
directive|define
name|FLAG_TRACE_BIT
value|0x100
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CONTEXT_FLOATING_POINT
end_ifdef

begin_define
define|#
directive|define
name|CONTEXT_DEBUGGER0
value|(CONTEXT_FULL | CONTEXT_FLOATING_POINT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONTEXT_DEBUGGER0
value|(CONTEXT_FULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SH4
end_ifdef

begin_define
define|#
directive|define
name|CONTEXT_DEBUGGER
value|((CONTEXT_DEBUGGER0& ~(CONTEXT_SH4 | CONTEXT_FLOATING_POINT)) | CONTEXT_SH3)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONTEXT_DEBUGGER
value|CONTEXT_DEBUGGER0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string sent by cygwin when it processes a signal.    FIXME: This should be in a cygwin include file. */
end_comment

begin_define
define|#
directive|define
name|CYGWIN_SIGNAL_STRING
value|"cygwin: signal"
end_define

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|check (x, __FILE__,__LINE__)
end_define

begin_define
define|#
directive|define
name|DEBUG_EXEC
parameter_list|(
name|x
parameter_list|)
value|if (debug_exec)		printf x
end_define

begin_define
define|#
directive|define
name|DEBUG_EVENTS
parameter_list|(
name|x
parameter_list|)
value|if (debug_events)	printf x
end_define

begin_define
define|#
directive|define
name|DEBUG_MEM
parameter_list|(
name|x
parameter_list|)
value|if (debug_memory)	printf x
end_define

begin_define
define|#
directive|define
name|DEBUG_EXCEPT
parameter_list|(
name|x
parameter_list|)
value|if (debug_exceptions)	printf x
end_define

begin_decl_stmt
specifier|static
name|int
name|connection_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we've initialized a RAPI session. */
end_comment

begin_comment
comment|/* The directory where the stub and executable files are uploaded. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|remote_directory
init|=
literal|"\\gdb"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The types automatic upload available. */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|UPLOAD_ALWAYS
init|=
literal|0
block|,
name|UPLOAD_NEWER
init|=
literal|1
block|,
name|UPLOAD_NEVER
init|=
literal|2
block|}
name|upload_when
init|=
name|UPLOAD_NEWER
enum|;
end_enum

begin_comment
comment|/* Valid options for 'set remoteupload'.  Note that options    must track upload_when enum. */
end_comment

begin_struct
specifier|static
struct|struct
name|opts
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|abbrev
decl_stmt|;
block|}
name|upload_options
index|[
literal|3
index|]
init|=
block|{
block|{
literal|"always"
block|,
literal|1
block|}
block|,
block|{
literal|"newer"
block|,
literal|3
block|}
block|,
block|{
literal|"never"
block|,
literal|3
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remote_upload
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by set remoteupload */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_add_host
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|win32_child_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|child_kill_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|last_sig
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if a signal was received from the 				   debugged process */
end_comment

begin_comment
comment|/* Thread information structure used to track information that is    not available in gdb's thread structure. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thread_info_struct
block|{
name|struct
name|thread_info_struct
modifier|*
name|next
decl_stmt|;
name|DWORD
name|id
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|suspend_count
decl_stmt|;
name|int
name|stepped
decl_stmt|;
comment|/* True if stepped. */
name|CORE_ADDR
name|step_pc
decl_stmt|;
name|unsigned
name|long
name|step_prev
decl_stmt|;
name|CONTEXT
name|context
decl_stmt|;
block|}
name|thread_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|thread_info
name|thread_head
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|thread_info
modifier|*
name|thread_rec
parameter_list|(
name|DWORD
name|id
parameter_list|,
name|int
name|get_context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The process and thread handles for the above context. */
end_comment

begin_decl_stmt
specifier|static
name|DEBUG_EVENT
name|current_event
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current debug event from 					   WaitForDebugEvent */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|current_process_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently executing process */
end_comment

begin_decl_stmt
specifier|static
name|thread_info
modifier|*
name|current_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info on currently selected thread */
end_comment

begin_decl_stmt
specifier|static
name|thread_info
modifier|*
name|this_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info on thread returned by wait_for_debug_event */
end_comment

begin_decl_stmt
specifier|static
name|DWORD
name|main_thread_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread ID of the main thread */
end_comment

begin_comment
comment|/* Counts of things. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exception_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|event_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_exec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show execution */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show events from kernel */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_memory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show target memory accesses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_exceptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show target exceptions */
end_comment

begin_comment
comment|/* An array of offset mappings into a Win32 Context structure.    This is a one-to-one mapping which is indexed by gdb's register    numbers.  It retrieves an offset into the context structure where    the 4 byte register is located.    An offset value of -1 indicates that Win32 does not provide this    register in it's CONTEXT structure.  regptr will return zero for this    register.     This is used by the regptr function. */
end_comment

begin_define
define|#
directive|define
name|context_offset
parameter_list|(
name|x
parameter_list|)
value|((int)&(((PCONTEXT)NULL)->x))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mappings
index|[
name|NUM_REGS
operator|+
literal|1
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|__i386__
name|context_offset
argument_list|(
name|Eax
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ecx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Edx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ebx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Esp
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ebp
argument_list|)
block|,
name|context_offset
argument_list|(
name|Esi
argument_list|)
block|,
name|context_offset
argument_list|(
name|Edi
argument_list|)
block|,
name|context_offset
argument_list|(
name|Eip
argument_list|)
block|,
name|context_offset
argument_list|(
name|EFlags
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegCs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegSs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegDs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegEs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegFs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegGs
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|0
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|1
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|2
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|3
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|4
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|5
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|6
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|7
operator|*
literal|10
index|]
argument_list|)
block|,
elif|#
directive|elif
name|defined
argument_list|(
name|SHx
argument_list|)
name|context_offset
argument_list|(
name|R0
argument_list|)
block|,
name|context_offset
argument_list|(
name|R1
argument_list|)
block|,
name|context_offset
argument_list|(
name|R2
argument_list|)
block|,
name|context_offset
argument_list|(
name|R3
argument_list|)
block|,
name|context_offset
argument_list|(
name|R4
argument_list|)
block|,
name|context_offset
argument_list|(
name|R5
argument_list|)
block|,
name|context_offset
argument_list|(
name|R6
argument_list|)
block|,
name|context_offset
argument_list|(
name|R7
argument_list|)
block|,
name|context_offset
argument_list|(
name|R8
argument_list|)
block|,
name|context_offset
argument_list|(
name|R9
argument_list|)
block|,
name|context_offset
argument_list|(
name|R10
argument_list|)
block|,
name|context_offset
argument_list|(
name|R11
argument_list|)
block|,
name|context_offset
argument_list|(
name|R12
argument_list|)
block|,
name|context_offset
argument_list|(
name|R13
argument_list|)
block|,
name|context_offset
argument_list|(
name|R14
argument_list|)
block|,
name|context_offset
argument_list|(
name|R15
argument_list|)
block|,
name|context_offset
argument_list|(
name|Fir
argument_list|)
block|,
name|context_offset
argument_list|(
name|PR
argument_list|)
block|,
comment|/* Procedure Register */
name|context_offset
argument_list|(
name|GBR
argument_list|)
block|,
comment|/* Global Base Register */
name|context_offset
argument_list|(
name|MACH
argument_list|)
block|,
comment|/* Accumulate */
name|context_offset
argument_list|(
name|MACL
argument_list|)
block|,
comment|/* Multiply */
name|context_offset
argument_list|(
name|Psr
argument_list|)
block|,
name|context_offset
argument_list|(
name|Fpul
argument_list|)
block|,
name|context_offset
argument_list|(
name|Fpscr
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|0
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|1
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|2
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|3
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|4
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|5
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|6
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|7
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|8
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|9
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|11
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|12
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|13
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|14
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FRegs
index|[
literal|15
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|0
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|1
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|2
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|3
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|4
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|5
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|6
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|7
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|8
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|9
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|11
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|12
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|13
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|14
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|xFRegs
index|[
literal|15
index|]
argument_list|)
block|,
elif|#
directive|elif
name|defined
argument_list|(
name|MIPS
argument_list|)
name|context_offset
argument_list|(
name|IntZero
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntAt
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntV0
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntV1
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntA0
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntA1
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntA2
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntA3
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT0
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT1
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT2
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT3
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT4
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT5
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT6
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT7
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS0
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS1
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS2
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS3
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS4
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS5
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS6
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS7
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT8
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntT9
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntK0
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntK1
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntGp
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntSp
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntS8
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntRa
argument_list|)
block|,
name|context_offset
argument_list|(
name|Psr
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntLo
argument_list|)
block|,
name|context_offset
argument_list|(
name|IntHi
argument_list|)
block|,
operator|-
literal|1
block|,
comment|/* bad */
operator|-
literal|1
block|,
comment|/* cause */
name|context_offset
argument_list|(
name|Fir
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF0
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF1
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF2
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF3
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF4
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF5
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF6
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF7
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF8
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF9
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF10
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF11
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF12
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF13
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF14
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF15
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF16
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF17
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF18
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF19
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF20
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF21
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF22
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF23
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF24
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF25
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF26
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF27
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF28
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF29
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF30
argument_list|)
block|,
name|context_offset
argument_list|(
name|FltF31
argument_list|)
block|,
name|context_offset
argument_list|(
name|Fsr
argument_list|)
block|,
name|context_offset
argument_list|(
name|Fir
argument_list|)
block|,
operator|-
literal|1
block|,
comment|/* fp */
elif|#
directive|elif
name|defined
argument_list|(
name|ARM
argument_list|)
name|context_offset
argument_list|(
name|R0
argument_list|)
block|,
name|context_offset
argument_list|(
name|R1
argument_list|)
block|,
name|context_offset
argument_list|(
name|R2
argument_list|)
block|,
name|context_offset
argument_list|(
name|R3
argument_list|)
block|,
name|context_offset
argument_list|(
name|R4
argument_list|)
block|,
name|context_offset
argument_list|(
name|R5
argument_list|)
block|,
name|context_offset
argument_list|(
name|R6
argument_list|)
block|,
name|context_offset
argument_list|(
name|R7
argument_list|)
block|,
name|context_offset
argument_list|(
name|R8
argument_list|)
block|,
name|context_offset
argument_list|(
name|R9
argument_list|)
block|,
name|context_offset
argument_list|(
name|R10
argument_list|)
block|,
name|context_offset
argument_list|(
name|R11
argument_list|)
block|,
name|context_offset
argument_list|(
name|R12
argument_list|)
block|,
name|context_offset
argument_list|(
name|Sp
argument_list|)
block|,
name|context_offset
argument_list|(
name|Lr
argument_list|)
block|,
name|context_offset
argument_list|(
name|Pc
argument_list|)
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|context_offset
argument_list|(
name|Psr
argument_list|)
block|,
endif|#
directive|endif
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer into a CONTEXT field indexed by gdb register number.    Return a pointer to an address pointing to zero if there is no    corresponding CONTEXT field for the given register number.  */
end_comment

begin_function
specifier|static
name|ULONG
modifier|*
name|regptr
parameter_list|(
name|LPCONTEXT
name|c
parameter_list|,
name|int
name|r
parameter_list|)
block|{
specifier|static
name|ULONG
name|zero
init|=
literal|0
decl_stmt|;
name|ULONG
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mappings
index|[
name|r
index|]
operator|<
literal|0
condition|)
name|p
operator|=
operator|&
name|zero
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|ULONG
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|c
operator|)
operator|+
name|mappings
index|[
name|r
index|]
operator|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/******************** Beginning of stub interface ********************/
end_comment

begin_comment
comment|/* Stub interface description:     The Windows CE stub implements a crude RPC.  The hand-held device    connects to gdb using port 7000.  gdb and the stub then communicate    using packets where:     byte 0:              command id (e.g. Create Process)     byte 1-4:    DWORD     byte 1-2:    WORD     byte 1-2:    length    byte 3-n:    arbitrary memory.     The interface is deterministic, i.e., if the stub expects a DWORD then    the gdb server should send a DWORD.  */
end_comment

begin_comment
comment|/* Note:  In the functions below, the `huh' parameter is a string passed from the    function containing a descriptive string concerning the current operation.    This is used for error reporting.     The 'what' parameter is a command id as found in wince-stub.h.     Hopefully, the rest of the parameters are self-explanatory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* communication socket */
end_comment

begin_comment
comment|/* v-style interface for handling varying argyment list error messages.    Displays the error message in a dialog box and exits when user clicks    on OK. */
end_comment

begin_function
specifier|static
name|void
name|vstub_error
parameter_list|(
name|LPCSTR
name|fmt
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The standard way to display an error message and exit. */
end_comment

begin_function
specifier|static
name|void
name|stub_error
parameter_list|(
name|LPCSTR
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vstub_error
argument_list|(
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Standard "oh well" can't communicate error.  Someday this might attempt    synchronization. */
end_comment

begin_function
specifier|static
name|void
name|attempt_resync
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|stub_error
argument_list|(
literal|"lost synchronization with target attempting %s"
argument_list|,
name|huh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read arbitrary stuff from a socket. */
end_comment

begin_function
specifier|static
name|int
name|sockread
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|int
name|s
parameter_list|,
name|void
modifier|*
name|str
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|recv
argument_list|(
name|s
argument_list|,
name|str
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
operator|==
name|n
condition|)
return|return
name|n
return|;
name|attempt_resync
argument_list|(
name|huh
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write arbitrary stuff to a socket. */
end_comment

begin_function
specifier|static
name|int
name|sockwrite
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
specifier|const
name|void
modifier|*
name|str
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|send
argument_list|(
name|s
argument_list|,
name|str
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
operator|==
name|n
condition|)
return|return
name|n
return|;
name|attempt_resync
argument_list|(
name|huh
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output an id/dword to the host */
end_comment

begin_function
specifier|static
name|void
name|putdword
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what
parameter_list|,
name|DWORD
name|n
parameter_list|)
block|{
if|if
condition|(
name|sockwrite
argument_list|(
name|huh
argument_list|,
operator|&
name|what
argument_list|,
sizeof|sizeof
argument_list|(
name|what
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|what
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error writing record id to host for %s"
argument_list|,
name|huh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockwrite
argument_list|(
name|huh
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error writing %s to host."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an id/word to the host */
end_comment

begin_function
specifier|static
name|void
name|putword
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what
parameter_list|,
name|WORD
name|n
parameter_list|)
block|{
if|if
condition|(
name|sockwrite
argument_list|(
name|huh
argument_list|,
operator|&
name|what
argument_list|,
sizeof|sizeof
argument_list|(
name|what
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|what
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error writing record id to host for %s"
argument_list|,
name|huh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockwrite
argument_list|(
name|huh
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error writing %s host."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convenience define for outputting a "gdb_wince_len" type. */
end_comment

begin_define
define|#
directive|define
name|putlen
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|,
name|n
parameter_list|)
value|putword((huh), (what), (gdb_wince_len) (n))
end_define

begin_comment
comment|/* Put an arbitrary block of memory to the gdb host.  This comes in    two chunks an id/dword representing the length and the stream of memory    itself. */
end_comment

begin_function
specifier|static
name|void
name|putmemory
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|mem
parameter_list|,
name|gdb_wince_len
name|len
parameter_list|)
block|{
name|putlen
argument_list|(
name|huh
argument_list|,
name|what
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|short
operator|)
name|len
operator|>
literal|0
operator|)
operator|&&
name|sockwrite
argument_list|(
name|huh
argument_list|,
name|mem
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
name|stub_error
argument_list|(
literal|"error writing %s to host."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the result of an operation to the host.  If res != 0, sends a block of    memory starting at mem of len bytes.  If res == 0, sends -GetLastError () and    avoids sending the mem. */
end_comment

begin_function
specifier|static
name|DWORD
name|getdword
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what_this
parameter_list|)
block|{
name|DWORD
name|n
decl_stmt|;
name|gdb_wince_id
name|what
decl_stmt|;
do|do
if|if
condition|(
name|sockread
argument_list|(
name|huh
argument_list|,
name|s
argument_list|,
operator|&
name|what
argument_list|,
sizeof|sizeof
argument_list|(
name|what
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|what
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error getting record type from host - %s."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
do|while
condition|(
name|what_this
operator|!=
name|what
condition|)
do|;
if|if
condition|(
name|sockread
argument_list|(
name|huh
argument_list|,
name|s
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error getting %s from host."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Get a an ID (possibly) and a WORD from the host gdb.    Don't bother with the id if the main loop has already    read it. */
end_comment

begin_function
specifier|static
name|WORD
name|getword
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what_this
parameter_list|)
block|{
name|WORD
name|n
decl_stmt|;
name|gdb_wince_id
name|what
decl_stmt|;
do|do
if|if
condition|(
name|sockread
argument_list|(
name|huh
argument_list|,
name|s
argument_list|,
operator|&
name|what
argument_list|,
sizeof|sizeof
argument_list|(
name|what
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|what
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error getting record type from host - %s."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
do|while
condition|(
name|what_this
operator|!=
name|what
condition|)
do|;
if|if
condition|(
name|sockread
argument_list|(
name|huh
argument_list|,
name|s
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
name|stub_error
argument_list|(
literal|"error getting %s from host."
argument_list|,
name|huh
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Handy defines for getting/putting various types of values. */
end_comment

begin_define
define|#
directive|define
name|gethandle
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|)
value|(HANDLE) getdword ((huh), (what))
end_define

begin_define
define|#
directive|define
name|getpvoid
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|)
value|(LPVOID) getdword ((huh), (what))
end_define

begin_define
define|#
directive|define
name|getlen
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|)
value|(gdb_wince_len) getword ((huh), (what))
end_define

begin_define
define|#
directive|define
name|puthandle
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|,
name|h
parameter_list|)
value|putdword ((huh), (what), (DWORD) (h))
end_define

begin_define
define|#
directive|define
name|putpvoid
parameter_list|(
name|huh
parameter_list|,
name|what
parameter_list|,
name|p
parameter_list|)
value|putdword ((huh), (what), (DWORD) (p))
end_define

begin_comment
comment|/* Retrieve the result of an operation from the stub.  If nbytes< 0) then nbytes    is actually an error and nothing else follows.  Use SetLastError to remember this.    if nbytes> 0, retrieve a block of *nbytes into buf.  */
end_comment

begin_function
name|int
name|getresult
parameter_list|(
name|LPCSTR
name|huh
parameter_list|,
name|gdb_wince_id
name|what
parameter_list|,
name|LPVOID
name|buf
parameter_list|,
name|gdb_wince_len
modifier|*
name|nbytes
parameter_list|)
block|{
name|gdb_wince_len
name|dummy
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
name|NULL
condition|)
name|nbytes
operator|=
operator|&
name|dummy
expr_stmt|;
operator|*
name|nbytes
operator|=
name|getlen
argument_list|(
name|huh
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|short
operator|)
operator|*
name|nbytes
operator|<
literal|0
condition|)
block|{
name|SetLastError
argument_list|(
operator|-
operator|(
name|short
operator|)
operator|*
name|nbytes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|gdb_wince_len
operator|)
name|sockread
argument_list|(
name|huh
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
operator|*
name|nbytes
argument_list|)
operator|!=
operator|*
name|nbytes
condition|)
name|stub_error
argument_list|(
literal|"couldn't read information from wince stub - %s"
argument_list|,
name|huh
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert "narrow" string to "wide".  Manipulates a buffer ring of 8    buffers which hold the translated string.  This is an arbitrary limit    but it is approximately double the current needs of this module.  */
end_comment

begin_function
name|LPWSTR
name|towide
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|gdb_wince_len
modifier|*
name|out_len
parameter_list|)
block|{
specifier|static
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|LPWSTR
name|outs
index|[
literal|8
index|]
init|=
block|{
name|NULL
comment|/*, NULL, etc. */
block|}
decl_stmt|;
name|gdb_wince_len
name|dummy
decl_stmt|;
if|if
condition|(
operator|!
name|out_len
condition|)
name|out_len
operator|=
operator|&
name|dummy
expr_stmt|;
comment|/* First determine the length required to hold the converted string. */
operator|*
name|out_len
operator|=
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
operator|*
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|out_len
condition|)
return|return
name|NULL
return|;
comment|/* The conversion failed */
if|if
condition|(
operator|++
name|n
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|outs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|outs
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* wrap */
comment|/* Allocate space for the converted string, reusing any previously allocated      space, if applicable. Note that if outs[n] is NULL, xrealloc will act as      a malloc (under cygwin, at least).    */
name|outs
index|[
name|n
index|]
operator|=
operator|(
name|LPWSTR
operator|)
name|xrealloc
argument_list|(
name|outs
index|[
name|n
index|]
argument_list|,
operator|*
name|out_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|,
operator|*
name|out_len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|,
name|outs
index|[
name|n
index|]
argument_list|,
operator|*
name|out_len
argument_list|)
expr_stmt|;
return|return
name|outs
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/******************** Emulation routines start here. ********************    The functions below are modelled after their Win32 counterparts.  They are named   similarly to Win32 and take exactly the same arguments except where otherwise noted.   They communicate with the stub on the hand-held device by sending their arguments   over the socket and waiting for results from the socket.    There is one universal change.  In cases where a length is expected to be returned   in a DWORD, we use a gdb_wince_len type instead.  Currently this is an unsigned short   which is smaller than the standard Win32 DWORD.  This is done to minimize unnecessary   traffic since the connection to Windows CE can be slow.  To change this, modify the   typedef in wince-stub.h and change the putlen/getlen macros in this file and in   the stub. */
end_comment

begin_function
specifier|static
name|int
name|create_process
parameter_list|(
name|LPSTR
name|exec_file
parameter_list|,
name|LPSTR
name|args
parameter_list|,
name|DWORD
name|flags
parameter_list|,
name|PROCESS_INFORMATION
modifier|*
name|pi
parameter_list|)
block|{
name|gdb_wince_len
name|len
decl_stmt|;
name|LPWSTR
name|buf
decl_stmt|;
name|buf
operator|=
name|towide
argument_list|(
name|exec_file
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|putmemory
argument_list|(
literal|"CreateProcess exec_file"
argument_list|,
name|GDB_CREATEPROCESS
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|=
name|towide
argument_list|(
name|args
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|putmemory
argument_list|(
literal|"CreateProcess args"
argument_list|,
name|GDB_CREATEPROCESS
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putdword
argument_list|(
literal|"CreateProcess flags"
argument_list|,
name|GDB_CREATEPROCESS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"CreateProcess result"
argument_list|,
name|GDB_CREATEPROCESS
argument_list|,
name|pi
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emulate TerminateProcess.  Don't bother with the second argument since CE    ignores it.  */
end_comment

begin_function
specifier|static
name|int
name|terminate_process
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
name|gdb_wince_result
name|res
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"TerminateProcess handle"
argument_list|,
name|GDB_TERMINATEPROCESS
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"TerminateProcess result"
argument_list|,
name|GDB_TERMINATEPROCESS
argument_list|,
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_debug_event
parameter_list|(
name|DEBUG_EVENT
modifier|*
name|ev
parameter_list|,
name|DWORD
name|ms
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|putdword
argument_list|(
literal|"WaitForDebugEvent ms"
argument_list|,
name|GDB_WAITFORDEBUGEVENT
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"WaitForDebugEvent event"
argument_list|,
name|GDB_WAITFORDEBUGEVENT
argument_list|,
name|ev
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_thread_context
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|CONTEXT
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"GetThreadContext handle"
argument_list|,
name|GDB_GETTHREADCONTEXT
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putdword
argument_list|(
literal|"GetThreadContext flags"
argument_list|,
name|GDB_GETTHREADCONTEXT
argument_list|,
name|c
operator|->
name|ContextFlags
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"GetThreadContext context"
argument_list|,
name|GDB_GETTHREADCONTEXT
argument_list|,
name|c
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_thread_context
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|CONTEXT
modifier|*
name|c
parameter_list|)
block|{
name|gdb_wince_result
name|res
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"SetThreadContext handle"
argument_list|,
name|GDB_SETTHREADCONTEXT
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putmemory
argument_list|(
literal|"SetThreadContext context"
argument_list|,
name|GDB_SETTHREADCONTEXT
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"SetThreadContext context"
argument_list|,
name|GDB_SETTHREADCONTEXT
argument_list|,
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_process_memory
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|LPCVOID
name|where
parameter_list|,
name|LPVOID
name|buf
parameter_list|,
name|gdb_wince_len
name|len
parameter_list|,
name|gdb_wince_len
modifier|*
name|nbytes
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"ReadProcessMemory handle"
argument_list|,
name|GDB_READPROCESSMEMORY
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putpvoid
argument_list|(
literal|"ReadProcessMemory location"
argument_list|,
name|GDB_READPROCESSMEMORY
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|putlen
argument_list|(
literal|"ReadProcessMemory size"
argument_list|,
name|GDB_READPROCESSMEMORY
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"ReadProcessMemory buf"
argument_list|,
name|GDB_READPROCESSMEMORY
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_process_memory
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|LPCVOID
name|where
parameter_list|,
name|LPCVOID
name|buf
parameter_list|,
name|gdb_wince_len
name|len
parameter_list|,
name|gdb_wince_len
modifier|*
name|nbytes
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"WriteProcessMemory handle"
argument_list|,
name|GDB_WRITEPROCESSMEMORY
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putpvoid
argument_list|(
literal|"WriteProcessMemory location"
argument_list|,
name|GDB_WRITEPROCESSMEMORY
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|putmemory
argument_list|(
literal|"WriteProcProcessMemory buf"
argument_list|,
name|GDB_WRITEPROCESSMEMORY
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"WriteProcessMemory result"
argument_list|,
name|GDB_WRITEPROCESSMEMORY
argument_list|,
name|nbytes
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_read_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|gdb_wince_len
name|nbytes
decl_stmt|;
if|if
condition|(
operator|!
name|read_process_memory
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|LPCVOID
operator|)
name|memaddr
argument_list|,
operator|(
name|LPVOID
operator|)
name|myaddr
argument_list|,
name|len
argument_list|,
operator|&
name|nbytes
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|nbytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_write_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|gdb_wince_len
name|nbytes
decl_stmt|;
if|if
condition|(
operator|!
name|write_process_memory
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|LPCVOID
operator|)
name|memaddr
argument_list|,
operator|(
name|LPCVOID
operator|)
name|myaddr
argument_list|,
name|len
argument_list|,
operator|&
name|nbytes
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|nbytes
return|;
block|}
end_function

begin_comment
comment|/* This is not a standard Win32 function.  It instructs the stub to return TRUE    if the thread referenced by HANDLE h is alive.  */
end_comment

begin_function
specifier|static
name|int
name|thread_alive
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
name|gdb_wince_result
name|res
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"ThreadAlive handle"
argument_list|,
name|GDB_THREADALIVE
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"ThreadAlive result"
argument_list|,
name|GDB_THREADALIVE
argument_list|,
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|suspend_thread
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"SuspendThread handle"
argument_list|,
name|GDB_SUSPENDTHREAD
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|getdword
argument_list|(
literal|"SuspendThread result"
argument_list|,
name|GDB_SUSPENDTHREAD
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_thread
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"ResumeThread handle"
argument_list|,
name|GDB_RESUMETHREAD
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|getdword
argument_list|(
literal|"SuspendThread result"
argument_list|,
name|GDB_RESUMETHREAD
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|continue_debug_event
parameter_list|(
name|DWORD
name|pid
parameter_list|,
name|DWORD
name|tid
parameter_list|,
name|DWORD
name|status
parameter_list|)
block|{
name|gdb_wince_result
name|res
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|putdword
argument_list|(
literal|"ContinueDebugEvent pid"
argument_list|,
name|GDB_CONTINUEDEBUGEVENT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|putdword
argument_list|(
literal|"ContinueDebugEvent tid"
argument_list|,
name|GDB_CONTINUEDEBUGEVENT
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|putdword
argument_list|(
literal|"ContinueDebugEvent status"
argument_list|,
name|GDB_CONTINUEDEBUGEVENT
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|getresult
argument_list|(
literal|"ContinueDebugEvent result"
argument_list|,
name|GDB_CONTINUEDEBUGEVENT
argument_list|,
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|close_handle
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
name|gdb_wince_result
name|res
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|puthandle
argument_list|(
literal|"CloseHandle handle"
argument_list|,
name|GDB_CLOSEHANDLE
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|getresult
argument_list|(
literal|"CloseHandle result"
argument_list|,
name|GDB_CLOSEHANDLE
argument_list|,
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is not a standard Win32 interface.  This function tells the stub    to terminate.  */
end_comment

begin_function
specifier|static
name|void
name|stop_stub
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|putdword
argument_list|(
literal|"Stopping gdb stub"
argument_list|,
name|GDB_STOPSTUB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************** End of emulation routines. ********************/
end_comment

begin_comment
comment|/******************** End of stub interface ********************/
end_comment

begin_define
define|#
directive|define
name|check_for_step
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|)
value|(x)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MIPS
end_ifdef

begin_function
specifier|static
name|void
name|undoSStep
parameter_list|(
name|thread_info
modifier|*
name|th
parameter_list|)
block|{
if|if
condition|(
name|th
operator|->
name|stepped
condition|)
block|{
name|memory_remove_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
name|th
operator|->
name|stepped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wince_software_single_step
parameter_list|(
name|enum
name|target_signal
name|ignore
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|unsigned
name|long
name|pc
decl_stmt|;
name|thread_info
modifier|*
name|th
init|=
name|current_thread
decl_stmt|;
comment|/* Info on currently selected thread */
name|CORE_ADDR
name|mips_next_pc
argument_list|(
name|CORE_ADDR
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insert_breakpoints_p
condition|)
block|{
name|undoSStep
argument_list|(
name|th
argument_list|)
expr_stmt|;
return|return;
block|}
name|th
operator|->
name|stepped
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|th
operator|->
name|step_pc
operator|=
name|mips_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|th
operator|->
name|step_prev
operator|=
literal|0
expr_stmt|;
name|memory_insert_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_elif
elif|#
directive|elif
name|SHx
end_elif

begin_comment
comment|/* Renesas SH architecture instruction encoding masks */
end_comment

begin_define
define|#
directive|define
name|COND_BR_MASK
value|0xff00
end_define

begin_define
define|#
directive|define
name|UCOND_DBR_MASK
value|0xe000
end_define

begin_define
define|#
directive|define
name|UCOND_RBR_MASK
value|0xf0df
end_define

begin_define
define|#
directive|define
name|TRAPA_MASK
value|0xff00
end_define

begin_define
define|#
directive|define
name|COND_DISP
value|0x00ff
end_define

begin_define
define|#
directive|define
name|UCOND_DISP
value|0x0fff
end_define

begin_define
define|#
directive|define
name|UCOND_REG
value|0x0f00
end_define

begin_comment
comment|/* Renesas SH instruction opcodes */
end_comment

begin_define
define|#
directive|define
name|BF_INSTR
value|0x8b00
end_define

begin_define
define|#
directive|define
name|BT_INSTR
value|0x8900
end_define

begin_define
define|#
directive|define
name|BRA_INSTR
value|0xa000
end_define

begin_define
define|#
directive|define
name|BSR_INSTR
value|0xb000
end_define

begin_define
define|#
directive|define
name|JMP_INSTR
value|0x402b
end_define

begin_define
define|#
directive|define
name|JSR_INSTR
value|0x400b
end_define

begin_define
define|#
directive|define
name|RTS_INSTR
value|0x000b
end_define

begin_define
define|#
directive|define
name|RTE_INSTR
value|0x002b
end_define

begin_define
define|#
directive|define
name|TRAPA_INSTR
value|0xc300
end_define

begin_define
define|#
directive|define
name|SSTEP_INSTR
value|0xc3ff
end_define

begin_define
define|#
directive|define
name|T_BIT_MASK
value|0x0001
end_define

begin_function
specifier|static
name|CORE_ADDR
name|sh_get_next_pc
parameter_list|(
name|CONTEXT
modifier|*
name|c
parameter_list|)
block|{
name|short
modifier|*
name|instrMem
decl_stmt|;
name|int
name|displacement
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
name|c
operator|->
name|Fir
expr_stmt|;
name|opcode
operator|=
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|c
operator|->
name|Fir
argument_list|,
sizeof|sizeof
argument_list|(
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|&
name|COND_BR_MASK
operator|)
operator|==
name|BT_INSTR
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|Psr
operator|&
name|T_BIT_MASK
condition|)
block|{
name|displacement
operator|=
operator|(
name|opcode
operator|&
name|COND_DISP
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|displacement
operator|&
literal|0x80
condition|)
name|displacement
operator||=
literal|0xffffff00
expr_stmt|;
comment|/* 	     * Remember PC points to second instr. 	     * after PC of branch ... so add 4 	   */
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|c
operator|->
name|Fir
operator|+
name|displacement
operator|+
literal|4
operator|)
expr_stmt|;
block|}
else|else
name|instrMem
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
name|COND_BR_MASK
operator|)
operator|==
name|BF_INSTR
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|Psr
operator|&
name|T_BIT_MASK
condition|)
name|instrMem
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|displacement
operator|=
operator|(
name|opcode
operator|&
name|COND_DISP
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|displacement
operator|&
literal|0x80
condition|)
name|displacement
operator||=
literal|0xffffff00
expr_stmt|;
comment|/* 	     * Remember PC points to second instr. 	     * after PC of branch ... so add 4 	   */
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|c
operator|->
name|Fir
operator|+
name|displacement
operator|+
literal|4
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
name|UCOND_DBR_MASK
operator|)
operator|==
name|BRA_INSTR
condition|)
block|{
name|displacement
operator|=
operator|(
name|opcode
operator|&
name|UCOND_DISP
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|displacement
operator|&
literal|0x0800
condition|)
name|displacement
operator||=
literal|0xfffff000
expr_stmt|;
comment|/* 	 * Remember PC points to second instr. 	 * after PC of branch ... so add 4        */
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|c
operator|->
name|Fir
operator|+
name|displacement
operator|+
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
name|UCOND_RBR_MASK
operator|)
operator|==
name|JSR_INSTR
condition|)
block|{
name|reg
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|opcode
operator|&
name|UCOND_REG
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|*
name|regptr
argument_list|(
name|c
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|RTS_INSTR
condition|)
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
name|c
operator|->
name|PR
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|RTE_INSTR
condition|)
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|*
name|regptr
argument_list|(
name|c
argument_list|,
literal|15
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
name|TRAPA_MASK
operator|)
operator|==
name|TRAPA_INSTR
condition|)
name|instrMem
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|opcode
operator|&
operator|~
name|TRAPA_MASK
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
else|else
name|instrMem
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|instrMem
return|;
block|}
end_function

begin_comment
comment|/* Single step (in a painstaking fashion) by inspecting the current    instruction and setting a breakpoint on the "next" instruction    which would be executed.  This code hails from sh-stub.c.  */
end_comment

begin_function
specifier|static
name|void
name|undoSStep
parameter_list|(
name|thread_info
modifier|*
name|th
parameter_list|)
block|{
if|if
condition|(
name|th
operator|->
name|stepped
condition|)
block|{
name|memory_remove_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
name|th
operator|->
name|stepped
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Single step (in a painstaking fashion) by inspecting the current    instruction and setting a breakpoint on the "next" instruction    which would be executed.  This code hails from sh-stub.c.  */
end_comment

begin_function
name|void
name|wince_software_single_step
parameter_list|(
name|enum
name|target_signal
name|ignore
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
init|=
name|current_thread
decl_stmt|;
comment|/* Info on currently selected thread */
if|if
condition|(
operator|!
name|insert_breakpoints_p
condition|)
block|{
name|undoSStep
argument_list|(
name|th
argument_list|)
expr_stmt|;
return|return;
block|}
name|th
operator|->
name|stepped
operator|=
literal|1
expr_stmt|;
name|th
operator|->
name|step_pc
operator|=
name|sh_get_next_pc
argument_list|(
operator|&
name|th
operator|->
name|context
argument_list|)
expr_stmt|;
name|th
operator|->
name|step_prev
operator|=
literal|0
expr_stmt|;
name|memory_insert_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|ARM
argument_list|)
end_elif

begin_undef
undef|#
directive|undef
name|check_for_step
end_undef

begin_function
specifier|static
name|enum
name|target_signal
name|check_for_step
parameter_list|(
name|DEBUG_EVENT
modifier|*
name|ev
parameter_list|,
name|enum
name|target_signal
name|x
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
init|=
name|thread_rec
argument_list|(
name|ev
operator|->
name|dwThreadId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|th
operator|->
name|stepped
operator|&&
name|th
operator|->
name|step_pc
operator|==
operator|(
name|CORE_ADDR
operator|)
name|ev
operator|->
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
condition|)
return|return
name|TARGET_SIGNAL_TRAP
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Single step (in a painstaking fashion) by inspecting the current    instruction and setting a breakpoint on the "next" instruction    which would be executed.  This code hails from sh-stub.c.  */
end_comment

begin_function
specifier|static
name|void
name|undoSStep
parameter_list|(
name|thread_info
modifier|*
name|th
parameter_list|)
block|{
if|if
condition|(
name|th
operator|->
name|stepped
condition|)
block|{
name|memory_remove_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
name|th
operator|->
name|stepped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wince_software_single_step
parameter_list|(
name|enum
name|target_signal
name|ignore
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|unsigned
name|long
name|pc
decl_stmt|;
name|thread_info
modifier|*
name|th
init|=
name|current_thread
decl_stmt|;
comment|/* Info on currently selected thread */
name|CORE_ADDR
name|mips_next_pc
argument_list|(
name|CORE_ADDR
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insert_breakpoints_p
condition|)
block|{
name|undoSStep
argument_list|(
name|th
argument_list|)
expr_stmt|;
return|return;
block|}
name|th
operator|->
name|stepped
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|th
operator|->
name|step_pc
operator|=
name|arm_get_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|th
operator|->
name|step_prev
operator|=
literal|0
expr_stmt|;
name|memory_insert_breakpoint
argument_list|(
name|th
operator|->
name|step_pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|th
operator|->
name|step_prev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find a thread record given a thread id.    If get_context then also retrieve the context for this    thread. */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|thread_rec
parameter_list|(
name|DWORD
name|id
parameter_list|,
name|int
name|get_context
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
operator|(
name|th
operator|=
name|th
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|th
operator|->
name|id
operator|==
name|id
condition|)
block|{
if|if
condition|(
operator|!
name|th
operator|->
name|suspend_count
operator|&&
name|get_context
condition|)
block|{
if|if
condition|(
name|get_context
operator|>
literal|0
operator|&&
name|th
operator|!=
name|this_thread
condition|)
name|th
operator|->
name|suspend_count
operator|=
name|suspend_thread
argument_list|(
name|th
operator|->
name|h
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|get_context
operator|<
literal|0
condition|)
name|th
operator|->
name|suspend_count
operator|=
operator|-
literal|1
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
name|CONTEXT_DEBUGGER
expr_stmt|;
name|get_thread_context
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
return|return
name|th
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add a thread to the thread list */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|child_add_thread
parameter_list|(
name|DWORD
name|id
parameter_list|,
name|HANDLE
name|h
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
if|if
condition|(
operator|(
name|th
operator|=
name|thread_rec
argument_list|(
name|id
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
return|return
name|th
return|;
name|th
operator|=
operator|(
name|thread_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|th
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|th
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|th
operator|->
name|next
operator|=
name|thread_head
operator|.
name|next
expr_stmt|;
name|thread_head
operator|.
name|next
operator|=
name|th
expr_stmt|;
name|add_thread
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|th
return|;
block|}
end_function

begin_comment
comment|/* Clear out any old thread list and reintialize it to a    pristine state. */
end_comment

begin_function
specifier|static
name|void
name|child_init_thread_list
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
init|=
operator|&
name|thread_head
decl_stmt|;
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: child_init_thread_list\n"
operator|)
argument_list|)
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|th
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|thread_info
modifier|*
name|here
init|=
name|th
operator|->
name|next
decl_stmt|;
name|th
operator|->
name|next
operator|=
name|here
operator|->
name|next
expr_stmt|;
operator|(
name|void
operator|)
name|close_handle
argument_list|(
name|here
operator|->
name|h
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete a thread from the list of threads */
end_comment

begin_function
specifier|static
name|void
name|child_delete_thread
parameter_list|(
name|DWORD
name|id
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[Deleting %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|delete_thread
argument_list|(
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
name|th
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|th
operator|->
name|next
operator|->
name|id
operator|!=
name|id
condition|;
name|th
operator|=
name|th
operator|->
name|next
control|)
continue|continue;
if|if
condition|(
name|th
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|thread_info
modifier|*
name|here
init|=
name|th
operator|->
name|next
decl_stmt|;
name|th
operator|->
name|next
operator|=
name|here
operator|->
name|next
expr_stmt|;
name|close_handle
argument_list|(
name|here
operator|->
name|h
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check
parameter_list|(
name|BOOL
name|ok
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
name|printf_filtered
argument_list|(
literal|"error return %s:%d was %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_child_fetch_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
name|supply_register
argument_list|(
name|r
argument_list|,
operator|(
name|char
operator|*
operator|)
name|regptr
argument_list|(
operator|&
name|current_thread
operator|->
name|context
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|do_child_fetch_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|child_fetch_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|current_thread
operator|=
name|thread_rec
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|do_child_fetch_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_child_store_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|deprecated_read_register_gen
argument_list|(
name|r
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|current_thread
operator|->
name|context
operator|)
operator|+
name|mappings
index|[
name|r
index|]
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|do_child_store_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store a new register value into the current thread context */
end_comment

begin_function
specifier|static
name|void
name|child_store_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|current_thread
operator|=
name|thread_rec
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|do_child_store_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for child to do something.  Return pid of child, or -1 in case    of error; store status through argument pointer OURSTATUS.  */
end_comment

begin_function
specifier|static
name|int
name|handle_load_dll
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|LOAD_DLL_DEBUG_INFO
modifier|*
name|event
init|=
operator|&
name|current_event
operator|.
name|u
operator|.
name|LoadDll
decl_stmt|;
name|char
name|dll_buf
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|imgp
decl_stmt|,
modifier|*
name|dll_name
decl_stmt|,
modifier|*
name|dll_basename
decl_stmt|;
name|int
name|len
decl_stmt|;
name|dll_buf
index|[
literal|0
index|]
operator|=
name|dll_buf
index|[
sizeof|sizeof
argument_list|(
name|dll_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|lpImageName
condition|)
return|return
literal|1
return|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|dll_buf
operator|,
name|imgp
operator|=
name|event
operator|->
name|lpImageName
init|;
name|bufp
operator|<
name|dll_buf
operator|+
sizeof|sizeof
argument_list|(
name|dll_buf
argument_list|)
condition|;
name|bufp
operator|+=
literal|16
operator|,
name|imgp
operator|+=
literal|16
control|)
block|{
name|gdb_wince_len
name|nbytes
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|read_process_memory
argument_list|(
name|current_process_handle
argument_list|,
name|imgp
argument_list|,
name|bufp
argument_list|,
literal|16
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nbytes
operator|&&
name|bufp
operator|==
name|dll_buf
condition|)
return|return
literal|1
return|;
comment|/* couldn't read it */
for|for
control|(
name|p
operator|=
name|bufp
init|;
name|p
operator|<
name|bufp
operator|+
name|nbytes
condition|;
name|p
operator|++
control|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|event
operator|->
name|fUnicode
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nbytes
condition|)
break|break;
block|}
name|out
label|:
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|1
return|;
if|#
directive|if
literal|0
block|dll_buf[len] = '\0';
endif|#
directive|endif
name|dll_name
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll_name
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|event
operator|->
name|fUnicode
condition|)
name|memcpy
argument_list|(
name|dll_name
argument_list|,
name|dll_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|dll_buf
argument_list|,
name|len
argument_list|,
name|dll_name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|dll_name
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* FIXME!! It would be nice to define one symbol which pointed to the      front of the dll if we can't find any symbols. */
if|if
condition|(
operator|!
operator|(
name|dll_basename
operator|=
name|strrchr
argument_list|(
name|dll_name
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|dll_basename
operator|=
name|dll_name
expr_stmt|;
else|else
name|dll_basename
operator|++
expr_stmt|;
comment|/* The symbols in a dll are offset by 0x1000, which is the      the offset from 0 of the first byte in an image - because      of the file header and the section alignment.       FIXME: Is this the real reason that we need the 0x1000 ? */
name|printf_unfiltered
argument_list|(
literal|"%x:%s"
argument_list|,
name|event
operator|->
name|lpBaseOfDll
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle DEBUG_STRING output from child process. */
end_comment

begin_function
specifier|static
name|void
name|handle_output_debug_string
parameter_list|(
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|char
name|p
index|[
literal|256
index|]
decl_stmt|;
name|char
name|s
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|gdb_wince_len
name|nbytes_read
decl_stmt|;
name|gdb_wince_len
name|nbytes
init|=
name|current_event
operator|.
name|u
operator|.
name|DebugString
operator|.
name|nDebugStringLength
decl_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|255
condition|)
name|nbytes
operator|=
literal|255
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_process_memory
argument_list|(
name|current_process_handle
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|DebugString
operator|.
name|lpDebugStringData
argument_list|,
operator|&
name|p
argument_list|,
name|nbytes
argument_list|,
operator|&
name|nbytes_read
argument_list|)
operator|||
operator|!
operator|*
name|p
condition|)
return|return;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|p
argument_list|,
operator|(
name|int
operator|)
name|nbytes_read
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|q
operator|=
literal|'\r'
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
name|warning
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle target exceptions. */
end_comment

begin_function
specifier|static
name|int
name|handle_exception
parameter_list|(
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
if|#
directive|if
literal|0
block|if (current_event.u.Exception.dwFirstChance)     return 0;
endif|#
directive|endif
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
switch|switch
condition|(
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionCode
condition|)
block|{
case|case
name|EXCEPTION_ACCESS_VIOLATION
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception ACCESS_VIOLATION at 0x%08x\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
name|STATUS_STACK_OVERFLOW
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception STACK_OVERFLOW at 0x%08x\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
name|EXCEPTION_BREAKPOINT
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception BREAKPOINT at 0x%08x\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|DBG_CONTROL_C
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception CONTROL_C at 0x%08x\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
comment|/* User typed CTRL-C.  Continue with this status */
name|last_sig
operator|=
name|SIGINT
expr_stmt|;
comment|/* FIXME - should check pass state */
break|break;
case|case
name|EXCEPTION_SINGLE_STEP
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception SINGLE_STEP at 0x%08x\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|EXCEPTION_ILLEGAL_INSTRUCTION
case|:
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"gdb: Target exception SINGLE_ILL at 0x%08x\n"
operator|,
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|check_for_step
argument_list|(
operator|&
name|current_event
argument_list|,
name|TARGET_SIGNAL_ILL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This may be a structured exception handling exception.  In 	 that case, we want to let the program try to handle it, and 	 only break if we see the exception a second time.  */
name|printf_unfiltered
argument_list|(
literal|"gdb: unknown target exception 0x%08x at 0x%08x\n"
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionCode
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
block|}
name|exception_count
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Resume all artificially suspended threads if we are continuing    execution */
end_comment

begin_function
specifier|static
name|BOOL
name|child_continue
parameter_list|(
name|DWORD
name|continue_status
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|thread_info
modifier|*
name|th
decl_stmt|;
name|BOOL
name|res
decl_stmt|;
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"ContinueDebugEvent (cpid=%d, ctid=%d, DBG_CONTINUE);\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|continue_debug_event
argument_list|(
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|continue_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
operator|(
name|th
operator|=
name|th
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|(
operator|(
name|id
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|id
operator|==
name|th
operator|->
name|id
operator|)
operator|)
operator|&&
name|th
operator|->
name|suspend_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|th
operator|->
name|suspend_count
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|resume_thread
argument_list|(
name|th
operator|->
name|h
argument_list|)
expr_stmt|;
name|th
operator|->
name|suspend_count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Get the next event from the child.  Return 1 if the event requires    handling by WFI (or whatever).  */
end_comment

begin_function
specifier|static
name|int
name|get_child_debug_event
parameter_list|(
name|int
name|pid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|,
name|DWORD
name|target_event_code
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|breakout
init|=
literal|0
decl_stmt|;
name|BOOL
name|debug_event
decl_stmt|;
name|DWORD
name|continue_status
decl_stmt|,
name|event_code
decl_stmt|;
name|thread_info
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
specifier|static
name|thread_info
name|dummy_thread_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|debug_event
operator|=
name|wait_for_debug_event
argument_list|(
operator|&
name|current_event
argument_list|,
literal|1000
argument_list|)
operator|)
condition|)
block|{
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|event_count
operator|++
expr_stmt|;
name|continue_status
operator|=
name|DBG_CONTINUE
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
name|event_code
operator|=
name|current_event
operator|.
name|dwDebugEventCode
expr_stmt|;
name|breakout
operator|=
name|event_code
operator|==
name|target_event_code
expr_stmt|;
switch|switch
condition|(
name|event_code
condition|)
block|{
case|case
name|CREATE_THREAD_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%x code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"CREATE_THREAD_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
comment|/* Record the existence of this thread */
name|th
operator|=
name|child_add_thread
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|CreateThread
operator|.
name|hThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_THREAD_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXIT_THREAD_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|child_delete_thread
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|)
expr_stmt|;
name|th
operator|=
operator|&
name|dummy_thread_info
expr_stmt|;
break|break;
case|case
name|CREATE_PROCESS_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"CREATE_PROCESS_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|current_process_handle
operator|=
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hProcess
expr_stmt|;
name|main_thread_id
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|main_thread_id
argument_list|)
expr_stmt|;
comment|/* Add the main thread */
name|th
operator|=
name|child_add_thread
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_PROCESS_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXIT_PROCESS_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
name|current_event
operator|.
name|u
operator|.
name|ExitProcess
operator|.
name|dwExitCode
expr_stmt|;
name|close_handle
argument_list|(
name|current_process_handle
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|current_event
operator|.
name|dwProcessId
expr_stmt|;
name|breakout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LOAD_DLL_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"LOAD_DLL_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|catch_errors
argument_list|(
name|handle_load_dll
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
comment|/* mark all regs invalid */
break|break;
case|case
name|UNLOAD_DLL_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"UNLOAD_DLL_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: don't know what to do here */
case|case
name|EXCEPTION_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXCEPTION_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle_exception
argument_list|(
name|ourstatus
argument_list|)
condition|)
operator|*
name|retval
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
else|else
block|{
name|continue_status
operator|=
name|DBG_EXCEPTION_NOT_HANDLED
expr_stmt|;
name|breakout
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|OUTPUT_DEBUG_STRING_EVENT
case|:
comment|/* message from the kernel */
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"OUTPUT_DEBUG_STRING_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|handle_output_debug_string
argument_list|(
name|ourstatus
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_unfiltered
argument_list|(
literal|"gdb: kernel event for pid=%d tid=%d\n"
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|current_event
operator|.
name|dwThreadId
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"                 unknown event code %d\n"
argument_list|,
name|current_event
operator|.
name|dwDebugEventCode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|breakout
condition|)
name|this_thread
operator|=
name|current_thread
operator|=
name|th
condition|?
else|:
name|thread_rec
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|child_continue
argument_list|(
name|continue_status
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|breakout
return|;
block|}
end_function

begin_comment
comment|/* Wait for interesting events to occur in the target process. */
end_comment

begin_function
specifier|static
name|ptid_t
name|child_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|DWORD
name|event_code
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
comment|/* We loop when we get a non-standard exception rather than return      with a SPURIOUS because resume can try and step or modify things,      which needs a current_thread->h.  But some of these exceptions mark      the birth or death of threads, which mean that the current thread      isn't necessarily what you think it is. */
while|while
condition|(
literal|1
condition|)
if|if
condition|(
name|get_child_debug_event
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|,
name|EXCEPTION_DEBUG_EVENT
argument_list|,
operator|&
name|retval
argument_list|)
condition|)
return|return
name|pid_to_ptid
argument_list|(
name|retval
argument_list|)
return|;
else|else
block|{
name|int
name|detach
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ui_loop_hook
operator|!=
name|NULL
condition|)
name|detach
operator|=
name|ui_loop_hook
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|detach
condition|)
name|child_kill_inferior
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|child_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of child %s.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_open
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FACTOR
value|(0x19db1ded53ea710LL)
end_define

begin_define
define|#
directive|define
name|NSPERSEC
value|10000000
end_define

begin_comment
comment|/* Convert a Win32 time to "UNIX" format. */
end_comment

begin_function
name|long
name|to_time_t
parameter_list|(
name|FILETIME
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* A file time is the number of 100ns since jan 1 1601      stuffed into two long words.      A time_t is the number of seconds since jan 1 1970.  */
name|long
name|rem
decl_stmt|;
name|long
name|long
name|x
init|=
operator|(
operator|(
name|long
name|long
operator|)
name|ptr
operator|->
name|dwHighDateTime
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|ptr
operator|->
name|dwLowDateTime
operator|)
decl_stmt|;
name|x
operator|-=
name|FACTOR
expr_stmt|;
comment|/* number of 100ns between 1601 and 1970 */
name|rem
operator|=
name|x
operator|%
operator|(
operator|(
name|long
name|long
operator|)
name|NSPERSEC
operator|)
expr_stmt|;
name|rem
operator|+=
operator|(
name|NSPERSEC
operator|/
literal|2
operator|)
expr_stmt|;
name|x
operator|/=
operator|(
name|long
name|long
operator|)
name|NSPERSEC
expr_stmt|;
comment|/* number of 100ns in a second */
name|x
operator|+=
call|(
name|long
name|long
call|)
argument_list|(
name|rem
operator|/
name|NSPERSEC
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Upload a file to the remote device depending on the user's    'set remoteupload' specification. */
end_comment

begin_function
name|char
modifier|*
name|upload_to_device
parameter_list|(
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
name|remote_directory
condition|?
else|:
literal|"\\gdb"
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|static
name|char
modifier|*
name|remotefile
init|=
name|NULL
decl_stmt|;
name|LPWSTR
name|wstr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|DWORD
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_to
init|=
name|to
decl_stmt|;
name|FILETIME
name|crtime
decl_stmt|,
name|actime
decl_stmt|,
name|wrtime
decl_stmt|;
name|time_t
name|utime
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Look for a path separator and only use trailing part. */
while|while
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|to
argument_list|,
literal|"/\\"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|to
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|to
condition|)
name|error
argument_list|(
literal|"no filename found to upload - %s."
argument_list|,
name|in_to
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
expr_stmt|;
name|remotefile
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|remotefile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remotefile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|remotefile
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|remotefile
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|upload_when
operator|==
name|UPLOAD_NEVER
condition|)
return|return
name|remotefile
return|;
comment|/* Don't bother uploading. */
comment|/* Open the source. */
if|if
condition|(
operator|(
name|fd
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
name|TRUE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|from
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"couldn't open %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Get the time for later comparison. */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|st
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Always attempt to create the directory on the remote system. */
name|wstr
operator|=
name|towide
argument_list|(
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CeCreateDirectory
argument_list|(
name|wstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Attempt to open the remote file, creating it if it doesn't exist. */
name|wstr
operator|=
name|towide
argument_list|(
name|remotefile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|CeCreateFile
argument_list|(
name|wstr
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_ALWAYS
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Some kind of problem? */
name|err
operator|=
name|CeGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
name|error
argument_list|(
literal|"error opening file \"%s\".  Windows error %d."
argument_list|,
name|remotefile
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|CeGetFileTime
argument_list|(
name|h
argument_list|,
operator|&
name|crtime
argument_list|,
operator|&
name|actime
argument_list|,
operator|&
name|wrtime
argument_list|)
expr_stmt|;
name|utime
operator|=
name|to_time_t
argument_list|(
operator|&
name|wrtime
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (utime< st.st_mtime)     {       char buf[80];       strcpy (buf, ctime(&utime));       printf ("%s< %s\n", buf, ctime(&st.st_mtime));     }
endif|#
directive|endif
comment|/* See if we need to upload the file. */
if|if
condition|(
name|upload_when
operator|==
name|UPLOAD_ALWAYS
operator|||
name|err
operator|!=
name|ERROR_ALREADY_EXISTS
operator|||
operator|!
name|CeGetFileTime
argument_list|(
name|h
argument_list|,
operator|&
name|crtime
argument_list|,
operator|&
name|actime
argument_list|,
operator|&
name|wrtime
argument_list|)
operator|||
name|to_time_t
argument_list|(
operator|&
name|wrtime
argument_list|)
operator|<
name|st
operator|.
name|st_mtime
condition|)
block|{
name|DWORD
name|nbytes
decl_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Upload the file. */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|CeWriteFile
argument_list|(
name|h
argument_list|,
name|buf
argument_list|,
operator|(
name|DWORD
operator|)
name|n
argument_list|,
operator|&
name|nbytes
argument_list|,
name|NULL
argument_list|)
condition|)
name|error
argument_list|(
literal|"error writing to remote device - %d."
argument_list|,
name|CeGetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CeCloseHandle
argument_list|(
name|h
argument_list|)
condition|)
name|error
argument_list|(
literal|"error closing remote file - %d."
argument_list|,
name|CeGetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|remotefile
return|;
block|}
end_function

begin_comment
comment|/* Initialize the connection to the remote device. */
end_comment

begin_function
specifier|static
name|void
name|wince_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|char
name|args
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|char
modifier|*
name|stub_file_name
decl_stmt|;
name|int
name|s0
decl_stmt|;
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|connection_initialized
condition|)
switch|switch
condition|(
name|CeRapiInit
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|connection_initialized
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|CeRapiUninit
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Can't initialize connection to remote device.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Upload the stub to the handheld device. */
name|stub_file_name
operator|=
name|upload_to_device
argument_list|(
literal|"wince-stub.exe"
argument_list|,
name|WINCE_STUB
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|args
argument_list|,
name|stub_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_add_host
condition|)
block|{
name|strcat
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|-
name|strlen
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"couldn't get hostname of this system."
argument_list|)
expr_stmt|;
block|}
comment|/* Get a socket. */
if|if
condition|(
operator|(
name|s0
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|stub_error
argument_list|(
literal|"Couldn't connect to host system."
argument_list|)
expr_stmt|;
comment|/* Allow rapid reuse of the port. */
name|tmp
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s0
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the information for connecting to the host gdb process. */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|7000
argument_list|)
expr_stmt|;
comment|/* FIXME: This should be configurable */
if|if
condition|(
name|bind
argument_list|(
name|s0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"couldn't bind socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|s0
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"Couldn't open socket for listening.\n"
argument_list|)
expr_stmt|;
comment|/* Start up the stub on the remote device. */
if|if
condition|(
operator|!
name|CeCreateProcess
argument_list|(
name|towide
argument_list|(
name|stub_file_name
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|towide
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unable to start remote stub '%s'.  Windows CE error %d."
argument_list|,
name|stub_file_name
argument_list|,
name|CeGetLastError
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Wait for a connection */
if|if
condition|(
operator|(
name|s
operator|=
name|accept
argument_list|(
name|s0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"couldn't set up server for connection."
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior win32 child process and sets inferior_ptid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().  */
end_comment

begin_function
specifier|static
name|void
name|child_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
name|struct
name|target_waitstatus
name|dummy
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DWORD
name|flags
decl_stmt|,
name|event_code
decl_stmt|;
name|char
modifier|*
name|exec_and_args
decl_stmt|;
if|if
condition|(
operator|!
name|exec_file
condition|)
name|error
argument_list|(
literal|"No executable specified, use `target exec'.\n"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DEBUG_PROCESS
expr_stmt|;
name|wince_initialize
argument_list|()
expr_stmt|;
comment|/* Make sure we've got a connection. */
name|exec_file
operator|=
name|upload_to_device
argument_list|(
name|exec_file
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
condition|)
name|args
operator|++
expr_stmt|;
comment|/* Allocate space for "command<sp>args" */
if|if
condition|(
operator|*
name|args
operator|==
literal|'\0'
condition|)
block|{
name|exec_and_args
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|exec_and_args
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exec_and_args
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|exec_file
operator|+
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|exec_and_args
argument_list|,
literal|"%s %s"
argument_list|,
name|exec_file
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Execute the process */
if|if
condition|(
operator|!
name|create_process
argument_list|(
name|exec_file
argument_list|,
name|exec_and_args
argument_list|,
name|flags
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error creating process %s, (error %d)\n"
argument_list|,
name|exec_file
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|exception_count
operator|=
literal|0
expr_stmt|;
name|event_count
operator|=
literal|0
expr_stmt|;
name|current_process_handle
operator|=
name|pi
operator|.
name|hProcess
expr_stmt|;
name|current_event
operator|.
name|dwProcessId
operator|=
name|pi
operator|.
name|dwProcessId
expr_stmt|;
name|memset
argument_list|(
operator|&
name|current_event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|current_event
argument_list|)
argument_list|)
expr_stmt|;
name|current_event
operator|.
name|dwThreadId
operator|=
name|pi
operator|.
name|dwThreadId
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|child_init_thread_list
argument_list|()
expr_stmt|;
name|child_add_thread
argument_list|(
name|pi
operator|.
name|dwThreadId
argument_list|,
name|pi
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|target_terminal_init
argument_list|()
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Run until process and threads are loaded */
while|while
condition|(
operator|!
name|get_child_debug_event
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
name|CREATE_PROCESS_DEBUG_EVENT
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
continue|continue;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Chile has gone bye-bye. */
end_comment

begin_function
specifier|static
name|void
name|child_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|child_continue
argument_list|(
name|DBG_CONTINUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|stop_stub
argument_list|()
expr_stmt|;
name|CeRapiUninit
argument_list|()
expr_stmt|;
name|connection_initialized
operator|=
literal|0
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move memory from child to/from gdb. */
end_comment

begin_function
name|int
name|child_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|our
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|write
condition|)
name|res
operator|=
name|remote_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|our
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|remote_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|our
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Terminate the process and wait for child to tell us it has completed. */
end_comment

begin_function
name|void
name|child_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|CHECK
argument_list|(
name|terminate_process
argument_list|(
name|current_process_handle
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|child_continue
argument_list|(
name|DBG_CONTINUE
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|wait_for_debug_event
argument_list|(
operator|&
name|current_event
argument_list|,
name|INFINITE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|current_event
operator|.
name|dwDebugEventCode
operator|==
name|EXIT_PROCESS_DEBUG_EVENT
condition|)
break|break;
block|}
name|CHECK
argument_list|(
name|close_handle
argument_list|(
name|current_process_handle
argument_list|)
argument_list|)
expr_stmt|;
name|close_handle
argument_list|(
name|current_thread
operator|->
name|h
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* or just child_mourn_inferior? */
block|}
end_function

begin_comment
comment|/* Resume the child after an exception. */
end_comment

begin_function
name|void
name|child_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
name|DWORD
name|continue_status
init|=
name|last_sig
operator|>
literal|0
operator|&&
name|last_sig
operator|<
name|NSIG
condition|?
name|DBG_EXCEPTION_NOT_HANDLED
else|:
name|DBG_CONTINUE
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|DEBUG_EXEC
argument_list|(
operator|(
literal|"gdb: child_resume (pid=%d, step=%d, sig=%d);\n"
operator|,
name|pid
operator|,
name|step
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
comment|/* Get context for currently selected thread */
name|th
operator|=
name|thread_rec
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|context
operator|.
name|ContextFlags
condition|)
block|{
name|CHECK
argument_list|(
name|set_thread_context
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allow continuing with the same signal that interrupted us.      Otherwise complain. */
if|if
condition|(
name|sig
operator|&&
name|sig
operator|!=
name|last_sig
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Can't send signals to the child.  signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|last_sig
operator|=
literal|0
expr_stmt|;
name|child_continue
argument_list|(
name|continue_status
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|int
name|child_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_close
parameter_list|(
name|void
parameter_list|)
block|{
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: child_close, inferior_ptid=%d\n"
operator|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Explicitly upload file to remotedir */
end_comment

begin_function
specifier|static
name|void
name|child_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|upload_to_device
argument_list|(
name|file
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_child_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|child_ops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|child_ops
argument_list|)
argument_list|)
expr_stmt|;
name|child_ops
operator|.
name|to_shortname
operator|=
operator|(
name|char
operator|*
operator|)
literal|"child"
expr_stmt|;
name|child_ops
operator|.
name|to_longname
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Windows CE process"
expr_stmt|;
name|child_ops
operator|.
name|to_doc
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Windows CE process (started by the \"run\" command)."
expr_stmt|;
name|child_ops
operator|.
name|to_open
operator|=
name|child_open
expr_stmt|;
name|child_ops
operator|.
name|to_close
operator|=
name|child_close
expr_stmt|;
name|child_ops
operator|.
name|to_resume
operator|=
name|child_resume
expr_stmt|;
name|child_ops
operator|.
name|to_wait
operator|=
name|child_wait
expr_stmt|;
name|child_ops
operator|.
name|to_fetch_registers
operator|=
name|child_fetch_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_store_registers
operator|=
name|child_store_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_prepare_to_store
operator|=
name|child_prepare_to_store
expr_stmt|;
name|child_ops
operator|.
name|to_xfer_memory
operator|=
name|child_xfer_memory
expr_stmt|;
name|child_ops
operator|.
name|to_files_info
operator|=
name|child_files_info
expr_stmt|;
name|child_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_save_ours
operator|=
name|terminal_save_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|child_ops
operator|.
name|to_kill
operator|=
name|child_kill_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_load
operator|=
name|child_load
expr_stmt|;
name|child_ops
operator|.
name|to_create_inferior
operator|=
name|child_create_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
operator|=
name|child_mourn_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_can_run
operator|=
name|child_can_run
expr_stmt|;
name|child_ops
operator|.
name|to_thread_alive
operator|=
name|win32_child_thread_alive
expr_stmt|;
name|child_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|child_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle 'set remoteupload' parameter. */
end_comment

begin_define
define|#
directive|define
name|replace_upload
parameter_list|(
name|what
parameter_list|)
define|\
value|upload_when = what; \       remote_upload = xrealloc (remote_upload, strlen (upload_options[upload_when].name) + 1); \       strcpy (remote_upload, upload_options[upload_when].name);
end_define

begin_function
specifier|static
name|void
name|set_upload_type
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|bad_option
decl_stmt|;
if|if
condition|(
operator|!
name|remote_upload
operator|||
operator|!
name|remote_upload
index|[
literal|0
index|]
condition|)
block|{
name|replace_upload
argument_list|(
name|UPLOAD_NEWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Upload upload_options are: always, newer, never.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|remote_upload
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|upload_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|upload_options
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|len
operator|>=
name|upload_options
index|[
name|i
index|]
operator|.
name|abbrev
operator|&&
name|strncasecmp
argument_list|(
name|remote_upload
argument_list|,
name|upload_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|replace_upload
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|bad_option
operator|=
name|remote_upload
expr_stmt|;
name|replace_upload
argument_list|(
name|UPLOAD_NEWER
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Unknown upload type: %s."
argument_list|,
name|bad_option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_wince
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|set
decl_stmt|;
name|init_child_ops
argument_list|()
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"remotedirectory"
argument_list|,
name|no_class
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_directory
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set directory for remote upload.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|remote_directory
operator|=
name|xstrdup
argument_list|(
name|remote_directory
argument_list|)
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"remoteupload"
argument_list|,
name|no_class
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_upload
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set how to upload executables to remote device.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|set
argument_list|,
name|set_upload_type
argument_list|)
expr_stmt|;
name|set_upload_type
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"debugexec"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_exec
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set whether to display execution in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"remoteaddhost"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_add_host
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"\ Set whether to add this host to remote stub arguments for\n\ debugging over a network."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"debugevents"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_events
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set whether to display kernel events in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"debugmemory"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_memory
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set whether to display memory accesses in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"debugexceptions"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_exceptions
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Set whether to display kernel exceptions in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if the thread referenced by "pid" is alive    by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0    it means that the pid has died.  Otherwise it is assumed to be alive. */
end_comment

begin_function
specifier|static
name|int
name|win32_child_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
return|return
name|thread_alive
argument_list|(
name|thread_rec
argument_list|(
name|pid
argument_list|,
name|FALSE
argument_list|)
operator|->
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert pid to printable format. */
end_comment

begin_function
name|char
modifier|*
name|cygwin_pid_to_str
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|pid
operator|==
name|current_event
operator|.
name|dwProcessId
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread %d.0x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

