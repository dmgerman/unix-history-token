begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Code dealing with register stack frames, for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"sentinel-frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_struct
struct|struct
name|frame_unwind_cache
block|{
name|struct
name|regcache
modifier|*
name|regcache
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
modifier|*
name|sentinel_frame_cache
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|struct
name|frame_unwind_cache
modifier|*
name|cache
init|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|frame_unwind_cache
argument_list|)
decl_stmt|;
name|cache
operator|->
name|regcache
operator|=
name|regcache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_comment
comment|/* Here the register value is taken direct from the register cache.  */
end_comment

begin_function
specifier|static
name|void
name|sentinel_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnum
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|frame_unwind_cache
modifier|*
name|cache
init|=
operator|*
name|this_prologue_cache
decl_stmt|;
comment|/* Describe the register's location.  A reg-frame maps all registers      onto the corresponding hardware register.  */
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_register
expr_stmt|;
operator|*
name|addrp
operator|=
name|register_offset_hack
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
operator|*
name|realnum
operator|=
name|regnum
expr_stmt|;
comment|/* If needed, find and return the value of the register.  */
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
block|{
comment|/* Return the actual value.  */
comment|/* Use the regcache_cooked_read() method so that it, on the fly,          constructs either a raw or pseudo register from the raw          register cache.  */
name|regcache_cooked_read
argument_list|(
name|cache
operator|->
name|regcache
argument_list|,
name|regnum
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sentinel_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
comment|/* The sentinel frame is used as a starting point for creating the      previous (inner most) frame.  That frame's THIS_ID method will be      called to determine the inner most frame's ID.  Not this one.  */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"sentinel_frame_this_id called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|frame_unwind
name|sentinel_frame_unwinder
init|=
block|{
comment|/* Should the sentinel frame be given a special type?  */
name|NORMAL_FRAME
block|,
name|sentinel_frame_this_id
block|,
name|sentinel_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|frame_unwind
modifier|*
specifier|const
name|sentinel_frame_unwind
init|=
operator|&
name|sentinel_frame_unwinder
decl_stmt|;
end_decl_stmt

end_unit

