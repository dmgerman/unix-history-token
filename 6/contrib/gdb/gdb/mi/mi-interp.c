begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MI Interpreter Definitions and Commands for GDB, the GNU debugger.     Copyright 2002, 2003, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"mi-main.h"
end_include

begin_include
include|#
directive|include
file|"mi-cmds.h"
end_include

begin_include
include|#
directive|include
file|"mi-out.h"
end_include

begin_include
include|#
directive|include
file|"mi-console.h"
end_include

begin_struct
struct|struct
name|mi_interp
block|{
comment|/* MI's output channels */
name|struct
name|ui_file
modifier|*
name|out
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|err
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|log
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|targ
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|event_channel
decl_stmt|;
comment|/* This is the interpreter for the mi... */
name|struct
name|interp
modifier|*
name|mi2_interp
decl_stmt|;
name|struct
name|interp
modifier|*
name|mi1_interp
decl_stmt|;
name|struct
name|interp
modifier|*
name|mi_interp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These are the interpreter setup, etc. functions for the MI interpreter */
end_comment

begin_function_decl
specifier|static
name|void
name|mi_execute_command_wrapper
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_command_loop
parameter_list|(
name|int
name|mi_version
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|mi_input
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These are hooks that we put in place while doing interpreter_exec    so we can report interesting things that happened "behind the mi's    back" in this command */
end_comment

begin_function_decl
specifier|static
name|int
name|mi_interp_query_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi3_command_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi2_command_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi1_command_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_insert_notify_hooks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_remove_notify_hooks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|mi_interpreter_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mi_interp
modifier|*
name|mi
init|=
name|XMALLOC
argument_list|(
expr|struct
name|mi_interp
argument_list|)
decl_stmt|;
comment|/* Why is this a part of the mi architecture? */
name|mi_setup_architecture_data
argument_list|()
expr_stmt|;
comment|/* HACK: We need to force stdout/stderr to point at the console.  This avoids      any potential side effects caused by legacy code that is still      using the TUI / fputs_unfiltered_hook.  So we set up output channels for      this now, and swap them in when we are run. */
name|raw_stdout
operator|=
name|stdio_fileopen
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Create MI channels */
name|mi
operator|->
name|out
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"~"
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|mi
operator|->
name|err
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"&"
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|mi
operator|->
name|log
operator|=
name|mi
operator|->
name|err
expr_stmt|;
name|mi
operator|->
name|targ
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"@"
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|mi
operator|->
name|event_channel
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"="
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|mi
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi_interpreter_resume
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mi_interp
modifier|*
name|mi
init|=
name|data
decl_stmt|;
comment|/* As per hack note in mi_interpreter_init, swap in the output channels... */
name|gdb_setup_readline
argument_list|()
expr_stmt|;
if|if
condition|(
name|event_loop_p
condition|)
block|{
comment|/* These overwrite some of the initialization done in          _intialize_event_loop. */
name|call_readline
operator|=
name|gdb_readline2
expr_stmt|;
name|input_handler
operator|=
name|mi_execute_command_wrapper
expr_stmt|;
name|add_file_handler
argument_list|(
name|input_fd
argument_list|,
name|stdin_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|async_command_editing_p
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: This is a total hack for now.  PB's use of the MI implicitly          relies on a bug in the async support which allows asynchronous          commands to leak through the commmand loop.  The bug involves          (but is not limited to) the fact that sync_execution was          erroneously initialized to 0.  Duplicate by initializing it          thus here... */
name|sync_execution
operator|=
literal|0
expr_stmt|;
block|}
name|gdb_stdout
operator|=
name|mi
operator|->
name|out
expr_stmt|;
comment|/* Route error and log output through the MI */
name|gdb_stderr
operator|=
name|mi
operator|->
name|err
expr_stmt|;
name|gdb_stdlog
operator|=
name|mi
operator|->
name|log
expr_stmt|;
comment|/* Route target output through the MI. */
name|gdb_stdtarg
operator|=
name|mi
operator|->
name|targ
expr_stmt|;
comment|/* Replace all the hooks that we know about.  There really needs to      be a better way of doing this... */
name|clear_interpreter_hooks
argument_list|()
expr_stmt|;
name|show_load_progress
operator|=
name|mi_load_progress
expr_stmt|;
comment|/* If we're _the_ interpreter, take control. */
if|if
condition|(
name|current_interp_named_p
argument_list|(
name|INTERP_MI1
argument_list|)
condition|)
name|command_loop_hook
operator|=
name|mi1_command_loop
expr_stmt|;
elseif|else
if|if
condition|(
name|current_interp_named_p
argument_list|(
name|INTERP_MI2
argument_list|)
condition|)
name|command_loop_hook
operator|=
name|mi2_command_loop
expr_stmt|;
elseif|else
if|if
condition|(
name|current_interp_named_p
argument_list|(
name|INTERP_MI3
argument_list|)
condition|)
name|command_loop_hook
operator|=
name|mi3_command_loop
expr_stmt|;
else|else
name|command_loop_hook
operator|=
name|mi2_command_loop
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi_interpreter_suspend
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|gdb_disable_readline
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi_interpreter_exec
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|command
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|command
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|mi_execute_command_wrapper
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Never display the default gdb prompt in mi case.  */
end_comment

begin_function
specifier|static
name|int
name|mi_interpreter_prompt_p
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_interpreter_exec_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_executing
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"*stopped"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_can_async_p
argument_list|()
condition|)
block|{
name|add_continuation
argument_list|(
name|mi_interpreter_exec_continuation
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_interpreter_exec
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|struct
name|interp
modifier|*
name|interp_to_use
decl_stmt|;
name|enum
name|mi_cmd_result
name|result
init|=
name|MI_CMD_DONE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|interp_procs
modifier|*
name|procs
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|interp_to_use
operator|=
name|interp_lookup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_to_use
operator|==
name|NULL
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_interpreter_exec: could not find interpreter \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|interp_exec_p
argument_list|(
name|interp_to_use
argument_list|)
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* Insert the MI out hooks, making sure to also call the interpreter's hooks      if it has any. */
comment|/* KRS: We shouldn't need this... Events should be installed and they should      just ALWAYS fire something out down the MI channel... */
name|mi_insert_notify_hooks
argument_list|()
expr_stmt|;
comment|/* Now run the code... */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
comment|/* Do this in a cleaner way...  We want to force execution to be          asynchronous for commands that run the target.  */
if|if
condition|(
name|target_can_async_p
argument_list|()
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"console"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|buff
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buff
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
index|[
name|len
index|]
operator|=
literal|'&'
expr_stmt|;
name|buff
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* We had to set sync_execution = 0 for the mi (well really for Project          Builder's use of the mi - particularly so interrupting would work.          But for console commands to work, we need to initialize it to 1 -          since that is what the cli expects - before running the command,          and then set it back to 0 when we are done. */
name|sync_execution
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|interp_exec
argument_list|(
name|interp_to_use
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mi_error_last_message
argument_list|()
expr_stmt|;
name|result
operator|=
name|MI_CMD_ERROR
expr_stmt|;
break|break;
block|}
name|xfree
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|do_exec_error_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
name|sync_execution
operator|=
literal|0
expr_stmt|;
block|}
name|mi_remove_notify_hooks
argument_list|()
expr_stmt|;
comment|/* Okay, now let's see if the command set the inferior going...      Tricky point - have to do this AFTER resetting the interpreter, since      changing the interpreter will clear out all the continuations for      that interpreter... */
if|if
condition|(
name|target_can_async_p
argument_list|()
operator|&&
name|target_executing
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"^running\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|add_continuation
argument_list|(
name|mi_interpreter_exec_continuation
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * mi_insert_notify_hooks - This inserts a number of hooks that are meant to produce  * async-notify ("=") MI messages while running commands in another interpreter  * using mi_interpreter_exec.  The canonical use for this is to allow access to  * the gdb CLI interpreter from within the MI, while still producing MI style output  * when actions in the CLI command change gdb's state. */
end_comment

begin_function
specifier|static
name|void
name|mi_insert_notify_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|query_hook
operator|=
name|mi_interp_query_hook
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_remove_notify_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|query_hook
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mi_interp_query_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|ctlstr
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_execute_command_wrapper
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|mi_execute_command
argument_list|(
name|cmd
argument_list|,
name|stdin
operator|==
name|instream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi1_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|mi_command_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi2_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|mi_command_loop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi3_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|mi_command_loop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_command_loop
parameter_list|(
name|int
name|mi_version
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* HACK: Force stdout/stderr to point at the console.  This avoids      any potential side effects caused by legacy code that is still      using the TUI / fputs_unfiltered_hook */
block|raw_stdout = stdio_fileopen (stdout);
comment|/* Route normal output through the MIx */
block|gdb_stdout = mi_console_file_new (raw_stdout, "~", '"');
comment|/* Route error and log output through the MI */
block|gdb_stderr = mi_console_file_new (raw_stdout, "&", '"');   gdb_stdlog = gdb_stderr;
comment|/* Route target output through the MI. */
block|gdb_stdtarg = mi_console_file_new (raw_stdout, "@", '"');
comment|/* HACK: Poke the ui_out table directly.  Should we be creating a      mi_out object wired up to the above gdb_stdout / gdb_stderr? */
block|uiout = mi_out_new (mi_version);
comment|/* HACK: Override any other interpreter hooks.  We need to create a      real event table and pass in that. */
block|init_ui_hook = 0;
comment|/* command_loop_hook = 0; */
block|print_frame_info_listing_hook = 0;   query_hook = 0;   warning_hook = 0;   create_breakpoint_hook = 0;   delete_breakpoint_hook = 0;   modify_breakpoint_hook = 0;   interactive_hook = 0;   registers_changed_hook = 0;   readline_begin_hook = 0;   readline_hook = 0;   readline_end_hook = 0;   register_changed_hook = 0;   memory_changed_hook = 0;   context_hook = 0;   target_wait_hook = 0;   call_command_hook = 0;   error_hook = 0;   error_begin_hook = 0;   show_load_progress = mi_load_progress;
endif|#
directive|endif
comment|/* Turn off 8 bit strings in quoted output.  Any character with the      high bit set is printed using C's octal format. */
name|sevenbit_strings
operator|=
literal|1
expr_stmt|;
comment|/* Tell the world that we're alive */
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
condition|)
name|simplified_command_loop
argument_list|(
name|mi_input
argument_list|,
name|mi_execute_command
argument_list|)
expr_stmt|;
else|else
name|start_event_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mi_input
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|gdb_readline
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_mi_interp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_mi_interp
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|interp_procs
name|procs
init|=
block|{
name|mi_interpreter_init
block|,
comment|/* init_proc */
name|mi_interpreter_resume
block|,
comment|/* resume_proc */
name|mi_interpreter_suspend
block|,
comment|/* suspend_proc */
name|mi_interpreter_exec
block|,
comment|/* exec_proc */
name|mi_interpreter_prompt_p
comment|/* prompt_proc_p */
block|}
decl_stmt|;
comment|/* The various interpreter levels.  */
name|interp_add
argument_list|(
name|interp_new
argument_list|(
name|INTERP_MI1
argument_list|,
name|NULL
argument_list|,
name|mi_out_new
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|procs
argument_list|)
argument_list|)
expr_stmt|;
name|interp_add
argument_list|(
name|interp_new
argument_list|(
name|INTERP_MI2
argument_list|,
name|NULL
argument_list|,
name|mi_out_new
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|procs
argument_list|)
argument_list|)
expr_stmt|;
name|interp_add
argument_list|(
name|interp_new
argument_list|(
name|INTERP_MI3
argument_list|,
name|NULL
argument_list|,
name|mi_out_new
argument_list|(
literal|3
argument_list|)
argument_list|,
operator|&
name|procs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "mi" selects the most recent released version.  "mi2" was      released as part of GDB 6.0.  */
name|interp_add
argument_list|(
name|interp_new
argument_list|(
name|INTERP_MI
argument_list|,
name|NULL
argument_list|,
name|mi_out_new
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|procs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

