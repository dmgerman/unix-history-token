begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic remote debugging interface for simulators.     Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2004 Free Software Foundation, Inc.     Contributed by Cygnus Support.    Steve Chamberlain (sac@cygnus.com).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb/callback.h"
end_include

begin_include
include|#
directive|include
file|"gdb/remote-sim.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"sim-regno.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_remote_sim
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_loop_hook
function_decl|)
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_callbacks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_callbacks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdb_os_write_stdout
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_os_flush_stdout
parameter_list|(
name|host_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdb_os_write_stderr
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_os_flush_stderr
parameter_list|(
name|host_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdb_os_poll_quit
parameter_list|(
name|host_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* printf_filtered is depreciated */
end_comment

begin_function_decl
specifier|static
name|void
name|gdb_os_printf_filtered
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_os_vprintf_filtered
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_os_evprintf_filtered
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_os_error
parameter_list|(
name|host_callback
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_load
parameter_list|(
name|char
modifier|*
name|prog
parameter_list|,
name|int
name|fromtty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|gdbsim_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdbsim_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdbsim_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|simulator_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Naming convention:     sim_* are the interface to the simulator (see remote-sim.h).    gdbsim_* are stuff which is internal to gdb.  */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|gdbsim_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|program_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We must keep track of whether the simulator has been opened or not because    GDB can call a target's close routine twice, but sim_close doesn't allow    this.  We also need to record the result of sim_open so we can pass it    back to the other sim_foo routines.  */
end_comment

begin_decl_stmt
specifier|static
name|SIM_DESC
name|gdbsim_desc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|8
operator|||
name|len
operator|==
literal|4
condition|)
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|l
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t0x%lx"
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|8
condition|)
name|printf_filtered
argument_list|(
literal|" 0x%lx"
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|host_callback
name|gdb_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|callbacks_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize gdb_callback.  */
end_comment

begin_function
specifier|static
name|void
name|init_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|callbacks_initialized
condition|)
block|{
name|gdb_callback
operator|=
name|default_callback
expr_stmt|;
name|gdb_callback
operator|.
name|init
argument_list|(
operator|&
name|gdb_callback
argument_list|)
expr_stmt|;
name|gdb_callback
operator|.
name|write_stdout
operator|=
name|gdb_os_write_stdout
expr_stmt|;
name|gdb_callback
operator|.
name|flush_stdout
operator|=
name|gdb_os_flush_stdout
expr_stmt|;
name|gdb_callback
operator|.
name|write_stderr
operator|=
name|gdb_os_write_stderr
expr_stmt|;
name|gdb_callback
operator|.
name|flush_stderr
operator|=
name|gdb_os_flush_stderr
expr_stmt|;
name|gdb_callback
operator|.
name|printf_filtered
operator|=
name|gdb_os_printf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|vprintf_filtered
operator|=
name|gdb_os_vprintf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|evprintf_filtered
operator|=
name|gdb_os_evprintf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|error
operator|=
name|gdb_os_error
expr_stmt|;
name|gdb_callback
operator|.
name|poll_quit
operator|=
name|gdb_os_poll_quit
expr_stmt|;
name|gdb_callback
operator|.
name|magic
operator|=
name|HOST_CALLBACK_MAGIC
expr_stmt|;
name|callbacks_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release callbacks (free resources used by them).  */
end_comment

begin_function
specifier|static
name|void
name|end_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|callbacks_initialized
condition|)
block|{
name|gdb_callback
operator|.
name|shutdown
argument_list|(
operator|&
name|gdb_callback
argument_list|)
expr_stmt|;
name|callbacks_initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GDB version of os_write_stdout callback.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_write_stdout
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|ui_file_write
argument_list|(
name|gdb_stdtarg
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* GDB version of os_flush_stdout callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_flush_stdout
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|)
block|{
name|gdb_flush
argument_list|(
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of os_write_stderr callback.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_write_stderr
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
literal|0
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|b
argument_list|,
name|gdb_stdtargerr
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* GDB version of os_flush_stderr callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_flush_stderr
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|)
block|{
name|gdb_flush
argument_list|(
name|gdb_stdtargerr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of printf_filtered callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_printf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error vprintf_filtered.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_vprintf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error evprintf_filtered.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_evprintf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_error
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|error_hook
condition|)
call|(
modifier|*
name|error_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|verror
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|one2one_register_sim_regno
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* Only makes sense to supply raw registers.  */
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
argument_list|)
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|REGISTER_SIM_REGNO
argument_list|(
name|regno
argument_list|)
condition|)
block|{
case|case
name|LEGACY_SIM_REGNO_IGNORE
case|:
break|break;
case|case
name|SIM_REGNO_DOES_NOT_EXIST
case|:
block|{
comment|/* For moment treat a `does not exist' register the same way            as an ``unavailable'' register.  */
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|set_register_cached
argument_list|(
name|regno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
specifier|static
name|int
name|warn_user
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|gdb_assert
argument_list|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NUM_REGS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|nr_bytes
operator|=
name|sim_fetch_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|REGISTER_SIM_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|,
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_bytes
operator|>
literal|0
operator|&&
name|nr_bytes
operator|!=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|&&
name|warn_user
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Size of register %s (%d/%d) incorrect (%d instead of %d))"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|,
name|REGISTER_SIM_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|,
name|nr_bytes
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|warn_user
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FIXME: cagney/2002-05-27: Should check `nr_bytes == 0' 	   indicating that GDB and the SIM have different ideas about 	   which registers are fetchable.  */
comment|/* Else if (nr_bytes< 0): an old simulator, that doesn't 	   think to return the register size.  Just assume all is ok.  */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_fetch_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|REGISTER_SIM_REGNO
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|tmp
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|deprecated_read_register_gen
argument_list|(
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nr_bytes
operator|=
name|sim_store_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|REGISTER_SIM_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_bytes
operator|>
literal|0
operator|&&
name|nr_bytes
operator|!=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Register size different to expected"
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-05-27: Should check `nr_bytes == 0' 	 indicating that GDB and the SIM have different ideas about 	 which registers are fetchable.  */
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_store_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|tmp
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Kill the running program.  This may involve closing any open files    and releasing other resources acquired by the simulated program.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_kill
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_kill\n"
argument_list|)
expr_stmt|;
comment|/* There is no need to `kill' running simulator - the simulator is      not running */
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an executable file into the target process.  This is expected to    not only bring new code into the target process, but also to update    GDB's symbol tables to match.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_load
parameter_list|(
name|char
modifier|*
name|prog
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_load: prog \"%s\"\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* FIXME: We will print two messages on error.      Need error to either not print anything if passed NULL or need      another routine that doesn't take any arguments.  */
if|if
condition|(
name|sim_load
argument_list|(
name|gdbsim_desc
argument_list|,
name|prog
argument_list|,
name|NULL
argument_list|,
name|fromtty
argument_list|)
operator|==
name|SIM_RC_FAIL
condition|)
name|error
argument_list|(
literal|"unable to load program"
argument_list|)
expr_stmt|;
comment|/* FIXME: If a load command should reset the targets registers then      a call to sim_create_inferior() should go here. */
name|program_loaded
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and set inferior_ptid to its pid.    EXEC_FILE is the file to run.    ARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().    On VxWorks and various standalone systems, we ignore exec_file.  */
end_comment

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"No executable file specified."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|warning
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_create_inferior: exec_file \"%s\", args \"%s\"\n"
argument_list|,
operator|(
name|exec_file
condition|?
name|exec_file
else|:
literal|"(NULL)"
operator|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|gdbsim_kill
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|exec_file
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop */
literal|10
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|argv
operator|=
name|buildargv
argument_list|(
name|arg_buf
argument_list|)
expr_stmt|;
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|argv
operator|=
name|NULL
expr_stmt|;
name|sim_create_inferior
argument_list|(
name|gdbsim_desc
argument_list|,
name|exec_bfd
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* NB: Entry point already set by sim_create_inferior. */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The open routine takes the rest of the parameters from the command,    and (if successful) pushes a new target onto the stack.    Targets should supply this routine, if only to provide an error message.  */
end_comment

begin_comment
comment|/* Called when selecting the simulator. EG: (gdb) target sim name.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_open: args \"%s\"\n"
argument_list|,
name|args
condition|?
name|args
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
comment|/* Remove current simulator if one exists.  Only do this if the simulator      has been opened because sim_close requires it.      This is important because the call to push_target below will cause      sim_close to be called if the simulator is already open, but push_target      is called after sim_open!  We can't move the call to push_target before      the call to sim_open because sim_open may invoke `error'.  */
if|if
condition|(
name|gdbsim_desc
operator|!=
name|NULL
condition|)
name|unpush_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
literal|7
operator|+
literal|1
comment|/* gdbsim */
operator|+
name|strlen
argument_list|(
literal|" -E little"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" --architecture=xxxxxxxxxx"
argument_list|)
operator|+
operator|(
name|args
condition|?
name|strlen
argument_list|(
name|args
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|50
operator|)
comment|/* slack */
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_buf
argument_list|,
literal|"gdbsim"
argument_list|)
expr_stmt|;
comment|/* 7 */
comment|/* Specify the byte order for the target when it is both selectable      and explicitly specified by the user (not auto detected). */
switch|switch
condition|(
name|selected_byte_order
argument_list|()
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" -E big"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" -E little"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_UNKNOWN
case|:
break|break;
block|}
comment|/* Specify the architecture of the target when it has been      explicitly specified */
if|if
condition|(
name|selected_architecture_name
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" --architecture="
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|selected_architecture_name
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* finally, any explicit args */
if|if
condition|(
name|args
condition|)
block|{
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* 1 */
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|buildargv
argument_list|(
name|arg_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Insufficient memory available to allocate simulator arg list."
argument_list|)
expr_stmt|;
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|init_callbacks
argument_list|()
expr_stmt|;
name|gdbsim_desc
operator|=
name|sim_open
argument_list|(
name|SIM_OPEN_DEBUG
argument_list|,
operator|&
name|gdb_callback
argument_list|,
name|exec_bfd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unable to create simulator instance"
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to the simulator.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Does whatever cleanup is required for a target that we are no longer    going to be calling.  Argument says whether we are quitting gdb and    should not get hung in case of errors, or whether we want a clean    termination even if it takes a while.  This routine is automatically    always called just before a routine is popped off the target stack.    Closing file descriptors and freeing memory are typical things it should    do.  */
end_comment

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_close: quitting %d\n"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|program_loaded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|!=
name|NULL
condition|)
block|{
name|sim_close
argument_list|(
name|gdbsim_desc
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|gdbsim_desc
operator|=
name|NULL
expr_stmt|;
block|}
name|end_callbacks
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes a program previously attached to and detaches it.    The program may resume execution (some targets do, some don't) and will    no longer stop on signals, etc.  We better not have left any breakpoints    in the program or it'll die when it hits one.  ARGS is arguments    typed by the user (e.g. a signal to send the process).  FROM_TTY    says whether to be verbose or not.  */
end_comment

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_detach: args \"%s\"\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls gdbsim_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Ending simulator %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the target process.  STEP says whether to single-step    or to run free; SIGGNAL is the signal value (e.g. SIGINT) to be given    to the target, or zero for no signal.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|resume_siggnal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resume_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gdbsim_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|!=
literal|42
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_resume: step %d, signal %d\n"
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|resume_siggnal
operator|=
name|siggnal
expr_stmt|;
name|resume_step
operator|=
name|step
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notify the simulator of an asynchronous request to stop.     The simulator shall ensure that the stop request is eventually    delivered to the simulator.  If the call is made while the    simulator is not running then the stop request is processed when    the simulator is next resumed.     For simulators that do not support this operation, just abort */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sim_stop
argument_list|(
name|gdbsim_desc
argument_list|)
condition|)
block|{
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GDB version of os_poll_quit callback.    Taken from gdb/util.c - should be in a library */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_poll_quit
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|ui_loop_hook
operator|!=
name|NULL
condition|)
name|ui_loop_hook
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
comment|/* gdb's idea of quit */
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
comment|/* we've stolen it */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|immediate_quit
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for inferior process to do something.  Return pid of child,    or -1 in case of error; store status through argument pointer STATUS,    just as `wait' would. */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_cntrl_c
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|gdbsim_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|gdbsim_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|RETSIGTYPE
function_decl|(
modifier|*
name|prev_sigint
function_decl|)
parameter_list|()
function_decl|;
name|int
name|sigrc
init|=
literal|0
decl_stmt|;
name|enum
name|sim_stop
name|reason
init|=
name|sim_running
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_wait\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGACTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|SA_RESTART
argument_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|,
name|osa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|gdbsim_cntrl_c
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|osa
argument_list|)
expr_stmt|;
name|prev_sigint
operator|=
name|osa
operator|.
name|sa_handler
expr_stmt|;
block|}
else|#
directive|else
name|prev_sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|gdbsim_cntrl_c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
name|resume_step
argument_list|,
name|target_signal_to_host
argument_list|(
name|resume_siggnal
argument_list|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|prev_sigint
argument_list|)
expr_stmt|;
name|resume_step
operator|=
literal|0
expr_stmt|;
name|sim_stop_reason
argument_list|(
name|gdbsim_desc
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|sigrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|sim_exited
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|sigrc
expr_stmt|;
break|break;
case|case
name|sim_stopped
case|:
switch|switch
condition|(
name|sigrc
condition|)
block|{
case|case
name|SIGABRT
case|:
name|quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIGINT
case|:
case|case
name|SIGTRAP
case|:
default|default:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably 	     should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|sim_signalled
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably          should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|sim_running
case|:
case|case
name|sim_polling
case|:
comment|/* FIXME: Is this correct? */
break|break;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If WRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
specifier|static
name|int
name|gdbsim_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|error
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
comment|/* FIXME: Send to something other than STDOUT? */
name|printf_filtered
argument_list|(
literal|"gdbsim_xfer_inferior_memory: myaddr 0x"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|myaddr
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", memaddr 0x%s, len %d, write %d\n"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|write
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|len
operator|=
name|sim_write
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|sim_read
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|len
operator|>
literal|0
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|char
modifier|*
name|file
init|=
literal|"nothing"
decl_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_files_info: file \"%s\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tAttached to %s running program %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sim_info
argument_list|(
name|gdbsim_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear the simulator's notion of what the break points are.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_mourn_inferior:\n"
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|memory_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|memory_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pass the command argument through to the simulator verbatim.  The    simulator must do any command interpretation work.  */
end_comment

begin_function
name|void
name|simulator_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|gdbsim_desc
operator|==
name|NULL
condition|)
block|{
comment|/* PREVIOUSLY: The user may give a command before the simulator          is opened. [...] (??? assuming of course one wishes to          continue to allow commands to be sent to unopened simulators,          which isn't entirely unreasonable). */
comment|/* The simulator is a builtin abstraction of a remote target.          Consistent with that model, access to the simulator, via sim          commands, is restricted to the period when the channel to the          simulator is open. */
name|error
argument_list|(
literal|"Not connected to the simulator target"
argument_list|)
expr_stmt|;
block|}
name|sim_do_command
argument_list|(
name|gdbsim_desc
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Invalidate the register cache, in case the simulator command does      something funny. */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|gdbsim_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_gdbsim_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbsim_ops
operator|.
name|to_shortname
operator|=
literal|"sim"
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_longname
operator|=
literal|"simulator"
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_doc
operator|=
literal|"Use the compiled-in simulator."
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_open
operator|=
name|gdbsim_open
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_close
operator|=
name|gdbsim_close
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_detach
operator|=
name|gdbsim_detach
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_resume
operator|=
name|gdbsim_resume
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_wait
operator|=
name|gdbsim_wait
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_fetch_registers
operator|=
name|gdbsim_fetch_register
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_store_registers
operator|=
name|gdbsim_store_register
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_prepare_to_store
operator|=
name|gdbsim_prepare_to_store
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_xfer_memory
operator|=
name|gdbsim_xfer_inferior_memory
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_files_info
operator|=
name|gdbsim_files_info
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_insert_breakpoint
operator|=
name|gdbsim_insert_breakpoint
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_remove_breakpoint
operator|=
name|gdbsim_remove_breakpoint
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_kill
operator|=
name|gdbsim_kill
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_load
operator|=
name|gdbsim_load
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_create_inferior
operator|=
name|gdbsim_create_inferior
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_mourn_inferior
operator|=
name|gdbsim_mourn_inferior
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_stop
operator|=
name|gdbsim_stop
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_REDEFINE_DEFAULT_OPS
name|TARGET_REDEFINE_DEFAULT_OPS
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_initialize_remote_sim
parameter_list|(
name|void
parameter_list|)
block|{
name|init_gdbsim_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sim<command>"
argument_list|,
name|class_obscure
argument_list|,
name|simulator_command
argument_list|,
literal|"Send a command to the simulator."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

