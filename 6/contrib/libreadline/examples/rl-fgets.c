begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Date: Tue, 16 Mar 2004 19:38:40 -0800 From: Harold Levy<Harold.Levy@synopsys.com> Subject: fgets(stdin) --> readline() redirector To: chet@po.cwru.edu  Hi Chet,  Here is something you may find useful enough to include in the readline distribution.  It is a shared library that redirects calls to fgets(stdin) to readline() via LD_PRELOAD, and it supports a custom prompt and list of command names.  Many people have asked me for this file, so I thought I'd pass it your way in hope of just including it with readline to begin with.  Best Regards,  -Harold */
end_comment

begin_comment
comment|/****************************************************************************** *******************************************************************************      FILE NAME:    fgets.c                  TARGET:   libfgets.so   AUTHOR:       Harold Levy              VERSION:  1.0                 hlevy@synopsys.com      ABSTRACT:  Customize fgets() behavior via LD_PRELOAD in the following ways:        -- If fgets(stdin) is called, redirect to GNU readline() to obtain        command-line editing, file-name completion, history, etc.        -- A list of commands for command-name completion can be configured by        setting the environment-variable FGETS_COMMAND_FILE to a file containing        the list of commands to be used.        -- Command-line editing with readline() works best when the prompt string        is known; you can set this with the FGETS_PROMPT environment variable.        -- There special strings that libfgets will interpret as internal commands:               _fgets_reset_    reset the command list               _fgets_dump_     dump status               _fgets_debug_    toggle debug messages    HOW TO BUILD:  Here are examples of how to build libfgets.so on various   platforms; you will have to add -I and -L flags to configure access to   the readline header and library files.    (32-bit builds with gcc)   AIX:   gcc -fPIC fgets.c -shared -o libfgets.so -lc -ldl -lreadline -ltermcap   HP-UX: gcc -fPIC fgets.c -shared -o libfgets.so -lc -ldld -lreadline   Linux: gcc -fPIC fgets.c -shared -o libfgets.so -lc -ldl -lreadline   SunOS: gcc -fPIC fgets.c -shared -o libfgets.so -lc -ldl -lgen -lreadline    (64-bit builds without gcc)   SunOS: SUNWspro/bin/cc -D_LARGEFILE64_SOURCE=1 -xtarget=ultra -xarch=v9 \            -KPIC fgets.c -Bdynamic -lc -ldl -lgen -ltermcap -lreadline      HOW TO USE:  Different operating systems have different levels of support   for the LD_PRELOAD concept.  The generic method for 32-bit platforms is to   put libtermcap.so, libfgets.so, and libreadline.so (with absolute paths)   in the LD_PRELOAD environment variable, and to put their parent directories   in the LD_LIBRARY_PATH environment variable.  Unfortunately there is no   generic method for 64-bit platforms; e.g. for 64-bit SunOS, you would have   to build both 32-bit and 64-bit libfgets and libreadline libraries, and   use the LD_FLAGS_32 and LD_FLAGS_64 environment variables with preload and   library_path configurations (a mix of 32-bit and 64-bit calls are made under   64-bit SunOS).      EXAMPLE WRAPPER:  Here is an example shell script wrapper around the   program "foo" that uses fgets() for command-line input:        #!/bin/csh       #### replace this with the libtermcap.so directory:       set dir1 = "/usr/lib"       #### replace this with the libfgets.so directory:       set dir2 = "/usr/fgets"       #### replace this with the libreadline.so directory:       set dir3 = "/usr/local/lib"       set lib1 = "${dir1}/libtermcap.so"       set lib2 = "${dir2}/libfgets.so"       set lib3 = "${dir3}/libreadline.so"       if ( "${?LD_PRELOAD}" ) then         setenv LD_PRELOAD "${lib1}:${lib2}:${lib3}:${LD_PRELOAD}"       else         setenv LD_PRELOAD "${lib1}:${lib2}:${lib3}"       endif       if ( "${?LD_LIBRARY_PATH}" ) then         setenv LD_LIBRARY_PATH "${dir1}:${dir2}:${dir3}:${LD_LIBRARY_PATH}"       else         setenv LD_LIBRARY_PATH "${dir1}:${dir2}:${dir3}"       endif       setenv FGETS_COMMAND_FILE "${dir2}/foo.commands"       setenv FGETS_PROMPT       "foo> "       exec "foo" $*      Copyright (C)Â©2003-2004 Harold Levy.      This code links to the GNU readline library, and as such is bound by the   terms of the GNU General Public License as published by the Free Software   Foundation, either version 2 or (at your option) any later version.      The GNU General Public License is often shipped with GNU software, and is   generally kept in a file called COPYING or LICENSE.  If you do not have a   copy of the license, write to the Free Software Foundation, 59 Temple Place,   Suite 330, Boston, MA 02111 USA.      This program is distributed in the hope that it will be useful, but WITHOUT   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more   details.    ******************************************************************************* ******************************************************************************/
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* for dynamically connecting to the native fgets() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RTLD_NEXT
argument_list|)
end_if

begin_define
define|#
directive|define
name|REAL_LIBC
value|RTLD_NEXT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REAL_LIBC
value|((void *) -1L)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|char
modifier|*
function_decl|(
modifier|*
name|fgets_t
function_decl|)
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* private data */
end_comment

begin_comment
comment|/* -- writeable data is stored in the shared library's data segment    -- every process that uses the shared library gets a private memory copy of       its entire data segment    -- static data in the shared library is not copied to the application    -- only read-only (i.e. 'const') data is stored in the shared library's       text segment */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|my_fgets_names
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_fgets_number_of_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_fgets_debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* invoked with _fgets_reset_ */
end_comment

begin_function
specifier|static
name|void
name|my_fgets_reset
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|my_fgets_names
operator|&&
operator|(
name|my_fgets_number_of_names
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
name|printf
argument_list|(
literal|"libfgets:  removing command list\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|my_fgets_number_of_names
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|my_fgets_names
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|my_fgets_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|my_fgets_names
argument_list|)
expr_stmt|;
block|}
name|my_fgets_names
operator|=
name|NULL
expr_stmt|;
name|my_fgets_number_of_names
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* invoked with _fgets_dump_ */
end_comment

begin_function
specifier|static
name|void
name|my_fgets_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|getenv
argument_list|(
literal|"FGETS_PROMPT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FGETS_PROMPT       = %s\n"
argument_list|,
name|s
condition|?
name|s
else|:
literal|""
argument_list|)
expr_stmt|;
name|s
operator|=
name|getenv
argument_list|(
literal|"FGETS_COMMAND_FILE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FGETS_COMMAND_FILE = %s\n"
argument_list|,
name|s
condition|?
name|s
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"debug flag         = %d\n"
argument_list|,
name|my_fgets_debug_flag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#commands          = %d\n"
argument_list|,
name|my_fgets_number_of_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
if|if
condition|(
name|my_fgets_names
operator|&&
operator|(
name|my_fgets_number_of_names
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|my_fgets_number_of_names
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|my_fgets_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* invoked with _fgets_debug_ */
end_comment

begin_function
specifier|static
name|void
name|my_fgets_debug_toggle
parameter_list|(
name|void
parameter_list|)
block|{
name|my_fgets_debug_flag
operator|=
name|my_fgets_debug_flag
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
name|printf
argument_list|(
literal|"libfgets:  debug flag = %d\n"
argument_list|,
name|my_fgets_debug_flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* read the command list if needed, return the i-th name */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_fgets_lookup
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|my_fgets_names
operator|)
operator|||
operator|(
operator|!
name|my_fgets_number_of_names
operator|)
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fgets_t
name|_fgets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf1
index|[
literal|256
index|]
decl_stmt|,
name|buf2
index|[
literal|256
index|]
decl_stmt|;
name|fname
operator|=
name|getenv
argument_list|(
literal|"FGETS_COMMAND_FILE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fname
condition|)
block|{
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
name|printf
argument_list|(
literal|"libfgets:  empty or unset FGETS_COMMAND_FILE\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
name|printf
argument_list|(
literal|"libfgets:  cannot open '%s' for reading\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|_fgets
operator|=
operator|(
name|fgets_t
operator|)
name|dlsym
argument_list|(
name|REAL_LIBC
argument_list|,
literal|"fgets"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_fgets
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libfgets:  failed to dynamically link to native fgets()\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_fgets
argument_list|(
name|buf1
argument_list|,
literal|255
argument_list|,
name|fp
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|my_fgets_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|_fgets
argument_list|(
name|buf1
argument_list|,
literal|255
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|buf1
index|[
literal|255
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|buf1
argument_list|,
literal|"%s"
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|my_fgets_names
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|my_fgets_number_of_names
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|my_fgets_debug_flag
condition|)
block|{
name|printf
argument_list|(
literal|"libfgets:  successfully read %d commands\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|my_fgets_number_of_names
condition|)
block|{
return|return
name|my_fgets_names
index|[
name|index
index|]
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* generate a list of partial name matches for readline() */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_fgets_generator
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
specifier|static
name|int
name|list_index
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|list_index
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|name
operator|=
name|my_fgets_lookup
argument_list|(
name|list_index
argument_list|)
operator|)
condition|)
block|{
name|list_index
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
condition|)
block|{
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* partial name completion callback for readline() */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|my_fgets_completion
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|matches
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
block|{
name|matches
operator|=
name|rl_completion_matches
argument_list|(
name|text
argument_list|,
name|my_fgets_generator
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|matches
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* fgets() intercept */
end_comment

begin_function
name|char
modifier|*
name|fgets
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|stream
operator|==
name|stdin
condition|)
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|my_fgets_line
decl_stmt|;
name|rl_already_prompted
operator|=
literal|1
expr_stmt|;
name|rl_attempted_completion_function
operator|=
name|my_fgets_completion
expr_stmt|;
name|rl_catch_signals
operator|=
literal|1
expr_stmt|;
name|rl_catch_sigwinch
operator|=
literal|1
expr_stmt|;
name|rl_set_signals
argument_list|()
expr_stmt|;
name|prompt
operator|=
name|getenv
argument_list|(
literal|"FGETS_PROMPT"
argument_list|)
expr_stmt|;
for|for
control|(
name|my_fgets_line
operator|=
literal|0
init|;
operator|!
name|my_fgets_line
condition|;
name|my_fgets_line
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|my_fgets_line
argument_list|,
literal|"_fgets_reset_"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|my_fgets_reset
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|my_fgets_line
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|my_fgets_line
argument_list|,
literal|"_fgets_dump_"
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|my_fgets_dump
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|my_fgets_line
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|my_fgets_line
argument_list|,
literal|"_fgets_debug_"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|my_fgets_debug_toggle
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|my_fgets_line
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|s
argument_list|,
name|my_fgets_line
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|my_fgets_line
condition|)
name|add_history
argument_list|(
name|my_fgets_line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_fgets_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
else|else
block|{
specifier|static
name|fgets_t
name|_fgets
decl_stmt|;
name|_fgets
operator|=
operator|(
name|fgets_t
operator|)
name|dlsym
argument_list|(
name|REAL_LIBC
argument_list|,
literal|"fgets"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_fgets
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libfgets:  failed to dynamically link to native fgets()\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
return|return
operator|(
name|_fgets
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|stream
argument_list|)
operator|)
return|;
block|}
block|}
end_function

end_unit

