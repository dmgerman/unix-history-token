begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph based intraprocedural optimizations.    Copyright (C) 2003, 2004 Free Software Foundation, Inc.    Contributed by Jan Hubicka  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_define
define|#
directive|define
name|INSNS_PER_CALL
value|10
end_define

begin_function_decl
specifier|static
name|void
name|cgraph_expand_all_functions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_mark_functions_to_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_expand_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|record_call_1
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_mark_local_functions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_optimize_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cgraph_default_inline_p
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgraph_decide_inlining_incrementally
parameter_list|(
name|struct
name|cgraph_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statistics we collect about inlining algorithm.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ncalls_inlined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfunctions_inlined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initial_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overall_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records tree nodes seen in cgraph_create_edges.  Simply using    walk_tree_without_duplicates doesn't guarantee each node is visited    once because it gets a new htab upon each recursive call from    record_calls_1.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|visited_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if function DECL is needed.  That is, visible to something    either outside this translation unit, something magic in the system    configury, or (if not doing unit-at-a-time) to something we havn't    seen yet.  */
end_comment

begin_function
specifier|static
name|bool
name|decide_is_function_needed
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
comment|/* If we decided it was needed before, but at the time we didn't have      the body of the function available, then it's still needed.  We have      to go back and re-check its dependencies now.  */
if|if
condition|(
name|node
operator|->
name|needed
condition|)
return|return
name|true
return|;
comment|/* Externally visible functions must be output.  The exception is      COMDAT functions that must be output only when they are needed.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Constructors and destructors are reachable from the runtime by      some mechanism.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the user told us it is used, then it must be so.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* ??? If the assembler name is set by hand, it is possible to assemble      the name later after finalizing the function and the fact is noticed      in assemble_name then.  This is arguably a bug.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return
name|false
return|;
comment|/* If not doing unit at a time, then we'll only defer this function      if its marked for inlining.  Otherwise we want to emit it now.  */
comment|/* "extern inline" functions are never output locally.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We want to emit COMDAT functions only when absolutely necessary.  */
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
comment|/* When declared inline, defer even the uninlinable functions. 	     This allows them to be eliminated when unused.  */
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
operator|||
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* When not doing unit-at-a-time, output all functions enqueued.    Return true when such a functions were found.  */
end_comment

begin_function
name|bool
name|cgraph_assemble_pending_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|output
init|=
name|false
decl_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return
name|false
return|;
while|while
condition|(
name|cgraph_nodes_queue
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
init|=
name|cgraph_nodes_queue
decl_stmt|;
name|cgraph_nodes_queue
operator|=
name|cgraph_nodes_queue
operator|->
name|next_needed
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|origin
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|n
operator|->
name|decl
argument_list|)
condition|)
block|{
name|cgraph_expand_function
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|output
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|output
return|;
block|}
end_function

begin_comment
comment|/* DECL has been parsed.  Take it, queue it, compile it at the whim of the    logic in effect.  If NESTED is true, then our caller cannot stand to have    the garbage collector run at the moment.  We would need to either create    a new GC context, or just not compile right now.  */
end_comment

begin_function
name|void
name|cgraph_finalize_function
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|nested
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
block|{
comment|/* As an GCC extension we allow redefinition of the function.  The 	 semantics when both copies of bodies differ is not well defined. 	 We replace the old body with new body so in unit at a time mode 	 we always use new body, while in normal mode we may end up with 	 old body inlined into some functions and new body expanded and 	 inlined in others. 	  	 ??? It may make more sense to use one body for inlining and other 	 body for expanding the function but this is difficult to do.  */
comment|/* If node->output is set, then this is a unit-at-a-time compilation 	 and we have already begun whole-unit analysis.  This is *not* 	 testing for whether we've already emitted the function.  That 	 case can be sort-of legitimately seen with real function  	 redefinition errors.  I would argue that the front end should 	 never present us with such a case, but don't enforce that for now.  */
if|if
condition|(
name|node
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Reset our datastructures so we can analyze the function again.  */
name|memset
argument_list|(
operator|&
name|node
operator|->
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
operator|->
name|global
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|global
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
operator|->
name|rtl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|false
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|redefined_extern_inline
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|callees
condition|)
name|cgraph_remove_edge
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|callees
operator|->
name|callee
argument_list|)
expr_stmt|;
comment|/* We may need to re-queue the node for assembling in case          we already proceeded it and ignored as not needed.  */
if|if
condition|(
name|node
operator|->
name|reachable
operator|&&
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|cgraph_nodes_queue
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next_needed
control|)
if|if
condition|(
name|n
operator|==
name|node
condition|)
break|break;
if|if
condition|(
operator|!
name|n
condition|)
name|node
operator|->
name|reachable
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|finalized
operator|=
name|true
expr_stmt|;
comment|/* If not unit at a time, then we need to create the call graph      now, so that called functions can be queued and emitted now.  */
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|cgraph_analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|cgraph_decide_inlining_incrementally
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decide_is_function_needed
argument_list|(
name|node
argument_list|,
name|decl
argument_list|)
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If not unit at a time, go ahead and emit everything we've found      to be reachable at this time.  */
if|if
condition|(
operator|!
name|nested
condition|)
block|{
if|if
condition|(
operator|!
name|cgraph_assemble_pending_functions
argument_list|()
condition|)
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
comment|/* If we've not yet emitted decl, tell the debug info about it.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We will never really output the function body, clear the SAVED_INSNS array      early then.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk tree and record all calls.  Called via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|record_call_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
comment|/* ??? Really, we should mark this decl as *potentially* referenced 	 by this function and re-examine whether the decl is actually used 	 after rtl has been generated.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|cgraph_varpool_node
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|flag_unit_at_a_time
condition|)
block|{
comment|/* Record dereferences to the functions.  This makes the 	     functions reachable unconditionally.  */
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cgraph_record_call
argument_list|(
name|data
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* When we see a function call, we don't want to look at the 	       function reference in the ADDR_EXPR that is hanging from 	       the CALL_EXPR we're examining here, because we would 	       conclude incorrectly that the function's address could be 	       taken by something that is not a function call.  So only 	       walk the function parameter list, skip the other subtrees.  */
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|record_call_1
argument_list|,
name|data
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* Save some cycles by not walking types and declaration as we 	 won't find anything useful there anyway.  */
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|>=
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|callgraph
operator|.
name|analyze_expr
call|)
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|data
argument_list|)
return|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create cgraph edges for function calls inside BODY from DECL.  */
end_comment

begin_function
name|void
name|cgraph_create_edges
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
comment|/* The nodes we're interested in are never shared, so walk      the tree ignoring duplicates.  */
name|visited_nodes
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|body
argument_list|,
name|record_call_1
argument_list|,
name|decl
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the function scheduled to be output.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
comment|/* First kill forward declaration so reverse inlining works properly.  */
name|cgraph_create_edges
argument_list|(
name|decl
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|inlinable
operator|=
name|tree_inlinable_function_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|self_insns
condition|)
name|node
operator|->
name|local
operator|.
name|self_insns
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|estimate_num_insns
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|redefined_extern_inline
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"redefined extern inline functions are not "
literal|"considered for inlining"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not inlinable"
argument_list|)
expr_stmt|;
else|else
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not considered for inlining"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_really_no_inline
operator|&&
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
name|node
operator|->
name|local
operator|.
name|inlinable
operator|=
literal|0
expr_stmt|;
comment|/* Inlining characteristics are maintained by the cgraph_mark_inline.  */
name|node
operator|->
name|global
operator|.
name|insns
operator|=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|node
operator|->
name|global
operator|.
name|cloned_times
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|global
operator|.
name|will_be_output
operator|=
name|true
expr_stmt|;
block|}
name|node
operator|->
name|analyzed
operator|=
name|true
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
comment|/* Possibly warn about unused parameters.  */
if|if
condition|(
name|warn_unused_parameter
condition|)
name|do_warn_unused_parameter
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the whole compilation unit once it is parsed completely.  */
end_comment

begin_function
name|void
name|cgraph_finalize_compilation_unit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
block|{
name|cgraph_assemble_pending_functions
argument_list|()
expr_stmt|;
return|return;
block|}
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nAnalyzing compilation unit\n"
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Initial entry points:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate reachability flag and lower representation of all reachable      functions.  In the future, lowering will introduce new functions and      new entry points on the way (by template instantiation and virtual      method table generation for instance).  */
while|while
condition|(
name|cgraph_nodes_queue
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
name|tree
name|decl
init|=
name|cgraph_nodes_queue
operator|->
name|decl
decl_stmt|;
name|node
operator|=
name|cgraph_nodes_queue
expr_stmt|;
name|cgraph_nodes_queue
operator|=
name|cgraph_nodes_queue
operator|->
name|next_needed
expr_stmt|;
comment|/* ??? It is possible to create extern inline function and later using 	 weak alas attribute to kill it's body. See 	 gcc.c-torture/compile/20011119-1.c  */
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|analyzed
operator|||
operator|!
name|node
operator|->
name|reachable
operator|||
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cgraph_analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callees
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|edge
operator|->
name|callee
operator|->
name|reachable
condition|)
name|cgraph_mark_reachable_node
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
expr_stmt|;
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
block|}
comment|/* Collect entry points to the unit.  */
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Unit entry points:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\nInitial "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nReclaiming functions:"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|reachable
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\nReclaimed "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CGRAPH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure out what functions we want to assemble.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_mark_functions_to_output
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
break|break;
comment|/* We need to output all local functions that are used and not 	 always inlined, as well as those that are reachable from 	 outside the current compilation unit.  */
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|node
operator|->
name|needed
operator|||
operator|(
name|e
operator|&&
name|node
operator|->
name|reachable
operator|)
operator|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|origin
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|node
operator|->
name|output
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Optimize the function before expansion.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_optimize_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
comment|/* optimize_inline_calls avoids inlining of current_function_decl.  */
name|current_function_decl
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|flag_inline_trees
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
operator|||
name|warn_inline
operator|||
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|e
condition|)
name|optimize_inline_calls
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|nested
condition|)
block|{
for|for
control|(
name|node
operator|=
name|node
operator|->
name|nested
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_nested
control|)
name|cgraph_optimize_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand function specified by NODE.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_expand_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
name|announce_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cgraph_optimize_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Generate RTL for the body of DECL.  Nested functions are expanded      via lang_expand_decl_stmt.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill array order with all nodes with output flag set in the reverse    topological order.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_postorder
parameter_list|(
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
name|int
name|stack_size
init|=
literal|0
decl_stmt|;
name|int
name|order_pos
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|stack
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We have to deal with cycles nicely, so use a depth first traversal      output algorithm.  Ignore the fact that some functions won't need      to be output and put them into order as well, so we get dependencies      right through intline functions.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|node
operator|->
name|aux
condition|)
block|{
name|node2
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|callers
condition|)
name|node
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
else|else
name|node
operator|->
name|aux
operator|=
name|node
operator|->
name|callers
expr_stmt|;
while|while
condition|(
name|node2
condition|)
block|{
while|while
condition|(
name|node2
operator|->
name|aux
operator|!=
operator|&
name|last
condition|)
block|{
name|edge
operator|=
name|node2
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|next_caller
condition|)
name|node2
operator|->
name|aux
operator|=
name|edge
operator|->
name|next_caller
expr_stmt|;
else|else
name|node2
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|caller
operator|->
name|aux
condition|)
block|{
if|if
condition|(
operator|!
name|edge
operator|->
name|caller
operator|->
name|callers
condition|)
name|edge
operator|->
name|caller
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
else|else
name|edge
operator|->
name|caller
operator|->
name|aux
operator|=
name|edge
operator|->
name|caller
operator|->
name|callers
expr_stmt|;
name|stack
index|[
name|stack_size
operator|++
index|]
operator|=
name|node2
expr_stmt|;
name|node2
operator|=
name|edge
operator|->
name|caller
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|node2
operator|->
name|aux
operator|==
operator|&
name|last
condition|)
block|{
name|order
index|[
name|order_pos
operator|++
index|]
operator|=
name|node2
expr_stmt|;
if|if
condition|(
name|stack_size
condition|)
name|node2
operator|=
name|stack
index|[
operator|--
name|stack_size
index|]
expr_stmt|;
else|else
name|node2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|order_pos
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INLINED_TIMES
parameter_list|(
name|node
parameter_list|)
value|((size_t)(node)->aux)
end_define

begin_define
define|#
directive|define
name|SET_INLINED_TIMES
parameter_list|(
name|node
parameter_list|,
name|times
parameter_list|)
value|((node)->aux = (void *)(times))
end_define

begin_comment
comment|/* Return list of nodes we decided to inline NODE into, set their output    flag and compute INLINED_TIMES.     We do simple backtracing to get INLINED_TIMES right.  This should not be    expensive as we limit the amount of inlining.  Alternatively we may first    discover set of nodes, topologically sort these and propagate    INLINED_TIMES  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_inlined_into
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|array
parameter_list|)
block|{
name|int
name|nfound
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
modifier|*
name|stack
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fast path: since we traverse in mostly topological order, we will likely      find no edges.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* Allocate stack for back-tracking up callgraph.  */
name|stack
operator|=
name|xmalloc
argument_list|(
operator|(
name|cgraph_n_nodes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|caller
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|caller
operator|=
name|e
operator|->
name|caller
expr_stmt|;
comment|/* Check if the caller destination has been visited yet.  */
if|if
condition|(
operator|!
name|caller
operator|->
name|output
condition|)
block|{
name|array
index|[
name|nfound
operator|++
index|]
operator|=
name|e
operator|->
name|caller
expr_stmt|;
comment|/* Mark that we have visited the destination.  */
name|caller
operator|->
name|output
operator|=
name|true
expr_stmt|;
name|SET_INLINED_TIMES
argument_list|(
name|caller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SET_INLINED_TIMES
argument_list|(
name|caller
argument_list|,
name|INLINED_TIMES
argument_list|(
name|caller
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|e1
operator|=
name|caller
operator|->
name|callers
init|;
name|e1
condition|;
name|e1
operator|=
name|e1
operator|->
name|next_caller
control|)
if|if
condition|(
operator|!
name|e1
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
name|e1
condition|)
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|e1
expr_stmt|;
else|else
block|{
while|while
condition|(
name|true
condition|)
block|{
for|for
control|(
name|e1
operator|=
name|e
operator|->
name|next_caller
init|;
name|e1
condition|;
name|e1
operator|=
name|e1
operator|->
name|next_caller
control|)
if|if
condition|(
operator|!
name|e1
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
name|e1
condition|)
block|{
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|sp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
break|break;
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Found inline predecesors of %s:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INLINED_TIMES
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" (%i times)"
argument_list|,
operator|(
name|int
operator|)
name|INLINED_TIMES
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|nfound
return|;
block|}
end_function

begin_comment
comment|/* Return list of nodes we decided to inline into NODE, set their output    flag and compute INLINED_TIMES.     This function is identical to cgraph_inlined_into with callers and callees    nodes swapped.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_inlined_callees
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|array
parameter_list|)
block|{
name|int
name|nfound
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
modifier|*
name|stack
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fast path: since we traverse in mostly topological order, we will likely      find no edges.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* Allocate stack for back-tracking up callgraph.  */
name|stack
operator|=
name|xmalloc
argument_list|(
operator|(
name|cgraph_n_nodes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_edge
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|callee
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|callee
operator|=
name|e
operator|->
name|callee
expr_stmt|;
comment|/* Check if the callee destination has been visited yet.  */
if|if
condition|(
operator|!
name|callee
operator|->
name|output
condition|)
block|{
name|array
index|[
name|nfound
operator|++
index|]
operator|=
name|e
operator|->
name|callee
expr_stmt|;
comment|/* Mark that we have visited the destination.  */
name|callee
operator|->
name|output
operator|=
name|true
expr_stmt|;
name|SET_INLINED_TIMES
argument_list|(
name|callee
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SET_INLINED_TIMES
argument_list|(
name|callee
argument_list|,
name|INLINED_TIMES
argument_list|(
name|callee
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|e1
operator|=
name|callee
operator|->
name|callees
init|;
name|e1
condition|;
name|e1
operator|=
name|e1
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e1
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
name|e1
condition|)
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|e1
expr_stmt|;
else|else
block|{
while|while
condition|(
name|true
condition|)
block|{
for|for
control|(
name|e1
operator|=
name|e
operator|->
name|next_callee
init|;
name|e1
condition|;
name|e1
operator|=
name|e1
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e1
operator|->
name|inline_failed
condition|)
break|break;
if|if
condition|(
name|e1
condition|)
block|{
name|stack
index|[
name|sp
operator|-
literal|1
index|]
operator|=
name|e1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|sp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
break|break;
name|e
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Found inline successors of %s:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INLINED_TIMES
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" (%i times)"
argument_list|,
operator|(
name|int
operator|)
name|INLINED_TIMES
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|nfound
return|;
block|}
end_function

begin_comment
comment|/* Perform reachability analysis and reclaim all unreachable nodes.    This function also remove unneeded bodies of extern inline functions    and thus needs to be done only after inlining decisions has been made.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_remove_unreachable_nodes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|first
init|=
operator|(
name|void
operator|*
operator|)
literal|1
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|int
name|insns
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nReclaiming functions:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|aux
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|||
operator|!
name|node
operator|->
name|analyzed
operator|)
condition|)
block|{
name|node
operator|->
name|aux
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|aux
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Perform reachability analysis.  As a special case do not consider      extern inline functions not inlined as live because we won't output      them at all.  */
while|while
condition|(
name|first
operator|!=
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|node
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|aux
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|callee
operator|->
name|aux
operator|&&
name|node
operator|->
name|analyzed
operator|&&
operator|(
operator|!
name|e
operator|->
name|inline_failed
operator|||
operator|!
name|e
operator|->
name|callee
operator|->
name|analyzed
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|)
condition|)
block|{
name|e
operator|->
name|callee
operator|->
name|aux
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|e
operator|->
name|callee
expr_stmt|;
block|}
block|}
comment|/* Remove unreachable nodes.  Extern inline functions need special care;      Unreachable extern inline functions shall be removed.      Reachable extern inline functions we never inlined shall get their bodies      elliminated      Reachable extern inline functions we sometimes inlined will be turned into      unanalyzed nodes so they look like for true extern functions to the rest      of code.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|aux
condition|)
block|{
name|int
name|local_insns
decl_stmt|;
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
condition|)
name|local_insns
operator|=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
else|else
name|local_insns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|analyzed
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|aux
condition|)
break|break;
if|if
condition|(
name|e
operator|||
name|node
operator|->
name|needed
condition|)
block|{
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|callees
condition|)
name|cgraph_remove_edge
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|callees
operator|->
name|callee
argument_list|)
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|false
expr_stmt|;
block|}
else|else
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|insns
operator|+=
name|local_insns
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nReclaimed %i insns"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Estimate size of the function after inlining WHAT into TO.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_estimate_size_after_inlining
parameter_list|(
name|int
name|times
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|)
block|{
return|return
operator|(
name|what
operator|->
name|global
operator|.
name|insns
operator|-
name|INSNS_PER_CALL
operator|)
operator|*
name|times
operator|+
name|to
operator|->
name|global
operator|.
name|insns
return|;
block|}
end_function

begin_comment
comment|/* Estimate the growth caused by inlining NODE into all callees.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_estimate_growth
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|growth
init|=
literal|0
decl_stmt|;
name|int
name|calls_saved
init|=
literal|0
decl_stmt|;
name|int
name|clones_added
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
block|{
name|growth
operator|+=
operator|(
operator|(
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|e
operator|->
name|caller
argument_list|,
name|node
argument_list|)
operator|-
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
operator|)
operator|*
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|cloned_times
operator|)
expr_stmt|;
name|calls_saved
operator|+=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|cloned_times
expr_stmt|;
name|clones_added
operator|+=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|cloned_times
expr_stmt|;
block|}
comment|/* ??? Wrong for self recursive functions or cases where we decide to not      inline for different reasons, but it is not big deal as in that case      we will keep the body around, but we will also avoid some inlining.  */
if|if
condition|(
operator|!
name|node
operator|->
name|needed
operator|&&
operator|!
name|node
operator|->
name|origin
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|growth
operator|-=
name|node
operator|->
name|global
operator|.
name|insns
operator|,
name|clones_added
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|calls_saved
condition|)
name|calls_saved
operator|=
literal|1
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Update insn sizes after inlining WHAT into TO that is already inlined into    all nodes in INLINED array.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_mark_inline
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined
parameter_list|,
name|int
name|ninlined
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined_callees
parameter_list|,
name|int
name|ninlined_callees
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
name|int
name|clones
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|bool
name|called
init|=
name|false
decl_stmt|;
name|int
name|new_insns
decl_stmt|;
name|what
operator|->
name|global
operator|.
name|inlined
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
name|what
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
block|{
if|if
condition|(
name|e
operator|->
name|caller
operator|==
name|to
condition|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
continue|continue;
name|e
operator|->
name|inline_failed
operator|=
name|NULL
expr_stmt|;
name|times
operator|++
expr_stmt|;
name|clones
operator|+=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|cloned_times
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
name|called
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|times
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ncalls_inlined
operator|+=
name|times
expr_stmt|;
name|new_insns
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
name|times
argument_list|,
name|to
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|global
operator|.
name|will_be_output
condition|)
name|overall_insns
operator|+=
name|new_insns
operator|-
name|to
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|to
operator|->
name|global
operator|.
name|insns
operator|=
name|new_insns
expr_stmt|;
if|if
condition|(
operator|!
name|called
operator|&&
operator|!
name|what
operator|->
name|needed
operator|&&
operator|!
name|what
operator|->
name|origin
operator|&&
name|flag_unit_at_a_time
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|what
operator|->
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|what
operator|->
name|global
operator|.
name|will_be_output
condition|)
name|abort
argument_list|()
expr_stmt|;
name|clones
operator|--
expr_stmt|;
name|nfunctions_inlined
operator|++
expr_stmt|;
name|what
operator|->
name|global
operator|.
name|will_be_output
operator|=
literal|0
expr_stmt|;
name|overall_insns
operator|-=
name|what
operator|->
name|global
operator|.
name|insns
expr_stmt|;
block|}
name|what
operator|->
name|global
operator|.
name|cloned_times
operator|+=
name|clones
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined
condition|;
name|i
operator|++
control|)
block|{
name|new_insns
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
name|INLINED_TIMES
argument_list|(
name|inlined
index|[
name|i
index|]
argument_list|)
operator|*
name|times
argument_list|,
name|inlined
index|[
name|i
index|]
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlined
index|[
name|i
index|]
operator|->
name|global
operator|.
name|will_be_output
condition|)
name|overall_insns
operator|+=
name|new_insns
operator|-
name|inlined
index|[
name|i
index|]
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|inlined
index|[
name|i
index|]
operator|->
name|global
operator|.
name|insns
operator|=
name|new_insns
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined_callees
condition|;
name|i
operator|++
control|)
block|{
name|inlined_callees
index|[
name|i
index|]
operator|->
name|global
operator|.
name|cloned_times
operator|+=
name|INLINED_TIMES
argument_list|(
name|inlined_callees
index|[
name|i
index|]
argument_list|)
operator|*
name|clones
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return false when inlining WHAT into TO is not good idea as it would cause    too large growth of function bodies.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_check_inline_limits
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined
parameter_list|,
name|int
name|ninlined
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|int
name|limit
decl_stmt|;
for|for
control|(
name|e
operator|=
name|to
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|==
name|what
condition|)
name|times
operator|++
expr_stmt|;
comment|/* When inlining large function body called once into small function,      take the inlined function as base for limiting the growth.  */
if|if
condition|(
name|to
operator|->
name|local
operator|.
name|self_insns
operator|>
name|what
operator|->
name|local
operator|.
name|self_insns
condition|)
name|limit
operator|=
name|to
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
else|else
name|limit
operator|=
name|what
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
name|limit
operator|+=
name|limit
operator|*
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_GROWTH
argument_list|)
operator|/
literal|100
expr_stmt|;
name|newsize
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
name|times
argument_list|,
name|to
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_INSNS
argument_list|)
operator|&&
name|newsize
operator|>
name|limit
condition|)
block|{
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"--param large-function-growth limit reached"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined
condition|;
name|i
operator|++
control|)
block|{
name|newsize
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
name|INLINED_TIMES
argument_list|(
name|inlined
index|[
name|i
index|]
argument_list|)
operator|*
name|times
argument_list|,
name|inlined
index|[
name|i
index|]
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_INSNS
argument_list|)
operator|&&
name|newsize
operator|>
name|inlined
index|[
name|i
index|]
operator|->
name|local
operator|.
name|self_insns
operator|*
operator|(
literal|100
operator|+
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_GROWTH
argument_list|)
operator|)
operator|/
literal|100
condition|)
block|{
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"--param large-function-growth limit reached while inlining the caller"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true when function N is small enough to be inlined.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_default_inline_p
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|n
operator|->
name|decl
argument_list|)
operator|||
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|n
operator|->
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|n
operator|->
name|decl
argument_list|)
condition|)
return|return
name|n
operator|->
name|global
operator|.
name|insns
operator|<
name|MAX_INLINE_INSNS_SINGLE
return|;
else|else
return|return
name|n
operator|->
name|global
operator|.
name|insns
operator|<
name|MAX_INLINE_INSNS_AUTO
return|;
block|}
end_function

begin_comment
comment|/* Set inline_failed for all callers of given function to REASON.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_set_inline_failed
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Inlining failed: %s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|reason
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We use greedy algorithm for inlining of small functions:    All inline candidates are put into prioritized heap based on estimated    growth of the overall number of instructions and then update the estimates.     INLINED and INLINED_CALEES are just pointers to arrays large enough    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_decide_inlining_of_small_functions
parameter_list|(
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined_callees
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|fibheap_t
name|heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
name|struct
name|fibnode
modifier|*
modifier|*
name|heap_node
init|=
name|xcalloc
argument_list|(
name|cgraph_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fibnode
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ninlined
decl_stmt|,
name|ninlined_callees
decl_stmt|;
name|int
name|max_insns
init|=
operator|(
operator|(
name|HOST_WIDEST_INT
operator|)
name|initial_insns
operator|*
operator|(
literal|100
operator|+
name|PARAM_VALUE
argument_list|(
name|PARAM_INLINE_UNIT_GROWTH
argument_list|)
operator|)
operator|/
literal|100
operator|)
decl_stmt|;
comment|/* Put all inline candidates into the heap.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
operator|||
operator|!
name|node
operator|->
name|callers
operator|||
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|cgraph_set_inline_failed
argument_list|(
name|node
argument_list|,
name|N_
argument_list|(
literal|"--param max-inline-insns-single limit reached"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|heap_node
index|[
name|node
operator|->
name|uid
index|]
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nDeciding on smaller functions:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|overall_insns
operator|<=
name|max_insns
operator|&&
operator|(
name|node
operator|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
operator|)
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|int
name|old_insns
init|=
name|overall_insns
decl_stmt|;
name|heap_node
index|[
name|node
operator|->
name|uid
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nConsidering %s with %i insns\n"
literal|" Estimated growth is %+i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|cgraph_set_inline_failed
argument_list|(
name|node
argument_list|,
name|N_
argument_list|(
literal|"--param max-inline-insns-single limit reached after inlining into the callee"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ninlined_callees
operator|=
name|cgraph_inlined_callees
argument_list|(
name|node
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
block|{
comment|/* Marking recursive function inlinine has sane semantic and 	       thus we should not warn on it.  */
if|if
condition|(
name|e
operator|->
name|caller
operator|==
name|node
condition|)
block|{
name|e
operator|->
name|inline_failed
operator|=
literal|""
expr_stmt|;
continue|continue;
block|}
name|ninlined
operator|=
name|cgraph_inlined_into
argument_list|(
name|e
operator|->
name|caller
argument_list|,
name|inlined
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|output
condition|)
name|e
operator|->
name|inline_failed
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|output
operator|||
operator|!
name|cgraph_check_inline_limits
argument_list|(
name|e
operator|->
name|caller
argument_list|,
name|node
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined
condition|;
name|i
operator|++
control|)
name|inlined
index|[
name|i
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined
index|[
name|i
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Not inlining into %s.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cgraph_mark_inline
argument_list|(
name|e
operator|->
name|caller
argument_list|,
name|node
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
name|inlined_callees
argument_list|,
name|ninlined_callees
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap_node
index|[
name|e
operator|->
name|caller
operator|->
name|uid
index|]
condition|)
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|heap_node
index|[
name|e
operator|->
name|caller
operator|->
name|uid
index|]
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size of the functions we updated into has changed, so update 	       the keys.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined
condition|;
name|i
operator|++
control|)
block|{
name|inlined
index|[
name|i
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined
index|[
name|i
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|heap_node
index|[
name|inlined
index|[
name|i
index|]
operator|->
name|uid
index|]
condition|)
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|heap_node
index|[
name|inlined
index|[
name|i
index|]
operator|->
name|uid
index|]
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|inlined
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|,
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly all functions called by the function we just inlined          are now called more times; update keys.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
operator|&&
name|heap_node
index|[
name|e
operator|->
name|callee
operator|->
name|uid
index|]
condition|)
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|heap_node
index|[
name|e
operator|->
name|callee
operator|->
name|uid
index|]
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninlined_callees
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|inlined_callees
index|[
name|i
index|]
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
operator|&&
name|heap_node
index|[
name|e
operator|->
name|callee
operator|->
name|uid
index|]
condition|)
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|heap_node
index|[
name|e
operator|->
name|callee
operator|->
name|uid
index|]
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|inlined_callees
index|[
name|i
index|]
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|inlined_callees
index|[
name|i
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inlined %i times for a net change of %+i insns.\n"
argument_list|,
name|node
operator|->
name|global
operator|.
name|cloned_times
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|node
operator|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
name|cgraph_set_inline_failed
argument_list|(
name|node
argument_list|,
name|N_
argument_list|(
literal|"--param inline-unit-growth limit reached"
argument_list|)
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|heap_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide on the inlining.  We do so in the topological order to avoid    expenses on updating datastructures.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_decide_inlining
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|int
name|nnodes
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined_callees
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ninlined
decl_stmt|;
name|int
name|ninlined_callees
decl_stmt|;
name|int
name|old_insns
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|initial_insns
operator|+=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
name|overall_insns
operator|=
name|initial_insns
expr_stmt|;
name|nnodes
operator|=
name|cgraph_postorder
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nDeciding on inlining.  Starting with %i insns.\n"
argument_list|,
name|initial_insns
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nInlining always_inline functions:\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|aux
operator|||
name|node
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* In the first pass mark all always_inline edges.  Do this with a priority      so none of our later choices will make this impossible.  */
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
continue|continue;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nConsidering %s %i insns (always inline)\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|,
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
name|ninlined
operator|=
name|cgraph_inlined_into
argument_list|(
name|order
index|[
name|i
index|]
argument_list|,
name|inlined
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
name|old_insns
operator|=
name|overall_insns
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
operator|||
operator|!
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|inlinable
operator|||
operator|!
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|output
operator|||
name|e
operator|->
name|callee
operator|==
name|node
condition|)
block|{
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"recursive inlining"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ninlined_callees
operator|=
name|cgraph_inlined_callees
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
name|cgraph_mark_inline
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
name|inlined_callees
argument_list|,
name|ninlined_callees
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined_callees
condition|;
name|y
operator|++
control|)
name|inlined_callees
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined_callees
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|callees
operator|->
name|caller
argument_list|)
argument_list|,
name|node
operator|->
name|callees
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
operator|&&
name|node
operator|->
name|global
operator|.
name|cloned_times
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inlined %i times for a net change of %+i insns.\n"
argument_list|,
name|node
operator|->
name|global
operator|.
name|cloned_times
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined
condition|;
name|y
operator|++
control|)
name|inlined
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|aux
operator|||
name|node
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_really_no_inline
condition|)
block|{
name|cgraph_decide_inlining_of_small_functions
argument_list|(
name|inlined
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|aux
operator|||
name|node
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nDeciding on functions called once:\n"
argument_list|)
expr_stmt|;
comment|/* And finally decide what functions are called once.  */
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|callers
operator|&&
operator|!
name|node
operator|->
name|callers
operator|->
name|next_caller
operator|&&
operator|!
name|node
operator|->
name|needed
operator|&&
name|node
operator|->
name|local
operator|.
name|inlinable
operator|&&
name|node
operator|->
name|callers
operator|->
name|inline_failed
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node1
decl_stmt|;
comment|/* Verify that we won't duplicate the caller.  */
for|for
control|(
name|node1
operator|=
name|node
operator|->
name|callers
operator|->
name|caller
init|;
name|node1
operator|->
name|callers
operator|&&
operator|!
name|node1
operator|->
name|callers
operator|->
name|inline_failed
operator|&&
name|ok
condition|;
name|node1
operator|=
name|node1
operator|->
name|callers
operator|->
name|caller
control|)
if|if
condition|(
name|node1
operator|->
name|callers
operator|->
name|next_caller
operator|||
name|node1
operator|->
name|needed
condition|)
name|ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|dummy_reason
decl_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nConsidering %s %i insns.\n"
literal|" Called once from %s %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|)
argument_list|,
name|node
operator|->
name|callers
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
name|ninlined
operator|=
name|cgraph_inlined_into
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|,
name|inlined
argument_list|)
expr_stmt|;
name|old_insns
operator|=
name|overall_insns
expr_stmt|;
comment|/* Inlining functions once would never cause inlining warnings.  */
if|if
condition|(
name|cgraph_check_inline_limits
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|,
name|node
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
operator|&
name|dummy_reason
argument_list|)
condition|)
block|{
name|ninlined_callees
operator|=
name|cgraph_inlined_callees
argument_list|(
name|node
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
name|cgraph_mark_inline
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|,
name|node
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
name|inlined_callees
argument_list|,
name|ninlined_callees
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined_callees
condition|;
name|y
operator|++
control|)
name|inlined_callees
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined_callees
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns"
literal|" for a net change of %+i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|)
argument_list|,
name|node
operator|->
name|callers
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" Inline limit reached, not inlined.\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined
condition|;
name|y
operator|++
control|)
name|inlined
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|cgraph_remove_unreachable_nodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nInlined %i calls, eliminated %i functions, "
literal|"%i insns turned to %i insns.\n\n"
argument_list|,
name|ncalls_inlined
argument_list|,
name|nfunctions_inlined
argument_list|,
name|initial_insns
argument_list|,
name|overall_insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inlined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inlined_callees
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide on the inlining.  We do so in the topological order to avoid    expenses on updating datastructures.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_decide_inlining_incrementally
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
operator|*
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|inlined_callees
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
operator|*
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
name|int
name|ninlined
decl_stmt|;
name|int
name|ninlined_callees
decl_stmt|;
name|int
name|y
decl_stmt|;
name|ninlined
operator|=
name|cgraph_inlined_into
argument_list|(
name|node
argument_list|,
name|inlined
argument_list|)
expr_stmt|;
comment|/* First of all look for always inline functions.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|&&
name|e
operator|->
name|inline_failed
comment|/* ??? It is possible that renaming variable removed the function body 	   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|output
operator|||
name|e
operator|->
name|callee
operator|==
name|node
condition|)
block|{
name|e
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"recursive inlining"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ninlined_callees
operator|=
name|cgraph_inlined_callees
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
name|cgraph_mark_inline
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
name|inlined_callees
argument_list|,
name|ninlined_callees
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined_callees
condition|;
name|y
operator|++
control|)
name|inlined_callees
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined_callees
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_really_no_inline
condition|)
block|{
comment|/* Now do the automatic inlining.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|inlinable
operator|&&
name|e
operator|->
name|inline_failed
operator|&&
name|cgraph_default_inline_p
argument_list|(
name|e
operator|->
name|callee
argument_list|)
operator|&&
name|cgraph_check_inline_limits
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
condition|)
block|{
comment|/* Marking recursive function inlinine has sane semantic and thus 	       we should not warn on it.  */
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|output
operator|||
name|e
operator|->
name|callee
operator|==
name|node
condition|)
block|{
name|e
operator|->
name|inline_failed
operator|=
literal|""
expr_stmt|;
continue|continue;
block|}
name|ninlined_callees
operator|=
name|cgraph_inlined_callees
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|inlined_callees
argument_list|)
expr_stmt|;
name|cgraph_mark_inline
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|inlined
argument_list|,
name|ninlined
argument_list|,
name|inlined_callees
argument_list|,
name|ninlined_callees
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined_callees
condition|;
name|y
operator|++
control|)
name|inlined_callees
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined_callees
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Clear the flags set by cgraph_inlined_into.  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ninlined
condition|;
name|y
operator|++
control|)
name|inlined
index|[
name|y
index|]
operator|->
name|output
operator|=
literal|0
operator|,
name|inlined
index|[
name|y
index|]
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|inlined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inlined_callees
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.    When returned false and reason is non-NULL, set it to the reason    why the call was not inlined.  */
end_comment

begin_function
name|bool
name|cgraph_inline_p
parameter_list|(
name|tree
name|caller_decl
parameter_list|,
name|tree
name|callee_decl
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|caller
init|=
name|cgraph_node
argument_list|(
name|caller_decl
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|callee
init|=
name|cgraph_node
argument_list|(
name|callee_decl
argument_list|)
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|caller
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|==
name|callee
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|inline_failed
operator|&&
name|reason
condition|)
operator|*
name|reason
operator|=
name|e
operator|->
name|inline_failed
expr_stmt|;
return|return
operator|!
name|e
operator|->
name|inline_failed
return|;
block|}
comment|/* We do not record builtins in the callgraph.  Perhaps it would make more      sense to do so and then prune out those not overwritten by explicit      function body.  */
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
literal|"originally indirect function calls never inlined"
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand all functions that must be output.     Attempt to topologically sort the nodes so function is output when    all called functions are already assembled to allow data to be    propagated across the callgraph.  Use a stack to get smaller distance    between a function and it's callees (later we may choose to use a more    sophisticated algorithm for function reordering; we will likely want    to use subsections to make the output functions appear in top-down    order).  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_expand_all_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|order_pos
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cgraph_mark_functions_to_output
argument_list|()
expr_stmt|;
name|order_pos
operator|=
name|cgraph_postorder
argument_list|(
name|order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|order_pos
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|output
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|reachable
condition|)
name|abort
argument_list|()
expr_stmt|;
name|node
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|cgraph_expand_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all local functions.     A local function is one whose calls can occur only in the    current compilation unit and all it's calls are explicit,    so we can change its calling convention.    We simply mark all static functions whose address is not taken    as local.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_mark_local_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nMarking local functions:"
argument_list|)
expr_stmt|;
comment|/* Figure out functions we want to assemble.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|node
operator|->
name|local
operator|.
name|local
operator|=
operator|(
operator|!
name|node
operator|->
name|needed
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
operator|&&
name|node
operator|->
name|local
operator|.
name|local
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgraph_dump_file
condition|)
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform simple optimizations based on callgraph.  */
end_comment

begin_function
name|void
name|cgraph_optimize
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_CGRAPHOPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Performing intraprocedural optimizations\n"
argument_list|)
expr_stmt|;
name|cgraph_mark_local_functions
argument_list|()
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Marked "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
name|cgraph_decide_inlining
argument_list|()
expr_stmt|;
name|cgraph_global_info_ready
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"Optimized "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_CGRAPHOPT
argument_list|)
expr_stmt|;
comment|/* Output everything.  */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Assembling functions:\n"
argument_list|)
expr_stmt|;
name|cgraph_expand_all_functions
argument_list|()
expr_stmt|;
if|if
condition|(
name|cgraph_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|cgraph_dump_file
argument_list|,
literal|"\nFinal "
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|cgraph_dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

