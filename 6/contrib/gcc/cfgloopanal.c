begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Natural loop analysis code for GNU compiler.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* Needed for doloop_condition_get().  */
end_comment

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_struct_decl
struct_decl|struct
name|unmark_altered_insn_data
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|unmark_altered
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blocks_invariant_registers
parameter_list|(
name|basic_block
modifier|*
parameter_list|,
name|int
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unmark_altered_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|unmark_altered_insn_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blocks_single_set_registers
parameter_list|(
name|basic_block
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invariant_rtx_wrto_regs_p_helper
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|invariant_rtx_wrto_regs_p
parameter_list|(
name|rtx
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|test_for_iteration
parameter_list|(
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|constant_iterations
parameter_list|(
name|struct
name|loop_desc
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|simple_loop_exit_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|edge
parameter_list|,
name|regset
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|struct
name|loop_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|variable_initial_value
parameter_list|(
name|rtx
parameter_list|,
name|regset
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|variable_initial_values
parameter_list|(
name|edge
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|simple_condition_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|regset
parameter_list|,
name|struct
name|loop_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|simple_increment
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|struct
name|loop_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|count_strange_loop_iterations
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDEST_INT
name|inverse
parameter_list|(
name|unsigned
name|HOST_WIDEST_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fits_in_mode_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Computes inverse to X modulo (1<< MOD).  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDEST_INT
name|inverse
parameter_list|(
name|unsigned
name|HOST_WIDEST_INT
name|x
parameter_list|,
name|int
name|mod
parameter_list|)
block|{
name|unsigned
name|HOST_WIDEST_INT
name|mask
init|=
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|mod
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|rslt
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mod
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rslt
operator|=
operator|(
name|rslt
operator|*
name|x
operator|)
operator|&
name|mask
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|*
name|x
operator|)
operator|&
name|mask
expr_stmt|;
block|}
return|return
name|rslt
return|;
block|}
end_function

begin_comment
comment|/* Checks whether BB is executed exactly once in each LOOP iteration.  */
end_comment

begin_function
name|bool
name|just_once_each_iteration_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
comment|/* It must be executed at least once each iteration.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* And just once.  */
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|!=
name|loop
condition|)
return|return
name|false
return|;
comment|/* But this was not enough.  We might have some irreducible loop here.  */
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Unmarks modified registers; helper to blocks_invariant_registers.  */
end_comment

begin_function
specifier|static
name|void
name|unmark_altered
parameter_list|(
name|rtx
name|what
parameter_list|,
name|rtx
name|by
name|ATTRIBUTE_UNUSED
parameter_list|,
name|regset
name|regs
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|what
argument_list|)
operator|==
name|SUBREG
condition|)
name|what
operator|=
name|SUBREG_REG
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|what
argument_list|)
condition|)
return|return;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|regs
argument_list|,
name|REGNO
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks registers that are invariant inside blocks BBS.  */
end_comment

begin_function
specifier|static
name|void
name|blocks_invariant_registers
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|,
name|regset
name|regs
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg_num
argument_list|()
condition|;
name|i
operator|++
control|)
name|SET_REGNO_REG_SET
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|unmark_altered
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unmarks modified registers; helper to blocks_single_set_registers.  */
end_comment

begin_struct
struct|struct
name|unmark_altered_insn_data
block|{
name|rtx
modifier|*
name|regs
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|unmark_altered_insn
parameter_list|(
name|rtx
name|what
parameter_list|,
name|rtx
name|by
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|unmark_altered_insn_data
modifier|*
name|data
parameter_list|)
block|{
name|int
name|rn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|what
argument_list|)
operator|==
name|SUBREG
condition|)
name|what
operator|=
name|SUBREG_REG
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|what
argument_list|)
condition|)
return|return;
name|rn
operator|=
name|REGNO
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|regs
index|[
name|rn
index|]
operator|==
name|data
operator|->
name|insn
condition|)
return|return;
name|data
operator|->
name|regs
index|[
name|rn
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks registers that have just single simple set in BBS; the relevant    insn is returned in REGS.  */
end_comment

begin_function
specifier|static
name|void
name|blocks_single_set_registers
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|,
name|rtx
modifier|*
name|regs
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|unmark_altered_insn_data
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg_num
argument_list|()
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|&&
name|is_bct_cond
argument_list|(
name|insn
argument_list|)
condition|)
name|set
operator|=
name|get_var_set_from_bct
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
continue|continue;
name|regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
name|data
operator|.
name|regs
operator|=
name|regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|unmark_altered_insn
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper for invariant_rtx_wrto_regs_p.  */
end_comment

begin_function
specifier|static
name|int
name|invariant_rtx_wrto_regs_p_helper
parameter_list|(
name|rtx
modifier|*
name|expr
parameter_list|,
name|regset
name|invariant_regs
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
operator|*
name|expr
argument_list|)
condition|)
block|{
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|1
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
return|return
name|MEM_VOLATILE_P
argument_list|(
operator|*
name|expr
argument_list|)
return|;
case|case
name|MEM
case|:
comment|/* If the memory is not constant, assume it is modified.  If it is 	 constant, we still have to check the address.  */
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
operator|*
name|expr
argument_list|)
return|;
case|case
name|REG
case|:
return|return
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|invariant_regs
argument_list|,
name|REGNO
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant.  */
end_comment

begin_function
specifier|static
name|bool
name|invariant_rtx_wrto_regs_p
parameter_list|(
name|rtx
name|expr
parameter_list|,
name|regset
name|invariant_regs
parameter_list|)
block|{
return|return
operator|!
name|for_each_rtx
argument_list|(
operator|&
name|expr
argument_list|,
operator|(
name|rtx_function
operator|)
name|invariant_rtx_wrto_regs_p_helper
argument_list|,
name|invariant_regs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether CONDITION is a simple comparison in that one of operands    is register and the other one is invariant in the LOOP. Fills var, lim    and cond fields in DESC.  */
end_comment

begin_function
specifier|static
name|bool
name|simple_condition_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|condition
parameter_list|,
name|regset
name|invariant_regs
parameter_list|,
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Check condition.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* Of integers or pointers.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
name|false
return|;
comment|/* One of operands must be a simple register.  */
name|op0
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* One of operands must be invariant.  */
if|if
condition|(
name|invariant_rtx_wrto_regs_p
argument_list|(
name|op0
argument_list|,
name|invariant_regs
argument_list|)
condition|)
block|{
comment|/* And the other one must be a register.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|false
return|;
name|desc
operator|->
name|var
operator|=
name|op1
expr_stmt|;
name|desc
operator|->
name|lim
operator|=
name|op0
expr_stmt|;
name|desc
operator|->
name|cond
operator|=
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|cond
operator|==
name|UNKNOWN
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|/* Check the other operand.  */
if|if
condition|(
operator|!
name|invariant_rtx_wrto_regs_p
argument_list|(
name|op1
argument_list|,
name|invariant_regs
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|false
return|;
name|desc
operator|->
name|var
operator|=
name|op0
expr_stmt|;
name|desc
operator|->
name|lim
operator|=
name|op1
expr_stmt|;
name|desc
operator|->
name|cond
operator|=
name|GET_CODE
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Checks whether DESC->var is incremented/decremented exactly once each    iteration.  Fills in DESC->stride and returns block in that DESC->var is    modified.  */
end_comment

begin_function
specifier|static
name|basic_block
name|simple_increment
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
modifier|*
name|simple_increment_regs
parameter_list|,
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|)
block|{
name|rtx
name|mod_insn
decl_stmt|,
name|mod_insn1
decl_stmt|,
name|set
decl_stmt|,
name|set_src
decl_stmt|,
name|set_add
decl_stmt|;
name|basic_block
name|mod_bb
decl_stmt|,
name|mod_bb1
decl_stmt|;
comment|/* Find insn that modifies var.  */
name|mod_insn
operator|=
name|simple_increment_regs
index|[
name|REGNO
argument_list|(
name|desc
operator|->
name|var
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mod_insn
condition|)
return|return
name|NULL
return|;
name|mod_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|mod_insn
argument_list|)
expr_stmt|;
comment|/* Check that it is executed exactly once each iteration.  */
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|mod_bb
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* mod_insn must be a simple increment/decrement.  */
name|set
operator|=
name|single_set
argument_list|(
name|mod_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|&&
name|is_bct_cond
argument_list|(
name|mod_insn
argument_list|)
condition|)
name|set
operator|=
name|get_var_set_from_bct
argument_list|(
name|mod_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|desc
operator|->
name|var
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set_src
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|mod_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_src
condition|)
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Check for variables that iterate in narrower mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
comment|/* If we are sign extending variable that is then compared unsigned 	 or vice versa, there is something weird happening.  */
if|if
condition|(
name|desc
operator|->
name|cond
operator|!=
name|EQ
operator|&&
name|desc
operator|->
name|cond
operator|!=
name|NE
operator|&&
operator|(
operator|(
name|desc
operator|->
name|cond
operator|==
name|LEU
operator|||
name|desc
operator|->
name|cond
operator|==
name|LTU
operator|||
name|desc
operator|->
name|cond
operator|==
name|GEU
operator|||
name|desc
operator|->
name|cond
operator|==
name|GTU
operator|)
operator|^
operator|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SUBREG
operator|||
name|SUBREG_BYTE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
condition|)
return|return
name|NULL
return|;
name|desc
operator|->
name|inner_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|extend
operator|=
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
expr_stmt|;
name|set_src
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|NULL
return|;
comment|/* Find where the reg is set.  */
name|mod_insn1
operator|=
name|simple_increment_regs
index|[
name|REGNO
argument_list|(
name|set_src
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mod_insn1
condition|)
return|return
name|NULL
return|;
name|mod_bb1
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|mod_insn1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|mod_bb
argument_list|,
name|mod_bb1
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mod_bb1
operator|==
name|mod_bb
condition|)
block|{
for|for
control|(
init|;
name|mod_insn
operator|!=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|mod_bb
argument_list|)
argument_list|)
condition|;
name|mod_insn
operator|=
name|PREV_INSN
argument_list|(
name|mod_insn
argument_list|)
control|)
if|if
condition|(
name|mod_insn
operator|==
name|mod_insn1
condition|)
break|break;
if|if
condition|(
name|mod_insn
operator|==
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|mod_bb
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
comment|/* Replace the source with the possible place of increment.  */
name|set
operator|=
name|single_set
argument_list|(
name|mod_insn1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|set_src
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set_src
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|mod_insn1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_src
condition|)
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|->
name|inner_mode
operator|=
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
expr_stmt|;
name|desc
operator|->
name|extend
operator|=
name|NIL
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|desc
operator|->
name|var
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Set desc->stride.  */
name|set_add
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|set_add
argument_list|)
condition|)
name|desc
operator|->
name|stride
operator|=
name|set_add
expr_stmt|;
else|else
return|return
name|NULL
return|;
return|return
name|mod_bb
return|;
block|}
end_function

begin_comment
comment|/* Tries to find initial value of VAR in INSN.  This value must be invariant    wrto INVARIANT_REGS.  If SET_INSN is not NULL, insn in that var is set is    placed here.  INNER_MODE is mode in that induction variable VAR iterates.  */
end_comment

begin_function
specifier|static
name|rtx
name|variable_initial_value
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|regset
name|invariant_regs
parameter_list|,
name|rtx
name|var
parameter_list|,
name|rtx
modifier|*
name|set_insn
parameter_list|,
name|enum
name|machine_mode
name|inner_mode
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL
decl_stmt|;
comment|/* Go back through cfg.  */
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
init|;
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|unmark_altered
argument_list|,
name|invariant_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_between_p
argument_list|(
name|var
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
block|{
comment|/* We found place where var is set.  */
name|rtx
name|set_dest
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NULL
return|;
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|set_dest
argument_list|,
name|var
argument_list|)
condition|)
return|return
name|NULL
return|;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|val
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* If we know that the initial value is indeed in range of 	     the inner mode, record the fact even in case the value itself 	     is useless.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|inner_mode
condition|)
name|ret
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|gen_rtx_fmt_ei
argument_list|(
name|SUBREG
argument_list|,
name|inner_mode
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invariant_rtx_wrto_regs_p
argument_list|(
name|val
argument_list|,
name|invariant_regs
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|set_insn
condition|)
operator|*
name|set_insn
operator|=
name|insn
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|bb
operator|->
name|pred
operator|->
name|pred_next
operator|||
name|bb
operator|->
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|NULL
return|;
name|bb
operator|=
name|bb
operator|->
name|pred
operator|->
name|src
expr_stmt|;
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns list of definitions of initial value of VAR at edge E.  INNER_MODE    is mode in that induction variable VAR really iterates.  */
end_comment

begin_function
specifier|static
name|rtx
name|variable_initial_values
parameter_list|(
name|edge
name|e
parameter_list|,
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|inner_mode
parameter_list|)
block|{
name|rtx
name|set_insn
decl_stmt|,
name|list
decl_stmt|;
name|regset
name|invariant_regs
decl_stmt|;
name|regset_head
name|invariant_regs_head
decl_stmt|;
name|int
name|i
decl_stmt|;
name|invariant_regs
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|invariant_regs_head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg_num
argument_list|()
condition|;
name|i
operator|++
control|)
name|SET_REGNO_REG_SET
argument_list|(
name|invariant_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|copy_rtx
argument_list|(
name|var
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|list
return|;
name|set_insn
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
name|REG_P
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|var
operator|=
name|variable_initial_value
argument_list|(
name|set_insn
argument_list|,
name|invariant_regs
argument_list|,
name|var
argument_list|,
operator|&
name|set_insn
argument_list|,
name|inner_mode
argument_list|)
operator|)
condition|)
name|list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|copy_rtx
argument_list|(
name|var
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|invariant_regs
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Counts constant number of iterations of the loop described by DESC;    returns false if impossible.  */
end_comment

begin_function
specifier|static
name|bool
name|constant_iterations
parameter_list|(
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|niter
parameter_list|,
name|bool
modifier|*
name|may_be_zero
parameter_list|)
block|{
name|rtx
name|test
decl_stmt|,
name|expr
decl_stmt|;
name|rtx
name|ainit
decl_stmt|,
name|alim
decl_stmt|;
name|test
operator|=
name|test_for_iteration
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
name|const0_rtx
condition|)
block|{
operator|*
name|niter
operator|=
literal|0
expr_stmt|;
operator|*
name|may_be_zero
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|may_be_zero
operator|=
operator|(
name|test
operator|!=
name|const_true_rtx
operator|)
expr_stmt|;
comment|/* It would make a little sense to check every with every when we      know that all but the first alternative are simply registers.  */
for|for
control|(
name|ainit
operator|=
name|desc
operator|->
name|var_alts
init|;
name|ainit
condition|;
name|ainit
operator|=
name|XEXP
argument_list|(
name|ainit
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|alim
operator|=
name|XEXP
argument_list|(
name|desc
operator|->
name|lim_alts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expr
operator|=
name|count_loop_iterations
argument_list|(
name|desc
argument_list|,
name|XEXP
argument_list|(
name|ainit
argument_list|,
literal|0
argument_list|)
argument_list|,
name|alim
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|niter
operator|=
name|INTVAL
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
for|for
control|(
name|alim
operator|=
name|XEXP
argument_list|(
name|desc
operator|->
name|lim_alts
argument_list|,
literal|1
argument_list|)
init|;
name|alim
condition|;
name|alim
operator|=
name|XEXP
argument_list|(
name|alim
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ainit
operator|=
name|XEXP
argument_list|(
name|desc
operator|->
name|var_alts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expr
operator|=
name|count_loop_iterations
argument_list|(
name|desc
argument_list|,
name|ainit
argument_list|,
name|XEXP
argument_list|(
name|alim
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|niter
operator|=
name|INTVAL
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Attempts to determine a number of iterations of a "strange" loop.    Its induction variable starts with value INIT, is compared by COND    with LIM.  If POSTINCR, it is incremented after the test.  It is incremented    by STRIDE each iteration, has mode MODE but iterates in INNER_MODE.     By "strange" we mean loops where induction variable increases in the wrong    direction wrto comparison, i.e. for (i = 6; i> 5; i++).  */
end_comment

begin_function
specifier|static
name|rtx
name|count_strange_loop_iterations
parameter_list|(
name|rtx
name|init
parameter_list|,
name|rtx
name|lim
parameter_list|,
name|enum
name|rtx_code
name|cond
parameter_list|,
name|int
name|postincr
parameter_list|,
name|rtx
name|stride
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|inner_mode
parameter_list|)
block|{
name|rtx
name|rqmt
decl_stmt|,
name|n_to_wrap
decl_stmt|,
name|before_wrap
decl_stmt|,
name|after_wrap
decl_stmt|;
name|rtx
name|mode_min
decl_stmt|,
name|mode_max
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* This could be handled, but it is not important enough to lose time with      it just now.  */
if|if
condition|(
name|mode
operator|!=
name|inner_mode
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|postincr
condition|)
name|init
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|init
argument_list|,
name|stride
argument_list|)
expr_stmt|;
comment|/* If we are able to prove that we don't pass the first test, we are      done.  */
name|rqmt
operator|=
name|simplify_relational_operation
argument_list|(
name|cond
argument_list|,
name|mode
argument_list|,
name|init
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqmt
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
comment|/* And if we don't know we pass it, the things are too complicated for us.  */
if|if
condition|(
name|rqmt
operator|!=
name|const_true_rtx
condition|)
return|return
name|NULL_RTX
return|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|mode_min
operator|=
name|gen_int_mode
argument_list|(
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mode_max
operator|=
name|gen_int_mode
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|EQ
case|:
name|mode_min
operator|=
name|const0_rtx
expr_stmt|;
name|mode_max
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|const0_rtx
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|EQ
case|:
comment|/* This iterates once, as init == lim.  */
return|return
name|const1_rtx
return|;
comment|/* The behavior is undefined in signed cases.  Never mind, we still 	 try to behave sanely.  */
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|stride
argument_list|)
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n_to_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|mode_max
argument_list|,
name|copy_rtx
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|n_to_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|n_to_wrap
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|before_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|n_to_wrap
argument_list|)
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|before_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|before_wrap
argument_list|,
name|copy_rtx
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|before_wrap
argument_list|,
name|stride
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|after_wrap
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|mode_min
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|after_wrap
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|stride
argument_list|)
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stride
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|stride
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|n_to_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|init
argument_list|)
argument_list|,
name|mode_min
argument_list|)
expr_stmt|;
name|n_to_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|n_to_wrap
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|before_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|n_to_wrap
argument_list|)
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|before_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|init
argument_list|)
argument_list|,
name|before_wrap
argument_list|)
expr_stmt|;
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|before_wrap
argument_list|,
name|stride
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|after_wrap
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|mode_max
argument_list|,
name|stride
argument_list|)
expr_stmt|;
name|after_wrap
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|after_wrap
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is const_true_rtx and we did not take a conservative approximation      of after_wrap above, we might iterate the calculation (but of course we      would have to take care about infinite cases).  Ignore this for now.  */
name|rqmt
operator|=
name|simplify_relational_operation
argument_list|(
name|cond
argument_list|,
name|mode
argument_list|,
name|after_wrap
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqmt
operator|!=
name|const0_rtx
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|n_to_wrap
argument_list|,
name|const1_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether value of EXPR fits into range of MODE.  */
end_comment

begin_function
specifier|static
name|bool
name|fits_in_mode_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|expr
parameter_list|)
block|{
name|unsigned
name|HOST_WIDEST_INT
name|val
decl_stmt|;
name|int
name|n_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
for|for
control|(
name|val
operator|=
name|INTVAL
argument_list|(
name|expr
argument_list|)
init|;
name|val
condition|;
name|val
operator|>>=
literal|1
control|)
name|n_bits
operator|++
expr_stmt|;
return|return
name|n_bits
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
return|return
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return RTX expression representing number of iterations of loop as bounded    by test described by DESC (in the case loop really has multiple exit    edges, fewer iterations may happen in the practice).     Return NULL if it is unknown.  Additionally the value may be invalid for    paradoxical loop (lets define paradoxical loops as loops whose test is    failing at -1th iteration, for instance "for (i=5;i<1;i++);").     These cases needs to be either cared by copying the loop test in the front    of loop or keeping the test in first iteration of loop.     When INIT/LIM are set, they are used instead of var/lim of DESC.  */
end_comment

begin_function
name|rtx
name|count_loop_iterations
parameter_list|(
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|,
name|rtx
name|init
parameter_list|,
name|rtx
name|lim
parameter_list|)
block|{
name|enum
name|rtx_code
name|cond
init|=
name|desc
operator|->
name|cond
decl_stmt|;
name|rtx
name|stride
init|=
name|desc
operator|->
name|stride
decl_stmt|;
name|rtx
name|mod
decl_stmt|,
name|exp
decl_stmt|,
name|ainit
decl_stmt|,
name|bound
decl_stmt|;
name|rtx
name|overflow_check
decl_stmt|,
name|mx
decl_stmt|,
name|mxp
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|s
decl_stmt|,
name|size
decl_stmt|,
name|d
decl_stmt|;
comment|/* Give up on floating point modes and friends.  It can be possible to do      the job for constant loop bounds, but it is probably not worthwhile.  */
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|NULL
return|;
name|init
operator|=
name|copy_rtx
argument_list|(
name|init
condition|?
name|init
else|:
name|desc
operator|->
name|var
argument_list|)
expr_stmt|;
name|lim
operator|=
name|copy_rtx
argument_list|(
name|lim
condition|?
name|lim
else|:
name|desc
operator|->
name|lim
argument_list|)
expr_stmt|;
comment|/* Ensure that we always handle the condition to stay inside loop.  */
if|if
condition|(
name|desc
operator|->
name|neg
condition|)
name|cond
operator|=
name|reverse_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|inner_mode
operator|!=
name|mode
condition|)
block|{
comment|/* We have a case when the variable in fact iterates in the narrower 	 mode.  This has following consequences: 	  	 For induction variable itself, if !desc->postincr, it does not mean 	 anything too special, since we know the variable is already in range 	 of the inner mode when we compare it (so it is just needed to shorten 	 it into the mode before calculations are done, so that we don't risk 	 wrong results).  More complicated case is when desc->postincr; then 	 the first two iterations are special (the first one because the value 	 may be out of range, the second one because after shortening it to the 	 range it may have absolutely any value), and we do not handle this in 	 unrolling.  So if we aren't able to prove that the initial value is in 	 the range, we fail in this case. 	  	 Step is just moduled to fit into inner mode.  	 If lim is out of range, then either the loop is infinite (and then 	 we may unroll however we like to), or exits in the first iteration 	 (this is also ok, since we handle it specially for this case anyway). 	 So we may safely assume that it fits into the inner mode.  */
for|for
control|(
name|ainit
operator|=
name|desc
operator|->
name|var_alts
init|;
name|ainit
condition|;
name|ainit
operator|=
name|XEXP
argument_list|(
name|ainit
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|fits_in_mode_p
argument_list|(
name|desc
operator|->
name|inner_mode
argument_list|,
name|XEXP
argument_list|(
name|ainit
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ainit
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|postincr
condition|)
return|return
name|NULL_RTX
return|;
name|init
operator|=
name|simplify_gen_unary
argument_list|(
name|desc
operator|->
name|extend
argument_list|,
name|mode
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|desc
operator|->
name|inner_mode
argument_list|,
name|init
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
expr_stmt|;
block|}
name|stride
operator|=
name|simplify_gen_subreg
argument_list|(
name|desc
operator|->
name|inner_mode
argument_list|,
name|stride
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stride
operator|==
name|const0_rtx
condition|)
return|return
name|NULL_RTX
return|;
block|}
comment|/* Prepare condition to verify that we do not risk overflow.  */
if|if
condition|(
name|stride
operator|==
name|const1_rtx
operator|||
name|stride
operator|==
name|constm1_rtx
operator|||
name|cond
operator|==
name|NE
operator|||
name|cond
operator|==
name|EQ
condition|)
block|{
comment|/* Overflow at NE conditions does not occur.  EQ condition 	 is weird and is handled in count_strange_loop_iterations. 	 If stride is 1, overflow may occur only for<= and>= conditions, 	 and then they are infinite, so it does not bother us.  */
name|overflow_check
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cond
operator|==
name|LT
operator|||
name|cond
operator|==
name|LTU
condition|)
name|mx
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|lim
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|GT
operator|||
name|cond
operator|==
name|GTU
condition|)
name|mx
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|lim
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
else|else
name|mx
operator|=
name|lim
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|desc
operator|->
name|inner_mode
condition|)
name|mxp
operator|=
name|simplify_gen_subreg
argument_list|(
name|desc
operator|->
name|inner_mode
argument_list|,
name|mx
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|mxp
operator|=
name|mx
expr_stmt|;
name|mxp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|,
name|mxp
argument_list|,
name|stride
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|desc
operator|->
name|inner_mode
condition|)
name|mxp
operator|=
name|simplify_gen_unary
argument_list|(
name|desc
operator|->
name|extend
argument_list|,
name|mode
argument_list|,
name|mxp
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
expr_stmt|;
name|overflow_check
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|mx
argument_list|,
name|mxp
argument_list|)
expr_stmt|;
block|}
comment|/* Compute absolute value of the difference of initial and final value.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|stride
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Handle strange tests specially.  */
if|if
condition|(
name|cond
operator|==
name|EQ
operator|||
name|cond
operator|==
name|GE
operator|||
name|cond
operator|==
name|GT
operator|||
name|cond
operator|==
name|GEU
operator|||
name|cond
operator|==
name|GTU
condition|)
return|return
name|count_strange_loop_iterations
argument_list|(
name|init
argument_list|,
name|lim
argument_list|,
name|cond
argument_list|,
name|desc
operator|->
name|postincr
argument_list|,
name|stride
argument_list|,
name|mode
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
return|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|lim
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cond
operator|==
name|EQ
operator|||
name|cond
operator|==
name|LE
operator|||
name|cond
operator|==
name|LT
operator|||
name|cond
operator|==
name|LEU
operator|||
name|cond
operator|==
name|LTU
condition|)
return|return
name|count_strange_loop_iterations
argument_list|(
name|init
argument_list|,
name|lim
argument_list|,
name|cond
argument_list|,
name|desc
operator|->
name|postincr
argument_list|,
name|stride
argument_list|,
name|mode
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
return|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|init
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|stride
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|stride
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* If there is a risk of overflow (i.e. when we increment value satisfying      a condition, we may again obtain a value satisfying the condition),      fail.  */
if|if
condition|(
name|overflow_check
operator|!=
name|const0_rtx
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Normalize difference so the value is always first examined      and later incremented.  Do not do this for a loop ending with a branch       and count register.  */
if|if
condition|(
operator|!
name|is_bct_cond
argument_list|(
name|BB_END
argument_list|(
name|desc
operator|->
name|out_edge
operator|->
name|src
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|desc
operator|->
name|postincr
operator|)
condition|)
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|stride
argument_list|)
expr_stmt|;
comment|/* Determine delta caused by exit condition.  */
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|NE
case|:
comment|/* NE tests are easy to handle, because we just perform simple 	 arithmetics modulo power of 2.  Let's use the fact to compute the 	 number of iterations exactly.  We are now in situation when we want to 	 solve an equation stride * i = c (mod size of inner_mode). 	 Let nsd (stride, size of mode) = d.  If d does not divide c, the 	 loop is infinite.  Otherwise, the number of iterations is 	 (inverse(s/d) * (c/d)) mod (size of mode/d).  */
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|desc
operator|->
name|inner_mode
argument_list|)
expr_stmt|;
name|s
operator|=
name|INTVAL
argument_list|(
name|stride
argument_list|)
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|%
literal|2
operator|!=
literal|1
condition|)
block|{
name|s
operator|/=
literal|2
expr_stmt|;
name|d
operator|*=
literal|2
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
name|bound
operator|=
name|gen_int_mode
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|gen_int_mode
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|gen_int_mode
argument_list|(
name|inverse
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|bound
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|!=
name|NE
operator|&&
name|stride
operator|!=
name|const1_rtx
condition|)
block|{
comment|/* Number of iterations is now (EXP + STRIDE - 1 / STRIDE), 	 but we need to take care for overflows.  */
name|mod
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|stride
argument_list|)
expr_stmt|;
comment|/* This is dirty trick.  When we can't compute number of iterations 	 to be constant, we simply ignore the possible overflow, as 	 runtime unroller always use power of 2 amounts and does not 	 care about possible lost bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mod
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|stridem1
init|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|stride
argument_list|,
name|constm1_rtx
argument_list|)
decl_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|stridem1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|stride
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|!=
name|const0_rtx
condition|)
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Number of iterations: "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Return simplified RTX expression representing the value of test    described of DESC at given iteration of loop.  */
end_comment

begin_function
specifier|static
name|rtx
name|test_for_iteration
parameter_list|(
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|iter
parameter_list|)
block|{
name|enum
name|rtx_code
name|cond
init|=
name|desc
operator|->
name|cond
decl_stmt|;
name|rtx
name|exp
init|=
name|XEXP
argument_list|(
name|desc
operator|->
name|var_alts
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|addval
decl_stmt|;
comment|/* Give up on floating point modes and friends.  It can be possible to do      the job for constant loop bounds, but it is probably not worthwhile.  */
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure that we always handle the condition to stay inside loop.  */
if|if
condition|(
name|desc
operator|->
name|neg
condition|)
name|cond
operator|=
name|reverse_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Compute the value of induction variable.  */
name|addval
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|desc
operator|->
name|stride
argument_list|,
name|gen_int_mode
argument_list|(
name|desc
operator|->
name|postincr
condition|?
name|iter
else|:
name|iter
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|exp
argument_list|,
name|addval
argument_list|)
expr_stmt|;
comment|/* Test at given condition.  */
name|exp
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|exp
argument_list|,
name|desc
operator|->
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Conditional to continue loop at "
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"th iteration: "
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Tests whether exit at EXIT_EDGE from LOOP is simple.  Returns simple loop    description joined to it in in DESC.  INVARIANT_REGS and SINGLE_SET_REGS    are results of blocks_{invariant,single_set}_regs over BODY.  */
end_comment

begin_function
specifier|static
name|bool
name|simple_loop_exit_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit_edge
parameter_list|,
name|regset
name|invariant_regs
parameter_list|,
name|rtx
modifier|*
name|single_set_regs
parameter_list|,
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|)
block|{
name|basic_block
name|mod_bb
decl_stmt|,
name|exit_bb
decl_stmt|;
name|int
name|fallthru_out
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|edge
name|ei
decl_stmt|,
name|e
decl_stmt|;
name|exit_bb
operator|=
name|exit_edge
operator|->
name|src
expr_stmt|;
name|fallthru_out
operator|=
operator|(
name|exit_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_bb
condition|)
return|return
name|false
return|;
comment|/* It must be tested (at least) once during any iteration.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|exit_bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* It must end in a simple conditional jump.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|exit_bb
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|ei
operator|=
name|exit_bb
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|ei
operator|==
name|exit_edge
condition|)
name|ei
operator|=
name|ei
operator|->
name|succ_next
expr_stmt|;
name|desc
operator|->
name|out_edge
operator|=
name|exit_edge
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|ei
expr_stmt|;
comment|/* Condition must be a simple comparison in that one of operands      is register and the other one is invariant.  */
if|if
condition|(
operator|!
operator|(
name|condition
operator|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|exit_bb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple_condition_p
argument_list|(
name|loop
argument_list|,
name|condition
argument_list|,
name|invariant_regs
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|false
return|;
comment|/*  Var must be simply incremented or decremented in exactly one insn that      is executed just once every iteration.  */
if|if
condition|(
operator|!
operator|(
name|mod_bb
operator|=
name|simple_increment
argument_list|(
name|loop
argument_list|,
name|single_set_regs
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* OK, it is simple loop.  Now just fill in remaining info.  */
name|desc
operator|->
name|postincr
operator|=
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_bb
argument_list|,
name|mod_bb
argument_list|)
expr_stmt|;
name|desc
operator|->
name|neg
operator|=
operator|!
name|fallthru_out
expr_stmt|;
comment|/* Find initial value of var and alternative values for lim.  */
name|e
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|desc
operator|->
name|var_alts
operator|=
name|variable_initial_values
argument_list|(
name|e
argument_list|,
name|desc
operator|->
name|var
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
expr_stmt|;
name|desc
operator|->
name|lim_alts
operator|=
name|variable_initial_values
argument_list|(
name|e
argument_list|,
name|desc
operator|->
name|lim
argument_list|,
name|desc
operator|->
name|inner_mode
argument_list|)
expr_stmt|;
comment|/* Number of iterations.  */
name|desc
operator|->
name|const_iter
operator|=
name|constant_iterations
argument_list|(
name|desc
argument_list|,
operator|&
name|desc
operator|->
name|niter
argument_list|,
operator|&
name|desc
operator|->
name|may_be_zero
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
operator|->
name|const_iter
operator|&&
operator|!
name|count_loop_iterations
argument_list|(
name|desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Tests whether LOOP is simple for loop.  Returns simple loop description    in DESC.  */
end_comment

begin_function
name|bool
name|simple_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loop_desc
modifier|*
name|desc
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop_desc
name|act
decl_stmt|;
name|bool
name|any
init|=
name|false
decl_stmt|;
name|regset
name|invariant_regs
decl_stmt|;
name|regset_head
name|invariant_regs_head
decl_stmt|;
name|rtx
modifier|*
name|single_set_regs
decl_stmt|;
name|int
name|n_branches
decl_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|invariant_regs
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|invariant_regs_head
argument_list|)
expr_stmt|;
name|single_set_regs
operator|=
name|xmalloc
argument_list|(
name|max_reg_num
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|blocks_invariant_registers
argument_list|(
name|body
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|,
name|invariant_regs
argument_list|)
expr_stmt|;
name|blocks_single_set_registers
argument_list|(
name|body
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|,
name|single_set_regs
argument_list|)
expr_stmt|;
name|n_branches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|e
operator|=
name|body
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
operator|&&
name|simple_loop_exit_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|,
name|invariant_regs
argument_list|,
name|single_set_regs
argument_list|,
operator|&
name|act
argument_list|)
condition|)
block|{
comment|/* Prefer constant iterations; the less the better.  */
if|if
condition|(
operator|!
name|any
condition|)
name|any
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|act
operator|.
name|const_iter
operator|||
operator|(
name|desc
operator|->
name|const_iter
operator|&&
name|act
operator|.
name|niter
operator|>=
name|desc
operator|->
name|niter
operator|)
condition|)
continue|continue;
operator|*
name|desc
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|succ
operator|&&
name|body
index|[
name|i
index|]
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|n_branches
operator|++
expr_stmt|;
block|}
name|desc
operator|->
name|n_branches
operator|=
name|n_branches
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|&&
name|any
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"; Simple loop %i\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|postincr
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  does postincrement after loop exit condition\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Induction variable:"
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|desc
operator|->
name|var
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Initial values:"
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|desc
operator|->
name|var_alts
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Stride:"
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|desc
operator|->
name|stride
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Compared with:"
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|desc
operator|->
name|lim
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Alternative values:"
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|rtl_dump_file
argument_list|,
name|desc
operator|->
name|lim_alts
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Exit condition:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|neg
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"(negated)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%s\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|desc
operator|->
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";  Number of branches:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d\n"
argument_list|,
name|desc
operator|->
name|n_branches
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|invariant_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|single_set_regs
argument_list|)
expr_stmt|;
return|return
name|any
return|;
block|}
end_function

begin_comment
comment|/* Marks blocks and edges that are part of non-recognized loops; i.e. we    throw away all latch edges and mark blocks inside any remaining cycle.    Everything is a bit complicated due to fact we do not want to do this    for parts of cycles that only "pass" through some loop -- i.e. for    each cycle, we want to mark blocks that belong directly to innermost    loop containing the whole cycle.  */
end_comment

begin_function
name|void
name|mark_irreducible_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|int
modifier|*
name|dfs_in
decl_stmt|,
modifier|*
name|closed
decl_stmt|,
modifier|*
name|mr
decl_stmt|,
modifier|*
name|mri
decl_stmt|,
modifier|*
name|n_edges
decl_stmt|,
modifier|*
name|stack
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|edge
modifier|*
modifier|*
name|edges
decl_stmt|,
name|e
decl_stmt|;
name|edge
modifier|*
name|estack
decl_stmt|;
name|basic_block
name|act
decl_stmt|;
name|int
name|stack_top
decl_stmt|,
name|tick
decl_stmt|,
name|depth
decl_stmt|;
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|;
comment|/* Reset the flags.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|act
operator|->
name|flags
operator|&=
operator|~
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
for|for
control|(
name|e
operator|=
name|act
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
comment|/* The first last_basic_block + 1 entries are for real blocks (including      entry); then we have loops->num - 1 fake blocks for loops to that we      assign edges leading from loops (fake loop 0 is not interesting).  */
name|dfs_in
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|closed
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|mri
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|n_edges
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|edges
operator|=
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|estack
operator|=
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
name|loops
operator|->
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the edge lists.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
operator|+
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|n_edges
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
for|for
control|(
name|e
operator|=
name|act
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
comment|/* Ignore edges to exit.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
comment|/* And latch edges.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|e
operator|->
name|dest
operator|&&
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|act
condition|)
continue|continue;
comment|/* Edges inside a single loop should be left where they are.  Edges 	   to subloop headers should lead to representative of the subloop, 	   but from the same place.  */
if|if
condition|(
name|act
operator|->
name|loop_father
operator|==
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|||
name|act
operator|->
name|loop_father
operator|==
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|outer
condition|)
block|{
name|n_edges
index|[
name|act
operator|->
name|index
operator|+
literal|1
index|]
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Edges exiting loops remain.  They should lead from representative 	   of the son of nearest common ancestor of the loops in that 	   act lays.  */
name|depth
operator|=
name|find_common_loop
argument_list|(
name|act
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|act
operator|->
name|loop_father
operator|->
name|depth
condition|)
name|cloop
operator|=
name|act
operator|->
name|loop_father
expr_stmt|;
else|else
name|cloop
operator|=
name|act
operator|->
name|loop_father
operator|->
name|pred
index|[
name|depth
index|]
expr_stmt|;
name|n_edges
index|[
name|cloop
operator|->
name|num
operator|+
name|last_basic_block
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
operator|+
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|edges
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|n_edges
index|[
name|i
index|]
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|n_edges
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
for|for
control|(
name|e
operator|=
name|act
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|e
operator|->
name|dest
operator|&&
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|act
condition|)
continue|continue;
if|if
condition|(
name|act
operator|->
name|loop_father
operator|==
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|||
name|act
operator|->
name|loop_father
operator|==
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|outer
condition|)
block|{
name|edges
index|[
name|act
operator|->
name|index
operator|+
literal|1
index|]
index|[
name|n_edges
index|[
name|act
operator|->
name|index
operator|+
literal|1
index|]
operator|++
index|]
operator|=
name|e
expr_stmt|;
continue|continue;
block|}
name|depth
operator|=
name|find_common_loop
argument_list|(
name|act
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|act
operator|->
name|loop_father
operator|->
name|depth
condition|)
name|cloop
operator|=
name|act
operator|->
name|loop_father
expr_stmt|;
else|else
name|cloop
operator|=
name|act
operator|->
name|loop_father
operator|->
name|pred
index|[
name|depth
index|]
expr_stmt|;
name|i
operator|=
name|cloop
operator|->
name|num
operator|+
name|last_basic_block
expr_stmt|;
name|edges
index|[
name|i
index|]
index|[
name|n_edges
index|[
name|i
index|]
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
comment|/* Compute dfs numbering, starting from loop headers, and mark found      loops.  */
name|tick
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
operator|+
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|dfs_in
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|closed
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mr
index|[
name|i
index|]
operator|=
name|last_basic_block
operator|+
name|loops
operator|->
name|num
expr_stmt|;
name|mri
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|stack_top
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
block|{
name|stack
index|[
name|stack_top
index|]
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|header
operator|->
name|index
operator|+
literal|1
expr_stmt|;
name|estack
index|[
name|stack_top
index|]
operator|=
name|NULL
expr_stmt|;
name|stack_top
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|stack_top
condition|)
block|{
name|int
name|idx
decl_stmt|,
name|sidx
decl_stmt|;
name|idx
operator|=
name|stack
index|[
name|stack_top
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|dfs_in
index|[
name|idx
index|]
operator|<
literal|0
condition|)
name|dfs_in
index|[
name|idx
index|]
operator|=
name|tick
operator|++
expr_stmt|;
while|while
condition|(
name|n_edges
index|[
name|idx
index|]
condition|)
block|{
name|e
operator|=
name|edges
index|[
name|idx
index|]
index|[
operator|--
name|n_edges
index|[
name|idx
index|]
index|]
expr_stmt|;
name|sidx
operator|=
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|e
operator|->
name|dest
condition|?
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|num
operator|+
name|last_basic_block
else|:
name|e
operator|->
name|dest
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|closed
index|[
name|sidx
index|]
condition|)
block|{
if|if
condition|(
name|mri
index|[
name|sidx
index|]
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|closed
index|[
name|mri
index|[
name|sidx
index|]
index|]
condition|)
block|{
if|if
condition|(
name|mr
index|[
name|sidx
index|]
operator|<
name|mr
index|[
name|idx
index|]
condition|)
block|{
name|mr
index|[
name|idx
index|]
operator|=
name|mr
index|[
name|sidx
index|]
expr_stmt|;
name|mri
index|[
name|idx
index|]
operator|=
name|mri
index|[
name|sidx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mr
index|[
name|sidx
index|]
operator|<=
name|dfs_in
index|[
name|idx
index|]
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|dfs_in
index|[
name|sidx
index|]
operator|<
literal|0
condition|)
block|{
name|stack
index|[
name|stack_top
index|]
operator|=
name|sidx
expr_stmt|;
name|estack
index|[
name|stack_top
index|]
operator|=
name|e
expr_stmt|;
name|stack_top
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|dfs_in
index|[
name|sidx
index|]
operator|<
name|mr
index|[
name|idx
index|]
condition|)
block|{
name|mr
index|[
name|idx
index|]
operator|=
name|dfs_in
index|[
name|sidx
index|]
expr_stmt|;
name|mri
index|[
name|idx
index|]
operator|=
name|sidx
expr_stmt|;
block|}
name|e
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
comment|/* Return back.  */
name|closed
index|[
name|idx
index|]
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|estack
index|[
name|stack_top
operator|-
literal|1
index|]
expr_stmt|;
name|stack_top
operator|--
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
comment|/* Propagate information back.  */
name|sidx
operator|=
name|stack
index|[
name|stack_top
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mr
index|[
name|sidx
index|]
operator|>
name|mr
index|[
name|idx
index|]
condition|)
block|{
name|mr
index|[
name|sidx
index|]
operator|=
name|mr
index|[
name|idx
index|]
expr_stmt|;
name|mri
index|[
name|sidx
index|]
operator|=
name|mri
index|[
name|idx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mr
index|[
name|idx
index|]
operator|<=
name|dfs_in
index|[
name|sidx
index|]
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
comment|/* Mark the block if relevant.  */
if|if
condition|(
name|idx
operator|&&
name|idx
operator|<=
name|last_basic_block
operator|&&
name|mr
index|[
name|idx
index|]
operator|<=
name|dfs_in
index|[
name|idx
index|]
condition|)
name|BASIC_BLOCK
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|estack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfs_in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|closed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mri
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
operator|+
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n_edges
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Counts number of insns inside LOOP.  */
end_comment

begin_function
name|int
name|num_loop_insns
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|ninsns
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|ninsns
operator|++
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|ninsns
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* Counts number of insns executed on average per iteration LOOP.  */
end_comment

begin_function
name|int
name|average_num_loop_insns
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|binsns
decl_stmt|,
name|ninsns
decl_stmt|,
name|ratio
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|ninsns
operator|=
literal|0
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|binsns
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|binsns
operator|++
expr_stmt|;
name|ratio
operator|=
name|loop
operator|->
name|header
operator|->
name|frequency
operator|==
literal|0
condition|?
name|BB_FREQ_MAX
else|:
operator|(
name|bb
operator|->
name|frequency
operator|*
name|BB_FREQ_MAX
operator|)
operator|/
name|loop
operator|->
name|header
operator|->
name|frequency
expr_stmt|;
name|ninsns
operator|+=
name|binsns
operator|*
name|ratio
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|ninsns
operator|/=
name|BB_FREQ_MAX
expr_stmt|;
if|if
condition|(
operator|!
name|ninsns
condition|)
name|ninsns
operator|=
literal|1
expr_stmt|;
comment|/* To avoid division by zero.  */
return|return
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* Returns expected number of LOOP iterations.    Compute upper bound on number of iterations in case they do not fit integer    to help loop peeling heuristics.  Use exact counts if at all possible.  */
end_comment

begin_function
name|unsigned
name|expected_loop_iterations
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
condition|)
block|{
name|gcov_type
name|count_in
decl_stmt|,
name|count_latch
decl_stmt|,
name|expected
decl_stmt|;
name|count_in
operator|=
literal|0
expr_stmt|;
name|count_latch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
name|count_latch
operator|=
name|e
operator|->
name|count
expr_stmt|;
else|else
name|count_in
operator|+=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|count_in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expected
operator|=
operator|(
name|count_latch
operator|+
name|count_in
operator|-
literal|1
operator|)
operator|/
name|count_in
expr_stmt|;
comment|/* Avoid overflows.  */
return|return
operator|(
name|expected
operator|>
name|REG_BR_PROB_BASE
condition|?
name|REG_BR_PROB_BASE
else|:
name|expected
operator|)
return|;
block|}
else|else
block|{
name|int
name|freq_in
decl_stmt|,
name|freq_latch
decl_stmt|;
name|freq_in
operator|=
literal|0
expr_stmt|;
name|freq_latch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
name|freq_latch
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|freq_in
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|freq_latch
operator|+
name|freq_in
operator|-
literal|1
operator|)
operator|/
name|freq_in
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function checks if an instruction is a branch and count instruction    no matter if the flag HAVE_doloop_end is enabled or not.  An alternative     would be the modification of doloop_condition_get function itself.  */
end_comment

begin_function
name|bool
name|is_bct_cond
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|HAVE_doloop_end
if|if
condition|(
operator|!
name|doloop_condition_get
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Extract the increment of the count register from the branch and count    instruction.  */
end_comment

begin_function
name|rtx
name|get_var_set_from_bct
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|rhs
decl_stmt|,
name|lhs
decl_stmt|,
name|cond
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_bct_cond
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* IA64 has the decrement conditional, i.e. done only when the loop does not       end.  We match (set (x (if_then_else (ne x 0) (plus x -1) x))) here.  */
name|lhs
operator|=
name|XEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
name|set
return|;
name|cond
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|NE
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lhs
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
condition|)
return|return
name|set
return|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SET
argument_list|(
name|GET_MODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

end_unit

