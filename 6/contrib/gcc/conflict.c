begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Register conflict graph computation routines.    Copyright (C) 2000, 2003 Free Software Foundation, Inc.    Contributed by CodeSourcery, LLC  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:     Building an Optimizing Compiler    Robert Morgan    Butterworth-Heinemann, 1998 */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_comment
comment|/* A register conflict graph is an undirected graph containing nodes    for some or all of the regs used in a function.  Arcs represent    conflicts, i.e. two nodes are connected by an arc if there is a    point in the function at which the regs corresponding to the two    nodes are both live.     The conflict graph is represented by the data structures described    in Morgan section 11.3.1.  Nodes are not stored explicitly; only    arcs are.  An arc stores the numbers of the regs it connects.     Arcs can be located by two methods:       - The two reg numbers for each arc are hashed into a single        value, and the arc is placed in a hash table according to this        value.  This permits quick determination of whether a specific        conflict is present in the graph.         - Additionally, the arc data structures are threaded by a set of        linked lists by single reg number.  Since each arc references        two regs, there are two next pointers, one for the        smaller-numbered reg and one for the larger-numbered reg.  This        permits the quick enumeration of conflicts for a single        register.     Arcs are allocated from an obstack.  */
end_comment

begin_comment
comment|/* An arc in a conflict graph.  */
end_comment

begin_struct
struct|struct
name|conflict_graph_arc_def
block|{
comment|/* The next element of the list of conflicts involving the      smaller-numbered reg, as an index in the table of arcs of this      graph.   Contains NULL if this is the tail.  */
name|struct
name|conflict_graph_arc_def
modifier|*
name|smaller_next
decl_stmt|;
comment|/* The next element of the list of conflicts involving the      larger-numbered reg, as an index in the table of arcs of this      graph.  Contains NULL if this is the tail.  */
name|struct
name|conflict_graph_arc_def
modifier|*
name|larger_next
decl_stmt|;
comment|/* The smaller-numbered reg involved in this conflict.  */
name|int
name|smaller
decl_stmt|;
comment|/* The larger-numbered reg involved in this conflict.  */
name|int
name|larger
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|conflict_graph_arc_def
modifier|*
name|conflict_graph_arc
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|struct
name|conflict_graph_arc_def
modifier|*
name|const_conflict_graph_arc
typedef|;
end_typedef

begin_comment
comment|/* A conflict graph.  */
end_comment

begin_struct
struct|struct
name|conflict_graph_def
block|{
comment|/* A hash table of arcs.  Used to search for a specific conflict.  */
name|htab_t
name|arc_hash_table
decl_stmt|;
comment|/* The number of regs this conflict graph handles.  */
name|int
name|num_regs
decl_stmt|;
comment|/* For each reg, the arc at the head of a list that threads through      all the arcs involving that reg.  An entry is NULL if no      conflicts exist involving that reg.  */
name|conflict_graph_arc
modifier|*
name|neighbor_heads
decl_stmt|;
comment|/* Arcs are allocated from here.  */
name|struct
name|obstack
name|arc_obstack
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The initial capacity (number of conflict arcs) for newly-created    conflict graphs.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_ARC_CAPACITY
value|64
end_define

begin_comment
comment|/* Computes the hash value of the conflict graph arc connecting regs    R1 and R2.  R1 is assumed to be smaller or equal to R2.  */
end_comment

begin_define
define|#
directive|define
name|CONFLICT_HASH_FN
parameter_list|(
name|R1
parameter_list|,
name|R2
parameter_list|)
value|((R2) * ((R2) - 1) / 2 + (R1))
end_define

begin_function_decl
specifier|static
name|hashval_t
name|arc_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arc_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_conflict
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Callback function to compute the hash value of an arc.  Uses    current_graph to locate the graph to which the arc belongs.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|arc_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|arcp
parameter_list|)
block|{
name|const_conflict_graph_arc
name|arc
init|=
operator|(
name|const_conflict_graph_arc
operator|)
name|arcp
decl_stmt|;
return|return
name|CONFLICT_HASH_FN
argument_list|(
name|arc
operator|->
name|smaller
argument_list|,
name|arc
operator|->
name|larger
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback function to determine the equality of two arcs in the hash    table.  */
end_comment

begin_function
specifier|static
name|int
name|arc_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|arcp1
parameter_list|,
specifier|const
name|void
modifier|*
name|arcp2
parameter_list|)
block|{
name|const_conflict_graph_arc
name|arc1
init|=
operator|(
name|const_conflict_graph_arc
operator|)
name|arcp1
decl_stmt|;
name|const_conflict_graph_arc
name|arc2
init|=
operator|(
name|const_conflict_graph_arc
operator|)
name|arcp2
decl_stmt|;
return|return
name|arc1
operator|->
name|smaller
operator|==
name|arc2
operator|->
name|smaller
operator|&&
name|arc1
operator|->
name|larger
operator|==
name|arc2
operator|->
name|larger
return|;
block|}
end_function

begin_comment
comment|/* Creates an empty conflict graph to hold conflicts among NUM_REGS    registers.  */
end_comment

begin_function
name|conflict_graph
name|conflict_graph_new
parameter_list|(
name|int
name|num_regs
parameter_list|)
block|{
name|conflict_graph
name|graph
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conflict_graph_def
argument_list|)
argument_list|)
decl_stmt|;
name|graph
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
comment|/* Set up the hash table.  No delete action is specified; memory      management of arcs is through the obstack.  */
name|graph
operator|->
name|arc_hash_table
operator|=
name|htab_create
argument_list|(
name|INITIAL_ARC_CAPACITY
argument_list|,
operator|&
name|arc_hash
argument_list|,
operator|&
name|arc_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create an obstack for allocating arcs.  */
name|obstack_init
argument_list|(
operator|&
name|graph
operator|->
name|arc_obstack
argument_list|)
expr_stmt|;
comment|/* Create and zero the lookup table by register number.  */
name|graph
operator|->
name|neighbor_heads
operator|=
name|xcalloc
argument_list|(
name|num_regs
argument_list|,
sizeof|sizeof
argument_list|(
name|conflict_graph_arc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|graph
return|;
block|}
end_function

begin_comment
comment|/* Deletes a conflict graph.  */
end_comment

begin_function
name|void
name|conflict_graph_delete
parameter_list|(
name|conflict_graph
name|graph
parameter_list|)
block|{
name|obstack_free
argument_list|(
operator|&
name|graph
operator|->
name|arc_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|graph
operator|->
name|arc_hash_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|neighbor_heads
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds a conflict to GRAPH between regs REG1 and REG2, which must be    distinct.  Returns nonzero, unless the conflict is already present    in GRAPH, in which case it does nothing and returns zero.  */
end_comment

begin_function
name|int
name|conflict_graph_add
parameter_list|(
name|conflict_graph
name|graph
parameter_list|,
name|int
name|reg1
parameter_list|,
name|int
name|reg2
parameter_list|)
block|{
name|int
name|smaller
init|=
name|MIN
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
decl_stmt|;
name|int
name|larger
init|=
name|MAX
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
decl_stmt|;
name|struct
name|conflict_graph_arc_def
name|dummy
decl_stmt|;
name|conflict_graph_arc
name|arc
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* A reg cannot conflict with itself.  */
if|if
condition|(
name|reg1
operator|==
name|reg2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dummy
operator|.
name|smaller
operator|=
name|smaller
expr_stmt|;
name|dummy
operator|.
name|larger
operator|=
name|larger
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|graph
operator|->
name|arc_hash_table
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If the conflict is already there, do nothing.  */
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Allocate an arc.  */
name|arc
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|graph
operator|->
name|arc_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|conflict_graph_arc_def
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the reg numbers.  */
name|arc
operator|->
name|smaller
operator|=
name|smaller
expr_stmt|;
name|arc
operator|->
name|larger
operator|=
name|larger
expr_stmt|;
comment|/* Link the conflict into into two lists, one for each reg.  */
name|arc
operator|->
name|smaller_next
operator|=
name|graph
operator|->
name|neighbor_heads
index|[
name|smaller
index|]
expr_stmt|;
name|graph
operator|->
name|neighbor_heads
index|[
name|smaller
index|]
operator|=
name|arc
expr_stmt|;
name|arc
operator|->
name|larger_next
operator|=
name|graph
operator|->
name|neighbor_heads
index|[
name|larger
index|]
expr_stmt|;
name|graph
operator|->
name|neighbor_heads
index|[
name|larger
index|]
operator|=
name|arc
expr_stmt|;
comment|/* Put it in the hash table.  */
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|arc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if a conflict exists in GRAPH between regs REG1    and REG2.  */
end_comment

begin_function
name|int
name|conflict_graph_conflict_p
parameter_list|(
name|conflict_graph
name|graph
parameter_list|,
name|int
name|reg1
parameter_list|,
name|int
name|reg2
parameter_list|)
block|{
comment|/* Build an arc to search for.  */
name|struct
name|conflict_graph_arc_def
name|arc
decl_stmt|;
name|arc
operator|.
name|smaller
operator|=
name|MIN
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|arc
operator|.
name|larger
operator|=
name|MAX
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
name|htab_find
argument_list|(
name|graph
operator|->
name|arc_hash_table
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arc
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Calls ENUM_FN for each conflict in GRAPH involving REG.  EXTRA is    passed back to ENUM_FN.  */
end_comment

begin_function
name|void
name|conflict_graph_enum
parameter_list|(
name|conflict_graph
name|graph
parameter_list|,
name|int
name|reg
parameter_list|,
name|conflict_graph_enum_fn
name|enum_fn
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|conflict_graph_arc
name|arc
init|=
name|graph
operator|->
name|neighbor_heads
index|[
name|reg
index|]
decl_stmt|;
while|while
condition|(
name|arc
operator|!=
name|NULL
condition|)
block|{
comment|/* Invoke the callback.  */
if|if
condition|(
call|(
modifier|*
name|enum_fn
call|)
argument_list|(
name|arc
operator|->
name|smaller
argument_list|,
name|arc
operator|->
name|larger
argument_list|,
name|extra
argument_list|)
condition|)
comment|/* Stop if requested.  */
break|break;
comment|/* Which next pointer to follow depends on whether REG is the 	 smaller or larger reg in this conflict.  */
if|if
condition|(
name|reg
operator|<
name|arc
operator|->
name|larger
condition|)
name|arc
operator|=
name|arc
operator|->
name|smaller_next
expr_stmt|;
else|else
name|arc
operator|=
name|arc
operator|->
name|larger_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each conflict between a register x and SRC in GRAPH, adds a    conflict to GRAPH between x and TARGET.  */
end_comment

begin_function
name|void
name|conflict_graph_merge_regs
parameter_list|(
name|conflict_graph
name|graph
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|src
parameter_list|)
block|{
name|conflict_graph_arc
name|arc
init|=
name|graph
operator|->
name|neighbor_heads
index|[
name|src
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|src
condition|)
return|return;
while|while
condition|(
name|arc
operator|!=
name|NULL
condition|)
block|{
name|int
name|other
init|=
name|arc
operator|->
name|smaller
decl_stmt|;
if|if
condition|(
name|other
operator|==
name|src
condition|)
name|other
operator|=
name|arc
operator|->
name|larger
expr_stmt|;
name|conflict_graph_add
argument_list|(
name|graph
argument_list|,
name|target
argument_list|,
name|other
argument_list|)
expr_stmt|;
comment|/* Which next pointer to follow depends on whether REG is the 	 smaller or larger reg in this conflict.  */
if|if
condition|(
name|src
operator|<
name|arc
operator|->
name|larger
condition|)
name|arc
operator|=
name|arc
operator|->
name|smaller_next
expr_stmt|;
else|else
name|arc
operator|=
name|arc
operator|->
name|larger_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Holds context information while a conflict graph is being traversed    for printing.  */
end_comment

begin_struct
struct|struct
name|print_context
block|{
comment|/* The file pointer to which we're printing.  */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* The reg whose conflicts we're printing.  */
name|int
name|reg
decl_stmt|;
comment|/* Whether a conflict has already been printed for this reg.  */
name|int
name|started
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback function when enumerating conflicts during printing.  */
end_comment

begin_function
specifier|static
name|int
name|print_conflict
parameter_list|(
name|int
name|reg1
parameter_list|,
name|int
name|reg2
parameter_list|,
name|void
modifier|*
name|contextp
parameter_list|)
block|{
name|struct
name|print_context
modifier|*
name|context
init|=
operator|(
expr|struct
name|print_context
operator|*
operator|)
name|contextp
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* If this is the first conflict printed for this reg, start a new      line.  */
if|if
condition|(
operator|!
name|context
operator|->
name|started
condition|)
block|{
name|fprintf
argument_list|(
name|context
operator|->
name|fp
argument_list|,
literal|" %d:"
argument_list|,
name|context
operator|->
name|reg
argument_list|)
expr_stmt|;
name|context
operator|->
name|started
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Figure out the reg whose conflicts we're printing.  The other reg      is the interesting one.  */
if|if
condition|(
name|reg1
operator|==
name|context
operator|->
name|reg
condition|)
name|reg
operator|=
name|reg2
expr_stmt|;
elseif|else
if|if
condition|(
name|reg2
operator|==
name|context
operator|->
name|reg
condition|)
name|reg
operator|=
name|reg1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Print the conflict.  */
name|fprintf
argument_list|(
name|context
operator|->
name|fp
argument_list|,
literal|" %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Continue enumerating.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prints the conflicts in GRAPH to FP.  */
end_comment

begin_function
name|void
name|conflict_graph_print
parameter_list|(
name|conflict_graph
name|graph
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|print_context
name|context
decl_stmt|;
name|context
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Conflicts:\n"
argument_list|)
expr_stmt|;
comment|/* Loop over registers supported in this graph.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|graph
operator|->
name|num_regs
condition|;
operator|++
name|reg
control|)
block|{
name|context
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|context
operator|.
name|started
operator|=
literal|0
expr_stmt|;
comment|/* Scan the conflicts for reg, printing as we go.  A label for 	 this line will be printed the first time a conflict is 	 printed for the reg; we won't start a new line if this reg 	 has no conflicts.  */
name|conflict_graph_enum
argument_list|(
name|graph
argument_list|,
name|reg
argument_list|,
operator|&
name|print_conflict
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* If this reg does have conflicts, end the line.  */
if|if
condition|(
name|context
operator|.
name|started
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Callback function for note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|regset
name|set
init|=
operator|(
name|regset
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* We're only interested in regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates a conflict graph and computes conflicts over the current    function for the registers set in REGS.  The caller is responsible    for deallocating the return value.       Preconditions: the flow graph must be in SSA form, and life    analysis (specifically, regs live at exit from each block) must be    up-to-date.       This algorithm determines conflicts by walking the insns in each    block backwards.  We maintain the set of live regs at each insn,    starting with the regs live on exit from the block.  For each insn:        1. If a reg is set in this insns, it must be born here, since         we're in SSA.  Therefore, it was not live before this insns, 	so remove it from the set of live regs.         2. For each reg born in this insn, record a conflict between it 	and every other reg live coming into this insn.  For each 	existing conflict, one of the two regs must be born while the 	other is alive.  See Morgan or elsewhere for a proof of this.       3. Regs clobbered by this insn must have been live coming into         it, so record them as such.       The resulting conflict graph is not built for regs in REGS    themselves; rather, partition P is used to obtain the canonical reg    for each of these.  The nodes of the conflict graph are these    canonical regs instead.  */
end_comment

begin_function
name|conflict_graph
name|conflict_graph_compute
parameter_list|(
name|regset
name|regs
parameter_list|,
name|partition
name|p
parameter_list|)
block|{
name|conflict_graph
name|graph
init|=
name|conflict_graph_new
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
decl_stmt|;
name|regset_head
name|live_head
decl_stmt|;
name|regset
name|live
init|=
operator|&
name|live_head
decl_stmt|;
name|regset_head
name|born_head
decl_stmt|;
name|regset
name|born
init|=
operator|&
name|born_head
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|INIT_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
name|born
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|;
comment|/* Start with the regs that are live on exit, limited to those 	 we're interested in.  */
name|COPY_REG_SET
argument_list|(
name|live
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|AND_REG_SET
argument_list|(
name|live
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* Walk the instruction stream backwards.  */
name|head
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|born_reg
decl_stmt|;
name|int
name|live_reg
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* Are we interested in this insn? */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Determine which regs are set in this insn.  Since   	         we're in SSA form, if a reg is set here it isn't set   	         anywhere else, so this insn is where the reg is born.  */
name|CLEAR_REG_SET
argument_list|(
name|born
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg
argument_list|,
name|born
argument_list|)
expr_stmt|;
name|AND_REG_SET
argument_list|(
name|born
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* Regs born here were not live before this insn.  */
name|AND_COMPL_REG_SET
argument_list|(
name|live
argument_list|,
name|born
argument_list|)
expr_stmt|;
comment|/* For every reg born here, add a conflict with every other   	         reg live coming into this insn.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|born
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|born_reg
argument_list|,
argument|{ 		   EXECUTE_IF_SET_IN_REG_SET 		     (live, FIRST_PSEUDO_REGISTER, live_reg, 		      {
comment|/* Build the conflict graph in terms of canonical 			   regnos.  */
argument|int b = partition_find (p, born_reg); 			int l = partition_find (p, live_reg);  			if (b != l) 			  conflict_graph_add (graph, b, l); 		      }); 		 }
argument_list|)
empty_stmt|;
comment|/* Morgan's algorithm checks the operands of the insn 	         and adds them to the set of live regs.  Instead, we 	         use death information added by life analysis.  Regs 	         dead after this instruction were live before it.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|regs
argument_list|,
name|regno
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|born
argument_list|)
expr_stmt|;
return|return
name|graph
return|;
block|}
end_function

end_unit

