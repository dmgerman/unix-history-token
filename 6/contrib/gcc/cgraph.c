begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph handling code.    Copyright (C) 2003, 2004 Free Software Foundation, Inc.    Contributed by Jan Hubicka  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Hash table used to convert declarations into nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct cgraph_node))
argument_list|)
name|htab_t
name|cgraph_hash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The linked list of cgraph nodes.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of cgraph nodes scheduled to be lowered.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_nodes_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nodes in existence.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_n_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximal uid used in cgraph nodes.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when whole unit has been analyzed so we can access global info.  */
end_comment

begin_decl_stmt
name|bool
name|cgraph_global_info_ready
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table used to convert declarations into nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct cgraph_varpool_node))
argument_list|)
name|htab_t
name|cgraph_varpool_hash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Queue of cgraph nodes scheduled to be lowered and output.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_nodes_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nodes in existence.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_varpool_n_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linked list of cgraph varpool nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|cgraph_varpool_node
operator|*
name|cgraph_varpool_nodes
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|cgraph_edge
modifier|*
name|create_edge
parameter_list|(
name|struct
name|cgraph_node
modifier|*
parameter_list|,
name|struct
name|cgraph_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|hash_node
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eq_node
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hashval_t
operator|)
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|(
operator|(
expr|struct
name|cgraph_node
operator|*
operator|)
name|p
operator|)
operator|->
name|decl
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|(
operator|(
expr|struct
name|cgraph_node
operator|*
operator|)
name|p1
operator|)
operator|->
name|decl
argument_list|)
operator|)
operator|==
operator|(
name|tree
operator|)
name|p2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return cgraph node assigned to DECL.  Create new one when needed.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_node
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_hash
condition|)
name|cgraph_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|hash_node
argument_list|,
name|eq_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_hash
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|*
name|slot
return|;
name|node
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|cgraph_nodes
expr_stmt|;
name|node
operator|->
name|uid
operator|=
name|cgraph_max_uid
operator|++
expr_stmt|;
if|if
condition|(
name|cgraph_nodes
condition|)
name|cgraph_nodes
operator|->
name|previous
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
name|cgraph_nodes
operator|=
name|node
expr_stmt|;
name|cgraph_n_nodes
operator|++
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|node
operator|->
name|origin
operator|=
name|cgraph_node
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|next_nested
operator|=
name|node
operator|->
name|origin
operator|->
name|nested
expr_stmt|;
name|node
operator|->
name|origin
operator|->
name|nested
operator|=
name|node
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Try to find existing function for identifier ID.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_node_for_identifier
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_hash
condition|)
return|return
name|NULL
return|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_hash
argument_list|,
name|id
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Create edge from CALLER to CALLEE in the cgraph.  */
end_comment

begin_function
specifier|static
name|struct
name|cgraph_edge
modifier|*
name|create_edge
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|caller
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|callee
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_edge
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge2
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|callee
operator|->
name|decl
argument_list|)
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function body not available"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|callee
operator|->
name|local
operator|.
name|redefined_extern_inline
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"redefined extern inline functions are not "
literal|"considered for inlining"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|callee
operator|->
name|local
operator|.
name|inlinable
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not considered for inlining"
argument_list|)
expr_stmt|;
else|else
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not inlinable"
argument_list|)
expr_stmt|;
comment|/* At the moment we don't associate calls with specific CALL_EXPRs      as we probably ought to, so we must preserve inline_call flags to      be the same in all copies of the same edge.  */
if|if
condition|(
name|cgraph_global_info_ready
condition|)
for|for
control|(
name|edge2
operator|=
name|caller
operator|->
name|callees
init|;
name|edge2
condition|;
name|edge2
operator|=
name|edge2
operator|->
name|next_callee
control|)
if|if
condition|(
name|edge2
operator|->
name|callee
operator|==
name|callee
condition|)
block|{
name|edge
operator|->
name|inline_failed
operator|=
name|edge2
operator|->
name|inline_failed
expr_stmt|;
break|break;
block|}
name|edge
operator|->
name|caller
operator|=
name|caller
expr_stmt|;
name|edge
operator|->
name|callee
operator|=
name|callee
expr_stmt|;
name|edge
operator|->
name|next_caller
operator|=
name|callee
operator|->
name|callers
expr_stmt|;
name|edge
operator|->
name|next_callee
operator|=
name|caller
operator|->
name|callees
expr_stmt|;
name|caller
operator|->
name|callees
operator|=
name|edge
expr_stmt|;
name|callee
operator|->
name|callers
operator|=
name|edge
expr_stmt|;
return|return
name|edge
return|;
block|}
end_function

begin_comment
comment|/* Remove the edge from CALLER to CALLEE in the cgraph.  */
end_comment

begin_function
name|void
name|cgraph_remove_edge
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|caller
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|callee
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
modifier|*
name|edge
decl_stmt|,
modifier|*
modifier|*
name|edge2
decl_stmt|;
for|for
control|(
name|edge
operator|=
operator|&
name|callee
operator|->
name|callers
init|;
operator|*
name|edge
operator|&&
operator|(
operator|*
name|edge
operator|)
operator|->
name|caller
operator|!=
name|caller
condition|;
name|edge
operator|=
operator|&
operator|(
operator|(
operator|*
name|edge
operator|)
operator|->
name|next_caller
operator|)
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|edge
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|edge
operator|=
operator|(
operator|*
name|edge
operator|)
operator|->
name|next_caller
expr_stmt|;
for|for
control|(
name|edge2
operator|=
operator|&
name|caller
operator|->
name|callees
init|;
operator|*
name|edge2
operator|&&
operator|(
operator|*
name|edge2
operator|)
operator|->
name|callee
operator|!=
name|callee
condition|;
name|edge2
operator|=
operator|&
operator|(
operator|*
name|edge2
operator|)
operator|->
name|next_callee
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|edge2
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|edge2
operator|=
operator|(
operator|*
name|edge2
operator|)
operator|->
name|next_callee
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the node from cgraph.  */
end_comment

begin_function
name|void
name|cgraph_remove_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
while|while
condition|(
name|node
operator|->
name|callers
condition|)
name|cgraph_remove_edge
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|,
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|callees
condition|)
name|cgraph_remove_edge
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|callees
operator|->
name|callee
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|nested
condition|)
name|cgraph_remove_node
argument_list|(
name|node
operator|->
name|nested
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|origin
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|node2
init|=
operator|&
name|node
operator|->
name|origin
operator|->
name|nested
decl_stmt|;
while|while
condition|(
operator|*
name|node2
operator|!=
name|node
condition|)
name|node2
operator|=
operator|&
operator|(
operator|*
name|node2
operator|)
operator|->
name|next_nested
expr_stmt|;
operator|*
name|node2
operator|=
name|node
operator|->
name|next_nested
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|previous
condition|)
name|node
operator|->
name|previous
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
else|else
name|cgraph_nodes
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|node
operator|->
name|next
operator|->
name|previous
operator|=
name|node
operator|->
name|previous
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_hash
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
block|{
comment|/* We use DECL_ASSEMBLER_NAME as key, which may not work in 	 all cases. See PR/15666. Gcc 3.5 uses DECL_UID as key, 	 which doesn't have this problem.  */
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|htab_clear_slot
argument_list|(
name|cgraph_hash
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Do not free the structure itself so the walk over chain can continue.  */
block|}
end_function

begin_comment
comment|/* Notify finalize_compilation_unit that given node is reachable.  */
end_comment

begin_function
name|void
name|cgraph_mark_reachable_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|reachable
operator|&&
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
block|{
name|notice_global_symbol
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|reachable
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|cgraph_nodes_queue
expr_stmt|;
name|cgraph_nodes_queue
operator|=
name|node
expr_stmt|;
comment|/* At the moment frontend automatically emits all nested functions.  */
if|if
condition|(
name|node
operator|->
name|nested
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node2
decl_stmt|;
for|for
control|(
name|node2
operator|=
name|node
operator|->
name|nested
init|;
name|node2
condition|;
name|node2
operator|=
name|node2
operator|->
name|next_nested
control|)
if|if
condition|(
operator|!
name|node2
operator|->
name|reachable
condition|)
name|cgraph_mark_reachable_node
argument_list|(
name|node2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Likewise indicate that a node is needed, i.e. reachable via some    external means.  */
end_comment

begin_function
name|void
name|cgraph_mark_needed_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|needed
operator|=
literal|1
expr_stmt|;
name|cgraph_mark_reachable_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record call from CALLER to CALLEE.  */
end_comment

begin_function
name|struct
name|cgraph_edge
modifier|*
name|cgraph_record_call
parameter_list|(
name|tree
name|caller
parameter_list|,
name|tree
name|callee
parameter_list|)
block|{
return|return
name|create_edge
argument_list|(
name|cgraph_node
argument_list|(
name|caller
argument_list|)
argument_list|,
name|cgraph_node
argument_list|(
name|callee
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|cgraph_remove_call
parameter_list|(
name|tree
name|caller
parameter_list|,
name|tree
name|callee
parameter_list|)
block|{
name|cgraph_remove_edge
argument_list|(
name|cgraph_node
argument_list|(
name|caller
argument_list|)
argument_list|,
name|cgraph_node
argument_list|(
name|callee
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when CALLER_DECL calls CALLEE_DECL.  */
end_comment

begin_function
name|bool
name|cgraph_calls_p
parameter_list|(
name|tree
name|caller_decl
parameter_list|,
name|tree
name|callee_decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|caller
init|=
name|cgraph_node
argument_list|(
name|caller_decl
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|callee
init|=
name|cgraph_node
argument_list|(
name|callee_decl
argument_list|)
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
for|for
control|(
name|edge
operator|=
name|callee
operator|->
name|callers
init|;
name|edge
operator|&&
operator|(
name|edge
operator|)
operator|->
name|caller
operator|!=
name|caller
condition|;
name|edge
operator|=
operator|(
name|edge
operator|->
name|next_caller
operator|)
control|)
continue|continue;
return|return
name|edge
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_local_info
modifier|*
name|cgraph_local_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
operator|&
name|node
operator|->
name|local
return|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_global_info
modifier|*
name|cgraph_global_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|cgraph_global_info_ready
condition|)
name|abort
argument_list|()
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
operator|&
name|node
operator|->
name|global
return|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_rtl_info
modifier|*
name|cgraph_rtl_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|node
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Return name of the node used in debug output.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgraph_node_name
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|node
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the callgraph.  */
end_comment

begin_function
name|void
name|dump_cgraph
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"callgraph:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|self_insns
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %i insns"
argument_list|,
name|node
operator|->
name|local
operator|.
name|self_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|insns
operator|&&
name|node
operator|->
name|global
operator|.
name|insns
operator|!=
name|node
operator|->
name|local
operator|.
name|self_insns
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" (%i after inlining)"
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|origin
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" nested in: %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|origin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|needed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" needed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|reachable
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" reachable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" tree"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|local
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" always_inline"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" inlinable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|cloned_times
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" cloned %ix"
argument_list|,
name|node
operator|->
name|global
operator|.
name|cloned_times
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  called by: "
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callers
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_caller
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|caller
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|inline_failed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(inlined) "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  calls: "
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callees
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_callee
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|inline_failed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(inlined) "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|cgraph_varpool_hash_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|hashval_t
operator|)
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|(
operator|(
expr|struct
name|cgraph_varpool_node
operator|*
operator|)
name|p
operator|)
operator|->
name|decl
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_cgraph_varpool_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|(
operator|(
expr|struct
name|cgraph_varpool_node
operator|*
operator|)
name|p1
operator|)
operator|->
name|decl
argument_list|)
operator|)
operator|==
operator|(
name|tree
operator|)
name|p2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */
end_comment

begin_function
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_node
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_varpool_hash
condition|)
name|cgraph_varpool_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|cgraph_varpool_hash_node
argument_list|,
name|eq_cgraph_varpool_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_varpool_node
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_varpool_hash
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|*
name|slot
return|;
name|node
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|cgraph_varpool_n_nodes
operator|++
expr_stmt|;
name|cgraph_varpool_nodes
operator|=
name|node
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Set the DECL_ASSEMBLER_NAME and update cgraph hashtables.  */
end_comment

begin_function
name|void
name|change_decl_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|name
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%D renamed after being referenced in assembly"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|cgraph_hash
condition|)
block|{
comment|/* Take a look whether declaration is in the cgraph structure.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_hash
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
name|node
operator|=
operator|*
name|slot
expr_stmt|;
comment|/* It is, verify that we are the canonical node for this decl.  */
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|decl
operator|==
name|decl
condition|)
block|{
name|node
operator|=
operator|*
name|slot
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|cgraph_hash
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|cgraph_varpool_hash
condition|)
block|{
comment|/* Take a look whether declaration is in the cgraph structure.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_varpool_hash
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
name|vnode
operator|=
operator|*
name|slot
expr_stmt|;
comment|/* It is, verify that we are the canonical vnode for this decl.  */
if|if
condition|(
name|vnode
operator|&&
name|vnode
operator|->
name|decl
operator|==
name|decl
condition|)
block|{
name|vnode
operator|=
operator|*
name|slot
expr_stmt|;
name|htab_clear_slot
argument_list|(
name|cgraph_varpool_hash
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
name|vnode
operator|=
name|NULL
expr_stmt|;
block|}
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_hash
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|vnode
condition|)
block|{
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_varpool_hash
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|slot
operator|=
name|vnode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to find existing function for identifier ID.  */
end_comment

begin_function
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_node_for_identifier
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_varpool_hash
condition|)
return|return
name|NULL
return|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_varpool_node
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|cgraph_varpool_hash
argument_list|,
name|id
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Notify finalize_compilation_unit that given node is reachable    or needed.  */
end_comment

begin_function
name|void
name|cgraph_varpool_mark_needed_node
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|needed
operator|&&
name|node
operator|->
name|finalized
condition|)
block|{
name|node
operator|->
name|next_needed
operator|=
name|cgraph_varpool_nodes_queue
expr_stmt|;
name|cgraph_varpool_nodes_queue
operator|=
name|node
expr_stmt|;
name|notice_global_symbol
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|needed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cgraph_varpool_finalize_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|node
operator|->
name|finalized
condition|)
return|return;
if|if
condition|(
name|node
operator|->
name|needed
condition|)
block|{
name|node
operator|->
name|next_needed
operator|=
name|cgraph_varpool_nodes_queue
expr_stmt|;
name|cgraph_varpool_nodes_queue
operator|=
name|node
expr_stmt|;
name|notice_global_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|finalized
operator|=
name|true
expr_stmt|;
if|if
condition|(
comment|/* Externally visible variables must be output.  The exception are 	 COMDAT functions that must be output only when they are needed.  */
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* Function whose name is output to the assembler file must be produced. 	 It is possible to assemble the name later after finalizing the function 	 and the fact is noticed in assemble_name then.  */
operator|||
operator|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|cgraph_varpool_assemble_pending_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
while|while
condition|(
name|cgraph_varpool_nodes_queue
condition|)
block|{
name|tree
name|decl
init|=
name|cgraph_varpool_nodes_queue
operator|->
name|decl
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_nodes_queue
decl_stmt|;
name|cgraph_varpool_nodes_queue
operator|=
name|cgraph_varpool_nodes_queue
operator|->
name|next_needed
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|assemble_variable
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Return true when the DECL can possibly be inlined.  */
end_comment

begin_function
name|bool
name|cgraph_function_possibly_inlined_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
return|return
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|flag_really_no_inline
operator|||
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
call|)
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
return|;
return|return
name|cgraph_node
argument_list|(
name|decl
argument_list|)
operator|->
name|global
operator|.
name|inlined
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cgraph.h"
end_include

end_unit

