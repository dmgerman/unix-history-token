begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers for pseudo-registers that span basic blocks.    Copyright (C) 1987, 1988, 1991, 1994, 1996, 1997, 1998,    1999, 2000, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* This pass of the compiler performs global register allocation.    It assigns hard register numbers to all the pseudo registers    that were not handled in local_alloc.  Assignments are recorded    in the vector reg_renumber, not by changing the rtl code.    (Such changes are made by final).  The entry point is    the function global_alloc.     After allocation is complete, the reload pass is run as a subroutine    of this pass, so that when a pseudo reg loses its hard reg due to    spilling it is possible to make a second attempt to find a hard    reg for it.  The reload pass is independent in other respects    and it is run even when stupid register allocation is in use.     1. Assign allocation-numbers (allocnos) to the pseudo-registers    still needing allocations and to the pseudo-registers currently    allocated by local-alloc which may be spilled by reload.    Set up tables reg_allocno and allocno_reg to map    reg numbers to allocnos and vice versa.    max_allocno gets the number of allocnos in use.     2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.    Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix    for conflicts between allocnos and explicit hard register use    (which includes use of pseudo-registers allocated by local_alloc).     3. For each basic block     walk forward through the block, recording which     pseudo-registers and which hardware registers are live.     Build the conflict matrix between the pseudo-registers     and another of pseudo-registers versus hardware registers.     Also record the preferred hardware registers     for each pseudo-register.     4. Sort a table of the allocnos into order of    desirability of the variables.     5. Allocate the variables in that order; each if possible into    a preferred register, else into another register.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Number of pseudo-registers which are candidates for allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the allocno, or -1    for pseudo registers which are not to be allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_allocno
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|allocno
block|{
name|int
name|reg
decl_stmt|;
comment|/* Gives the number of consecutive hard registers needed by that      pseudo reg.  */
name|int
name|size
decl_stmt|;
comment|/* Number of calls crossed by each allocno.  */
name|int
name|calls_crossed
decl_stmt|;
comment|/* Number of calls that might throw crossed by each allocno.  */
name|int
name|throwing_calls_crossed
decl_stmt|;
comment|/* Number of refs to each allocno.  */
name|int
name|n_refs
decl_stmt|;
comment|/* Frequency of uses of each allocno.  */
name|int
name|freq
decl_stmt|;
comment|/* Guess at live length of each allocno.      This is actually the max of the live lengths of the regs.  */
name|int
name|live_length
decl_stmt|;
comment|/* Set of hard regs conflicting with allocno N.  */
name|HARD_REG_SET
name|hard_reg_conflicts
decl_stmt|;
comment|/* Set of hard regs preferred by allocno N.      This is used to make allocnos go into regs that are copied to or from them,      when possible, to reduce register shuffling.  */
name|HARD_REG_SET
name|hard_reg_preferences
decl_stmt|;
comment|/* Similar, but just counts register preferences made in simple copy      operations, rather than arithmetic.  These are given priority because      we can always eliminate an insn by using these, but using a register      in the above list won't always eliminate an insn.  */
name|HARD_REG_SET
name|hard_reg_copy_preferences
decl_stmt|;
comment|/* Similar to hard_reg_preferences, but includes bits for subsequent      registers when an allocno is multi-word.  The above variable is used for      allocation while this is used to build reg_someone_prefers, below.  */
name|HARD_REG_SET
name|hard_reg_full_preferences
decl_stmt|;
comment|/* Set of hard registers that some later allocno has a preference for.  */
name|HARD_REG_SET
name|regs_someone_prefers
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Set to true if allocno can't be allocated in the stack register.  */
name|bool
name|no_stack_reg
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|allocno
modifier|*
name|allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of the integers from 0 to max_allocno-1,    sorted in the order of first-to-be-allocated first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the number of another    lower-numbered pseudo reg which can share a hard reg with this pseudo    *even if the two pseudos would otherwise appear to conflict*.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the number of bits in each element of `conflicts' and what    type that element has.  We use the largest integer format on the    host machine.  */
end_comment

begin_define
define|#
directive|define
name|INT_BITS
value|HOST_BITS_PER_WIDE_INT
end_define

begin_define
define|#
directive|define
name|INT_TYPE
value|HOST_WIDE_INT
end_define

begin_comment
comment|/* max_allocno by max_allocno array of bits,    recording whether two allocno's conflict (can't go in the same    hardware register).     `conflicts' is symmetric after the call to mirror_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ints require to hold max_allocno bits.    This is the length of a row in `conflicts'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocno_row_words
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two macros to test or store 1 in an element of `conflicts'.  */
end_comment

begin_define
define|#
directive|define
name|CONFLICTP
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (unsigned) (J) / INT_BITS]	\& ((INT_TYPE) 1<< ((unsigned) (J) % INT_BITS)))
end_define

begin_comment
comment|/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,    and execute CODE.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
parameter_list|(
name|ALLOCNO_SET
parameter_list|,
name|ALLOCNO
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   int i_;								\   int allocno_;								\   INT_TYPE *p_ = (ALLOCNO_SET);						\ 									\   for (i_ = allocno_row_words - 1, allocno_ = 0; i_>= 0;		\        i_--, allocno_ += INT_BITS)					\     {									\       unsigned INT_TYPE word_ = (unsigned INT_TYPE) *p_++;		\ 									\       for ((ALLOCNO) = allocno_; word_; word_>>= 1, (ALLOCNO)++)	\ 	{								\ 	  if (word_& 1)						\ 	    {CODE;}							\ 	}								\     }									\ } while (0)
end_define

begin_comment
comment|/* This doesn't work for non-GNU C due to the way CODE is macro expanded.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* For any allocno that conflicts with IN_ALLOCNO, set OUT_ALLOCNO to    the conflicting allocno, and execute CODE.  This macro assumes that    mirror_conflicts has been run.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_CONFLICT
parameter_list|(
name|IN_ALLOCNO
parameter_list|,
name|OUT_ALLOCNO
parameter_list|,
name|CODE
parameter_list|)
define|\
value|EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + (IN_ALLOCNO) * allocno_row_words,\ 				 OUT_ALLOCNO, (CODE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that global-alloc isn't supposed to use.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|no_global_alloc_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers used so far.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_used_so_far
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of refs to each hard reg, as used by local alloc.    It is zero for a reg that contains global pseudos or is explicitly used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_n_refs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Frequency of uses of given hard reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_freq
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess at live length of each hard reg, as used by local alloc.    This is actually the sum of the live lengths of the specific regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_live_length
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 a bit in a vector TABLE of HARD_REG_SETs, for vector    element I, and hard register number J.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGBIT
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|SET_HARD_REG_BIT (allocno[I].TABLE, J)
end_define

begin_comment
comment|/* Bit mask for allocnos live at current point in the scan.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|allocnos_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test, set or clear bit number I in allocnos_live,    a bit vector indexed by allocno.  */
end_comment

begin_define
define|#
directive|define
name|SET_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(unsigned) (I) / INT_BITS]		\      |= ((INT_TYPE) 1<< ((unsigned) (I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|CLEAR_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(unsigned) (I) / INT_BITS]		\&= ~((INT_TYPE) 1<< ((unsigned) (I) % INT_BITS)))
end_define

begin_comment
comment|/* This is turned off because it doesn't work right for DImode.    (And it is only used for DImode, so the other cases are worthless.)    The problem is that it isn't true that there is NO possibility of conflict;    only that there is no conflict if the two pseudos get the exact same regs.    If they were allocated with a partial overlap, there would be a conflict.    We can't safely turn off the conflict unless we have another way to    prevent the partial overlap.     Idea: change hard_reg_conflicts so that instead of recording which    hard regs the allocno may not overlap, it records where the allocno    may not start.  Change both where it is used and where it is updated.    Then there is a way to record that (reg:DI 108) may start at 10    but not at 9 or 11.  There is still the question of how to record    this semi-conflict between two pseudos.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Reg pairs for which conflict after the current insn    is inhibited by a REG_NO_CONFLICT note.    If the table gets full, we ignore any other notes--that is conservative.  */
end_comment

begin_define
define|#
directive|define
name|NUM_NO_CONFLICT_PAIRS
value|4
end_define

begin_comment
comment|/* Number of pairs in use in this insn.  */
end_comment

begin_endif
unit|int n_no_conflict_pairs; static struct { int allocno1, allocno2;}   no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Record all regs that are set in any one insn.    Communication from mark_reg_{store,clobber} and global_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|regs_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_regs_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All registers that can be eliminated.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|eliminable_regset
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|allocno_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|global_conflicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mirror_conflicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_preferences
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_preferences
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_reg
parameter_list|(
name|int
parameter_list|,
name|HARD_REG_SET
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_conflicts
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_preference
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_dies
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|struct
name|insn_chain
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Perform allocation of pseudo-registers not allocated by local_alloc.    FILE is a file to output debugging information on,    or zero if such output is not desired.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
name|int
name|global_alloc
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
name|int
name|need_fp
init|=
operator|(
operator|!
name|flag_omit_frame_pointer
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|max_allocno
operator|=
literal|0
expr_stmt|;
comment|/* A machine may have certain hard registers that      are safe to use only within a basic block.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
comment|/* Build the regset of all eliminable registers and show we can't use those      that we already know won't be eliminated.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|eliminables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|cannot_elim
init|=
operator|(
operator|!
name|CAN_ELIMINATE
argument_list|(
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|to
argument_list|)
operator|||
operator|(
name|eliminables
index|[
name|i
index|]
operator|.
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_fp
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|cannot_elim
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cannot_elim
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_fp
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_fp
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Track which registers have already been used.  Start with registers      explicitly in the rtl, then registers allocated by local register      allocation.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_used_so_far
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
comment|/* If we are doing the leaf function optimization, and this is a leaf      function, it means that the registers that take work to save are those      that need a register window.  So prefer the ones that can be used in      a leaf function.  */
block|{
specifier|const
name|char
modifier|*
name|cheap_regs
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|leaf_regs
init|=
name|LEAF_REGISTERS
decl_stmt|;
if|if
condition|(
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
condition|)
name|cheap_regs
operator|=
name|leaf_regs
expr_stmt|;
else|else
name|cheap_regs
operator|=
name|call_used_regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|cheap_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We consider registers that do not have to be saved over calls as if      they were already used since there is no cost in using them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Establish mappings from register number to allocation number      and vice versa.  In the process, count the allocnos.  */
name|reg_allocno
operator|=
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialize the shared-hard-reg mapping      from the list of pairs that may share.  */
name|reg_may_share
operator|=
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|regs_may_share
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|r1
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r1
operator|>
name|r2
condition|)
name|reg_may_share
index|[
name|r1
index|]
operator|=
name|r2
expr_stmt|;
else|else
name|reg_may_share
index|[
name|r2
index|]
operator|=
name|r1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
comment|/* Note that reg_live_length[i]< 0 indicates a "constant" reg        that we are supposed to refrain from putting in a hard reg.        -2 means do make an allocno but don't allocate it.  */
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|!=
operator|-
literal|1
comment|/* Don't allocate pseudos that cross calls, 	   if this function receives a nonlocal goto.  */
operator|&&
operator|(
operator|!
name|current_function_has_nonlocal_label
operator|||
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_may_share
index|[
name|i
index|]
operator|&&
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
operator|>=
literal|0
condition|)
name|reg_allocno
index|[
name|i
index|]
operator|=
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
name|max_allocno
operator|++
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|allocno
operator|=
name|xcalloc
argument_list|(
name|max_allocno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|allocno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|num
init|=
name|reg_allocno
index|[
name|i
index|]
decl_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|reg
operator|=
name|i
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|size
operator|=
name|PSEUDO_REGNO_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|+=
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|throwing_calls_crossed
operator|+=
name|REG_N_THROWING_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|freq
operator|+=
name|REG_FREQ
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|<
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
condition|)
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate amount of usage of each hard reg by pseudos      allocated by local-alloc.  This is to see if we want to      override it.  */
name|memset
argument_list|(
name|local_reg_live_length
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_live_length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|local_reg_n_refs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_n_refs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|local_reg_freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_freq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
init|;
name|j
operator|<
name|endregno
condition|;
name|j
operator|++
control|)
block|{
name|local_reg_n_refs
index|[
name|j
index|]
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|local_reg_freq
index|[
name|j
index|]
operator|+=
name|REG_FREQ
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|local_reg_live_length
index|[
name|j
index|]
operator|+=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We can't override local-alloc for a reg used not just by local-alloc.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|local_reg_n_refs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|local_reg_freq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|allocno_row_words
operator|=
operator|(
name|max_allocno
operator|+
name|INT_BITS
operator|-
literal|1
operator|)
operator|/
name|INT_BITS
expr_stmt|;
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  Some examples were> 2Mb in size.  */
name|conflicts
operator|=
name|xcalloc
argument_list|(
name|max_allocno
operator|*
name|allocno_row_words
argument_list|,
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|allocnos_live
operator|=
name|xmalloc
argument_list|(
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is work to be done (at least one reg to allocate),      perform global conflict analysis and allocate the regs.  */
if|if
condition|(
name|max_allocno
operator|>
literal|0
condition|)
block|{
comment|/* Scan all the insns and compute the conflicts among allocnos 	 and between allocnos and hard regs.  */
name|global_conflicts
argument_list|()
expr_stmt|;
name|mirror_conflicts
argument_list|()
expr_stmt|;
comment|/* Eliminate conflicts between pseudos and eliminable registers.  If 	 the register is not eliminated, the pseudo won't really be able to 	 live in the eliminable register, so the conflict doesn't matter. 	 If we do eliminate the register, the conflict will no longer exist. 	 So in either case, we can ignore the conflict.  Likewise for 	 preferences.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
block|}
comment|/* Try to expand the preferences by merging them between allocnos.  */
name|expand_preferences
argument_list|()
expr_stmt|;
comment|/* Determine the order to allocate the remaining pseudo registers.  */
name|allocno_order
operator|=
name|xmalloc
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
name|allocno_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Default the size to 1, since allocno_compare uses it to divide by. 	 Also convert allocno_live_length of zero to -1.  A length of zero 	 can occur when all the registers for that allocno have reg_live_length 	 equal to -2.  In this case, we want to make an allocno, but not 	 allocate it.  So avoid the divide-by-zero and set it to a low 	 priority.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|allocno
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
name|allocno
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|i
index|]
operator|.
name|live_length
operator|==
literal|0
condition|)
name|allocno
index|[
name|i
index|]
operator|.
name|live_length
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|qsort
argument_list|(
name|allocno_order
argument_list|,
name|max_allocno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|allocno_compare
argument_list|)
expr_stmt|;
name|prune_preferences
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_conflicts
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Try allocating them, one by one, in that order, 	 except for parameters marked with reg_live_length[regno] == -2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|<
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	       first try allocating in the class that is cheapest 	       for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|reg_alternate_class
argument_list|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|allocno_order
argument_list|)
expr_stmt|;
block|}
comment|/* Do the reloads now while the allocno data still exist, so that we can      try to assign new hard regs to any pseudo regs that are spilled.  */
if|#
directive|if
literal|0
comment|/* We need to eliminate regs even if there is no rtl code, 	 for the sake of debugging information.  */
block|if (n_basic_blocks> 0)
endif|#
directive|endif
block|{
name|build_insn_chain
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|=
name|reload
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|reg_allocno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_may_share
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|allocno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|allocnos_live
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Sort predicate for ordering the allocnos.    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */
end_comment

begin_function
specifier|static
name|int
name|allocno_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|v1p
parameter_list|,
specifier|const
name|void
modifier|*
name|v2p
parameter_list|)
block|{
name|int
name|v1
init|=
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|v1p
decl_stmt|,
name|v2
init|=
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|v2p
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100)      weighted by the frequency (maximally REG_FREQ_MAX).      Multiplying this by 10000/REG_FREQ_MAX can't overflow.  */
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno
index|[
name|v1
index|]
operator|.
name|n_refs
argument_list|)
operator|*
name|allocno
index|[
name|v1
index|]
operator|.
name|freq
argument_list|)
operator|/
name|allocno
index|[
name|v1
index|]
operator|.
name|live_length
operator|)
operator|*
operator|(
literal|10000
operator|/
name|REG_FREQ_MAX
operator|)
operator|*
name|allocno
index|[
name|v1
index|]
operator|.
name|size
operator|)
decl_stmt|;
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno
index|[
name|v2
index|]
operator|.
name|n_refs
argument_list|)
operator|*
name|allocno
index|[
name|v2
index|]
operator|.
name|freq
argument_list|)
operator|/
name|allocno
index|[
name|v2
index|]
operator|.
name|live_length
operator|)
operator|*
operator|(
literal|10000
operator|/
name|REG_FREQ_MAX
operator|)
operator|*
name|allocno
index|[
name|v2
index|]
operator|.
name|size
operator|)
decl_stmt|;
if|if
condition|(
name|pri2
operator|-
name|pri1
condition|)
return|return
name|pri2
operator|-
name|pri1
return|;
comment|/* If regs are equally good, sort by allocno,      so that the results of qsort leave nothing to chance.  */
return|return
name|v1
operator|-
name|v2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the rtl code and record all conflicts and register preferences in the    conflict matrices and preference tables.  */
end_comment

begin_function
specifier|static
name|void
name|global_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|block_start_allocnos
decl_stmt|;
comment|/* Make a vector that mark_reg_{store,clobber} will store in.  */
name|regs_set
operator|=
name|xmalloc
argument_list|(
name|max_parallel
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|block_start_allocnos
operator|=
name|xmalloc
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
name|memset
argument_list|(
name|allocnos_live
argument_list|,
literal|0
argument_list|,
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of registers currently live 	 to the state at the beginning of this basic block. 	 This also marks the conflicts among hard registers 	 and any allocnos that are live.  	 For pseudo-regs, there is only one bit for each one 	 no matter how many hard regs it occupies. 	 This is ok; we know the size from PSEUDO_REGNO_SIZE. 	 For explicit hard regs, we cannot know the size that way 	 since one hard reg can be used with various sizes. 	 Therefore, we must require that all the hard regs 	 implicitly live as part of a multi-word hard reg 	 are explicitly marked in basic_block_live_at_start.  */
block|{
name|regset
name|old
init|=
name|b
operator|->
name|global_live_at_start
decl_stmt|;
name|int
name|ax
init|=
literal|0
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 				     int a = reg_allocno[i]; 				     if (a>=
literal|0
argument|) 				       { 					 SET_ALLOCNO_LIVE (a); 					 block_start_allocnos[ax++] = a; 				       } 				     else if ((a = reg_renumber[i])>=
literal|0
argument|) 				       mark_reg_live_nc 					 (a, PSEUDO_REGNO_MODE (i)); 				   }
argument_list|)
empty_stmt|;
comment|/* Record that each allocno now live conflicts with each hard reg 	   now live.  	   It is not necessary to mark any conflicts between pseudos as 	   this point, even for pseudos which are live at the start of 	   the basic block.  	     Given two pseudos X and Y and any point in the CFG P.  	     On any path to point P where X and Y are live one of the 	     following conditions must be true:  		1. X is live at some instruction on the path that 		   evaluates Y.  		2. Y is live at some instruction on the path that 		   evaluates X.  		3. Either X or Y is not evaluated on the path to P 		   (ie it is used uninitialized) and thus the 		   conflict can be ignored.  	    In cases #1 and #2 the conflict will be recorded when we 	    scan the instruction that makes either X or Y become live.  */
name|record_conflicts
argument_list|(
name|block_start_allocnos
argument_list|,
name|ax
argument_list|)
expr_stmt|;
comment|/* Pseudos can't go in stack regs at the start of a basic block that 	   is reached by an abnormal edge. Likewise for call clobbered regs, 	   because because caller-save, fixup_abnormal_edges, and possibly 	   the table driven EH machinery are not quite ready to handle such 	   regs live across such edges.  */
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
break|break;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|allocnos_live
argument_list|,
argument|ax
argument_list|,
argument|{ 					       allocno[ax].no_stack_reg =
literal|1
argument|; 					     }
argument_list|)
empty_stmt|;
for|for
control|(
name|ax
operator|=
name|FIRST_STACK_REG
init|;
name|ax
operator|<=
name|LAST_STACK_REG
condition|;
name|ax
operator|++
control|)
name|record_one_conflict
argument_list|(
name|ax
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No need to record conflicts for call clobbered regs if we have 		 nonlocal labels around, as we don't ever try to allocate such 		 regs in this case.  */
if|if
condition|(
operator|!
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|ax
operator|=
literal|0
init|;
name|ax
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|ax
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|ax
index|]
condition|)
name|record_one_conflict
argument_list|(
name|ax
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Scan the code of this basic block, noting which allocnos 	 and hard regs are born or die.  When one is born, 	 record a conflict with all others currently live.  */
while|while
condition|(
literal|1
condition|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* Make regs_set an empty set.  */
name|n_regs_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
if|#
directive|if
literal|0
block|int i = 0; 	      for (link = REG_NOTES (insn); 		   link&& i< NUM_NO_CONFLICT_PAIRS; 		   link = XEXP (link, 1)) 		if (REG_NOTE_KIND (link) == REG_NO_CONFLICT) 		  { 		    no_conflict_pairs[i].allocno1 		      = reg_allocno[REGNO (SET_DEST (PATTERN (insn)))]; 		    no_conflict_pairs[i].allocno2 		      = reg_allocno[REGNO (XEXP (link, 0))]; 		    i++; 		  }
endif|#
directive|endif
comment|/* 0 */
comment|/* Mark any registers clobbered by INSN as live, 		 so they conflict with the inputs.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_clobber
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Mark any registers dead after INSN as dead now.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark any registers set in INSN as live, 		 and mark them as conflicting with all other live regs. 		 Clobbers are processed again, so they conflict with 		 the registers that are set.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|mark_reg_store
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If INSN has multiple outputs, then any reg that dies here 		 and is used inside of an output 		 must conflict with the other outputs.  		 It is unsafe to use !single_set here since it will ignore an 		 unused output.  Just because an output is unused does not mean 		 the compiler can assume the side effect will not occur. 		 Consider if REG appears in the address of an output and we 		 reload the output.  If we allocate REG to the same hard 		 register as an unused output we could set the hard register 		 before the output reload insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|multiple_sets
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|used_in_output
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|used_in_output
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|used_in_output
condition|)
name|mark_reg_conflicts
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Mark any registers set in INSN and then never used.  */
while|while
condition|(
name|n_regs_set
operator|--
operator|>
literal|0
condition|)
block|{
name|rtx
name|note
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|regs_set
index|[
name|n_regs_set
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|block_start_allocnos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the preference information by looking for cases where one allocno    dies in an insn that sets an allocno.  If those two allocnos don't conflict,    merge any preferences between those allocnos.  */
end_comment

begin_function
specifier|static
name|void
name|expand_preferences
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* We only try to handle the most common cases here.  Most of the cases      where this wins are reg-reg copies.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|CONFLICTP
argument_list|(
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|int
name|a1
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|int
name|a2
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|)
expr_stmt|;
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prune the preferences for global registers to exclude registers that cannot    be used.     Compute `regs_someone_prefers', which is a bitmask of the hard registers    that are preferred by conflicting registers of lower priority.  If possible,    we will avoid using these registers.  */
end_comment

begin_function
specifier|static
name|void
name|prune_preferences
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
modifier|*
name|allocno_to_order
init|=
name|xmalloc
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Scan least most important to most important.      For each allocno, remove from preferences registers that cannot be used,      either because of conflicts or register type.  Then compute all registers      preferred by each lower-priority register that conflicts.  */
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|HARD_REG_SET
name|temp
decl_stmt|;
name|num
operator|=
name|allocno_order
index|[
name|i
index|]
expr_stmt|;
name|allocno_to_order
index|[
name|num
index|]
operator|=
name|i
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_preferred_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Merge in the preferences of lower-priority registers (they have 	 already been pruned).  If we also prefer some of those registers, 	 don't exclude them unless we are of a smaller size (in which case 	 we want to give the lower-priority allocno the first chance for 	 these registers).  */
name|HARD_REG_SET
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|int
name|allocno2
decl_stmt|;
name|num
operator|=
name|allocno_order
index|[
name|i
index|]
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|temp2
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|conflicts + num * allocno_row_words
argument_list|,
argument|allocno2
argument_list|,
argument|{ 	  if (allocno_to_order[allocno2]> i) 	    { 	      if (allocno[allocno2].size<= allocno[num].size) 		IOR_HARD_REG_SET (temp, 				  allocno[allocno2].hard_reg_full_preferences); 	      else 		IOR_HARD_REG_SET (temp2, 				  allocno[allocno2].hard_reg_full_preferences); 	    } 	}
argument_list|)
empty_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|regs_someone_prefers
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|allocno_to_order
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a hard register to allocno NUM; look for one that is the beginning    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.    The registers marked in PREFREGS are tried first.     LOSERS, if nonzero, is a HARD_REG_SET indicating registers that cannot    be used for this allocation.     If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.    Otherwise ignore that preferred class and use the alternate class.     If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that    will have to be saved and restored at calls.     RETRYING is nonzero if this is called from retry_global_alloc.     If we find one, record it in reg_renumber.    If not, do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|find_reg
parameter_list|(
name|int
name|num
parameter_list|,
name|HARD_REG_SET
name|losers
parameter_list|,
name|int
name|alt_regs_p
parameter_list|,
name|int
name|accept_call_clobbered
parameter_list|,
name|int
name|retrying
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|best_reg
decl_stmt|,
name|pass
decl_stmt|;
name|HARD_REG_SET
name|used
decl_stmt|,
name|used1
decl_stmt|,
name|used2
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
operator|(
name|alt_regs_p
condition|?
name|reg_alternate_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
else|:
name|reg_preferred_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|PSEUDO_REGNO_MODE
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* Some registers should not be allocated in global-alloc.  */
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|losers
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|used2
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_conflicts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
name|cannot_change_mode_set_regs
argument_list|(
operator|&
name|used1
argument_list|,
name|mode
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try each hard reg to see if it fits.  Do this in two passes.      In the first pass, skip registers that are preferred by some other pseudo      to give it a better chance of getting one of those registers.  Only if      we can't get a register when excluding those do we take one of them.      However, we never allocate a register for the first time in pass 0.  */
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_used_so_far
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|regs_someone_prefers
argument_list|)
expr_stmt|;
name|best_reg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|1
operator|&&
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|pass
operator|++
control|)
block|{
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
block|}
comment|/* See if there is a preferred register with the same class as the register      we allocated above.  Making this restriction prevents register      preferencing from creating worse register allocation.       Remove from the preferred registers and conflicting registers.  Note that      additional conflicts may have been added after `prune_preferences' was      called.       First do this for those register with copy preferences, then all      preferred registers.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_copy_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
goto|goto
name|no_prefs
goto|;
block|}
block|}
block|}
name|no_copy_prefs
label|:
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|no_prefs
label|:
comment|/* If we haven't succeeded yet, try with caller-saves.      We need not check to see if the current function has nonlocal      labels because we don't put any pseudos that are live over calls in      registers in that case.  */
if|if
condition|(
name|flag_caller_saves
operator|&&
name|best_reg
operator|<
literal|0
condition|)
block|{
comment|/* Did not find a register.  If it would be profitable to 	 allocate a call-clobbered register and save and restore it 	 around calls, do that.  Don't do this if it crosses any calls 	 that might throw.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|!=
literal|0
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|throwing_calls_crossed
operator|==
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
argument_list|)
condition|)
block|{
name|HARD_REG_SET
name|new_losers
decl_stmt|;
if|if
condition|(
operator|!
name|losers
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losing_caller_save_reg_set
argument_list|)
expr_stmt|;
name|find_reg
argument_list|(
name|num
argument_list|,
name|new_losers
argument_list|,
name|alt_regs_p
argument_list|,
literal|1
argument_list|,
name|retrying
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
block|{
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If we haven't succeeded yet,      see if some hard reg that conflicts with us      was utilized poorly by local-alloc.      If so, kick out the regs that were put there by local-alloc      so we can use it instead.  */
if|if
condition|(
name|best_reg
operator|<
literal|0
operator|&&
operator|!
name|retrying
comment|/* Let's not bother with multi-reg allocnos.  */
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|size
operator|==
literal|1
condition|)
block|{
comment|/* Count from the end, to find the least-used ones first.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_reg_n_refs
index|[
name|regno
index|]
operator|!=
literal|0
comment|/* Don't use a reg no good for this pseudo.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used2
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
comment|/* The code below assumes that we need only a single 		 register, but the check of allocno[num].size above 		 was not enough.  Sometimes we need more than one 		 register for a single-word value.  */
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
name|invalid_mode_change_p
argument_list|(
name|regno
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_REGS
operator|&&
operator|(
operator|!
name|allocno
index|[
name|num
index|]
operator|.
name|no_stack_reg
operator|||
name|regno
operator|<
name|FIRST_STACK_REG
operator|||
name|regno
operator|>
name|LAST_STACK_REG
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* We explicitly evaluate the divide results into temporary 		 variables so as to avoid excess precision problems that occur 		 on an i386-unknown-sysv4.2 (unixware) host.  */
name|double
name|tmp1
init|=
operator|(
operator|(
name|double
operator|)
name|local_reg_freq
index|[
name|regno
index|]
operator|/
name|local_reg_live_length
index|[
name|regno
index|]
operator|)
decl_stmt|;
name|double
name|tmp2
init|=
operator|(
operator|(
name|double
operator|)
name|allocno
index|[
name|num
index|]
operator|.
name|freq
operator|/
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|)
decl_stmt|;
if|if
condition|(
name|tmp1
operator|<
name|tmp2
condition|)
block|{
comment|/* Hard reg REGNO was used less in total by local regs 		     than it would be used by this one allocno!  */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max_regno
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|r
init|=
name|reg_renumber
index|[
name|k
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|r
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|r
operator|&&
name|regno
operator|<
name|endregno
condition|)
name|reg_renumber
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Did we find a register?  */
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
name|int
name|lim
decl_stmt|,
name|j
decl_stmt|;
name|HARD_REG_SET
name|this_reg
decl_stmt|;
comment|/* Yes.  Record it as the hard register of this pseudo-reg.  */
name|reg_renumber
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Also of any pseudo-regs that share with it.  */
if|if
condition|(
name|reg_may_share
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
condition|)
for|for
control|(
name|j
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|num
condition|)
name|reg_renumber
index|[
name|j
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Make a set of the hard regs being allocated.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
name|lim
operator|=
name|best_reg
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|best_reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|best_reg
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* This is no longer a reg used just by local regs.  */
name|local_reg_n_refs
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|local_reg_freq
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For each other pseudo-reg conflicting with this one, 	 mark it as conflicting with the hard regs this one occupies.  */
name|lim
operator|=
name|num
expr_stmt|;
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|conflicts + lim * allocno_row_words
argument_list|,
argument|j
argument_list|,
argument|{ 	  IOR_HARD_REG_SET (allocno[j].hard_reg_conflicts, this_reg); 	}
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.    Perhaps it had previously seemed not worth a hard reg,    or perhaps its old hard reg has been commandeered for reloads.    FORBIDDEN_REGS indicates certain hard regs that may not be used, even if    they do not appear to be allocated.    If FORBIDDEN_REGS is zero, no regs are forbidden.  */
end_comment

begin_function
name|void
name|retry_global_alloc
parameter_list|(
name|int
name|regno
parameter_list|,
name|HARD_REG_SET
name|forbidden_regs
parameter_list|)
block|{
name|int
name|alloc_no
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|alloc_no
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	 first try allocating in the class that is cheapest 	 for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
name|find_reg
argument_list|(
name|alloc_no
argument_list|,
name|forbidden_regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|alloc_no
argument_list|,
name|forbidden_regs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we found a register, modify the RTL for the register to 	 show the hard register, and mark that register live.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
name|mark_home_live
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a conflict between register REGNO    and everything currently live.    REGNO must not be a pseudo reg that was allocated    by local_alloc; such numbers must be translated through    reg_renumber before calling here.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
comment|/* When a hard register becomes live,        record conflicts with live pseudo regs.  */
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|allocnos_live
argument_list|,
argument|j
argument_list|,
argument|{ 	SET_HARD_REG_BIT (allocno[j].hard_reg_conflicts, regno);       }
argument_list|)
empty_stmt|;
else|else
comment|/* When a pseudo-register becomes live,        record conflicts first with hard regs,        then with other pseudo regs.  */
block|{
name|int
name|ialloc
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
name|int
name|ialloc_prod
init|=
name|ialloc
operator|*
name|allocno_row_words
decl_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|ialloc
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|#
directive|if
literal|0
block|int k; 	  for (k = 0; k< n_no_conflict_pairs; k++) 	    if (! ((j == no_conflict_pairs[k].allocno1&& ialloc == no_conflict_pairs[k].allocno2) 		   || 		   (j == no_conflict_pairs[k].allocno2&& ialloc == no_conflict_pairs[k].allocno1)))
endif|#
directive|endif
comment|/* 0 */
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record all allocnos currently live as conflicting    with all hard regs currently live.     ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that    are currently live.  Their bits are also flagged in allocnos_live.  */
end_comment

begin_function
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|int
modifier|*
name|allocno_vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|allocno_vec
index|[
name|len
index|]
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */
end_comment

begin_function
specifier|static
name|void
name|mirror_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|rw
init|=
name|allocno_row_words
decl_stmt|;
name|int
name|rwb
init|=
name|rw
operator|*
name|INT_BITS
decl_stmt|;
name|INT_TYPE
modifier|*
name|p
init|=
name|conflicts
decl_stmt|;
name|INT_TYPE
modifier|*
name|q0
init|=
name|conflicts
decl_stmt|,
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|unsigned
name|INT_TYPE
name|mask
decl_stmt|;
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
operator|,
name|mask
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
name|mask
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|q0
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
operator|,
name|q1
operator|=
name|q0
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
operator|,
name|q1
operator|+=
name|rwb
control|)
block|{
name|unsigned
name|INT_TYPE
name|word
decl_stmt|;
for|for
control|(
name|word
operator|=
operator|(
name|unsigned
name|INT_TYPE
operator|)
operator|*
name|p
operator|++
operator|,
name|q2
operator|=
name|q1
init|;
name|word
condition|;
name|word
operator|>>=
literal|1
operator|,
name|q2
operator|+=
name|rw
control|)
block|{
if|if
condition|(
name|word
operator|&
literal|1
condition|)
operator|*
name|q2
operator||=
name|mask
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case where REG is set by the insn being scanned,    during the forward scan to accumulate conflicts.    Store a 1 in regs_live or allocnos_live for this register, record how many    consecutive hardware registers it actually needs,    and record a conflict with all other registers already live.     Note that even if REG does not remain alive after this insn,    we must mark it here as live, to ensure a conflict between    REG and any other regs set in this insn that really do live.    This is because those other regs could be considered after this.     REG might actually be something other than a register;    if so, we do nothing.     SETTER is 0 if this register was modified by an auto-increment (i.e.,    a REG_INC note was found for it).  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regs_set
index|[
name|n_regs_set
operator|++
index|]
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|setter
operator|&&
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|set_preference
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_reg_store
argument_list|(
name|reg
argument_list|,
name|setter
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that REG has conflicts with all the regs currently live.    Do not mark REG itself as live.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_conflicts
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark REG as being dead (following the insn being scanned now).    Store a 0 in regs_live or allocnos_live for this register.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|CLEAR_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Pseudo regs already assigned hardware regs are treated 	 almost the same as explicit hardware regs.  */
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark hard reg REGNO as currently live, assuming machine mode MODE    for the value stored in it.  MODE determines how many consecutive    registers are actually in use.  Do not record conflicts;    it is assumed that the caller will do that.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to set a preference for an allocno to a hard register.    We are passed DEST and SRC which are the operands of a SET.  It is known    that SRC is a register.  If SRC or the first operand of SRC is a register,    try to set a preference.  If one of the two is a hard register and the other    is a pseudo-register, mark the preference.     Note that we are not as aggressive as local-alloc in trying to tie a    pseudo-register to a hard register.  */
end_comment

begin_function
specifier|static
name|void
name|set_preference
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|unsigned
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Amount to add to the hard regno for SRC, or subtract from that for DEST,      to compensate for subregs in SRC or DEST.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|copy
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|,
name|copy
operator|=
literal|0
expr_stmt|;
comment|/* Get the reg number for both SRC and DEST.      If neither is a reg, give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|+=
operator|(
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|/
name|REGMODE_NATURAL_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|-=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|-=
operator|(
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
operator|/
name|REGMODE_NATURAL_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* Convert either or both to hard reg numbers.  */
if|if
condition|(
name|reg_renumber
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
name|src_regno
operator|=
name|reg_renumber
index|[
name|src_regno
index|]
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
name|dest_regno
operator|=
name|reg_renumber
index|[
name|dest_regno
index|]
expr_stmt|;
comment|/* Now if one is a hard reg and the other is a global pseudo      then give the other a preference.  */
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|src_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|dest_regno
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest_regno
init|;
name|i
operator|<
name|dest_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|dest_regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dest_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|src_regno
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|src_regno
init|;
name|i
operator|<
name|src_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|src_regno
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate that hard register number FROM was eliminated and replaced with    an offset from hard register number TO.  The status of hard registers live    at the start of a basic block is updated by replacing a use of FROM with    a use of TO.  */
end_comment

begin_function
name|void
name|mark_elimination
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|regset
name|r
init|=
name|bb
operator|->
name|global_live_at_start
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the following functions.  Holds the    current life information.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|live_relevant_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in live_relevant_regs and REGS_SET that register REG became live.    This is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|regs_set
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|regs_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|regs_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record in live_relevant_regs that register REGNO died.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dies
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|insn_chain
modifier|*
name|chain
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk the insns of the current function and build reload_insn_chain,    and record register life information.  */
end_comment

begin_function
name|void
name|build_insn_chain
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|struct
name|insn_chain
modifier|*
modifier|*
name|p
init|=
operator|&
name|reload_insn_chain
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|basic_block
name|b
init|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
decl_stmt|;
name|regset_head
name|live_relevant_regs_head
decl_stmt|;
name|live_relevant_regs
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|live_relevant_regs_head
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
block|{
name|struct
name|insn_chain
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|BB_HEAD
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|b->global_live_at_start
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	       if (i< FIRST_PSEUDO_REGISTER 		   ? ! TEST_HARD_REG_BIT (eliminable_regset, i) 		   : reg_renumber[i]>=
literal|0
argument|) 		 SET_REGNO_REG_SET (live_relevant_regs, i); 	     }
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|c
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
name|c
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|insn
operator|=
name|first
expr_stmt|;
name|c
operator|->
name|block
operator|=
name|b
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark the death of everything that dies in this instruction.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|live_throughout
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
comment|/* Mark everything born in this instruction as live.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|,
name|reg_becomes_live
argument_list|,
operator|&
name|c
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
block|}
else|else
name|COPY_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|live_throughout
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark anything that is set in this insn and then unused as dying.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
name|b
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
comment|/* Stop after we pass the end of the last basic block.  Verify that 	 no real insns are after the end of the last basic block.  	 We may want to reorganize the loop somewhat since this test should 	 always be the right exit test.  Allow an ADDR_VEC or ADDR_DIF_VEC if 	 the previous real insn is a JUMP_INSN.  */
if|if
condition|(
name|b
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
for|for
control|(
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
operator|&&
name|prev_real_insn
argument_list|(
name|first
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev_real_insn
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print debugging trace information if -dg switch is given,    showing the information on which the allocation decisions are based.  */
end_comment

begin_function
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|has_preferences
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|nregs
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d regs to allocate:"
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|allocno_order
index|[
name|i
index|]
operator|&&
name|j
operator|!=
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|size
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%d)"
argument_list|,
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d conflicts:"
argument_list|,
name|allocno
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno
index|[
name|j
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|has_preferences
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|j
argument_list|)
condition|)
name|has_preferences
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_preferences
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d preferences:"
argument_list|,
name|allocno
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_global_regs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register dispositions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d in %d  "
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|%
literal|6
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n;; Hard regs used: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

