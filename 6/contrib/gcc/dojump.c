begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_function_decl
specifier|static
name|bool
name|prefer_and_bit_test
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_jump_by_parts_greater
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_jump_by_parts_equality
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_compare_and_jump
parameter_list|(
name|tree
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* At the start of a function, record that we have no previously-pushed    arguments waiting to be popped.  */
end_comment

begin_function
name|void
name|init_pending_stack_adjust
parameter_list|(
name|void
parameter_list|)
block|{
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard any pending stack adjustment.  This avoid relying on the    RTL optimizers to remove useless adjustments when we know the    stack pointer value is dead.  */
end_comment

begin_function
name|void
name|discard_pending_stack_adjust
parameter_list|(
name|void
parameter_list|)
block|{
name|stack_pointer_delta
operator|-=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting from function, if safe, clear out any pending stack adjust    so the adjustment won't get done.     Note, if the current function calls alloca, then it must have a    frame pointer regardless of the value of flag_omit_frame_pointer.  */
end_comment

begin_function
name|void
name|clear_pending_stack_adjust
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
operator|!
name|flag_omit_frame_pointer
operator|||
name|current_function_calls_alloca
operator|)
operator|&&
name|EXIT_IGNORE_STACK
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|&&
operator|!
name|flag_inline_functions
condition|)
name|discard_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop any previously-pushed arguments that have not been popped yet.  */
end_comment

begin_function
name|void
name|do_pending_stack_adjust
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_stack_adjust
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|pending_stack_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand conditional expressions.  */
end_comment

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is zero.    LABEL is an rtx of code CODE_LABEL, in this function and all the    functions here.  */
end_comment

begin_function
name|void
name|jumpifnot
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
end_comment

begin_function
name|void
name|jumpif
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used internally by prefer_and_bit_test.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|and_reg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|and_test
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|shift_test
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Compare the relative costs of "(X& (1<< BITNUM))" and "(X>> BITNUM)& 1"    where X is an arbitrary register of mode MODE.  Return true if the former    is preferred.  */
end_comment

begin_function
specifier|static
name|bool
name|prefer_and_bit_test
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|bitnum
parameter_list|)
block|{
if|if
condition|(
name|and_test
operator|==
literal|0
condition|)
block|{
comment|/* Set up rtxes for the two variations.  Use NULL as a placeholder 	 for the BITNUM-based constants.  */
name|and_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|and_test
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|and_reg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shift_test
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFTRT
argument_list|(
name|mode
argument_list|,
name|and_reg
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Change the mode of the previously-created rtxes.  */
name|PUT_MODE
argument_list|(
name|and_reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|and_test
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|shift_test
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|XEXP
argument_list|(
name|shift_test
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the integers.  */
name|XEXP
argument_list|(
name|and_test
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitnum
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|shift_test
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|bitnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtx_cost
argument_list|(
name|and_test
argument_list|,
name|IF_THEN_ELSE
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|shift_test
argument_list|,
name|IF_THEN_ELSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if    the result is zero, or IF_TRUE_LABEL if the result is one.    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,    meaning fall through in that case.     do_jump always does any pending stack adjust except when it does not    actually perform a jump.  An example where there is no jump    is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.     This function is responsible for optimizing cases such as&&, || and comparison operators in EXP.  */
end_comment

begin_function
name|void
name|do_jump
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Some cases need to create a label to jump to      in order to properly fall through.      These cases set DROP_THROUGH_LABEL nonzero.  */
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|integer_zerop
argument_list|(
name|exp
argument_list|)
condition|?
name|if_false_label
else|:
name|if_true_label
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|emit_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is not true with #pragma weak  */
block|case ADDR_EXPR:
comment|/* The address of something can never be zero.  */
block|if (if_true_label)         emit_jump (if_true_label);       break;
endif|#
directive|endif
case|case
name|UNSAVE_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|unsave_expr_now
call|)
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
goto|goto
name|normal
goto|;
case|case
name|CONVERT_EXPR
case|:
comment|/* If we are narrowing the operand, we have to do the compare in the          narrower mode.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|normal
goto|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These cannot change zero->nonzero or vice versa.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_RECORD_EXPR
case|:
comment|/* Put the object on the placeholder list, recurse through our first          operand, and pop the list.  */
name|placeholder_list
operator|=
name|tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|placeholder_list
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is never less insns than evaluating the PLUS_EXPR followed by          a test and can be longer if the test is eliminated.  */
block|case PLUS_EXPR:
comment|/* Reduce to minus.  */
block|exp = build (MINUS_EXPR, TREE_TYPE (exp),                    TREE_OPERAND (exp, 0),                    fold (build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)),                                  TREE_OPERAND (exp, 1))));
comment|/* Process as MINUS.  */
endif|#
directive|endif
case|case
name|MINUS_EXPR
case|:
comment|/* Nonzero iff operands of minus differ.  */
name|do_compare_and_jump
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
comment|/* fold_single_bit_test() converts (X& (1<< C)) into (X>> C)& 1. 	 See if the former is preferred for jump tests and restore it 	 if so.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|exp0
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|set_label
decl_stmt|,
name|clr_label
decl_stmt|;
comment|/* Strip narrowing integral type conversions.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp0
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|0
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "exp0 ^ 1" inverts the sense of the single bit test.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|exp0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clr_label
operator|=
name|if_true_label
expr_stmt|;
name|set_label
operator|=
name|if_false_label
expr_stmt|;
block|}
else|else
block|{
name|clr_label
operator|=
name|if_false_label
expr_stmt|;
name|set_label
operator|=
name|if_true_label
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp0
argument_list|)
operator|==
name|RSHIFT_EXPR
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|shift
init|=
name|TREE_OPERAND
argument_list|(
name|exp0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|shift
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|shift
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|shift
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|)
operator|<
literal|0
operator|&&
name|prefer_and_bit_test
argument_list|(
name|TYPE_MODE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|shift
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|TREE_INT_CST_LOW
argument_list|(
name|shift
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|build_int_2
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|argtype
expr_stmt|;
name|do_jump
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
argument_list|,
name|clr_label
argument_list|,
name|set_label
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we are AND'ing with a small constant, do this comparison in the          smallest type that fits.  If the machine doesn't have comparisons          that small, it will be converted back to the wider comparison.          This helps if we are testing the sign bit of a narrower object.          combine can't do this for us because it can't know whether a          ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|i
operator|=
name|tree_floor_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
if|if
condition|(
name|if_false_label
operator|==
literal|0
condition|)
name|if_false_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
name|if_true_label
operator|==
literal|0
condition|)
name|if_true_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
comment|/* Get description of this reference.  We don't actually care            about the underlying object here.  */
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
call|)
argument_list|(
name|bitsize
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|bitsize
operator|>=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
block|}
case|case
name|COND_EXPR
case|:
comment|/* Do (a ? 1 : 0) and (a ? 0 : 1) as special cases.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
comment|/* Now the THEN-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
comment|/* In case the do_jump just above never jumps.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
comment|/* Now the ELSE-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|EQ
argument_list|,
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NE_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|NE
argument_list|,
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LT_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|LT
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|LE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GT
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
block|{
name|enum
name|rtx_code
name|cmp
decl_stmt|,
name|rcmp
decl_stmt|;
name|int
name|do_rev
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|UNORDERED_EXPR
condition|)
name|cmp
operator|=
name|UNORDERED
operator|,
name|rcmp
operator|=
name|ORDERED
expr_stmt|;
else|else
name|cmp
operator|=
name|ORDERED
operator|,
name|rcmp
operator|=
name|UNORDERED
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|can_compare_p
argument_list|(
name|cmp
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
operator|&&
operator|(
name|can_compare_p
argument_list|(
name|rcmp
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
comment|/* If the target doesn't provide either UNORDERED or ORDERED              comparisons, canonicalize on UNORDERED for the library.  */
operator|||
name|rcmp
operator|==
name|UNORDERED
operator|)
condition|)
name|do_rev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|do_rev
condition|)
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|cmp
argument_list|,
name|cmp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|rcmp
argument_list|,
name|rcmp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
break|break;
block|{
name|enum
name|rtx_code
name|rcode1
decl_stmt|;
name|enum
name|tree_code
name|tcode2
decl_stmt|;
case|case
name|UNLT_EXPR
case|:
name|rcode1
operator|=
name|UNLT
expr_stmt|;
name|tcode2
operator|=
name|LT_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNLE_EXPR
case|:
name|rcode1
operator|=
name|UNLE
expr_stmt|;
name|tcode2
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNGT_EXPR
case|:
name|rcode1
operator|=
name|UNGT
expr_stmt|;
name|tcode2
operator|=
name|GT_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNGE_EXPR
case|:
name|rcode1
operator|=
name|UNGE
expr_stmt|;
name|tcode2
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNEQ_EXPR
case|:
name|rcode1
operator|=
name|UNEQ
expr_stmt|;
name|tcode2
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
name|unordered_bcc
label|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_compare_p
argument_list|(
name|rcode1
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|rcode1
argument_list|,
name|rcode1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|op0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cmp0
decl_stmt|,
name|cmp1
decl_stmt|;
comment|/* If the target doesn't support combined unordered                compares, decompose into UNORDERED + comparison.  */
name|cmp0
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|UNORDERED_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|cmp1
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|tcode2
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Special case:           __builtin_expect (<test>, 0)	and           __builtin_expect (<test>, 1)           We need to do this here, so that<test> is not converted to a SCC          operation on machines that use condition code registers and COMPARE          like the PowerPC, and then the jump is done based on whether the SCC          operation produced a 1 or 0.  */
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_EXPECT
operator|&&
name|arglist
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|rtx
name|seq
init|=
name|expand_builtin_expect_jump
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|NULL_RTX
condition|)
block|{
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Fall through and generate the normal code.  */
default|default:
name|normal
label|:
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is not needed any more and causes poor code since it causes          comparisons and tests from non-SI objects to have different code          sequences.  */
comment|/* Copy to register to avoid generating bad insns by cse          from (set (mem ...) (arithop))  (set (cc0) (mem ...)).  */
block|if (!cse_not_expected&& GET_CODE (temp) == MEM)         temp = copy_to_reg (temp);
endif|#
directive|endif
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|target
init|=
name|temp
operator|==
name|const0_rtx
condition|?
name|if_false_label
else|:
name|if_true_label
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_jump
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|NE
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
comment|/* Note swapping the labels gives us not-equal.  */
name|do_jump_by_parts_equality_rtx
argument_list|(
name|temp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* The RTL optimizers prefer comparisons against pseudos.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Compare promoted variables in their promoted mode.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|do_compare_rtx_and_jump
argument_list|(
name|temp
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|drop_through_label
condition|)
block|{
comment|/* If do_jump produces code that might be jumped around,          do any stack adjusts from that code, before the place          where control merges in.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.    The code of EXP is ignored; we always test GT if SWAP is 0,    and LT if SWAP is 1.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_greater
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|swap
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
operator|!
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare OP0 with OP1, word at a time, in mode MODE.    UNSIGNEDP says to do unsigned comparison.    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_greater_rtx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|do_compare_rtx_and_jump
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|GT
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|do_compare_rtx_and_jump
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an EQ_EXPR expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_equality
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|do_compare_rtx_and_jump
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Jump according to whether OP0 is 0.    We assume that OP0 has an integer mode that is too wide    for the available compare insns.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_equality_rtx
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|int
name|nwords
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
comment|/* The fastest way of doing this comparison on almost any machine is to      "or" all the words and compare the result.  If all have to be loaded      from memory and this is a very wide item, it's possible this may      be slower, but that's highly unlikely.  */
name|part
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nwords
operator|&&
name|part
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|part
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|part
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
literal|0
condition|)
block|{
name|do_compare_rtx_and_jump
argument_list|(
name|part
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we couldn't do the "or" simply, do this with a series of compares.  */
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|do_compare_rtx_and_jump
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code for a comparison of OP0 and OP1 with rtx code CODE.    (including code to compute the values to be compared)    and set (CC0) according to the result.    The decision as to signed or unsigned comparison must be made by the caller.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.  */
end_comment

begin_function
name|rtx
name|compare_from_rtx
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|size
parameter_list|)
block|{
name|enum
name|rtx_code
name|ucode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|ucode
operator|=
name|unsignedp
condition|?
name|unsigned_condition
argument_list|(
name|code
argument_list|)
else|:
name|code
expr_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|ucode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines.  */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))         op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_cc0
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
else|#
directive|else
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Like do_compare_and_jump but expects the values to compare as two rtx's.    The decision as to signed or unsigned comparison must be made by the caller.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.  */
end_comment

begin_function
name|void
name|do_compare_rtx_and_jump
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|size
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|enum
name|rtx_code
name|ucode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|dummy_true_label
init|=
literal|0
decl_stmt|;
comment|/* Reverse the comparison if that is safe and we want to jump if it is      false.  */
if|if
condition|(
operator|!
name|if_true_label
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|if_true_label
operator|=
name|if_false_label
expr_stmt|;
name|if_false_label
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|ucode
operator|=
name|unsignedp
condition|?
name|unsigned_condition
argument_list|(
name|code
argument_list|)
else|:
name|code
expr_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|ucode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines.  */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))         op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|if_true_label
condition|)
block|{
name|dummy_true_label
operator|=
literal|1
expr_stmt|;
name|if_true_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_true_label
condition|)
name|emit_label
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for a comparison expression EXP (including code to compute    the values to be compared) and a conditional jump to IF_FALSE_LABEL and/or    IF_TRUE_LABEL.  One of the labels can be NULL_RTX, in which case the    generated code will drop through.    SIGNED_CODE should be the rtx operation for this comparison for    signed data; UNSIGNED_CODE, likewise for use if data is unsigned.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.  */
end_comment

begin_function
specifier|static
name|void
name|do_compare_and_jump
parameter_list|(
name|tree
name|exp
parameter_list|,
name|enum
name|rtx_code
name|signed_code
parameter_list|,
name|enum
name|rtx_code
name|unsigned_code
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Don't crash if the comparison was erroneous.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* op0 might have been replaced by promoted constant, in which          case the type of second argument should be used.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|unsignedp
condition|?
name|unsigned_code
else|:
name|signed_code
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* If function pointers need to be "canonicalized" before they can      be reliably compared, then canonicalize them.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op0
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op0
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new_op0
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op1
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|new_op1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-dojump.h"
end_include

end_unit

