begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Graph coloring register allocator    Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Michael Matz<matz@suse.de>    and Daniel Berlin<dan@cgsoftware.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GCC; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_comment
comment|/* This file is part of the graph coloring register allocator.    It deals with building the interference graph.  When rebuilding    the graph for a function after spilling, we rebuild only those    parts needed, i.e. it works incrementally.     The first part (the functions called from build_web_parts_and_conflicts()    ) constructs a web_part for each pseudo register reference in the insn    stream, then goes backward from each use, until it reaches defs for that    pseudo.  While going back it remember seen defs for other registers as    conflicts.  By connecting the uses and defs, which reach each other, webs    (or live ranges) are built conceptually.     The second part (make_webs() and children) deals with converting that    structure to the nodes and edges, on which our interference graph is    built.  For each root web part constructed above, an instance of struct    web is created.  For all subregs of pseudos, which matter for allocation,    a subweb of the corresponding super web is built.  Finally all the    conflicts noted in the first part (as bitmaps) are transformed into real    edges.     As part of that process the webs are also classified (their spill cost    is calculated, and if they are spillable at all, and if not, for what    reason; or if they are rematerializable), and move insns are collected,    which are potentially coalescable.     The top-level entry of this file (build_i_graph) puts it all together,    and leaves us with a complete interference graph, which just has to    be colored.  */
end_comment

begin_struct_decl
struct_decl|struct
name|curr_use
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|rtx_to_undefined
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bitmap
name|find_sub_conflicts
parameter_list|(
name|struct
name|web_part
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bitmap
name|get_sub_conflicts
parameter_list|(
name|struct
name|web_part
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|undef_to_size_word
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bitmap
name|undef_to_bitmap
parameter_list|(
name|struct
name|web_part
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|web_part
modifier|*
name|find_web_part_1
parameter_list|(
name|struct
name|web_part
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|web_part
modifier|*
name|union_web_part_roots
parameter_list|(
name|struct
name|web_part
modifier|*
parameter_list|,
name|struct
name|web_part
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|defuse_overlap_p_1
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|curr_use
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_out_1
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|curr_use
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|live_out
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|curr_use
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|live_in_edge
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|curr_use
modifier|*
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|live_in
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|curr_use
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_insn_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remember_move
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_asm_insn
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_hardregs_for_mode
parameter_list|(
name|HARD_REG_SET
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_one_web_common
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_one_web
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reinit_one_web
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|web
modifier|*
name|add_subweb
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|web
modifier|*
name|add_subweb_2
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_web_parts
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_conflict_list
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_conflict_edge
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|struct
name|web
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_inverse_webs
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_web
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|,
name|struct
name|web_link
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compare_and_free_webs
parameter_list|(
name|struct
name|web_link
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_webs_defs_uses
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|parts_to_webs_1
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|web_link
modifier|*
modifier|*
parameter_list|,
name|struct
name|df_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parts_to_webs
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_conflicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void check_conflict_numbers (void)
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|conflicts_between_webs
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remember_web_was_spilled
parameter_list|(
name|struct
name|web
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|detect_spill_temps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contains_pseudo
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|want_to_remat
parameter_list|(
name|rtx
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|detect_remat_webs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|determine_web_costs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|detect_webs_set_in_cond_jump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_webs
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moves_to_webs
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_rmw_web_parts
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_regnos_mentioned
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|livethrough_conflicts_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_bb_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bb_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_web_parts_and_conflicts
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A sbitmap of DF_REF_IDs of uses, which are live over an abnormal    edge.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|live_over_abnormal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To cache if we already saw a certain edge while analyzing one    use, we use a tick count incremented per use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|visited_pass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A sbitmap of UIDs of move insns, which we already analyzed.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|move_handled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One such structed is allocated per insn, and traces for the currently    analyzed use, which web part belongs to it, and how many bytes of    it were still undefined when that insn was reached.  */
end_comment

begin_struct
struct|struct
name|visit_trace
block|{
name|struct
name|web_part
modifier|*
name|wp
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|undefined
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Indexed by UID.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|visit_trace
modifier|*
name|visit_trace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per basic block we have one such structure, used to speed up    the backtracing of uses.  */
end_comment

begin_struct
struct|struct
name|ra_bb_info
block|{
comment|/* The value of visited_pass, as the first insn of this BB was reached      the last time.  If this equals the current visited_pass, then      undefined is valid.  Otherwise not.  */
name|unsigned
name|int
name|pass
decl_stmt|;
comment|/* The still undefined bytes at that time.  The use to which this is      relative is the current use.  */
name|unsigned
name|HOST_WIDE_INT
name|undefined
decl_stmt|;
comment|/* Bit regno is set, if that regno is mentioned in this BB as a def, or      the source of a copy insn.  In these cases we can not skip the whole      block if we reach it from the end.  */
name|bitmap
name|regnos_mentioned
decl_stmt|;
comment|/* If a use reaches the end of a BB, and that BB doesn't mention its      regno, we skip the block, and remember the ID of that use      as living throughout the whole block.  */
name|bitmap
name|live_throughout
decl_stmt|;
comment|/* The content of the aux field before placing a pointer to this      structure there.  */
name|void
modifier|*
name|old_aux
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We need a fast way to describe a certain part of a register.    Therefore we put together the size and offset (in bytes) in one    integer.  */
end_comment

begin_define
define|#
directive|define
name|BL_TO_WORD
parameter_list|(
name|b
parameter_list|,
name|l
parameter_list|)
value|((((b)& 0xFFFF)<< 16) | ((l)& 0xFFFF))
end_define

begin_define
define|#
directive|define
name|BYTE_BEGIN
parameter_list|(
name|i
parameter_list|)
value|(((unsigned int)(i)>> 16)& 0xFFFF)
end_define

begin_define
define|#
directive|define
name|BYTE_LENGTH
parameter_list|(
name|i
parameter_list|)
value|((unsigned int)(i)& 0xFFFF)
end_define

begin_comment
comment|/* For a REG or SUBREG expression X return the size/offset pair    as an integer.  */
end_comment

begin_function
name|unsigned
name|int
name|rtx_to_bits
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|beg
decl_stmt|;
name|len
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|)
condition|?
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
else|:
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
name|beg
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* X is a REG or SUBREG rtx.  Return the bytes it touches as a bitmask.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|rtx_to_undefined
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|beg
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ret
decl_stmt|;
name|len
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|)
condition|?
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
else|:
literal|0
expr_stmt|;
name|ret
operator|=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|~
operator|(
name|ret
operator|<<
name|len
operator|)
operator|)
operator|<<
name|beg
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* We remember if we've analyzed an insn for being a move insn, and if yes    between which operands.  */
end_comment

begin_struct
struct|struct
name|copy_p_cache
block|{
name|int
name|seen
decl_stmt|;
name|rtx
name|source
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* On demand cache, for if insns are copy insns, and if yes, what    source/target they have.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|copy_p_cache
modifier|*
name|copy_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|number_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For INSN, return nonzero, if it's a move insn, we consider to coalesce    later, and place the operands in *SOURCE and *TARGET, if they are    not NULL.  */
end_comment

begin_function
specifier|static
name|int
name|copy_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|source
parameter_list|,
name|rtx
modifier|*
name|target
parameter_list|)
block|{
name|rtx
name|d
decl_stmt|,
name|s
decl_stmt|;
name|unsigned
name|int
name|d_regno
decl_stmt|,
name|s_regno
decl_stmt|;
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* First look, if we already saw this insn.  */
if|if
condition|(
name|copy_cache
index|[
name|uid
index|]
operator|.
name|seen
condition|)
block|{
comment|/* And if we saw it, if it's actually a copy insn.  */
if|if
condition|(
name|copy_cache
index|[
name|uid
index|]
operator|.
name|seen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|source
condition|)
operator|*
name|source
operator|=
name|copy_cache
index|[
name|uid
index|]
operator|.
name|source
expr_stmt|;
if|if
condition|(
name|target
condition|)
operator|*
name|target
operator|=
name|copy_cache
index|[
name|uid
index|]
operator|.
name|target
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Mark it as seen, but not being a copy insn.  */
name|copy_cache
index|[
name|uid
index|]
operator|.
name|seen
operator|=
literal|2
expr_stmt|;
name|insn
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
literal|0
return|;
name|d
operator|=
name|SET_DEST
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|s
operator|=
name|SET_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We recognize moves between subreg's as copy insns.  This is used to avoid      conflicts of those subwebs.  But they are currently _not_ used for      coalescing (the check for this is in remember_move() below).  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|d
operator|=
name|XEXP
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|d
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|d
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|d
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|s
operator|=
name|XEXP
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
return|return
literal|0
return|;
name|s_regno
operator|=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|s
argument_list|)
else|:
name|s
argument_list|)
expr_stmt|;
name|d_regno
operator|=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|d
argument_list|)
else|:
name|d
argument_list|)
expr_stmt|;
comment|/* Copies between hardregs are useless for us, as not coalesable anyway.  */
if|if
condition|(
operator|(
name|s_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|d_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|s_regno
operator|>=
name|max_normal_pseudo
operator|||
name|d_regno
operator|>=
name|max_normal_pseudo
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|source
condition|)
operator|*
name|source
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|target
condition|)
operator|*
name|target
operator|=
name|d
expr_stmt|;
comment|/* Still mark it as seen, but as a copy insn this time.  */
name|copy_cache
index|[
name|uid
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|copy_cache
index|[
name|uid
index|]
operator|.
name|source
operator|=
name|s
expr_stmt|;
name|copy_cache
index|[
name|uid
index|]
operator|.
name|target
operator|=
name|d
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We build webs, as we process the conflicts.  For each use we go upward    the insn stream, noting any defs as potentially conflicting with the    current use.  We stop at defs of the current regno.  The conflicts are only    potentially, because we may never reach a def, so this is an undefined use,    which conflicts with nothing.  */
end_comment

begin_comment
comment|/* Given a web part WP, and the location of a reg part SIZE_WORD    return the conflict bitmap for that reg part, or NULL if it doesn't    exist yet in WP.  */
end_comment

begin_function
specifier|static
name|bitmap
name|find_sub_conflicts
parameter_list|(
name|struct
name|web_part
modifier|*
name|wp
parameter_list|,
name|unsigned
name|int
name|size_word
parameter_list|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl
decl_stmt|;
name|cl
operator|=
name|wp
operator|->
name|sub_conflicts
expr_stmt|;
for|for
control|(
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
if|if
condition|(
name|cl
operator|->
name|size_word
operator|==
name|size_word
condition|)
return|return
name|cl
operator|->
name|conflicts
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Similar to find_sub_conflicts(), but creates that bitmap, if it    doesn't exist.  I.e. this never returns NULL.  */
end_comment

begin_function
specifier|static
name|bitmap
name|get_sub_conflicts
parameter_list|(
name|struct
name|web_part
modifier|*
name|wp
parameter_list|,
name|unsigned
name|int
name|size_word
parameter_list|)
block|{
name|bitmap
name|b
init|=
name|find_sub_conflicts
argument_list|(
name|wp
argument_list|,
name|size_word
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl
init|=
name|ra_alloc
argument_list|(
sizeof|sizeof
expr|*
name|cl
argument_list|)
decl_stmt|;
name|cl
operator|->
name|conflicts
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|cl
operator|->
name|size_word
operator|=
name|size_word
expr_stmt|;
name|cl
operator|->
name|next
operator|=
name|wp
operator|->
name|sub_conflicts
expr_stmt|;
name|wp
operator|->
name|sub_conflicts
operator|=
name|cl
expr_stmt|;
name|b
operator|=
name|cl
operator|->
name|conflicts
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Helper table for undef_to_size_word() below for small values    of UNDEFINED.  Offsets and lengths are byte based.  */
end_comment

begin_struct
specifier|static
struct|struct
name|undef_table_s
block|{
name|unsigned
name|int
name|new_undef
decl_stmt|;
comment|/* size | (byte<< 16)  */
name|unsigned
name|int
name|size_word
decl_stmt|;
block|}
decl|const
name|undef_table
index|[]
init|=
block|{
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* 0 */
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* 4 */
block|{
literal|1
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|2
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|3
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* 8 */
block|{
literal|1
block|,
name|BL_TO_WORD
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|2
block|,
name|BL_TO_WORD
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|3
block|,
name|BL_TO_WORD
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* 12 */
block|{
literal|1
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
block|{
literal|2
block|,
name|BL_TO_WORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Interpret *UNDEFINED as bitmask where each bit corresponds to a byte.    A set bit means an undefined byte.  Factor all undefined bytes into    groups, and return a size/ofs pair of consecutive undefined bytes,    but according to certain borders.  Clear out those bits corresponding    to bytes overlaid by that size/ofs pair.  REG is only used for    the mode, to detect if it's a floating mode or not.     For example:	*UNDEFINED	size+ofs	new *UNDEFINED 		 1111		4+0		  0 		 1100		2+2		  0 		 1101		2+2		  1 		 0001		1+0		  0 		10101		1+4		101     */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|undef_to_size_word
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|undefined
parameter_list|)
block|{
comment|/* When only the lower four bits are possibly set, we use      a fast lookup table.  */
if|if
condition|(
operator|*
name|undefined
operator|<=
literal|15
condition|)
block|{
name|struct
name|undef_table_s
name|u
decl_stmt|;
name|u
operator|=
name|undef_table
index|[
operator|*
name|undefined
index|]
expr_stmt|;
operator|*
name|undefined
operator|=
name|u
operator|.
name|new_undef
expr_stmt|;
return|return
name|u
operator|.
name|size_word
return|;
block|}
comment|/* Otherwise we handle certain cases directly.  */
if|if
condition|(
operator|*
name|undefined
operator|<=
literal|0xffff
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
operator|*
name|undefined
condition|)
block|{
case|case
literal|0x00f0
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|0x00ff
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
return|;
case|case
literal|0x0f00
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|8
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|0x0ff0
case|:
operator|*
name|undefined
operator|=
literal|0xf0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|8
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|0x0fff
case|:
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|undefined
operator|=
literal|0xff
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|8
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
return|;
comment|/* XFmode */
block|}
case|case
literal|0xf000
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|12
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|0xff00
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
return|;
case|case
literal|0xfff0
case|:
operator|*
name|undefined
operator|=
literal|0xf0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
return|;
case|case
literal|0xffff
case|:
operator|*
name|undefined
operator|=
literal|0
expr_stmt|;
return|return
name|BL_TO_WORD
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|)
return|;
block|}
comment|/* And if nothing matched fall back to the general solution.  For      now unknown undefined bytes are converted to sequences of maximal      length 4 bytes.  We could make this larger if necessary.  */
block|{
name|unsigned
name|HOST_WIDE_INT
name|u
init|=
operator|*
name|undefined
decl_stmt|;
name|int
name|word
decl_stmt|;
name|struct
name|undef_table_s
name|tab
decl_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
operator|(
name|u
operator|&
literal|15
operator|)
operator|==
literal|0
condition|;
name|word
operator|+=
literal|4
control|)
name|u
operator|>>=
literal|4
expr_stmt|;
name|u
operator|=
name|u
operator|&
literal|15
expr_stmt|;
name|tab
operator|=
name|undef_table
index|[
name|u
index|]
expr_stmt|;
name|u
operator|=
name|tab
operator|.
name|new_undef
expr_stmt|;
name|u
operator|=
operator|(
operator|*
name|undefined
operator|&
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|15
operator|<<
name|word
operator|)
operator|)
operator||
operator|(
name|u
operator|<<
name|word
operator|)
expr_stmt|;
operator|*
name|undefined
operator|=
name|u
expr_stmt|;
comment|/* Size remains the same, only the begin is moved up move bytes.  */
return|return
name|tab
operator|.
name|size_word
operator|+
name|BL_TO_WORD
argument_list|(
name|word
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Put the above three functions together.  For a set of undefined bytes    as bitmap *UNDEFINED, look for (create if necessary) and return the    corresponding conflict bitmap.  Change *UNDEFINED to remove the bytes    covered by the part for that bitmap.  */
end_comment

begin_function
specifier|static
name|bitmap
name|undef_to_bitmap
parameter_list|(
name|struct
name|web_part
modifier|*
name|wp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|undefined
parameter_list|)
block|{
name|unsigned
name|int
name|size_word
init|=
name|undef_to_size_word
argument_list|(
name|DF_REF_REAL_REG
argument_list|(
name|wp
operator|->
name|ref
argument_list|)
argument_list|,
name|undefined
argument_list|)
decl_stmt|;
return|return
name|get_sub_conflicts
argument_list|(
name|wp
argument_list|,
name|size_word
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the root of the web part P is a member of.  Additionally    it compresses the path.  P may not be NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|web_part
modifier|*
name|find_web_part_1
parameter_list|(
name|struct
name|web_part
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|web_part
modifier|*
name|r
init|=
name|p
decl_stmt|;
name|struct
name|web_part
modifier|*
name|p_next
decl_stmt|;
while|while
condition|(
name|r
operator|->
name|uplink
condition|)
name|r
operator|=
name|r
operator|->
name|uplink
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|r
condition|;
name|p
operator|=
name|p_next
control|)
block|{
name|p_next
operator|=
name|p
operator|->
name|uplink
expr_stmt|;
name|p
operator|->
name|uplink
operator|=
name|r
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Fast macro for the common case (WP either being the root itself, or    the end of an already compressed path.  */
end_comment

begin_define
define|#
directive|define
name|find_web_part
parameter_list|(
name|wp
parameter_list|)
value|((! (wp)->uplink) ? (wp) \   : (! (wp)->uplink->uplink) ? (wp)->uplink : find_web_part_1 (wp))
end_define

begin_comment
comment|/* Unions together the parts R1 resp. R2 is a root of.    All dynamic information associated with the parts (number of spanned insns    and so on) is also merged.    The root of the resulting (possibly larger) web part is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|web_part
modifier|*
name|union_web_part_roots
parameter_list|(
name|struct
name|web_part
modifier|*
name|r1
parameter_list|,
name|struct
name|web_part
modifier|*
name|r2
parameter_list|)
block|{
if|if
condition|(
name|r1
operator|!=
name|r2
condition|)
block|{
comment|/* The new root is the smaller (pointerwise) of both.  This is crucial          to make the construction of webs from web parts work (so, when 	 scanning all parts, we see the roots before all its children).          Additionally this ensures, that if the web has a def at all, than          the root is a def (because all def parts are before use parts in the 	 web_parts[] array), or put another way, as soon, as the root of a          web part is not a def, this is an uninitialized web part.  The          way we construct the I-graph ensures, that if a web is initialized,          then the first part we find (besides trivial 1 item parts) has a          def.  */
if|if
condition|(
name|r1
operator|>
name|r2
condition|)
block|{
name|struct
name|web_part
modifier|*
name|h
init|=
name|r1
decl_stmt|;
name|r1
operator|=
name|r2
expr_stmt|;
name|r2
operator|=
name|h
expr_stmt|;
block|}
name|r2
operator|->
name|uplink
operator|=
name|r1
expr_stmt|;
name|num_webs
operator|--
expr_stmt|;
comment|/* Now we merge the dynamic information of R1 and R2.  */
name|r1
operator|->
name|spanned_deaths
operator|+=
name|r2
operator|->
name|spanned_deaths
expr_stmt|;
if|if
condition|(
operator|!
name|r1
operator|->
name|sub_conflicts
condition|)
name|r1
operator|->
name|sub_conflicts
operator|=
name|r2
operator|->
name|sub_conflicts
expr_stmt|;
elseif|else
if|if
condition|(
name|r2
operator|->
name|sub_conflicts
condition|)
comment|/* We need to merge the conflict bitmaps from R2 into R1.  */
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl1
decl_stmt|,
modifier|*
name|cl2
decl_stmt|;
comment|/* First those from R2, which are also contained in R1. 	     We union the bitmaps, and free those from R2, resetting them 	     to 0.  */
for|for
control|(
name|cl1
operator|=
name|r1
operator|->
name|sub_conflicts
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
for|for
control|(
name|cl2
operator|=
name|r2
operator|->
name|sub_conflicts
init|;
name|cl2
condition|;
name|cl2
operator|=
name|cl2
operator|->
name|next
control|)
if|if
condition|(
name|cl1
operator|->
name|size_word
operator|==
name|cl2
operator|->
name|size_word
condition|)
block|{
name|bitmap_operation
argument_list|(
name|cl1
operator|->
name|conflicts
argument_list|,
name|cl1
operator|->
name|conflicts
argument_list|,
name|cl2
operator|->
name|conflicts
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|cl2
operator|->
name|conflicts
argument_list|)
expr_stmt|;
name|cl2
operator|->
name|conflicts
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now the conflict lists from R2 which weren't in R1. 	     We simply copy the entries from R2 into R1' list.  */
for|for
control|(
name|cl2
operator|=
name|r2
operator|->
name|sub_conflicts
init|;
name|cl2
condition|;
control|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl_next
init|=
name|cl2
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|cl2
operator|->
name|conflicts
condition|)
block|{
name|cl2
operator|->
name|next
operator|=
name|r1
operator|->
name|sub_conflicts
expr_stmt|;
name|r1
operator|->
name|sub_conflicts
operator|=
name|cl2
expr_stmt|;
block|}
name|cl2
operator|=
name|cl_next
expr_stmt|;
block|}
block|}
name|r2
operator|->
name|sub_conflicts
operator|=
name|NULL
expr_stmt|;
name|r1
operator|->
name|crosses_call
operator||=
name|r2
operator|->
name|crosses_call
expr_stmt|;
block|}
return|return
name|r1
return|;
block|}
end_function

begin_comment
comment|/* Convenience macro, that is capable of unioning also non-roots.  */
end_comment

begin_define
define|#
directive|define
name|union_web_parts
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
define|\
value|((p1 == p2) ? find_web_part (p1) \       : union_web_part_roots (find_web_part (p1), find_web_part (p2)))
end_define

begin_comment
comment|/* Remember that we've handled a given move, so we don't reprocess it.  */
end_comment

begin_function
specifier|static
name|void
name|remember_move
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|move_handled
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|s
decl_stmt|,
name|d
decl_stmt|;
name|SET_BIT
argument_list|(
name|move_handled
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_insn_p
argument_list|(
name|insn
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|d
argument_list|)
condition|)
block|{
comment|/* Some sanity test for the copy insn.  */
name|struct
name|df_link
modifier|*
name|slink
init|=
name|DF_INSN_USES
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
init|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|link
operator|||
operator|!
name|link
operator|->
name|ref
operator|||
operator|!
name|slink
operator|||
operator|!
name|slink
operator|->
name|ref
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The following (link->next != 0) happens when a hardreg 	     is used in wider mode (REG:DI %eax).  Then df.* creates 	     a def/use for each hardreg contained therein.  We only 	     allow hardregs here.  */
if|if
condition|(
name|link
operator|->
name|next
operator|&&
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|next
operator|->
name|ref
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* XXX for now we don't remember move insns involving any subregs. 	 Those would be difficult to coalesce (we would need to implement 	 handling of all the subwebs in the allocator, including that such 	 subwebs could be source and target of coalescing).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|REG
condition|)
block|{
name|struct
name|move
modifier|*
name|m
init|=
name|ra_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|move
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|m
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|ml
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|move_list
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|move
operator|=
name|m
expr_stmt|;
name|ml
operator|->
name|next
operator|=
name|wl_moves
expr_stmt|;
name|wl_moves
operator|=
name|ml
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This describes the USE currently looked at in the main-loop in    build_web_parts_and_conflicts().  */
end_comment

begin_struct
struct|struct
name|curr_use
block|{
name|struct
name|web_part
modifier|*
name|wp
decl_stmt|;
comment|/* This has a 1-bit for each byte in the USE, which is still undefined.  */
name|unsigned
name|HOST_WIDE_INT
name|undefined
decl_stmt|;
comment|/* For easy access.  */
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* If some bits of this USE are live over an abnormal edge.  */
name|unsigned
name|int
name|live_over_abnormal
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Returns nonzero iff rtx DEF and USE have bits in common (but see below).    It is only called with DEF and USE being (reg:M a) or (subreg:M1 (reg:M2 a)    x) rtx's.  Furthermore if it's a subreg rtx M1 is at least one word wide,    and a is a multi-word pseudo.  If DEF or USE are hardregs, they are in    word_mode, so we don't need to check for further hardregs which would result    from wider references.  We are never called with paradoxical subregs.     This returns:    0 for no common bits,    1 if DEF and USE exactly cover the same bytes,    2 if the DEF only covers a part of the bits of USE    3 if the DEF covers more than the bits of the USE, and    4 if both are SUBREG's of different size, but have bytes in common.    -1 is a special case, for when DEF and USE refer to the same regno, but       have for other reasons no bits in common (can only happen with       subregs referring to different words, or to words which already were       defined for this USE).    Furthermore it modifies use->undefined to clear the bits which get defined    by DEF (only for cases with partial overlap).    I.e. if bit 1 is set for the result != -1, the USE was completely covered,    otherwise a test is needed to track the already defined bytes.  */
end_comment

begin_function
specifier|static
name|int
name|defuse_overlap_p_1
parameter_list|(
name|rtx
name|def
parameter_list|,
name|struct
name|curr_use
modifier|*
name|use
parameter_list|)
block|{
name|int
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|def
operator|==
name|use
operator|->
name|x
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|def
argument_list|)
argument_list|)
operator|!=
name|use
operator|->
name|regno
condition|)
return|return
literal|0
return|;
name|mode
operator||=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|def
argument_list|)
operator|!=
name|use
operator|->
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|use
operator|->
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|mode
operator||=
literal|2
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* REG, REG */
return|return
literal|1
return|;
case|case
literal|1
case|:
comment|/* SUBREG, REG */
block|{
name|unsigned
name|HOST_WIDE_INT
name|old_u
init|=
name|use
operator|->
name|undefined
decl_stmt|;
name|use
operator|->
name|undefined
operator|&=
operator|~
name|rtx_to_undefined
argument_list|(
name|def
argument_list|)
expr_stmt|;
return|return
operator|(
name|old_u
operator|!=
name|use
operator|->
name|undefined
operator|)
condition|?
literal|2
else|:
operator|-
literal|1
return|;
block|}
case|case
literal|2
case|:
comment|/* REG, SUBREG */
return|return
literal|3
return|;
case|case
literal|3
case|:
comment|/* SUBREG, SUBREG */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|def
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
operator|->
name|x
argument_list|)
argument_list|)
condition|)
comment|/* If the size of both things is the same, the subreg's overlap 	     if they refer to the same word.  */
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|def
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|use
operator|->
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now the more difficult part: the same regno is referred, but the 	   sizes of the references or the words differ.  E.g.            (subreg:SI (reg:CDI a) 0) and (subreg:DI (reg:CDI a) 2) do not 	   overlap, whereas the latter overlaps with (subreg:SI (reg:CDI a) 3). 	   */
block|{
name|unsigned
name|HOST_WIDE_INT
name|old_u
decl_stmt|;
name|int
name|b1
decl_stmt|,
name|e1
decl_stmt|,
name|b2
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|int
name|bl1
decl_stmt|,
name|bl2
decl_stmt|;
name|bl1
operator|=
name|rtx_to_bits
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|bl2
operator|=
name|rtx_to_bits
argument_list|(
name|use
operator|->
name|x
argument_list|)
expr_stmt|;
name|b1
operator|=
name|BYTE_BEGIN
argument_list|(
name|bl1
argument_list|)
expr_stmt|;
name|b2
operator|=
name|BYTE_BEGIN
argument_list|(
name|bl2
argument_list|)
expr_stmt|;
name|e1
operator|=
name|b1
operator|+
name|BYTE_LENGTH
argument_list|(
name|bl1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|e2
operator|=
name|b2
operator|+
name|BYTE_LENGTH
argument_list|(
name|bl2
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|b1
operator|>
name|e2
operator|||
name|b2
operator|>
name|e1
condition|)
return|return
operator|-
literal|1
return|;
name|old_u
operator|=
name|use
operator|->
name|undefined
expr_stmt|;
name|use
operator|->
name|undefined
operator|&=
operator|~
name|rtx_to_undefined
argument_list|(
name|def
argument_list|)
expr_stmt|;
return|return
operator|(
name|old_u
operator|!=
name|use
operator|->
name|undefined
operator|)
condition|?
literal|4
else|:
operator|-
literal|1
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Macro for the common case of either def and use having the same rtx,    or based on different regnos.  */
end_comment

begin_define
define|#
directive|define
name|defuse_overlap_p
parameter_list|(
name|def
parameter_list|,
name|use
parameter_list|)
define|\
value|((def) == (use)->x ? 1 : \      (REGNO (GET_CODE (def) == SUBREG \ 	     ? SUBREG_REG (def) : def) != use->regno \       ? 0 : defuse_overlap_p_1 (def, use)))
end_define

begin_comment
comment|/* The use USE flows into INSN (backwards).  Determine INSNs effect on it,    and return nonzero, if (parts of) that USE are also live before it.    This also notes conflicts between the USE and all DEFS in that insn,    and modifies the undefined bits of USE in case parts of it were set in    this insn.  */
end_comment

begin_function
specifier|static
name|int
name|live_out_1
parameter_list|(
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|curr_use
modifier|*
name|use
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|defined
init|=
literal|0
decl_stmt|;
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|web_part
modifier|*
name|wp
init|=
name|use
operator|->
name|wp
decl_stmt|;
comment|/* Mark, that this insn needs this webpart live.  */
name|visit_trace
index|[
name|uid
index|]
operator|.
name|wp
operator|=
name|wp
expr_stmt|;
name|visit_trace
index|[
name|uid
index|]
operator|.
name|undefined
operator|=
name|use
operator|->
name|undefined
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|source_regno
init|=
operator|~
literal|0
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|use
operator|->
name|regno
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|orig_undef
init|=
name|use
operator|->
name|undefined
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|final_undef
init|=
name|use
operator|->
name|undefined
decl_stmt|;
name|rtx
name|s
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|,
name|num_defs
init|=
name|insn_df
index|[
name|uid
index|]
operator|.
name|num_defs
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|defs
init|=
name|insn_df
index|[
name|uid
index|]
operator|.
name|defs
decl_stmt|;
comment|/* We want to access the root webpart.  */
name|wp
operator|=
name|find_web_part
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|wp
operator|->
name|crosses_call
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|copy_insn_p
argument_list|(
name|insn
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
condition|)
name|source_regno
operator|=
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|s
argument_list|)
else|:
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all DEFS in this insn.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_defs
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|defs
index|[
name|n
index|]
decl_stmt|;
name|int
name|lap
decl_stmt|;
comment|/* Reset the undefined bits for each iteration, in case this 	     insn has more than one set, and one of them sets this regno. 	     But still the original undefined part conflicts with the other 	     sets.  */
name|use
operator|->
name|undefined
operator|=
name|orig_undef
expr_stmt|;
if|if
condition|(
operator|(
name|lap
operator|=
name|defuse_overlap_p
argument_list|(
name|DF_REF_REG
argument_list|(
name|ref
argument_list|)
argument_list|,
name|use
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lap
operator|==
operator|-
literal|1
condition|)
comment|/* Same regnos but non-overlapping or already defined bits, 		     so ignore this DEF, or better said make the yet undefined 		     part and this DEF conflicting.  */
block|{
name|unsigned
name|HOST_WIDE_INT
name|undef
decl_stmt|;
name|undef
operator|=
name|use
operator|->
name|undefined
expr_stmt|;
while|while
condition|(
name|undef
condition|)
name|bitmap_set_bit
argument_list|(
name|undef_to_bitmap
argument_list|(
name|wp
argument_list|,
operator|&
name|undef
argument_list|)
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|lap
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
comment|/* The current DEF completely covers the USE, so we can 		     stop traversing the code looking for further DEFs.  */
name|defined
operator|=
literal|1
expr_stmt|;
else|else
comment|/* We have a partial overlap.  */
block|{
name|final_undef
operator|&=
name|use
operator|->
name|undefined
expr_stmt|;
if|if
condition|(
name|final_undef
operator|==
literal|0
condition|)
comment|/* Now the USE is completely defined, which means, that 		       we can stop looking for former DEFs.  */
name|defined
operator|=
literal|1
expr_stmt|;
comment|/* If this is a partial overlap, which left some bits 		     in USE undefined, we normally would need to create 		     conflicts between that undefined part and the part of 		     this DEF which overlapped with some of the formerly 		     undefined bits.  We don't need to do this, because both 		     parts of this DEF (that which overlaps, and that which 		     doesn't) are written together in this one DEF, and can 		     not be colored in a way which would conflict with 		     the USE.  This is only true for partial overlap, 		     because only then the DEF and USE have bits in common, 		     which makes the DEF move, if the USE moves, making them 		     aligned. 		     If they have no bits in common (lap == -1), they are 		     really independent.  Therefore we there made a 		     conflict above.  */
block|}
comment|/* This is at least a partial overlap, so we need to union 		 the web parts.  */
name|wp
operator|=
name|union_web_parts
argument_list|(
name|wp
argument_list|,
operator|&
name|web_parts
index|[
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The DEF and the USE don't overlap at all, different 		 regnos.  I.e. make conflicts between the undefined bits, 	         and that DEF.  */
name|unsigned
name|HOST_WIDE_INT
name|undef
init|=
name|use
operator|->
name|undefined
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|source_regno
condition|)
comment|/* This triggers only, when this was a copy insn and the 		   source is at least a part of the USE currently looked at. 		   In this case only the bits of the USE conflict with the 		   DEF, which are not covered by the source of this copy 		   insn, and which are still undefined.  I.e. in the best 		   case (the whole reg being the source), _no_ conflicts 		   between that USE and this DEF (the target of the move) 		   are created by this insn (though they might be by 		   others).  This is a super case of the normal copy insn 		   only between full regs.  */
block|{
name|undef
operator|&=
operator|~
name|rtx_to_undefined
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|undef
condition|)
block|{
comment|/*struct web_part *cwp; 		    cwp = find_web_part (&web_parts[DF_REF_ID 		    (ref)]);*/
comment|/* TODO: somehow instead of noting the ID of the LINK 		     use an ID nearer to the root webpart of that LINK. 		     We can't use the root itself, because we later use the 		     ID to look at the form (reg or subreg, and if yes, 		     which subreg) of this conflict.  This means, that we 		     need to remember in the root an ID for each form, and 		     maintaining this, when merging web parts.  This makes 		     the bitmaps smaller.  */
do|do
name|bitmap_set_bit
argument_list|(
name|undef_to_bitmap
argument_list|(
name|wp
argument_list|,
operator|&
name|undef
argument_list|)
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
name|undef
condition|)
do|;
block|}
block|}
block|}
if|if
condition|(
name|defined
condition|)
name|use
operator|->
name|undefined
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If this insn doesn't completely define the USE, increment also 	     it's spanned deaths count (if this insn contains a death).  */
if|if
condition|(
name|uid
operator|>=
name|death_insns_max_uid
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|insns_with_deaths
argument_list|,
name|uid
argument_list|)
condition|)
name|wp
operator|->
name|spanned_deaths
operator|++
expr_stmt|;
name|use
operator|->
name|undefined
operator|=
name|final_undef
expr_stmt|;
block|}
block|}
return|return
operator|!
name|defined
return|;
block|}
end_function

begin_comment
comment|/* Same as live_out_1() (actually calls it), but caches some information.    E.g. if we reached this INSN with the current regno already, and the    current undefined bits are a subset of those as we came here, we    simply connect the web parts of the USE, and the one cached for this    INSN, and additionally return zero, indicating we don't need to traverse    this path any longer (all effect were already seen, as we first reached    this insn).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|live_out
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|curr_use
modifier|*
name|use
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|visit_trace
index|[
name|uid
index|]
operator|.
name|wp
operator|&&
name|DF_REF_REGNO
argument_list|(
name|visit_trace
index|[
name|uid
index|]
operator|.
name|wp
operator|->
name|ref
argument_list|)
operator|==
name|use
operator|->
name|regno
operator|&&
operator|(
name|use
operator|->
name|undefined
operator|&
operator|~
name|visit_trace
index|[
name|uid
index|]
operator|.
name|undefined
operator|)
operator|==
literal|0
condition|)
block|{
name|union_web_parts
argument_list|(
name|visit_trace
index|[
name|uid
index|]
operator|.
name|wp
argument_list|,
name|use
operator|->
name|wp
argument_list|)
expr_stmt|;
comment|/* Don't search any further, as we already were here with this regno.  */
return|return
literal|0
return|;
block|}
else|else
return|return
name|live_out_1
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The current USE reached a basic block head.  The edge E is one    of the predecessors edges.  This evaluates the effect of the predecessor    block onto the USE, and returns the next insn, which should be looked at.    This either is the last insn of that pred. block, or the first one.    The latter happens, when the pred. block has no possible effect on the    USE, except for conflicts.  In that case, it's remembered, that the USE    is live over that whole block, and it's skipped.  Otherwise we simply    continue with the last insn of the block.     This also determines the effects of abnormal edges, and remembers    which uses are live at the end of that basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|live_in_edge
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|curr_use
modifier|*
name|use
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|struct
name|ra_bb_info
modifier|*
name|info_pred
decl_stmt|;
name|rtx
name|next_insn
decl_stmt|;
comment|/* Call used hard regs die over an exception edge, ergo      they don't reach the predecessor block, so ignore such      uses.  And also don't set the live_over_abnormal flag      for them.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|&&
name|use
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|use
operator|->
name|regno
index|]
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|use
operator|->
name|live_over_abnormal
operator|=
literal|1
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|live_at_end
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
operator|->
name|wp
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|info_pred
operator|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|e
operator|->
name|src
operator|->
name|aux
expr_stmt|;
name|next_insn
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* If the last insn of the pred. block doesn't completely define the      current use, we need to check the block.  */
if|if
condition|(
name|live_out
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|next_insn
argument_list|)
condition|)
block|{
comment|/* If the current regno isn't mentioned anywhere in the whole block, 	 and the complete use is still undefined...  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|info_pred
operator|->
name|regnos_mentioned
argument_list|,
name|use
operator|->
name|regno
argument_list|)
operator|&&
operator|(
name|rtx_to_undefined
argument_list|(
name|use
operator|->
name|x
argument_list|)
operator|&
operator|~
name|use
operator|->
name|undefined
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* ...we can hop over the whole block and defer conflict 	     creation to later.  */
name|bitmap_set_bit
argument_list|(
name|info_pred
operator|->
name|live_throughout
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
operator|->
name|wp
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
return|return
name|next_insn
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* USE flows into the end of the insns preceding INSN.  Determine    their effects (in live_out()) and possibly loop over the preceding INSN,    or call itself recursively on a basic block border.  When a topleve    call of this function returns the USE is completely analyzed.  I.e.    its def-use chain (at least) is built, possibly connected with other    def-use chains, and all defs during that chain are noted.  */
end_comment

begin_function
specifier|static
name|void
name|live_in
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|curr_use
modifier|*
name|use
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|loc_vpass
init|=
name|visited_pass
decl_stmt|;
comment|/* Note, that, even _if_ we are called with use->wp a root-part, this might      become non-root in the for() loop below (due to live_out() unioning      it).  So beware, not to change use->wp in a way, for which only root-webs      are allowed.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|number_seen
index|[
name|uid
index|]
operator|++
expr_stmt|;
comment|/* We want to be as fast as possible, so explicitly write 	 this loop.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return;
if|if
condition|(
name|bb
operator|!=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|undef
init|=
name|use
operator|->
name|undefined
decl_stmt|;
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|bb
operator|->
name|pred
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* We now check, if we already traversed the predecessors of this 	     block for the current pass and the current set of undefined 	     bits.  If yes, we don't need to check the predecessors again. 	     So, conceptually this information is tagged to the first 	     insn of a basic block.  */
if|if
condition|(
name|info
operator|->
name|pass
operator|==
name|loc_vpass
operator|&&
operator|(
name|undef
operator|&
operator|~
name|info
operator|->
name|undefined
operator|)
operator|==
literal|0
condition|)
return|return;
name|info
operator|->
name|pass
operator|=
name|loc_vpass
expr_stmt|;
name|info
operator|->
name|undefined
operator|=
name|undef
expr_stmt|;
comment|/* All but the last predecessor are handled recursively.  */
for|for
control|(
init|;
name|e
operator|->
name|pred_next
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|insn
operator|=
name|live_in_edge
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|live_in
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|use
operator|->
name|undefined
operator|=
name|undef
expr_stmt|;
block|}
name|insn
operator|=
name|live_in_edge
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|live_out
argument_list|(
name|df
argument_list|,
name|use
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Determine all regnos which are mentioned in a basic block, in an    interesting way.  Interesting here means either in a def, or as the    source of a move insn.  We only look at insns added since the last    pass.  */
end_comment

begin_function
specifier|static
name|void
name|update_regnos_mentioned
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|last_uid
init|=
name|last_max_uid
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Don't look at old insns.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|last_uid
condition|)
block|{
comment|/* XXX We should also remember moves over iterations (we already 	       save the cache, but not the movelist).  */
if|if
condition|(
name|copy_insn_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|remember_move
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rtx
name|source
decl_stmt|;
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
name|bitmap
name|mentioned
init|=
name|info
operator|->
name|regnos_mentioned
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|copy_insn_p
argument_list|(
name|insn
argument_list|,
operator|&
name|source
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|remember_move
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|mentioned
argument_list|,
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|source
argument_list|)
else|:
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
name|bitmap_set_bit
argument_list|(
name|mentioned
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the uses which reach a block end, but were deferred due    to it's regno not being mentioned in that block.  This adds the    remaining conflicts and updates also the crosses_call and    spanned_deaths members.  */
end_comment

begin_function
specifier|static
name|void
name|livethrough_conflicts_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap
name|all_defs
decl_stmt|;
name|int
name|first
decl_stmt|,
name|use_id
decl_stmt|;
name|unsigned
name|int
name|deaths
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|contains_call
init|=
literal|0
decl_stmt|;
comment|/* If there are no deferred uses, just return.  */
if|if
condition|(
operator|(
name|first
operator|=
name|bitmap_first_set_bit
argument_list|(
name|info
operator|->
name|live_throughout
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* First collect the IDs of all defs, count the number of death      containing insns, and if there's some call_insn here.  */
name|all_defs
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|struct
name|ra_insn_info
name|info
decl_stmt|;
name|info
operator|=
name|insn_df
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_defs
condition|;
name|n
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|all_defs
argument_list|,
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|defs
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|insns_with_deaths
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|deaths
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|contains_call
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
comment|/* And now, if we have found anything, make all live_through      uses conflict with all defs, and update their other members.  */
if|if
condition|(
name|deaths
operator|>
literal|0
operator|||
name|bitmap_first_set_bit
argument_list|(
name|all_defs
argument_list|)
operator|>=
literal|0
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|info->live_throughout
argument_list|,
argument|first
argument_list|,
argument|use_id
argument_list|,
argument|{         struct web_part *wp =&web_parts[df->def_id + use_id];         unsigned int bl = rtx_to_bits (DF_REF_REG (wp->ref));         bitmap conflicts;         wp = find_web_part (wp);         wp->spanned_deaths += deaths; 	wp->crosses_call |= contains_call;         conflicts = get_sub_conflicts (wp, bl);         bitmap_operation (conflicts, conflicts, all_defs, BITMAP_IOR);       }
argument_list|)
empty_stmt|;
name|BITMAP_XFREE
argument_list|(
name|all_defs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate the per basic block info for traversing the insn stream for    building live ranges.  */
end_comment

begin_function
specifier|static
name|void
name|init_bb_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|info
argument_list|)
decl_stmt|;
name|info
operator|->
name|regnos_mentioned
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|info
operator|->
name|live_throughout
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|info
operator|->
name|old_aux
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free that per basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|free_bb_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
name|BITMAP_XFREE
argument_list|(
name|info
operator|->
name|regnos_mentioned
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|info
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|info
operator|->
name|old_aux
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Toplevel function for the first part of this file.    Connect web parts, thereby implicitly building webs, and remember    their conflicts.  */
end_comment

begin_function
specifier|static
name|void
name|build_web_parts_and_conflicts
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|struct
name|curr_use
name|use
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|number_seen
operator|=
name|xcalloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|visit_trace
operator|=
name|xcalloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|visit_trace
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|update_regnos_mentioned
argument_list|()
expr_stmt|;
comment|/* Here's the main loop.      It goes through all insn's, connects web parts along the way, notes      conflicts between webparts, and remembers move instructions.  */
name|visited_pass
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|use
operator|.
name|regno
operator|=
literal|0
init|;
name|use
operator|.
name|regno
operator|<
operator|(
name|unsigned
name|int
operator|)
name|max_regno
condition|;
name|use
operator|.
name|regno
operator|++
control|)
if|if
condition|(
name|use
operator|.
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|fixed_regs
index|[
name|use
operator|.
name|regno
index|]
condition|)
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|use
operator|.
name|regno
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
decl_stmt|;
comment|/* Only recheck marked or new uses, or uses from hardregs.  */
if|if
condition|(
name|use
operator|.
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
operator|<
name|last_use_id
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|last_check_uses
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
continue|continue;
name|use
operator|.
name|wp
operator|=
operator|&
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|use
operator|.
name|x
operator|=
name|DF_REF_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|use
operator|.
name|live_over_abnormal
operator|=
literal|0
expr_stmt|;
name|use
operator|.
name|undefined
operator|=
name|rtx_to_undefined
argument_list|(
name|use
operator|.
name|x
argument_list|)
expr_stmt|;
name|visited_pass
operator|++
expr_stmt|;
name|live_in
argument_list|(
name|df
argument_list|,
operator|&
name|use
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|.
name|live_over_abnormal
condition|)
name|SET_BIT
argument_list|(
name|live_over_abnormal
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dump_number_seen
argument_list|()
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|ra_bb_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|ra_bb_info
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
name|livethrough_conflicts_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bitmap_zero
argument_list|(
name|info
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|info
operator|->
name|pass
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|visit_trace
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|number_seen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here we look per insn, for DF references being in uses _and_ defs.    This means, in the RTL a (REG xx) expression was seen as a    read/modify/write, as happens for (set (subreg:SI (reg:DI xx)) (...))    e.g.  Our code has created two webs for this, as it should.  Unfortunately,    as the REG reference is only one time in the RTL we can't color    both webs different (arguably this also would be wrong for a real    read-mod-write instruction), so we must reconnect such webs.  */
end_comment

begin_function
specifier|static
name|void
name|connect_rmw_web_parts
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web_part
modifier|*
name|wp1
init|=
operator|&
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|i
index|]
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|wp1
operator|->
name|ref
condition|)
continue|continue;
comment|/* If it's an uninitialized web, we don't want to connect it to others, 	 as the read cycle in read-mod-write had probably no effect.  */
if|if
condition|(
name|find_web_part
argument_list|(
name|wp1
argument_list|)
operator|>=
operator|&
name|web_parts
index|[
name|df
operator|->
name|def_id
index|]
condition|)
continue|continue;
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|wp1
operator|->
name|ref
argument_list|)
expr_stmt|;
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|wp1
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|reg
operator|==
name|DF_REF_REAL_REG
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|)
block|{
name|struct
name|web_part
modifier|*
name|wp2
init|=
operator|&
name|web_parts
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
decl_stmt|;
name|union_web_parts
argument_list|(
name|wp1
argument_list|,
name|wp2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deletes all hardregs from *S which are not allowed for MODE.  */
end_comment

begin_function
specifier|static
name|void
name|prune_hardregs_for_mode
parameter_list|(
name|HARD_REG_SET
modifier|*
name|s
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|AND_HARD_REG_SET
argument_list|(
operator|*
name|s
argument_list|,
name|hardregs_for_mode
index|[
operator|(
name|int
operator|)
name|mode
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the members of a web, which are deducible from REG.  */
end_comment

begin_function
specifier|static
name|void
name|init_one_web_common
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* web->id isn't initialized here.  */
name|web
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|web
operator|->
name|orig_x
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|dlink
condition|)
block|{
name|web
operator|->
name|dlink
operator|=
name|ra_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dlist
argument_list|)
argument_list|)
expr_stmt|;
name|DLIST_WEB
argument_list|(
name|web
operator|->
name|dlink
argument_list|)
operator|=
name|web
expr_stmt|;
block|}
comment|/* XXX      the former (superunion) doesn't constrain the graph enough. E.g.      on x86 QImode _requires_ QI_REGS, but as alternate class usually      GENERAL_REGS is given.  So the graph is not constrained enough,      thinking it has more freedom then it really has, which leads      to repeated spill tryings.  OTOH the latter (only using preferred      class) is too constrained, as normally (e.g. with all SImode      pseudos), they can be allocated also in the alternate class.      What we really want, are the _exact_ hard regs allowed, not      just a class.  Later.  */
comment|/*web->regclass = reg_class_superunion 		    [reg_preferred_class (web->regno)] 		    [reg_alternate_class (web->regno)];*/
comment|/*web->regclass = reg_preferred_class (web->regno);*/
name|web
operator|->
name|regclass
operator|=
name|reg_class_subunion
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
index|[
name|reg_alternate_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
expr_stmt|;
name|web
operator|->
name|regclass
operator|=
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|web
operator|->
name|color
operator|=
name|web
operator|->
name|regno
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|PRECOLORED
argument_list|)
expr_stmt|;
name|web
operator|->
name|num_conflicts
operator|=
name|UINT_MAX
expr_stmt|;
name|web
operator|->
name|add_hardregs
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|web
operator|->
name|regno
argument_list|)
expr_stmt|;
name|web
operator|->
name|num_freedom
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|HARD_REG_SET
name|alternate
decl_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|INITIAL
argument_list|)
expr_stmt|;
comment|/* add_hardregs is wrong in multi-length classes, e.g. 	 using a DFmode pseudo on x86 can result in class FLOAT_INT_REGS, 	 where, if it finally is allocated to GENERAL_REGS it needs two, 	 if allocated to FLOAT_REGS only one hardreg.  XXX */
name|web
operator|->
name|add_hardregs
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|web
operator|->
name|regclass
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|web
operator|->
name|num_conflicts
operator|=
literal|0
operator|*
name|web
operator|->
name|add_hardregs
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|reg_class_contents
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|alternate
argument_list|,
name|reg_class_contents
index|[
name|reg_alternate_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|alternate
argument_list|)
expr_stmt|;
comment|/*IOR_HARD_REG_SET (web->usable_regs, 			reg_class_contents[reg_alternate_class 			(web->regno)]);*/
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|never_use_colors
argument_list|)
expr_stmt|;
name|prune_hardregs_for_mode
argument_list|(
operator|&
name|web
operator|->
name|usable_regs
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|web
operator|->
name|mode_changed
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|invalid_mode_change_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|web
operator|->
name|num_freedom
operator|=
name|hard_regs_count
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|web
operator|->
name|num_freedom
operator|-=
name|web
operator|->
name|add_hardregs
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|num_freedom
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|orig_usable_regs
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initializes WEBs members from REG or zero them.  */
end_comment

begin_function
specifier|static
name|void
name|init_one_web
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|memset
argument_list|(
name|web
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|web
argument_list|)
argument_list|)
expr_stmt|;
name|init_one_web_common
argument_list|(
name|web
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|web
operator|->
name|useless_conflicts
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WEB is an old web, meaning it came from the last pass, and got a    color.  We want to remember some of it's info, so zero only some    members.  */
end_comment

begin_function
specifier|static
name|void
name|reinit_one_web
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|web
operator|->
name|old_color
operator|=
name|web
operator|->
name|color
operator|+
literal|1
expr_stmt|;
name|init_one_web_common
argument_list|(
name|web
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|web
operator|->
name|span_deaths
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|spill_temp
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|orig_spill_temp
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|use_my_regs
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|spill_cost
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|was_spilled
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|is_coalesced
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|artificial
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|live_over_abnormal
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|mode_changed
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|subreg_stripped
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|move_related
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|in_load
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|target_of_spilled_move
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|num_aliased
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|web
operator|->
name|num_defs
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|num_uses
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|orig_spill_cost
operator|=
literal|0
expr_stmt|;
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|web
operator|->
name|bias_colors
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|web
operator|->
name|prefer_colors
argument_list|)
expr_stmt|;
name|web
operator|->
name|reg_rtx
operator|=
name|NULL
expr_stmt|;
name|web
operator|->
name|stack_slot
operator|=
name|NULL
expr_stmt|;
name|web
operator|->
name|pattern
operator|=
name|NULL
expr_stmt|;
name|web
operator|->
name|alias
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|moves
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|useless_conflicts
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert and returns a subweb corresponding to REG into WEB (which    becomes its super web).  It must not exist already.  */
end_comment

begin_function
specifier|static
name|struct
name|web
modifier|*
name|add_subweb
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|struct
name|web
modifier|*
name|w
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|w
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|web
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy most content from parent-web.  */
operator|*
name|w
operator|=
operator|*
name|web
expr_stmt|;
comment|/* And initialize the private stuff.  */
name|w
operator|->
name|orig_x
operator|=
name|reg
expr_stmt|;
name|w
operator|->
name|add_hardregs
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|web
operator|->
name|regclass
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|num_conflicts
operator|=
literal|0
operator|*
name|w
operator|->
name|add_hardregs
expr_stmt|;
name|w
operator|->
name|num_defs
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|num_uses
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|dlink
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|parent_web
operator|=
name|web
expr_stmt|;
name|w
operator|->
name|subreg_next
operator|=
name|web
operator|->
name|subreg_next
expr_stmt|;
name|web
operator|->
name|subreg_next
operator|=
name|w
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/* Similar to add_subweb(), but instead of relying on a given SUBREG,    we have just a size and an offset of the subpart of the REG rtx.    In difference to add_subweb() this marks the new subweb as artificial.  */
end_comment

begin_function
specifier|static
name|struct
name|web
modifier|*
name|add_subweb_2
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|unsigned
name|int
name|size_word
parameter_list|)
block|{
comment|/* To get a correct mode for the to be produced subreg, we don't want to      simply do a mode_for_size() for the mode_class of the whole web.      Suppose we deal with a CDImode web, but search for a 8 byte part.      Now mode_for_size() would only search in the class MODE_COMPLEX_INT      and would find CSImode which probably is not what we want.  Instead      we want DImode, which is in a completely other class.  For this to work      we instead first search the already existing subwebs, and take      _their_ modeclasses as base for a search for ourself.  */
name|rtx
name|ref_rtx
init|=
operator|(
name|web
operator|->
name|subreg_next
condition|?
name|web
operator|->
name|subreg_next
else|:
name|web
operator|)
operator|->
name|orig_x
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|BYTE_LENGTH
argument_list|(
name|size_word
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|ref_rtx
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|web
operator|=
name|add_subweb
argument_list|(
name|web
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|web
operator|->
name|orig_x
argument_list|,
name|BYTE_BEGIN
argument_list|(
name|size_word
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|->
name|artificial
operator|=
literal|1
expr_stmt|;
return|return
name|web
return|;
block|}
end_function

begin_comment
comment|/* Initialize all the web parts we are going to need.  */
end_comment

begin_function
specifier|static
name|void
name|init_web_parts
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|no
decl_stmt|;
name|num_webs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|no
operator|=
literal|0
init|;
name|no
operator|<
name|df
operator|->
name|def_id
condition|;
name|no
operator|++
control|)
block|{
if|if
condition|(
name|df
operator|->
name|defs
index|[
name|no
index|]
condition|)
block|{
if|if
condition|(
name|no
operator|<
name|last_def_id
operator|&&
name|web_parts
index|[
name|no
index|]
operator|.
name|ref
operator|!=
name|df
operator|->
name|defs
index|[
name|no
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|web_parts
index|[
name|no
index|]
operator|.
name|ref
operator|=
name|df
operator|->
name|defs
index|[
name|no
index|]
expr_stmt|;
comment|/* Uplink might be set from the last iteration.  */
if|if
condition|(
operator|!
name|web_parts
index|[
name|no
index|]
operator|.
name|uplink
condition|)
name|num_webs
operator|++
expr_stmt|;
block|}
else|else
comment|/* The last iteration might have left .ref set, while df_analyse() 	   removed that ref (due to a removed copy insn) from the df->defs[] 	   array.  As we don't check for that in realloc_web_parts() 	   we do that here.  */
name|web_parts
index|[
name|no
index|]
operator|.
name|ref
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|no
operator|=
literal|0
init|;
name|no
operator|<
name|df
operator|->
name|use_id
condition|;
name|no
operator|++
control|)
block|{
if|if
condition|(
name|df
operator|->
name|uses
index|[
name|no
index|]
condition|)
block|{
if|if
condition|(
name|no
operator|<
name|last_use_id
operator|&&
name|web_parts
index|[
name|no
operator|+
name|df
operator|->
name|def_id
index|]
operator|.
name|ref
operator|!=
name|df
operator|->
name|uses
index|[
name|no
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|web_parts
index|[
name|no
operator|+
name|df
operator|->
name|def_id
index|]
operator|.
name|ref
operator|=
name|df
operator|->
name|uses
index|[
name|no
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|web_parts
index|[
name|no
operator|+
name|df
operator|->
name|def_id
index|]
operator|.
name|uplink
condition|)
name|num_webs
operator|++
expr_stmt|;
block|}
else|else
name|web_parts
index|[
name|no
operator|+
name|df
operator|->
name|def_id
index|]
operator|.
name|ref
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We want to have only one web for each precolored register.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|struct
name|web_part
modifier|*
name|r1
init|=
name|NULL
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
comment|/* Here once was a test, if there is any DEF at all, and only then to 	 merge all the parts.  This was incorrect, we really also want to have 	 only one web-part for hardregs, even if there is no explicit DEF.  */
comment|/* Link together all defs...  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
block|{
name|struct
name|web_part
modifier|*
name|r2
init|=
operator|&
name|web_parts
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|r1
condition|)
name|r1
operator|=
name|r2
expr_stmt|;
else|else
name|r1
operator|=
name|union_web_parts
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
comment|/* ... and all uses.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
block|{
name|struct
name|web_part
modifier|*
name|r2
init|=
operator|&
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|r1
condition|)
name|r1
operator|=
name|r2
expr_stmt|;
else|else
name|r1
operator|=
name|union_web_parts
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* In case we want to remember the conflict list of a WEB, before adding    new conflicts, we copy it here to orig_conflict_list.  */
end_comment

begin_function
specifier|static
name|void
name|copy_conflict_list
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|)
block|{
name|struct
name|conflict_link
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|orig_conflict_list
operator|||
name|web
operator|->
name|have_orig_conflicts
condition|)
name|abort
argument_list|()
expr_stmt|;
name|web
operator|->
name|have_orig_conflicts
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
name|struct
name|conflict_link
modifier|*
name|ncl
decl_stmt|;
name|ncl
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
expr|*
name|ncl
argument_list|)
expr_stmt|;
name|ncl
operator|->
name|t
operator|=
name|cl
operator|->
name|t
expr_stmt|;
name|ncl
operator|->
name|sub
operator|=
name|NULL
expr_stmt|;
name|ncl
operator|->
name|next
operator|=
name|web
operator|->
name|orig_conflict_list
expr_stmt|;
name|web
operator|->
name|orig_conflict_list
operator|=
name|ncl
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|sub
condition|)
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|,
modifier|*
name|nsl
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|cl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|nsl
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
expr|*
name|nsl
argument_list|)
expr_stmt|;
name|nsl
operator|->
name|s
operator|=
name|sl
operator|->
name|s
expr_stmt|;
name|nsl
operator|->
name|t
operator|=
name|sl
operator|->
name|t
expr_stmt|;
name|nsl
operator|->
name|next
operator|=
name|ncl
operator|->
name|sub
expr_stmt|;
name|ncl
operator|->
name|sub
operator|=
name|nsl
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Possibly add an edge from web FROM to TO marking a conflict between    those two.  This is one half of marking a complete conflict, which notes    in FROM, that TO is a conflict.  Adding TO to FROM's conflicts might    make other conflicts superfluous, because the current TO overlaps some web    already being in conflict with FROM.  In this case the smaller webs are    deleted from the conflict list.  Likewise if TO is overlapped by a web    already in the list, it isn't added at all.  Note, that this can only    happen, if SUBREG webs are involved.  */
end_comment

begin_function
specifier|static
name|void
name|add_conflict_edge
parameter_list|(
name|struct
name|web
modifier|*
name|from
parameter_list|,
name|struct
name|web
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|pfrom
init|=
name|find_web_for_subweb
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|pto
init|=
name|find_web_for_subweb
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|cl
init|=
name|pfrom
operator|->
name|conflict_list
decl_stmt|;
name|int
name|may_delete
init|=
literal|1
decl_stmt|;
comment|/* This can happen when subwebs of one web conflict with each 	 other.  In live_out_1() we created such conflicts between yet 	 undefined webparts and defs of parts which didn't overlap with the 	 undefined bits.  Then later they nevertheless could have merged into 	 one web, and then we land here.  */
if|if
condition|(
name|pfrom
operator|==
name|pto
condition|)
return|return;
if|if
condition|(
name|remember_conflicts
operator|&&
operator|!
name|pfrom
operator|->
name|have_orig_conflicts
condition|)
name|copy_conflict_list
argument_list|(
name|pfrom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
operator|(
name|pfrom
operator|->
name|id
operator|*
name|num_webs
operator|+
name|pto
operator|->
name|id
operator|)
argument_list|)
condition|)
block|{
name|cl
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cl
argument_list|)
argument_list|)
expr_stmt|;
name|cl
operator|->
name|t
operator|=
name|pto
expr_stmt|;
name|cl
operator|->
name|sub
operator|=
name|NULL
expr_stmt|;
name|cl
operator|->
name|next
operator|=
name|pfrom
operator|->
name|conflict_list
expr_stmt|;
name|pfrom
operator|->
name|conflict_list
operator|=
name|cl
expr_stmt|;
if|if
condition|(
name|pto
operator|->
name|type
operator|!=
name|SELECT
operator|&&
name|pto
operator|->
name|type
operator|!=
name|COALESCED
condition|)
name|pfrom
operator|->
name|num_conflicts
operator|+=
literal|1
operator|+
name|pto
operator|->
name|add_hardregs
expr_stmt|;
name|SET_BIT
argument_list|(
name|sup_igraph
argument_list|,
operator|(
name|pfrom
operator|->
name|id
operator|*
name|num_webs
operator|+
name|pto
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|may_delete
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* We don't need to test for cl==NULL, because at this point 	   a cl with cl->t==pto is guaranteed to exist.  */
while|while
condition|(
name|cl
operator|->
name|t
operator|!=
name|pto
condition|)
name|cl
operator|=
name|cl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pfrom
operator|!=
name|from
operator|||
name|pto
operator|!=
name|to
condition|)
block|{
comment|/* This is a subconflict which should be added. 	     If we inserted cl in this invocation, we really need to add this 	     subconflict.  If we did _not_ add it here, we only add the 	     subconflict, if cl already had subconflicts, because otherwise 	     this indicated, that the whole webs already conflict, which 	     means we are not interested in this subconflict.  */
if|if
condition|(
operator|!
name|may_delete
operator|||
name|cl
operator|->
name|sub
operator|!=
name|NULL
condition|)
block|{
name|sl
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sl
argument_list|)
argument_list|)
expr_stmt|;
name|sl
operator|->
name|s
operator|=
name|from
expr_stmt|;
name|sl
operator|->
name|t
operator|=
name|to
expr_stmt|;
name|sl
operator|->
name|next
operator|=
name|cl
operator|->
name|sub
expr_stmt|;
name|cl
operator|->
name|sub
operator|=
name|sl
expr_stmt|;
block|}
block|}
else|else
comment|/* pfrom == from&& pto == to means, that we are not interested 	   anymore in the subconflict list for this pair, because anyway 	   the whole webs conflict.  */
name|cl
operator|->
name|sub
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a conflict between two webs, if we haven't recorded it    already.  */
end_comment

begin_function
name|void
name|record_conflict
parameter_list|(
name|struct
name|web
modifier|*
name|web1
parameter_list|,
name|struct
name|web
modifier|*
name|web2
parameter_list|)
block|{
name|unsigned
name|int
name|id1
init|=
name|web1
operator|->
name|id
decl_stmt|,
name|id2
init|=
name|web2
operator|->
name|id
decl_stmt|;
name|unsigned
name|int
name|index
init|=
name|igraph_index
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
decl_stmt|;
comment|/* Trivial non-conflict or already recorded conflict.  */
if|if
condition|(
name|web1
operator|==
name|web2
operator|||
name|TEST_BIT
argument_list|(
name|igraph
argument_list|,
name|index
argument_list|)
condition|)
return|return;
if|if
condition|(
name|id1
operator|==
name|id2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* As fixed_regs are no targets for allocation, conflicts with them      are pointless.  */
if|if
condition|(
operator|(
name|web1
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|fixed_regs
index|[
name|web1
operator|->
name|regno
index|]
operator|)
operator|||
operator|(
name|web2
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|fixed_regs
index|[
name|web2
operator|->
name|regno
index|]
operator|)
condition|)
return|return;
comment|/* Conflicts with hardregs, which are not even a candidate      for this pseudo are also pointless.  */
if|if
condition|(
operator|(
name|web1
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|web2
operator|->
name|usable_regs
argument_list|,
name|web1
operator|->
name|regno
argument_list|)
operator|)
operator|||
operator|(
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|web1
operator|->
name|usable_regs
argument_list|,
name|web2
operator|->
name|regno
argument_list|)
operator|)
condition|)
return|return;
comment|/* Similar if the set of possible hardregs don't intersect.  This iteration      those conflicts are useless (and would make num_conflicts wrong, because      num_freedom is calculated from the set of possible hardregs).      But in presence of spilling and incremental building of the graph we      need to note all uses of webs conflicting with the spilled ones.      Because the set of possible hardregs can change in the next round for      spilled webs, we possibly have then conflicts with webs which would      be excluded now (because then hardregs intersect).  But we actually      need to check those uses, and to get hold of them, we need to remember      also webs conflicting with this one, although not conflicting in this      round because of non-intersecting hardregs.  */
if|if
condition|(
name|web1
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|web2
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|!
name|hard_regs_intersect_p
argument_list|(
operator|&
name|web1
operator|->
name|usable_regs
argument_list|,
operator|&
name|web2
operator|->
name|usable_regs
argument_list|)
condition|)
block|{
name|struct
name|web
modifier|*
name|p1
init|=
name|find_web_for_subweb
argument_list|(
name|web1
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|p2
init|=
name|find_web_for_subweb
argument_list|(
name|web2
argument_list|)
decl_stmt|;
comment|/* We expect these to be rare enough to justify bitmaps.  And because          we have only a special use for it, we note only the superwebs.  */
name|bitmap_set_bit
argument_list|(
name|p1
operator|->
name|useless_conflicts
argument_list|,
name|p2
operator|->
name|id
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|p2
operator|->
name|useless_conflicts
argument_list|,
name|p1
operator|->
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_BIT
argument_list|(
name|igraph
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|add_conflict_edge
argument_list|(
name|web1
argument_list|,
name|web2
argument_list|)
expr_stmt|;
name|add_conflict_edge
argument_list|(
name|web2
argument_list|,
name|web1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each web W this produces the missing subwebs Wx, such that it's    possible to exactly specify (W-Wy) for all already existing subwebs Wy.  */
end_comment

begin_function
specifier|static
name|void
name|build_inverse_webs
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|)
block|{
name|struct
name|web
modifier|*
name|sweb
init|=
name|web
operator|->
name|subreg_next
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|undef
decl_stmt|;
name|undef
operator|=
name|rtx_to_undefined
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sweb
condition|;
name|sweb
operator|=
name|sweb
operator|->
name|subreg_next
control|)
comment|/* Only create inverses of non-artificial webs.  */
if|if
condition|(
operator|!
name|sweb
operator|->
name|artificial
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|bits
decl_stmt|;
name|bits
operator|=
name|undef
operator|&
operator|~
name|rtx_to_undefined
argument_list|(
name|sweb
operator|->
name|orig_x
argument_list|)
expr_stmt|;
while|while
condition|(
name|bits
condition|)
block|{
name|unsigned
name|int
name|size_word
init|=
name|undef_to_size_word
argument_list|(
name|web
operator|->
name|orig_x
argument_list|,
operator|&
name|bits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|find_subweb_2
argument_list|(
name|web
argument_list|,
name|size_word
argument_list|)
condition|)
name|add_subweb_2
argument_list|(
name|web
argument_list|,
name|size_word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copies the content of WEB to a new one, and link it into WL.    Used for consistency checking.  */
end_comment

begin_function
specifier|static
name|void
name|copy_web
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|,
name|struct
name|web_link
modifier|*
modifier|*
name|wl
parameter_list|)
block|{
name|struct
name|web
modifier|*
name|cweb
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|cweb
argument_list|)
decl_stmt|;
name|struct
name|web_link
modifier|*
name|link
init|=
name|ra_alloc
argument_list|(
sizeof|sizeof
expr|*
name|link
argument_list|)
decl_stmt|;
name|link
operator|->
name|next
operator|=
operator|*
name|wl
expr_stmt|;
operator|*
name|wl
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|web
operator|=
name|cweb
expr_stmt|;
operator|*
name|cweb
operator|=
operator|*
name|web
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a list of webs LINK, compare the content of the webs therein    with the global webs of the same ID.  For consistency checking.  */
end_comment

begin_function
specifier|static
name|void
name|compare_and_free_webs
parameter_list|(
name|struct
name|web_link
modifier|*
modifier|*
name|link
parameter_list|)
block|{
name|struct
name|web_link
modifier|*
name|wl
decl_stmt|;
for|for
control|(
name|wl
operator|=
operator|*
name|link
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web1
init|=
name|wl
operator|->
name|web
decl_stmt|;
name|struct
name|web
modifier|*
name|web2
init|=
name|ID2WEB
argument_list|(
name|web1
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|web1
operator|->
name|regno
operator|!=
name|web2
operator|->
name|regno
operator|||
name|web1
operator|->
name|mode_changed
operator|!=
name|web2
operator|->
name|mode_changed
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|web1
operator|->
name|orig_x
argument_list|,
name|web2
operator|->
name|orig_x
argument_list|)
operator|||
name|web1
operator|->
name|type
operator|!=
name|web2
operator|->
name|type
comment|/* Only compare num_defs/num_uses with non-hardreg webs. 	     E.g. the number of uses of the framepointer changes due to 	     inserting spill code.  */
operator|||
operator|(
name|web1
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|(
name|web1
operator|->
name|num_uses
operator|!=
name|web2
operator|->
name|num_uses
operator|||
name|web1
operator|->
name|num_defs
operator|!=
name|web2
operator|->
name|num_defs
operator|)
operator|)
comment|/* Similarly, if the framepointer was unreferenced originally 	     but we added spills, these fields may not match.  */
operator|||
operator|(
name|web1
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|web1
operator|->
name|crosses_call
operator|!=
name|web2
operator|->
name|crosses_call
operator|)
operator|||
operator|(
name|web1
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|web1
operator|->
name|live_over_abnormal
operator|!=
name|web2
operator|->
name|live_over_abnormal
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|web1
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web1
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|web1
operator|->
name|defs
index|[
name|i
index|]
operator|!=
name|web2
operator|->
name|defs
index|[
name|i
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web1
operator|->
name|num_uses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|web1
operator|->
name|uses
index|[
name|i
index|]
operator|!=
name|web2
operator|->
name|uses
index|[
name|i
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|web1
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
if|if
condition|(
name|web1
operator|->
name|defs
condition|)
name|free
argument_list|(
name|web1
operator|->
name|defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|web1
operator|->
name|uses
condition|)
name|free
argument_list|(
name|web1
operator|->
name|uses
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|web1
argument_list|)
expr_stmt|;
block|}
operator|*
name|link
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup and fill uses[] and defs[] arrays of the webs.  */
end_comment

begin_function
specifier|static
name|void
name|init_webs_defs_uses
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|def_i
decl_stmt|,
name|use_i
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|old_web
condition|)
continue|continue;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|web
operator|->
name|num_defs
operator|=
name|web
operator|->
name|num_uses
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|web
operator|->
name|num_defs
condition|)
name|web
operator|->
name|defs
operator|=
name|xmalloc
argument_list|(
name|web
operator|->
name|num_defs
operator|*
sizeof|sizeof
argument_list|(
name|web
operator|->
name|defs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|num_uses
condition|)
name|web
operator|->
name|uses
operator|=
name|xmalloc
argument_list|(
name|web
operator|->
name|num_uses
operator|*
sizeof|sizeof
argument_list|(
name|web
operator|->
name|uses
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|def_i
operator|=
name|use_i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|web
operator|->
name|temp_refs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
if|if
condition|(
name|DF_REF_REG_DEF_P
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|)
name|web
operator|->
name|defs
index|[
name|def_i
operator|++
index|]
operator|=
name|link
operator|->
name|ref
expr_stmt|;
else|else
name|web
operator|->
name|uses
index|[
name|use_i
operator|++
index|]
operator|=
name|link
operator|->
name|ref
expr_stmt|;
block|}
name|web
operator|->
name|temp_refs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|def_i
operator|!=
name|web
operator|->
name|num_defs
operator|||
name|use_i
operator|!=
name|web
operator|->
name|num_uses
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by parts_to_webs().  This creates (or recreates) the webs (and    subwebs) from web parts, gives them IDs (only to super webs), and sets    up use2web and def2web arrays.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|parts_to_webs_1
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|web_link
modifier|*
modifier|*
name|copy_webs
parameter_list|,
name|struct
name|df_link
modifier|*
name|all_refs
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|webnum
decl_stmt|;
name|unsigned
name|int
name|def_id
init|=
name|df
operator|->
name|def_id
decl_stmt|;
name|unsigned
name|int
name|use_id
init|=
name|df
operator|->
name|use_id
decl_stmt|;
name|struct
name|web_part
modifier|*
name|wp_first_use
init|=
operator|&
name|web_parts
index|[
name|def_id
index|]
decl_stmt|;
comment|/* For each root web part: create and initialize a new web,      setup def2web[] and use2web[] for all defs and uses, and      id2web for all new webs.  */
name|webnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def_id
operator|+
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|subweb
decl_stmt|,
modifier|*
name|web
init|=
literal|0
decl_stmt|;
comment|/* Initialize web to silence warnings.  */
name|struct
name|web_part
modifier|*
name|wp
init|=
operator|&
name|web_parts
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
name|wp
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|ref_id
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
continue|continue;
name|ref_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|def_id
condition|)
name|ref_id
operator|-=
name|def_id
expr_stmt|;
name|all_refs
index|[
name|i
index|]
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
name|reg
operator|=
name|DF_REF_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wp
operator|->
name|uplink
condition|)
block|{
comment|/* If we have a web part root, create a new web.  */
name|unsigned
name|int
name|newid
init|=
operator|~
operator|(
name|unsigned
operator|)
literal|0
decl_stmt|;
name|unsigned
name|int
name|old_web
init|=
literal|0
decl_stmt|;
comment|/* In the first pass, there are no old webs, so unconditionally 	     allocate a new one.  */
if|if
condition|(
name|ra_pass
operator|==
literal|1
condition|)
block|{
name|web
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|web
argument_list|)
argument_list|)
expr_stmt|;
name|newid
operator|=
name|last_num_webs
operator|++
expr_stmt|;
name|init_one_web
argument_list|(
name|web
argument_list|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we look for an old web.  */
else|else
block|{
comment|/* Remember, that use2web == def2web + def_id. 		 Ergo is def2web[i] == use2web[i - def_id] for i>= def_id. 		 So we only need to look into def2web[] array. 		 Try to look at the web, which formerly belonged to this 		 def (or use).  */
name|web
operator|=
name|def2web
index|[
name|i
index|]
expr_stmt|;
comment|/* Or which belonged to this hardreg.  */
if|if
condition|(
operator|!
name|web
operator|&&
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|web
operator|=
name|hardreg2web
index|[
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|web
condition|)
block|{
comment|/* If we found one, reuse it.  */
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
expr_stmt|;
name|old_web
operator|=
literal|1
expr_stmt|;
name|copy_web
argument_list|(
name|web
argument_list|,
name|copy_webs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use a new one.  First from the free list.  */
if|if
condition|(
name|WEBS
argument_list|(
name|FREE
argument_list|)
condition|)
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|FREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Else allocate a new one.  */
name|web
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|web
argument_list|)
argument_list|)
expr_stmt|;
name|newid
operator|=
name|last_num_webs
operator|++
expr_stmt|;
block|}
block|}
comment|/* The id is zeroed in init_one_web().  */
if|if
condition|(
name|newid
operator|==
operator|~
operator|(
name|unsigned
operator|)
literal|0
condition|)
name|newid
operator|=
name|web
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|old_web
condition|)
name|reinit_one_web
argument_list|(
name|web
argument_list|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
expr_stmt|;
else|else
name|init_one_web
argument_list|(
name|web
argument_list|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
expr_stmt|;
name|web
operator|->
name|old_web
operator|=
operator|(
name|old_web
operator|&&
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|web
operator|->
name|span_deaths
operator|=
name|wp
operator|->
name|spanned_deaths
expr_stmt|;
name|web
operator|->
name|crosses_call
operator|=
name|wp
operator|->
name|crosses_call
expr_stmt|;
name|web
operator|->
name|id
operator|=
name|newid
expr_stmt|;
name|web
operator|->
name|temp_refs
operator|=
name|NULL
expr_stmt|;
name|webnum
operator|++
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|hardreg2web
index|[
name|web
operator|->
name|regno
index|]
condition|)
name|hardreg2web
index|[
name|web
operator|->
name|regno
index|]
operator|=
name|web
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|hardreg2web
index|[
name|web
operator|->
name|regno
index|]
operator|!=
name|web
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this reference already had a web assigned, we are done.          This test better is equivalent to the web being an old web.          Otherwise something is screwed.  (This is tested)  */
if|if
condition|(
name|def2web
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|web
operator|=
name|def2web
index|[
name|i
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
comment|/* But if this ref includes a mode change, or was a use live 	     over an abnormal call, set appropriate flags in the web.  */
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_MODE_CHANGE
operator|)
operator|!=
literal|0
operator|&&
name|web
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|web
operator|->
name|mode_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_STRIPPED
operator|)
operator|!=
literal|0
operator|&&
name|web
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|web
operator|->
name|subreg_stripped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|def_id
operator|&&
name|TEST_BIT
argument_list|(
name|live_over_abnormal
argument_list|,
name|ref_id
argument_list|)
condition|)
name|web
operator|->
name|live_over_abnormal
operator|=
literal|1
expr_stmt|;
comment|/* And check, that it's not a newly allocated web.  This would be 	     an inconsistency.  */
if|if
condition|(
operator|!
name|web
operator|->
name|old_web
operator|||
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* In case this was no web part root, we need to initialize WEB 	 from the ref2web array belonging to the root.  */
if|if
condition|(
name|wp
operator|->
name|uplink
condition|)
block|{
name|struct
name|web_part
modifier|*
name|rwp
init|=
name|find_web_part
argument_list|(
name|wp
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|j
init|=
name|DF_REF_ID
argument_list|(
name|rwp
operator|->
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|rwp
operator|<
name|wp_first_use
condition|)
name|web
operator|=
name|def2web
index|[
name|j
index|]
expr_stmt|;
else|else
name|web
operator|=
name|use2web
index|[
name|j
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
block|}
comment|/* Remember all references for a web in a single linked list.  */
name|all_refs
index|[
name|i
index|]
operator|.
name|next
operator|=
name|web
operator|->
name|temp_refs
expr_stmt|;
name|web
operator|->
name|temp_refs
operator|=
operator|&
name|all_refs
index|[
name|i
index|]
expr_stmt|;
comment|/* And the test, that if def2web[i] was NULL above, that we are _not_ 	 an old web.  */
if|if
condition|(
name|web
operator|->
name|old_web
operator|&&
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Possible create a subweb, if this ref was a subreg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|subweb
operator|=
name|find_subweb
argument_list|(
name|web
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subweb
condition|)
block|{
name|subweb
operator|=
name|add_subweb
argument_list|(
name|web
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|old_web
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|subweb
operator|=
name|web
expr_stmt|;
comment|/* And look, if the ref involves an invalid mode change.  */
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_MODE_CHANGE
operator|)
operator|!=
literal|0
operator|&&
name|web
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|web
operator|->
name|mode_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_STRIPPED
operator|)
operator|!=
literal|0
operator|&&
name|web
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|web
operator|->
name|subreg_stripped
operator|=
literal|1
expr_stmt|;
comment|/* Setup def2web, or use2web, and increment num_defs or num_uses.  */
if|if
condition|(
name|i
operator|<
name|def_id
condition|)
block|{
comment|/* Some sanity checks.  */
if|if
condition|(
name|ra_pass
operator|>
literal|1
condition|)
block|{
name|struct
name|web
modifier|*
name|compare
init|=
name|def2web
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|last_def_id
condition|)
block|{
if|if
condition|(
name|web
operator|->
name|old_web
operator|&&
name|compare
operator|!=
name|subweb
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|web
operator|->
name|old_web
operator|&&
name|compare
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
name|compare
operator|!=
name|subweb
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|def2web
index|[
name|i
index|]
operator|=
name|subweb
expr_stmt|;
name|web
operator|->
name|num_defs
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ra_pass
operator|>
literal|1
condition|)
block|{
name|struct
name|web
modifier|*
name|compare
init|=
name|use2web
index|[
name|ref_id
index|]
decl_stmt|;
if|if
condition|(
name|ref_id
operator|<
name|last_use_id
condition|)
block|{
if|if
condition|(
name|web
operator|->
name|old_web
operator|&&
name|compare
operator|!=
name|subweb
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|web
operator|->
name|old_web
operator|&&
name|compare
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
name|compare
operator|!=
name|subweb
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|use2web
index|[
name|ref_id
index|]
operator|=
name|subweb
expr_stmt|;
name|web
operator|->
name|num_uses
operator|++
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|live_over_abnormal
argument_list|,
name|ref_id
argument_list|)
condition|)
name|web
operator|->
name|live_over_abnormal
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We better now have exactly as many webs as we had web part roots.  */
if|if
condition|(
name|webnum
operator|!=
name|num_webs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|webnum
return|;
block|}
end_function

begin_comment
comment|/* This builds full webs out of web parts, without relating them to each    other (i.e. without creating the conflict edges).  */
end_comment

begin_function
specifier|static
name|void
name|parts_to_webs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|webnum
decl_stmt|;
name|struct
name|web_link
modifier|*
name|copy_webs
init|=
name|NULL
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|struct
name|df_link
modifier|*
name|all_refs
decl_stmt|;
name|num_subwebs
operator|=
literal|0
expr_stmt|;
comment|/* First build webs and ordinary subwebs.  */
name|all_refs
operator|=
name|xcalloc
argument_list|(
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
argument_list|,
sizeof|sizeof
argument_list|(
name|all_refs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|webnum
operator|=
name|parts_to_webs_1
argument_list|(
name|df
argument_list|,
operator|&
name|copy_webs
argument_list|,
name|all_refs
argument_list|)
expr_stmt|;
comment|/* Setup the webs for hardregs which are still missing (weren't      mentioned in the code).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hardreg2web
index|[
name|i
index|]
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|web
argument_list|)
argument_list|)
decl_stmt|;
name|init_one_web
argument_list|(
name|web
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|->
name|id
operator|=
name|last_num_webs
operator|++
expr_stmt|;
name|hardreg2web
index|[
name|web
operator|->
name|regno
index|]
operator|=
name|web
expr_stmt|;
block|}
name|num_webs
operator|=
name|last_num_webs
expr_stmt|;
comment|/* Now create all artificial subwebs, i.e. those, which do      not correspond to a real subreg in the current function's RTL, but      which nevertheless is a target of a conflict.      XXX we need to merge this loop with the one above, which means, we need      a way to later override the artificiality.  Beware: currently      add_subweb_2() relies on the existence of normal subwebs for deducing      a sane mode to use for the artificial subwebs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web_part
modifier|*
name|wp
init|=
operator|&
name|web_parts
index|[
name|i
index|]
decl_stmt|;
name|struct
name|tagged_conflict
modifier|*
name|cl
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
if|if
condition|(
name|wp
operator|->
name|uplink
operator|||
operator|!
name|wp
operator|->
name|ref
condition|)
block|{
if|if
condition|(
name|wp
operator|->
name|sub_conflicts
condition|)
name|abort
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|web
operator|=
name|def2web
index|[
name|i
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|wp
operator|->
name|sub_conflicts
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|find_subweb_2
argument_list|(
name|web
argument_list|,
name|cl
operator|->
name|size_word
argument_list|)
condition|)
name|add_subweb_2
argument_list|(
name|web
argument_list|,
name|cl
operator|->
name|size_word
argument_list|)
expr_stmt|;
block|}
comment|/* And now create artificial subwebs needed for representing the inverse      of some subwebs.  This also gives IDs to all subwebs.  */
name|webnum
operator|=
name|last_num_webs
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|subreg_next
condition|)
block|{
name|struct
name|web
modifier|*
name|sweb
decl_stmt|;
name|build_inverse_webs
argument_list|(
name|web
argument_list|)
expr_stmt|;
for|for
control|(
name|sweb
operator|=
name|web
operator|->
name|subreg_next
init|;
name|sweb
condition|;
name|sweb
operator|=
name|sweb
operator|->
name|subreg_next
control|)
name|sweb
operator|->
name|id
operator|=
name|webnum
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now that everyone has an ID, we can setup the id2web array.  */
name|id2web
operator|=
name|xcalloc
argument_list|(
name|webnum
argument_list|,
sizeof|sizeof
argument_list|(
name|id2web
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|ID2WEB
argument_list|(
name|web
operator|->
name|id
argument_list|)
operator|=
name|web
expr_stmt|;
for|for
control|(
name|web
operator|=
name|web
operator|->
name|subreg_next
init|;
name|web
condition|;
name|web
operator|=
name|web
operator|->
name|subreg_next
control|)
name|ID2WEB
argument_list|(
name|web
operator|->
name|id
argument_list|)
operator|=
name|web
expr_stmt|;
block|}
name|num_subwebs
operator|=
name|webnum
operator|-
name|last_num_webs
expr_stmt|;
name|num_allwebs
operator|=
name|num_webs
operator|+
name|num_subwebs
expr_stmt|;
name|num_webs
operator|+=
name|num_subwebs
expr_stmt|;
comment|/* Allocate and clear the conflict graph bitmaps.  */
name|igraph
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
operator|*
name|num_webs
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sup_igraph
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
operator|*
name|num_webs
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|igraph
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|sup_igraph
argument_list|)
expr_stmt|;
comment|/* Distribute the references to their webs.  */
name|init_webs_defs_uses
argument_list|()
expr_stmt|;
comment|/* And do some sanity checks if old webs, and those recreated from the      really are the same.  */
name|compare_and_free_webs
argument_list|(
operator|&
name|copy_webs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_refs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This deletes all conflicts to and from webs which need to be renewed    in this pass of the allocator, i.e. those which were spilled in the    last pass.  Furthermore it also rebuilds the bitmaps for the remaining    conflicts.  */
end_comment

begin_function
specifier|static
name|void
name|reset_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap
name|newwebs
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Hardreg webs and non-old webs are new webs (which 	 need rebuilding).  */
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
operator|!
name|web
operator|->
name|old_web
condition|)
name|bitmap_set_bit
argument_list|(
name|newwebs
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|cl
decl_stmt|;
name|struct
name|conflict_link
modifier|*
modifier|*
name|pcl
decl_stmt|;
name|pcl
operator|=
operator|&
operator|(
name|web
operator|->
name|conflict_list
operator|)
expr_stmt|;
comment|/* First restore the conflict list to be like it was before 	 coalescing.  */
if|if
condition|(
name|web
operator|->
name|have_orig_conflicts
condition|)
block|{
name|web
operator|->
name|conflict_list
operator|=
name|web
operator|->
name|orig_conflict_list
expr_stmt|;
name|web
operator|->
name|orig_conflict_list
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|web
operator|->
name|orig_conflict_list
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* New non-precolored webs, have no conflict list.  */
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|!
name|web
operator|->
name|old_web
condition|)
block|{
operator|*
name|pcl
operator|=
name|NULL
expr_stmt|;
comment|/* Useless conflicts will be rebuilt completely.  But check 	     for cleanliness, as the web might have come from the 	     free list.  */
if|if
condition|(
name|bitmap_first_set_bit
argument_list|(
name|web
operator|->
name|useless_conflicts
argument_list|)
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Useless conflicts with new webs will be rebuilt if they 	     are still there.  */
name|bitmap_operation
argument_list|(
name|web
operator|->
name|useless_conflicts
argument_list|,
name|web
operator|->
name|useless_conflicts
argument_list|,
name|newwebs
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
comment|/* Go through all conflicts, and retain those to old webs.  */
for|for
control|(
name|cl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|t
operator|->
name|old_web
operator|||
name|cl
operator|->
name|t
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
operator|*
name|pcl
operator|=
name|cl
expr_stmt|;
name|pcl
operator|=
operator|&
operator|(
name|cl
operator|->
name|next
operator|)
expr_stmt|;
comment|/* Also restore the entries in the igraph bitmaps.  */
name|web
operator|->
name|num_conflicts
operator|+=
literal|1
operator|+
name|cl
operator|->
name|t
operator|->
name|add_hardregs
expr_stmt|;
name|SET_BIT
argument_list|(
name|sup_igraph
argument_list|,
operator|(
name|web
operator|->
name|id
operator|*
name|num_webs
operator|+
name|cl
operator|->
name|t
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
comment|/* No subconflicts mean full webs conflict.  */
if|if
condition|(
operator|!
name|cl
operator|->
name|sub
condition|)
name|SET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|web
operator|->
name|id
argument_list|,
name|cl
operator|->
name|t
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Else only the parts in cl->sub must be in the 		       bitmap.  */
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|cl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|sl
operator|->
name|s
operator|->
name|id
argument_list|,
name|sl
operator|->
name|t
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pcl
operator|=
name|NULL
expr_stmt|;
block|}
name|web
operator|->
name|have_orig_conflicts
operator|=
literal|0
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|newwebs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each web check it's num_conflicts member against that    number, as calculated from scratch from all neighbors.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void check_conflict_numbers (void) {   unsigned int i;   for (i = 0; i< num_webs; i++)     {       struct web *web = ID2WEB (i);       int new_conf = 0 * web->add_hardregs;       struct conflict_link *cl;       for (cl = web->conflict_list; cl; cl = cl->next) 	if (cl->t->type != SELECT&& cl->t->type != COALESCED) 	  new_conf += 1 + cl->t->add_hardregs;       if (web->type != PRECOLORED&& new_conf != web->num_conflicts) 	abort ();     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert the conflicts between web parts to conflicts between full webs.     This can't be done in parts_to_webs(), because for recording conflicts    between webs we need to know their final usable_regs set, which is used    to discard non-conflicts (between webs having no hard reg in common).    But this is set for spill temporaries only after the webs itself are    built.  Until then the usable_regs set is based on the pseudo regno used    in this web, which may contain far less registers than later determined.    This would result in us loosing conflicts (due to record_conflict()    thinking that a web can only be allocated to the current usable_regs,    whereas later this is extended) leading to colorings, where some regs which    in reality conflict get the same color.  */
end_comment

begin_function
specifier|static
name|void
name|conflicts_between_webs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
endif|#
directive|endif
name|bitmap
name|ignore_defs
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|have_ignored
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pass_cache
init|=
name|xcalloc
argument_list|(
name|num_webs
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|pass
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ra_pass
operator|>
literal|1
condition|)
name|reset_conflicts
argument_list|()
expr_stmt|;
comment|/* It is possible, that in the conflict bitmaps still some defs I are noted,      which have web_parts[I].ref being NULL.  This can happen, when from the      last iteration the conflict bitmap for this part wasn't deleted, but a      conflicting move insn was removed.  It's DEF is still in the conflict      bitmap, but it doesn't exist anymore in df->defs.  To not have to check      it in the tight loop below, we instead remember the ID's of them in a      bitmap, and loop only over IDs which are not in it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|web_parts
index|[
name|i
index|]
operator|.
name|ref
operator|==
name|NULL
condition|)
name|bitmap_set_bit
argument_list|(
name|ignore_defs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|have_ignored
operator|=
operator|(
name|bitmap_first_set_bit
argument_list|(
name|ignore_defs
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
comment|/* Now record all conflicts between webs.  Note that we only check      the conflict bitmaps of all defs.  Conflict bitmaps are only in      webpart roots.  If they are in uses, those uses are roots, which      means, that this is an uninitialized web, whose conflicts      don't matter.  Nevertheless for hardregs we also need to check uses.      E.g. hardregs used for argument passing have no DEF in the RTL,      but if they have uses, they indeed conflict with all DEFs they      overlap.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl
init|=
name|web_parts
index|[
name|i
index|]
operator|.
name|sub_conflicts
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb1
decl_stmt|;
if|if
condition|(
operator|!
name|cl
operator|||
operator|(
name|i
operator|>=
name|df
operator|->
name|def_id
operator|&&
name|DF_REF_REGNO
argument_list|(
name|web_parts
index|[
name|i
index|]
operator|.
name|ref
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
continue|continue;
name|supweb1
operator|=
name|def2web
index|[
name|i
index|]
expr_stmt|;
name|supweb1
operator|=
name|find_web_for_subweb
argument_list|(
name|supweb1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
if|if
condition|(
name|cl
operator|->
name|conflicts
condition|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|web
modifier|*
name|web1
init|=
name|find_subweb_2
argument_list|(
name|supweb1
argument_list|,
name|cl
operator|->
name|size_word
argument_list|)
decl_stmt|;
if|if
condition|(
name|have_ignored
condition|)
name|bitmap_operation
argument_list|(
name|cl
operator|->
name|conflicts
argument_list|,
name|cl
operator|->
name|conflicts
argument_list|,
name|ignore_defs
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
comment|/* We reduce the number of calls to record_conflict() with this 	       pass thing.  record_conflict() itself also has some early-out 	       optimizations, but here we can use the special properties of 	       the loop (constant web1) to reduce that even more. 	       We once used an sbitmap of already handled web indices, 	       but sbitmaps are slow to clear and bitmaps are slow to 	       set/test.  The current approach needs more memory, but 	       locality is large.  */
name|pass
operator|++
expr_stmt|;
comment|/* Note, that there are only defs in the conflicts bitset.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|cl->conflicts
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		struct web *web2 = def2web[j]; 		unsigned int id2 = web2->id; 		if (pass_cache[id2] != pass) 		  { 		    pass_cache[id2] = pass; 		    record_conflict (web1, web2); 		  } 	      }
argument_list|)
empty_stmt|;
block|}
block|}
name|free
argument_list|(
name|pass_cache
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|ignore_defs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Pseudos can't go in stack regs if they are live at the beginning of      a block that is reached by an abnormal edge.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|live_over_abnormal
condition|)
for|for
control|(
name|j
operator|=
name|FIRST_STACK_REG
init|;
name|j
operator|<=
name|LAST_STACK_REG
condition|;
name|j
operator|++
control|)
name|record_conflict
argument_list|(
name|web
argument_list|,
name|hardreg2web
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Remember that a web was spilled, and change some characteristics    accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|remember_web_was_spilled
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|found_size
init|=
literal|0
decl_stmt|;
name|int
name|adjust
decl_stmt|;
name|web
operator|->
name|spill_temp
operator|=
literal|1
expr_stmt|;
comment|/* From now on don't use reg_pref/alt_class (regno) anymore for      this web, but instead  usable_regs.  We can't use spill_temp for      this, as it might get reset later, when we are coalesced to a      non-spill-temp.  In that case we still want to use usable_regs.  */
name|web
operator|->
name|use_my_regs
operator|=
literal|1
expr_stmt|;
comment|/* We don't constrain spill temporaries in any way for now.      It's wrong sometimes to have the same constraints or      preferences as the original pseudo, esp. if they were very narrow.      (E.g. there once was a reg wanting class AREG (only one register)      without alternative class.  As long, as also the spill-temps for      this pseudo had the same constraints it was spilled over and over.      Ideally we want some constraints also on spill-temps: Because they are      not only loaded/stored, but also worked with, any constraints from insn      alternatives needs applying.  Currently this is dealt with by reload, as      many other things, but at some time we want to integrate that      functionality into the allocator.  */
if|if
condition|(
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|reg_class_contents
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|reg_class_contents
index|[
name|reg_alternate_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|never_use_colors
argument_list|)
expr_stmt|;
name|prune_hardregs_for_mode
argument_list|(
operator|&
name|web
operator|->
name|usable_regs
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|web
operator|->
name|mode_changed
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|invalid_mode_change_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|web
operator|->
name|num_freedom
operator|=
name|hard_regs_count
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|num_freedom
condition|)
name|abort
argument_list|()
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|orig_usable_regs
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
comment|/* Now look for a class, which is subset of our constraints, to      setup add_hardregs, and regclass for debug output.  */
name|web
operator|->
name|regclass
operator|=
name|NO_REGS
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|HARD_REG_SET
name|test
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|test
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|test
argument_list|,
name|never_use_colors
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|test
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|,
name|found
argument_list|)
expr_stmt|;
continue|continue;
name|found
label|:
comment|/* Measure the actual number of bits which really are overlapping 	 the target regset, not just the reg_class_size.  */
name|size
operator|=
name|hard_regs_count
argument_list|(
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_size
operator|<
name|size
condition|)
block|{
name|web
operator|->
name|regclass
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|i
expr_stmt|;
name|found_size
operator|=
name|size
expr_stmt|;
block|}
block|}
name|adjust
operator|=
literal|0
operator|*
name|web
operator|->
name|add_hardregs
expr_stmt|;
name|web
operator|->
name|add_hardregs
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|web
operator|->
name|regclass
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|web
operator|->
name|num_freedom
operator|-=
name|web
operator|->
name|add_hardregs
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|num_freedom
condition|)
name|abort
argument_list|()
expr_stmt|;
name|adjust
operator|-=
literal|0
operator|*
name|web
operator|->
name|add_hardregs
expr_stmt|;
name|web
operator|->
name|num_conflicts
operator|-=
name|adjust
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at each web, if it is used as spill web.  Or better said,    if it will be spillable in this pass.  */
end_comment

begin_function
specifier|static
name|void
name|detect_spill_temps
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|bitmap
name|already
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
comment|/* Detect webs used for spill temporaries.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|/* Below only the detection of spill temporaries.  We never spill          precolored webs, so those can't be spill temporaries.  The code above          (remember_web_was_spilled) can't currently cope with hardregs          anyway.  */
if|if
condition|(
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
comment|/* Uninitialized webs can't be spill-temporaries.  */
if|if
condition|(
name|web
operator|->
name|num_defs
operator|==
literal|0
condition|)
continue|continue;
comment|/* A web with only defs and no uses can't be spilled.  Nevertheless 	 it must get a color, as it takes away a register from all webs 	 live at these defs.  So we make it a short web.  */
if|if
condition|(
name|web
operator|->
name|num_uses
operator|==
literal|0
condition|)
name|web
operator|->
name|spill_temp
operator|=
literal|3
expr_stmt|;
comment|/* A web which was spilled last time, but for which no insns were          emitted (can happen with IR spilling ignoring sometimes 	 all deaths).  */
elseif|else
if|if
condition|(
name|web
operator|->
name|changed
condition|)
name|web
operator|->
name|spill_temp
operator|=
literal|1
expr_stmt|;
comment|/* A spill temporary has one def, one or more uses, all uses 	 are in one insn, and either the def or use insn was inserted 	 by the allocator.  */
comment|/* XXX not correct currently.  There might also be spill temps 	 involving more than one def.  Usually that's an additional 	 clobber in the using instruction.  We might also constrain 	 ourself to that, instead of like currently marking all 	 webs involving any spill insns at all.  */
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|spill_involved
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_uses
operator|&&
operator|!
name|spill_involved
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DF_REF_INSN_UID
argument_list|(
name|web
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
operator|>=
name|orig_max_uid
condition|)
name|spill_involved
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
operator|&&
operator|!
name|spill_involved
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DF_REF_INSN_UID
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
operator|>=
name|orig_max_uid
condition|)
name|spill_involved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spill_involved
comment|/*&& ra_pass> 2*/
condition|)
block|{
name|int
name|num_deaths
init|=
name|web
operator|->
name|span_deaths
decl_stmt|;
comment|/* Mark webs involving at least one spill insn as 		 spill temps.  */
name|remember_web_was_spilled
argument_list|(
name|web
argument_list|)
expr_stmt|;
comment|/* Search for insns which define and use the web in question 		 at the same time, i.e. look for rmw insns.  If these insns 		 are also deaths of other webs they might have been counted 		 as such into web->span_deaths.  But because of the rmw nature 		 of this insn it is no point where a load/reload could be 		 placed successfully (it would still conflict with the 		 dead web), so reduce the number of spanned deaths by those 		 insns.  Note that sometimes such deaths are _not_ counted, 	         so negative values can result.  */
name|bitmap_zero
argument_list|(
name|already
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|web
operator|->
name|defs
index|[
name|i
index|]
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|insns_with_deaths
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|already
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|already
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only decrement it once for each insn.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|web
operator|->
name|num_uses
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|web
operator|->
name|uses
index|[
name|j
index|]
operator|->
name|insn
operator|==
name|insn
condition|)
block|{
name|num_deaths
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* But mark them specially if they could possibly be spilled, 		 either because they cross some deaths (without the above 		 mentioned ones) or calls.  */
if|if
condition|(
name|web
operator|->
name|crosses_call
operator|||
name|num_deaths
operator|>
literal|0
condition|)
name|web
operator|->
name|spill_temp
operator|=
literal|1
operator|*
literal|2
expr_stmt|;
block|}
comment|/* A web spanning no deaths can't be spilled either.  No loads 	     would be created for it, ergo no defs.  So the insns wouldn't 	     change making the graph not easier to color.  Make this also 	     a short web.  Don't do this if it crosses calls, as these are 	     also points of reloads.  */
elseif|else
if|if
condition|(
name|web
operator|->
name|span_deaths
operator|==
literal|0
operator|&&
operator|!
name|web
operator|->
name|crosses_call
condition|)
name|web
operator|->
name|spill_temp
operator|=
literal|3
expr_stmt|;
block|}
name|web
operator|->
name|orig_spill_temp
operator|=
name|web
operator|->
name|spill_temp
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|already
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the rtx MEM refers somehow to a stack location.  */
end_comment

begin_function
name|int
name|memref_is_stack_slot
parameter_list|(
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|ad
init|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
operator|||
name|x
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero, if rtx X somewhere contains any pseudo register.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pseudo
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|contains_pseudo
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|contains_pseudo
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero, if we are able to rematerialize something with    value X.  If it's not a general operand, we test if we can produce    a valid insn which set a pseudo to that value, and that insn doesn't    clobber anything.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|remat_test_insn
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|want_to_remat
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|num_clobbers
init|=
literal|0
decl_stmt|;
name|int
name|icode
decl_stmt|;
comment|/* If this is a valid operand, we are OK.  If it's VOIDmode, we aren't.  */
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, check if we can make a valid insn from it.  First initialize      our test insn if we haven't already.  */
if|if
condition|(
name|remat_test_insn
operator|==
literal|0
condition|)
block|{
name|remat_test_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
literal|2
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|remat_test_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|remat_test_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now make an insn like the one we would make when rematerializing      the value X and see if valid.  */
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|remat_test_insn
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|remat_test_insn
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* XXX For now we don't allow any clobbers to be added, not just no      hardreg clobbers.  */
return|return
operator|(
operator|(
name|icode
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|remat_test_insn
argument_list|)
argument_list|,
name|remat_test_insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|num_clobbers
operator|==
literal|0
comment|/*|| ! added_clobbers_hard_reg_p (icode)*/
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look at all webs, if they perhaps are rematerializable.    They are, if all their defs are simple sets to the same value,    and that value is simple enough, and want_to_remat() holds for it.  */
end_comment

begin_function
specifier|static
name|void
name|detect_remat_webs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Hardregs and useless webs aren't spilled -> no remat necessary. 	 Defless webs obviously also can't be rematerialized.  */
if|if
condition|(
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|web
operator|->
name|num_defs
operator|||
operator|!
name|web
operator|->
name|num_uses
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
operator|=
name|DF_REF_INSN
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
break|break;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* When only subregs of the web are set it isn't easily 	     rematerializable.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|web
operator|->
name|orig_x
argument_list|)
condition|)
break|break;
comment|/* If we already have a pattern it must be equal to the current.  */
if|if
condition|(
name|pat
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|pat
argument_list|,
name|src
argument_list|)
condition|)
break|break;
comment|/* Don't do the expensive checks multiple times.  */
if|if
condition|(
name|pat
condition|)
continue|continue;
comment|/* For now we allow only constant sources.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
comment|/* If the whole thing is stable already, it is a source for 		  remat, no matter how complicated (probably all needed 		  resources for it are live everywhere, and don't take 		  additional register resources).  */
comment|/* XXX Currently we can't use patterns which contain 		  pseudos, _even_ if they are stable.  The code simply isn't 		  prepared for that.  All those operands can't be spilled (or 		  the dependent remat webs are not remat anymore), so they 		  would be oldwebs in the next iteration.  But currently 		  oldwebs can't have their references changed.  The 		  incremental machinery barfs on that.  */
operator|||
operator|(
operator|!
name|rtx_unstable_p
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|contains_pseudo
argument_list|(
name|src
argument_list|)
operator|)
comment|/* Additionally also memrefs to stack-slots are useful, when 		  we created them ourself.  They might not have set their 		  unchanging flag set, but nevertheless they are stable across 		  the livetime in question.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|orig_max_uid
operator|&&
name|memref_is_stack_slot
argument_list|(
name|src
argument_list|)
operator|)
operator|)
comment|/* And we must be able to construct an insn without 		 side-effects to actually load that value into a reg.  */
operator|&&
name|want_to_remat
argument_list|(
name|src
argument_list|)
condition|)
name|pat
operator|=
name|src
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|pat
operator|&&
name|i
operator|==
name|web
operator|->
name|num_defs
condition|)
name|web
operator|->
name|pattern
operator|=
name|pat
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the spill costs of all webs.  */
end_comment

begin_function
specifier|static
name|void
name|determine_web_costs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|num_loads
decl_stmt|;
name|int
name|load_cost
decl_stmt|,
name|store_cost
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
continue|continue;
comment|/* Get costs for one load/store.  Note that we offset them by 1, 	 because some patterns have a zero rtx_cost(), but we of course 	 still need the actual load/store insns.  With zero all those 	 webs would be the same, no matter how often and where 	 they are used.  */
if|if
condition|(
name|web
operator|->
name|pattern
condition|)
block|{
comment|/* This web is rematerializable.  Beware, we set store_cost to 	     zero optimistically assuming, that we indeed don't emit any 	     stores in the spill-code addition.  This might be wrong if 	     at the point of the load not all needed resources are 	     available, in which case we emit a stack-based load, for 	     which we in turn need the according stores.  */
name|load_cost
operator|=
literal|1
operator|+
name|rtx_cost
argument_list|(
name|web
operator|->
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_cost
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|load_cost
operator|=
literal|1
operator|+
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|,
name|web
operator|->
name|regclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_cost
operator|=
literal|1
operator|+
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|,
name|web
operator|->
name|regclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We create only loads at deaths, whose number is in span_deaths.  */
name|num_loads
operator|=
name|MIN
argument_list|(
name|web
operator|->
name|span_deaths
argument_list|,
name|web
operator|->
name|num_uses
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_uses
condition|;
name|i
operator|++
control|)
name|w
operator|+=
name|DF_REF_BB
argument_list|(
name|web
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|num_loads
operator|<
name|web
operator|->
name|num_uses
condition|)
name|w
operator|=
operator|(
name|w
operator|*
name|num_loads
operator|+
name|web
operator|->
name|num_uses
operator|-
literal|1
operator|)
operator|/
name|web
operator|->
name|num_uses
expr_stmt|;
name|web
operator|->
name|spill_cost
operator|=
name|w
operator|*
name|load_cost
expr_stmt|;
if|if
condition|(
name|store_cost
condition|)
block|{
for|for
control|(
name|w
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
name|w
operator|+=
name|DF_REF_BB
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
name|web
operator|->
name|spill_cost
operator|+=
name|w
operator|*
name|store_cost
expr_stmt|;
block|}
name|web
operator|->
name|orig_spill_cost
operator|=
name|web
operator|->
name|spill_cost
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Detect webs which are set in a conditional jump insn (possibly a    decrement-and-branch type of insn), and mark them not to be    spillable.  The stores for them would need to be placed on edges,    which destroys the CFG.  (Somewhen we want to deal with that XXX)  */
end_comment

begin_function
specifier|static
name|void
name|detect_webs_set_in_cond_jump
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
operator|&&
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
decl_stmt|;
name|web
operator|->
name|orig_spill_temp
operator|=
name|web
operator|->
name|spill_temp
operator|=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Second top-level function of this file.    Converts the connected web parts to full webs.  This means, it allocates    all webs, and initializes all fields, including detecting spill    temporaries.  It does not distribute moves to their corresponding webs,    though.  */
end_comment

begin_function
specifier|static
name|void
name|make_webs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
comment|/* First build all the webs itself.  They are not related with      others yet.  */
name|parts_to_webs
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Now detect spill temporaries to initialize their usable_regs set.  */
name|detect_spill_temps
argument_list|()
expr_stmt|;
name|detect_webs_set_in_cond_jump
argument_list|()
expr_stmt|;
comment|/* And finally relate them to each other, meaning to record all possible      conflicts between webs (see the comment there).  */
name|conflicts_between_webs
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|detect_remat_webs
argument_list|()
expr_stmt|;
name|determine_web_costs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Distribute moves to the corresponding webs.  */
end_comment

begin_function
specifier|static
name|void
name|moves_to_webs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
comment|/* Distribute all moves to their corresponding webs, making sure,      each move is in a web maximally one time (happens on some strange      insns).  */
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
name|struct
name|move
modifier|*
name|m
init|=
name|ml
operator|->
name|move
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|struct
name|move_list
modifier|*
name|newml
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
continue|continue;
name|m
operator|->
name|type
operator|=
name|WORKLIST
expr_stmt|;
name|m
operator|->
name|dlink
operator|=
name|NULL
expr_stmt|;
comment|/* Multiple defs/uses can happen in moves involving hard-regs in 	 a wider mode.  For those df.* creates use/def references for each 	 real hard-reg involved.  For coalescing we are interested in 	 the smallest numbered hard-reg.  */
for|for
control|(
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|m
operator|->
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
block|{
name|web
operator|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|target_web
operator|||
name|web
operator|->
name|regno
operator|<
name|m
operator|->
name|target_web
operator|->
name|regno
condition|)
name|m
operator|->
name|target_web
operator|=
name|web
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|DF_INSN_USES
argument_list|(
name|df
argument_list|,
name|m
operator|->
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
block|{
name|web
operator|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|source_web
operator|||
name|web
operator|->
name|regno
operator|<
name|m
operator|->
name|source_web
operator|->
name|regno
condition|)
name|m
operator|->
name|source_web
operator|=
name|web
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|source_web
operator|&&
name|m
operator|->
name|target_web
comment|/* If the usable_regs don't intersect we can't coalesce the two 	     webs anyway, as this is no simple copy insn (it might even 	     need an intermediate stack temp to execute this "copy" insn).  */
operator|&&
name|hard_regs_intersect_p
argument_list|(
operator|&
name|m
operator|->
name|source_web
operator|->
name|usable_regs
argument_list|,
operator|&
name|m
operator|->
name|target_web
operator|->
name|usable_regs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|flag_ra_optimistic_coalescing
condition|)
block|{
name|struct
name|move_list
modifier|*
name|test
init|=
name|m
operator|->
name|source_web
operator|->
name|moves
decl_stmt|;
for|for
control|(
init|;
name|test
operator|&&
name|test
operator|->
name|move
operator|!=
name|m
condition|;
name|test
operator|=
name|test
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
block|{
name|newml
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|move_list
argument_list|)
argument_list|)
expr_stmt|;
name|newml
operator|->
name|move
operator|=
name|m
expr_stmt|;
name|newml
operator|->
name|next
operator|=
name|m
operator|->
name|source_web
operator|->
name|moves
expr_stmt|;
name|m
operator|->
name|source_web
operator|->
name|moves
operator|=
name|newml
expr_stmt|;
block|}
name|test
operator|=
name|m
operator|->
name|target_web
operator|->
name|moves
expr_stmt|;
for|for
control|(
init|;
name|test
operator|&&
name|test
operator|->
name|move
operator|!=
name|m
condition|;
name|test
operator|=
name|test
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
block|{
name|newml
operator|=
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|move_list
argument_list|)
argument_list|)
expr_stmt|;
name|newml
operator|->
name|move
operator|=
name|m
expr_stmt|;
name|newml
operator|->
name|next
operator|=
name|m
operator|->
name|target_web
operator|->
name|moves
expr_stmt|;
name|m
operator|->
name|target_web
operator|->
name|moves
operator|=
name|newml
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Delete this move.  */
name|ml
operator|->
name|move
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle tricky asm insns.    Supposed to create conflicts to hardregs which aren't allowed in    the constraints.  Doesn't actually do that, as it might confuse    and constrain the allocator too much.  */
end_comment

begin_function
specifier|static
name|void
name|handle_asm_insn
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|noperands
decl_stmt|,
name|in_output
decl_stmt|;
name|HARD_REG_SET
name|clobbered
decl_stmt|,
name|allowed
decl_stmt|,
name|conflict
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|clobbered
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|t
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|clobbered
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decode_asm_operands
argument_list|(
name|pat
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|recog_data
operator|.
name|operand_loc
argument_list|,
name|constraints
argument_list|,
name|operand_mode
argument_list|)
expr_stmt|;
name|in_output
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|int
name|cls
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|int
name|nothing_allowed
init|=
literal|1
decl_stmt|;
name|reg
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
comment|/* Look, if the constraints apply to a pseudo reg, and not to 	 e.g. a mem.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
comment|/* Search the web corresponding to this operand.  We depend on 	 that decode_asm_operands() places the output operands 	 before the input operands.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|in_output
condition|)
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|.
name|defs
expr_stmt|;
else|else
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|.
name|uses
expr_stmt|;
while|while
condition|(
name|link
operator|&&
name|link
operator|->
name|ref
operator|&&
name|DF_REF_REAL_REG
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|!=
name|reg
condition|)
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|link
operator|||
operator|!
name|link
operator|->
name|ref
condition|)
block|{
if|if
condition|(
name|in_output
condition|)
name|in_output
operator|=
literal|0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|in_output
condition|)
name|web
operator|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
else|else
name|web
operator|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
name|reg
operator|=
name|DF_REF_REG
argument_list|(
name|link
operator|->
name|ref
argument_list|)
expr_stmt|;
comment|/* Find the constraints, noting the allowed hardregs in allowed.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* End of one alternative - mark the regs in the current 	       class, and reset the class.  */
name|p
operator|++
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|,
name|reg_class_contents
index|[
name|cls
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls
operator|!=
name|NO_REGS
condition|)
name|nothing_allowed
operator|=
literal|0
expr_stmt|;
name|cls
operator|=
name|NO_REGS
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'&'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'X'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'p'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
expr_stmt|;
name|nothing_allowed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
name|nothing_allowed
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
index|]
expr_stmt|;
block|}
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Now make conflicts between this web, and all hardregs, which 	 are not allowed by the constraints.  */
if|if
condition|(
name|nothing_allowed
condition|)
block|{
comment|/* If we had no real constraints nothing was explicitly 	     allowed, so we allow the whole class (i.e. we make no 	     additional conflicts).  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|conflict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|conflict
argument_list|,
name|usable_regs
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|conflict
argument_list|,
name|usable_regs
index|[
name|reg_alternate_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|conflict
argument_list|,
name|allowed
argument_list|)
expr_stmt|;
comment|/* We can't yet establish these conflicts.  Reload must go first 	     (or better said, we must implement some functionality of reload). 	     E.g. if some operands must match, and they need the same color 	     we don't see yet, that they do not conflict (because they match). 	     For us it looks like two normal references with different DEFs, 	     so they conflict, and as they both need the same color, the 	     graph becomes uncolorable.  */
if|#
directive|if
literal|0
block|for (c = 0; c< FIRST_PSEUDO_REGISTER; c++) 	    if (TEST_HARD_REG_BIT (conflict, c)) 	      record_conflict (web, hardreg2web[c]);
endif|#
directive|endif
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|int
name|c
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_ASM
argument_list|,
literal|" ASM constrain Web %d conflicts with:"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|conflict
argument_list|,
name|c
argument_list|)
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_ASM
argument_list|,
literal|" %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_ASM
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The real toplevel function in this file.    Build (or rebuilds) the complete interference graph with webs    and conflicts.  */
end_comment

begin_function
name|void
name|build_i_graph
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|init_web_parts
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|move_handled
argument_list|)
expr_stmt|;
name|wl_moves
operator|=
name|NULL
expr_stmt|;
name|build_web_parts_and_conflicts
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* For read-modify-write instructions we may have created two webs.      Reconnect them here.  (s.a.)  */
name|connect_rmw_web_parts
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* The webs are conceptually complete now, but still scattered around as      connected web parts.  Collect all information and build the webs      including all conflicts between webs (instead web parts).  */
name|make_webs
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|moves_to_webs
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Look for additional constraints given by asms.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|handle_asm_insn
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates or reallocates most memory for the interference graph and    associated structures.  If it reallocates memory (meaning, this is not    the first pass), this also changes some structures to reflect the    additional entries in various array, and the higher number of    defs and uses.  */
end_comment

begin_function
name|void
name|ra_build_realloc
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|struct
name|web_part
modifier|*
name|last_web_parts
init|=
name|web_parts
decl_stmt|;
name|struct
name|web
modifier|*
modifier|*
name|last_def2web
init|=
name|def2web
decl_stmt|;
name|struct
name|web
modifier|*
modifier|*
name|last_use2web
init|=
name|use2web
decl_stmt|;
name|sbitmap
name|last_live_over_abnormal
init|=
name|live_over_abnormal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|move_handled
operator|=
name|sbitmap_alloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
name|web_parts
operator|=
name|xcalloc
argument_list|(
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
argument_list|,
sizeof|sizeof
name|web_parts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|def2web
operator|=
name|xcalloc
argument_list|(
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
argument_list|,
sizeof|sizeof
name|def2web
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|use2web
operator|=
operator|&
name|def2web
index|[
name|df
operator|->
name|def_id
index|]
expr_stmt|;
name|live_over_abnormal
operator|=
name|sbitmap_alloc
argument_list|(
name|df
operator|->
name|use_id
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|live_over_abnormal
argument_list|)
expr_stmt|;
comment|/* First go through all old defs and uses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_def_id
operator|+
name|last_use_id
condition|;
name|i
operator|++
control|)
block|{
comment|/* And relocate them to the new array.  This is made ugly by the          fact, that defs and uses are placed consecutive into one array.  */
name|struct
name|web_part
modifier|*
name|dest
init|=
operator|&
name|web_parts
index|[
name|i
operator|<
name|last_def_id
condition|?
name|i
else|:
operator|(
name|df
operator|->
name|def_id
operator|+
name|i
operator|-
name|last_def_id
operator|)
index|]
decl_stmt|;
name|struct
name|web_part
modifier|*
name|up
decl_stmt|;
operator|*
name|dest
operator|=
name|last_web_parts
index|[
name|i
index|]
expr_stmt|;
name|up
operator|=
name|dest
operator|->
name|uplink
expr_stmt|;
name|dest
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
comment|/* Also relocate the uplink to point into the new array.  */
if|if
condition|(
name|up
operator|&&
name|up
operator|->
name|ref
condition|)
block|{
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|up
operator|->
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|up
operator|<
operator|&
name|last_web_parts
index|[
name|last_def_id
index|]
condition|)
block|{
if|if
condition|(
name|df
operator|->
name|defs
index|[
name|id
index|]
condition|)
name|dest
operator|->
name|uplink
operator|=
operator|&
name|web_parts
index|[
name|DF_REF_ID
argument_list|(
name|up
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|df
operator|->
name|uses
index|[
name|id
index|]
condition|)
name|dest
operator|->
name|uplink
operator|=
operator|&
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|DF_REF_ID
argument_list|(
name|up
operator|->
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
block|}
comment|/* Also set up the def2web and use2web arrays, from the last pass.i      Remember also the state of live_over_abnormal.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_def_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|last_def2web
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|web
condition|)
block|{
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|FREE
operator|&&
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|def2web
index|[
name|i
index|]
operator|=
name|last_def2web
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|last_use2web
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|web
condition|)
block|{
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|FREE
operator|&&
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|use2web
index|[
name|i
index|]
operator|=
name|last_use2web
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|TEST_BIT
argument_list|(
name|last_live_over_abnormal
argument_list|,
name|i
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|live_over_abnormal
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* We don't have any subwebs for now.  Somewhen we might want to      remember them too, instead of recreating all of them every time.      The problem is, that which subwebs we need, depends also on what      other webs and subwebs exist, and which conflicts are there.      OTOH it should be no problem, if we had some more subwebs than strictly      needed.  Later.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|FREE
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|wnext
decl_stmt|;
for|for
control|(
name|web
operator|=
name|web
operator|->
name|subreg_next
init|;
name|web
condition|;
name|web
operator|=
name|wnext
control|)
block|{
name|wnext
operator|=
name|web
operator|->
name|subreg_next
expr_stmt|;
name|free
argument_list|(
name|web
argument_list|)
expr_stmt|;
block|}
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|subreg_next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The uses we anyway are going to check, are not yet live over an abnormal      edge.  In fact, they might actually not anymore, due to added      loads.  */
if|if
condition|(
name|last_check_uses
condition|)
name|sbitmap_difference
argument_list|(
name|live_over_abnormal
argument_list|,
name|live_over_abnormal
argument_list|,
name|last_check_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_def_id
operator|||
name|last_use_id
condition|)
block|{
name|sbitmap_free
argument_list|(
name|last_live_over_abnormal
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|last_web_parts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|last_def2web
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last_max_uid
condition|)
block|{
comment|/* Setup copy cache, for copy_insn_p ().  */
name|copy_cache
operator|=
name|xcalloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|copy_cache
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|init_bb_info
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|copy_cache
operator|=
name|xrealloc
argument_list|(
name|copy_cache
argument_list|,
name|get_max_uid
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|copy_cache
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|copy_cache
index|[
name|last_max_uid
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|get_max_uid
argument_list|()
operator|-
name|last_max_uid
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|copy_cache
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free up/clear some memory, only needed for one pass.  */
end_comment

begin_function
name|void
name|ra_build_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Clear the moves associated with a web (we also need to look into      subwebs here).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|web
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|num_webs
operator|-
name|num_subwebs
operator|&&
operator|(
name|web
operator|->
name|conflict_list
operator|||
name|web
operator|->
name|orig_conflict_list
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|web
operator|->
name|moves
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* All webs in the free list have no defs or uses anymore.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|FREE
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|defs
condition|)
name|free
argument_list|(
name|web
operator|->
name|defs
argument_list|)
expr_stmt|;
name|web
operator|->
name|defs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|uses
condition|)
name|free
argument_list|(
name|web
operator|->
name|uses
argument_list|)
expr_stmt|;
name|web
operator|->
name|uses
operator|=
name|NULL
expr_stmt|;
comment|/* We can't free the subwebs here, as they are referenced from 	 def2web[], and possibly needed in the next ra_build_realloc(). 	 We free them there (or in free_all_mem()).  */
block|}
comment|/* Free all conflict bitmaps from web parts.  Note that we clear      _all_ these conflicts, and don't rebuild them next time for uses      which aren't rechecked.  This mean, that those conflict bitmaps      only contain the incremental information.  The cumulative one      is still contained in the edges of the I-graph, i.e. in      conflict_list (or orig_conflict_list) of the webs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl
decl_stmt|;
for|for
control|(
name|cl
operator|=
name|web_parts
index|[
name|i
index|]
operator|.
name|sub_conflicts
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|conflicts
condition|)
name|BITMAP_XFREE
argument_list|(
name|cl
operator|->
name|conflicts
argument_list|)
expr_stmt|;
block|}
name|web_parts
index|[
name|i
index|]
operator|.
name|sub_conflicts
operator|=
name|NULL
expr_stmt|;
block|}
name|wl_moves
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|id2web
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|move_handled
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|sup_igraph
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|igraph
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all memory for the interference graph structures.  */
end_comment

begin_function
name|void
name|ra_build_free_all
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|free_bb_info
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|copy_cache
argument_list|)
expr_stmt|;
name|copy_cache
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tagged_conflict
modifier|*
name|cl
decl_stmt|;
for|for
control|(
name|cl
operator|=
name|web_parts
index|[
name|i
index|]
operator|.
name|sub_conflicts
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|conflicts
condition|)
name|BITMAP_XFREE
argument_list|(
name|cl
operator|->
name|conflicts
argument_list|)
expr_stmt|;
block|}
name|web_parts
index|[
name|i
index|]
operator|.
name|sub_conflicts
operator|=
name|NULL
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|live_over_abnormal
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|web_parts
argument_list|)
expr_stmt|;
name|web_parts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_check_uses
condition|)
name|sbitmap_free
argument_list|(
name|last_check_uses
argument_list|)
expr_stmt|;
name|last_check_uses
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|def2web
argument_list|)
expr_stmt|;
name|use2web
operator|=
name|NULL
expr_stmt|;
name|def2web
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-ra-build.h"
end_include

begin_comment
comment|/* vim:cinoptions={.5s,g0,p5,t0,(0,^-0.5s,n-0.5s:tw=78:cindent:sw=4: */
end_comment

end_unit

