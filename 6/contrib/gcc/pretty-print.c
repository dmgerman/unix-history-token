begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Various declarations for language-independent pretty-print subroutines.    Copyright (C) 2003 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"pretty-print.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* A pointer to the formatted diagnostic message.  */
end_comment

begin_define
define|#
directive|define
name|pp_formatted_text_data
parameter_list|(
name|PP
parameter_list|)
define|\
value|((const char *) obstack_base (&pp_base (PP)->buffer->obstack))
end_define

begin_comment
comment|/* Format an integer given by va_arg (ARG, type-specifier T) where    type-specifier is a precision modifier as indicated by PREC.  F is    a string used to construct the appropriate format-specifier.  */
end_comment

begin_define
define|#
directive|define
name|pp_integer_with_precision
parameter_list|(
name|PP
parameter_list|,
name|ARG
parameter_list|,
name|PREC
parameter_list|,
name|T
parameter_list|,
name|F
parameter_list|)
define|\
value|do                                                         \     switch (PREC)                                            \       {                                                      \       case 0:                                                \         pp_scalar (PP, "%" F, va_arg (ARG, T));              \         break;                                               \                                                              \       case 1:                                                \         pp_scalar (PP, "%l" F, va_arg (ARG, long T));        \         break;                                               \                                                              \       case 2:                                                \         pp_scalar (PP, "%ll" F, va_arg (ARG, long long T));  \         break;                                               \                                                              \       default:                                               \         break;                                               \       }                                                      \   while (0)
end_define

begin_comment
comment|/* Subroutine of pp_set_maximum_length.  Set up PRETTY-PRINTER's    internal maximum characters per line.  */
end_comment

begin_function
specifier|static
name|void
name|pp_set_real_maximum_length
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
comment|/* If we're told not to wrap lines then do the obvious thing.  In case      we'll emit prefix only once per message, it is appropriate      not to increase unnecessarily the line-length cut-off.  */
if|if
condition|(
operator|!
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
operator|||
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
operator|||
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
condition|)
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|prefix_length
init|=
name|pp
operator|->
name|prefix
condition|?
name|strlen
argument_list|(
name|pp
operator|->
name|prefix
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If the prefix is ridiculously too long, output at least          32 characters.  */
if|if
condition|(
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|-
name|prefix_length
operator|<
literal|32
condition|)
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|+
literal|32
expr_stmt|;
else|else
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear PRETTY-PRINTER's output state.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_clear_state
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|emitted_prefix
operator|=
name|false
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the formatted text of PRETTY-PRINTER onto the attached stream.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_write_text_to_stream
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
name|pp_formatted_text
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pp_clear_output_area
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrap a text delimited by START and END into PRETTY-PRINTER.  */
end_comment

begin_function
specifier|static
name|void
name|pp_wrap_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|bool
name|wrapping_line
init|=
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
decl_stmt|;
while|while
condition|(
name|start
operator|!=
name|end
condition|)
block|{
comment|/* Dump anything bordered by whitespaces.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|!
name|ISBLANK
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|wrapping_line
operator|&&
name|p
operator|-
name|start
operator|>=
name|pp_remaining_character_count_for_line
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
name|ISBLANK
argument_list|(
operator|*
name|start
argument_list|)
condition|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Same as pp_wrap_text but wrap text only when in line-wrapping mode.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_maybe_wrap_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_wrap_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append to the output area of PRETTY-PRINTER a string specified by its    STARTing character and LENGTH.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_append_r
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert enough spaces into the output area of PRETTY-PRINTER to bring    the column position to the current indentation level, assuming that a    newline has just been written to the buffer.  */
end_comment

begin_function
name|void
name|pp_base_indent
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|n
init|=
name|pp_indentation
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format a message pointed to by TEXT.  The following format specifiers are    recognized as being client independent:    %d, %i: (signed) integer in base ten.    %u: unsigned integer in base ten.    %o: unsigned integer in base eight.    %x: unsigned integer in base sixteen.    %ld, %li, %lo, %lu, %lx: long versions of the above.    %lld, %lli, %llo, %llu, %llx: long long versions.    %wd, %wi, %wo, %wu, %wx: HOST_WIDE_INT versions.    %c: character.    %s: string.    %p: pointer.    %m: strerror(text->err_no) - does not consume a value from args_ptr.    %%: `%'.    %.*s: a substring the length of which is specified by an integer.    %H: location_t.  */
end_comment

begin_function
name|void
name|pp_base_format_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|text
operator|->
name|format_spec
condition|;
operator|++
name|text
operator|->
name|format_spec
control|)
block|{
name|int
name|precision
init|=
literal|0
decl_stmt|;
name|bool
name|wide
init|=
name|false
decl_stmt|;
comment|/* Ignore text.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|text
operator|->
name|format_spec
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
name|pp_wrap_text
argument_list|(
name|pp
argument_list|,
name|text
operator|->
name|format_spec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|text
operator|->
name|format_spec
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|text
operator|->
name|format_spec
operator|==
literal|'\0'
condition|)
break|break;
comment|/* We got a '%'.  Parse precision modifiers, if any.  */
switch|switch
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
condition|)
block|{
case|case
literal|'w'
case|:
name|wide
operator|=
name|true
expr_stmt|;
operator|++
name|text
operator|->
name|format_spec
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
do|do
operator|++
name|precision
expr_stmt|;
do|while
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|==
literal|'l'
condition|)
do|;
break|break;
default|default:
break|break;
block|}
comment|/* We don't support precision beyond that of "long long".  */
if|if
condition|(
name|precision
operator|>
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|text
operator|->
name|format_spec
condition|)
block|{
case|case
literal|'c'
case|:
name|pp_character
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|int
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"%"
name|HOST_WIDE_INT_PRINT
literal|"o"
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pp_pointer
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
name|xstrerror
argument_list|(
name|text
operator|->
name|err_no
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
block|{
specifier|const
name|location_t
modifier|*
name|locus
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|location_t
operator|*
argument_list|)
decl_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"file '"
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|locus
operator|->
name|file
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"', line "
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|pp
argument_list|,
name|locus
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* We handle no precision specifier but `%.*s'.  */
if|if
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|!=
literal|'*'
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|pp_format_decoder
argument_list|(
name|pp
argument_list|)
operator|||
operator|!
operator|(
operator|*
name|pp_format_decoder
argument_list|(
name|pp
argument_list|)
operator|)
operator|(
name|pp
operator|,
name|text
operator|)
condition|)
block|{
comment|/* Hmmm.  The client failed to install a format translator                  but called us with an unrecognized format.  Or, maybe, the                  translated string just contains an invalid format, or                  has formats in the wrong order.  Sorry.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper subroutine of output_verbatim and verbatim. Do the appropriate    settings needed by BUFFER for a verbatim formatting.  */
end_comment

begin_function
name|void
name|pp_base_format_verbatim
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
name|diagnostic_prefixing_rule_t
name|rule
init|=
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|int
name|line_cutoff
init|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
decl_stmt|;
comment|/* Set verbatim mode.  */
name|pp
operator|->
name|prefixing_rule
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
expr_stmt|;
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do the actual formatting.  */
name|pp_format_text
argument_list|(
name|pp
argument_list|,
name|text
argument_list|)
expr_stmt|;
comment|/* Restore previous settings.  */
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|=
name|rule
expr_stmt|;
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
name|line_cutoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the content of BUFFER onto the attached stream.  */
end_comment

begin_function
name|void
name|pp_base_flush
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_write_text_to_stream
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_clear_state
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the number of maximum characters per line PRETTY-PRINTER can    output in line-wrapping mode.  A LENGTH value 0 suppresses    line-wrapping.  */
end_comment

begin_function
name|void
name|pp_base_set_line_maximum_length
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
name|length
expr_stmt|;
name|pp_set_real_maximum_length
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear PRETTY-PRINTER output area text info.  */
end_comment

begin_function
name|void
name|pp_base_clear_output_area
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_free
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set PREFIX for PRETTY-PRINTER.  */
end_comment

begin_function
name|void
name|pp_base_set_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|pp
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|pp_set_real_maximum_length
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|emitted_prefix
operator|=
name|false
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free PRETTY-PRINTER's prefix, a previously malloc()'d string.  */
end_comment

begin_function
name|void
name|pp_base_destroy_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|prefix
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|pp
operator|->
name|prefix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out PRETTY-PRINTER's prefix.  */
end_comment

begin_function
name|void
name|pp_base_emit_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|prefix
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
condition|)
block|{
default|default:
case|case
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
case|:
break|break;
case|case
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
case|:
if|if
condition|(
name|pp
operator|->
name|emitted_prefix
condition|)
block|{
name|pp_base_indent
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
literal|3
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
case|:
block|{
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|pp
operator|->
name|prefix
argument_list|)
decl_stmt|;
name|pp_append_r
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|prefix
argument_list|,
name|prefix_length
argument_list|)
expr_stmt|;
name|pp
operator|->
name|emitted_prefix
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Construct a PRETTY-PRINTER with PREFIX and of MAXIMUM_LENGTH    characters per line.  */
end_comment

begin_function
name|void
name|pp_construct
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|maximum_length
parameter_list|)
block|{
name|memset
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_printer
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|output_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|stream
operator|=
name|stderr
expr_stmt|;
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
name|maximum_length
expr_stmt|;
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|pp_set_prefix
argument_list|(
name|pp
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a string delimited by START and END to the output area of    PRETTY-PRINTER.  No line wrapping is done.  However, if beginning a    new line then emit PRETTY-PRINTER's prefix and skip any leading    whitespace if appropriate.  The caller must ensure that it is    safe to do so.  */
end_comment

begin_function
name|void
name|pp_base_append_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
comment|/* Emit prefix and skip whitespace if we're starting a new line.  */
if|if
condition|(
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|==
literal|0
condition|)
block|{
name|pp_emit_prefix
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
condition|)
while|while
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
operator|++
name|start
expr_stmt|;
block|}
name|pp_append_r
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishes constructing a NULL-terminated character string representing    the PRETTY-PRINTED text.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pp_base_formatted_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text_data
argument_list|(
name|pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Return a pointer to the last character emitted in PRETTY-PRINTER's     output area.  A NULL pointer means no character available.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pp_base_last_position_in_text
parameter_list|(
specifier|const
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|obstack
modifier|*
name|text
init|=
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
decl_stmt|;
if|if
condition|(
name|obstack_base
argument_list|(
name|text
argument_list|)
operator|!=
name|obstack_next_free
argument_list|(
name|text
argument_list|)
condition|)
name|p
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|text
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of characters PRETTY-PRINTER can accept to    make a full line.  Meaningful only in line-wrapping mode.  */
end_comment

begin_function
name|int
name|pp_base_remaining_character_count_for_line
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
return|return
name|pp
operator|->
name|maximum_length
operator|-
name|pp
operator|->
name|buffer
operator|->
name|line_length
return|;
block|}
end_function

begin_comment
comment|/* Format a message into BUFFER a la printf.  */
end_comment

begin_function
name|void
name|pp_printf
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|msg
expr_stmt|;
name|pp_format_text
argument_list|(
name|pp
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output MESSAGE verbatim into BUFFER.  */
end_comment

begin_function
name|void
name|pp_verbatim
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|msg
expr_stmt|;
name|pp_format_verbatim
argument_list|(
name|pp
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have PRETTY-PRINTER start a new line.  */
end_comment

begin_function
name|void
name|pp_base_newline
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have PRETTY-PRINTER add a CHARACTER.  */
end_comment

begin_function
name|void
name|pp_base_character
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
operator|&&
name|pp_remaining_character_count_for_line
argument_list|(
name|pp
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
return|return;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|pp
operator|->
name|buffer
operator|->
name|line_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a STRING to the output area of PRETTY-PRINTER; the STRING may    be line-wrapped if in appropriate mode.  */
end_comment

begin_function
name|void
name|pp_base_string
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|pp_maybe_wrap_text
argument_list|(
name|pp
argument_list|,
name|str
argument_list|,
name|str
operator|+
operator|(
name|str
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

