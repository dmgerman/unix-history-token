begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler component interface functions.    Copyright (C) 2004 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@wasabisystems.com>.     This file is part of the libiberty library, which is part of GCC.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combined    executable.)     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements a few interface functions which are provided    for use with struct demangle_component trees.  These functions are    declared in demangle.h.  These functions are closely tied to the    demangler code in cp-demangle.c, and other interface functions can    be found in that file.  We put these functions in a separate file    because they are not needed by the demangler, and so we avoid    having them pulled in by programs which only need the    demangler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"cp-demangle.h"
end_include

begin_comment
comment|/* Fill in most component types.  */
end_comment

begin_function
name|int
name|cplus_demangle_fill_component
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|enum
name|demangle_component_type
name|type
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|left
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|right
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
case|case
name|DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
case|case
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_ARRAY_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_ARGLIST
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
case|:
case|case
name|DEMANGLE_COMPONENT_UNARY
case|:
case|case
name|DEMANGLE_COMPONENT_BINARY
case|:
case|case
name|DEMANGLE_COMPONENT_BINARY_ARGS
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG1
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG2
case|:
case|case
name|DEMANGLE_COMPONENT_LITERAL
case|:
case|case
name|DEMANGLE_COMPONENT_LITERAL_NEG
case|:
break|break;
comment|/* These component types only have one subtree.  */
case|case
name|DEMANGLE_COMPONENT_VTABLE
case|:
case|case
name|DEMANGLE_COMPONENT_VTT
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_FN
case|:
case|case
name|DEMANGLE_COMPONENT_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_VIRTUAL_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_COVARIANT_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_JAVA_CLASS
case|:
case|case
name|DEMANGLE_COMPONENT_GUARD
case|:
case|case
name|DEMANGLE_COMPONENT_REFTEMP
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
if|if
condition|(
name|right
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* Other types do not use subtrees.  */
return|return
literal|0
return|;
block|}
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_binary
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_binary
operator|.
name|right
operator|=
name|right
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_BUILTIN_TYPE.  */
end_comment

begin_function
name|int
name|cplus_demangle_fill_builtin_type
parameter_list|(
name|p
parameter_list|,
name|typename
parameter_list|)
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|typename
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|typename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_BUILTIN_TYPE_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|cplus_demangle_builtin_types
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|strcmp
argument_list|(
name|typename
argument_list|,
name|cplus_demangle_builtin_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|=
operator|&
name|cplus_demangle_builtin_types
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_OPERATOR.  */
end_comment

begin_function
name|int
name|cplus_demangle_fill_operator
parameter_list|(
name|p
parameter_list|,
name|opname
parameter_list|,
name|args
parameter_list|)
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|opname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cplus_demangle_operators
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|cplus_demangle_operators
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|args
operator|==
name|cplus_demangle_operators
index|[
name|i
index|]
operator|.
name|args
operator|&&
name|strcmp
argument_list|(
name|opname
argument_list|,
name|cplus_demangle_operators
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_OPERATOR
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|=
operator|&
name|cplus_demangle_operators
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate a mangled name into components.  */
end_comment

begin_function
name|struct
name|demangle_component
modifier|*
name|cplus_demangle_v3_components
parameter_list|(
name|mangled
parameter_list|,
name|options
parameter_list|,
name|mem
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|options
decl_stmt|;
name|void
modifier|*
modifier|*
name|mem
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|d_info
name|di
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
name|type
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|DMGL_TYPES
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|type
operator|=
literal|1
expr_stmt|;
block|}
name|cplus_demangle_init_info
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|,
name|len
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
name|di
operator|.
name|comps
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_comps
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|di
operator|.
name|subs
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_subs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|comps
operator|==
name|NULL
operator|||
name|di
operator|.
name|subs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|di
operator|.
name|comps
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|subs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
name|dc
operator|=
name|cplus_demangle_mangled_name
argument_list|(
operator|&
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|dc
operator|=
name|cplus_demangle_type
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
comment|/* If DMGL_PARAMS is set, then if we didn't consume the entire      mangled string, then we didn't successfully demangle it.  */
if|if
condition|(
operator|(
name|options
operator|&
name|DMGL_PARAMS
operator|)
operator|!=
literal|0
operator|&&
name|d_peek_char
argument_list|(
operator|&
name|di
argument_list|)
operator|!=
literal|'\0'
condition|)
name|dc
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|!=
name|NULL
condition|)
operator|*
name|mem
operator|=
name|di
operator|.
name|comps
expr_stmt|;
else|else
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
return|return
name|dc
return|;
block|}
end_function

end_unit

