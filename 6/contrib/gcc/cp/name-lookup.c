begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions for C++ name lookup routines.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"name-lookup.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_function_decl
specifier|static
name|cxx_scope
modifier|*
name|innermost_nonclass_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|select_decl
parameter_list|(
name|cxx_binding
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cxx_binding
modifier|*
name|binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|push_overloaded_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|lookup_using_namespace
parameter_list|(
name|tree
parameter_list|,
name|cxx_binding
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|qualified_lookup_using_namespace
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|cxx_binding
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_type_current_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|push_using_directive
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The :: namespace.  */
end_comment

begin_decl_stmt
name|tree
name|global_namespace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the anonymous namespace, throughout this translation    unit.  */
end_comment

begin_macro
name|GTY
argument_list|(
argument|()
argument_list|)
end_macro

begin_decl_stmt
name|tree
name|anonymous_namespace_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the chain index of a binding_entry given the HASH value of its    name and the total COUNT of chains.  COUNT is assumed to be a power    of 2.  */
end_comment

begin_define
define|#
directive|define
name|ENTRY_INDEX
parameter_list|(
name|HASH
parameter_list|,
name|COUNT
parameter_list|)
value|(((HASH)>> 3)& ((COUNT) - 1))
end_define

begin_comment
comment|/* A free list of "binding_entry"s awaiting for re-use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable(
literal|""
argument|))
argument_list|)
name|binding_entry
name|free_binding_entry
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create a binding_entry object for (NAME, TYPE).  */
end_comment

begin_function
specifier|static
specifier|inline
name|binding_entry
name|binding_entry_make
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|binding_entry
name|entry
decl_stmt|;
if|if
condition|(
name|free_binding_entry
condition|)
block|{
name|entry
operator|=
name|free_binding_entry
expr_stmt|;
name|free_binding_entry
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_entry_s
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Put ENTRY back on the free list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|binding_entry_free
parameter_list|(
name|binding_entry
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|free_binding_entry
expr_stmt|;
name|free_binding_entry
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The datatype used to implement the mapping from names to types at    a given scope.  */
end_comment

begin_decl_stmt
name|struct
name|binding_table_s
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Array of chains of "binding_entry"s  */
name|binding_entry
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.chain_count"
argument_list|)
operator|)
argument_list|)
name|chain
decl_stmt|;
comment|/* The number of chains in this table.  This is the length of the      the member "chain" considered as an array.  */
name|size_t
name|chain_count
decl_stmt|;
comment|/* Number of "binding_entry"s in this table.  */
name|size_t
name|entry_count
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Construct TABLE with an initial CHAIN_COUNT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|binding_table_construct
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|size_t
name|chain_count
parameter_list|)
block|{
name|table
operator|->
name|chain_count
operator|=
name|chain_count
expr_stmt|;
name|table
operator|->
name|entry_count
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|chain
operator|=
name|ggc_alloc_cleared
argument_list|(
name|table
operator|->
name|chain_count
operator|*
sizeof|sizeof
argument_list|(
name|binding_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make TABLE's entries ready for reuse.  */
end_comment

begin_function
specifier|static
name|void
name|binding_table_free
parameter_list|(
name|binding_table
name|table
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|count
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
name|table
operator|->
name|chain_count
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
name|temp
init|=
name|table
operator|->
name|chain
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|binding_entry
name|entry
init|=
name|temp
decl_stmt|;
name|temp
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
name|binding_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|chain
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|table
operator|->
name|entry_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */
end_comment

begin_function
specifier|static
specifier|inline
name|binding_table
name|binding_table_new
parameter_list|(
name|size_t
name|chain_count
parameter_list|)
block|{
name|binding_table
name|table
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_table_s
argument_list|)
argument_list|)
decl_stmt|;
name|table
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|binding_table_construct
argument_list|(
name|table
argument_list|,
name|chain_count
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Expand TABLE to twice its current chain_count.  */
end_comment

begin_function
specifier|static
name|void
name|binding_table_expand
parameter_list|(
name|binding_table
name|table
parameter_list|)
block|{
specifier|const
name|size_t
name|old_chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
specifier|const
name|size_t
name|old_entry_count
init|=
name|table
operator|->
name|entry_count
decl_stmt|;
specifier|const
name|size_t
name|new_chain_count
init|=
literal|2
operator|*
name|old_chain_count
decl_stmt|;
name|binding_entry
modifier|*
name|old_chains
init|=
name|table
operator|->
name|chain
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|binding_table_construct
argument_list|(
name|table
argument_list|,
name|new_chain_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_chain_count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
name|entry
init|=
name|old_chains
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|old_chains
index|[
name|i
index|]
control|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|entry
operator|->
name|name
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|j
init|=
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|new_chain_count
argument_list|)
decl_stmt|;
name|old_chains
index|[
name|i
index|]
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|table
operator|->
name|chain
index|[
name|j
index|]
expr_stmt|;
name|table
operator|->
name|chain
index|[
name|j
index|]
operator|=
name|entry
expr_stmt|;
block|}
block|}
name|table
operator|->
name|entry_count
operator|=
name|old_entry_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a binding for NAME to TYPE into TABLE.  */
end_comment

begin_function
specifier|static
name|void
name|binding_table_insert
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|i
init|=
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
decl_stmt|;
name|binding_entry
name|entry
init|=
name|binding_entry_make
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|entry
operator|->
name|chain
operator|=
name|table
operator|->
name|chain
index|[
name|i
index|]
expr_stmt|;
name|table
operator|->
name|chain
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
operator|++
name|table
operator|->
name|entry_count
expr_stmt|;
if|if
condition|(
literal|3
operator|*
name|table
operator|->
name|chain_count
operator|<
literal|5
operator|*
name|table
operator|->
name|entry_count
condition|)
name|binding_table_expand
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the binding_entry, if any, that maps NAME.  */
end_comment

begin_function
name|binding_entry
name|binding_table_find
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|binding_entry
name|entry
init|=
name|table
operator|->
name|chain
index|[
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|name
operator|!=
name|name
condition|)
name|entry
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Return the binding_entry, if any, that maps NAME to an anonymous type.  */
end_comment

begin_function
specifier|static
name|tree
name|binding_table_find_anon_type
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|binding_entry
name|entry
init|=
name|table
operator|->
name|chain
index|[
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|entry
operator|->
name|type
argument_list|)
operator|!=
name|name
condition|)
name|entry
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
return|return
name|entry
condition|?
name|entry
operator|->
name|type
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the binding_entry, if any, that has TYPE as target.  If NAME    is non-null, then set the domain and rehash that entry.  */
end_comment

begin_function
specifier|static
name|binding_entry
name|binding_table_reverse_maybe_remap
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
specifier|const
name|size_t
name|chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
name|binding_entry
name|entry
init|=
name|NULL
decl_stmt|;
name|binding_entry
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain_count
operator|&&
name|entry
operator|==
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|table
operator|->
name|chain
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|NULL
operator|&&
name|entry
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
operator|==
name|type
condition|)
name|entry
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|chain
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|name
operator|!=
name|name
condition|)
block|{
comment|/* Remove the bucket from the previous chain.  */
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|chain
expr_stmt|;
comment|/* Remap the name type to type.  */
name|i
operator|=
name|ENTRY_INDEX
argument_list|(
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|chain_count
argument_list|)
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|table
operator|->
name|chain
index|[
name|i
index|]
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|table
operator|->
name|chain
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Remove from TABLE all entries that map to anonymous enums or    class-types.  */
end_comment

begin_function
name|void
name|binding_table_remove_anonymous_types
parameter_list|(
name|binding_table
name|table
parameter_list|)
block|{
specifier|const
name|size_t
name|chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain_count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
modifier|*
name|p
init|=
operator|&
name|table
operator|->
name|chain
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|NULL
condition|)
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|binding_entry
name|e
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|chain
expr_stmt|;
operator|--
name|table
operator|->
name|entry_count
expr_stmt|;
name|binding_entry_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|chain
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply PROC -- with DATA -- to all entries in TABLE.  */
end_comment

begin_function
name|void
name|binding_table_foreach
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|bt_foreach_proc
name|proc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|size_t
name|chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain_count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
name|entry
init|=
name|table
operator|->
name|chain
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|chain
control|)
name|proc
argument_list|(
name|entry
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ENABLE_SCOPE_CHECKING
end_ifndef

begin_define
define|#
directive|define
name|ENABLE_SCOPE_CHECKING
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENABLE_SCOPE_CHECKING
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A free list of "cxx_binding"s, connected by their PREVIOUS.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
name|cxx_binding
operator|*
name|free_bindings
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Zero out a cxx_binding pointed to by B.  */
end_comment

begin_define
define|#
directive|define
name|cxx_binding_clear
parameter_list|(
name|B
parameter_list|)
value|memset ((B), 0, sizeof (cxx_binding))
end_define

begin_comment
comment|/* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|cxx_binding_make
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|free_bindings
condition|)
block|{
name|binding
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cxx_binding
argument_list|)
argument_list|)
expr_stmt|;
name|binding
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|binding
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|binding
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
return|return
name|binding
return|;
block|}
end_function

begin_comment
comment|/* Put BINDING back on the free list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cxx_binding_free
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|)
block|{
name|binding
operator|->
name|scope
operator|=
name|NULL
expr_stmt|;
name|binding
operator|->
name|previous
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make DECL the innermost binding for ID.  The LEVEL is the binding    level at which this declaration is being bound.  */
end_comment

begin_function
specifier|static
name|void
name|push_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|level
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|cxx_binding_make
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Now, fill in the binding information.  */
name|binding
operator|->
name|previous
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|binding
operator|->
name|scope
operator|=
name|level
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOCAL_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
operator|(
name|level
operator|!=
name|class_binding_level
operator|)
expr_stmt|;
comment|/* And put it on the front of the list of bindings for ID.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the binding for DECL which should be the innermost binding    for ID.  */
end_comment

begin_function
name|void
name|pop_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
comment|/* It's easiest to write the loops that call this function without        checking whether or not the entities involved have names.  We        get here for such an entity.  */
return|return;
comment|/* Get the innermost binding for ID.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* The name should be bound.  */
name|my_friendly_assert
argument_list|(
name|binding
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The DECL will be either the ordinary binding or the type      binding for this identifier.  Remove that binding.  */
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
condition|)
name|binding
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
operator|->
name|type
operator|==
name|decl
condition|)
name|binding
operator|->
name|type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|binding
operator|->
name|value
operator|&&
operator|!
name|binding
operator|->
name|type
condition|)
block|{
comment|/* We're completely done with the innermost binding for this 	 identifier.  Unhook it from the list of bindings.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
comment|/* Add it to the free list.  */
name|cxx_binding_free
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BINDING records an existing declaration for a namein the current scope.    But, DECL is another declaration for that same identifier in the    same scope.  This is the `struct stat' hack whereby a non-typedef    class name or enum-name can be bound at the same level as some other    kind of entity.    3.3.7/1       A class name (9.1) or enumeration name (7.2) can be hidden by the      name of an object, function, or enumerator declared in the same scope.      If a class or enumeration name and an object, function, or enumerator      are declared in the same scope (in any order) with the same name, the      class or enumeration name is hidden wherever the object, function, or      enumerator name is visible.     It's the responsibility of the caller to check that    inserting this name is valid here.  Returns nonzero if the new binding    was successful.  */
end_comment

begin_function
specifier|static
name|bool
name|supplement_binding
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|bval
init|=
name|binding
operator|->
name|value
decl_stmt|;
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The new name is the type name.  */
name|binding
operator|->
name|type
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
comment|/* BVAL is null when push_class_level_binding moves an 	      inherited type-binding out of the way to make room for a 	      new value binding.  */
operator|!
name|bval
comment|/* BVAL is error_mark_node when DECL's name has been used 	      in a non-class scope prior declaration.  In that case, 	      we should have already issued a diagnostic; for graceful 	      error recovery purpose, pretend this was the intended 	      declaration for that name.  */
operator|||
name|bval
operator|==
name|error_mark_node
comment|/* If BVAL is a built-in that has not yet been declared, 	      pretend it is not there at all.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|bval
argument_list|)
operator|)
condition|)
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|bval
argument_list|)
condition|)
block|{
comment|/* The old binding was a type name.  It was placed in 	 VALUE field because it was thought, at the point it was 	 declared, to be the only entity with such a name.  Move the 	 type name into the type slot; it is now hidden by the new 	 binding.  */
name|binding
operator|->
name|type
operator|=
name|bval
expr_stmt|;
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
name|binding
operator|->
name|value_is_inherited
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|bval
argument_list|)
operator|&&
operator|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|bval
argument_list|)
argument_list|)
comment|/* If either type involves template parameters, we must 		  wait until instantiation.  */
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|bval
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* We have two typedef-names, both naming the same type to have        the same name.  This is OK because of:           [dcl.typedef]  	 In a given scope, a typedef specifier can be used to redefine 	 the name of any type declared in that scope to refer to the 	 type to which it already refers.  */
name|ok
operator|=
name|false
expr_stmt|;
comment|/* There can be two block-scope declarations of the same variable,      so long as they are `extern' declarations.  However, there cannot      be two declarations of the same static data member:         [class.mem]         A member shall not be declared twice in the        member-specification.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|bval
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|binding
operator|->
name|value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|bval
argument_list|)
operator|&&
name|ORIGINAL_NAMESPACE
argument_list|(
name|bval
argument_list|)
operator|==
name|ORIGINAL_NAMESPACE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* [namespace.alias]               In a declarative region, a namespace-alias-definition can be       used to redefine a namespace-alias declared in that declarative       region to refer only to the namespace to which it already       refers.  */
name|ok
operator|=
name|false
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|bval
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add DECL to the list of things declared in B.  */
end_comment

begin_function
specifier|static
name|void
name|add_decl_to_level
parameter_list|(
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
operator|!
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|namespaces
expr_stmt|;
name|b
operator|->
name|namespaces
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|vtables
expr_stmt|;
name|b
operator|->
name|vtables
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* We build up the list in reverse order, and reverse it later if          necessary.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|decl
expr_stmt|;
name|b
operator|->
name|names_size
operator|++
expr_stmt|;
comment|/* If appropriate, add decl to separate list of statics.  We 	 include extern variables because they might turn out to be  	 static later.  It's OK for this list to contain a few false 	 positives. */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_namespace
condition|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|b
operator|->
name|static_decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|need_new_binding
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|need_new_binding
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Template parameters have no context; they are not X::T even        when declared within a class or namespace.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
comment|/* A local declaration for a function doesn't constitute              nesting.  */
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
comment|/* A local declaration for an `extern' variable is in the 	     scope of the current namespace, not the current 	     function.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If this is the declaration for a namespace-scope function, 	 but the declaration itself is in a local scope, mark the 	 declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
condition|)
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|different_binding_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
condition|)
name|check_default_args
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In case this decl was explicitly namespace-qualified, look it 	 up in its namespace context.  */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* [basic.link] If there is a visible declaration of an entity 	 with linkage having the same name and type, ignoring entities 	 declared outside the innermost enclosing namespace scope, the 	 block scope declaration declares that same entity and 	 receives the linkage of the previous declaration.  */
if|if
condition|(
operator|!
name|t
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Look in block scope.  */
name|t
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Or in the innermost namespace.  */
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does it have linkage?  Note that if this isn't a DECL, it's an 	     OVERLOAD, which is OK.  */
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|different_binding_level
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are declaring a function, and the result of name-lookup 	 was an OVERLOAD, look for an overloaded instance that is 	 actually the same as the function we are declaring.  (If 	 there is one, we have to merge our declaration with the 	 previous declaration.)  */
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|tree
name|match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
for|for
control|(
name|match
operator|=
name|t
init|;
name|match
condition|;
name|match
operator|=
name|OVL_NEXT
argument_list|(
name|match
argument_list|)
control|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
break|break;
block|}
else|else
comment|/* Just choose one.  */
name|match
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
comment|/* error_mark_node is 0 for a while during initialization!  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"`%#D' used prior to declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|different_binding_level
condition|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
comment|/* The standard only says that the local extern 		   inherits linkage from the previous decl; in 		   particular, default args are not shared.  It would 		   be nice to propagate inlining info, though.  FIXME.  */
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* This is probably caused by too many errors, but calling 		   abort will say that if errors have occurred.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for duplicate params.  */
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Don't do anything just yet.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|wchar_decl_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"redeclaration of `wchar_t' as `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Throw away the redeclaration.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|olddecl
init|=
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|/* If the redeclaration failed, we can stop at this 		 point.  */
if|if
condition|(
name|olddecl
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* A redeclaration of main, but not a duplicate of the 		     previous one. 		      		     [basic.start.main] 		      		     This function shall not be overloaded.  */
name|cp_error_at
argument_list|(
literal|"invalid redeclaration of `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"as `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We don't try to push this declaration since that 		     causes a crash.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a function conjured up by the backend, massage it 	 so it looks friendly.  */
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|retrofit_lang_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|x
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|x
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namespace_bindings_p
argument_list|()
condition|)
comment|/* We do not need to create a binding for this name; 	       push_overloaded_decl will have already done so if 	       necessary.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|x
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If declaring a type as a typedef, copy the type (unless we're 	 at line 0), and install this TYPE_DECL as the new type's typedef 	 name.  See the extensive comment in ../c-decl.c (pushdecl).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|x
comment|/* We don't want to copy the type when all we're 		      doing is making a TYPE_DECL for the purposes of 		      inlining.  */
operator|&&
operator|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Multiple external decls of the same identifier ought to match.  	 We get warnings about inline functions where they are defined. 	 We get warnings about other functions from push_overloaded_decl.  	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_FUNCTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* If different sort of thing, we already gave an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"type mismatch with previous external decl of `%#D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous external decl of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Bind the name for the entity.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ALIAS_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`%D' was previously implicitly declared to return `int'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If new decl is `static' and an `extern' was seen previously, 	     warn about it.  */
if|if
condition|(
name|x
operator|!=
name|NULL_TREE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|warn_extern_redeclared_static
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_new_binding
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because push_local_binding will hook X on to the 		 current_binding_level's name list, we don't want to 		 do that again below.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a TYPE_DECL, push it into the type value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Clear out any TYPE_DECL shadowed by a namespace so that 	     we won't think this is a type.  The C struct hack doesn't 	     go through namespaces.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
condition|)
block|{
name|tree
name|d
init|=
name|oldlocal
decl_stmt|;
while|while
condition|(
name|oldlocal
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
name|oldlocal
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|oldlocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
condition|)
name|oldlocal
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|oldglobal
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"extern declaration of `%#D' doesn't match"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"global declaration `%#D'"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* Inline decls shadow nothing.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
comment|/* Don't check the `this' parameter.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
block|{
name|bool
name|err
init|=
name|false
decl_stmt|;
comment|/* Don't complain if it's from an enclosing function.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we find 		     them there.  */
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
comment|/* Skip the ctor/dtor cleanup level.  */
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_function_parms
condition|)
block|{
name|error
argument_list|(
literal|"declaration of '%#D' shadows a parameter"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|err
condition|)
block|{
name|warning
argument_list|(
literal|"declaration of '%#D' shadows a parameter"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|current_class_ptr
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Location of previous decl is not useful in this case.  */
name|warning
argument_list|(
literal|"declaration of '%D' shadows a member of 'this'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"declaration of '%D' shadows a previous local"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|VAR_DECL
condition|)
comment|/* XXX shadow warnings in outer-more namespaces */
block|{
name|warning
argument_list|(
literal|"declaration of '%D' shadows a global declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_register_incomplete_var
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_new_binding
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|?
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|current_binding_level
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter DECL into the symbol table, if that's appropriate.  Returns    DECL, or a modified version thereof.  */
end_comment

begin_function
name|tree
name|maybe_push_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Add this decl to the current binding level, but not if it comes      from another scope, e.g. a static member variable.  TEM may equal      DECL or it may be a previous decl of the same name.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* Definitions of namespace members outside their namespace are 	     possible.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|namespace_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNKNOWN_TYPE
comment|/* The declaration of a template specialization does not affect 	 the functions available for overload resolution, so we do not 	 call pushdecl.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|decl
return|;
else|else
return|return
name|pushdecl
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the current_binding_level, assumed to be a local    binding level.  If PUSH_USING is set in FLAGS, we know that DECL    doesn't really belong to this binding level, that it got here    through a using-declaration.  */
end_comment

begin_function
name|void
name|push_local_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Skip over any local classes.  This makes sense if we call      push_local_binding with a friend decl of a local class.  */
name|b
operator|=
name|innermost_nonclass_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookup_name_current_level
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* Supplement the existing binding.  */
if|if
condition|(
operator|!
name|supplement_binding
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
argument_list|,
name|decl
argument_list|)
condition|)
comment|/* It didn't work.  Something else must be bound at this 	   level.  Do not add DECL to the list of things to pop 	   later.  */
return|return;
block|}
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
comment|/* We must put the OVERLOAD into a TREE_LIST since the        TREE_CHAIN of an OVERLOAD is already used.  Similarly for        decls that got here through a using-declaration.  */
name|decl
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* And put DECL on the list of things declared by the current      binding level.  */
name|add_decl_to_level
argument_list|(
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The old ARM scoping rules injected variables declared in the    initialization statement of a for-statement into the surrounding    scope.  We support this usage, in order to be backward-compatible.    DECL is a just-declared VAR_DECL; if necessary inject its    declaration into the surrounding scope.  */
end_comment

begin_function
name|void
name|maybe_inject_for_scope_var
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Declarations of __FUNCTION__ and its ilk appear magically when      the variable is first used.  If that happens to be inside a      for-loop, we don't want to do anything special.  */
if|if
condition|(
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_for
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|outer
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
comment|/* Check to see if the same name is already bound at the outer 	 level, either because it was directly declared, or because a 	 dead for-decl got preserved.  In either case, the code would 	 not have been valid under the ARM scope rules, so clear 	 is_for_scope for the current_binding_level.  	 Otherwise, we need to preserve the temp slot for decl to last 	 into the outer binding level.  */
name|cxx_binding
modifier|*
name|outer_binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|->
name|previous
decl_stmt|;
if|if
condition|(
name|outer_binding
operator|&&
name|outer_binding
operator|->
name|scope
operator|==
name|outer
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|outer_binding
operator|->
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|outer_binding
operator|->
name|value
argument_list|)
condition|)
block|{
name|outer_binding
operator|->
name|value
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|outer_binding
operator|->
name|value
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|kind
operator|=
name|sk_block
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see whether or not DECL is a variable that would have been    in scope under the ARM, but is not in scope under the ANSI/ISO    standard.  If so, issue an error message.  If name lookup would    work in both cases, but return a different result, this function    returns the result of ANSI/ISO lookup.  Otherwise, it returns    DECL.  */
end_comment

begin_function
name|tree
name|check_for_out_of_scope_variable
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|shadowed
decl_stmt|;
comment|/* We only care about out of scope variables.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|decl
return|;
name|shadowed
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|shadowed
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|shadowed
argument_list|)
condition|)
name|shadowed
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shadowed
condition|)
name|shadowed
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadowed
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"name lookup of `%D' changed"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  matches this `%D' under ISO standard rules"
argument_list|,
name|shadowed
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  matches this `%D' under old rules"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|shadowed
return|;
block|}
comment|/* If we have already complained about this declaration, there's no      need to do it again.  */
if|if
condition|(
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|decl
return|;
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"name lookup of `%D' changed for new ISO `for' scoping"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  cannot use obsolete binding at `%D' because it has a destructor"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"name lookup of `%D' changed for new ISO `for' scoping"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  using obsolete binding at `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* true means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|binding_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_class_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|indent
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string describing the kind of SCOPE we have.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cxx_scope_descriptor
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|)
block|{
comment|/* The order of this table must match the "scope_kind"      enumerators.  */
specifier|static
specifier|const
name|char
modifier|*
name|scope_kind_names
index|[]
init|=
block|{
literal|"block-scope"
block|,
literal|"cleanup-scope"
block|,
literal|"try-scope"
block|,
literal|"catch-scope"
block|,
literal|"for-scope"
block|,
literal|"function-parameter-scope"
block|,
literal|"class-scope"
block|,
literal|"namespace-scope"
block|,
literal|"template-parameter-scope"
block|,
literal|"template-explicit-spec-scope"
block|}
decl_stmt|;
specifier|const
name|scope_kind
name|kind
init|=
name|scope
operator|->
name|explicit_spec_p
condition|?
name|sk_template_spec
else|:
name|scope
operator|->
name|kind
decl_stmt|;
return|return
name|scope_kind_names
index|[
name|kind
index|]
return|;
block|}
end_function

begin_comment
comment|/* Output a debugging information about SCOPE when performing    ACTION at LINE.  */
end_comment

begin_function
specifier|static
name|void
name|cxx_scope_debug
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|action
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|desc
init|=
name|cxx_scope_descriptor
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|->
name|this_entity
condition|)
name|verbatim
argument_list|(
literal|"%s %s(%E) %p %d\n"
argument_list|,
name|action
argument_list|,
name|desc
argument_list|,
name|scope
operator|->
name|this_entity
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scope
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|verbatim
argument_list|(
literal|"%s %s %p %d\n"
argument_list|,
name|action
argument_list|,
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scope
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the estimated initial size of the hashtable of a NAMESPACE    scope.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|namespace_scope_ht_size
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|ns
argument_list|)
decl_stmt|;
return|return
name|name
operator|==
name|std_identifier
condition|?
name|NAMESPACE_STD_HT_SIZE
else|:
operator|(
name|name
operator|==
name|global_scope_name
condition|?
name|GLOBAL_SCOPE_HT_SIZE
else|:
name|NAMESPACE_ORDINARY_HT_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
expr|struct
name|cp_binding_level
operator|*
name|free_binding_level
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create a new KIND scope and make it the top of the active scopes stack.    ENTITY is the scope of the associated C++ entity (namespace, class,    function); it is NULL otherwise.  */
end_comment

begin_function
name|cxx_scope
modifier|*
name|begin_scope
parameter_list|(
name|scope_kind
name|kind
parameter_list|,
name|tree
name|entity
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|scope
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
operator|!
name|ENABLE_SCOPE_CHECKING
operator|&&
name|free_binding_level
condition|)
block|{
name|scope
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|scope
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cxx_scope
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|scope
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cxx_scope
argument_list|)
argument_list|)
expr_stmt|;
name|scope
operator|->
name|this_entity
operator|=
name|entity
expr_stmt|;
name|scope
operator|->
name|more_cleanups_ok
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|sk_cleanup
case|:
name|scope
operator|->
name|keep
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|sk_template_spec
case|:
name|scope
operator|->
name|explicit_spec_p
operator|=
name|true
expr_stmt|;
name|kind
operator|=
name|sk_template_parms
expr_stmt|;
comment|/* Fall through.  */
case|case
name|sk_template_parms
case|:
case|case
name|sk_block
case|:
case|case
name|sk_try
case|:
case|case
name|sk_catch
case|:
case|case
name|sk_for
case|:
case|case
name|sk_class
case|:
case|case
name|sk_function_parms
case|:
name|scope
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
break|break;
case|case
name|sk_namespace
case|:
name|scope
operator|->
name|type_decls
operator|=
name|binding_table_new
argument_list|(
name|namespace_scope_ht_size
argument_list|(
name|entity
argument_list|)
argument_list|)
expr_stmt|;
name|NAMESPACE_LEVEL
argument_list|(
name|entity
argument_list|)
operator|=
name|scope
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|scope
operator|->
name|static_decls
argument_list|,
name|DECL_NAME
argument_list|(
name|entity
argument_list|)
operator|==
name|std_identifier
operator|||
name|DECL_NAME
argument_list|(
name|entity
argument_list|)
operator|==
name|global_scope_name
condition|?
literal|200
else|:
literal|10
argument_list|,
literal|"Static declarations"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Should not happen.  */
name|my_friendly_assert
argument_list|(
name|false
argument_list|,
literal|20030922
argument_list|)
expr_stmt|;
break|break;
block|}
name|scope
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
comment|/* Add it to the front of currently active scopes stack.  */
name|scope
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|scope
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|scope
argument_list|,
name|input_location
operator|.
name|line
argument_list|,
literal|"push"
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
block|}
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* We're about to leave current scope.  Pop the top of the stack of    currently active scopes.  Return the enclosing scope, now active.  */
end_comment

begin_function
name|cxx_scope
modifier|*
name|leave_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|scope
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_namespace
operator|&&
name|class_binding_level
condition|)
name|current_binding_level
operator|=
name|class_binding_level
expr_stmt|;
comment|/* We cannot leave a scope, if there are none left.  */
if|if
condition|(
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
operator|!
name|global_scope_p
argument_list|(
name|scope
argument_list|)
argument_list|,
literal|20030527
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|indent
argument_list|(
operator|--
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|scope
argument_list|,
name|input_location
operator|.
name|line
argument_list|,
literal|"leave"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|scope
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|verbatim
argument_list|(
literal|"XXX is_class_level != (current_scope == class_scope)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Move one nesting level up.  */
name|current_binding_level
operator|=
name|scope
operator|->
name|level_chain
expr_stmt|;
comment|/* Namespace-scopes are left most probably temporarily, not completely;      they can be reopen later, e.g. in namespace-extension or any name      binding activity that requires us to resume a namespace.  For other      scopes, we just make the structure available for reuse.  */
if|if
condition|(
name|scope
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
block|{
name|scope
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|scope
operator|->
name|type_decls
operator|=
name|NULL
expr_stmt|;
else|else
name|binding_table_free
argument_list|(
name|scope
operator|->
name|type_decls
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|ENABLE_SCOPE_CHECKING
operator|||
name|scope
operator|->
name|binding_depth
operator|==
name|binding_depth
argument_list|,
literal|20030529
argument_list|)
expr_stmt|;
name|free_binding_level
operator|=
name|scope
expr_stmt|;
block|}
comment|/* Find the innermost enclosing class scope, and reset      CLASS_BINDING_LEVEL appropriately.  */
for|for
control|(
name|scope
operator|=
name|current_binding_level
init|;
name|scope
operator|&&
name|scope
operator|->
name|kind
operator|!=
name|sk_class
condition|;
name|scope
operator|=
name|scope
operator|->
name|level_chain
control|)
empty_stmt|;
name|class_binding_level
operator|=
name|scope
operator|&&
name|scope
operator|->
name|kind
operator|==
name|sk_class
condition|?
name|scope
else|:
name|NULL
expr_stmt|;
return|return
name|current_binding_level
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_scope
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|b
parameter_list|)
block|{
comment|/* Resuming binding levels is meant only for namespaces,      and those cannot nest into classes.  */
name|my_friendly_assert
argument_list|(
operator|!
name|class_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
comment|/* Also, resuming a non-directly nested namespace is a no-no.  */
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|==
name|current_binding_level
argument_list|,
literal|386
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|b
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|b
argument_list|,
name|input_location
operator|.
name|line
argument_list|,
literal|"resume"
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the innermost binding level that is not for a class scope.  */
end_comment

begin_function
specifier|static
name|cxx_scope
modifier|*
name|innermost_nonclass_level
parameter_list|(
name|void
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* We're defining an object of type TYPE.  If it needs a cleanup, but    we're not allowed to add any more objects with cleanups to the current    scope, create a new binding level.  */
end_comment

begin_function
name|void
name|maybe_push_cleanup_level
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
block|{
name|begin_scope
argument_list|(
name|sk_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|global_scope_p
argument_list|(
name|current_binding_level
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True if we are currently in a toplevel binding level.  This    means either the global binding level or a namespace in a toplevel    binding level.  Since there are no non-toplevel namespace levels,    this really means any namespace or template parameter level.  We    also include a class whose context is toplevel.  */
end_comment

begin_function
name|bool
name|toplevel_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|kind
operator|==
name|sk_namespace
operator|||
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
return|;
block|}
end_function

begin_comment
comment|/* True if this is a namespace scope, or if we are defining a class    which is itself at namespace scope, or whose enclosing class is    such a class, etc.  */
end_comment

begin_function
name|bool
name|namespace_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|kind
operator|==
name|sk_namespace
return|;
block|}
end_function

begin_comment
comment|/* True if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|bool
name|kept_level_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_cleanup
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|type_decls
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of the innermost scope.  */
end_comment

begin_function
name|scope_kind
name|innermost_scope_kind
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_binding_level
operator|->
name|kind
return|;
block|}
end_function

begin_comment
comment|/* Returns true if this scope was created to store template parameters.  */
end_comment

begin_function
name|bool
name|template_parm_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|innermost_scope_kind
argument_list|()
operator|==
name|sk_template_parms
return|;
block|}
end_function

begin_comment
comment|/* If KEEP is true, make a BLOCK node for the next binding level,    unconditionally.  Otherwise, use the normal logic to decide whether    or not to create a BLOCK.  */
end_comment

begin_function
name|void
name|keep_next_level
parameter_list|(
name|bool
name|keep
parameter_list|)
block|{
name|keep_next_level_flag
operator|=
name|keep
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Set the current binding TABLE for type declarations..  This is a    temporary workaround of the fact that the data structure classtypes    does not currently carry its allocated cxx_scope structure.  */
end_comment

begin_function
name|void
name|cxx_remember_type_decls
parameter_list|(
name|binding_table
name|table
parameter_list|)
block|{
name|current_binding_level
operator|->
name|type_decls
operator|=
name|table
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from print_binding_level through binding_table_foreach to    print the content of binding ENTRY.  DATA is a pointer to line offset    marker.  */
end_comment

begin_function
specifier|static
name|void
name|bt_print_entry
parameter_list|(
name|binding_entry
name|entry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|name
operator|==
name|NULL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|entry
operator|->
name|type
argument_list|)
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
operator|*
name|p
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<unnamed-typedef"
argument_list|,
name|entry
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|entry
operator|->
name|type
argument_list|)
condition|)
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<typedef"
argument_list|,
name|entry
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_level
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|lvl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks="
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"<built-in>"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_decls
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tags:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|binding_table_foreach
argument_list|(
name|lvl
operator|->
name|type_decls
argument_list|,
name|bt_print_entry
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|class_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
operator|!
name|global_scope_p
argument_list|(
name|level
argument_list|)
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level "
name|HOST_PTR_PRINTF
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|level
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level="
name|HOST_PTR_PRINTF
literal|"\nclass_binding_level="
name|HOST_PTR_PRINTF
literal|"\nNAMESPACE_LEVEL (global_namespace)="
name|HOST_PTR_PRINTF
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_binding_level
argument_list|,
operator|(
name|void
operator|*
operator|)
name|class_binding_level
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type associated with id.  */
end_comment

begin_function
name|tree
name|identifier_type_value
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* There is no type with that name, anywhere.  */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This is not the type marker, but the real thing.  */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|!=
name|global_type_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have to search for it. It must be on the global level, now.      Ask lookup_name not to return non-types.  */
name|id
operator|=
name|lookup_name_real
argument_list|(
name|id
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a definition of struct, union or enum tag named ID.  into    binding_level B.  DECL is a TYPE_DECL for the type.  We assume that    the tag ID is not already defined.  */
end_comment

begin_function
specifier|static
name|void
name|set_identifier_type_value_with_scope
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
block|{
comment|/* Shadow the marker, not the real thing, so that the marker 	 gets restored later.  */
name|tree
name|old_type_value
init|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|b
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
name|type
operator|=
name|decl
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|supplement_binding
argument_list|(
name|binding
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Store marker instead of real type.  */
name|type
operator|=
name|global_type_node
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As set_identifier_type_value_with_scope, but using    current_binding_level.  */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|set_identifier_type_value_with_scope
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name for the constructor (or destructor) for the    specified class TYPE.  When given a template, this routine doesn't    lose the specialization.  */
end_comment

begin_function
name|tree
name|constructor_name_full
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name for the constructor (or destructor) for the    specified class.  When given a template, return the plain    unspecialized name.  */
end_comment

begin_function
name|tree
name|constructor_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|name
operator|=
name|constructor_name_full
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if NAME is the name for the constructor for TYPE.  */
end_comment

begin_function
name|bool
name|constructor_name_p
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|ctor_name
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
name|false
return|;
name|ctor_name
operator|=
name|constructor_name_full
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|ctor_name
condition|)
return|return
name|true
return|;
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|ctor_name
argument_list|)
operator|&&
name|name
operator|==
name|IDENTIFIER_TEMPLATE
argument_list|(
name|ctor_name
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|anon_cnt
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the TREE_PURPOSE slot of UTDs which have anonymous typenames.    This keeps dbxout from getting confused.  */
end_comment

begin_function
name|void
name|clear_anon_tags
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
specifier|static
name|int
name|last_cnt
init|=
literal|0
decl_stmt|;
comment|/* Fast out if no new anon names were declared.  */
if|if
condition|(
name|last_cnt
operator|==
name|anon_cnt
condition|)
return|return;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type_decls
operator|!=
name|NULL
condition|)
name|binding_table_remove_anonymous_types
argument_list|(
name|b
operator|->
name|type_decls
argument_list|)
expr_stmt|;
name|last_cnt
operator|=
name|anon_cnt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cxx_binding
modifier|*
name|find_binding
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|cxx_binding
modifier|*
name|binding
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|binding
operator|!=
name|NULL
condition|;
name|binding
operator|=
name|binding
operator|->
name|previous
control|)
if|if
condition|(
name|binding
operator|->
name|scope
operator|==
name|scope
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
operator|(
name|cxx_binding
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cxx_binding
modifier|*
name|cxx_scope_find_binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
comment|/* Fold-in case where NAME is used only once.  */
if|if
condition|(
name|scope
operator|==
name|b
operator|->
name|scope
operator|&&
name|b
operator|->
name|previous
operator|==
name|NULL
condition|)
return|return
name|b
return|;
return|return
name|find_binding
argument_list|(
name|scope
argument_list|,
name|b
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Always returns a binding for name in scope.  If no binding is    found, make a new one.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* Not found, make a new one.  */
name|result
operator|=
name|cxx_binding_make
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|->
name|previous
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|result
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
name|result
operator|->
name|is_local
operator|=
name|false
expr_stmt|;
name|result
operator|->
name|value_is_inherited
operator|=
name|false
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Insert another USING_DECL into the current binding level, returning    this declaration. If this is a redeclaration, do nothing, and    return NULL_TREE if this not in namespace scope (in namespace    scope, a using decl might extend any previous bindings).  */
end_comment

begin_function
name|tree
name|push_using_decl
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|383
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|384
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|usings
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|scope
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|decl
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|namespace_bindings_p
argument_list|()
condition|?
name|decl
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|scope
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|usings
expr_stmt|;
name|current_binding_level
operator|->
name|usings
operator|=
name|decl
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the    caller to set DECL_CONTEXT properly.  */
end_comment

begin_function
name|tree
name|pushdecl_with_scope
parameter_list|(
name|tree
name|x
parameter_list|,
name|cxx_scope
modifier|*
name|level
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|function_decl
init|=
name|current_function_decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|b
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
name|level
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|level
expr_stmt|;
name|x
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|function_decl
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL for a non-member function, which may have    other definitions already in place.  We get around this by making    the value of the identifier point to a list of all the things that    want to be referenced by that name.  It is then up to the users of    that name to decide what to do with that list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its    DECL_TEMPLATE_RESULT.  It is dealt with the same way.     FLAGS is a bitwise-or of the following values:      PUSH_LOCAL: Bind DECL in the current scope, rather than at                  namespace scope.      PUSH_USING: DECL is being pushed as the result of a using                  declaration.     The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
specifier|static
name|tree
name|push_overloaded_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|tree
name|new_binding
decl_stmt|;
name|int
name|doing_global
init|=
operator|(
name|namespace_bindings_p
argument_list|()
operator|||
operator|!
operator|(
name|flags
operator|&
name|PUSH_LOCAL
operator|)
operator|)
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|old
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|warn_shadow
operator|&&
operator|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|old
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"`%#D' hides constructor for `%#T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|old
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|OVL_USED
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|decls_match
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%#D' conflicts with previous using declaration `%#D'"
argument_list|,
name|decl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|)
operator|==
name|fn
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|old
operator|==
name|error_mark_node
condition|)
comment|/* Ignore the undefined symbol marker.  */
name|old
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous non-function declaration `%#D'"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with function declaration `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
comment|/* If it's a using declaration, we always need to build an OVERLOAD, 	 because it's the only way to remember that the declaration comes 	 from 'using', and have the lookup behave correctly.  */
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
block|{
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|ovl_cons
argument_list|(
name|old
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PUSH_USING
condition|)
name|OVL_USED
argument_list|(
name|new_binding
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* NAME is not ambiguous.  */
name|new_binding
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|set_namespace_binding
argument_list|(
name|name
argument_list|,
name|current_namespace
argument_list|,
name|new_binding
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We only create an OVERLOAD if there was a previous binding at 	 this level, or if decl is a template. In the former case, we 	 need to remove the old binding and replace it with the new 	 binding.  We must also run through the NAMES on the binding 	 level where the name was bound to update the chain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_binding
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|old
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|scope
operator|->
name|names
init|;
operator|*
name|d
condition|;
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
control|)
if|if
condition|(
operator|*
name|d
operator|==
name|old
operator|||
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|old
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Just replace the old binding with the new.  */
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|=
name|new_binding
expr_stmt|;
else|else
comment|/* Build a TREE_LIST to wrap the OVERLOAD.  */
operator|*
name|d
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_binding
argument_list|,
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And update the cxx_binding node.  */
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|value
operator|=
name|new_binding
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* We should always find a previous binding in this case.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Install the new binding.  */
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|new_binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a non-member using-declaration. Return the name and scope    being used, and the USING_DECL, or NULL_TREE on failure.  */
end_comment

begin_function
specifier|static
name|tree
name|validate_nonmember_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* 7.3.3/5 	   A using-declaration shall not name a template-id.  */
name|error
argument_list|(
literal|"a using-declaration cannot specify a template-id.  Try `using %D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"namespace `%D' not allowed in using-declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
comment|/* It's a nested name with template parameter dependent scope. 	 This can only be using-declaration for class member.  */
name|error
argument_list|(
literal|"`%T' is not a namespace"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|get_first_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|20020908
argument_list|)
expr_stmt|;
comment|/* [namespace.udecl]        A using-declaration for a class member shall be a        member-declaration.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is not a namespace"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Make a USING_DECL.  */
return|return
name|push_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process local and global using-declarations.  */
end_comment

begin_function
specifier|static
name|void
name|do_nonmember_using_decl
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|oldval
parameter_list|,
name|tree
name|oldtype
parameter_list|,
name|tree
modifier|*
name|newval
parameter_list|,
name|tree
modifier|*
name|newtype
parameter_list|)
block|{
name|cxx_binding
name|decls
decl_stmt|;
operator|*
name|newval
operator|=
operator|*
name|newtype
operator|=
name|NULL_TREE
expr_stmt|;
name|cxx_binding_clear
argument_list|(
operator|&
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
operator|&
name|decls
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* Lookup error */
return|return;
if|if
condition|(
operator|!
name|decls
operator|.
name|value
operator|&&
operator|!
name|decls
operator|.
name|type
condition|)
block|{
name|error
argument_list|(
literal|"`%D' not declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for using functions.  */
if|if
condition|(
name|decls
operator|.
name|value
operator|&&
name|is_overloaded_fn
argument_list|(
name|decls
operator|.
name|value
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|;
if|if
condition|(
name|oldval
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|oldval
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|oldval
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|*
name|newval
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|decls
operator|.
name|value
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|new_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
comment|/* [namespace.udecl]  	     If a function declaration in namespace scope or block 	     scope has the same name and the same parameter types as a 	     function introduced by a using declaration the program is 	     ill-formed.  */
for|for
control|(
name|tmp1
operator|=
name|oldval
init|;
name|tmp1
condition|;
name|tmp1
operator|=
name|OVL_NEXT
argument_list|(
name|tmp1
argument_list|)
control|)
block|{
name|tree
name|old_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_fn
operator|==
name|old_fn
condition|)
comment|/* The function already exists in the current namespace.  */
break|break;
elseif|else
if|if
condition|(
name|OVL_USED
argument_list|(
name|tmp1
argument_list|)
condition|)
continue|continue;
comment|/* this is a using decl */
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_fn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* There was already a non-using declaration in 		     this scope with the same parameter types. If both 	             are the same extern "C" functions, that's ok.  */
if|if
condition|(
name|decls_match
argument_list|(
name|new_fn
argument_list|,
name|old_fn
argument_list|)
condition|)
block|{
comment|/* If the OLD_FN was a builtin, there is now a 			 real declaration.  */
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|old_fn
argument_list|)
condition|)
name|DECL_ANTICIPATED
argument_list|(
name|old_fn
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_ANTICIPATED
argument_list|(
name|old_fn
argument_list|)
condition|)
block|{
comment|/* If the OLD_FN was really declared, the 			 declarations don't match.  */
name|error
argument_list|(
literal|"`%D' is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the OLD_FN was not really there, just ignore 		     it and keep going.  */
block|}
block|}
comment|/* If we broke out of the loop, there's no reason to add 	     this function to the using declarations for this 	     scope.  */
if|if
condition|(
name|tmp1
condition|)
continue|continue;
comment|/* If we are adding to an existing OVERLOAD, then we no 	     longer know the type of the set of functions.  */
if|if
condition|(
operator|*
name|newval
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|newval
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Add this new function to the set.  */
operator|*
name|newval
operator|=
name|build_overload
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|*
name|newval
argument_list|)
expr_stmt|;
comment|/* If there is only one function, then we use its type.  (A 	     using-declaration naming a single function can be used in 	     contexts where overload resolution cannot be 	     performed.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|newval
argument_list|)
operator|!=
name|OVERLOAD
condition|)
block|{
operator|*
name|newval
operator|=
name|ovl_cons
argument_list|(
operator|*
name|newval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OVL_USED
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|newval
operator|=
name|decls
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|oldval
operator|&&
operator|!
name|decls_match
argument_list|(
operator|*
name|newval
argument_list|,
name|oldval
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|newtype
operator|=
name|decls
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|oldtype
operator|&&
operator|*
name|newtype
operator|&&
operator|!
name|same_type_p
argument_list|(
name|oldtype
argument_list|,
operator|*
name|newtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"using declaration `%D' introduced ambiguous type `%T'"
argument_list|,
name|name
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Process a using-declaration at function scope.  */
end_comment

begin_function
name|void
name|do_local_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|building_stmt_tree
argument_list|()
operator|&&
name|at_function_scope_p
argument_list|()
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|oldtype
operator|=
name|lookup_type_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|newval
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|term
decl_stmt|;
comment|/* We only need to push declarations for those functions 	     that were not already bound in the current level. 	     The old value might be NULL_TREE, it might be a single 	     function, or an OVERLOAD.  */
if|if
condition|(
name|oldval
operator|&&
name|TREE_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|term
operator|=
name|OVL_FUNCTION
argument_list|(
name|oldval
argument_list|)
expr_stmt|;
else|else
name|term
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|newval
init|;
name|fn
operator|&&
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
operator|!=
name|term
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
name|push_overloaded_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|PUSH_LOCAL
operator||
name|PUSH_USING
argument_list|)
expr_stmt|;
block|}
else|else
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|newval
argument_list|,
name|PUSH_USING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newtype
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|newtype
argument_list|,
name|PUSH_USING
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the type that should be used when TYPE's name is preceded    by a tag such as 'struct' or 'union', or null if the name cannot    be used in this way.     For example, when processing the third line of:  	struct A; 	typedef struct A A; 	struct A;     lookup of A will find the typedef.  Given A's typedef, this function    will return the type associated with "struct A".  For the tag to be    anything other than TYPE, TYPE must be a typedef whose original type    has the same name and context as TYPE itself.     It is not valid for a typedef of an anonymous type to be used with    an explicit tag:         typedef struct { ... } B;        struct B;     Return null for this case.  */
end_comment

begin_function
specifier|static
name|tree
name|follow_tag_typedef
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|original
decl_stmt|;
name|original
operator|=
name|original_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|original
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|original
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|original
argument_list|)
argument_list|)
operator|==
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|CLASS_TYPE_P
argument_list|(
name|original
argument_list|)
operator|&&
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|original
argument_list|)
operator|)
condition|)
return|return
name|original
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from its SCOPE up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any sk_cleanup contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, and it's not a template, an error is    reported.  */
end_comment

begin_function
name|tree
name|lookup_tag
parameter_list|(
name|enum
name|tree_code
name|form
parameter_list|,
name|tree
name|name
parameter_list|,
name|cxx_scope
modifier|*
name|binding_level
parameter_list|,
name|int
name|thislevel_only
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
comment|/* Nonzero if, we should look past a template parameter level, even      if THISLEVEL_ONLY.  */
name|int
name|allow_template_parms_p
init|=
literal|1
decl_stmt|;
name|bool
name|type_is_anonymous
init|=
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|type_is_anonymous
operator|&&
name|level
operator|->
name|type_decls
operator|!=
name|NULL
condition|)
block|{
name|tree
name|type
init|=
name|binding_table_find_anon_type
argument_list|(
name|level
operator|->
name|type_decls
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* There is no need for error checking here, because            anon names are unique throughout the compilation.  */
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|->
name|kind
operator|==
name|sk_namespace
condition|)
comment|/* Do namespace lookup.  */
for|for
control|(
name|tail
operator|=
name|current_namespace
init|;
literal|1
condition|;
name|tail
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|tail
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
comment|/* If we just skipped past a template parameter level, 	       even though THISLEVEL_ONLY, and we find a template 	       class declaration, then we use the _TYPE node for the 	       template.  See the example below.  */
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|allow_template_parms_p
operator|&&
name|binding
operator|&&
name|binding
operator|->
name|value
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|binding
operator|->
name|value
argument_list|)
condition|)
name|old
operator|=
name|binding
operator|->
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
condition|)
name|old
operator|=
name|select_decl
argument_list|(
name|binding
argument_list|,
name|LOOKUP_PREFER_TYPES
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
comment|/* We've found something at this binding level.  If it is 		   a typedef, extract the tag it refers to.  Lookup fails 		   if the typedef doesn't refer to a taggable type.  */
name|old
operator|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|old
operator|=
name|follow_tag_typedef
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|form
operator|&&
operator|(
name|form
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|old
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thislevel_only
operator|||
name|tail
operator|==
name|global_namespace
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|->
name|type_decls
operator|!=
name|NULL
condition|)
block|{
name|binding_entry
name|entry
init|=
name|binding_table_find
argument_list|(
name|level
operator|->
name|type_decls
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|entry
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|form
operator|&&
operator|(
name|form
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|entry
operator|->
name|type
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|entry
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
name|level
operator|->
name|kind
operator|!=
name|sk_cleanup
condition|)
block|{
if|if
condition|(
name|level
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|allow_template_parms_p
condition|)
block|{
comment|/* We must deal with cases like this:  	           template<class T> struct S; 		   template<class T> struct S {};  		 When looking up `S', for the second declaration, we 		 would like to find the first declaration.  But, we 		 are in the pseudo-global level created for the 		 template parameters, rather than the (surrounding) 		 namespace level.  Thus, we keep going one more level, 		 even though THISLEVEL_ONLY is nonzero.  */
name|allow_template_parms_p
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is nonzero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
name|tree
name|lookup_tag_reverse
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|binding_entry
name|entry
init|=
name|level
operator|->
name|type_decls
operator|==
name|NULL
condition|?
name|NULL
else|:
name|binding_table_reverse_maybe_remap
argument_list|(
name|level
operator|->
name|type_decls
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if ROOT (a namespace, class, or function) encloses    CHILD.  CHILD may be either a class type or a namespace.  */
end_comment

begin_function
name|bool
name|is_ancestor
parameter_list|(
name|tree
name|root
parameter_list|,
name|tree
name|child
parameter_list|)
block|{
name|my_friendly_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|root
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|root
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|root
argument_list|)
operator|)
argument_list|,
literal|20030307
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|child
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|child
argument_list|)
operator|)
argument_list|,
literal|20030307
argument_list|)
expr_stmt|;
comment|/* The global namespace encloses everything.  */
if|if
condition|(
name|root
operator|==
name|global_namespace
condition|)
return|return
name|true
return|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* If we've run out of scopes, stop.  */
if|if
condition|(
operator|!
name|child
condition|)
return|return
name|false
return|;
comment|/* If we've reached the ROOT, it encloses CHILD.  */
if|if
condition|(
name|root
operator|==
name|child
condition|)
return|return
name|true
return|;
comment|/* Go out one level.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|child
argument_list|)
condition|)
name|child
operator|=
name|TYPE_NAME
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
name|DECL_CONTEXT
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter the class or namespace scope indicated by T.  Returns TRUE iff    pop_scope should be called later to exit this scope.  */
end_comment

begin_function
name|bool
name|push_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|bool
name|pop
init|=
name|true
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|push_decl_namespace
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|at_class_scope_p
argument_list|()
operator|||
operator|!
name|same_type_p
argument_list|(
name|current_class_type
argument_list|,
name|t
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
comment|/* T is the same as the current scope.  There is therefore no 	   need to re-enter the scope.  Since we are not actually 	   pushing a new scope, our caller should not call 	   pop_scope.  */
name|pop
operator|=
name|false
expr_stmt|;
block|}
return|return
name|pop
return|;
block|}
end_function

begin_comment
comment|/* Leave scope pushed by push_scope.  */
end_comment

begin_function
name|void
name|pop_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
elseif|else
if|if CLASS_TYPE_P
condition|(
name|t
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
name|class_binding_level
operator|=
name|begin_scope
argument_list|(
name|sk_class
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
name|void
name|poplevel_class
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|level
operator|!=
literal|0
argument_list|,
literal|354
argument_list|)
expr_stmt|;
comment|/* If we're leaving a toplevel class, don't bother to do the setting      of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot      shouldn't even be used when current_class_type isn't set, and second,      if we don't touch it here, we're able to use the cache effect if the      next time we're entering a class scope, it is the same class.  */
if|if
condition|(
name|current_class_depth
operator|!=
literal|1
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Clear out our IDENTIFIER_CLASS_VALUEs.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Find the next enclosing class, and recreate 	 IDENTIFIER_CLASS_VALUEs appropriate for that class.  */
name|b
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
while|while
condition|(
name|b
operator|&&
name|b
operator|->
name|kind
operator|!=
name|sk_class
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
condition|)
for|for
control|(
name|shadowed
operator|=
name|b
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|binding
operator|&&
name|binding
operator|->
name|scope
operator|!=
name|b
condition|)
name|binding
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
if|if
condition|(
name|binding
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|binding
operator|->
name|value
expr_stmt|;
block|}
block|}
else|else
comment|/* Remember to save what IDENTIFIER's were bound in this scope so we        can recover from cache misses.  */
block|{
name|previous_class_type
operator|=
name|current_class_type
expr_stmt|;
name|previous_class_values
operator|=
name|class_binding_level
operator|->
name|class_shadowed
expr_stmt|;
block|}
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the bindings for all of the class-level declarations.  */
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|pop_binding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, pop out of the binding level which we created up in the      `pushlevel_class' routine.  */
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
name|leave_scope
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the    binding was successful.  */
end_comment

begin_function
name|int
name|push_class_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
name|cxx_binding
modifier|*
name|binding
init|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Note that we declared this value so that we can issue an error if      this is an invalid redeclaration of a name already used for some      other purpose.  */
name|note_name_declared_in_class
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|scope
operator|==
name|class_binding_level
condition|)
comment|/* Supplement the existing binding.  */
name|result
operator|=
name|supplement_binding
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
comment|/* Update the IDENTIFIER_CLASS_VALUE for this ID to be the      class-level declaration.  Note that we do not use DECL here      because of the possibility of the `struct stat' hack; if DECL is      a class-name or enum-name we might prefer a field-name, or some      such.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* If this is a binding from a base class, mark it as such.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|current_class_type
argument_list|,
name|context
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
condition|)
comment|/* We only encounter a TREE_LIST when push_class_decls detects an        ambiguity.  Such an ambiguity can be overridden by a definition        in this class.  */
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE    for any names in enclosing classes.  */
end_comment

begin_function
name|void
name|clear_identifier_class_values
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|class_binding_level
condition|)
return|return;
for|for
control|(
name|t
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|bool
name|pushdecl_class_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|bool
name|is_valid
init|=
name|true
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Get the name of X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|is_valid
operator|=
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If X is an anonymous aggregate, all of its members are 	 treated as if they were members of the class containing the 	 aggregate, for naming purposes.  */
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|location_t
name|save_location
init|=
name|input_location
decl_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pushdecl_class_level
argument_list|(
name|f
argument_list|)
condition|)
name|is_valid
operator|=
name|false
expr_stmt|;
name|input_location
operator|=
name|save_location
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return
name|is_valid
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration(s) of X appear in CLASS scope under the name    NAME.  Returns true if the binding is valid.  */
end_comment

begin_function
name|bool
name|push_class_level_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* The class_binding_level will be NULL if x is a template      parameter name in a member template.  */
if|if
condition|(
operator|!
name|class_binding_level
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Make sure that this new member does not have the same name      as a template parameter.  */
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* [class.mem]       If T is the name of a class, then each of the following shall      have a name different from T:       -- every static data member of class T;       -- every member of class T that is itself a type;       -- every enumerator of every member of class T that is an 	enumerated type;       -- every member of every anonymous union that is a member of 	class T.       (Non-static data members were also forbidden to have the same      name as T until TC1.)  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|x
argument_list|)
comment|/* A data member of an anonymous union.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|!=
name|current_class_type
operator|)
operator|)
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|scope
init|=
name|context_for_name_lookup
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|scope
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%D' has the same name as the class in which it is declared"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this declaration shadows a declaration from an enclosing      class, then we will need to restore IDENTIFIER_CLASS_VALUE when      we leave this class.  Record the shadowed declaration here.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
name|tree
name|bval
init|=
name|binding
operator|->
name|value
decl_stmt|;
name|tree
name|old_decl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
condition|)
block|{
comment|/* If the old binding was from a base class, and was for a   	     tag name, slide it over to make room for the new binding.   	     The old binding is still visible if explicitly qualified   	     with a class-key.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|bval
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|old_decl
operator|=
name|binding
operator|->
name|type
expr_stmt|;
name|binding
operator|->
name|type
operator|=
name|bval
expr_stmt|;
name|binding
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|old_decl
operator|=
name|bval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|is_overloaded_fn
argument_list|(
name|bval
argument_list|)
condition|)
name|old_decl
operator|=
name|bval
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|USING_DECL
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|is_overloaded_fn
argument_list|(
name|bval
argument_list|)
condition|)
name|old_decl
operator|=
name|bval
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|is_overloaded_fn
argument_list|(
name|x
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
condition|)
block|{
name|tree
name|shadow
decl_stmt|;
comment|/* Find the previous binding of name on the class-shadowed              list, and update it.  */
for|for
control|(
name|shadow
operator|=
name|class_binding_level
operator|->
name|class_shadowed
init|;
name|shadow
condition|;
name|shadow
operator|=
name|TREE_CHAIN
argument_list|(
name|shadow
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadow
argument_list|)
operator|==
name|name
operator|&&
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|==
name|old_decl
condition|)
block|{
name|binding
operator|->
name|value
operator|=
name|x
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|shadow
argument_list|)
operator|=
name|x
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we didn't replace an existing binding, put the binding on the      stack of bindings for the identifier, and update the shadowed list.  */
if|if
condition|(
name|push_class_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
comment|/* Record the value we are binding NAME to so that we can know 	 what to pop later.  */
name|TREE_TYPE
argument_list|(
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
operator|=
name|x
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|do_class_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|,
name|scope
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SCOPE_REF
operator|||
operator|!
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"using-declaration for non-member at class scope"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"using-declaration cannot name destructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|fns
init|=
name|BASELINK_FUNCTIONS
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|fns
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|980716
argument_list|)
expr_stmt|;
comment|/* Dependent using decls have a NULL type, non-dependent ones have a      void type.  */
name|type
operator|=
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|?
name|NULL_TREE
else|:
name|void_type_node
expr_stmt|;
name|value
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|scope
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|set_class_shadows
parameter_list|(
name|tree
name|shadows
parameter_list|)
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|shadows
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the binding value for name in scope.  */
end_comment

begin_function
name|tree
name|namespace_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|binding
operator|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|binding
condition|?
name|binding
operator|->
name|value
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set the binding value for name in scope.  */
end_comment

begin_function
name|void
name|set_namespace_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|b
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
name|b
operator|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|value
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|val
operator|==
name|error_mark_node
condition|)
name|b
operator|->
name|value
operator|=
name|val
expr_stmt|;
else|else
name|supplement_binding
argument_list|(
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the context of a declaration to scope. Complain if we are not    outside scope.  */
end_comment

begin_function
name|void
name|set_decl_namespace
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|bool
name|friendp
parameter_list|)
block|{
name|tree
name|old
decl_stmt|;
comment|/* Get rid of namespace aliases.  */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* It is ok for friends to be qualified in parallel space.  */
if|if
condition|(
operator|!
name|friendp
operator|&&
operator|!
name|is_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"declaration of `%D' not in a namespace surrounding `%D'"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|!=
name|current_namespace
condition|)
block|{
comment|/* See whether this has been declared in the namespace.  */
name|old
operator|=
name|namespace_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
comment|/* No old declaration at all.  */
goto|goto
name|complain
goto|;
comment|/* A template can be explicitly specialized in any namespace.  */
if|if
condition|(
name|processing_explicit_instantiation
condition|)
return|return;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Don't compare non-function decls with decls_match here, 	   since it can't check for the correct constness at this 	   point. pushdecl will find those errors later.  */
return|return;
comment|/* Since decl is a function, old should contain a function decl.  */
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
goto|goto
name|complain
goto|;
if|if
condition|(
name|processing_template_decl
operator|||
name|processing_specialization
condition|)
comment|/* We have not yet called push_template_decl to turn a 	   FUNCTION_DECL into a TEMPLATE_DECL, so the declarations 	   won't match.  But, we'll check later, when we construct the 	   template.  */
return|return;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|old
condition|;
name|old
operator|=
name|OVL_NEXT
argument_list|(
name|old
argument_list|)
control|)
if|if
condition|(
name|decls_match
argument_list|(
name|decl
argument_list|,
name|OVL_CURRENT
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|decls_match
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|/* Writing "int N::i" to declare a variable within "N" is invalid.  */
if|if
condition|(
name|at_namespace_scope_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"explicit qualification in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|complain
label|:
name|error
argument_list|(
literal|"`%D' should have been declared inside `%D'"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the namespace where the current declaration is declared.  */
end_comment

begin_function
name|tree
name|current_decl_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
comment|/* If we have been pushed into a different namespace, use it.  */
if|if
condition|(
name|decl_namespace_list
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|decl_namespace_list
argument_list|)
return|;
if|if
condition|(
name|current_class_type
condition|)
name|result
operator|=
name|decl_namespace_context
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
name|result
operator|=
name|decl_namespace_context
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|current_namespace
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we    select a name that is unique to this compilation unit.  */
end_comment

begin_function
name|void
name|push_namespace
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|need_new
init|=
literal|1
decl_stmt|;
name|int
name|implicit_use
init|=
literal|0
decl_stmt|;
name|bool
name|anon
init|=
operator|!
name|name
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* We should not get here if the global_namespace is not yet constructed      nor if NAME designates the global namespace:  The global scope is      constructed elsewhere.  */
name|my_friendly_assert
argument_list|(
name|global_namespace
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|global_scope_name
argument_list|,
literal|20030531
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
condition|)
block|{
comment|/* The name of anonymous namespace is unique for the translation          unit.  */
if|if
condition|(
operator|!
name|anonymous_namespace_name
condition|)
name|anonymous_namespace_name
operator|=
name|get_file_function_name
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|name
operator|=
name|anonymous_namespace_name
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
comment|/* Reopening anonymous namespace.  */
name|need_new
operator|=
literal|0
expr_stmt|;
name|implicit_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check whether this is an extended namespace definition.  */
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|need_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"namespace alias `%D' not allowed here, assuming `%D'"
argument_list|,
name|d
argument_list|,
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_new
condition|)
block|{
comment|/* Make a new namespace, binding the name to it.  */
name|d
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|d
operator|=
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
condition|)
block|{
comment|/* Clear DECL_NAME for the benefit of debugging back ends.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|begin_scope
argument_list|(
name|sk_namespace
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|resume_scope
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_use
condition|)
name|do_using_directive
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Enter the name space.  */
name|current_namespace
operator|=
name|d
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop from the scope of the current namespace.  */
end_comment

begin_function
name|void
name|pop_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|my_friendly_assert
argument_list|(
name|current_namespace
operator|!=
name|global_namespace
argument_list|,
literal|20010801
argument_list|)
expr_stmt|;
name|current_namespace
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* The binding level is not popped, as it might be re-opened later.  */
name|leave_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the namespace NS, even if it is deeply    nested within another namespace.  */
end_comment

begin_function
name|void
name|push_nested_namespace
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
if|if
condition|(
name|ns
operator|==
name|global_namespace
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
else|else
block|{
name|push_nested_namespace
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|DECL_NAME
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pop back from the scope of the namespace NS, which was previously    entered with push_nested_namespace.  */
end_comment

begin_function
name|void
name|pop_nested_namespace
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
while|while
condition|(
name|ns
operator|!=
name|global_namespace
condition|)
block|{
name|pop_namespace
argument_list|()
expr_stmt|;
name|ns
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporarily set the namespace for the current declaration.  */
end_comment

begin_function
name|void
name|push_decl_namespace
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|decl
operator|=
name|decl_namespace_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl_namespace_list
operator|=
name|tree_cons
argument_list|(
name|ORIGINAL_NAMESPACE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [namespace.memdef]/2 */
end_comment

begin_function
name|void
name|pop_decl_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_namespace_list
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the namespace that is the common ancestor     of two given namespaces.  */
end_comment

begin_function
specifier|static
name|tree
name|namespace_ancestor
parameter_list|(
name|tree
name|ns1
parameter_list|,
name|tree
name|ns2
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ancestor
argument_list|(
name|ns1
argument_list|,
name|ns2
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ns1
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|namespace_ancestor
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns1
argument_list|)
argument_list|,
name|ns2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a namespace-alias declaration.  */
end_comment

begin_function
name|void
name|do_namespace_alias
parameter_list|(
name|tree
name|alias
parameter_list|,
name|tree
name|namespace
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
name|error_mark_node
condition|)
return|return;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|20050830
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
comment|/* Build the alias.  */
name|alias
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|alias
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|alias
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the current namespace,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_namespace_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|t
operator|=
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|!
name|global_scope_p
argument_list|(
name|b
argument_list|)
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips              up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert USED into the using list of USER. Set INDIRECT_flag if this    directive is not directly from the source. Also find the common    ancestor and let our users know about the new namespace */
end_comment

begin_function
specifier|static
name|void
name|add_using_namespace
parameter_list|(
name|tree
name|user
parameter_list|,
name|tree
name|used
parameter_list|,
name|bool
name|indirect
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Using oneself is a no-op.  */
if|if
condition|(
name|user
operator|==
name|used
condition|)
block|{
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|380
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|used
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|380
argument_list|)
expr_stmt|;
comment|/* Check if we already have this.  */
name|t
operator|=
name|purpose_member
argument_list|(
name|used
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|indirect
condition|)
comment|/* Promote to direct usage.  */
name|TREE_INDIRECT_USING
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add used to the user's using list.  */
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|used
argument_list|,
name|namespace_ancestor
argument_list|(
name|user
argument_list|,
name|used
argument_list|)
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INDIRECT_USING
argument_list|(
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
operator|=
name|indirect
expr_stmt|;
comment|/* Add user to the used's users list.  */
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|user
argument_list|,
literal|0
argument_list|,
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively add all namespaces used.  */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* indirect usage */
name|add_using_namespace
argument_list|(
name|user
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell everyone using us about the new used namespaces.  */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USERS
argument_list|(
name|user
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_using_namespace
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|used
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a using-declaration not appearing in class or local scope.  */
end_comment

begin_function
name|void
name|do_toplevel_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
name|binding
operator|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|binding
operator|->
name|value
expr_stmt|;
name|oldtype
operator|=
name|binding
operator|->
name|type
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
comment|/* Copy declarations found.  */
if|if
condition|(
name|newval
condition|)
name|binding
operator|->
name|value
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|newtype
condition|)
name|binding
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Process a using-directive.  */
end_comment

begin_function
name|void
name|do_using_directive
parameter_list|(
name|tree
name|namespace
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
name|error_mark_node
condition|)
return|return;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|20050830
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|USING_STMT
argument_list|,
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|push_using_directive
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
else|else
comment|/* direct usage */
name|add_using_namespace
argument_list|(
name|current_namespace
argument_list|,
name|namespace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deal with a using-directive seen by the parser.  Currently we only    handle attributes here, since they cannot appear inside a template.  */
end_comment

begin_function
name|void
name|parse_using_directive
parameter_list|(
name|tree
name|namespace
parameter_list|,
name|tree
name|attribs
parameter_list|)
block|{
name|tree
name|a
decl_stmt|;
name|do_using_directive
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attribs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"strong"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"strong using only meaningful at namespace scope"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|namespace
operator|!=
name|error_mark_node
condition|)
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|namespace
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|current_namespace
argument_list|,
literal|0
argument_list|,
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"`%D' attribute directive ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if appropriate.    Calls cp_finish_decl to register the variable, initializing it with    *INIT, if INIT is non-NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_top_level_1
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
modifier|*
name|init
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|x
operator|=
name|pushdecl_namespace_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|cp_finish_decl
argument_list|(
name|x
argument_list|,
operator|*
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
return|return
name|pushdecl_top_level_1
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if    appropriate.  Calls cp_finish_decl to register the variable,    initializing it with INIT.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level_and_finish
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
return|return
name|pushdecl_top_level_1
argument_list|(
name|x
argument_list|,
operator|&
name|init
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Combines two sets of overloaded functions into an OVERLOAD chain, removing    duplicates.  The first list becomes the tail of the result.     The algorithm is O(n^2).  We could get this down to O(n log n) by    doing a sort on the addresses of the functions, if that becomes    necessary.  */
end_comment

begin_function
specifier|static
name|tree
name|merge_functions
parameter_list|(
name|tree
name|s1
parameter_list|,
name|tree
name|s2
parameter_list|)
block|{
for|for
control|(
init|;
name|s2
condition|;
name|s2
operator|=
name|OVL_NEXT
argument_list|(
name|s2
argument_list|)
control|)
block|{
name|tree
name|fn2
init|=
name|OVL_CURRENT
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|tree
name|fns1
decl_stmt|;
for|for
control|(
name|fns1
operator|=
name|s1
init|;
name|fns1
condition|;
name|fns1
operator|=
name|OVL_NEXT
argument_list|(
name|fns1
argument_list|)
control|)
block|{
name|tree
name|fn1
init|=
name|OVL_CURRENT
argument_list|(
name|fns1
argument_list|)
decl_stmt|;
comment|/* If the function from S2 is already in S1, there is no 	     need to add it again.  For `extern "C"' functions, we 	     might have two FUNCTION_DECLs for the same function, in 	     different namespaces; again, we only need one of them.  */
if|if
condition|(
name|fn1
operator|==
name|fn2
operator|||
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|fn1
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|fn2
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|fn1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|fn2
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* If we exhausted all of the functions in S1, FN2 is new.  */
if|if
condition|(
operator|!
name|fns1
condition|)
name|s1
operator|=
name|build_overload
argument_list|(
name|fn2
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/* This should return an error not all definitions define functions.    It is not an error if we find two functions with exactly the    same signature, only if these are selected in overload resolution.    old is the current set of bindings, new the freshly-found binding.    XXX Do we want to give *all* candidates in case of ambiguity?    XXX In what way should I treat extern declarations?    XXX I don't want to repeat the entire duplicate_decls here */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|ambiguous_decl
parameter_list|(
name|tree
name|name
parameter_list|,
name|cxx_binding
modifier|*
name|old
parameter_list|,
name|cxx_binding
modifier|*
name|new
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|val
decl_stmt|,
name|type
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|old
operator|!=
name|NULL
argument_list|,
literal|393
argument_list|)
expr_stmt|;
comment|/* Copy the value.  */
name|val
operator|=
name|new
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|val
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
comment|/* If we expect types or namespaces, and not templates,            or this is not a template class.  */
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore built-in functions that are still anticipated.  */
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
operator|||
name|DECL_ANTICIPATED
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|old
operator|->
name|value
condition|)
name|old
operator|->
name|value
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&&
name|val
operator|!=
name|old
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
operator|->
name|value
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|old
operator|->
name|value
operator|=
name|merge_functions
argument_list|(
name|old
operator|->
name|value
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Some declarations are functions, some are not.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
comment|/* If we've already given this error for this lookup, 		 old->value is error_mark_node, so let's not 		 repeat ourselves.  */
if|if
condition|(
name|old
operator|->
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"use of `%D' is ambiguous"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  first declared as `%#D' here"
argument_list|,
name|old
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|cp_error_at
argument_list|(
literal|"  also declared as `%#D' here"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|old
operator|->
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* ... and copy the type.  */
name|type
operator|=
name|new
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|old
operator|->
name|type
condition|)
name|old
operator|->
name|type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&&
name|old
operator|->
name|type
operator|!=
name|type
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error
argument_list|(
literal|"`%D' denotes an ambiguous type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%J  first type here"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|old
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%J  other type here"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* Return the declarations that are members of the namespace NS.  */
end_comment

begin_function
name|tree
name|cp_namespace_decls
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
return|return
name|NAMESPACE_LEVEL
argument_list|(
name|ns
argument_list|)
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Combine prefer_type and namespaces_only into flags.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_flags
parameter_list|(
name|int
name|prefer_type
parameter_list|,
name|int
name|namespaces_only
parameter_list|)
block|{
if|if
condition|(
name|namespaces_only
condition|)
return|return
name|LOOKUP_PREFER_NAMESPACES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|1
condition|)
return|return
name|LOOKUP_PREFER_TYPES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|0
condition|)
return|return
name|LOOKUP_PREFER_BOTH
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a lookup that returned VAL, use FLAGS to decide if we want to    ignore it or not.  Subroutine of lookup_name_real.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_lookup
parameter_list|(
name|tree
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_NAMESPACES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|val
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|LOOKUP_PREFER_NAMESPACES
operator||
name|LOOKUP_PREFER_TYPES
operator|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the NAMESPACE.  */
end_comment

begin_function
name|tree
name|lookup_namespace_name
parameter_list|(
name|tree
name|namespace
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|template_id
init|=
name|NULL_TREE
decl_stmt|;
name|cxx_binding
name|binding
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|370
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
comment|/* This happens for A::B<int> when B is a namespace.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This happens for A::B where B is a template, and there are no 	 template arguments.  */
name|error
argument_list|(
literal|"invalid use of `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_id
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|373
argument_list|)
expr_stmt|;
name|cxx_binding_clear
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|namespace
argument_list|,
operator|&
name|binding
argument_list|,
literal|0
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|.
name|value
condition|)
block|{
name|val
operator|=
name|binding
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|template_id
condition|)
block|{
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|lookup_template_class
argument_list|(
name|val
argument_list|,
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/*in_decl=*/
name|NULL_TREE
argument_list|,
comment|/*context=*/
name|NULL_TREE
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
name|tf_error
operator||
name|tf_warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|val
operator|=
name|lookup_template_function
argument_list|(
name|val
argument_list|,
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"`%D::%D' is not a template"
argument_list|,
name|namespace
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Ignore built-in functions that haven't been prototyped yet.  */
if|if
condition|(
operator|!
name|val
operator|||
operator|!
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|||
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|val
argument_list|)
operator|||
operator|!
name|DECL_ANTICIPATED
argument_list|(
name|val
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"`%D' undeclared in namespace `%D'"
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the right _DECL from multiple choices.  */
end_comment

begin_function
specifier|static
name|tree
name|select_decl
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|val
operator|=
name|binding
operator|->
name|value
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
block|{
comment|/* We are not interested in types.  */
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If looking for a type, or if there is no non-type binding, select      the value binding.  */
if|if
condition|(
name|binding
operator|->
name|type
operator|&&
operator|(
operator|!
name|val
operator|||
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|)
condition|)
name|val
operator|=
name|binding
operator|->
name|type
expr_stmt|;
comment|/* Don't return non-types if we really prefer types.  */
elseif|else
if|if
condition|(
name|val
operator|&&
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unscoped lookup of a global: iterate over current namespaces,    considering using-directives.  */
end_comment

begin_function
specifier|static
name|tree
name|unqualified_namespace_lookup
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|initial
init|=
name|current_decl_namespace
argument_list|()
decl_stmt|;
name|tree
name|scope
init|=
name|initial
decl_stmt|;
name|tree
name|siter
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|cxx_binding
name|binding
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|cxx_binding_clear
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|val
condition|;
name|scope
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
control|)
block|{
name|cxx_binding
modifier|*
name|b
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|value
operator|&&
name|DECL_P
argument_list|(
name|b
operator|->
name|value
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|b
operator|->
name|value
argument_list|)
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|b
operator|->
name|value
argument_list|)
condition|)
comment|/* Ignore anticipated built-in functions.  */
empty_stmt|;
else|else
name|binding
operator|.
name|value
operator|=
name|b
operator|->
name|value
expr_stmt|;
name|binding
operator|.
name|type
operator|=
name|b
operator|->
name|type
expr_stmt|;
block|}
comment|/* Add all _DECLs seen through local using-directives.  */
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
operator|&
name|binding
argument_list|,
name|level
operator|->
name|using_directives
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* Add all _DECLs seen through global using-directives.  */
comment|/* XXX local and global using lists should work equally.  */
name|siter
operator|=
name|initial
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
operator|&
name|binding
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|siter
argument_list|)
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|siter
operator|==
name|scope
condition|)
break|break;
name|siter
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|siter
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|select_decl
argument_list|(
operator|&
name|binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
break|break;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL    or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type    bindings.       Returns a DECL (or OVERLOAD, or BASELINK) representing the    declaration found.  If no suitable declaration can be found,    ERROR_MARK_NODE is returned.  Iif COMPLAIN is true and SCOPE is    neither a class-type nor a namespace a diagnostic is issued.  */
end_comment

begin_function
name|tree
name|lookup_qualified_name
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|is_type_p
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|cxx_binding
name|binding
decl_stmt|;
name|cxx_binding_clear
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
if|if
condition|(
name|is_type_p
condition|)
name|flags
operator||=
name|LOOKUP_PREFER_TYPES
expr_stmt|;
if|if
condition|(
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
operator|&
name|binding
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|select_decl
argument_list|(
operator|&
name|binding
argument_list|,
name|flags
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_type
argument_list|(
name|scope
argument_list|,
name|complain
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|lookup_member
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|is_type_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of unqualified_namespace_lookup:    Add the bindings of NAME in used namespaces to VAL.    We are currently looking for names in namespace SCOPE, so we    look through USINGS for using-directives of namespaces    which have SCOPE as a common ancestor with the current scope.    Returns false on errors.  */
end_comment

begin_function
specifier|static
name|bool
name|lookup_using_namespace
parameter_list|(
name|tree
name|name
parameter_list|,
name|cxx_binding
modifier|*
name|val
parameter_list|,
name|tree
name|usings
parameter_list|,
name|tree
name|scope
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|iter
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Iterate over all used namespaces in current, searching for using      directives of scope.  */
for|for
control|(
name|iter
operator|=
name|usings
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|iter
argument_list|)
operator|==
name|scope
condition|)
block|{
name|tree
name|used
init|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
decl_stmt|;
name|cxx_binding
modifier|*
name|val1
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|used
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* Resolve ambiguities.  */
if|if
condition|(
name|val1
condition|)
name|val
operator|=
name|ambiguous_decl
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|val1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
operator|->
name|value
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [namespace.qual]    Accepts the NAME to lookup and its qualifying SCOPE.    Returns the name/type pair found into the cxx_binding *RESULT,    or false on error.  */
end_comment

begin_function
specifier|static
name|bool
name|qualified_lookup_using_namespace
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|,
name|cxx_binding
modifier|*
name|result
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Maintain a list of namespaces visited...  */
name|tree
name|seen
init|=
name|NULL_TREE
decl_stmt|;
comment|/* ... and a list of namespace yet to see.  */
name|tree
name|todo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|todo_maybe
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|usings
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Look through namespace aliases.  */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
while|while
condition|(
name|scope
operator|&&
name|result
operator|->
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|seen
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
name|result
operator|=
name|ambiguous_decl
argument_list|(
name|name
argument_list|,
name|result
argument_list|,
name|binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Consider strong using directives always, and non-strong ones 	 if we haven't found a binding yet.  ??? Shouldn't we consider 	 non-strong ones if the initial RESULT is non-NULL, but the 	 binding in the given namespace is?  */
for|for
control|(
name|usings
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|scope
argument_list|)
init|;
name|usings
condition|;
name|usings
operator|=
name|TREE_CHAIN
argument_list|(
name|usings
argument_list|)
control|)
comment|/* If this was a real directive, and we have not seen it.  */
if|if
condition|(
operator|!
name|TREE_INDIRECT_USING
argument_list|(
name|usings
argument_list|)
condition|)
block|{
comment|/* Try to avoid queuing the same namespace more than once, 	       the exception being when a namespace was already 	       enqueued for todo_maybe and then a strong using is 	       found for it.  We could try to remove it from 	       todo_maybe, but it's probably not worth the effort.  */
if|if
condition|(
name|is_associated_namespace
argument_list|(
name|scope
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|seen
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo
argument_list|)
condition|)
name|todo
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|!
name|result
operator|->
name|value
operator|&&
operator|!
name|result
operator|->
name|type
operator|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|seen
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo_maybe
argument_list|)
condition|)
name|todo_maybe
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo_maybe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|todo
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|todo_maybe
operator|&&
operator|(
operator|!
name|result
operator|->
name|value
operator|&&
operator|!
name|result
operator|->
name|type
operator|)
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo_maybe
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo_maybe
argument_list|)
expr_stmt|;
name|todo_maybe
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there never was a todo list.  */
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|result
operator|->
name|value
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs or namespaces.    If PREFER_TYPE is> 1, we reject non-type decls (e.g. namespaces).    Otherwise we prefer non-TYPE_DECLs.     If NONCLASS is nonzero, we don't look for the NAME in class scope,    using IDENTIFIER_CLASS_VALUE.  */
end_comment

begin_function
name|tree
name|lookup_name_real
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|prefer_type
parameter_list|,
name|int
name|nonclass
parameter_list|,
name|int
name|namespaces_only
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|iter
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Conversion operators are handled specially because ordinary      unqualified name lookup will not find template conversion      operators.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
operator|&&
name|level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|tree
name|class_type
decl_stmt|;
name|tree
name|operators
decl_stmt|;
comment|/* A conversion operator can only be declared in a class  	     scope.  */
if|if
condition|(
name|level
operator|->
name|kind
operator|!=
name|sk_class
condition|)
continue|continue;
comment|/* Lookup the conversion operator in the class.  */
name|class_type
operator|=
name|level
operator|->
name|this_entity
expr_stmt|;
name|operators
operator|=
name|lookup_fnfields
argument_list|(
name|class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|operators
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|operators
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|flags
operator||=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* First, look in non-namespace scopes.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|nonclass
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|previous
control|)
block|{
name|tree
name|binding
decl_stmt|;
if|if
condition|(
operator|!
name|LOCAL_BINDING_P
argument_list|(
name|iter
argument_list|)
operator|&&
name|nonclass
condition|)
comment|/* We're not looking for class-scoped bindings, so keep going.  */
continue|continue;
comment|/* If this is the kind of thing we're looking for, we're done.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|value
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|iter
operator|->
name|value
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|type
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|iter
operator|->
name|type
expr_stmt|;
else|else
name|binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
name|val
operator|=
name|binding
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now lookup in namespace scopes.  */
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|tree
name|t
init|=
name|unqualified_namespace_lookup
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|val
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
block|{
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|lookup_name_nonclass
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_function_nonclass
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
return|return
name|lookup_arg_dependent
argument_list|(
name|name
argument_list|,
name|lookup_name_nonclass
argument_list|(
name|name
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|prefer_type
parameter_list|)
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|prefer_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only in the innermost non-class    binding level.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|b
operator|=
name|innermost_nonclass_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_namespace
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* extern "C" function() */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|&&
name|LOCAL_BINDING_P
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|scope
operator|==
name|b
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|IDENTIFIER_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like lookup_name_current_level, but for types.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_type_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_namespace
argument_list|,
literal|980716
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|global_type_node
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [basic.lookup.koenig] */
end_comment

begin_comment
comment|/* A nonzero return value in the functions below indicates an error.  */
end_comment

begin_struct
struct|struct
name|arg_lookup
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|namespaces
decl_stmt|;
name|tree
name|classes
decl_stmt|;
name|tree
name|functions
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|arg_assoc
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_args
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_type
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|add_function
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_namespace
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_class
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_template_arg
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add a function to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|add_function
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
comment|/* We used to check here to see if the function was already in the list,      but that's O(n^2), which is just too expensive for function lookup.      Now we deal with the occasional duplicate in joust.  In doing this, we      assume that the number of duplicates will be small compared to the      total number of functions being compared, which should usually be the      case.  */
comment|/* We must find only functions, or exactly one non-function.  */
if|if
condition|(
operator|!
name|k
operator|->
name|functions
condition|)
name|k
operator|->
name|functions
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|==
name|k
operator|->
name|functions
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|k
operator|->
name|functions
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|k
operator|->
name|functions
operator|=
name|build_overload
argument_list|(
name|fn
argument_list|,
name|k
operator|->
name|functions
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|f1
init|=
name|OVL_CURRENT
argument_list|(
name|k
operator|->
name|functions
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|fn
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|f1
argument_list|)
condition|)
block|{
name|fn
operator|=
name|f1
expr_stmt|;
name|f1
operator|=
name|f2
expr_stmt|;
name|f2
operator|=
name|fn
expr_stmt|;
block|}
name|cp_error_at
argument_list|(
literal|"`%D' is not a function,"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  conflict with `%D'"
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  in call to `%D'"
argument_list|,
name|k
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff CURRENT has declared itself to be an associated    namespace of SCOPE via a strong using-directive (or transitive chain    thereof).  Both are namespaces.  */
end_comment

begin_function
name|bool
name|is_associated_namespace
parameter_list|(
name|tree
name|current
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|tree
name|seen
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|todo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|scope
operator|==
name|current
condition|)
return|return
name|true
return|;
name|seen
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|scope
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|seen
argument_list|)
condition|)
name|todo
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo
argument_list|)
expr_stmt|;
if|if
condition|(
name|todo
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add functions of a namespace to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_namespace
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|purpose_member
argument_list|(
name|scope
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
condition|)
return|return
literal|0
return|;
name|k
operator|->
name|namespaces
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
expr_stmt|;
comment|/* Check out our super-users.  */
for|for
control|(
name|value
operator|=
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|scope
argument_list|)
init|;
name|value
condition|;
name|value
operator|=
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
control|)
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|value
operator|=
name|namespace_binding
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|value
condition|;
name|value
operator|=
name|OVL_NEXT
argument_list|(
name|value
argument_list|)
control|)
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a template argument to the lookup    structure.  Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_template_arg
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
comment|/* [basic.lookup.koenig]       If T is a template-id, its associated namespaces and classes are      ... the namespaces and classes associated with the types of the      template arguments provided for template type parameters      (excluding template template parameters); the namespaces in which      any template template arguments are defined; and the classes in      which any member templates used as template template arguments      are defined.  [Note: non-type template arguments do not      contribute to the set of associated namespaces.  ]  */
comment|/* Consider first template template arguments.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|ctx
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* It's not a member template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
return|;
comment|/* Otherwise, it must be member template.  */
else|else
return|return
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
return|;
block|}
comment|/* It's not a template template argument, but it is a type template      argument.  */
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|arg
argument_list|)
return|;
comment|/* It's a non-type template argument.  */
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with class to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_class
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|list
decl_stmt|,
name|friends
decl_stmt|,
name|context
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Backend build structures, such as __builtin_va_list, aren't      affected by all this.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|purpose_member
argument_list|(
name|type
argument_list|,
name|k
operator|->
name|classes
argument_list|)
condition|)
return|return
name|false
return|;
name|k
operator|->
name|classes
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|classes
argument_list|)
expr_stmt|;
name|context
operator|=
name|decl_namespace_context
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|context
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Process baseclasses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Process friends.  */
for|for
control|(
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
if|if
condition|(
name|k
operator|->
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
for|for
control|(
name|friends
operator|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
decl_stmt|;
comment|/* Only interested in global functions with potentially hidden 	     (i.e. unqualified) declarations.  */
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|context
condition|)
continue|continue;
comment|/* Template specializations are never found by name lookup. 	     (Templates themselves can be found, but not template 	     specializations.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* Process template arguments.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|list
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
name|arg_assoc_template_arg
argument_list|(
name|k
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given type.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_type
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* As we do not get the type of non-type dependent expressions      right, we can end up with such things without a type.  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Pointer to member: associate class type and value type.  */
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|false
return|;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|false
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|type
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|decl_namespace_context
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
comment|/* The basetype is referenced in the first arg type, so just 	 fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Associate the parameter types.  */
if|if
condition|(
name|arg_assoc_args
argument_list|(
name|k
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Associate the return type.  */
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
return|return
name|false
return|;
case|case
name|TYPENAME_TYPE
case|:
return|return
name|false
return|;
case|case
name|LANG_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|unknown_type_node
condition|)
return|return
name|false
return|;
comment|/* else fall through */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with arguments.  Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_args
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|arg_assoc
argument_list|(
name|k
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given tree_node.  Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
operator|!
name|type_unknown_p
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|n
operator|=
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|BASELINK
condition|)
name|n
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* [basic.lookup.koenig]  	 If T is a template-id, its associated namespaces and classes 	 are the namespace in which the template is defined; for 	 member templates, the member template's class...  */
name|tree
name|template
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|template
operator|=
name|TREE_OPERAND
argument_list|(
name|template
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First, the template.  There may actually be more than one if 	 this is an overloaded function template.  But, in that case, 	 we only need the first; all the functions will be in the same 	 namespace.  */
name|template
operator|=
name|OVL_CURRENT
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
block|}
comment|/* It must be a member template.  */
elseif|else
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
comment|/* Now the arguments.  */
if|if
condition|(
name|args
condition|)
for|for
control|(
name|ix
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
init|;
name|ix
operator|--
condition|;
control|)
if|if
condition|(
name|arg_assoc_template_arg
argument_list|(
name|k
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|ix
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|OVL_CHAIN
argument_list|(
name|n
argument_list|)
control|)
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Performs Koenig lookup depending on arguments, where fns    are the functions found in normal lookup.  */
end_comment

begin_function
name|tree
name|lookup_arg_dependent
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|fns
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|struct
name|arg_lookup
name|k
decl_stmt|;
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|k
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|k
operator|.
name|functions
operator|=
name|fns
expr_stmt|;
name|k
operator|.
name|classes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We've already looked at some namespaces during normal unqualified      lookup -- but we don't know exactly which ones.  If the functions      we found were brought into the current namespace via a using      declaration, we have not really checked the namespace from which      they came.  Therefore, we check all namespaces here -- unless the      function we have is from the current namespace.  Even then, we      must check all namespaces if the function is a local      declaration; any other declarations present at namespace scope      should be visible during argument-dependent lookup.  */
if|if
condition|(
name|fns
condition|)
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|CP_DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|current_decl_namespace
argument_list|()
operator|||
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|)
condition|)
name|k
operator|.
name|namespaces
operator|=
name|NULL_TREE
expr_stmt|;
else|else
comment|/* Setting NAMESPACES is purely an optimization; it prevents        adding functions which are already in FNS.  Adding them would        be safe -- "joust" will eliminate the duplicates -- but        wasteful.  */
name|k
operator|.
name|namespaces
operator|=
name|build_tree_list
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg_assoc_args
argument_list|(
operator|&
name|k
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|k
operator|.
name|functions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add namespace to using_directives. Return NULL_TREE if nothing was    changed (i.e. there was already a directive), or the fresh    TREE_LIST otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|push_using_directive
parameter_list|(
name|tree
name|used
parameter_list|)
block|{
name|tree
name|ud
init|=
name|current_binding_level
operator|->
name|using_directives
decl_stmt|;
name|tree
name|iter
decl_stmt|,
name|ancestor
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Check if we already have this.  */
if|if
condition|(
name|purpose_member
argument_list|(
name|used
argument_list|,
name|ud
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|namespace_ancestor
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ud
operator|=
name|current_binding_level
operator|->
name|using_directives
expr_stmt|;
name|ud
operator|=
name|tree_cons
argument_list|(
name|used
argument_list|,
name|ancestor
argument_list|,
name|ud
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|using_directives
operator|=
name|ud
expr_stmt|;
comment|/* Recursively add all namespaces used.  */
for|for
control|(
name|iter
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
name|push_using_directive
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The type TYPE is being declared.  If it is a class template, or a    specialization of a class template, do any processing required and    perform error-checking.  If IS_FRIEND is nonzero, this TYPE is    being declared a friend.  B is the binding level at which this TYPE    should be bound.     Returns the TYPE_DECL for TYPE, which may have been altered by this    processing.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_process_template_type_declaration
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|globalize
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_parmlist
condition|)
comment|/* You can't declare a new template type in a template parameter        list.  But, you can declare a non-template type:           template<class A*> struct S;         is a forward-declaration of `A'.  */
empty_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* This may change after the call to 	     push_template_decl_real, but we want the original value.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
comment|/* If the current binding level is the binding level for the 	     template parameters (see the comment in 	     begin_template_parm_list) and the enclosing level is a class 	     scope, and we're not looking at a friend, push the 	     declaration of the member class into the class scope.  In the 	     friend case, push_template_decl will already have put the 	     friend into global scope, if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
name|globalize
operator|&&
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|finish_member_declaration
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put this UDT in the table of UDTs for the class, since 		 that won't happen below because B is not the class 		 binding level, but is instead the pseudo-global level.  */
if|if
condition|(
name|b
operator|->
name|level_chain
operator|->
name|type_decls
operator|==
name|NULL
condition|)
name|b
operator|->
name|level_chain
operator|->
name|type_decls
operator|=
name|binding_table_new
argument_list|(
name|SCOPE_DEFAULT_HT_SIZE
argument_list|)
expr_stmt|;
name|binding_table_insert
argument_list|(
name|b
operator|->
name|level_chain
operator|->
name|type_decls
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|level_chain
operator|->
name|type_decls
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Push a tag name NAME for struct/class/union/enum type TYPE.    Normally put it into the inner-most non-sk_cleanup scope,    but if GLOBALIZE is true, put it in the inner-most non-class scope.    The latter is needed for implicit declarations.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|globalize
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
comment|/* Cleanup scopes are not scopes from the point of view of 	    the language.  */
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
comment|/* Neither are the scopes used to hold template parameters 	    for an explicit specialization.  For an ordinary template 	    declaration, these scopes are not scopes from the point of 	    view of the language -- but we need a place to stash 	    things that will go in the containing namespace when the 	    template is instantiated.  */
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|b
operator|->
name|explicit_spec_p
operator|)
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|&&
operator|(
name|globalize
comment|/* We may be defining a new type in the initializer 		    of a static member variable. We allow this when 		    not pedantic, and it is particularly useful for 		    type punning via an anonymous union.  */
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|b
operator|->
name|this_entity
argument_list|)
operator|)
operator|)
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type_decls
operator|==
name|NULL
condition|)
name|b
operator|->
name|type_decls
operator|=
name|binding_table_new
argument_list|(
name|SCOPE_DEFAULT_HT_SIZE
argument_list|)
expr_stmt|;
name|binding_table_insert
argument_list|(
name|b
operator|->
name|type_decls
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
condition|)
block|{
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|in_class
init|=
literal|0
decl_stmt|;
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalize
condition|)
name|context
operator|=
name|cs
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_P
argument_list|(
name|cs
argument_list|)
condition|)
comment|/* When declaring a friend class of a local class, we want 		   to inject the newly named class into the scope 		   containing the local class, not the namespace scope.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|get_type_decl
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|kind
operator|==
name|sk_class
operator|)
condition|)
name|in_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|create_implicit_typedef
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_class
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|d
operator|=
name|maybe_process_template_type_declaration
argument_list|(
name|type
argument_list|,
name|globalize
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
if|if
condition|(
operator|!
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
comment|/* Put this TYPE_DECL on the TYPE_FIELDS list for the 		   class.  But if it's a member template class, we 		   want the TEMPLATE_DECL, not the TYPE_DECL, so this 		   is done later.  */
name|finish_member_declaration
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* FIXME what if it gets a name from typedef?  */
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If this is a local class, keep track of it.  We need this 	     information for name-mangling, and so that it is possible to find 	     all function definitions in a translation unit in a convenient 	     way.  (It's otherwise tricky to find a member function definition 	     it's only pointed to from within a local class.)  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|processing_template_decl
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|local_classes
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|type_decls
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Use the canonical TYPE_DECL for this node.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE 	 will be the tagged type we just added to the current 	 binding level.  This fake NULL-named TYPE_DECL node helps 	 dwarfout.c to know when it needs to output a 	 representation of a tagged type, and it also gives us a 	 convenient place to record the "scope start" address for 	 the tagged type.  */
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate storage for saving a C++ binding.  */
end_comment

begin_define
define|#
directive|define
name|cxx_saved_binding_make
parameter_list|()
define|\
value|(ggc_alloc (sizeof (cxx_saved_binding)))
end_define

begin_decl_stmt
name|struct
name|cxx_saved_binding
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Link that chains saved C++ bindings for a given name into a stack.  */
name|cxx_saved_binding
modifier|*
name|previous
decl_stmt|;
comment|/* The name of the current binding.  */
name|tree
name|identifier
decl_stmt|;
comment|/* The binding we're saving.  */
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|tree
name|class_value
decl_stmt|;
name|tree
name|real_type_value
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_decl_stmt
name|struct
name|saved_scope
modifier|*
name|scope_chain
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|cxx_saved_binding
modifier|*
name|store_bindings
parameter_list|(
name|tree
name|names
parameter_list|,
name|cxx_saved_binding
modifier|*
name|old_bindings
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|search_bindings
init|=
name|old_bindings
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|id
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|saved
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
comment|/* Note that we may have an IDENTIFIER_CLASS_VALUE even when 	     we have no IDENTIFIER_BINDING if we have left the class 	     scope, but cached the class-level declarations.  */
operator|||
operator|!
operator|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|||
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|t1
operator|=
name|search_bindings
init|;
name|t1
condition|;
name|t1
operator|=
name|t1
operator|->
name|previous
control|)
if|if
condition|(
name|t1
operator|->
name|identifier
operator|==
name|id
condition|)
goto|goto
name|skip_it
goto|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|135
argument_list|)
expr_stmt|;
name|saved
operator|=
name|cxx_saved_binding_make
argument_list|()
expr_stmt|;
name|saved
operator|->
name|previous
operator|=
name|old_bindings
expr_stmt|;
name|saved
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|saved
operator|->
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|saved
operator|->
name|class_value
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
empty_stmt|;
name|saved
operator|->
name|real_type_value
operator|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|old_bindings
operator|=
name|saved
expr_stmt|;
name|skip_it
label|:
empty_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_to_top_level
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|saved_scope
modifier|*
name|s
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|old_bindings
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|s
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_scope
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|scope_chain
condition|?
name|current_binding_level
else|:
literal|0
expr_stmt|;
comment|/* If we're in the middle of some function, save our state.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|need_pop
operator|=
literal|1
expr_stmt|;
name|push_function_context_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|need_pop
operator|=
literal|0
expr_stmt|;
name|old_bindings
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scope_chain
operator|&&
name|previous_class_type
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|previous_class_values
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Have to include the global scope, because class-scope decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Template IDs are inserted into the global level. If they were 	 inserted into namespace level, finish_file wouldn't find them 	 when doing pending instantiations. Therefore, don't stop at 	 namespace level, but continue until :: .  */
if|if
condition|(
name|global_scope_p
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|names
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* We also need to check class_shadowed to save class-level type 	 bindings, since pushclass doesn't fill in b->names.  */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|old_bindings
operator|=
name|store_bindings
argument_list|(
name|b
operator|->
name|class_shadowed
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Unwind type-value slots back to top level.  */
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|prev
operator|=
name|scope_chain
expr_stmt|;
name|s
operator|->
name|old_bindings
operator|=
name|old_bindings
expr_stmt|;
name|s
operator|->
name|bindings
operator|=
name|b
expr_stmt|;
name|s
operator|->
name|need_pop_function_context
operator|=
name|need_pop
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|scope_chain
operator|=
name|s
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|current_lang_base
argument_list|,
literal|10
argument_list|,
literal|"current_lang_base"
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|current_namespace
operator|=
name|global_namespace
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|scope_chain
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|saved
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Clear out class-level bindings cache.  */
if|if
condition|(
name|previous_class_type
condition|)
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
name|current_lang_base
operator|=
literal|0
expr_stmt|;
name|scope_chain
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|saved
operator|=
name|s
operator|->
name|old_bindings
init|;
name|saved
condition|;
name|saved
operator|=
name|saved
operator|->
name|previous
control|)
block|{
name|tree
name|id
init|=
name|saved
operator|->
name|identifier
decl_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|saved
operator|->
name|binding
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|saved
operator|->
name|class_value
expr_stmt|;
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|saved
operator|->
name|real_type_value
argument_list|)
expr_stmt|;
block|}
comment|/* If we were in the middle of compiling a function, restore our      state.  */
if|if
condition|(
name|s
operator|->
name|need_pop_function_context
condition|)
name|pop_function_context_from
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop off extraneous binding levels left over due to syntax errors.     We don't pop past namespaces, as they might be valid.  */
end_comment

begin_function
name|void
name|pop_everything
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|verbatim
argument_list|(
literal|"XXX entering pop_everything ()\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|verbatim
argument_list|(
literal|"XXX leaving pop_everything ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-name-lookup.h"
end_include

end_unit

