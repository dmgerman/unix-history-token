begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop manipulation code for GNU compiler.    Copyright (C) 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_function_decl
specifier|static
name|struct
name|loop
modifier|*
name|duplicate_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|duplicate_subloops
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_loops_to
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loop_redirect_edge
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|loop_delete_branch_edge
parameter_list|(
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_bbs
parameter_list|(
name|basic_block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rpe_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_path
parameter_list|(
name|edge
parameter_list|,
name|basic_block
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|alp_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_loop_placements
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fix_bb_placement
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_bb_placements
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|place_new_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_loop_frequencies
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_bbs_frequencies
parameter_list|(
name|basic_block
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|create_preheader
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_irreducible_loops
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Splits basic block BB after INSN, returns created edge.  Updates loops    and dominators.  */
end_comment

begin_function
name|edge
name|split_loop_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* Split the block.  */
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Add dest to loop.  */
name|add_bb_to_loop
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
argument_list|)
expr_stmt|;
comment|/* Fix dominators.  */
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|redirect_immediate_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Checks whether basic block BB is dominated by DATA.  */
end_comment

begin_function
specifier|static
name|bool
name|rpe_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove basic blocks BBS from loop structure and dominance info,    and delete them afterwards.  */
end_comment

begin_function
specifier|static
name|void
name|remove_bbs
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|remove_bb_from_loops
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|delete_from_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|delete_block
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find path -- i.e. the basic blocks dominated by edge E and put them    into array BBS, that will be allocated large enough to contain them.    E->dest must have exactly one predecessor for this to work (it is    easy to achieve and we do not put it here because we do not want to    alter anything by this function).  The number of basic blocks in the    path is returned.  */
end_comment

begin_function
specifier|static
name|int
name|find_path
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
modifier|*
modifier|*
name|bbs
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find bbs in the path.  */
operator|*
name|bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dfs_enumerate_from
argument_list|(
name|e
operator|->
name|dest
argument_list|,
literal|0
argument_list|,
name|rpe_enum_p
argument_list|,
operator|*
name|bbs
argument_list|,
name|n_basic_blocks
argument_list|,
name|e
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fix placement of basic block BB inside loop hierarchy stored in LOOPS --    Let L be a loop to that BB belongs.  Then every successor of BB must either      1) belong to some superloop of loop L, or      2) be a header of loop K such that K->outer is superloop of L    Returns true if we had to move BB into other loop to enforce this condition,    false if the placement of BB was already correct (provided that placements    of its successors are correct).  */
end_comment

begin_function
specifier|static
name|bool
name|fix_bb_placement
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|tree_root
decl_stmt|,
modifier|*
name|act
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
name|act
operator|=
name|e
operator|->
name|dest
operator|->
name|loop_father
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|header
operator|==
name|e
operator|->
name|dest
condition|)
name|act
operator|=
name|act
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|act
argument_list|)
condition|)
name|loop
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|==
name|bb
operator|->
name|loop_father
condition|)
return|return
name|false
return|;
name|remove_bb_from_loops
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Fix placements of basic blocks inside loop hierarchy stored in loops; i.e.    enforce condition condition stated in description of fix_bb_placement. We    start from basic block FROM that had some of its successors removed, so that    his placement no longer has to be correct, and iteratively fix placement of    its predecessors that may change if placement of FROM changed.  Also fix    placement of subloops of FROM->loop_father, that might also be altered due    to this change; the condition for them is similar, except that instead of    successors we consider edges coming out of the loops.  */
end_comment

begin_function
specifier|static
name|void
name|fix_bb_placements
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|basic_block
name|from
parameter_list|)
block|{
name|sbitmap
name|in_queue
decl_stmt|;
name|basic_block
modifier|*
name|queue
decl_stmt|,
modifier|*
name|qtop
decl_stmt|,
modifier|*
name|qbeg
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|struct
name|loop
modifier|*
name|base_loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* We pass through blocks back-reachable from FROM, testing whether some      of their successors moved to outer loop.  It may be necessary to      iterate several times, but it is finite, as we stop unless we move      the basic block up the loop structure.  The whole story is a bit      more complicated due to presence of subloops, those are moved using      fix_loop_placement.  */
name|base_loop
operator|=
name|from
operator|->
name|loop_father
expr_stmt|;
if|if
condition|(
name|base_loop
operator|==
name|loops
operator|->
name|tree_root
condition|)
return|return;
name|in_queue
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|from
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Prevent us from going out of the base_loop.  */
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|base_loop
operator|->
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|queue
operator|=
name|xmalloc
argument_list|(
operator|(
name|base_loop
operator|->
name|num_nodes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|qtop
operator|=
name|queue
operator|+
name|base_loop
operator|->
name|num_nodes
operator|+
literal|1
expr_stmt|;
name|qbeg
operator|=
name|queue
expr_stmt|;
name|qend
operator|=
name|queue
operator|+
literal|1
expr_stmt|;
operator|*
name|qbeg
operator|=
name|from
expr_stmt|;
while|while
condition|(
name|qbeg
operator|!=
name|qend
condition|)
block|{
name|from
operator|=
operator|*
name|qbeg
expr_stmt|;
name|qbeg
operator|++
expr_stmt|;
if|if
condition|(
name|qbeg
operator|==
name|qtop
condition|)
name|qbeg
operator|=
name|queue
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_queue
argument_list|,
name|from
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|loop_father
operator|->
name|header
operator|==
name|from
condition|)
block|{
comment|/* Subloop header, maybe move the loop upward.  */
if|if
condition|(
operator|!
name|fix_loop_placement
argument_list|(
name|from
operator|->
name|loop_father
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* Ordinary basic block.  */
if|if
condition|(
operator|!
name|fix_bb_placement
argument_list|(
name|loops
argument_list|,
name|from
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Something has changed, insert predecessors into queue.  */
for|for
control|(
name|e
operator|=
name|from
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
name|struct
name|loop
modifier|*
name|nca
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
condition|)
continue|continue;
comment|/* If it is subloop, then it either was not moved, or 	     the path up the loop tree from base_loop do not contain 	     it.  */
name|nca
operator|=
name|find_common_loop
argument_list|(
name|pred
operator|->
name|loop_father
argument_list|,
name|base_loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|->
name|loop_father
operator|!=
name|base_loop
operator|&&
operator|(
name|nca
operator|==
name|base_loop
operator|||
name|nca
operator|!=
name|pred
operator|->
name|loop_father
operator|)
condition|)
name|pred
operator|=
name|pred
operator|->
name|loop_father
operator|->
name|header
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flow_loop_nested_p
argument_list|(
name|from
operator|->
name|loop_father
argument_list|,
name|pred
operator|->
name|loop_father
argument_list|)
condition|)
block|{
comment|/* No point in processing it.  */
continue|continue;
block|}
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
condition|)
continue|continue;
comment|/* Schedule the basic block.  */
operator|*
name|qend
operator|=
name|pred
expr_stmt|;
name|qend
operator|++
expr_stmt|;
if|if
condition|(
name|qend
operator|==
name|qtop
condition|)
name|qend
operator|=
name|queue
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|pred
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic block from has lost one or more of its predecessors, so it might    mo longer be part irreducible loop.  Fix it and proceed recursively    for its successors if needed.  */
end_comment

begin_function
specifier|static
name|void
name|fix_irreducible_loops
parameter_list|(
name|basic_block
name|from
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|basic_block
modifier|*
name|stack
decl_stmt|;
name|int
name|stack_top
decl_stmt|;
name|sbitmap
name|on_stack
decl_stmt|;
name|edge
modifier|*
name|edges
decl_stmt|,
name|e
decl_stmt|;
name|unsigned
name|n_edges
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|from
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
condition|)
return|return;
name|on_stack
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|on_stack
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|on_stack
argument_list|,
name|from
operator|->
name|index
argument_list|)
expr_stmt|;
name|stack
operator|=
name|xmalloc
argument_list|(
name|from
operator|->
name|loop_father
operator|->
name|num_nodes
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|stack
index|[
literal|0
index|]
operator|=
name|from
expr_stmt|;
name|stack_top
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|stack_top
condition|)
block|{
name|bb
operator|=
name|stack
index|[
operator|--
name|stack_top
index|]
expr_stmt|;
name|RESET_BIT
argument_list|(
name|on_stack
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
break|break;
if|if
condition|(
name|e
condition|)
continue|continue;
name|bb
operator|->
name|flags
operator|&=
operator|~
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|->
name|header
operator|==
name|bb
condition|)
name|edges
operator|=
name|get_loop_exit_edges
argument_list|(
name|bb
operator|->
name|loop_father
argument_list|,
operator|&
name|n_edges
argument_list|)
expr_stmt|;
else|else
block|{
name|n_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|n_edges
operator|++
expr_stmt|;
name|edges
operator|=
name|xmalloc
argument_list|(
name|n_edges
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|n_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|edges
index|[
name|n_edges
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_edges
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|edges
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
block|{
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|from
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|on_stack
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|on_stack
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|stack
index|[
name|stack_top
operator|++
index|]
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|on_stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes path beginning at edge E, i.e. remove basic blocks dominated by E    and update loop structure stored in LOOPS and dominators.  Return true if    we were able to remove the path, false otherwise (and nothing is affected    then).  */
end_comment

begin_function
name|bool
name|remove_path
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|edge
name|ae
decl_stmt|;
name|basic_block
modifier|*
name|rem_bbs
decl_stmt|,
modifier|*
name|bord_bbs
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|,
name|from
decl_stmt|,
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nrem
decl_stmt|,
name|n_bord_bbs
decl_stmt|,
name|n_dom_bbs
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
if|if
condition|(
operator|!
name|loop_delete_branch_edge
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We need to check whether basic blocks are dominated by the edge      e, but we only have basic block dominators.  This is easy to      fix -- when e->dest has exactly one predecessor, this corresponds      to blocks dominated by e->dest, if not, split the edge.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
condition|)
name|e
operator|=
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
operator|->
name|pred
expr_stmt|;
comment|/* It may happen that by removing path we remove one or more loops      we belong to.  In this case first unloop the loops, then proceed      normally.   We may assume that e->dest is not a header of any loop,      as it now has exactly one predecessor.  */
while|while
condition|(
name|e
operator|->
name|src
operator|->
name|loop_father
operator|->
name|outer
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
operator|->
name|latch
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|unloop
argument_list|(
name|loops
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
argument_list|)
expr_stmt|;
comment|/* Identify the path.  */
name|nrem
operator|=
name|find_path
argument_list|(
name|e
argument_list|,
operator|&
name|rem_bbs
argument_list|)
expr_stmt|;
name|n_bord_bbs
operator|=
literal|0
expr_stmt|;
name|bord_bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
comment|/* Find "border" hexes -- i.e. those with predecessor in removed path.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|rem_bbs
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|rem_bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|ae
operator|=
name|rem_bbs
index|[
name|i
index|]
operator|->
name|succ
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|succ_next
control|)
if|if
condition|(
name|ae
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|ae
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|ae
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|bord_bbs
index|[
name|n_bord_bbs
operator|++
index|]
operator|=
name|ae
operator|->
name|dest
expr_stmt|;
block|}
block|}
comment|/* Remove the path.  */
name|from
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
operator|!
name|loop_delete_branch_edge
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dom_bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cancel loops contained in the path.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrem
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rem_bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|->
name|header
operator|==
name|rem_bbs
index|[
name|i
index|]
condition|)
name|cancel_loop_tree
argument_list|(
name|loops
argument_list|,
name|rem_bbs
index|[
name|i
index|]
operator|->
name|loop_father
argument_list|)
expr_stmt|;
name|remove_bbs
argument_list|(
name|rem_bbs
argument_list|,
name|nrem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rem_bbs
argument_list|)
expr_stmt|;
comment|/* Find blocks whose dominators may be affected.  */
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bord_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|ldom
decl_stmt|;
name|bb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bord_bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|ldom
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|ldom
condition|;
name|ldom
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ldom
argument_list|)
control|)
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|from
argument_list|,
name|ldom
argument_list|)
condition|)
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
expr_stmt|;
block|}
name|free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
comment|/* Recount dominators.  */
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
comment|/* These blocks have lost some predecessor(s), thus their irreducible      status could be changed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bord_bbs
condition|;
name|i
operator|++
control|)
name|fix_irreducible_loops
argument_list|(
name|bord_bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bord_bbs
argument_list|)
expr_stmt|;
comment|/* Fix placements of basic blocks inside loops and the placement of      loops in the loop tree.  */
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fix_loop_placements
argument_list|(
name|loops
argument_list|,
name|from
operator|->
name|loop_father
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Predicate for enumeration in add_loop.  */
end_comment

begin_function
specifier|static
name|bool
name|alp_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|alp_header
parameter_list|)
block|{
return|return
name|bb
operator|!=
operator|(
name|basic_block
operator|)
name|alp_header
return|;
block|}
end_function

begin_comment
comment|/* Given LOOP structure with filled header and latch, find the body of the    corresponding loop and add it to LOOPS tree.  */
end_comment

begin_function
specifier|static
name|void
name|add_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* Add it to loop structure.  */
name|place_new_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|level
operator|=
literal|1
expr_stmt|;
comment|/* Find its nodes.  */
name|bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|dfs_enumerate_from
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
literal|1
argument_list|,
name|alp_enum_p
argument_list|,
name|bbs
argument_list|,
name|n_basic_blocks
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|add_bb_to_loop
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply all frequencies of basic blocks in array BBS of length NBBS    by NUM/DEN.  */
end_comment

begin_function
specifier|static
name|void
name|scale_bbs_frequencies
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|den
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|=
operator|(
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|*
name|num
operator|)
operator|/
name|den
expr_stmt|;
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|=
operator|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|*
name|num
operator|)
operator|/
name|den
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bbs
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|count
operator|=
operator|(
name|e
operator|->
name|count
operator|*
name|num
operator|)
operator|/
name|den
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Multiply all frequencies in LOOP by NUM/DEN.  */
end_comment

begin_function
specifier|static
name|void
name|scale_loop_frequencies
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|den
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|scale_bbs_frequencies
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|,
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting    latch to header and update loop tree stored in LOOPS and dominators    accordingly. Everything between them plus LATCH_EDGE destination must    be dominated by HEADER_EDGE destination, and back-reachable from    LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,    SWITCH_BB->succ to original destination of LATCH_EDGE and    SWITCH_BB->succ->succ_next to original destination of HEADER_EDGE.    Returns newly created loop.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|loopify
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|latch_edge
parameter_list|,
name|edge
name|header_edge
parameter_list|,
name|basic_block
name|switch_bb
parameter_list|)
block|{
name|basic_block
name|succ_bb
init|=
name|latch_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|pred_bb
init|=
name|header_edge
operator|->
name|src
decl_stmt|;
name|basic_block
modifier|*
name|dom_bbs
decl_stmt|,
modifier|*
name|body
decl_stmt|;
name|unsigned
name|n_dom_bbs
decl_stmt|,
name|i
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|outer
init|=
name|succ_bb
operator|->
name|loop_father
operator|->
name|outer
decl_stmt|;
name|int
name|freq
decl_stmt|,
name|prob
decl_stmt|,
name|tot_prob
decl_stmt|;
name|gcov_type
name|cnt
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|loop
operator|->
name|header
operator|=
name|header_edge
operator|->
name|dest
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|latch_edge
operator|->
name|src
expr_stmt|;
name|freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|header_edge
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|header_edge
operator|->
name|count
expr_stmt|;
name|prob
operator|=
name|switch_bb
operator|->
name|succ
operator|->
name|probability
expr_stmt|;
name|tot_prob
operator|=
name|prob
operator|+
name|switch_bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|tot_prob
operator|==
literal|0
condition|)
name|tot_prob
operator|=
literal|1
expr_stmt|;
comment|/* Redirect edges.  */
name|loop_redirect_edge
argument_list|(
name|latch_edge
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|loop_redirect_edge
argument_list|(
name|header_edge
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
name|loop_redirect_edge
argument_list|(
name|switch_bb
operator|->
name|succ
operator|->
name|succ_next
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|loop_redirect_edge
argument_list|(
name|switch_bb
operator|->
name|succ
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
comment|/* Update dominators.  */
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|switch_bb
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|header
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|succ_bb
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
comment|/* Compute new loop.  */
name|add_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|outer
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/* Add switch_bb to appropriate loop.  */
name|add_bb_to_loop
argument_list|(
name|switch_bb
argument_list|,
name|outer
argument_list|)
expr_stmt|;
comment|/* Fix frequencies.  */
name|switch_bb
operator|->
name|frequency
operator|=
name|freq
expr_stmt|;
name|switch_bb
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
for|for
control|(
name|e
operator|=
name|switch_bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|count
operator|=
operator|(
name|switch_bb
operator|->
name|count
operator|*
name|e
operator|->
name|probability
operator|)
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|scale_loop_frequencies
argument_list|(
name|loop
argument_list|,
name|prob
argument_list|,
name|tot_prob
argument_list|)
expr_stmt|;
name|scale_loop_frequencies
argument_list|(
name|succ_bb
operator|->
name|loop_father
argument_list|,
name|tot_prob
operator|-
name|prob
argument_list|,
name|tot_prob
argument_list|)
expr_stmt|;
comment|/* Update dominators of blocks outside of LOOP.  */
name|dom_bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|body
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|ldom
decl_stmt|;
for|for
control|(
name|ldom
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|body
index|[
name|i
index|]
argument_list|)
init|;
name|ldom
condition|;
name|ldom
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ldom
argument_list|)
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|ldom
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|ldom
operator|->
name|index
argument_list|)
expr_stmt|;
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
expr_stmt|;
block|}
block|}
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
return|return
name|loop
return|;
block|}
end_function

begin_comment
comment|/* Remove the latch edge of a LOOP and update LOOPS tree to indicate that    the LOOP was removed.  After this function, original loop latch will    have no successor, which caller is expected to fix somehow.  */
end_comment

begin_function
name|void
name|unloop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|;
name|struct
name|loop
modifier|*
name|ploop
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
name|latch
init|=
name|loop
operator|->
name|latch
decl_stmt|;
name|edge
modifier|*
name|edges
decl_stmt|;
name|unsigned
name|n_edges
decl_stmt|;
comment|/* This is relatively straightforward.  The dominators are unchanged, as      loop header dominates loop latch, so the only thing we have to care of      is the placement of loops and basic blocks inside the loop tree.  We      move them all to the loop->outer, and then let fix_bb_placements do      its work.  */
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|edges
operator|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_edges
argument_list|)
expr_stmt|;
name|n
operator|=
name|loop
operator|->
name|num_nodes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
name|remove_bb_from_loops
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|body
index|[
name|i
index|]
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
name|ploop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
name|flow_loop_tree_node_remove
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|loop
operator|->
name|outer
argument_list|,
name|ploop
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the loop and free its data.  */
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
name|loop
operator|->
name|num
index|]
operator|=
name|NULL
expr_stmt|;
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|latch
operator|->
name|succ
argument_list|)
expr_stmt|;
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|latch
argument_list|)
expr_stmt|;
comment|/* If the loop was inside an irreducible region, we would have to somehow      update the irreducible marks inside its body.  While it is certainly      possible to do, it is a bit complicated and this situation should be      very rare, so we just remark all loops in this case.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_edges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|edges
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|n_edges
condition|)
name|mark_irreducible_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop    FATHER of LOOP such that all of the edges coming out of LOOP belong to    FATHER, and set it as outer loop of LOOP.  Return 1 if placement of    LOOP changed.  */
end_comment

begin_function
name|int
name|fix_loop_placement
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|father
init|=
name|loop
operator|->
name|pred
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|act
decl_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|e
operator|=
name|body
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|act
operator|=
name|find_common_loop
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|father
argument_list|,
name|act
argument_list|)
condition|)
name|father
operator|=
name|act
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|father
operator|!=
name|loop
operator|->
name|outer
condition|)
block|{
for|for
control|(
name|act
operator|=
name|loop
operator|->
name|outer
init|;
name|act
operator|!=
name|father
condition|;
name|act
operator|=
name|act
operator|->
name|outer
control|)
name|act
operator|->
name|num_nodes
operator|-=
name|loop
operator|->
name|num_nodes
expr_stmt|;
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|flow_loop_tree_node_add
argument_list|(
name|father
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fix placement of superloops of LOOP inside loop tree, i.e. ensure that    condition stated in description of fix_loop_placement holds for them.    It is used in case when we removed some edges coming out of LOOP, which    may cause the right placement of LOOP inside loop tree to change.  */
end_comment

begin_function
specifier|static
name|void
name|fix_loop_placements
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|outer
decl_stmt|;
while|while
condition|(
name|loop
operator|->
name|outer
condition|)
block|{
name|outer
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
if|if
condition|(
operator|!
name|fix_loop_placement
argument_list|(
name|loop
argument_list|)
condition|)
break|break;
comment|/* Changing the placement of a loop in the loop tree may alter the 	 validity of condition 2) of the description of fix_bb_placement 	 for its preheader, because the successor is the header and belongs 	 to the loop.  So call fix_bb_placements to fix up the placement 	 of the preheader and (possibly) of its predecessors.  */
name|fix_bb_placements
argument_list|(
name|loops
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
argument_list|)
expr_stmt|;
name|loop
operator|=
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates place for a new LOOP in LOOPS structure.  */
end_comment

begin_function
specifier|static
name|void
name|place_new_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loops
operator|->
name|parray
operator|=
name|xrealloc
argument_list|(
name|loops
operator|->
name|parray
argument_list|,
operator|(
name|loops
operator|->
name|num
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
name|loops
operator|->
name|num
index|]
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|num
operator|=
name|loops
operator|->
name|num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies copy of LOOP as subloop of TARGET loop, placing newly    created loop into LOOPS structure.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|duplicate_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|;
name|cloop
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|place_new_loop
argument_list|(
name|loops
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
comment|/* Initialize copied loop.  */
name|cloop
operator|->
name|level
operator|=
name|loop
operator|->
name|level
expr_stmt|;
comment|/* Set it as copy of loop.  */
name|loop
operator|->
name|copy
operator|=
name|cloop
expr_stmt|;
comment|/* Add it to target.  */
name|flow_loop_tree_node_add
argument_list|(
name|target
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
return|return
name|cloop
return|;
block|}
end_function

begin_comment
comment|/* Copies structure of subloops of LOOP into TARGET loop, placing    newly created loops into loop tree stored in LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|duplicate_subloops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|aloop
decl_stmt|,
modifier|*
name|cloop
decl_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
control|)
block|{
name|cloop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|aloop
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|duplicate_subloops
argument_list|(
name|loops
argument_list|,
name|aloop
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,    into TARGET loop, placing newly created loops into loop tree LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|copy_loops_to
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
modifier|*
name|copied_loops
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|loop
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|aloop
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|aloop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|copied_loops
index|[
name|i
index|]
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|duplicate_subloops
argument_list|(
name|loops
argument_list|,
name|copied_loops
index|[
name|i
index|]
argument_list|,
name|aloop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redirects edge E to basic block DEST.  */
end_comment

begin_function
specifier|static
name|void
name|loop_redirect_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dest
condition|)
return|return;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,    just test whether it is possible to remove the edge.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_delete_branch_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|really_delete
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|int
name|irr
decl_stmt|;
name|edge
name|snd
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|basic_block
name|newdest
decl_stmt|;
comment|/* Cannot handle more than two exit edges.  */
if|if
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|false
return|;
comment|/* And it must be just a simple branch.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|snd
operator|=
name|e
operator|==
name|src
operator|->
name|succ
condition|?
name|src
operator|->
name|succ
operator|->
name|succ_next
else|:
name|src
operator|->
name|succ
expr_stmt|;
name|newdest
operator|=
name|snd
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|newdest
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Hopefully the above conditions should suffice.  */
if|if
condition|(
operator|!
name|really_delete
condition|)
return|return
name|true
return|;
comment|/* Redirecting behaves wrongly wrto this flag.  */
name|irr
operator|=
name|snd
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|newdest
argument_list|)
condition|)
return|return
name|false
return|;
name|src
operator|->
name|succ
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|src
operator|->
name|succ
operator|->
name|flags
operator||=
name|irr
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* Cannot happen -- we are using this only to remove an edge 	 from branch.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
comment|/* To avoid warning, cannot get here.  */
block|}
end_function

begin_comment
comment|/* Check whether LOOP's body can be duplicated.  */
end_comment

begin_function
name|bool
name|can_duplicate_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|ret
operator|=
name|can_copy_bbs_p
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RDIV
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|(((X) + (Y) / 2) / (Y))
end_define

begin_comment
comment|/* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating    LOOPS structure and dominators.  E's destination must be LOOP header for    this to work, i.e. it must be entry or latch edge of this loop; these are    unique, as the loops must have preheaders for this function to work    correctly (in case E is latch, the function unrolls the loop, if E is entry    edge, it peels the loop).  Store edges created by copying ORIG edge from    copies corresponding to set bits in WONT_EXIT bitmap (bit 0 corresponds to    original LOOP body, the other copies are numbered in order given by control    flow through them) into TO_REMOVE array.  Returns false if duplication is    impossible.  */
end_comment

begin_function
name|int
name|duplicate_loop_to_header_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|unsigned
name|int
name|ndupl
parameter_list|,
name|sbitmap
name|wont_exit
parameter_list|,
name|edge
name|orig
parameter_list|,
name|edge
modifier|*
name|to_remove
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_to_remove
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|target
decl_stmt|,
modifier|*
name|aloop
decl_stmt|;
name|struct
name|loop
modifier|*
modifier|*
name|orig_loops
decl_stmt|;
name|unsigned
name|n_orig_loops
decl_stmt|;
name|basic_block
name|header
init|=
name|loop
operator|->
name|header
decl_stmt|,
name|latch
init|=
name|loop
operator|->
name|latch
decl_stmt|;
name|basic_block
modifier|*
name|new_bbs
decl_stmt|,
modifier|*
name|bbs
decl_stmt|,
modifier|*
name|first_active
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|,
name|bb
decl_stmt|,
name|first_active_latch
init|=
name|NULL
decl_stmt|;
name|edge
name|ae
decl_stmt|,
name|latch_edge
decl_stmt|;
name|edge
name|spec_edges
index|[
literal|2
index|]
decl_stmt|,
name|new_spec_edges
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|SE_LATCH
value|0
define|#
directive|define
name|SE_ORIG
value|1
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|is_latch
init|=
operator|(
name|latch
operator|==
name|e
operator|->
name|src
operator|)
decl_stmt|;
name|int
name|scale_act
init|=
literal|0
decl_stmt|,
modifier|*
name|scale_step
init|=
name|NULL
decl_stmt|,
name|scale_main
init|=
literal|0
decl_stmt|;
name|int
name|p
decl_stmt|,
name|freq_in
decl_stmt|,
name|freq_le
decl_stmt|,
name|freq_out_orig
decl_stmt|;
name|int
name|prob_pass_thru
decl_stmt|,
name|prob_pass_wont_exit
decl_stmt|,
name|prob_pass_main
decl_stmt|;
name|int
name|add_irreducible_flag
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ndupl
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig
condition|)
block|{
comment|/* Orig must be edge out of the loop.  */
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|orig
operator|->
name|src
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|orig
operator|->
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check whether duplication is possible.  */
if|if
condition|(
operator|!
name|can_copy_bbs_p
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|new_bbs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
comment|/* In case we are doing loop peeling and the loop is in the middle of      irreducible region, the peeled copies will be inside it too.  */
name|add_irreducible_flag
operator|=
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
name|is_latch
operator|&&
name|add_irreducible_flag
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find edge from latch.  */
name|latch_edge
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
comment|/* Calculate coefficients by that we have to scale frequencies 	 of duplicated loop bodies.  */
name|freq_in
operator|=
name|header
operator|->
name|frequency
expr_stmt|;
name|freq_le
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|latch_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_in
operator|==
literal|0
condition|)
name|freq_in
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|freq_in
operator|<
name|freq_le
condition|)
name|freq_in
operator|=
name|freq_le
expr_stmt|;
name|freq_out_orig
operator|=
name|orig
condition|?
name|EDGE_FREQUENCY
argument_list|(
name|orig
argument_list|)
else|:
name|freq_in
operator|-
name|freq_le
expr_stmt|;
if|if
condition|(
name|freq_out_orig
operator|>
name|freq_in
operator|-
name|freq_le
condition|)
name|freq_out_orig
operator|=
name|freq_in
operator|-
name|freq_le
expr_stmt|;
name|prob_pass_thru
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|freq_le
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
name|prob_pass_wont_exit
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
operator|(
name|freq_le
operator|+
name|freq_out_orig
operator|)
argument_list|,
name|freq_in
argument_list|)
expr_stmt|;
name|scale_step
operator|=
name|xmalloc
argument_list|(
name|ndupl
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ndupl
condition|;
name|i
operator|++
control|)
name|scale_step
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
name|i
argument_list|)
condition|?
name|prob_pass_wont_exit
else|:
name|prob_pass_thru
expr_stmt|;
if|if
condition|(
name|is_latch
condition|)
block|{
name|prob_pass_main
operator|=
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
condition|?
name|prob_pass_wont_exit
else|:
name|prob_pass_thru
expr_stmt|;
name|p
operator|=
name|prob_pass_main
expr_stmt|;
name|scale_main
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
block|{
name|scale_main
operator|+=
name|p
expr_stmt|;
name|p
operator|=
name|RDIV
argument_list|(
name|p
operator|*
name|scale_step
index|[
name|i
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
name|scale_main
operator|=
name|RDIV
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|REG_BR_PROB_BASE
argument_list|,
name|scale_main
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|RDIV
argument_list|(
name|scale_main
operator|*
name|prob_pass_main
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale_main
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
name|scale_main
operator|=
name|RDIV
argument_list|(
name|scale_main
operator|*
name|scale_step
index|[
name|i
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob_pass_thru
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndupl
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|scale_step
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|scale_step
index|[
name|i
index|]
operator|>
name|REG_BR_PROB_BASE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|scale_main
operator|<
literal|0
operator|||
name|scale_main
operator|>
name|REG_BR_PROB_BASE
operator|||
name|scale_act
operator|<
literal|0
operator|||
name|scale_act
operator|>
name|REG_BR_PROB_BASE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Loop the new bbs will belong to.  */
name|target
operator|=
name|e
operator|->
name|src
operator|->
name|loop_father
expr_stmt|;
comment|/* Original loops.  */
name|n_orig_loops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
control|)
name|n_orig_loops
operator|++
expr_stmt|;
name|orig_loops
operator|=
name|xcalloc
argument_list|(
name|n_orig_loops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|aloop
operator|=
name|loop
operator|->
name|inner
operator|,
name|i
operator|=
literal|0
init|;
name|aloop
condition|;
name|aloop
operator|=
name|aloop
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|orig_loops
index|[
name|i
index|]
operator|=
name|aloop
expr_stmt|;
name|loop
operator|->
name|copy
operator|=
name|target
expr_stmt|;
name|n
operator|=
name|loop
operator|->
name|num_nodes
expr_stmt|;
name|first_active
operator|=
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_latch
condition|)
block|{
name|memcpy
argument_list|(
name|first_active
argument_list|,
name|bbs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_active_latch
operator|=
name|latch
expr_stmt|;
block|}
comment|/* Record exit edge in original loop body.  */
if|if
condition|(
name|orig
operator|&&
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
condition|)
name|to_remove
index|[
operator|(
operator|*
name|n_to_remove
operator|)
operator|++
index|]
operator|=
name|orig
expr_stmt|;
name|spec_edges
index|[
name|SE_ORIG
index|]
operator|=
name|orig
expr_stmt|;
name|spec_edges
index|[
name|SE_LATCH
index|]
operator|=
name|latch_edge
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndupl
condition|;
name|j
operator|++
control|)
block|{
comment|/* Copy loops.  */
name|copy_loops_to
argument_list|(
name|loops
argument_list|,
name|orig_loops
argument_list|,
name|n_orig_loops
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Copy bbs.  */
name|copy_bbs
argument_list|(
name|bbs
argument_list|,
name|n
argument_list|,
name|new_bbs
argument_list|,
name|spec_edges
argument_list|,
literal|2
argument_list|,
name|new_spec_edges
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/* Note whether the blocks and edges belong to an irreducible loop.  */
if|if
condition|(
name|add_irreducible_flag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|new_bbs
index|[
name|i
index|]
operator|->
name|rbi
operator|->
name|duplicated
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|new_bb
operator|=
name|new_bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new_bb
operator|->
name|loop_father
operator|==
name|target
condition|)
name|new_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
for|for
control|(
name|ae
operator|=
name|new_bb
operator|->
name|succ
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|succ_next
control|)
if|if
condition|(
name|ae
operator|->
name|dest
operator|->
name|rbi
operator|->
name|duplicated
operator|&&
operator|(
name|ae
operator|->
name|src
operator|->
name|loop_father
operator|==
name|target
operator|||
name|ae
operator|->
name|dest
operator|->
name|loop_father
operator|==
name|target
operator|)
condition|)
name|ae
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|new_bbs
index|[
name|i
index|]
operator|->
name|rbi
operator|->
name|duplicated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Redirect the special edges.  */
if|if
condition|(
name|is_latch
condition|)
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|latch_edge
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|new_spec_edges
index|[
name|SE_LATCH
index|]
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|,
name|latch
argument_list|)
expr_stmt|;
name|latch
operator|=
name|loop
operator|->
name|latch
operator|=
name|new_bbs
index|[
literal|1
index|]
expr_stmt|;
name|e
operator|=
name|latch_edge
operator|=
name|new_spec_edges
index|[
name|SE_LATCH
index|]
expr_stmt|;
block|}
else|else
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|new_spec_edges
index|[
name|SE_LATCH
index|]
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bbs
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|e
operator|=
name|new_spec_edges
index|[
name|SE_LATCH
index|]
expr_stmt|;
block|}
comment|/* Record exit edge in this copy.  */
if|if
condition|(
name|orig
operator|&&
name|TEST_BIT
argument_list|(
name|wont_exit
argument_list|,
name|j
operator|+
literal|1
argument_list|)
condition|)
name|to_remove
index|[
operator|(
operator|*
name|n_to_remove
operator|)
operator|++
index|]
operator|=
name|new_spec_edges
index|[
name|SE_ORIG
index|]
expr_stmt|;
comment|/* Record the first copy in the control flow order if it is not 	 the original loop (i.e. in case of peeling).  */
if|if
condition|(
operator|!
name|first_active_latch
condition|)
block|{
name|memcpy
argument_list|(
name|first_active
argument_list|,
name|new_bbs
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_active_latch
operator|=
name|new_bbs
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* Set counts and frequencies.  */
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
name|scale_bbs_frequencies
argument_list|(
name|new_bbs
argument_list|,
name|n
argument_list|,
name|scale_act
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|scale_act
operator|=
name|RDIV
argument_list|(
name|scale_act
operator|*
name|scale_step
index|[
name|j
index|]
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|new_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig_loops
argument_list|)
expr_stmt|;
comment|/* Update the original loop.  */
if|if
condition|(
operator|!
name|is_latch
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DLTHE_FLAG_UPDATE_FREQ
condition|)
block|{
name|scale_bbs_frequencies
argument_list|(
name|bbs
argument_list|,
name|n
argument_list|,
name|scale_main
argument_list|,
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scale_step
argument_list|)
expr_stmt|;
block|}
comment|/* Update dominators of outer blocks if affected.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|dominated
decl_stmt|,
name|dom_bb
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|;
name|int
name|n_dom_bbs
decl_stmt|,
name|j
decl_stmt|;
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|n_dom_bbs
operator|=
name|get_dominated_by
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
operator|&
name|dom_bbs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_dom_bbs
condition|;
name|j
operator|++
control|)
block|{
name|dominated
operator|=
name|dom_bbs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|dominated
argument_list|)
condition|)
continue|continue;
name|dom_bb
operator|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|first_active
index|[
name|i
index|]
argument_list|,
name|first_active_latch
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dominated
argument_list|,
name|dom_bb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|first_active
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Creates a pre-header for a LOOP.  Returns newly created block.  Unless    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single    entry; otherwise we also force preheader block to have only one successor.    The function also updates dominators stored in DOM.  */
end_comment

begin_function
specifier|static
name|basic_block
name|create_preheader
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|fallthru
decl_stmt|;
name|basic_block
name|dummy
decl_stmt|;
name|basic_block
name|jump
decl_stmt|,
name|src
init|=
literal|0
decl_stmt|;
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|,
modifier|*
name|ploop
decl_stmt|;
name|int
name|nentry
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|cloop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
continue|continue;
name|nentry
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nentry
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CP_SIMPLE_PREHEADERS
operator|)
operator|||
operator|!
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
condition|)
return|return
name|NULL
return|;
block|}
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
comment|/* Split_block would not split block after its end.  */
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|fallthru
operator|=
name|split_block
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|fallthru
operator|->
name|src
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
comment|/* The header could be a latch of some superloop(s); due to design of      split_block, it would now move to fallthru->dest.  */
for|for
control|(
name|ploop
operator|=
name|loop
init|;
name|ploop
condition|;
name|ploop
operator|=
name|ploop
operator|->
name|outer
control|)
if|if
condition|(
name|ploop
operator|->
name|latch
operator|==
name|dummy
condition|)
name|ploop
operator|->
name|latch
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|fallthru
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* Redirect edges.  */
for|for
control|(
name|e
operator|=
name|dummy
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dummy
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
name|fallthru
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
name|jump
operator|=
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
block|{
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|jump
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|jump
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|jump
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|jump
expr_stmt|;
block|}
comment|/* Update structures.  */
name|redirect_immediate_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dummy
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|header
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|loop
operator|->
name|header
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|dummy
argument_list|,
name|cloop
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Created preheader block for loop %i\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|dummy
return|;
block|}
end_function

begin_comment
comment|/* Create preheaders for each loop from loop tree stored in LOOPS; for meaning    of FLAGS see create_preheader.  */
end_comment

begin_function
name|void
name|create_preheaders
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|create_preheader
argument_list|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_PREHEADERS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forces all loop latches of loops from loop tree LOOPS to have only single    successor.  */
end_comment

begin_function
name|void
name|force_single_succ_latches
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|!=
name|loop
operator|->
name|header
operator|&&
operator|!
name|loop
operator|->
name|latch
operator|->
name|succ
operator|->
name|succ_next
condition|)
continue|continue;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
operator|->
name|src
operator|!=
name|loop
operator|->
name|latch
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
continue|continue;
name|loop_split_edge_with
argument_list|(
name|e
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_SIMPLE_LATCHES
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A quite stupid function to put INSNS on edge E. They are supposed to form    just one basic block.  Jumps in INSNS are not handled, so cfg do not have to    be ok after this function.  The created block is placed on correct place    in LOOPS structure and its dominator is set.  */
end_comment

begin_function
name|basic_block
name|loop_split_edge_with
parameter_list|(
name|edge
name|e
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|new_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop_c
decl_stmt|;
name|edge
name|new_e
decl_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|loop_c
operator|=
name|find_common_loop
argument_list|(
name|src
operator|->
name|loop_father
argument_list|,
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
comment|/* Create basic block for it.  */
name|new_bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|new_bb
argument_list|,
name|loop_c
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|flags
operator|=
name|insns
condition|?
name|BB_SUPERBLOCK
else|:
literal|0
expr_stmt|;
name|new_e
operator|=
name|new_bb
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
block|{
name|new_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|new_e
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
if|if
condition|(
name|insns
condition|)
name|emit_insn_after
argument_list|(
name|insns
argument_list|,
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|,
name|recount_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|src
condition|)
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|=
name|new_bb
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

end_unit

