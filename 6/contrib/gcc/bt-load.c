begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform branch target register load optimizations.    Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Target register optimizations - these are performed after reload.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|btr_def_group_s
block|{
name|struct
name|btr_def_group_s
modifier|*
name|next
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|struct
name|btr_def_s
modifier|*
name|members
decl_stmt|;
block|}
typedef|*
name|btr_def_group
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|btr_user_s
block|{
name|struct
name|btr_user_s
modifier|*
name|next
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|luid
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* If INSN has a single use of a single branch register, then      USE points to it within INSN.  If there is more than      one branch register use, or the use is in some way ambiguous,      then USE is NULL.  */
name|rtx
name|use
decl_stmt|;
name|int
name|n_reaching_defs
decl_stmt|;
name|int
name|first_reaching_def
decl_stmt|;
name|char
name|other_use_this_block
decl_stmt|;
block|}
typedef|*
name|btr_user
typedef|;
end_typedef

begin_comment
comment|/* btr_def structs appear on three lists:      1. A list of all btr_def structures (head is 	ALL_BTR_DEFS, linked by the NEXT field).      2. A list of branch reg definitions per basic block (head is 	BB_BTR_DEFS[i], linked by the NEXT_THIS_BB field).      3. A list of all branch reg definitions belonging to the same 	group (head is in a BTR_DEF_GROUP struct, linked by 	NEXT_THIS_GROUP field).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|btr_def_s
block|{
name|struct
name|btr_def_s
modifier|*
name|next_this_bb
decl_stmt|;
name|struct
name|btr_def_s
modifier|*
name|next_this_group
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|luid
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|btr
decl_stmt|;
name|int
name|cost
decl_stmt|;
comment|/* For a branch register setting insn that has a constant      source (i.e. a label), group links together all the      insns with the same source.  For other branch register      setting insns, group is NULL.  */
name|btr_def_group
name|group
decl_stmt|;
name|btr_user
name|uses
decl_stmt|;
comment|/* If this def has a reaching use which is not a simple use      in a branch instruction, then has_ambiguous_use will be true,      and we will not attempt to migrate this definition.  */
name|char
name|has_ambiguous_use
decl_stmt|;
comment|/* live_range is an approximation to the true live range for this      def/use web, because it records the set of blocks that contain      the live range.  There could be other live ranges for the same      branch register in that set of blocks, either in the block      containing the def (before the def), or in a block containing      a use (after the use).  If there are such other live ranges, then      other_btr_uses_before_def or other_btr_uses_after_use must be set true      as appropriate.  */
name|char
name|other_btr_uses_before_def
decl_stmt|;
name|char
name|other_btr_uses_after_use
decl_stmt|;
name|bitmap
name|live_range
decl_stmt|;
block|}
typedef|*
name|btr_def
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|basic_block_freq
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insn_sets_btr_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
modifier|*
name|find_btr_use
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|btr_referenced_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_btr_reference
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_btr_def_group
parameter_list|(
name|btr_def_group
modifier|*
parameter_list|,
name|btr_def
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|btr_def
name|add_btr_def
parameter_list|(
name|fibheap_t
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|btr_def_group
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|btr_user
name|new_btr_user
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_hard_reg_set
parameter_list|(
name|HARD_REG_SET
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_btrs_live
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_other_use_this_block
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|btr_user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_defs_uses_and_gen
parameter_list|(
name|fibheap_t
parameter_list|,
name|btr_def
modifier|*
parameter_list|,
name|btr_user
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_kill
parameter_list|(
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_out
parameter_list|(
name|sbitmap
modifier|*
name|bb_out
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_btr_uses
parameter_list|(
name|btr_def
modifier|*
parameter_list|,
name|btr_user
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_btr_def_use_webs
parameter_list|(
name|fibheap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|block_at_edge_of_live_range_p
parameter_list|(
name|int
parameter_list|,
name|btr_def
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_btr_from_live_range
parameter_list|(
name|btr_def
name|def
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_btr_to_live_range
parameter_list|(
name|btr_def
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|augment_live_range
parameter_list|(
name|bitmap
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|choose_btr
parameter_list|(
name|HARD_REG_SET
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|combine_btr_defs
parameter_list|(
name|btr_def
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btr_def_live_range
parameter_list|(
name|btr_def
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_btr_def
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|btr_def
parameter_list|,
name|bitmap
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|migrate_btr_def
parameter_list|(
name|btr_def
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|migrate_btr_defs
parameter_list|(
name|enum
name|reg_class
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_move_up
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_btr_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* The following code performs code motion of target load instructions    (instructions that set branch target registers), to move them    forward away from the branch instructions and out of loops (or,    more generally, from a more frequently executed place to a less    frequently executed place).    Moving target load instructions further in front of the branch    instruction that uses the target register value means that the hardware    has a better chance of preloading the instructions at the branch    target by the time the branch is reached.  This avoids bubbles    when a taken branch needs to flush out the pipeline.    Moving target load instructions out of loops means they are executed    less frequently.  */
end_comment

begin_comment
comment|/* An obstack to hold the def-use web data structures built up for    migrating branch target load instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|migrate_btrl_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array indexed by basic block number, giving the set of registers    live in that block.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|btrs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of all target registers that we are willing to allocate.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|all_btrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Provide lower and upper bounds for target register numbers, so that    we don't need to search through all the hard registers all the time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_btr
decl_stmt|,
name|last_btr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an estimate of the frequency of execution of block bb.    If we have a profiling count available, we could use it here.  */
end_comment

begin_function
specifier|static
name|int
name|basic_block_freq
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
return|return
name|bb
operator|->
name|frequency
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|btr_reference_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A subroutine of btr_referenced_p, called through for_each_rtx.    PREG is a pointer to an rtx that is to be excluded from the    traversal.  If we find a reference to a target register anywhere    else, return 1, and put a pointer to it into btr_reference_found.  */
end_comment

begin_function
specifier|static
name|int
name|find_btr_reference
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|preg
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|px
operator|==
name|preg
condition|)
return|return
operator|-
literal|1
return|;
name|x
operator|=
operator|*
name|px
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
block|{
name|btr_reference_found
operator|=
name|px
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X references (sets or reads) any branch target register.    If EXCLUDEP is set, disregard any references within the rtx pointed to    by it.  If returning nonzero, also set btr_reference_found as above.  */
end_comment

begin_function
specifier|static
name|int
name|btr_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|excludep
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|find_btr_reference
argument_list|,
name|excludep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if insn is an instruction that sets a target register.    if CHECK_CONST is true, only return true if the source is constant.    If such a set is found and REGNO is nonzero, assign the register number    of the destination register to *REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|insn_sets_btr_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|check_const
parameter_list|,
name|int
modifier|*
name|regno
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|btr_referenced_p
argument_list|(
name|src
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|check_const
operator|||
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|regno
condition|)
operator|*
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find and return a use of a target register within an instruction INSN.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_btr_use
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|btr_referenced_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|)
condition|?
name|btr_reference_found
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find the group that the target register definition DEF belongs    to in the list starting with *ALL_BTR_DEF_GROUPS.  If no such    group exists, create one.  Add def to the group.  */
end_comment

begin_function
specifier|static
name|void
name|find_btr_def_group
parameter_list|(
name|btr_def_group
modifier|*
name|all_btr_def_groups
parameter_list|,
name|btr_def
name|def
parameter_list|)
block|{
if|if
condition|(
name|insn_sets_btr_p
argument_list|(
name|def
operator|->
name|insn
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|btr_def_group
name|this_group
decl_stmt|;
name|rtx
name|def_src
init|=
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|def
operator|->
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ?? This linear search is an efficiency concern, particularly 	 as the search will almost always fail to find a match.  */
for|for
control|(
name|this_group
operator|=
operator|*
name|all_btr_def_groups
init|;
name|this_group
operator|!=
name|NULL
condition|;
name|this_group
operator|=
name|this_group
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|def_src
argument_list|,
name|this_group
operator|->
name|src
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|this_group
condition|)
block|{
name|this_group
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|migrate_btrl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|btr_def_group_s
argument_list|)
argument_list|)
expr_stmt|;
name|this_group
operator|->
name|src
operator|=
name|def_src
expr_stmt|;
name|this_group
operator|->
name|members
operator|=
name|NULL
expr_stmt|;
name|this_group
operator|->
name|next
operator|=
operator|*
name|all_btr_def_groups
expr_stmt|;
operator|*
name|all_btr_def_groups
operator|=
name|this_group
expr_stmt|;
block|}
name|def
operator|->
name|group
operator|=
name|this_group
expr_stmt|;
name|def
operator|->
name|next_this_group
operator|=
name|this_group
operator|->
name|members
expr_stmt|;
name|this_group
operator|->
name|members
operator|=
name|def
expr_stmt|;
block|}
else|else
name|def
operator|->
name|group
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new target register definition structure, for a definition in    block BB, instruction INSN, and insert it into ALL_BTR_DEFS.  Return    the new definition.  */
end_comment

begin_function
specifier|static
name|btr_def
name|add_btr_def
parameter_list|(
name|fibheap_t
name|all_btr_defs
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|insn_luid
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|unsigned
name|int
name|dest_reg
parameter_list|,
name|int
name|other_btr_uses_before_def
parameter_list|,
name|btr_def_group
modifier|*
name|all_btr_def_groups
parameter_list|)
block|{
name|btr_def
name|this
init|=
name|obstack_alloc
argument_list|(
operator|&
name|migrate_btrl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|btr_def_s
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
name|this
operator|->
name|luid
operator|=
name|insn_luid
expr_stmt|;
name|this
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|this
operator|->
name|btr
operator|=
name|dest_reg
expr_stmt|;
name|this
operator|->
name|cost
operator|=
name|basic_block_freq
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|this
operator|->
name|has_ambiguous_use
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|other_btr_uses_before_def
operator|=
name|other_btr_uses_before_def
expr_stmt|;
name|this
operator|->
name|other_btr_uses_after_use
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|next_this_bb
operator|=
name|NULL
expr_stmt|;
name|this
operator|->
name|next_this_group
operator|=
name|NULL
expr_stmt|;
name|this
operator|->
name|uses
operator|=
name|NULL
expr_stmt|;
name|this
operator|->
name|live_range
operator|=
name|NULL
expr_stmt|;
name|find_btr_def_group
argument_list|(
name|all_btr_def_groups
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|fibheap_insert
argument_list|(
name|all_btr_defs
argument_list|,
operator|-
name|this
operator|->
name|cost
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Found target reg definition: sets %u { bb %d, insn %d }%s priority %d\n"
argument_list|,
name|dest_reg
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|this
operator|->
name|group
condition|?
literal|""
else|:
literal|":not const"
operator|)
argument_list|,
name|this
operator|->
name|cost
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/* Create a new target register user structure, for a use in block BB,    instruction INSN.  Return the new user.  */
end_comment

begin_function
specifier|static
name|btr_user
name|new_btr_user
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|insn_luid
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* This instruction reads target registers.  We need      to decide whether we can replace all target register      uses easily.    */
name|rtx
modifier|*
name|usep
init|=
name|find_btr_use
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|btr_user
name|user
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|usep
condition|)
block|{
name|int
name|unambiguous_single_use
decl_stmt|;
comment|/* We want to ensure that USE is the only use of a target 	 register in INSN, so that we know that to rewrite INSN to use 	 a different target register, all we have to do is replace USE.  */
name|unambiguous_single_use
operator|=
operator|!
name|btr_referenced_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|usep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unambiguous_single_use
condition|)
name|usep
operator|=
name|NULL
expr_stmt|;
block|}
name|use
operator|=
name|usep
condition|?
operator|*
name|usep
else|:
name|NULL_RTX
expr_stmt|;
name|user
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|migrate_btrl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|btr_user_s
argument_list|)
argument_list|)
expr_stmt|;
name|user
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
name|user
operator|->
name|luid
operator|=
name|insn_luid
expr_stmt|;
name|user
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|user
operator|->
name|use
operator|=
name|use
expr_stmt|;
name|user
operator|->
name|other_use_this_block
operator|=
literal|0
expr_stmt|;
name|user
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|user
operator|->
name|n_reaching_defs
operator|=
literal|0
expr_stmt|;
name|user
operator|->
name|first_reaching_def
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Uses target reg: { bb %d, insn %d }"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|use
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|": unambiguous use of reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|user
operator|->
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|user
return|;
block|}
end_function

begin_comment
comment|/* Write the contents of S to the dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_hard_reg_set
parameter_list|(
name|HARD_REG_SET
name|s
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|s
argument_list|,
name|reg
argument_list|)
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the set of target regs live in block BB to the dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_btrs_live
parameter_list|(
name|int
name|bb
parameter_list|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"BB%d live:"
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|dump_hard_reg_set
argument_list|(
name|btrs_live
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REGNO is the number of a branch target register that is being used or    set.  USERS_THIS_BB is a list of preceding branch target register users;    If any of them use the same register, set their other_use_this_block    flag.  */
end_comment

begin_function
specifier|static
name|void
name|note_other_use_this_block
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|btr_user
name|users_this_bb
parameter_list|)
block|{
name|btr_user
name|user
decl_stmt|;
for|for
control|(
name|user
operator|=
name|users_this_bb
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
if|if
condition|(
name|user
operator|->
name|use
operator|&&
name|REGNO
argument_list|(
name|user
operator|->
name|use
argument_list|)
operator|==
name|regno
condition|)
name|user
operator|->
name|other_use_this_block
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|btr_user
name|users_this_bb
decl_stmt|;
name|HARD_REG_SET
name|btrs_written_in_block
decl_stmt|;
name|HARD_REG_SET
name|btrs_live_in_block
decl_stmt|;
name|sbitmap
name|bb_gen
decl_stmt|;
name|sbitmap
modifier|*
name|btr_defset
decl_stmt|;
block|}
name|defs_uses_info
typedef|;
end_typedef

begin_comment
comment|/* Called via note_stores or directly to register stores into /    clobbers of a branch target register DEST that are not recognized as    straightforward definitions.  DATA points to information about the    current basic block that needs updating.  */
end_comment

begin_function
specifier|static
name|void
name|note_btr_set
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|set
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|defs_uses_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|end_regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|end_regno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|regno
operator|<
name|end_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|note_other_use_this_block
argument_list|(
name|regno
argument_list|,
name|info
operator|->
name|users_this_bb
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|->
name|btrs_written_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|->
name|btrs_live_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|info
operator|->
name|bb_gen
argument_list|,
name|info
operator|->
name|bb_gen
argument_list|,
name|info
operator|->
name|btr_defset
index|[
name|regno
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|compute_defs_uses_and_gen
parameter_list|(
name|fibheap_t
name|all_btr_defs
parameter_list|,
name|btr_def
modifier|*
name|def_array
parameter_list|,
name|btr_user
modifier|*
name|use_array
parameter_list|,
name|sbitmap
modifier|*
name|btr_defset
parameter_list|,
name|sbitmap
modifier|*
name|bb_gen
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_written
parameter_list|)
block|{
comment|/* Scan the code building up the set of all defs and all uses.      For each target register, build the set of defs of that register.      For each block, calculate the set of target registers      written in that block.      Also calculate the set of btrs ever live in that block.   */
name|int
name|i
decl_stmt|;
name|int
name|insn_luid
init|=
literal|0
decl_stmt|;
name|btr_def_group
name|all_btr_def_groups
init|=
name|NULL
decl_stmt|;
name|defs_uses_info
name|info
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|bb_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|btr_def
name|defs_this_bb
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|info
operator|.
name|users_this_bb
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|bb_gen
operator|=
name|bb_gen
index|[
name|i
index|]
expr_stmt|;
name|info
operator|.
name|btr_defset
operator|=
name|btr_defset
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|info
operator|.
name|btrs_written_in_block
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|first_btr
init|;
name|reg
operator|<=
name|last_btr
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|reg
argument_list|)
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|reg
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|,
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|,
name|insn_luid
operator|++
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|insn_uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn_sets_btr_p
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
block|{
name|btr_def
name|def
init|=
name|add_btr_def
argument_list|(
name|all_btr_defs
argument_list|,
name|bb
argument_list|,
name|insn_luid
argument_list|,
name|insn
argument_list|,
name|regno
argument_list|,
name|TEST_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|,
name|regno
argument_list|)
argument_list|,
operator|&
name|all_btr_def_groups
argument_list|)
decl_stmt|;
name|def_array
index|[
name|insn_uid
index|]
operator|=
name|def
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_written_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|bb_gen
index|[
name|i
index|]
argument_list|,
name|bb_gen
index|[
name|i
index|]
argument_list|,
name|btr_defset
index|[
name|regno
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|bb_gen
index|[
name|i
index|]
argument_list|,
name|insn_uid
argument_list|)
expr_stmt|;
name|def
operator|->
name|next_this_bb
operator|=
name|defs_this_bb
expr_stmt|;
name|defs_this_bb
operator|=
name|def
expr_stmt|;
name|SET_BIT
argument_list|(
name|btr_defset
index|[
name|regno
operator|-
name|first_btr
index|]
argument_list|,
name|insn_uid
argument_list|)
expr_stmt|;
name|note_other_use_this_block
argument_list|(
name|regno
argument_list|,
name|info
operator|.
name|users_this_bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|btr_referenced_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|btr_user
name|user
init|=
name|new_btr_user
argument_list|(
name|bb
argument_list|,
name|insn_luid
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|use_array
index|[
name|insn_uid
index|]
operator|=
name|user
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|use
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|,
name|REGNO
argument_list|(
name|user
operator|->
name|use
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|first_btr
init|;
name|reg
operator|<=
name|last_btr
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|reg
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|reg
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|user
operator|->
name|insn
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|note_other_use_this_block
argument_list|(
name|reg
argument_list|,
name|info
operator|.
name|users_this_bb
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|info
operator|.
name|btrs_live_in_block
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_btr_set
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
name|user
operator|->
name|next
operator|=
name|info
operator|.
name|users_this_bb
expr_stmt|;
name|info
operator|.
name|users_this_bb
operator|=
name|user
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|HARD_REG_SET
modifier|*
name|clobbered
init|=
operator|&
name|call_used_reg_set
decl_stmt|;
name|HARD_REG_SET
name|call_saved
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for sibcall.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|COMPL_HARD_REG_SET
argument_list|(
name|call_saved
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|clobbered
operator|=
operator|&
name|call_saved
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|first_btr
init|;
name|regno
operator|<=
name|last_btr
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|clobbered
argument_list|,
name|regno
argument_list|)
condition|)
name|note_btr_set
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|btrs_live
index|[
name|i
index|]
argument_list|,
name|info
operator|.
name|btrs_live_in_block
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|btrs_written
index|[
name|i
index|]
argument_list|,
name|info
operator|.
name|btrs_written_in_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_btrs_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|compute_kill
parameter_list|(
name|sbitmap
modifier|*
name|bb_kill
parameter_list|,
name|sbitmap
modifier|*
name|btr_defset
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_written
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* For each basic block, form the set BB_KILL - the set      of definitions that the block kills.  */
name|sbitmap_vector_zero
argument_list|(
name|bb_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|regno
operator|=
name|first_btr
init|;
name|regno
operator|<=
name|last_btr
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|regno
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|btrs_written
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|sbitmap_a_or_b
argument_list|(
name|bb_kill
index|[
name|i
index|]
argument_list|,
name|bb_kill
index|[
name|i
index|]
argument_list|,
name|btr_defset
index|[
name|regno
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|compute_out
parameter_list|(
name|sbitmap
modifier|*
name|bb_out
parameter_list|,
name|sbitmap
modifier|*
name|bb_gen
parameter_list|,
name|sbitmap
modifier|*
name|bb_kill
parameter_list|,
name|int
name|max_uid
parameter_list|)
block|{
comment|/* Perform iterative dataflow:       Initially, for all blocks, BB_OUT = BB_GEN.       For each block, 	BB_IN  = union over predecessors of BB_OUT(pred) 	BB_OUT = (BB_IN - BB_KILL) + BB_GEN      Iterate until the bb_out sets stop growing.  */
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|sbitmap
name|bb_in
init|=
name|sbitmap_alloc
argument_list|(
name|max_uid
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|sbitmap_copy
argument_list|(
name|bb_out
index|[
name|i
index|]
argument_list|,
name|bb_gen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|sbitmap_union_of_preds
argument_list|(
name|bb_in
argument_list|,
name|bb_out
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff_cg
argument_list|(
name|bb_out
index|[
name|i
index|]
argument_list|,
name|bb_gen
index|[
name|i
index|]
argument_list|,
name|bb_in
argument_list|,
name|bb_kill
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|bb_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_btr_uses
parameter_list|(
name|btr_def
modifier|*
name|def_array
parameter_list|,
name|btr_user
modifier|*
name|use_array
parameter_list|,
name|sbitmap
modifier|*
name|bb_out
parameter_list|,
name|sbitmap
modifier|*
name|btr_defset
parameter_list|,
name|int
name|max_uid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sbitmap
name|reaching_defs
init|=
name|sbitmap_alloc
argument_list|(
name|max_uid
argument_list|)
decl_stmt|;
comment|/* Link uses to the uses lists of all of their reaching defs.      Count up the number of reaching defs of each use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|sbitmap_union_of_preds
argument_list|(
name|reaching_defs
argument_list|,
name|bb_out
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|,
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|insn_uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|btr_def
name|def
init|=
name|def_array
index|[
name|insn_uid
index|]
decl_stmt|;
name|btr_user
name|user
init|=
name|use_array
index|[
name|insn_uid
index|]
decl_stmt|;
if|if
condition|(
name|def
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove all reaching defs of regno except 		     for this one.  */
name|sbitmap_difference
argument_list|(
name|reaching_defs
argument_list|,
name|reaching_defs
argument_list|,
name|btr_defset
index|[
name|def
operator|->
name|btr
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|reaching_defs
argument_list|,
name|insn_uid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user
operator|!=
name|NULL
condition|)
block|{
comment|/* Find all the reaching defs for this use.  */
name|sbitmap
name|reaching_defs_of_reg
init|=
name|sbitmap_alloc
argument_list|(
name|max_uid
argument_list|)
decl_stmt|;
name|int
name|uid
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|use
condition|)
name|sbitmap_a_and_b
argument_list|(
name|reaching_defs_of_reg
argument_list|,
name|reaching_defs
argument_list|,
name|btr_defset
index|[
name|REGNO
argument_list|(
name|user
operator|->
name|use
argument_list|)
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|reg
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|reaching_defs_of_reg
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|first_btr
init|;
name|reg
operator|<=
name|last_btr
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|reg
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|reg
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|user
operator|->
name|insn
argument_list|,
name|NULL
argument_list|)
condition|)
name|sbitmap_a_or_b_and_c
argument_list|(
name|reaching_defs_of_reg
argument_list|,
name|reaching_defs_of_reg
argument_list|,
name|reaching_defs
argument_list|,
name|btr_defset
index|[
name|reg
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|reaching_defs_of_reg
argument_list|,
literal|0
argument_list|,
argument|uid
argument_list|,
argument|{ 		      btr_def def = def_array[uid];
comment|/* We now know that def reaches user.  */
argument|if (rtl_dump_file) 			fprintf (rtl_dump_file,
literal|"Def in insn %d reaches use in insn %d\n"
argument|, 			  uid, insn_uid);  		      user->n_reaching_defs++; 		      if (!user->use) 			def->has_ambiguous_use =
literal|1
argument|; 		      if (user->first_reaching_def != -
literal|1
argument|) 			{
comment|/* There is more than one reaching def.  This is 			     a rare case, so just give up on this def/use 			     web when it occurs.  */
argument|def->has_ambiguous_use =
literal|1
argument|; 			  def_array[user->first_reaching_def] 			    ->has_ambiguous_use =
literal|1
argument|; 			  if (rtl_dump_file) 			    fprintf (rtl_dump_file,
literal|"(use %d has multiple reaching defs)\n"
argument|, 				     insn_uid); 			} 		      else 			user->first_reaching_def = uid; 		      if (user->other_use_this_block) 			def->other_btr_uses_after_use =
literal|1
argument|; 		      user->next = def->uses; 		      def->uses = user; 		    }
argument_list|)
empty_stmt|;
name|sbitmap_free
argument_list|(
name|reaching_defs_of_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first_btr
init|;
name|regno
operator|<=
name|last_btr
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|regno
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|sbitmap_difference
argument_list|(
name|reaching_defs
argument_list|,
name|reaching_defs
argument_list|,
name|btr_defset
index|[
name|regno
operator|-
name|first_btr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|sbitmap_free
argument_list|(
name|reaching_defs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_btr_def_use_webs
parameter_list|(
name|fibheap_t
name|all_btr_defs
parameter_list|)
block|{
specifier|const
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|btr_def
modifier|*
name|def_array
init|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|btr_def
argument_list|)
argument_list|)
decl_stmt|;
name|btr_user
modifier|*
name|use_array
init|=
name|xcalloc
argument_list|(
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|btr_user
argument_list|)
argument_list|)
decl_stmt|;
name|sbitmap
modifier|*
name|btr_defset
init|=
name|sbitmap_vector_alloc
argument_list|(
operator|(
name|last_btr
operator|-
name|first_btr
operator|)
operator|+
literal|1
argument_list|,
name|max_uid
argument_list|)
decl_stmt|;
name|sbitmap
modifier|*
name|bb_gen
init|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_uid
argument_list|)
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|btrs_written
init|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
decl_stmt|;
name|sbitmap
modifier|*
name|bb_kill
decl_stmt|;
name|sbitmap
modifier|*
name|bb_out
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|btr_defset
argument_list|,
operator|(
name|last_btr
operator|-
name|first_btr
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|compute_defs_uses_and_gen
argument_list|(
name|all_btr_defs
argument_list|,
name|def_array
argument_list|,
name|use_array
argument_list|,
name|btr_defset
argument_list|,
name|bb_gen
argument_list|,
name|btrs_written
argument_list|)
expr_stmt|;
name|bb_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|compute_kill
argument_list|(
name|bb_kill
argument_list|,
name|btr_defset
argument_list|,
name|btrs_written
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|btrs_written
argument_list|)
expr_stmt|;
name|bb_out
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|compute_out
argument_list|(
name|bb_out
argument_list|,
name|bb_gen
argument_list|,
name|bb_kill
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|bb_gen
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|bb_kill
argument_list|)
expr_stmt|;
name|link_btr_uses
argument_list|(
name|def_array
argument_list|,
name|use_array
argument_list|,
name|bb_out
argument_list|,
name|btr_defset
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|bb_out
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|btr_defset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use_array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if basic block BB contains the start or end of the    live range of the definition DEF, AND there are other live    ranges of the same target register that include BB.  */
end_comment

begin_function
specifier|static
name|int
name|block_at_edge_of_live_range_p
parameter_list|(
name|int
name|bb
parameter_list|,
name|btr_def
name|def
parameter_list|)
block|{
if|if
condition|(
name|def
operator|->
name|other_btr_uses_before_def
operator|&&
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|==
name|def
operator|->
name|bb
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|def
operator|->
name|other_btr_uses_after_use
condition|)
block|{
name|btr_user
name|user
decl_stmt|;
for|for
control|(
name|user
operator|=
name|def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
if|if
condition|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|==
name|user
operator|->
name|bb
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We are removing the def/use web DEF.  The target register    used in this web is therefore no longer live in the live range    of this web, so remove it from the live set of all basic blocks    in the live range of the web.    Blocks at the boundary of the live range may contain other live    ranges for the same target register, so we have to be careful    to remove the target register from the live set of these blocks    only if they do not contain other live ranges for the same register.  */
end_comment

begin_function
specifier|static
name|void
name|clear_btr_from_live_range
parameter_list|(
name|btr_def
name|def
parameter_list|)
block|{
name|int
name|bb
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|def->live_range
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{        if ((!def->other_btr_uses_before_def&& !def->other_btr_uses_after_use) 	   || !block_at_edge_of_live_range_p (bb, def)) 	 { 	   CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr); 	   if (rtl_dump_file) 	     dump_btrs_live (bb); 	 }      }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* We are adding the def/use web DEF.  Add the target register used    in this web to the live set of all of the basic blocks that contain    the live range of the web.  */
end_comment

begin_function
specifier|static
name|void
name|add_btr_to_live_range
parameter_list|(
name|btr_def
name|def
parameter_list|)
block|{
name|int
name|bb
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|def->live_range
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{        SET_HARD_REG_BIT (btrs_live[bb], def->btr);        if (rtl_dump_file) 	 dump_btrs_live (bb);      }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Update a live range to contain the basic block NEW_BLOCK, and all    blocks on paths between the existing live range and NEW_BLOCK.    HEAD is a block contained in the existing live range that dominates    all other blocks in the existing live range.    Also add to the set BTRS_LIVE_IN_RANGE all target registers that    are live in the blocks that we add to the live range.    It is a precondition that either NEW_BLOCK dominates HEAD,or    HEAD dom NEW_BLOCK.  This is used to speed up the    implementation of this function.  */
end_comment

begin_function
specifier|static
name|void
name|augment_live_range
parameter_list|(
name|bitmap
name|live_range
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_live_in_range
parameter_list|,
name|basic_block
name|head_bb
parameter_list|,
name|basic_block
name|new_bb
parameter_list|)
block|{
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|tos
decl_stmt|;
name|tos
operator|=
name|worklist
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bb
argument_list|,
name|head_bb
argument_list|)
condition|)
operator|*
name|tos
operator|++
operator|=
name|new_bb
expr_stmt|;
elseif|else
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|head_bb
argument_list|,
name|new_bb
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|new_block
init|=
name|new_bb
operator|->
name|index
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|live_range
argument_list|,
name|new_block
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|,
name|btrs_live
index|[
name|new_block
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding block %d to live range\n"
argument_list|,
name|new_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Now live btrs are "
argument_list|)
expr_stmt|;
name|dump_hard_reg_set
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|head_bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|src
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
name|basic_block
name|bb
init|=
operator|*
operator|--
name|tos
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live_range
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|live_range
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|,
name|btrs_live
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Adding block %d to live range\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Now live btrs are "
argument_list|)
expr_stmt|;
name|dump_hard_reg_set
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live_range
argument_list|,
name|pred
operator|->
name|index
argument_list|)
condition|)
operator|*
name|tos
operator|++
operator|=
name|pred
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return the most desirable target register that is not in     the set USED_BTRS.  */
end_comment

begin_function
specifier|static
name|int
name|choose_btr
parameter_list|(
name|HARD_REG_SET
name|used_btrs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|all_btrs
argument_list|,
name|used_btrs
argument_list|,
name|give_up
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used_btrs
argument_list|,
name|regno
argument_list|)
condition|)
return|return
name|regno
return|;
block|}
name|give_up
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Calculate the set of basic blocks that contain the live range of    the def/use web DEF.    Also calculate the set of target registers that are live at time    in this live range, but ignore the live range represented by DEF    when calculating this set.  */
end_comment

begin_function
specifier|static
name|void
name|btr_def_live_range
parameter_list|(
name|btr_def
name|def
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_live_in_range
parameter_list|)
block|{
if|if
condition|(
operator|!
name|def
operator|->
name|live_range
condition|)
block|{
name|btr_user
name|user
decl_stmt|;
name|def
operator|->
name|live_range
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|def
operator|->
name|live_range
argument_list|,
name|def
operator|->
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|,
name|btrs_live
index|[
name|def
operator|->
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|user
operator|=
name|def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
name|augment_live_range
argument_list|(
name|def
operator|->
name|live_range
argument_list|,
name|btrs_live_in_range
argument_list|,
name|def
operator|->
name|bb
argument_list|,
name|user
operator|->
name|bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* def->live_range is accurate, but we need to recompute 	 the set of target registers live over it, because migration 	 of other PT instructions may have affected it.       */
name|int
name|bb
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|def->live_range
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{ 	   IOR_HARD_REG_SET (*btrs_live_in_range, 	     btrs_live[bb]); 	 }
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|def
operator|->
name|other_btr_uses_before_def
operator|&&
operator|!
name|def
operator|->
name|other_btr_uses_after_use
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|,
name|def
operator|->
name|btr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge into the def/use web DEF any other def/use webs in the same    group that are dominated by DEF, provided that there is a target    register available to allocate to the merged web.  */
end_comment

begin_function
specifier|static
name|void
name|combine_btr_defs
parameter_list|(
name|btr_def
name|def
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_live_in_range
parameter_list|)
block|{
name|btr_def
name|other_def
decl_stmt|;
for|for
control|(
name|other_def
operator|=
name|def
operator|->
name|group
operator|->
name|members
init|;
name|other_def
operator|!=
name|NULL
condition|;
name|other_def
operator|=
name|other_def
operator|->
name|next_this_group
control|)
block|{
if|if
condition|(
name|other_def
operator|!=
name|def
operator|&&
name|other_def
operator|->
name|uses
operator|!=
name|NULL
operator|&&
operator|!
name|other_def
operator|->
name|has_ambiguous_use
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|other_def
operator|->
name|bb
argument_list|,
name|def
operator|->
name|bb
argument_list|)
condition|)
block|{
comment|/* def->bb dominates the other def, so def and other_def could 	     be combined.  */
comment|/* Merge their live ranges, and get the set of 	     target registers live over the merged range.  */
name|int
name|btr
decl_stmt|;
name|HARD_REG_SET
name|combined_btrs_live
decl_stmt|;
name|bitmap
name|combined_live_range
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
name|btr_user
name|user
decl_stmt|;
if|if
condition|(
name|other_def
operator|->
name|live_range
operator|==
name|NULL
condition|)
block|{
name|HARD_REG_SET
name|dummy_btrs_live_in_range
decl_stmt|;
name|btr_def_live_range
argument_list|(
name|other_def
argument_list|,
operator|&
name|dummy_btrs_live_in_range
argument_list|)
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|combined_btrs_live
argument_list|,
operator|*
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|combined_live_range
argument_list|,
name|def
operator|->
name|live_range
argument_list|)
expr_stmt|;
for|for
control|(
name|user
operator|=
name|other_def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
name|augment_live_range
argument_list|(
name|combined_live_range
argument_list|,
operator|&
name|combined_btrs_live
argument_list|,
name|def
operator|->
name|bb
argument_list|,
name|user
operator|->
name|bb
argument_list|)
expr_stmt|;
name|btr
operator|=
name|choose_btr
argument_list|(
name|combined_btrs_live
argument_list|)
expr_stmt|;
if|if
condition|(
name|btr
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We can combine them.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Combining def in insn %d with def in insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|other_def
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|def
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|def
operator|->
name|btr
operator|=
name|btr
expr_stmt|;
name|user
operator|=
name|other_def
operator|->
name|uses
expr_stmt|;
while|while
condition|(
name|user
operator|!=
name|NULL
condition|)
block|{
name|btr_user
name|next
init|=
name|user
operator|->
name|next
decl_stmt|;
name|user
operator|->
name|next
operator|=
name|def
operator|->
name|uses
expr_stmt|;
name|def
operator|->
name|uses
operator|=
name|user
expr_stmt|;
name|user
operator|=
name|next
expr_stmt|;
block|}
comment|/* Combining def/use webs can make target registers live 		 after uses where they previously were not.  This means 		 some REG_DEAD notes may no longer be correct.  We could 		 be more precise about this if we looked at the combined 		 live range, but here I just delete any REG_DEAD notes 		 in case they are no longer correct.  */
for|for
control|(
name|user
operator|=
name|def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
name|remove_note
argument_list|(
name|user
operator|->
name|insn
argument_list|,
name|find_regno_note
argument_list|(
name|user
operator|->
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|user
operator|->
name|use
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|clear_btr_from_live_range
argument_list|(
name|other_def
argument_list|)
expr_stmt|;
name|other_def
operator|->
name|uses
operator|=
name|NULL
expr_stmt|;
name|bitmap_copy
argument_list|(
name|def
operator|->
name|live_range
argument_list|,
name|combined_live_range
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_def
operator|->
name|other_btr_uses_after_use
condition|)
name|def
operator|->
name|other_btr_uses_after_use
operator|=
literal|1
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
operator|*
name|btrs_live_in_range
argument_list|,
name|combined_btrs_live
argument_list|)
expr_stmt|;
comment|/* Delete the old target register initialization.  */
name|delete_insn
argument_list|(
name|other_def
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|combined_live_range
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move the definition DEF from its current position to basic    block NEW_DEF_BB, and modify it to use branch target register BTR.    Delete the old defining insn, and insert a new one in NEW_DEF_BB.    Update all reaching uses of DEF in the RTL to use BTR.    If this new position means that other defs in the    same group can be combined with DEF then combine them.  */
end_comment

begin_function
specifier|static
name|void
name|move_btr_def
parameter_list|(
name|basic_block
name|new_def_bb
parameter_list|,
name|int
name|btr
parameter_list|,
name|btr_def
name|def
parameter_list|,
name|bitmap
name|live_range
parameter_list|,
name|HARD_REG_SET
modifier|*
name|btrs_live_in_range
parameter_list|)
block|{
comment|/* We can move the instruction.      Set a target register in block NEW_DEF_BB to the value      needed for this target register definition.      Replace all uses of the old target register definition by      uses of the new definition.  Delete the old definition.  */
name|basic_block
name|b
init|=
name|new_def_bb
decl_stmt|;
name|rtx
name|insp
init|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|rtx
name|old_insn
init|=
name|def
operator|->
name|insn
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|btr_rtx
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
name|enum
name|machine_mode
name|btr_mode
decl_stmt|;
name|btr_user
name|user
decl_stmt|;
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"migrating to basic block %d, using reg %d\n"
argument_list|,
name|new_def_bb
operator|->
name|index
argument_list|,
name|btr
argument_list|)
expr_stmt|;
name|clear_btr_from_live_range
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|def
operator|->
name|btr
operator|=
name|btr
expr_stmt|;
name|def
operator|->
name|bb
operator|=
name|new_def_bb
expr_stmt|;
name|def
operator|->
name|luid
operator|=
literal|0
expr_stmt|;
name|def
operator|->
name|cost
operator|=
name|basic_block_freq
argument_list|(
name|new_def_bb
argument_list|)
expr_stmt|;
name|def
operator|->
name|other_btr_uses_before_def
operator|=
literal|0
expr_stmt|;
name|bitmap_copy
argument_list|(
name|def
operator|->
name|live_range
argument_list|,
name|live_range
argument_list|)
expr_stmt|;
name|combine_btr_defs
argument_list|(
name|def
argument_list|,
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|btr
operator|=
name|def
operator|->
name|btr
expr_stmt|;
name|add_btr_to_live_range
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|insp
operator|=
name|NEXT_INSN
argument_list|(
name|insp
argument_list|)
expr_stmt|;
comment|/* N.B.: insp is expected to be NOTE_INSN_BASIC_BLOCK now.  Some      optimizations can result in insp being both first and last insn of      its basic block.  */
comment|/* ?? some assertions to check that insp is sensible? */
name|set
operator|=
name|single_set
argument_list|(
name|old_insn
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|btr_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|btr_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|btr_mode
argument_list|,
name|btr
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|gen_move_insn
argument_list|(
name|btr_rtx
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Insert target register initialization at head of basic block.  */
name|def
operator|->
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insp
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|btr
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"New pt is insn %d, inserted after insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|def
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the old target register initialization.  */
name|delete_insn
argument_list|(
name|old_insn
argument_list|)
expr_stmt|;
comment|/* Replace each use of the old target register by a use of the new target      register.  */
for|for
control|(
name|user
operator|=
name|def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
block|{
comment|/* Some extra work here to ensure consistent modes, because 	 it seems that a target register REG rtx can be given a different 	 mode depending on the context (surely that should not be 	 the case?).  */
name|rtx
name|replacement_rtx
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|user
operator|->
name|use
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|btr_rtx
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|user
operator|->
name|use
argument_list|)
operator|==
name|VOIDmode
condition|)
name|replacement_rtx
operator|=
name|btr_rtx
expr_stmt|;
else|else
name|replacement_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|user
operator|->
name|use
argument_list|)
argument_list|,
name|btr
argument_list|)
expr_stmt|;
name|replace_rtx
argument_list|(
name|user
operator|->
name|insn
argument_list|,
name|user
operator|->
name|use
argument_list|,
name|replacement_rtx
argument_list|)
expr_stmt|;
name|user
operator|->
name|use
operator|=
name|replacement_rtx
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We anticipate intra-block scheduling to be done.  See if INSN could move    up within BB by N_INSNS.  */
end_comment

begin_function
specifier|static
name|int
name|can_move_up
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|n_insns
parameter_list|)
block|{
while|while
condition|(
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|&&
name|n_insns
operator|>
literal|0
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? What if we have an anti-dependency that actually prevents the 	 scheduler from doing the move?  We'd like to re-allocate the register, 	 but not necessarily put the load into another basic block.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|n_insns
operator|--
expr_stmt|;
block|}
return|return
name|n_insns
operator|<=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Attempt to migrate the target register definition DEF to an    earlier point in the flowgraph.     It is a precondition of this function that DEF is migratable:    i.e. it has a constant source, and all uses are unambiguous.     Only migrations that reduce the cost of DEF will be made.    MIN_COST is the lower bound on the cost of the DEF after migration.    If we migrate DEF so that its cost falls below MIN_COST,    then we do not attempt to migrate further.  The idea is that    we migrate definitions in a priority order based on their cost,    when the cost of this definition falls below MIN_COST, then    there is another definition with cost == MIN_COST which now    has a higher priority than this definition.     Return nonzero if there may be benefit from attempting to    migrate this DEF further (i.e. we have reduced the cost below    MIN_COST, but we may be able to reduce it further).    Return zero if no further migration is possible.  */
end_comment

begin_function
specifier|static
name|int
name|migrate_btr_def
parameter_list|(
name|btr_def
name|def
parameter_list|,
name|int
name|min_cost
parameter_list|)
block|{
name|bitmap
name|live_range
decl_stmt|;
name|HARD_REG_SET
name|btrs_live_in_range
decl_stmt|;
name|int
name|btr_used_near_def
init|=
literal|0
decl_stmt|;
name|int
name|def_basic_block_freq
decl_stmt|;
name|basic_block
name|try
decl_stmt|;
name|int
name|give_up
init|=
literal|0
decl_stmt|;
name|int
name|def_moved
init|=
literal|0
decl_stmt|;
name|btr_user
name|user
decl_stmt|;
name|int
name|def_latency
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Attempting to migrate pt from insn %d (cost = %d, min_cost = %d) ... "
argument_list|,
name|INSN_UID
argument_list|(
name|def
operator|->
name|insn
argument_list|)
argument_list|,
name|def
operator|->
name|cost
argument_list|,
name|min_cost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|->
name|group
operator|||
name|def
operator|->
name|has_ambiguous_use
condition|)
comment|/* These defs are not migratable.  */
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"it's not migratable\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|def
operator|->
name|uses
condition|)
comment|/* We have combined this def with another in the same group, so        no need to consider it further.     */
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"it's already combined with another pt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|btr_def_live_range
argument_list|(
name|def
argument_list|,
operator|&
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|live_range
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_copy
argument_list|(
name|live_range
argument_list|,
name|def
operator|->
name|live_range
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|def_latency
operator|=
name|insn_default_latency
argument_list|(
name|def
operator|->
name|insn
argument_list|)
expr_stmt|;
else|else
name|def_latency
operator|=
name|result_ready_cost
argument_list|(
name|def
operator|->
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|def_latency
operator|*=
name|issue_rate
expr_stmt|;
for|for
control|(
name|user
operator|=
name|def
operator|->
name|uses
init|;
name|user
operator|!=
name|NULL
condition|;
name|user
operator|=
name|user
operator|->
name|next
control|)
block|{
if|if
condition|(
name|user
operator|->
name|bb
operator|==
name|def
operator|->
name|bb
operator|&&
name|user
operator|->
name|luid
operator|>
name|def
operator|->
name|luid
operator|&&
operator|(
name|def
operator|->
name|luid
operator|+
name|def_latency
operator|)
operator|>
name|user
operator|->
name|luid
operator|&&
operator|!
name|can_move_up
argument_list|(
name|def
operator|->
name|bb
argument_list|,
name|def
operator|->
name|insn
argument_list|,
operator|(
name|def
operator|->
name|luid
operator|+
name|def_latency
operator|)
operator|-
name|user
operator|->
name|luid
argument_list|)
condition|)
block|{
name|btr_used_near_def
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|def_basic_block_freq
operator|=
name|basic_block_freq
argument_list|(
name|def
operator|->
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
name|try
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|def
operator|->
name|bb
argument_list|)
init|;
operator|!
name|give_up
operator|&&
name|try
operator|&&
name|try
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|def
operator|->
name|cost
operator|>=
name|min_cost
condition|;
name|try
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|try
argument_list|)
control|)
block|{
comment|/* Try to move the instruction that sets the target register into 	 basic block TRY.  */
name|int
name|try_freq
init|=
name|basic_block_freq
argument_list|(
name|try
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"trying block %d ..."
argument_list|,
name|try
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_freq
operator|<
name|def_basic_block_freq
operator|||
operator|(
name|try_freq
operator|==
name|def_basic_block_freq
operator|&&
name|btr_used_near_def
operator|)
condition|)
block|{
name|int
name|btr
decl_stmt|;
name|augment_live_range
argument_list|(
name|live_range
argument_list|,
operator|&
name|btrs_live_in_range
argument_list|,
name|def
operator|->
name|bb
argument_list|,
name|try
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Now btrs live in range are: "
argument_list|)
expr_stmt|;
name|dump_hard_reg_set
argument_list|(
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|btr
operator|=
name|choose_btr
argument_list|(
name|btrs_live_in_range
argument_list|)
expr_stmt|;
if|if
condition|(
name|btr
operator|!=
operator|-
literal|1
condition|)
block|{
name|move_btr_def
argument_list|(
name|try
argument_list|,
name|btr
argument_list|,
name|def
argument_list|,
name|live_range
argument_list|,
operator|&
name|btrs_live_in_range
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|live_range
argument_list|,
name|def
operator|->
name|live_range
argument_list|)
expr_stmt|;
name|btr_used_near_def
operator|=
literal|0
expr_stmt|;
name|def_moved
operator|=
literal|1
expr_stmt|;
name|def_basic_block_freq
operator|=
name|basic_block_freq
argument_list|(
name|def
operator|->
name|bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There are no free target registers available to move 		 this far forward, so give up */
name|give_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"giving up because there are no free target registers\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|def_moved
condition|)
block|{
name|give_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"failed to move\n"
argument_list|)
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|live_range
argument_list|)
expr_stmt|;
return|return
operator|!
name|give_up
return|;
block|}
end_function

begin_comment
comment|/* Attempt to move instructions that set target registers earlier    in the flowgraph, away from their corresponding uses.  */
end_comment

begin_function
specifier|static
name|void
name|migrate_btr_defs
parameter_list|(
name|enum
name|reg_class
name|btr_class
parameter_list|,
name|int
name|allow_callee_save
parameter_list|)
block|{
name|fibheap_t
name|all_btr_defs
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|migrate_btrl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Basic block %d: count = "
name|HOST_WIDEST_INT_PRINT_DEC
literal|" loop-depth = %d idom = %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|,
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|all_btrs
argument_list|)
expr_stmt|;
for|for
control|(
name|first_btr
operator|=
operator|-
literal|1
operator|,
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|btr_class
index|]
argument_list|,
name|reg
argument_list|)
operator|&&
operator|(
name|allow_callee_save
operator|||
name|call_used_regs
index|[
name|reg
index|]
operator|||
name|regs_ever_live
index|[
name|reg
index|]
operator|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|all_btrs
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|last_btr
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|first_btr
operator|<
literal|0
condition|)
name|first_btr
operator|=
name|reg
expr_stmt|;
block|}
name|btrs_live
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|build_btr_def_use_webs
argument_list|(
name|all_btr_defs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|all_btr_defs
argument_list|)
condition|)
block|{
name|btr_def
name|def
init|=
operator|(
name|btr_def
operator|)
name|fibheap_extract_min
argument_list|(
name|all_btr_defs
argument_list|)
decl_stmt|;
name|int
name|min_cost
init|=
operator|-
name|fibheap_min_key
argument_list|(
name|all_btr_defs
argument_list|)
decl_stmt|;
if|if
condition|(
name|migrate_btr_def
argument_list|(
name|def
argument_list|,
name|min_cost
argument_list|)
condition|)
block|{
name|fibheap_insert
argument_list|(
name|all_btr_defs
argument_list|,
operator|-
name|def
operator|->
name|cost
argument_list|,
operator|(
name|void
operator|*
operator|)
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Putting insn %d back on queue with priority %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|def
operator|->
name|insn
argument_list|)
argument_list|,
name|def
operator|->
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|def
operator|->
name|live_range
condition|)
name|BITMAP_XFREE
argument_list|(
name|def
operator|->
name|live_range
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|btrs_live
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|migrate_btrl_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|all_btr_defs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|branch_target_load_optimize
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|bool
name|after_prologue_epilogue_gen
parameter_list|)
block|{
name|enum
name|reg_class
name|class
init|=
call|(
modifier|*
name|targetm
operator|.
name|branch_target_register_class
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
name|class
operator|!=
name|NO_REGS
condition|)
block|{
comment|/* Initialize issue_rate.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
condition|)
name|issue_rate
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
call|)
argument_list|()
expr_stmt|;
else|else
name|issue_rate
operator|=
literal|1
expr_stmt|;
comment|/* Build the CFG for migrate_btr_defs.  */
if|#
directive|if
literal|1
comment|/* This may or may not be needed, depending on where we 	 run this phase.  */
name|cleanup_cfg
argument_list|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dominator info is also needed for migrate_btr_def.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|migrate_btr_defs
argument_list|(
name|class
argument_list|,
operator|(
call|(
modifier|*
name|targetm
operator|.
name|branch_target_register_callee_saved
call|)
argument_list|(
name|after_prologue_epilogue_gen
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

