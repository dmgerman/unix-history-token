begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Web construction code for GNU compiler.    Contributed by Jan Hubicka.    Copyright (C) 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Simple optimization pass that splits independent uses of each pseudo,    increasing effectiveness of other optimizations.  The optimization can    serve as an example of use for the dataflow module.     We don't split registers with REG_USERVAR set unless -fmessy-debugging    is specified, because debugging information about such split variables    is almost unusable.     TODO     - Add code to keep debugging up-to-date after splitting user variable       pseudos.  This can be done by keeping track of all the pseudos used       for the variable and using life analysis information before reload       to determine which one is live and, in case more than one are live,       choose the one with the latest definition.        Other optimization passes can benefit from the infrastructure too.      - We may use profile information and ignore infrequent use for the       purpose of web unifying, inserting the compensation code later to       implement full induction variable expansion for loops (currently       we expand only if the induction variable is dead afterward, which       is often the case).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_comment
comment|/* This entry is allocated for each reference in the insn stream.  */
end_comment

begin_struct
struct|struct
name|web_entry
block|{
comment|/* Pointer to the parent in the union/find tree.  */
name|struct
name|web_entry
modifier|*
name|pred
decl_stmt|;
comment|/* Newly assigned register to the entry.  Set only for roots.  */
name|rtx
name|reg
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|web_entry
modifier|*
name|unionfind_root
parameter_list|(
name|struct
name|web_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unionfind_union
parameter_list|(
name|struct
name|web_entry
modifier|*
parameter_list|,
name|struct
name|web_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|union_defs
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|,
name|struct
name|ref
modifier|*
parameter_list|,
name|struct
name|web_entry
modifier|*
parameter_list|,
name|struct
name|web_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|entry_register
parameter_list|(
name|struct
name|web_entry
modifier|*
parameter_list|,
name|struct
name|ref
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_ref
parameter_list|(
name|struct
name|ref
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_addressof
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Find the root of unionfind tree (the representative of set).  */
end_comment

begin_function
specifier|static
name|struct
name|web_entry
modifier|*
name|unionfind_root
parameter_list|(
name|struct
name|web_entry
modifier|*
name|element
parameter_list|)
block|{
name|struct
name|web_entry
modifier|*
name|element1
init|=
name|element
decl_stmt|,
modifier|*
name|element2
decl_stmt|;
while|while
condition|(
name|element
operator|->
name|pred
condition|)
name|element
operator|=
name|element
operator|->
name|pred
expr_stmt|;
while|while
condition|(
name|element1
operator|->
name|pred
condition|)
block|{
name|element2
operator|=
name|element1
operator|->
name|pred
expr_stmt|;
name|element1
operator|->
name|pred
operator|=
name|element
expr_stmt|;
name|element1
operator|=
name|element2
expr_stmt|;
block|}
return|return
name|element
return|;
block|}
end_function

begin_comment
comment|/* Union sets.  */
end_comment

begin_function
specifier|static
name|void
name|unionfind_union
parameter_list|(
name|struct
name|web_entry
modifier|*
name|first
parameter_list|,
name|struct
name|web_entry
modifier|*
name|second
parameter_list|)
block|{
name|first
operator|=
name|unionfind_root
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|second
operator|=
name|unionfind_root
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|second
condition|)
return|return;
name|second
operator|->
name|pred
operator|=
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each use, all possible defs reaching it must come in the same    register, union them.  */
end_comment

begin_function
specifier|static
name|void
name|union_defs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|ref
modifier|*
name|use
parameter_list|,
name|struct
name|web_entry
modifier|*
name|def_entry
parameter_list|,
name|struct
name|web_entry
modifier|*
name|use_entry
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
init|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|use_link
init|=
name|DF_INSN_USES
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|def_link
init|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Some instructions may use match_dup for their operands.  In case the      operands are dead, we will assign them different pseudos, creating      invalid instructions, so union all uses of the same operand for each      insn.  */
while|while
condition|(
name|use_link
condition|)
block|{
if|if
condition|(
name|use
operator|!=
name|use_link
operator|->
name|ref
operator|&&
name|DF_REF_REAL_REG
argument_list|(
name|use
argument_list|)
operator|==
name|DF_REF_REAL_REG
argument_list|(
name|use_link
operator|->
name|ref
argument_list|)
condition|)
name|unionfind_union
argument_list|(
name|use_entry
operator|+
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|,
name|use_entry
operator|+
name|DF_REF_ID
argument_list|(
name|use_link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|use_link
operator|=
name|use_link
operator|->
name|next
expr_stmt|;
block|}
comment|/* Recognize trivial noop moves and attempt to keep them as noop.      While most of noop moves should be removed, we still keep some      of them at libcall boundaries and such.  */
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|DF_REF_REG
argument_list|(
name|use
argument_list|)
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
block|{
while|while
condition|(
name|def_link
condition|)
block|{
if|if
condition|(
name|DF_REF_REAL_REG
argument_list|(
name|use
argument_list|)
operator|==
name|DF_REF_REAL_REG
argument_list|(
name|def_link
operator|->
name|ref
argument_list|)
condition|)
name|unionfind_union
argument_list|(
name|use_entry
operator|+
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|,
name|def_entry
operator|+
name|DF_REF_ID
argument_list|(
name|def_link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|def_link
operator|=
name|def_link
operator|->
name|next
expr_stmt|;
block|}
block|}
while|while
condition|(
name|link
condition|)
block|{
name|unionfind_union
argument_list|(
name|use_entry
operator|+
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|,
name|def_entry
operator|+
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
comment|/* A READ_WRITE use requires the corresponding def to be in the same      register.  Find it and union.  */
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
block|{
name|struct
name|df_link
modifier|*
name|link
init|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|DF_REF_REAL_REG
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|!=
name|DF_REF_REAL_REG
argument_list|(
name|use
argument_list|)
condition|)
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|unionfind_union
argument_list|(
name|use_entry
operator|+
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|,
name|def_entry
operator|+
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the corresponding register for the given entry.  */
end_comment

begin_function
specifier|static
name|rtx
name|entry_register
parameter_list|(
name|struct
name|web_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|char
modifier|*
name|used
parameter_list|,
name|char
modifier|*
name|use_addressof
parameter_list|)
block|{
name|struct
name|web_entry
modifier|*
name|root
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|newreg
decl_stmt|;
comment|/* Find the corresponding web and see if it has been visited.  */
name|root
operator|=
name|unionfind_root
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|reg
condition|)
return|return
name|root
operator|->
name|reg
return|;
comment|/* We are seeing this web for the first time, do the assignment.  */
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* In case the original register is already assigned, generate new one.  */
if|if
condition|(
operator|!
name|used
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
name|newreg
operator|=
name|reg
operator|,
name|used
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|&&
literal|0
comment|/*&& !flag_messy_debugging*/
condition|)
block|{
name|newreg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"New web forced to keep reg=%i (user variable)\n"
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_addressof
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
block|{
name|newreg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"New web forced to keep reg=%i (address taken)\n"
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newreg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|newreg
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|REG_POINTER
argument_list|(
name|newreg
argument_list|)
operator|=
name|REG_POINTER
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|newreg
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newreg
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|REG_ATTRS
argument_list|(
name|newreg
argument_list|)
operator|=
name|REG_ATTRS
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Web oldreg=%i newreg=%i\n"
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|newreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|root
operator|->
name|reg
operator|=
name|newreg
expr_stmt|;
return|return
name|newreg
return|;
block|}
end_function

begin_comment
comment|/* Replace the reference by REG.  */
end_comment

begin_function
specifier|static
name|void
name|replace_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|oldreg
init|=
name|DF_REF_REAL_REG
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
name|DF_REF_REAL_LOC
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldreg
operator|==
name|reg
condition|)
return|return;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Updating insn %i (%i->%i)\n"
argument_list|,
name|INSN_UID
argument_list|(
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|oldreg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark each pseudo whose address is taken.  */
end_comment

begin_function
specifier|static
name|int
name|mark_addressof
parameter_list|(
name|rtx
modifier|*
name|rtl
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|rtl
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|rtl
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|)
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main entry point.  */
end_comment

begin_function
name|void
name|web_main
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|struct
name|web_entry
modifier|*
name|def_entry
decl_stmt|;
name|struct
name|web_entry
modifier|*
name|use_entry
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|max
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|char
modifier|*
name|used
decl_stmt|;
name|char
modifier|*
name|use_addressof
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|df
operator|=
name|df_init
argument_list|()
expr_stmt|;
name|df_analyse
argument_list|(
name|df
argument_list|,
literal|0
argument_list|,
name|DF_UD_CHAIN
operator||
name|DF_EQUIV_NOTES
argument_list|)
expr_stmt|;
name|def_entry
operator|=
operator|(
expr|struct
name|web_entry
operator|*
operator|)
name|xcalloc
argument_list|(
name|df
operator|->
name|n_defs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|web_entry
argument_list|)
argument_list|)
expr_stmt|;
name|use_entry
operator|=
operator|(
expr|struct
name|web_entry
operator|*
operator|)
name|xcalloc
argument_list|(
name|df
operator|->
name|n_uses
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|web_entry
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|max
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|use_addressof
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|max
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|df_dump
argument_list|(
name|df
argument_list|,
name|DF_UD_CHAIN
operator||
name|DF_DU_CHAIN
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* Produce the web.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_uses
condition|;
name|i
operator|++
control|)
name|union_defs
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|uses
index|[
name|i
index|]
argument_list|,
name|def_entry
argument_list|,
name|use_entry
argument_list|)
expr_stmt|;
comment|/* We can not safely rename registers whose address is taken.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_addressof
argument_list|,
name|use_addressof
argument_list|)
expr_stmt|;
comment|/* Update the instruction stream, allocating new registers for split pseudos      in progress.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_uses
condition|;
name|i
operator|++
control|)
name|replace_ref
argument_list|(
name|df
operator|->
name|uses
index|[
name|i
index|]
argument_list|,
name|entry_register
argument_list|(
name|use_entry
operator|+
name|i
argument_list|,
name|df
operator|->
name|uses
index|[
name|i
index|]
argument_list|,
name|used
argument_list|,
name|use_addressof
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_defs
condition|;
name|i
operator|++
control|)
name|replace_ref
argument_list|(
name|df
operator|->
name|defs
index|[
name|i
index|]
argument_list|,
name|entry_register
argument_list|(
name|def_entry
operator|+
name|i
argument_list|,
name|df
operator|->
name|defs
index|[
name|i
index|]
argument_list|,
name|used
argument_list|,
name|use_addressof
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dataflow information is corrupt here, but it can be easily updated      by creating new entries for new registers and updates or calling      df_insns_modify.  */
name|free
argument_list|(
name|def_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use_addressof
argument_list|)
expr_stmt|;
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

