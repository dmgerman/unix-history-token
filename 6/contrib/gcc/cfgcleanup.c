begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow optimization code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains optimizer of the control flow.  The main entrypoint is    cleanup_cfg.  Following optimizations are performed:     - Unreachable blocks removal    - Edge forwarding (edge to the forwarder block is forwarded to it's      successor.  Simplification of the branch instruction is performed by      underlying infrastructure so branch can be converted to simplejump or      eliminated).    - Cross jumping (tail merging)    - Conditional jump-around-simplejump simplification    - Basic block merging.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* cleanup_cfg maintains following flags for each basic block.  */
end_comment

begin_enum
enum|enum
name|bb_flags
block|{
comment|/* Set if BB is the forwarder block to avoid too many        forwarder_block_p calls.  */
name|BB_FORWARDER_BLOCK
init|=
literal|1
block|,
name|BB_NONTHREADABLE_BLOCK
init|=
literal|2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|BB_FLAGS
parameter_list|(
name|BB
parameter_list|)
value|(enum bb_flags) (BB)->aux
end_define

begin_define
define|#
directive|define
name|BB_SET_FLAG
parameter_list|(
name|BB
parameter_list|,
name|FLAG
parameter_list|)
define|\
value|(BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux | (FLAG))
end_define

begin_define
define|#
directive|define
name|BB_CLEAR_FLAG
parameter_list|(
name|BB
parameter_list|,
name|FLAG
parameter_list|)
define|\
value|(BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux& ~(FLAG))
end_define

begin_define
define|#
directive|define
name|FORWARDER_BLOCK_P
parameter_list|(
name|BB
parameter_list|)
value|(BB_FLAGS (BB)& BB_FORWARDER_BLOCK)
end_define

begin_function_decl
specifier|static
name|bool
name|try_crossjump_to_edge
parameter_list|(
name|int
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|try_crossjump_bb
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|outgoing_edges_match
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flow_find_cross_jump
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|insns_match_p
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tail_recursion_label_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_blocks_move_predecessor_nojumps
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_blocks_move_successor_nojumps
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|try_optimize_cfg
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|try_simplify_condjump
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|try_forward_edges
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|thread_jump
parameter_list|(
name|int
parameter_list|,
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mark_effect
parameter_list|(
name|rtx
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notice_new_block
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_forwarder_flag
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mentions_nonequal_regs
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_memattrs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Set flags for newly created block.  */
end_comment

begin_function
specifier|static
name|void
name|notice_new_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bb
condition|)
return|return;
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recompute forwarder flag after block has been modified.  */
end_comment

begin_function
specifier|static
name|void
name|update_forwarder_flag
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
else|else
name|BB_CLEAR_FLAG
argument_list|(
name|bb
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a conditional jump around an unconditional jump.    Return true if something changed.  */
end_comment

begin_function
specifier|static
name|bool
name|try_simplify_condjump
parameter_list|(
name|basic_block
name|cbranch_block
parameter_list|)
block|{
name|basic_block
name|jump_block
decl_stmt|,
name|jump_dest_block
decl_stmt|,
name|cbranch_dest_block
decl_stmt|;
name|edge
name|cbranch_jump_edge
decl_stmt|,
name|cbranch_fallthru_edge
decl_stmt|;
name|rtx
name|cbranch_insn
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|end
decl_stmt|;
comment|/* Verify that there are exactly two successors.  */
if|if
condition|(
operator|!
name|cbranch_block
operator|->
name|succ
operator|||
operator|!
name|cbranch_block
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|cbranch_block
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|false
return|;
comment|/* Verify that we've got a normal conditional branch at the end      of the block.  */
name|cbranch_insn
operator|=
name|BB_END
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|cbranch_insn
argument_list|)
condition|)
return|return
name|false
return|;
name|cbranch_fallthru_edge
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
name|cbranch_jump_edge
operator|=
name|BRANCH_EDGE
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
comment|/* The next block must not have multiple predecessors, must not      be the last block in the function, and must contain just the      unconditional jump.  */
name|jump_block
operator|=
name|cbranch_fallthru_edge
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|jump_block
operator|->
name|pred
operator|->
name|pred_next
operator|||
name|jump_block
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|!
name|FORWARDER_BLOCK_P
argument_list|(
name|jump_block
argument_list|)
condition|)
return|return
name|false
return|;
name|jump_dest_block
operator|=
name|jump_block
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
comment|/* The conditional branch must target the block after the      unconditional branch.  */
name|cbranch_dest_block
operator|=
name|cbranch_jump_edge
operator|->
name|dest
expr_stmt|;
if|if
condition|(
operator|!
name|can_fallthru
argument_list|(
name|jump_block
argument_list|,
name|cbranch_dest_block
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Invert the conditional branch.  */
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|cbranch_insn
argument_list|,
name|block_label
argument_list|(
name|jump_dest_block
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Simplifying condjump %i around jump %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|cbranch_insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Success.  Update the CFG to match.  Note that after this point      the edge variable names appear backwards; the redirection is done      this way to preserve edge profile data.  */
name|cbranch_jump_edge
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|cbranch_jump_edge
argument_list|,
name|cbranch_dest_block
argument_list|)
expr_stmt|;
name|cbranch_fallthru_edge
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|cbranch_fallthru_edge
argument_list|,
name|jump_dest_block
argument_list|)
expr_stmt|;
name|cbranch_jump_edge
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|cbranch_fallthru_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|cbranch_block
argument_list|)
expr_stmt|;
name|end
operator|=
name|BB_END
argument_list|(
name|jump_block
argument_list|)
expr_stmt|;
comment|/* Deleting a block may produce unreachable code warning even when we are      not deleting anything live.  Suppress it by moving all the line number      notes out of the block.  */
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|jump_block
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|jump_block
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|jump_block
argument_list|)
condition|)
block|{
name|BB_END
argument_list|(
name|jump_block
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
name|reorder_insns_nobb
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|end
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Delete the block with the unconditional jump, and clean up the mess.  */
name|delete_block
argument_list|(
name|jump_block
argument_list|)
expr_stmt|;
name|tidy_fallthru_edge
argument_list|(
name|cbranch_jump_edge
argument_list|,
name|cbranch_block
argument_list|,
name|cbranch_dest_block
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to prove that operation is NOOP using CSElib or mark the effect    on register.  Used by jump threading.  */
end_comment

begin_function
specifier|static
name|bool
name|mark_effect
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|regset
name|nonequal
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* In case we do clobber the register, mark it as equal, as we know the          value is dead so it don't have to match.  */
case|case
name|CLOBBER
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|dest
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
case|case
name|SET
case|:
if|if
condition|(
name|rtx_equal_for_cselib_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|pc_rtx
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|true
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a register set in regset DATA.    Called via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|mentions_nonequal_regs
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|regset
name|nonequal
init|=
operator|(
name|regset
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|x
argument_list|)
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
operator|*
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|nonequal
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|nonequal
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Attempt to prove that the basic block B will have no side effects and    always continues in the same edge if reached via E.  Return the edge    if exist, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|edge
name|thread_jump
parameter_list|(
name|int
name|mode
parameter_list|,
name|edge
name|e
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|set1
decl_stmt|,
name|set2
decl_stmt|,
name|cond1
decl_stmt|,
name|cond2
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|reversed_code2
decl_stmt|;
name|bool
name|reverse1
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regset
name|nonequal
decl_stmt|;
name|bool
name|failed
init|=
name|false
decl_stmt|;
if|if
condition|(
name|BB_FLAGS
argument_list|(
name|b
argument_list|)
operator|&
name|BB_NONTHREADABLE_BLOCK
condition|)
return|return
name|NULL
return|;
comment|/* At the moment, we do handle only conditional jumps, but later we may      want to extend this code to tablejumps and others.  */
if|if
condition|(
operator|!
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|succ
operator|||
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_NONTHREADABLE_BLOCK
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Second branch must end with onlyjump, as we will eliminate the jump.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_NONTHREADABLE_BLOCK
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|set1
operator|=
name|pc_set
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|set2
operator|=
name|pc_set
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
name|reverse1
operator|=
name|true
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse1
condition|)
name|code1
operator|=
name|reversed_comparison_code
argument_list|(
name|cond1
argument_list|,
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code1
operator|=
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
expr_stmt|;
name|reversed_code2
operator|=
name|reversed_comparison_code
argument_list|(
name|cond2
argument_list|,
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
operator|&&
operator|!
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|reversed_code2
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure that the comparison operators are equivalent.      ??? This is far too pessimistic.  We should allow swapped operands,      different CCmodes, or for example comparisons for interval, that      dominate even when operands are not equivalent.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Short circuit cases where block B contains some side effects, as we can't      safely bypass it.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_NONTHREADABLE_BLOCK
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cselib_init
argument_list|()
expr_stmt|;
comment|/* First process all values computed in the source basic block.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nonequal
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
comment|/* Now assume that we've continued by the edge E to B and continue      processing as if it were same basic block.      Our goal is to prove that whole block is an NOOP.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|&&
operator|!
name|failed
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|failed
operator||=
name|mark_effect
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|nonequal
argument_list|)
expr_stmt|;
block|}
else|else
name|failed
operator||=
name|mark_effect
argument_list|(
name|pat
argument_list|,
name|nonequal
argument_list|)
expr_stmt|;
block|}
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Later we should clear nonequal of dead registers.  So far we don't      have life information in cfg_cleanup.  */
if|if
condition|(
name|failed
condition|)
block|{
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_NONTHREADABLE_BLOCK
argument_list|)
expr_stmt|;
goto|goto
name|failed_exit
goto|;
block|}
comment|/* cond2 must not mention any register that is not equal to the      former block.  */
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|cond2
argument_list|,
name|mentions_nonequal_regs
argument_list|,
name|nonequal
argument_list|)
condition|)
goto|goto
name|failed_exit
goto|;
comment|/* In case liveness information is available, we need to prove equivalence      only of the live values.  */
if|if
condition|(
name|mode
operator|&
name|CLEANUP_UPDATE_LIFE
condition|)
name|AND_REG_SET
argument_list|(
name|nonequal
argument_list|,
name|b
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|nonequal
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|goto failed_exit;
argument_list|)
empty_stmt|;
name|BITMAP_XFREE
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
return|return
name|BRANCH_EDGE
argument_list|(
name|b
argument_list|)
return|;
else|else
return|return
name|FALLTHRU_EDGE
argument_list|(
name|b
argument_list|)
return|;
name|failed_exit
label|:
name|BITMAP_XFREE
argument_list|(
name|nonequal
argument_list|)
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to forward edges leaving basic block B.    Return true if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|try_forward_edges
parameter_list|(
name|int
name|mode
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|,
modifier|*
name|threaded_edges
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|basic_block
name|target
decl_stmt|,
name|first
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|bool
name|threaded
init|=
name|false
decl_stmt|;
name|int
name|nthreaded_edges
init|=
literal|0
decl_stmt|;
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
comment|/* Skip complex edges because we don't know how to update them.           Still handle fallthru edges, as we can succeed to forward fallthru          edge to the same place as the branch edge of conditional branch          and turn conditional branch to an unconditional branch.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
continue|continue;
name|target
operator|=
name|first
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|n_basic_blocks
condition|)
block|{
name|basic_block
name|new_target
init|=
name|NULL
decl_stmt|;
name|bool
name|new_target_threaded
init|=
name|false
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|target
argument_list|)
operator|&&
name|target
operator|->
name|succ
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* Bypass trivial infinite loops.  */
if|if
condition|(
name|target
operator|==
name|target
operator|->
name|succ
operator|->
name|dest
condition|)
name|counter
operator|=
name|n_basic_blocks
expr_stmt|;
name|new_target
operator|=
name|target
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
block|}
comment|/* Allow to thread only over one edge at time to simplify updating 	     of probabilities.  */
elseif|else
if|if
condition|(
name|mode
operator|&
name|CLEANUP_THREADING
condition|)
block|{
name|edge
name|t
init|=
name|thread_jump
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|threaded_edges
condition|)
name|threaded_edges
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|threaded_edges
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Detect an infinite loop across blocks not 			 including the start block.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreaded_edges
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|threaded_edges
index|[
name|i
index|]
operator|==
name|t
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nthreaded_edges
condition|)
block|{
name|counter
operator|=
name|n_basic_blocks
expr_stmt|;
break|break;
block|}
block|}
comment|/* Detect an infinite loop across the start block.  */
if|if
condition|(
name|t
operator|->
name|dest
operator|==
name|b
condition|)
break|break;
if|if
condition|(
name|nthreaded_edges
operator|>=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|threaded_edges
index|[
name|nthreaded_edges
operator|++
index|]
operator|=
name|t
expr_stmt|;
name|new_target
operator|=
name|t
operator|->
name|dest
expr_stmt|;
name|new_target_threaded
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|new_target
condition|)
break|break;
comment|/* Avoid killing of loop pre-headers, as it is the place loop 	     optimizer wants to hoist code to.  	     For fallthru forwarders, the LOOP_BEG note must appear between 	     the header of block and CODE_LABEL of the loop, for non forwarders 	     it must appear before the JUMP_INSN.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_PRE_LOOP
operator|)
operator|&&
name|optimize
condition|)
block|{
name|rtx
name|insn
init|=
operator|(
name|target
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|?
name|BB_HEAD
argument_list|(
name|target
argument_list|)
else|:
name|prev_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|target
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
break|break;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
break|break;
comment|/* Do not clean up branches to just past the end of a loop 		 at this time; it can mess up the loop optimizer's 		 recognition of some patterns.  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
block|}
name|counter
operator|++
expr_stmt|;
name|target
operator|=
name|new_target
expr_stmt|;
name|threaded
operator||=
name|new_target_threaded
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|>=
name|n_basic_blocks
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Infinite loop in BB %i.\n"
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|first
condition|)
empty_stmt|;
comment|/* We didn't do anything.  */
else|else
block|{
comment|/* Save the values now, as the edge may get removed.  */
name|gcov_type
name|edge_count
init|=
name|e
operator|->
name|count
decl_stmt|;
name|int
name|edge_probability
init|=
name|e
operator|->
name|probability
decl_stmt|;
name|int
name|edge_frequency
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Don't force if target is exit block.  */
if|if
condition|(
name|threaded
operator|&&
name|target
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|notice_new_block
argument_list|(
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Conditionals threaded.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Forwarding edge %i->%i to %i failed.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|target
operator|->
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We successfully forwarded the edge.  Now update profile 	     data: for each edge we traversed in the chain, remove 	     the original edge's execution count.  */
name|edge_frequency
operator|=
operator|(
operator|(
name|edge_probability
operator|*
name|b
operator|->
name|frequency
operator|+
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
operator|&&
name|forwarder_block_p
argument_list|(
name|b
argument_list|)
condition|)
name|BB_SET_FLAG
argument_list|(
name|b
argument_list|,
name|BB_FORWARDER_BLOCK
argument_list|)
expr_stmt|;
do|do
block|{
name|edge
name|t
decl_stmt|;
name|first
operator|->
name|count
operator|-=
name|edge_count
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|count
operator|<
literal|0
condition|)
name|first
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|frequency
operator|-=
name|edge_frequency
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|frequency
operator|<
literal|0
condition|)
name|first
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|prob
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|nthreaded_edges
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|threaded_edges
index|[
name|n
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|src
operator|!=
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|frequency
condition|)
name|prob
operator|=
name|edge_frequency
operator|*
name|REG_BR_PROB_BASE
operator|/
name|first
operator|->
name|frequency
expr_stmt|;
else|else
name|prob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prob
operator|>
name|t
operator|->
name|probability
condition|)
name|prob
operator|=
name|t
operator|->
name|probability
expr_stmt|;
name|t
operator|->
name|probability
operator|-=
name|prob
expr_stmt|;
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
if|if
condition|(
name|prob
operator|<=
literal|0
condition|)
block|{
name|first
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|first
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|e
operator|=
name|first
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
operator|(
operator|(
name|e
operator|->
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|)
operator|/
operator|(
name|double
operator|)
name|prob
operator|)
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is possible that as the result of 		     threading we've removed edge as it is 		     threaded to the fallthru edge.  Avoid 		     getting out of sync.  */
if|if
condition|(
name|n
operator|<
name|nthreaded_edges
operator|&&
name|first
operator|==
name|threaded_edges
index|[
name|n
index|]
operator|->
name|src
condition|)
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|first
operator|->
name|succ
expr_stmt|;
block|}
name|t
operator|->
name|count
operator|-=
name|edge_count
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|count
operator|<
literal|0
condition|)
name|t
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|t
operator|->
name|dest
expr_stmt|;
block|}
do|while
condition|(
name|first
operator|!=
name|target
condition|)
do|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|threaded_edges
condition|)
name|free
argument_list|(
name|threaded_edges
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if LABEL is used for tail recursion.  */
end_comment

begin_function
specifier|static
name|bool
name|tail_recursion_label_p
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|tail_recursion_label_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block.  A has no incoming    fallthru edge, so it can be moved before B without adding or modifying    any jumps (aside from the jump from A to B).  */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks_move_predecessor_nojumps
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|barrier
decl_stmt|;
name|barrier
operator|=
name|next_nonnote_insn
argument_list|(
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
comment|/* Move block and loop notes out of the chain so that we do not      disturb their order.       ??? A better solution would be to squeeze out all the non-nested notes      and adjust the block trees appropriately.   Even better would be to have      a tighter connection between block trees and rtl so that this is not      necessary.  */
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|BB_HEAD
argument_list|(
name|a
argument_list|)
argument_list|,
operator|&
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scramble the insn chain.  */
if|if
condition|(
name|BB_END
argument_list|(
name|a
argument_list|)
operator|!=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|reorder_insns_nobb
argument_list|(
name|BB_HEAD
argument_list|(
name|a
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Moved block %d before %d and merged.\n"
argument_list|,
name|a
operator|->
name|index
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Swap the records for the two blocks around.  */
name|unlink_block
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|link_block
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
comment|/* Now blocks A and B are contiguous.  Merge them.  */
name|merge_blocks
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block.  B has no outgoing    fallthru edge, so it can be moved after A without adding or modifying    any jumps (aside from the jump from A to B).  */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks_move_successor_nojumps
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|barrier
decl_stmt|,
name|real_b_end
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|table
decl_stmt|;
name|real_b_end
operator|=
name|BB_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* If there is a jump table following block B temporarily add the jump table      to block B so that it will also be moved to the correct location.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|table
argument_list|)
operator|&&
name|prev_active_insn
argument_list|(
name|label
argument_list|)
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|BB_END
argument_list|(
name|b
argument_list|)
operator|=
name|table
expr_stmt|;
block|}
comment|/* There had better have been a barrier there.  Delete it.  */
name|barrier
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
comment|/* Move block and loop notes out of the chain so that we do not      disturb their order.       ??? A better solution would be to squeeze out all the non-nested notes      and adjust the block trees appropriately.   Even better would be to have      a tighter connection between block trees and rtl so that this is not      necessary.  */
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scramble the insn chain.  */
name|reorder_insns_nobb
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the real end of b.  */
name|BB_END
argument_list|(
name|b
argument_list|)
operator|=
name|real_b_end
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Moved block %d after %d and merged.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|,
name|a
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Now blocks A and B are contiguous.  Merge them.  */
name|merge_blocks
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to merge basic blocks that are potentially non-adjacent.    Return NULL iff the attempt failed, otherwise return basic block    where cleanup_cfg should continue.  Because the merging commonly    moves basic block away or introduces another optimization    possibility, return basic block just before B so cleanup_cfg don't    need to iterate.     It may be good idea to return basic block before C in the case    C has been moved after B and originally appeared earlier in the    insn sequence, but we have no information available about the    relative ordering of these two.  Hopefully it is not too common.  */
end_comment

begin_function
specifier|static
name|basic_block
name|merge_blocks_move
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|b
parameter_list|,
name|basic_block
name|c
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|basic_block
name|next
decl_stmt|;
comment|/* If C has a tail recursion label, do not merge.  There is no      edge recorded from the call_placeholder back to this label, as      that would make optimize_sibling_and_tail_recursive_calls more      complex for no gain.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_PRE_SIBCALL
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|tail_recursion_label_p
argument_list|(
name|BB_HEAD
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If B has a fallthru edge to C, no need to move anything.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|int
name|b_index
init|=
name|b
operator|->
name|index
decl_stmt|,
name|c_index
init|=
name|c
operator|->
name|index
decl_stmt|;
name|merge_blocks
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Merged %d and %d without moving.\n"
argument_list|,
name|b_index
argument_list|,
name|c_index
argument_list|)
expr_stmt|;
return|return
name|b
operator|->
name|prev_bb
operator|==
name|ENTRY_BLOCK_PTR
condition|?
name|b
else|:
name|b
operator|->
name|prev_bb
return|;
block|}
comment|/* Otherwise we will need to move code around.  Do that only if expensive      transformations are allowed.  */
elseif|else
if|if
condition|(
name|mode
operator|&
name|CLEANUP_EXPENSIVE
condition|)
block|{
name|edge
name|tmp_edge
decl_stmt|,
name|b_fallthru_edge
decl_stmt|;
name|bool
name|c_has_outgoing_fallthru
decl_stmt|;
name|bool
name|b_has_incoming_fallthru
decl_stmt|;
comment|/* Avoid overactive code motion, as the forwarder blocks should be          eliminated by edge redirection instead.  One exception might have 	 been if B is a forwarder block and C has no fallthru edge, but 	 that should be cleaned up by bb-reorder instead.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* We must make sure to not munge nesting of lexical blocks, 	 and loop notes.  This is done by squeezing out all the notes 	 and leaving them there to lie.  Not ideal, but functional.  */
for|for
control|(
name|tmp_edge
operator|=
name|c
operator|->
name|succ
init|;
name|tmp_edge
condition|;
name|tmp_edge
operator|=
name|tmp_edge
operator|->
name|succ_next
control|)
if|if
condition|(
name|tmp_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
name|c_has_outgoing_fallthru
operator|=
operator|(
name|tmp_edge
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|tmp_edge
operator|=
name|b
operator|->
name|pred
init|;
name|tmp_edge
condition|;
name|tmp_edge
operator|=
name|tmp_edge
operator|->
name|pred_next
control|)
if|if
condition|(
name|tmp_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
name|b_has_incoming_fallthru
operator|=
operator|(
name|tmp_edge
operator|!=
name|NULL
operator|)
expr_stmt|;
name|b_fallthru_edge
operator|=
name|tmp_edge
expr_stmt|;
name|next
operator|=
name|b
operator|->
name|prev_bb
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|c
condition|)
name|next
operator|=
name|next
operator|->
name|prev_bb
expr_stmt|;
comment|/* Otherwise, we're going to try to move C after B.  If C does 	 not have an outgoing fallthru, then it can be moved 	 immediately after B without introducing or modifying jumps.  */
if|if
condition|(
operator|!
name|c_has_outgoing_fallthru
condition|)
block|{
name|merge_blocks_move_successor_nojumps
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|next
operator|==
name|ENTRY_BLOCK_PTR
condition|?
name|next
operator|->
name|next_bb
else|:
name|next
return|;
block|}
comment|/* If B does not have an incoming fallthru, then it can be moved 	 immediately before C without introducing or modifying jumps. 	 C cannot be the first block, so we do not have to worry about 	 accessing a non-existent block.  */
if|if
condition|(
name|b_has_incoming_fallthru
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|b_fallthru_edge
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|NULL
return|;
name|bb
operator|=
name|force_nonfallthru
argument_list|(
name|b_fallthru_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
name|notice_new_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|merge_blocks_move_predecessor_nojumps
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|next
operator|==
name|ENTRY_BLOCK_PTR
condition|?
name|next
operator|->
name|next_bb
else|:
name|next
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Removes the memory attributes of MEM expression    if they are not equal.  */
end_comment

begin_function
name|void
name|merge_memattrs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
condition|)
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
condition|)
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ALIAS_SET
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|set_mem_alias_set
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mem_expr_equal_p
argument_list|(
name|MEM_EXPR
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|set_mem_expr
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_expr
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_OFFSET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_OFFSET
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|set_mem_offset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_mem_size
argument_list|(
name|x
argument_list|,
name|MAX
argument_list|(
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|y
argument_list|,
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|x
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|y
argument_list|,
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|merge_memattrs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|merge_memattrs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */
end_comment

begin_function
specifier|static
name|bool
name|insns_match_p
parameter_list|(
name|int
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|i1
parameter_list|,
name|rtx
name|i2
parameter_list|)
block|{
name|rtx
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* Verify that I1 and I2 are equivalent.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|i2
argument_list|)
condition|)
return|return
name|false
return|;
name|p1
operator|=
name|PATTERN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|p2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a CALL_INSN, compare register usage information.      If we don't check this on stack register machines, the two      CALL_INSNs might be merged leaving reg-stack.c with mismatching      numbers of stack registers in the same basic block.      If we don't check this on machines with delay slots, a delay slot may      be filled that clobbers a parameter expected by the subroutine.       ??? We take the simple route for now and assume that if they're      equal, they were constructed identically.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|||
name|SIBLING_CALL_P
argument_list|(
name|i1
argument_list|)
operator|!=
name|SIBLING_CALL_P
argument_list|(
name|i2
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* If cross_jump_death_matters is not 0, the insn's mode      indicates whether or not the insn contains any stack-like      regs.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|)
operator|&&
name|stack_regs_mentioned
argument_list|(
name|i1
argument_list|)
condition|)
block|{
comment|/* If register stack conversion has already been done, then          death notes must also be compared before it is certain that          the two instruction streams match.  */
name|rtx
name|note
decl_stmt|;
name|HARD_REG_SET
name|i1_regset
decl_stmt|,
name|i2_regset
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i1_regset
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i2_regset
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i1_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i2_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|i1_regset
argument_list|,
name|i2_regset
argument_list|,
name|done
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|done
label|:
empty_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
condition|?
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
else|:
name|rtx_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Do not do EQUIV substitution after reload.  First, we're undoing the      work of reload_cse.  Second, we may be undoing the work of the post-      reload splitting pass.  */
comment|/* ??? Possibly add a new phase switch variable that can be used by      targets to disallow the troublesome insns after splitting.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
comment|/* The following code helps take care of G++ cleanups.  */
name|rtx
name|equiv1
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|equiv2
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
comment|/* If the equivalences are not to a constant, they may 	     reference pseudos that no longer exist, so we can't 	     use them.  */
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|s1
init|=
name|single_set
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|s2
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|!=
literal|0
operator|&&
name|s2
operator|!=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|s1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|s2
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|i1
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|i2
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the insns at the end of BB1 and BB2 and find the longest    sequence that are equivalent.  Store the first insns for that sequence    in *F1 and *F2 and return the sequence length.     To simplify callers of this function, if the blocks match exactly,    store the head of the blocks in *F1 and *F2.  */
end_comment

begin_function
specifier|static
name|int
name|flow_find_cross_jump
parameter_list|(
name|int
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|,
name|rtx
modifier|*
name|f1
parameter_list|,
name|rtx
modifier|*
name|f2
parameter_list|)
block|{
name|rtx
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|last1
decl_stmt|,
name|last2
decl_stmt|,
name|afterlast1
decl_stmt|,
name|afterlast2
decl_stmt|;
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
comment|/* Skip simple jumps at the end of the blocks.  Complex jumps still      need to be compared for equivalence, which we'll do below.  */
name|i1
operator|=
name|BB_END
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|last1
operator|=
name|afterlast1
operator|=
name|last2
operator|=
name|afterlast2
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|i1
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|i1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|last1
operator|=
name|i1
expr_stmt|;
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
name|i2
operator|=
name|BB_END
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|i2
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|i2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|last2
operator|=
name|i2
expr_stmt|;
comment|/* Count everything except for unconditional jump as insn.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|i2
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|i2
argument_list|)
operator|&&
name|last1
condition|)
name|ninsns
operator|++
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
comment|/* Ignore notes.  */
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|i1
argument_list|)
operator|&&
name|i1
operator|!=
name|BB_HEAD
argument_list|(
name|bb1
argument_list|)
condition|)
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|i2
argument_list|)
operator|&&
name|i2
operator|!=
name|BB_HEAD
argument_list|(
name|bb2
argument_list|)
condition|)
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
name|BB_HEAD
argument_list|(
name|bb1
argument_list|)
operator|||
name|i2
operator|==
name|BB_HEAD
argument_list|(
name|bb2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|insns_match_p
argument_list|(
name|mode
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
condition|)
break|break;
name|merge_memattrs
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* Don't begin a cross-jump with a NOTE insn.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|i1
argument_list|)
condition|)
block|{
comment|/* If the merged insns have different REG_EQUAL notes, then 	     remove them.  */
name|rtx
name|equiv1
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|equiv2
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|equiv1
operator|&&
operator|!
name|equiv2
condition|)
name|remove_note
argument_list|(
name|i1
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|equiv1
operator|&&
name|equiv2
condition|)
name|remove_note
argument_list|(
name|i2
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|i1
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|i2
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
block|}
name|afterlast1
operator|=
name|last1
operator|,
name|afterlast2
operator|=
name|last2
expr_stmt|;
name|last1
operator|=
name|i1
operator|,
name|last2
operator|=
name|i2
expr_stmt|;
name|ninsns
operator|++
expr_stmt|;
block|}
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't allow the insn after a compare to be shared by      cross-jumping unless the compare is also shared.  */
if|if
condition|(
name|ninsns
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|last1
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|last1
argument_list|)
condition|)
name|last1
operator|=
name|afterlast1
operator|,
name|last2
operator|=
name|afterlast2
operator|,
name|ninsns
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Include preceding notes and labels in the cross-jump.  One,      this may bring us to the head of the blocks as requested above.      Two, it keeps line number notes as matched as may be.  */
if|if
condition|(
name|ninsns
condition|)
block|{
while|while
condition|(
name|last1
operator|!=
name|BB_HEAD
argument_list|(
name|bb1
argument_list|)
operator|&&
operator|!
name|INSN_P
argument_list|(
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
argument_list|)
condition|)
name|last1
operator|=
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last1
operator|!=
name|BB_HEAD
argument_list|(
name|bb1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last1
operator|=
name|PREV_INSN
argument_list|(
name|last1
argument_list|)
expr_stmt|;
while|while
condition|(
name|last2
operator|!=
name|BB_HEAD
argument_list|(
name|bb2
argument_list|)
operator|&&
operator|!
name|INSN_P
argument_list|(
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
argument_list|)
condition|)
name|last2
operator|=
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
expr_stmt|;
if|if
condition|(
name|last2
operator|!=
name|BB_HEAD
argument_list|(
name|bb2
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last2
operator|=
name|PREV_INSN
argument_list|(
name|last2
argument_list|)
expr_stmt|;
operator|*
name|f1
operator|=
name|last1
expr_stmt|;
operator|*
name|f2
operator|=
name|last2
expr_stmt|;
block|}
return|return
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* Return true iff outgoing edges of BB1 and BB2 match, together with    the branch instruction.  This means that if we commonize the control    flow before end of the basic block, the semantic remains unchanged.     We may assume that there exists one edge with a common destination.  */
end_comment

begin_function
specifier|static
name|bool
name|outgoing_edges_match
parameter_list|(
name|int
name|mode
parameter_list|,
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|int
name|nehedges1
init|=
literal|0
decl_stmt|,
name|nehedges2
init|=
literal|0
decl_stmt|;
name|edge
name|fallthru1
init|=
literal|0
decl_stmt|,
name|fallthru2
init|=
literal|0
decl_stmt|;
name|edge
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* If BB1 has only one successor, we may be looking at either an      unconditional jump, or a fake edge to exit.  */
if|if
condition|(
name|bb1
operator|->
name|succ
operator|&&
operator|!
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|(
name|bb1
operator|->
name|succ
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|bb2
operator|->
name|succ
operator|&&
operator|!
name|bb2
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|(
name|bb2
operator|->
name|succ
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FAKE
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
operator|)
operator|)
return|;
comment|/* Match conditional jumps - this may get tricky when fallthru and branch      edges are crossed.  */
if|if
condition|(
name|bb1
operator|->
name|succ
operator|&&
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
name|bb1
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
condition|)
block|{
name|edge
name|b1
decl_stmt|,
name|f1
decl_stmt|,
name|b2
decl_stmt|,
name|f2
decl_stmt|;
name|bool
name|reverse
decl_stmt|,
name|match
decl_stmt|;
name|rtx
name|set1
decl_stmt|,
name|set2
decl_stmt|,
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
if|if
condition|(
operator|!
name|bb2
operator|->
name|succ
operator|||
operator|!
name|bb2
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|bb2
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|b1
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|b2
operator|=
name|BRANCH_EDGE
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
name|f1
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|f2
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
comment|/* Get around possible forwarders on fallthru edges.  Other cases          should be optimized out already.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f1
operator|->
name|dest
argument_list|)
condition|)
name|f1
operator|=
name|f1
operator|->
name|dest
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f2
operator|->
name|dest
argument_list|)
condition|)
name|f2
operator|=
name|f2
operator|->
name|dest
operator|->
name|succ
expr_stmt|;
comment|/* To simplify use of this function, return false if there are 	 unneeded forwarder blocks.  These will get eliminated later 	 during cleanup_cfg.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|f1
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|f2
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|b1
operator|->
name|dest
argument_list|)
operator|||
name|FORWARDER_BLOCK_P
argument_list|(
name|b2
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|f1
operator|->
name|dest
operator|==
name|f2
operator|->
name|dest
operator|&&
name|b1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
condition|)
name|reverse
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
operator|&&
name|b1
operator|->
name|dest
operator|==
name|f2
operator|->
name|dest
condition|)
name|reverse
operator|=
name|true
expr_stmt|;
else|else
return|return
name|false
return|;
name|set1
operator|=
name|pc_set
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
expr_stmt|;
name|set2
operator|=
name|pc_set
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|!=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
condition|)
name|reverse
operator|=
operator|!
name|reverse
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|code2
operator|=
name|reversed_comparison_code
argument_list|(
name|cond2
argument_list|,
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code2
operator|=
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|==
name|UNKNOWN
condition|)
return|return
name|false
return|;
comment|/* Verify codes and operands match.  */
name|match
operator|=
operator|(
operator|(
name|code1
operator|==
name|code2
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|code1
operator|==
name|swap_condition
argument_list|(
name|code2
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we return true, we will join the blocks.  Which means that 	 we will only have one branch prediction bit to work with.  Thus 	 we require the existing branches to have probabilities that are 	 roughly similar.  */
if|if
condition|(
name|match
operator|&&
operator|!
name|optimize_size
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|bb1
argument_list|)
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|bb2
argument_list|)
condition|)
block|{
name|int
name|prob2
decl_stmt|;
if|if
condition|(
name|b1
operator|->
name|dest
operator|==
name|b2
operator|->
name|dest
condition|)
name|prob2
operator|=
name|b2
operator|->
name|probability
expr_stmt|;
else|else
comment|/* Do not use f2 probability as f2 may be forwarded.  */
name|prob2
operator|=
name|REG_BR_PROB_BASE
operator|-
name|b2
operator|->
name|probability
expr_stmt|;
comment|/* Fail if the difference in probabilities is greater than 50%. 	     This rules out two well-predicted branches with opposite 	     outcomes.  */
if|if
condition|(
name|abs
argument_list|(
name|b1
operator|->
name|probability
operator|-
name|prob2
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Outcomes of branch in bb %i and %i differs to much (%i %i)\n"
argument_list|,
name|bb1
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|,
name|b1
operator|->
name|probability
argument_list|,
name|prob2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
operator|&&
name|match
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Conditionals in bb %i and %i match.\n"
argument_list|,
name|bb1
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
comment|/* Generic case - we are seeing a computed jump, table jump or trapping      instruction.  */
ifndef|#
directive|ifndef
name|CASE_DROPS_THROUGH
comment|/* Check whether there are tablejumps in the end of BB1 and BB2.      Return true if they are identical.  */
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|;
name|rtx
name|table1
decl_stmt|,
name|table2
decl_stmt|;
if|if
condition|(
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
operator|&
name|label1
argument_list|,
operator|&
name|table1
argument_list|)
operator|&&
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|,
operator|&
name|label2
argument_list|,
operator|&
name|table2
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table1
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The labels should never be the same rtx.  If they really are same 	     the jump tables are same too. So disable crossjumping of blocks BB1 	     and BB2 because when deleting the common insns in the end of BB1 	     by delete_block () the jump table would be deleted too.  */
comment|/* If LABEL2 is referenced in BB1->END do not do anything 	     because we would loose information when replacing 	     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */
if|if
condition|(
name|label1
operator|!=
name|label2
operator|&&
operator|!
name|rtx_referenced_p
argument_list|(
name|label2
argument_list|,
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set IDENTICAL to true when the tables are identical.  */
name|bool
name|identical
init|=
name|false
decl_stmt|;
name|rtx
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|p1
operator|=
name|PATTERN
argument_list|(
name|table1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PATTERN
argument_list|(
name|table2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|ADDR_VEC
operator|&&
name|rtx_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|identical
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|&&
operator|(
name|XVECLEN
argument_list|(
name|p1
argument_list|,
literal|1
argument_list|)
operator|==
name|XVECLEN
argument_list|(
name|p2
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|p1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|p2
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|p1
argument_list|,
literal|3
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|p2
argument_list|,
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|identical
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|p1
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|identical
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|p1
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|identical
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|identical
condition|)
block|{
name|replace_label_data
name|rr
decl_stmt|;
name|bool
name|match
decl_stmt|;
comment|/* Temporarily replace references to LABEL1 with LABEL2 		     in BB1->END so that we could compare the instructions.  */
name|rr
operator|.
name|r1
operator|=
name|label1
expr_stmt|;
name|rr
operator|.
name|r2
operator|=
name|label2
expr_stmt|;
name|rr
operator|.
name|update_label_nuses
operator|=
name|false
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
name|replace_label
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
name|match
operator|=
name|insns_match_p
argument_list|(
name|mode
argument_list|,
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|&&
name|match
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Tablejumps in bb %i and %i match.\n"
argument_list|,
name|bb1
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Set the original label in BB1->END because when deleting 		     a block whose end is a tablejump, the tablejump referenced 		     from the instruction is deleted too.  */
name|rr
operator|.
name|r1
operator|=
name|label2
expr_stmt|;
name|rr
operator|.
name|r2
operator|=
name|label1
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
name|replace_label
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
return|return
name|false
return|;
block|}
block|}
endif|#
directive|endif
comment|/* First ensure that the instructions match.  There may be many outgoing      edges so this test is generally cheaper.  */
if|if
condition|(
operator|!
name|insns_match_p
argument_list|(
name|mode
argument_list|,
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Search the outgoing edges, ensure that the counts do match, find possible      fallthru and exception handling edges since these needs more      validation.  */
for|for
control|(
name|e1
operator|=
name|bb1
operator|->
name|succ
operator|,
name|e2
operator|=
name|bb2
operator|->
name|succ
init|;
name|e1
operator|&&
name|e2
condition|;
name|e1
operator|=
name|e1
operator|->
name|succ_next
operator|,
name|e2
operator|=
name|e2
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|nehedges1
operator|++
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|nehedges2
operator|++
expr_stmt|;
if|if
condition|(
name|e1
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru1
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru2
operator|=
name|e2
expr_stmt|;
block|}
comment|/* If number of edges of various types does not match, fail.  */
if|if
condition|(
name|e1
operator|||
name|e2
operator|||
name|nehedges1
operator|!=
name|nehedges2
operator|||
operator|(
name|fallthru1
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|fallthru2
operator|!=
literal|0
operator|)
condition|)
return|return
name|false
return|;
comment|/* fallthru edges must be forwarded to the same destination.  */
if|if
condition|(
name|fallthru1
condition|)
block|{
name|basic_block
name|d1
init|=
operator|(
name|forwarder_block_p
argument_list|(
name|fallthru1
operator|->
name|dest
argument_list|)
condition|?
name|fallthru1
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
else|:
name|fallthru1
operator|->
name|dest
operator|)
decl_stmt|;
name|basic_block
name|d2
init|=
operator|(
name|forwarder_block_p
argument_list|(
name|fallthru2
operator|->
name|dest
argument_list|)
condition|?
name|fallthru2
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
else|:
name|fallthru2
operator|->
name|dest
operator|)
decl_stmt|;
if|if
condition|(
name|d1
operator|!=
name|d2
condition|)
return|return
name|false
return|;
block|}
comment|/* Ensure the same EH region.  */
block|{
name|rtx
name|n1
init|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb1
argument_list|)
argument_list|,
name|REG_EH_REGION
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|n2
init|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|bb2
argument_list|)
argument_list|,
name|REG_EH_REGION
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n1
operator|&&
name|n2
condition|)
return|return
name|false
return|;
if|if
condition|(
name|n1
operator|&&
operator|(
operator|!
name|n2
operator|||
name|XEXP
argument_list|(
name|n1
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|n2
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We don't need to match the rest of edges as above checks should be enough      to ensure that they are equivalent.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* E1 and E2 are edges with the same destination block.  Search their    predecessors for common code.  If found, redirect control flow from    (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */
end_comment

begin_function
specifier|static
name|bool
name|try_crossjump_to_edge
parameter_list|(
name|int
name|mode
parameter_list|,
name|edge
name|e1
parameter_list|,
name|edge
name|e2
parameter_list|)
block|{
name|int
name|nmatch
decl_stmt|;
name|basic_block
name|src1
init|=
name|e1
operator|->
name|src
decl_stmt|,
name|src2
init|=
name|e2
operator|->
name|src
decl_stmt|;
name|basic_block
name|redirect_to
decl_stmt|,
name|redirect_from
decl_stmt|,
name|to_remove
decl_stmt|;
name|rtx
name|newpos1
decl_stmt|,
name|newpos2
decl_stmt|;
name|edge
name|s
decl_stmt|;
comment|/* Search backward through forwarder blocks.  We don't need to worry      about multiple entry or chained forwarders, as they will be optimized      away.  We do this to look past the unconditional jump following a      conditional jump that is required due to the current CFG shape.  */
if|if
condition|(
name|src1
operator|->
name|pred
operator|&&
operator|!
name|src1
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|src1
argument_list|)
condition|)
name|e1
operator|=
name|src1
operator|->
name|pred
operator|,
name|src1
operator|=
name|e1
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|src2
operator|->
name|pred
operator|&&
operator|!
name|src2
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|src2
argument_list|)
condition|)
name|e2
operator|=
name|src2
operator|->
name|pred
operator|,
name|src2
operator|=
name|e2
operator|->
name|src
expr_stmt|;
comment|/* Nothing to do if we reach ENTRY, or a common source block.  */
if|if
condition|(
name|src1
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|src2
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|src1
operator|==
name|src2
condition|)
return|return
name|false
return|;
comment|/* Seeing more than 1 forwarder blocks would confuse us later...  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|e1
operator|->
name|dest
argument_list|)
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|e1
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|e2
operator|->
name|dest
argument_list|)
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|e2
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Likewise with dead code (possibly newly created by the other optimizations      of cfg_cleanup).  */
if|if
condition|(
operator|!
name|src1
operator|->
name|pred
operator|||
operator|!
name|src2
operator|->
name|pred
condition|)
return|return
name|false
return|;
comment|/* Look for the common insn sequence, part the first ...  */
if|if
condition|(
operator|!
name|outgoing_edges_match
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* ... and part the second.  */
name|nmatch
operator|=
name|flow_find_cross_jump
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
operator|&
name|newpos1
argument_list|,
operator|&
name|newpos2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nmatch
condition|)
return|return
name|false
return|;
ifndef|#
directive|ifndef
name|CASE_DROPS_THROUGH
comment|/* Here we know that the insns in the end of SRC1 which are common with SRC2      will be deleted.      If we have tablejumps in the end of SRC1 and SRC2      they have been already compared for equivalence in outgoing_edges_match ()      so replace the references to TABLE1 by references to TABLE2.  */
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|;
name|rtx
name|table1
decl_stmt|,
name|table2
decl_stmt|;
if|if
condition|(
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|src1
argument_list|)
argument_list|,
operator|&
name|label1
argument_list|,
operator|&
name|table1
argument_list|)
operator|&&
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|src2
argument_list|)
argument_list|,
operator|&
name|label2
argument_list|,
operator|&
name|table2
argument_list|)
operator|&&
name|label1
operator|!=
name|label2
condition|)
block|{
name|replace_label_data
name|rr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Replace references to LABEL1 with LABEL2.  */
name|rr
operator|.
name|r1
operator|=
name|label1
expr_stmt|;
name|rr
operator|.
name|r2
operator|=
name|label2
expr_stmt|;
name|rr
operator|.
name|update_label_nuses
operator|=
name|true
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Do not replace the label in SRC1->END because when deleting 		 a block whose end is a tablejump, the tablejump referenced 		 from the instruction is deleted too.  */
if|if
condition|(
name|insn
operator|!=
name|BB_END
argument_list|(
name|src1
argument_list|)
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|replace_label
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Avoid splitting if possible.  */
if|if
condition|(
name|newpos2
operator|==
name|BB_HEAD
argument_list|(
name|src2
argument_list|)
condition|)
name|redirect_to
operator|=
name|src2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Splitting bb %i before %i insns\n"
argument_list|,
name|src2
operator|->
name|index
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
name|redirect_to
operator|=
name|split_block
argument_list|(
name|src2
argument_list|,
name|PREV_INSN
argument_list|(
name|newpos2
argument_list|)
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Cross jumping from bb %i to bb %i; %i common insns\n"
argument_list|,
name|src1
operator|->
name|index
argument_list|,
name|src2
operator|->
name|index
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
name|redirect_to
operator|->
name|count
operator|+=
name|src1
operator|->
name|count
expr_stmt|;
name|redirect_to
operator|->
name|frequency
operator|+=
name|src1
operator|->
name|frequency
expr_stmt|;
comment|/* We may have some registers visible trought the block.  */
name|redirect_to
operator|->
name|flags
operator||=
name|BB_DIRTY
expr_stmt|;
comment|/* Recompute the frequencies and counts of outgoing edges.  */
for|for
control|(
name|s
operator|=
name|redirect_to
operator|->
name|succ
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|succ_next
control|)
block|{
name|edge
name|s2
decl_stmt|;
name|basic_block
name|d
init|=
name|s
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|s2
operator|=
name|src1
operator|->
name|succ
init|;
condition|;
name|s2
operator|=
name|s2
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|d2
init|=
name|s2
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|d2
argument_list|)
condition|)
name|d2
operator|=
name|d2
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|d2
condition|)
break|break;
block|}
name|s
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
comment|/* Take care to update possible forwarder blocks.  We verified          that there is no more than one in the chain, so we can't run          into infinite loop.  */
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|s
operator|->
name|dest
argument_list|)
condition|)
block|{
name|s
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
name|s
operator|->
name|dest
operator|->
name|count
operator|+=
name|s2
operator|->
name|count
expr_stmt|;
name|s
operator|->
name|dest
operator|->
name|frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FORWARDER_BLOCK_P
argument_list|(
name|s2
operator|->
name|dest
argument_list|)
condition|)
block|{
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|-=
name|s2
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|succ
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|s2
operator|->
name|dest
operator|->
name|count
operator|-=
name|s2
operator|->
name|count
expr_stmt|;
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|dest
operator|->
name|count
operator|<
literal|0
condition|)
name|s2
operator|->
name|dest
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|redirect_to
operator|->
name|frequency
operator|&&
operator|!
name|src1
operator|->
name|frequency
condition|)
name|s
operator|->
name|probability
operator|=
operator|(
name|s
operator|->
name|probability
operator|+
name|s2
operator|->
name|probability
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|s
operator|->
name|probability
operator|=
operator|(
operator|(
name|s
operator|->
name|probability
operator|*
name|redirect_to
operator|->
name|frequency
operator|+
name|s2
operator|->
name|probability
operator|*
name|src1
operator|->
name|frequency
operator|)
operator|/
operator|(
name|redirect_to
operator|->
name|frequency
operator|+
name|src1
operator|->
name|frequency
operator|)
operator|)
expr_stmt|;
block|}
name|update_br_prob_note
argument_list|(
name|redirect_to
argument_list|)
expr_stmt|;
comment|/* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */
comment|/* Skip possible basic block header.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpos1
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|newpos1
operator|=
name|NEXT_INSN
argument_list|(
name|newpos1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpos1
argument_list|)
operator|==
name|NOTE
condition|)
name|newpos1
operator|=
name|NEXT_INSN
argument_list|(
name|newpos1
argument_list|)
expr_stmt|;
name|redirect_from
operator|=
name|split_block
argument_list|(
name|src1
argument_list|,
name|PREV_INSN
argument_list|(
name|newpos1
argument_list|)
argument_list|)
operator|->
name|src
expr_stmt|;
name|to_remove
operator|=
name|redirect_from
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|redirect_from
operator|->
name|succ
argument_list|,
name|redirect_to
argument_list|)
expr_stmt|;
name|delete_block
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|redirect_from
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search the predecessors of BB for common insn sequences.  When found,    share code between them by redirecting control flow.  Return true if    any changes made.  */
end_comment

begin_function
specifier|static
name|bool
name|try_crossjump_bb
parameter_list|(
name|int
name|mode
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|e2
decl_stmt|,
name|nexte2
decl_stmt|,
name|nexte
decl_stmt|,
name|fallthru
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|max
decl_stmt|;
comment|/* Nothing to do if there is not at least two incoming edges.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|pred
operator|||
operator|!
name|bb
operator|->
name|pred
operator|->
name|pred_next
condition|)
return|return
name|false
return|;
comment|/* It is always cheapest to redirect a block that ends in a branch to      a block that falls through into BB, as that adds no branches to the      program.  We'll try that combination first.  */
name|fallthru
operator|=
name|NULL
expr_stmt|;
name|max
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_CROSSJUMP_EDGES
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|max
condition|)
return|return
name|false
return|;
block|}
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|nexte
control|)
block|{
name|nexte
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
comment|/* As noted above, first try with the fallthru predecessor.  */
if|if
condition|(
name|fallthru
condition|)
block|{
comment|/* Don't combine the fallthru edge into anything else. 	     If there is a match, we'll do it the other way around.  */
if|if
condition|(
name|e
operator|==
name|fallthru
condition|)
continue|continue;
if|if
condition|(
name|try_crossjump_to_edge
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|fallthru
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|nexte
operator|=
name|bb
operator|->
name|pred
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Non-obvious work limiting check: Recognize that we're going 	 to call try_crossjump_bb on every basic block.  So if we have 	 two blocks with lots of outgoing edges (a switch) and they 	 share lots of common destinations, then we would do the 	 cross-jump check once for each common destination.  	 Now, if the blocks actually are cross-jump candidates, then 	 all of their destinations will be shared.  Which means that 	 we only need check them for cross-jump candidacy once.  We 	 can eliminate redundant checks of crossjump(A,B) by arbitrarily 	 choosing to do the check from the block for which the edge 	 in question is the first successor of A.  */
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|succ
operator|!=
name|e
condition|)
continue|continue;
for|for
control|(
name|e2
operator|=
name|bb
operator|->
name|pred
init|;
name|e2
condition|;
name|e2
operator|=
name|nexte2
control|)
block|{
name|nexte2
operator|=
name|e2
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
name|e2
operator|==
name|e
condition|)
continue|continue;
comment|/* We've already checked the fallthru edge above.  */
if|if
condition|(
name|e2
operator|==
name|fallthru
condition|)
continue|continue;
comment|/* The "first successor" check above only prevents multiple 	     checks of crossjump(A,B).  In order to prevent redundant 	     checks of crossjump(B,A), require that A be the block 	     with the lowest index.  */
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|>
name|e2
operator|->
name|src
operator|->
name|index
condition|)
continue|continue;
if|if
condition|(
name|try_crossjump_to_edge
argument_list|(
name|mode
argument_list|,
name|e
argument_list|,
name|e2
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|nexte
operator|=
name|bb
operator|->
name|pred
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Do simple CFG optimizations - basic block merging, simplifying of jump    instructions etc.  Return nonzero if changes were made.  */
end_comment

begin_function
specifier|static
name|bool
name|try_optimize_cfg
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|bool
name|changed_overall
init|=
name|false
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|int
name|iterations
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|b
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
condition|)
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|update_forwarder_flag
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|CLEANUP_UPDATE_LIFE
condition|)
name|clear_bb_flags
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|targetm
operator|.
name|cannot_modify_jumps_p
call|)
argument_list|()
condition|)
block|{
comment|/* Attempt to merge blocks as made possible by edge removal.  If 	 a block has only one successor, and the successor has only 	 one predecessor, they may be combined.  */
do|do
block|{
name|changed
operator|=
name|false
expr_stmt|;
name|iterations
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n\ntry_optimize_cfg iteration %i\n\n"
argument_list|,
name|iterations
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
init|;
name|b
operator|!=
name|EXIT_BLOCK_PTR
condition|;
control|)
block|{
name|basic_block
name|c
decl_stmt|;
name|edge
name|s
decl_stmt|;
name|bool
name|changed_here
init|=
name|false
decl_stmt|;
comment|/* Delete trivially dead basic blocks.  */
while|while
condition|(
name|b
operator|->
name|pred
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
name|b
operator|->
name|prev_bb
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleting block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
comment|/* Remove code labels no longer used.  Don't do this 		 before CALL_PLACEHOLDER is removed, as some branches 		 may be hidden within.  */
if|if
condition|(
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_PRE_SIBCALL
operator|)
operator|||
operator|!
name|tail_recursion_label_p
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
comment|/* If the previous block ends with a branch to this 		     block, we can't delete the label.  Normally this 		     is a condjump that is yet to be simplified, but 		     if CASE_DROPS_THRU, this can be a tablejump with 		     some element going to the same place as the 		     default (fallthru).  */
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|b
operator|->
name|pred
operator|->
name|src
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|label_is_jump_target_p
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|b
operator|->
name|pred
operator|->
name|src
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|delete_insn_chain
argument_list|(
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* In the case label is undeletable, move it after the 		     BASIC_BLOCK note.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
block|{
name|rtx
name|bb_note
init|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|reorder_insns_nobb
argument_list|(
name|label
argument_list|,
name|label
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|bb_note
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleted label in block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* If we fall through an empty block, we can remove it.  */
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
operator|&&
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
operator|(
name|b
operator|->
name|pred
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|FORWARDER_BLOCK_P
argument_list|(
name|b
argument_list|)
comment|/* Note that forwarder_block_p true ensures that 		     there is a successor for this block.  */
operator|&&
operator|(
name|b
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|&&
name|n_basic_blocks
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleting fallthru block %i.\n"
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|c
operator|=
name|b
operator|->
name|prev_bb
operator|==
name|ENTRY_BLOCK_PTR
condition|?
name|b
operator|->
name|next_bb
else|:
name|b
operator|->
name|prev_bb
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|b
operator|->
name|pred
argument_list|,
name|b
operator|->
name|succ
operator|->
name|dest
argument_list|)
expr_stmt|;
name|delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|(
name|c
operator|=
name|s
operator|->
name|dest
operator|)
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|c
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
name|b
operator|!=
name|c
condition|)
block|{
comment|/* When not in cfg_layout mode use code aware of reordering 		     INSN.  This code possibly creates new basic blocks so it 		     does not fit merge_blocks interface and is kept here in 		     hope that it will become useless once more of compiler 		     is transformed to use cfg_layout mode.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
operator|&&
name|can_merge_blocks_p
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|merge_blocks
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|update_forwarder_flag
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed_here
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
comment|/* If the jump insn has side effects, 			      we can't kill the edge.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|reload_completed
condition|?
name|simplejump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
else|:
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|next
operator|=
name|merge_blocks_move
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|b
operator|=
name|next
expr_stmt|;
name|changed_here
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Simplify branch over branch.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_EXPENSIVE
operator|)
operator|&&
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
operator|&&
name|try_simplify_condjump
argument_list|(
name|b
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* If B has a single outgoing edge, but uses a 		 non-trivial jump instruction without side-effects, we 		 can either delete the jump entirely, or replace it 		 with a simple unconditional jump.  */
if|if
condition|(
name|b
operator|->
name|succ
operator|&&
operator|!
name|b
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|b
operator|->
name|succ
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|)
operator|&&
name|try_redirect_by_replacing_jump
argument_list|(
name|b
operator|->
name|succ
argument_list|,
name|b
operator|->
name|succ
operator|->
name|dest
argument_list|,
operator|(
name|mode
operator|&
name|CLEANUP_CFGLAYOUT
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|update_forwarder_flag
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed_here
operator|=
name|true
expr_stmt|;
block|}
comment|/* Simplify branch to branch.  */
if|if
condition|(
name|try_forward_edges
argument_list|(
name|mode
argument_list|,
name|b
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* Look for shared code between blocks.  */
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
operator|)
operator|&&
name|try_crossjump_bb
argument_list|(
name|mode
argument_list|,
name|b
argument_list|)
condition|)
name|changed_here
operator|=
name|true
expr_stmt|;
comment|/* Don't get confused by the index shift caused by 		 deleting blocks.  */
if|if
condition|(
operator|!
name|changed_here
condition|)
name|b
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
else|else
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
operator|)
operator|&&
name|try_crossjump_bb
argument_list|(
name|mode
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|changed
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|changed_overall
operator||=
name|changed
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
block|}
if|if
condition|(
name|mode
operator|&
name|CLEANUP_CROSSJUMP
condition|)
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
return|return
name|changed_overall
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete all unreachable basic blocks.  */
end_comment

begin_function
name|bool
name|delete_unreachable_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|basic_block
name|b
decl_stmt|,
name|next_bb
decl_stmt|;
name|find_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Delete all unreachable basic blocks.  */
for|for
control|(
name|b
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
init|;
name|b
operator|!=
name|EXIT_BLOCK_PTR
condition|;
name|b
operator|=
name|next_bb
control|)
block|{
name|next_bb
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|BB_REACHABLE
operator|)
condition|)
block|{
name|delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|tidy_fallthru_edges
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tidy the CFG by deleting unreachable code and whatnot.  */
end_comment

begin_function
name|bool
name|cleanup_cfg
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CLEANUP_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_unreachable_blocks
argument_list|()
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
comment|/* We've possibly created trivially dead code.  Cleanup it right 	 now to introduce more opportunities for try_optimize_cfg.  */
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
operator|(
name|CLEANUP_NO_INSN_DEL
operator||
name|CLEANUP_UPDATE_LIFE
operator||
name|CLEANUP_PRE_SIBCALL
operator|)
operator|)
operator|&&
operator|!
name|reload_completed
condition|)
name|delete_trivially_dead_insns
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|compact_blocks
argument_list|()
expr_stmt|;
while|while
condition|(
name|try_optimize_cfg
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|delete_unreachable_blocks
argument_list|()
operator|,
name|changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|CLEANUP_UPDATE_LIFE
condition|)
block|{
comment|/* Cleaning up CFG introduces more opportunities for dead code 	     removal that in turn may introduce more opportunities for 	     cleaning up the CFG.  */
if|if
condition|(
operator|!
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
operator||
operator|(
operator|(
name|mode
operator|&
name|CLEANUP_LOG_LINKS
operator|)
condition|?
name|PROP_LOG_LINKS
else|:
literal|0
operator|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
operator|(
name|CLEANUP_NO_INSN_DEL
operator||
name|CLEANUP_PRE_SIBCALL
operator|)
operator|)
operator|&&
operator|(
name|mode
operator|&
name|CLEANUP_EXPENSIVE
operator|)
operator|&&
operator|!
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|delete_trivially_dead_insns
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
condition|)
break|break;
block|}
else|else
break|break;
name|delete_dead_jumptables
argument_list|()
expr_stmt|;
block|}
comment|/* Kill the data we won't maintain.  */
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|label_value_list
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CLEANUP_CFG
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

end_unit

