begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  Generic Unix version    (also used for UWIN and VMS).    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_ERRNO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_WAITPID
end_ifndef

begin_define
define|#
directive|define
name|waitpid
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
value|wait(status)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|execv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|execvp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
init|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|execvp
operator|:
name|execv
init|)
function_decl|;
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|input_desc
decl_stmt|,
name|output_desc
decl_stmt|;
name|int
name|retries
decl_stmt|,
name|sleep_interval
decl_stmt|;
comment|/* Pipe waiting from last process, to be used as input for the next one.      Value is STDIN_FILE_NO if no pipe is waiting      (i.e. the next command is the first of a group).  */
specifier|static
name|int
name|last_pipe_input
decl_stmt|;
comment|/* If this is the first process, initialize.  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_FIRST
condition|)
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|input_desc
operator|=
name|last_pipe_input
expr_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PEXECUTE_LAST
operator|)
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
literal|"pipe"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Last process.  */
name|output_desc
operator|=
name|STDOUT_FILE_NO
expr_stmt|;
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
block|}
comment|/* Fork a subprocess; wait and retry if it fails.  */
name|sleep_interval
operator|=
literal|1
expr_stmt|;
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|retries
operator|=
literal|0
init|;
name|retries
operator|<
literal|4
condition|;
name|retries
operator|++
control|)
block|{
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
name|sleep_interval
argument_list|)
expr_stmt|;
name|sleep_interval
operator|*=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
operator|*
name|errmsg_fmt
operator|=
literal|"fork"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* child */
comment|/* Move the input and output pipes into place, if necessary.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
comment|/* Close the parent's descs that aren't wanted here.  */
if|if
condition|(
name|last_pipe_input
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|last_pipe_input
argument_list|)
expr_stmt|;
comment|/* Exec the program.  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|program
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|this_pname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|install_error_msg
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
default|default:
comment|/* In the parent, after forking. 	 Close the descriptors that we made for this child.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
comment|/* Return child's process number.  */
return|return
name|pid
return|;
block|}
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

end_unit

