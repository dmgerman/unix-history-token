begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dwarf2 assembler output helper routines.    Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Output an unaligned integer with the given value and size.  Prefer not    to print a newline, since the caller may want to add a comment.  */
end_comment

begin_function
name|void
name|dw2_assemble_integer
parameter_list|(
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|integer_asm_op
argument_list|(
name|size
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|fputs
argument_list|(
name|op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an immediate constant in a given size.  */
end_comment

begin_function
name|void
name|dw2_asm_output_data
parameter_list|(
name|int
name|size
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|*
literal|8
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|value
operator|&=
operator|~
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|size
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the difference between two symbols in a given size.  */
end_comment

begin_comment
comment|/* ??? There appear to be assemblers that do not like such    subtraction, but do support ASM_SET_OP.  It's unfortunately    impossible to do here, since the ASM_SET_OP for the difference    symbol must appear after both symbols are defined.  */
end_comment

begin_function
name|void
name|dw2_asm_output_delta
parameter_list|(
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|lab1
parameter_list|,
specifier|const
name|char
modifier|*
name|lab2
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DWARF_DELTA
name|ASM_OUTPUT_DWARF_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|,
name|lab1
argument_list|,
name|lab2
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|lab1
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|lab2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a section-relative reference to a label.  In general this    can only be done for debugging symbols.  E.g. on most targets with    the GNU linker, this is accomplished with a direct reference and    the knowledge that the debugging section will be placed at VMA 0.    Some targets have special relocations for this that we must use.  */
end_comment

begin_function
name|void
name|dw2_asm_output_offset
parameter_list|(
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DWARF_OFFSET
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a self-relative reference to a label, possibly in a    different section or object file.  */
end_comment

begin_function
name|void
name|dw2_asm_output_pcrel
parameter_list|(
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|label
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DWARF_PCREL
name|ASM_OUTPUT_DWARF_PCREL
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an absolute reference to a label.  */
end_comment

begin_function
name|void
name|dw2_asm_output_addr
parameter_list|(
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but use an RTX expression instead of a text label.  */
end_comment

begin_function
name|void
name|dw2_asm_output_addr_rtx
parameter_list|(
name|int
name|size
parameter_list|,
name|rtx
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the first ORIG_LEN characters of STR as a string.    If ORIG_LEN is equal to -1, ignore this parameter and output    the entire STR instead.    If COMMENT is not NULL and comments in the debug information    have been requested by the user, append the given COMMENT    to the generated output.  */
end_comment

begin_function
name|void
name|dw2_asm_output_nstring
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|orig_len
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|len
operator|=
name|orig_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ascii \""
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|str
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\\0\"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If an explicit length was given, we can't assume there 	 is a null termination in the string buffer.  */
if|if
condition|(
name|orig_len
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_len
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size of an unsigned LEB128 quantity.  */
end_comment

begin_function
name|int
name|size_of_uleb128
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
do|do
block|{
name|value
operator|>>=
literal|7
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a signed LEB128 quantity.  */
end_comment

begin_function
name|int
name|size_of_sleb128
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|,
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
operator|(
name|value
operator|==
literal|0
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
operator|==
operator|-
literal|1
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Given an encoding, return the number of bytes the format occupies.    This is only defined for fixed-size encodings, and so does not    include leb128.  */
end_comment

begin_function
name|int
name|size_of_encoded_value
parameter_list|(
name|int
name|encoding
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x07
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
return|return
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
return|;
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Yield a name for a given pointer encoding.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|eh_data_format_name
parameter_list|(
name|int
name|format
parameter_list|)
block|{
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
define|#
directive|define
name|S
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|[p] = v,
else|#
directive|else
define|#
directive|define
name|S
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|case p: return v;
endif|#
directive|endif
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
name|__extension__
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|format_names
index|[
literal|256
index|]
init|=
block|{
else|#
directive|else
switch|switch
condition|(
name|format
condition|)
block|{
endif|#
directive|endif
name|S
argument_list|(
argument|DW_EH_PE_absptr
argument_list|,
literal|"absolute"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_omit
argument_list|,
literal|"omit"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_aligned
argument_list|,
literal|"aligned absolute"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_uleb128
argument_list|,
literal|"uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata2
argument_list|,
literal|"udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata4
argument_list|,
literal|"udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata8
argument_list|,
literal|"udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sleb128
argument_list|,
literal|"sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata2
argument_list|,
literal|"sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata4
argument_list|,
literal|"sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata8
argument_list|,
literal|"sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_absptr | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_uleb128 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata2 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata4 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata8 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sleb128 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata2 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata4 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata8 | DW_EH_PE_pcrel
argument_list|,
literal|"pcrel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_absptr | DW_EH_PE_textrel
argument_list|,
literal|"textrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_uleb128 | DW_EH_PE_textrel
argument_list|,
literal|"textrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata2 | DW_EH_PE_textrel
argument_list|,
literal|"textrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata4 | DW_EH_PE_textrel
argument_list|,
literal|"textrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata8 | DW_EH_PE_textrel
argument_list|,
literal|"textrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sleb128 | DW_EH_PE_textrel
argument_list|,
literal|"textrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata2 | DW_EH_PE_textrel
argument_list|,
literal|"textrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata4 | DW_EH_PE_textrel
argument_list|,
literal|"textrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata8 | DW_EH_PE_textrel
argument_list|,
literal|"textrel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_absptr | DW_EH_PE_datarel
argument_list|,
literal|"datarel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_uleb128 | DW_EH_PE_datarel
argument_list|,
literal|"datarel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata2 | DW_EH_PE_datarel
argument_list|,
literal|"datarel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata4 | DW_EH_PE_datarel
argument_list|,
literal|"datarel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata8 | DW_EH_PE_datarel
argument_list|,
literal|"datarel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sleb128 | DW_EH_PE_datarel
argument_list|,
literal|"datarel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata2 | DW_EH_PE_datarel
argument_list|,
literal|"datarel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata4 | DW_EH_PE_datarel
argument_list|,
literal|"datarel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata8 | DW_EH_PE_datarel
argument_list|,
literal|"datarel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_absptr | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_uleb128 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata2 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata4 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_udata8 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sleb128 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata2 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata4 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_sdata8 | DW_EH_PE_funcrel
argument_list|,
literal|"funcrel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_pcrel
argument_list|,
literal|"indirect pcrel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_textrel
argument_list|,
literal|"indirect textrel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_datarel
argument_list|,
literal|"indirect datarel sdata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel uleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel udata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel udata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel udata8"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel sleb128"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel sdata2"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel sdata4"
argument_list|)
name|S
argument_list|(
argument|DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_funcrel
argument_list|,
literal|"indirect funcrel sdata8"
argument_list|)
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
block|}
empty_stmt|;
if|if
condition|(
name|format
operator|<
literal|0
operator|||
name|format
operator|>
literal|0xff
operator|||
name|format_names
index|[
name|format
index|]
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|format_names
index|[
name|format
index|]
return|;
else|#
directive|else
block|}
end_function

begin_expr_stmt
name|abort
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/* Output an unsigned LEB128 quantity.  */
end_comment

begin_macro
unit|void
name|dw2_asm_output_data_uleb128
argument_list|(
argument|unsigned HOST_WIDE_INT value
argument_list|,
argument|const char *comment
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.uleb128 "
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|work
init|=
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|byte_op
init|=
name|targetm
operator|.
name|asm_out
operator|.
name|byte_op
decl_stmt|;
if|if
condition|(
name|byte_op
condition|)
name|fputs
argument_list|(
name|byte_op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|byte
init|=
operator|(
name|work
operator|&
literal|0x7f
operator|)
decl_stmt|;
name|work
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|work
operator|!=
literal|0
condition|)
comment|/* More bytes to follow.  */
name|byte
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|byte_op
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|!=
literal|0
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|work
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s uleb128 "
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
condition|)
block|{
name|fputs
argument_list|(
literal|"; "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Output a signed LEB128 quantity.  */
end_comment

begin_function
name|void
name|dw2_asm_output_data_sleb128
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.sleb128 "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|HOST_WIDE_INT
name|work
init|=
name|value
decl_stmt|;
name|int
name|more
decl_stmt|,
name|byte
decl_stmt|;
specifier|const
name|char
modifier|*
name|byte_op
init|=
name|targetm
operator|.
name|asm_out
operator|.
name|byte_op
decl_stmt|;
if|if
condition|(
name|byte_op
condition|)
name|fputs
argument_list|(
name|byte_op
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|work
operator|&
literal|0x7f
operator|)
expr_stmt|;
comment|/* arithmetic shift */
name|work
operator|>>=
literal|7
expr_stmt|;
name|more
operator|=
operator|!
operator|(
operator|(
name|work
operator|==
literal|0
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|work
operator|==
operator|-
literal|1
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|byte_op
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s sleb128 "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
condition|)
block|{
name|fputs
argument_list|(
literal|"; "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dw2_asm_output_delta_uleb128
parameter_list|(
specifier|const
name|char
modifier|*
name|lab1
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|lab2
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|fputs
argument_list|(
literal|"\t.uleb128 "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lab2
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dw2_asm_output_delta_sleb128
parameter_list|(
specifier|const
name|char
modifier|*
name|lab1
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|lab2
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AS_LEB128
name|fputs
argument_list|(
literal|"\t.sleb128 "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lab2
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|rtx
name|dw2_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dw2_output_indirect_constant_1
parameter_list|(
name|splay_tree_node
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param1_is (char *), param2_is (tree))
argument_list|)
name|splay_tree
name|indirect_pool
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|dw2_const_labelno
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GAS_HIDDEN
argument_list|)
operator|&&
name|defined
argument_list|(
name|SUPPORTS_ONE_ONLY
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_LINKONCE_INDIRECT
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_LINKONCE_INDIRECT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put X, a SYMBOL_REF, in memory.  Return a SYMBOL_REF to the allocated    memory.  Differs from force_const_mem in that a single pool is used for    the entire unit of translation, and the memory is not guaranteed to be    "near" the function in any interesting sense.  */
end_comment

begin_function
specifier|static
name|rtx
name|dw2_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|indirect_pool
condition|)
name|indirect_pool
operator|=
name|splay_tree_new_ggc
argument_list|(
name|splay_tree_compare_pointers
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|str
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|indirect_pool
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|decl
operator|=
operator|(
name|tree
operator|)
name|node
operator|->
name|value
expr_stmt|;
else|else
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|USE_LINKONCE_INDIRECT
condition|)
block|{
name|char
modifier|*
name|ref_name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
sizeof|sizeof
expr|"DW.ref."
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|ref_name
argument_list|,
literal|"DW.ref.%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|ref_name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|label
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LDFCM"
argument_list|,
name|dw2_const_labelno
argument_list|)
expr_stmt|;
operator|++
name|dw2_const_labelno
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|indirect_pool
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|str
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A helper function for dw2_output_indirect_constants called through    splay_tree_foreach.  Emit one queued constant to memory.  */
end_comment

begin_function
specifier|static
name|int
name|dw2_output_indirect_constant_1
parameter_list|(
name|splay_tree_node
name|node
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
name|rtx
name|sym_ref
decl_stmt|;
name|sym
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|node
operator|->
name|key
expr_stmt|;
name|sym_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_LINKONCE_INDIRECT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.hidden %sDW.ref.%s\n"
argument_list|,
name|user_label_prefix
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|assemble_variable
argument_list|(
operator|(
name|tree
operator|)
name|node
operator|->
name|value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|sym_ref
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit the constants queued through dw2_force_const_mem.  */
end_comment

begin_function
name|void
name|dw2_output_indirect_constants
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|indirect_pool
condition|)
name|splay_tree_foreach
argument_list|(
name|indirect_pool
argument_list|,
name|dw2_output_indirect_constant_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like dw2_asm_output_addr_rtx, but encode the pointer as directed.  */
end_comment

begin_function
name|void
name|dw2_asm_output_encoded_addr_rtx
parameter_list|(
name|int
name|encoding
parameter_list|,
name|rtx
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_of_encoded_value
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* NULL is _always_ represented as a plain zero, as is 1 for Ada's      "all others".  */
if|if
condition|(
name|addr
operator|==
name|const0_rtx
operator|||
name|addr
operator|==
name|const1_rtx
condition|)
name|assemble_integer
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|restart
label|:
comment|/* Allow the target first crack at emitting this.  Some of the 	 special relocations require special directives instead of 	 just ".4byte" or whatever.  */
ifdef|#
directive|ifdef
name|ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX
name|ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX
argument_list|(
name|asm_out_file
argument_list|,
name|encoding
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Indirection is used to get dynamic relocations out of a 	 read-only section.  */
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_indirect
condition|)
block|{
comment|/* It is very tempting to use force_const_mem so that we share data 	     with the normal constant pool.  However, we've already emitted 	     the constant pool for this function.  Moreover, we'd like to 	     share these constants across the entire unit of translation, 	     or better, across the entire application (or DSO).  */
name|addr
operator|=
name|dw2_force_const_mem
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|encoding
operator|&=
operator|~
name|DW_EH_PE_indirect
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
switch|switch
condition|(
name|encoding
operator|&
literal|0xF0
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DWARF_PCREL
name|ASM_OUTPUT_DWARF_PCREL
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|,
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|dw2_assemble_integer
argument_list|(
name|size
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
comment|/* Other encodings should have been handled by 	     ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX
name|done
label|:
empty_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|flag_debug_asm
operator|&&
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|asm_out_file
argument_list|,
name|comment
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-dwarf2asm.h"
end_include

end_unit

