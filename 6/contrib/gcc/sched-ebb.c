begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The number of insns to be scheduled in total.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementations of the sched_info functions for region scheduling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|new_ready
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ebb_print_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rank
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|earliest_block_with_similiar_load
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_deps_for_risky_insns
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|schedule_ebb
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|fix_basic_block_boundaries
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_missing_bbs
parameter_list|(
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return nonzero if there are more insns that should be scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sched_n_insns
operator|<
name|target_n_insns
return|;
block|}
end_function

begin_comment
comment|/* Add all insns that are initially ready to the ready list READY.  Called    once before scheduling a set of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_n_insns
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Print debugging information.  */
block|if (sched_verbose>= 5)     debug_dependencies ();
endif|#
directive|endif
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|target_n_insns
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after taking INSN from the ready list.  Returns nonzero if this    insn can be scheduled, nonzero if we should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|sched_n_insns
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called after INSN has all its dependencies resolved.  Return nonzero    if it should be moved to the ready list or the queue, or zero if we    should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|new_ready
parameter_list|(
name|rtx
name|next
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a string that contains the insn uid and optionally anything else    necessary to identify this insn in an output.  It's valid to use a    static buffer for this.  The ALIGNED parameter should cause the string    to be formatted so that multiple output lines will line up nicely.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ebb_print_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|aligned
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%4d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Compare priority of two insns.  Return a positive number if the second    insn is to be preferred for scheduling, and a negative one if the first    is to be preferred.  Zero if they are equally good.  */
end_comment

begin_function
specifier|static
name|int
name|rank
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|)
block|{
name|basic_block
name|bb1
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn1
argument_list|)
decl_stmt|;
name|basic_block
name|bb2
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb1
operator|->
name|count
operator|>
name|bb2
operator|->
name|count
operator|||
name|bb1
operator|->
name|frequency
operator|>
name|bb2
operator|->
name|frequency
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bb1
operator|->
name|count
operator|<
name|bb2
operator|->
name|count
operator|||
name|bb1
operator|->
name|frequency
operator|<
name|bb2
operator|->
name|frequency
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NEXT is an instruction that depends on INSN (a backward dependence);    return nonzero if we should include this dependence in priority    calculations.  */
end_comment

begin_function
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
name|next
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* INSN is a JUMP_INSN, COND_SET is the set of registers that are     conditionally set before INSN.  Store the set of registers that     must be considered as used by this jump in USED and that of     registers that must be considered as set in SET.  */
end_comment

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|regset
name|cond_set
parameter_list|,
name|regset
name|used
parameter_list|,
name|regset
name|set
parameter_list|)
block|{
name|basic_block
name|b
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
comment|/* The jump may be a by-product of a branch that has been merged 	 in the main codepath after being conditionalized.  Therefore 	 it may guard the fallthrough block from using a value that has 	 conditionally overwritten that of the main codepath.  So we 	 consider that it restores the value of the main codepath.  */
name|bitmap_operation
argument_list|(
name|set
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|,
name|cond_set
argument_list|,
name|BITMAP_AND
argument_list|)
expr_stmt|;
else|else
name|bitmap_operation
argument_list|(
name|used
argument_list|,
name|used
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in schedule_insns to initialize current_sched_info for scheduling    regions (or single basic blocks).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|ebb_sched_info
init|=
block|{
name|init_ready_list
block|,
name|can_schedule_ready_p
block|,
name|schedule_more_p
block|,
name|new_ready
block|,
name|rank
block|,
name|ebb_print_insn
block|,
name|contributes_to_priority
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* It is possible that ebb scheduling eliminated some blocks.    Place blocks from FIRST to LAST before BEFORE.  */
end_comment

begin_function
specifier|static
name|void
name|add_missing_bbs
parameter_list|(
name|rtx
name|before
parameter_list|,
name|basic_block
name|first
parameter_list|,
name|basic_block
name|last
parameter_list|)
block|{
for|for
control|(
init|;
name|last
operator|!=
name|first
operator|->
name|prev_bb
condition|;
name|last
operator|=
name|last
operator|->
name|prev_bb
control|)
block|{
name|before
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|NOTE_BASIC_BLOCK
argument_list|(
name|before
argument_list|)
operator|=
name|last
expr_stmt|;
name|BB_HEAD
argument_list|(
name|last
argument_list|)
operator|=
name|before
expr_stmt|;
name|BB_END
argument_list|(
name|last
argument_list|)
operator|=
name|before
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup the CFG after EBB scheduling.  Re-recognize the basic    block boundaries in between HEAD and TAIL and update basic block    structures between BB and LAST.  */
end_comment

begin_function
specifier|static
name|basic_block
name|fix_basic_block_boundaries
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|last
parameter_list|,
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|head
decl_stmt|;
name|rtx
name|last_inside
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|aftertail
init|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|head
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|!=
name|aftertail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create new basic blocks just before first insn.  */
if|if
condition|(
name|inside_basic_block_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last_inside
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Re-emit the basic block note for newly found BB header.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|head
operator|=
name|insn
expr_stmt|;
name|last_inside
operator|=
name|note
expr_stmt|;
block|}
else|else
block|{
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|head
operator|=
name|note
expr_stmt|;
name|last_inside
operator|=
name|insn
expr_stmt|;
block|}
block|}
else|else
name|last_inside
operator|=
name|insn
expr_stmt|;
block|}
comment|/* Control flow instruction terminate basic block.  It is possible 	 that we've eliminated some basic blocks (made them empty). 	 Find the proper basic block using BLOCK_FOR_INSN and arrange things in 	 a sensible way by inserting empty basic blocks as needed.  */
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|insn
operator|==
name|tail
operator|&&
name|last_inside
operator|)
condition|)
block|{
name|basic_block
name|curr_bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|curr_bb
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|last
operator|->
name|next_bb
condition|)
block|{
name|edge
name|f
decl_stmt|;
name|rtx
name|h
decl_stmt|;
comment|/* An obscure special case, where we do have partially dead 	         instruction scheduled after last control flow instruction. 	         In this case we can create new basic block.  It is 	         always exactly one basic block last in the sequence.  Handle 	         it by splitting the edge and repositioning the block. 	         This is somewhat hackish, but at least avoid cut&paste  	         A safer solution can be to bring the code into sequence, 	         do the split and re-emit it back in case this will ever 	         trigger problem.  */
name|f
operator|=
name|bb
operator|->
name|prev_bb
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|f
operator|&&
operator|!
operator|(
name|f
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|f
operator|=
name|f
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|last
operator|=
name|curr_bb
operator|=
name|split_edge
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|h
operator|=
name|BB_HEAD
argument_list|(
name|curr_bb
argument_list|)
expr_stmt|;
name|BB_HEAD
argument_list|(
name|curr_bb
argument_list|)
operator|=
name|head
expr_stmt|;
name|BB_END
argument_list|(
name|curr_bb
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Edge splitting created misplaced BASIC_BLOCK note, kill 		     it.  */
name|delete_insn
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
comment|/* It may happen that code got moved past unconditional jump in 	         case the code is completely dead.  Kill it.  */
else|else
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|delete_insn_chain
argument_list|(
name|head
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* We keep some notes in the way that may split barrier from the 		     jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|emit_barrier_after
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|BB_HEAD
argument_list|(
name|curr_bb
argument_list|)
operator|=
name|head
expr_stmt|;
name|BB_END
argument_list|(
name|curr_bb
argument_list|)
operator|=
name|insn
expr_stmt|;
name|add_missing_bbs
argument_list|(
name|BB_HEAD
argument_list|(
name|curr_bb
argument_list|)
argument_list|,
name|bb
argument_list|,
name|curr_bb
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
block|}
name|note
operator|=
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|?
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
else|:
name|head
expr_stmt|;
name|NOTE_BASIC_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|curr_bb
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|curr_bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|curr_bb
operator|->
name|next_bb
expr_stmt|;
name|last_inside
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
break|break;
block|}
block|}
name|add_missing_bbs
argument_list|(
name|BB_HEAD
argument_list|(
name|last
operator|->
name|next_bb
argument_list|)
argument_list|,
name|bb
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return
name|bb
operator|->
name|prev_bb
return|;
block|}
end_function

begin_comment
comment|/* Returns the earliest block in EBB currently being processed where a    "similar load" 'insn2' is found, and hence LOAD_INSN can move    speculatively into the found block.  All the following must hold:     (1) both loads have 1 base register (PFREE_CANDIDATEs).    (2) load_insn and load2 have a def-use dependence upon    the same insn 'insn1'.     From all these we can conclude that the two loads access memory    addresses that differ at most by a constant, and hence if moving    load_insn would cause an exception, it would have been caused by    load2 anyhow.     The function uses list (given by LAST_BLOCK) of already processed    blocks in EBB.  The list is formed in `add_deps_for_risky_insns'.  */
end_comment

begin_function
specifier|static
name|basic_block
name|earliest_block_with_similiar_load
parameter_list|(
name|basic_block
name|last_block
parameter_list|,
name|rtx
name|load_insn
parameter_list|)
block|{
name|rtx
name|back_link
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|earliest_block
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|back_link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|back_link
condition|;
name|back_link
operator|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|back_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, load_insn).  */
name|rtx
name|fore_link
decl_stmt|;
for|for
control|(
name|fore_link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|fore_link
condition|;
name|fore_link
operator|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn2
init|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|basic_block
name|insn2_block
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|fore_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|earliest_block
operator|!=
name|NULL
operator|&&
name|earliest_block
operator|->
name|index
operator|<
name|insn2_block
operator|->
name|index
condition|)
continue|continue;
comment|/* Found a DEF-USE dependence (insn1, insn2).  */
if|if
condition|(
name|haifa_classify_insn
argument_list|(
name|insn2
argument_list|)
operator|!=
name|PFREE_CANDIDATE
condition|)
comment|/* insn2 not guaranteed to be a 1 base reg load.  */
continue|continue;
for|for
control|(
name|bb
operator|=
name|last_block
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|aux
control|)
if|if
condition|(
name|insn2_block
operator|==
name|bb
condition|)
break|break;
if|if
condition|(
operator|!
name|bb
condition|)
comment|/* insn2 is the similar load.  */
name|earliest_block
operator|=
name|insn2_block
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|earliest_block
return|;
block|}
end_function

begin_comment
comment|/* The following function adds dependencies between jumps and risky    insns in given ebb.  */
end_comment

begin_function
specifier|static
name|void
name|add_deps_for_risky_insns
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|class
decl_stmt|;
name|rtx
name|last_jump
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|next_tail
init|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|basic_block
name|last_block
init|=
name|NULL
decl_stmt|,
name|bb
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|last_block
expr_stmt|;
name|last_block
operator|=
name|bb
expr_stmt|;
name|last_jump
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|last_jump
operator|!=
name|NULL_RTX
condition|)
block|{
name|class
operator|=
name|haifa_classify_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev
operator|=
name|last_jump
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|PFREE_CANDIDATE
case|:
if|if
condition|(
name|flag_schedule_speculative_load
condition|)
block|{
name|bb
operator|=
name|earliest_block_with_similiar_load
argument_list|(
name|last_block
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
name|bb
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
break|break;
name|prev
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|TRAP_RISKY
case|:
case|case
name|IRISKY
case|:
case|case
name|PRISKY_CANDIDATE
case|:
comment|/* ??? We could implement better checking PRISKY_CANDIDATEs 	       analogous to sched-rgn.c.  */
comment|/* We can not change the mode of the backward 	       dependency because REG_DEP_ANTI has the lowest 	       rank.  */
if|if
condition|(
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|REG_DEP_ANTI
argument_list|)
condition|)
name|add_forward_dependence
argument_list|(
name|prev
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Maintain the invariant that bb->aux is clear after use.  */
while|while
condition|(
name|last_block
condition|)
block|{
name|bb
operator|=
name|last_block
operator|->
name|aux
expr_stmt|;
name|last_block
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|last_block
operator|=
name|bb
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Schedule a single extended basic block, defined by the boundaries HEAD    and TAIL.  */
end_comment

begin_function
specifier|static
name|basic_block
name|schedule_ebb
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|int
name|n_insns
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|struct
name|deps
name|tmp_deps
decl_stmt|;
name|basic_block
name|first_bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|basic_block
name|last_bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|tail
argument_list|)
decl_stmt|;
if|if
condition|(
name|no_real_insns_p
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
condition|)
return|return
name|BLOCK_FOR_INSN
argument_list|(
name|tail
argument_list|)
return|;
name|init_deps_global
argument_list|()
expr_stmt|;
comment|/* Compute LOG_LINKS.  */
name|init_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Compute INSN_DEPEND.  */
name|compute_forward_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|add_deps_for_risky_insns
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
condition|)
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* Set priorities.  */
name|n_insns
operator|=
name|set_priorities
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
name|first_bb
operator|->
name|index
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* rm_other_notes only removes notes which are _inside_ the      block---that is, it won't remove notes before the first real insn      or after the last real insn of the block.  So if the first insn      has a REG_SAVE_NOTE which would otherwise be emitted before the      insn, it is redundant with the note before the start of the      block, and so we have to take it out.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove remaining note insns from the block, save them in      note_list.  These notes are restored at the end of      schedule_block ().  */
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|=
literal|1
expr_stmt|;
name|schedule_block
argument_list|(
operator|-
literal|1
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
comment|/* Sanity check: verify that all region insns were scheduled.  */
if|if
condition|(
name|sched_n_insns
operator|!=
name|n_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
name|head
operator|=
name|current_sched_info
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|current_sched_info
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|restore_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|b
operator|=
name|fix_basic_block_boundaries
argument_list|(
name|first_bb
argument_list|,
name|last_bb
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|finish_deps_global
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_ebbs
parameter_list|(
name|FILE
modifier|*
name|dump_file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|probability_cutoff
decl_stmt|;
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY
argument_list|)
expr_stmt|;
name|probability_cutoff
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|probability_cutoff
expr_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
name|sched_init
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|current_sched_info
operator|=
operator|&
name|ebb_sched_info
expr_stmt|;
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* Schedule every region in the subroutine.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|edge
name|e
decl_stmt|;
name|tail
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|GET_CODE
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
operator|->
name|next_bb
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
name|e
operator|->
name|probability
operator|<=
name|probability_cutoff
condition|)
break|break;
name|bb
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
block|}
comment|/* Blah.  We should fix the rest of the code not to get confused by 	 a note or two.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|bb
operator|=
name|schedule_ebb
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* Updating life info can be done by local propagation over the modified      superblocks.  */
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
name|sched_finish
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

