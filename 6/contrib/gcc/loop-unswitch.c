begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop unswitching for GNU compiler.    Copyright (C) 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* This pass moves constant conditions out of loops, duplicating the loop    in progress, i.e. this code:     while (loop_cond)      {        A;        if (cond)          branch1;        else 	 branch2;        B;        if (cond)          branch3;        C;      }    where nothing inside the loop alters cond is transformed    into     if (cond)      {        while (loop_cond) 	 { 	   A; 	   branch1; 	   B; 	   branch3; 	   C; 	 }      }    else      {        while (loop_cond) 	 { 	   A; 	   branch2; 	   B; 	   C; 	 }      }    Duplicating the loop might lead to code growth exponential in number of   branches inside loop, so we limit the number of unswitchings performed   in a single loop to PARAM_MAX_UNSWITCH_LEVEL.  We only perform the   transformation on innermost loops, as the benefit of doing it on loops   containing subloops would not be very large compared to complications   with handling this case.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|loop
modifier|*
name|unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|may_unswitch_on_p
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|reversed_condition
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */
end_comment

begin_function
name|void
name|unswitch_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
comment|/* Go through inner loops (only original ones).  */
name|num
operator|=
name|loops
operator|->
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Removed loop?  */
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
continue|continue;
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its    basic blocks (for what it means see comments below).  List of basic blocks    inside LOOP is provided in BODY to save time.  */
end_comment

begin_function
specifier|static
name|bool
name|may_unswitch_on_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
modifier|*
name|body
parameter_list|)
block|{
name|rtx
name|test
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* BB must end in a simple conditional jump.  */
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|||
operator|!
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* With branches inside loop.  */
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
operator|->
name|succ
operator|->
name|dest
argument_list|)
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* It must be executed just once each iteration (because otherwise we      are unable to update dominator/irreducible loop information correctly).  */
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Condition must be invariant.  We use just a stupid test of invariantness      of the condition: all used regs must not be modified inside loop body.  */
name|test
operator|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|modified_between_p
argument_list|(
name|test
argument_list|,
name|BB_HEAD
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Reverses CONDition; returns NULL if we cannot.  */
end_comment

begin_function
specifier|static
name|rtx
name|reversed_condition
parameter_list|(
name|rtx
name|cond
parameter_list|)
block|{
name|enum
name|rtx_code
name|reversed
decl_stmt|;
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
else|else
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reversed
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unswitch single LOOP.  COND_CHECKED holds list of conditions we already    unswitched on and are therefore known to be true in this LOOP.  NUM is    number of unswitchings done; do not allow it to grow too much, it is too    easy to create example on that the code would grow exponentially.  */
end_comment

begin_function
specifier|static
name|void
name|unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|cond_checked
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|true_first
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|rcond
decl_stmt|,
name|conds
decl_stmt|,
name|rconds
decl_stmt|,
name|acond
decl_stmt|,
name|split_before
decl_stmt|;
name|int
name|always_true
decl_stmt|;
name|int
name|always_false
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Do not unswitch too much.  */
if|if
condition|(
name|num
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_LEVEL
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching anymore, hit max level\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only unswitch innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching, not innermost loop\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We must be able to duplicate loop body.  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching, can't duplicate loop\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The loop should not be too large, to limit code growth.  */
if|if
condition|(
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_INSNS
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching, loop too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not unswitch in cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching, not hot area\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Nor if the loop usually does not roll.  */
if|if
condition|(
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unswitching, loop iterations< 1\n"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|repeat
operator|=
literal|0
expr_stmt|;
comment|/* Find a bb to unswitch on.  */
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|may_unswitch_on_p
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|loop
argument_list|,
name|bbs
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|loop
operator|->
name|num_nodes
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|cond
operator|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|&
name|split_before
argument_list|,
name|true
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rcond
operator|=
name|reversed_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Check whether the result can be predicted.  */
name|always_true
operator|=
literal|0
expr_stmt|;
name|always_false
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|acond
operator|=
name|cond_checked
init|;
name|acond
condition|;
name|acond
operator|=
name|XEXP
argument_list|(
name|acond
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cond
argument_list|,
name|XEXP
argument_list|(
name|acond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|always_true
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|rcond
argument_list|,
name|XEXP
argument_list|(
name|acond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|always_false
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|always_true
condition|)
block|{
comment|/* Remove false path.  */
for|for
control|(
name|e
operator|=
name|bbs
index|[
name|i
index|]
operator|->
name|succ
init|;
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
empty_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|always_false
condition|)
block|{
comment|/* Remove true path.  */
for|for
control|(
name|e
operator|=
name|bbs
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
empty_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|repeat
condition|)
do|;
comment|/* We found the condition we can unswitch on.  */
name|conds
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|,
name|cond_checked
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcond
condition|)
name|rconds
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|rcond
argument_list|,
name|cond_checked
argument_list|)
expr_stmt|;
else|else
name|rconds
operator|=
name|cond_checked
expr_stmt|;
comment|/* Separate condition in a single basic block.  */
name|bb
operator|=
name|split_loop_bb
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|PREV_INSN
argument_list|(
name|split_before
argument_list|)
argument_list|)
operator|->
name|dest
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|true_first
operator|=
operator|!
operator|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unswitching loop\n"
argument_list|)
expr_stmt|;
comment|/* Unswitch the loop on this condition.  */
name|nloop
operator|=
name|unswitch_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nloop
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Invoke itself on modified loops.  */
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|nloop
argument_list|,
name|true_first
condition|?
name|conds
else|:
name|rconds
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|true_first
condition|?
name|rconds
else|:
name|conds
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|conds
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcond
condition|)
name|free_EXPR_LIST_node
argument_list|(
name|rconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support    unswitching of innermost loops.  UNSWITCH_ON must be executed in every    iteration, i.e. it must dominate LOOP latch, and should only contain code    for the condition we unswitch on.  Returns NULL if impossible, new    loop otherwise.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|unswitch_on
parameter_list|)
block|{
name|edge
name|entry
decl_stmt|,
name|latch_edge
decl_stmt|;
name|basic_block
name|switch_bb
decl_stmt|,
name|unswitch_on_alt
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|sbitmap
name|zero_bitmap
decl_stmt|;
name|int
name|irred_flag
decl_stmt|;
comment|/* Some sanity checking.  */
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|unswitch_on
operator|->
name|succ
operator|||
operator|!
name|unswitch_on
operator|->
name|succ
operator|->
name|succ_next
operator|||
name|unswitch_on
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Will we be able to perform redirection?  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|unswitch_on
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|cfg_layout_can_duplicate_bb_p
argument_list|(
name|unswitch_on
argument_list|)
condition|)
return|return
name|NULL
return|;
name|entry
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Make a copy.  */
name|src
operator|=
name|entry
operator|->
name|src
expr_stmt|;
name|irred_flag
operator|=
name|entry
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|zero_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|entry
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|zero_bitmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|free
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|irred_flag
expr_stmt|;
comment|/* Record the block with condition we unswitch on.  */
name|unswitch_on_alt
operator|=
name|unswitch_on
operator|->
name|rbi
operator|->
name|copy
expr_stmt|;
comment|/* Make a copy of the block containing the condition; we will use      it as switch to decide which loop we want to use.  */
name|switch_bb
operator|=
name|cfg_layout_duplicate_bb
argument_list|(
name|unswitch_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|irred_flag
condition|)
block|{
name|switch_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|switch_bb
operator|->
name|succ
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|switch_bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
else|else
block|{
name|switch_bb
operator|->
name|flags
operator|&=
operator|~
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|switch_bb
operator|->
name|succ
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|switch_bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
name|unswitch_on
operator|->
name|rbi
operator|->
name|copy
operator|=
name|unswitch_on_alt
expr_stmt|;
comment|/* Loopify from the copy of LOOP body, constructing the new loop.  */
for|for
control|(
name|latch_edge
operator|=
name|loop
operator|->
name|latch
operator|->
name|rbi
operator|->
name|copy
operator|->
name|succ
init|;
name|latch_edge
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|;
name|latch_edge
operator|=
name|latch_edge
operator|->
name|succ_next
control|)
empty_stmt|;
name|nloop
operator|=
name|loopify
argument_list|(
name|loops
argument_list|,
name|latch_edge
argument_list|,
name|loop
operator|->
name|header
operator|->
name|rbi
operator|->
name|copy
operator|->
name|pred
argument_list|,
name|switch_bb
argument_list|)
expr_stmt|;
comment|/* Remove branches that are now unreachable in new loops.  We rely on the      fact that cfg_layout_duplicate_bb reverses list of edges.  */
name|remove_path
argument_list|(
name|loops
argument_list|,
name|unswitch_on
operator|->
name|succ
argument_list|)
expr_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|unswitch_on_alt
operator|->
name|succ
argument_list|)
expr_stmt|;
comment|/* One of created loops do not have to be subloop of the outer loop now,      so fix its placement in loop data structure.  */
name|fix_loop_placement
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|fix_loop_placement
argument_list|(
name|nloop
argument_list|)
expr_stmt|;
comment|/* Preserve the simple loop preheaders.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|nloop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|nloop
return|;
block|}
end_function

end_unit

