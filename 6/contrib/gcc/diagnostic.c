begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent diagnostic subroutines for the GNU Compiler Collection    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements the language independent aspect of diagnostic    message module.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_diagnostic_finalizer
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|error_recursion
argument_list|(
name|diagnostic_context
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|text_specifies_location
parameter_list|(
name|text_info
modifier|*
parameter_list|,
name|location_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|diagnostic_count_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|diagnostic_action_after_output
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|real_abort
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A diagnostic_context surrogate for stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|diagnostic_context
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|global_dc
init|=
operator|&
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boilerplate text used in two locations.  */
end_comment

begin_define
define|#
directive|define
name|bug_report_request
define|\
value|"Please submit a full bug report,\n\ with preprocessed source if appropriate.\n\ See %s for instructions.\n"
end_define

begin_escape
end_escape

begin_comment
comment|/* Return a malloc'd string containing MSG formatted a la printf.  The    caller is responsible for freeing the memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_message_string
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|str
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Same as diagnostic_build_prefix, but only the source FILE is given.  */
end_comment

begin_function
name|char
modifier|*
name|file_name_as_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
return|return
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|f
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the diagnostic message outputting machinery.  */
end_comment

begin_function
name|void
name|diagnostic_initialize
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
comment|/* Allocate a basic pretty-printer.  Clients will replace this a      much more elaborated pretty-printer if they wish.  */
name|context
operator|->
name|printer
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pretty_printer
argument_list|)
argument_list|)
expr_stmt|;
name|pp_construct
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* By default, diagnostics are sent to stderr.  */
name|context
operator|->
name|printer
operator|->
name|buffer
operator|->
name|stream
operator|=
name|stderr
expr_stmt|;
comment|/* By default, we emit prefixes once per message.  */
name|context
operator|->
name|printer
operator|->
name|prefixing_rule
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|memset
argument_list|(
name|context
operator|->
name|diagnostic_count
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|context
operator|->
name|diagnostic_count
argument_list|)
expr_stmt|;
name|context
operator|->
name|warnings_are_errors_message
operator|=
name|warnings_are_errors
expr_stmt|;
name|context
operator|->
name|abort_on_error
operator|=
name|false
expr_stmt|;
name|context
operator|->
name|internal_error
operator|=
name|NULL
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_finalizer
expr_stmt|;
name|context
operator|->
name|last_module
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|last_function
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|x_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if the next format specifier in TEXT is a format specifier    for a location_t.  If so, update the object pointed by LOCUS to reflect    the specified location in *TEXT->args_ptr.  */
end_comment

begin_function
specifier|static
name|bool
name|text_specifies_location
parameter_list|(
name|text_info
modifier|*
name|text
parameter_list|,
name|location_t
modifier|*
name|locus
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Skip any leading text.  */
for|for
control|(
name|p
operator|=
name|text
operator|->
name|format_spec
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Extract the location information if any.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'H'
condition|)
block|{
operator|*
name|locus
operator|=
operator|*
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|location_t
operator|*
argument_list|)
expr_stmt|;
name|text
operator|->
name|format_spec
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'J'
condition|)
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
decl_stmt|;
operator|*
name|locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|text
operator|->
name|format_spec
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|diagnostic_set_info
parameter_list|(
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|location_t
name|location
parameter_list|,
name|diagnostic_t
name|kind
parameter_list|)
block|{
name|diagnostic
operator|->
name|message
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|args_ptr
operator|=
name|args
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
comment|/* If the diagnostic message doesn't specify a location,      use LOCATION.  */
if|if
condition|(
operator|!
name|text_specifies_location
argument_list|(
operator|&
name|diagnostic
operator|->
name|message
argument_list|,
operator|&
name|diagnostic
operator|->
name|location
argument_list|)
condition|)
name|diagnostic
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|diagnostic
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a malloc'd string describing a location.  The caller is    responsible for freeing the memory.  */
end_comment

begin_function
name|char
modifier|*
name|diagnostic_build_prefix
parameter_list|(
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|diagnostic_kind_text
index|[]
init|=
block|{
define|#
directive|define
name|DEFINE_DIAGNOSTIC_KIND
parameter_list|(
name|K
parameter_list|,
name|T
parameter_list|)
value|(T),
include|#
directive|include
file|"diagnostic.def"
undef|#
directive|undef
name|DEFINE_DIAGNOSTIC_KIND
literal|"must-not-happen"
block|}
decl_stmt|;
if|if
condition|(
name|diagnostic
operator|->
name|kind
operator|>=
name|DK_LAST_DIAGNOSTIC_KIND
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|diagnostic
operator|->
name|location
operator|.
name|file
condition|?
name|build_message_string
argument_list|(
literal|"%s:%d: %s"
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|file
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|line
argument_list|,
name|_
argument_list|(
name|diagnostic_kind_text
index|[
name|diagnostic
operator|->
name|kind
index|]
argument_list|)
argument_list|)
else|:
name|build_message_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|progname
argument_list|,
name|_
argument_list|(
name|diagnostic_kind_text
index|[
name|diagnostic
operator|->
name|kind
index|]
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Count a diagnostic.  Return true if the message should be printed.  */
end_comment

begin_function
specifier|static
name|bool
name|diagnostic_count_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
name|diagnostic_t
name|kind
init|=
name|diagnostic
operator|->
name|kind
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|DK_ICE
case|:
ifndef|#
directive|ifndef
name|ENABLE_CHECKING
comment|/* When not checking, ICEs are converted to fatal errors when an 	 error has already occurred.  This is counteracted by 	 abort_on_error.  */
if|if
condition|(
operator|(
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_ERROR
argument_list|)
operator|>
literal|0
operator|||
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_SORRY
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|!
name|context
operator|->
name|abort_on_error
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: confused by earlier errors, bailing out\n"
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|file
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|line
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|context
operator|->
name|internal_error
condition|)
call|(
modifier|*
name|context
operator|->
name|internal_error
call|)
argument_list|(
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
argument_list|,
name|diagnostic
operator|->
name|message
operator|.
name|args_ptr
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DK_FATAL
case|:
case|case
name|DK_SORRY
case|:
case|case
name|DK_ANACHRONISM
case|:
case|case
name|DK_NOTE
case|:
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
case|case
name|DK_WARNING
case|:
if|if
condition|(
operator|!
name|diagnostic_report_warnings_p
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|warnings_are_errors
condition|)
block|{
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|context
operator|->
name|warnings_are_errors_message
condition|)
block|{
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|context
operator|->
name|warnings_are_errors_message
operator|=
name|false
expr_stmt|;
block|}
comment|/* And fall through.  */
case|case
name|DK_ERROR
case|:
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Take any action which is expected to happen after the diagnostic    is written out.  This function does not always return.  */
end_comment

begin_function
specifier|static
name|void
name|diagnostic_action_after_output
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
switch|switch
condition|(
name|diagnostic
operator|->
name|kind
condition|)
block|{
case|case
name|DK_DEBUG
case|:
case|case
name|DK_NOTE
case|:
case|case
name|DK_ANACHRONISM
case|:
case|case
name|DK_WARNING
case|:
break|break;
case|case
name|DK_ERROR
case|:
case|case
name|DK_SORRY
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|DK_ICE
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
name|bug_report_request
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
case|case
name|DK_FATAL
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"compilation terminated.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
default|default:
name|real_abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function   that caused an error.  Called from all error and warning functions.   We ignore the FILE parameter, as it cannot be relied upon.  */
end_comment

begin_function
name|void
name|diagnostic_report_current_function
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|diagnostic_report_current_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|print_error_function
call|)
argument_list|(
name|context
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|diagnostic_report_current_module
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
condition|)
block|{
name|pp_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|diagnostic_last_module_changed
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|p
operator|=
name|input_file_stack
expr_stmt|;
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"In file included from %s:%d"
argument_list|,
name|p
operator|->
name|location
operator|.
name|file
argument_list|,
name|p
operator|->
name|location
operator|.
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|",\n                 from %s:%d"
argument_list|,
name|p
operator|->
name|location
operator|.
name|file
argument_list|,
name|p
operator|->
name|location
operator|.
name|line
argument_list|)
expr_stmt|;
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|diagnostic_set_last_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
name|diagnostic_report_current_function
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pp_set_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_finalizer
argument_list|(
name|diagnostic_context
operator|*
name|context
argument_list|,
name|diagnostic_info
operator|*
name|diagnostic
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
name|pp_destroy_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a diagnostic message (an error or a warning) as specified by    DC.  This function is *the* subroutine in terms of which front-ends    should implement their specific diagnostic handling modules.  The    front-end independent format specifiers are exactly those described    in the documentation of output_format.  */
end_comment

begin_function
name|void
name|diagnostic_report_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|lock
operator|++
operator|&&
name|diagnostic
operator|->
name|kind
operator|<
name|DK_SORRY
condition|)
name|error_recursion
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnostic_count_diagnostic
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
condition|)
block|{
operator|(
operator|*
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|pp_format_text
argument_list|(
name|context
operator|->
name|printer
argument_list|,
operator|&
name|diagnostic
operator|->
name|message
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|pp_flush
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|diagnostic_action_after_output
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|lock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a partial pathname as input, return another pathname that    shares no directory elements with the pathname of __FILE__.  This    is used by fancy_abort() to print `Internal compiler error in expr.c'    instead of `Internal compiler error in ../../GCC/gcc/expr.c'.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trim_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|this_file
index|[]
init|=
name|__FILE__
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|,
modifier|*
name|q
init|=
name|this_file
decl_stmt|;
comment|/* First skip any "../" in each filename.  This allows us to give a proper      reference to a file in a subdirectory.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|q
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|q
operator|+=
literal|3
expr_stmt|;
comment|/* Now skip any parts the two filenames have in common.  */
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|)
name|p
operator|++
operator|,
name|q
operator|++
expr_stmt|;
comment|/* Now go backwards until the previous directory separator.  */
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR_2
endif|#
directive|endif
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Standard error reporting routines in increasing order of severity.    All of these take arguments like printf.  */
end_comment

begin_comment
comment|/* Text to be emitted verbatim to the error message stream; this    produces no prefix and disables line-wrapping.  Use rarely.  */
end_comment

begin_function
name|void
name|verbatim
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|pp_format_verbatim
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An informative note.  Use this for additional details on an error    message.  */
end_comment

begin_function
name|void
name|inform
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_NOTE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A warning.  Use this for code which is correct according to the    relevant language specification but is likely to be buggy anyway.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A "pedantic" warning: issues a warning unless -pedantic-errors was    given on the command line, in which case it issues an error.  Use    this for diagnostics required by the relevant language standard,    if you have chosen not to make them errors.     Note that these diagnostics are issued independent of the setting    of the -pedantic command-line switch.  To get a warning enabled    only with that switch, write "if (pedantic) pedwarn (...);"  */
end_comment

begin_function
name|void
name|pedwarn
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|pedantic_error_kind
argument_list|()
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A hard error: the code is definitely ill-formed, and an object file    will not be produced.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "Sorry, not implemented."  Use for a language feature which is    required by the relevant specification but not implemented by GCC.    An object file will not be produced.  */
end_comment

begin_function
name|void
name|sorry
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_SORRY
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An error which is severe enough that we make no attempt to    continue.  Do not use this for internal consistency checks; that's    internal_error.  Use of this function should be rare.  */
end_comment

begin_function
name|void
name|fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_FATAL
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|real_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An internal consistency check has failed.  We make no attempt to    continue.  Note that unless there is debugging value to be had from    a more specific message, or some other good reason, you should use    abort () instead of calling this function directly.  */
end_comment

begin_function
name|void
name|internal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_ICE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|real_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Special case error functions.  Most are implemented in terms of the    above, or should be.  */
end_comment

begin_comment
comment|/* Print a diagnostic MSGID on FILE.  This is just fprintf, except it    runs its second argument through gettext.  */
end_comment

begin_function
name|void
name|fnotice
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inform the user that an error occurred while trying to report some    other error.  This indicates catastrophic internal inconsistencies,    so give up now.  But do try to flush out the previous error.    This mustn't use internal_error, that will cause infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|error_recursion
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|lock
operator|<
literal|3
condition|)
name|pp_flush
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal compiler error: Error reporting routines re-entered.\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
name|bug_report_request
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an internal compiler error in a friendly manner.  This is    the function that gets called upon use of abort() in the source    code generally, thanks to a special macro.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"in %s, at %s:%d"
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Really call the system 'abort'.  This has to go right at the end of    this file, so that there are no functions after it that call abort    and get the system abort instead of our macro.  */
end_comment

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_function
specifier|static
name|void
name|real_abort
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

