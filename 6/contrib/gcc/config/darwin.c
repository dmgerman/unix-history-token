begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for generic Darwin as target machine for GNU C compiler.    Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Contributed by Apple Computer Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_function_decl
specifier|static
name|int
name|machopic_data_defined_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_non_lazy_ptrs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_stubs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|machopic_non_lazy_ptr_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|name_needs_quotes
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|ISIDNUM
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * flag_pic = 1 ... generate only indirections  * flag_pic = 2 ... generate indirections and pure code  */
end_comment

begin_comment
comment|/* This module assumes that (const (symbol_ref "foo")) is a legal pic    reference, which will not be changed.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|machopic_defined_list
expr_stmt|;
end_expr_stmt

begin_function
name|enum
name|machopic_addr_class
name|machopic_classify_ident
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
decl_stmt|;
name|int
name|lprefix
init|=
operator|(
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'"'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|)
operator|)
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'O'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'B'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'J'
operator|&&
name|name
index|[
literal|4
index|]
operator|==
literal|'C'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'_'
operator|)
operator|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
comment|/* The PIC base symbol is always defined. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"<pic base>"
argument_list|)
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'!'
condition|)
block|{
comment|/* Here if no special encoding to be found.  */
if|if
condition|(
name|lprefix
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|5
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|"$stub"
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|>
literal|6
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
literal|6
argument_list|,
literal|"$stub\""
argument_list|)
operator|)
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_defined_list
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|ident
argument_list|)
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
return|return
name|MACHOPIC_UNDEFINED
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
comment|/* It is possible that someone is holding a "stale" name, which has      since been defined.  See if there is a "defined" name (i.e,      different from NAME only in having a '!D_' or a '!T_' instead of      a '!d_' or '!t_' prefix) in the identifier hash tables.  If so, say      that this identifier is defined.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_name
index|[
literal|1
index|]
operator|=
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
condition|?
literal|'D'
else|:
literal|'T'
expr_stmt|;
if|if
condition|(
name|maybe_get_identifier
argument_list|(
name|new_name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
condition|?
name|MACHOPIC_DEFINED_DATA
else|:
name|MACHOPIC_DEFINED_FUNCTION
return|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_defined_list
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
else|else
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|lprefix
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
else|else
return|return
name|MACHOPIC_UNDEFINED_FUNCTION
return|;
block|}
else|else
block|{
if|if
condition|(
name|lprefix
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
else|else
return|return
name|MACHOPIC_UNDEFINED_DATA
return|;
block|}
block|}
end_function

begin_function
name|enum
name|machopic_addr_class
name|machopic_classify_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|machopic_classify_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|machopic_ident_defined_p
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
switch|switch
condition|(
name|machopic_classify_ident
argument_list|(
name|ident
argument_list|)
condition|)
block|{
case|case
name|MACHOPIC_UNDEFINED
case|:
case|case
name|MACHOPIC_UNDEFINED_DATA
case|:
case|case
name|MACHOPIC_UNDEFINED_FUNCTION
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|machopic_data_defined_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
switch|switch
condition|(
name|machopic_classify_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|MACHOPIC_DEFINED_DATA
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|machopic_name_defined_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|machopic_ident_defined_p
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|machopic_define_ident
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
if|if
condition|(
operator|!
name|machopic_ident_defined_p
argument_list|(
name|ident
argument_list|)
condition|)
name|machopic_defined_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|machopic_defined_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_define_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|machopic_define_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|char
operator|*
name|function_base
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|char
modifier|*
name|machopic_function_base_name
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|current_name
decl_stmt|;
comment|/* if dynamic-no-pic is on, we should not get here */
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_base
operator|==
name|NULL
condition|)
name|function_base
operator|=
operator|(
name|char
operator|*
operator|)
name|ggc_alloc_string
argument_list|(
literal|"<pic base>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"<pic base>"
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|function_base
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
specifier|const
name|char
operator|*
name|function_base_func_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|current_pic_label_num
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|machopic_output_function_base_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|current_name
decl_stmt|;
comment|/* If dynamic-no-pic is on, we should not get here. */
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_base_func_name
operator|!=
name|current_name
condition|)
block|{
operator|++
name|current_pic_label_num
expr_stmt|;
name|function_base_func_name
operator|=
name|current_name
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"L%011d$pb\""
argument_list|,
name|current_pic_label_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|machopic_non_lazy_pointers
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a non-lazy pointer name corresponding to the given name,    either by finding it in our list of pointer names, or by generating    a new one.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|machopic_non_lazy_ptr_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|temp_name
decl_stmt|;
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
name|name
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try again, but comparing names this time.  */
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|temp_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|temp_name
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
block|}
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|bufferlen
init|=
literal|0
decl_stmt|;
name|tree
name|ptr_name
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|namelen
operator|+
name|strlen
argument_list|(
literal|"$non_lazy_ptr"
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&L"
argument_list|)
expr_stmt|;
name|bufferlen
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|namelen
operator|-
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|bufferlen
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
argument_list|,
literal|"$non_lazy_ptr"
argument_list|,
name|strlen
argument_list|(
literal|"$non_lazy_ptr"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|strlen
argument_list|(
literal|"$non_lazy_ptr"
argument_list|)
expr_stmt|;
name|ptr_name
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|machopic_non_lazy_pointers
operator|=
name|tree_cons
argument_list|(
name|ptr_name
argument_list|,
name|ident
argument_list|,
name|machopic_non_lazy_pointers
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|machopic_non_lazy_pointers
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|ptr_name
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|machopic_stubs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return the name of the stub corresponding to the given name,    generating a new stub name if necessary.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|machopic_stub_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
name|tname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
comment|/* A library call name might not be section-encoded yet, so try 	 it against a stripped name.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'!'
operator|&&
name|tname
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|tname
operator|+
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
name|name
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|bufferlen
init|=
literal|0
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|ptr_name
decl_stmt|;
name|int
name|needs_quotes
init|=
name|name_needs_quotes
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|namelen
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_quotes
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&\"L"
argument_list|)
expr_stmt|;
name|bufferlen
operator|=
name|strlen
argument_list|(
literal|"&\"L"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&L"
argument_list|)
expr_stmt|;
name|bufferlen
operator|=
name|strlen
argument_list|(
literal|"&L"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|namelen
operator|-
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|bufferlen
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|needs_quotes
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
argument_list|,
literal|"$stub\""
argument_list|,
name|strlen
argument_list|(
literal|"$stub\""
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|strlen
argument_list|(
literal|"$stub\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufferlen
argument_list|,
literal|"$stub"
argument_list|,
name|strlen
argument_list|(
literal|"$stub"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferlen
operator|+=
name|strlen
argument_list|(
literal|"$stub"
argument_list|)
expr_stmt|;
block|}
name|ptr_name
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|machopic_stubs
operator|=
name|tree_cons
argument_list|(
name|ptr_name
argument_list|,
name|ident
argument_list|,
name|machopic_stubs
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|machopic_stubs
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|ptr_name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|machopic_validate_stub_or_non_lazy_ptr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|validate_stub
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|id2
decl_stmt|;
for|for
control|(
name|temp
operator|=
operator|(
name|validate_stub
condition|?
name|machopic_stubs
else|:
name|machopic_non_lazy_pointers
operator|)
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|ident
operator|==
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
comment|/* Mark both the stub or non-lazy pointer as well as the 	     original symbol as being referenced.  */
name|TREE_USED
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|mark_referenced
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|real_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|real_name
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
name|id2
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id2
condition|)
name|mark_referenced
argument_list|(
name|id2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Transform ORIG, which may be any data source, to the corresponding    source using indirections.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_data_reference
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|ptr_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|defined
init|=
name|machopic_data_defined_p
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|defined
operator|&&
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_low
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* some other cpu -- writeme!  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|defined
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_lo_sum
argument_list|)
name|rtx
name|pic_base
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
init|=
operator|(
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|reg
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_lo_sum
argument_list|)
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|orig
return|;
block|}
name|ptr_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_non_lazy_ptr_name
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|ptr_ref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|ptr_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ptr_ref
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|result
decl_stmt|;
comment|/* legitimize both operands of the PLUS */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|orig
return|;
if|if
condition|(
name|MACHOPIC_PURE
operator|&&
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
name|result
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* When the target is i386, this code prevents crashes due to the      compiler's ignorance on how to move the PIC base register to      other registers.  (The reload phase sometimes introduces such      insns.)  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
ifdef|#
directive|ifdef
name|I386
comment|/* Prevent the same register from being erroneously used 	      as both the base and index registers.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
endif|#
directive|endif
operator|&&
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|ptr_ref
return|;
block|}
end_function

begin_comment
comment|/* Transform TARGET (a MEM), which is a function call target, to the    corresponding symbol_stub if necessary.  Return a new MEM.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_call_target
parameter_list|(
name|rtx
name|target
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|target
return|;
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the name is already defined, we need do nothing.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|target
return|;
if|if
condition|(
operator|!
name|machopic_name_defined_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|stub_name
init|=
name|machopic_stub_name
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|mode
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
name|rtx
name|machopic_legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|pic_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
return|return
name|orig
return|;
comment|/* First handle a simple SYMBOL_REF or LABEL_REF */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
condition|)
block|{
comment|/* addr(foo) =&func+(foo-func) */
name|rtx
name|pic_base
decl_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|orig
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
return|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* if dynamic-no-pic then use 0 as the pic base  */
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|pic_base
operator|=
name|CONST0_RTX
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|pic_base
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* ppc  */
name|rtx
name|temp_reg
init|=
operator|(
name|no_new_pseudos
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|asym
init|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|temp_reg
argument_list|,
name|asym
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|asym
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Some other CPU -- WriteMe! but right now there are no other platform that can use dynamic-no-pic  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
comment|/* Generating a new reg may expose opportunities for 		 common subexpression elimination.  */
name|rtx
name|hi_sum_reg
init|=
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
name|sum
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|sum
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|sum
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|pic_ref
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_lo_sum */
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx_USE (VOIDmode, 				      gen_rtx_REG (Pmode,  						   PIC_OFFSET_TABLE_REGNUM)));
endif|#
directive|endif
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
name|hi_sum_reg
operator|=
name|reg
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
operator|(
name|MACHO_DYNAMIC_NO_PIC_P
operator|)
condition|?
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
else|:
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/*  HAVE_lo_sum  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|REG
condition|)
block|{
return|return
name|orig
return|;
block|}
else|else
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx_USE (VOIDmode, 					  pic_offset_table_rtx));
endif|#
directive|endif
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic_ref
argument_list|)
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
else|else
block|{
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|pic_ref
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|pic_ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|orig
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|!=
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|int
name|is_complex
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
decl_stmt|;
name|base
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|pic_ref
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|is_complex
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|base
argument_list|)
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg
operator|&&
name|is_complex
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Likewise, should we set special REG_NOTEs here?  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|addr
init|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|addr
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|pic_ref
return|;
block|}
end_function

begin_function
name|void
name|machopic_finish
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|)
block|{
name|tree
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|stub
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|temp
argument_list|)
condition|)
continue|continue;
name|sym_name
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
name|sym
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|else
name|sym
index|[
literal|0
index|]
operator|=
literal|'_'
operator|,
name|strcpy
argument_list|(
name|sym
operator|+
literal|1
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|stub
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|stub_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|stub_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|stub
argument_list|,
name|stub_name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|stub
index|[
literal|0
index|]
operator|=
literal|'_'
operator|,
name|strcpy
argument_list|(
name|stub
operator|+
literal|1
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|machopic_output_stub
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|lazy_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|temp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|machopic_ident_defined_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
block|{
name|data_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|lazy_name
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|sym_name
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|machopic_nl_symbol_ptr_section
argument_list|()
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lazy_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.indirect_symbol "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|machopic_operand_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function records whether a given name corresponds to a defined    or undefined function or variable, for machopic_classify_ident to    use later.  */
end_comment

begin_function
name|void
name|darwin_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|code
init|=
literal|'\0'
decl_stmt|;
name|int
name|defined
init|=
literal|0
decl_stmt|;
name|rtx
name|sym_ref
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_str
decl_stmt|;
name|char
modifier|*
name|new_str
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|new_len
decl_stmt|;
comment|/* Do the standard encoding things first.  */
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* With the introduction of symbol_ref flags, some of the following      code has become redundant and should be removed at some point.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|)
condition|)
name|defined
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|code
operator|=
operator|(
name|defined
condition|?
literal|'T'
else|:
literal|'t'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|code
operator|=
operator|(
name|defined
condition|?
literal|'D'
else|:
literal|'d'
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'\0'
condition|)
return|return;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|orig_str
operator|=
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|orig_str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|orig_str
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* Already encoded; see if we need to change it.  */
if|if
condition|(
name|code
operator|==
name|orig_str
index|[
literal|1
index|]
condition|)
return|return;
comment|/* Yes, tweak a copy of the name and put it in a new string.  */
name|new_str
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_str
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_str
index|[
literal|1
index|]
operator|=
name|code
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|new_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the encoding.  */
name|new_len
operator|=
name|len
operator|+
literal|4
expr_stmt|;
name|new_str
operator|=
name|alloca
argument_list|(
name|new_len
argument_list|)
expr_stmt|;
name|new_str
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|new_str
index|[
literal|1
index|]
operator|=
name|code
expr_stmt|;
name|new_str
index|[
literal|2
index|]
operator|=
literal|'_'
expr_stmt|;
name|new_str
index|[
literal|3
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
name|new_str
operator|+
literal|4
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|new_str
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
block|}
comment|/* The non-lazy pointer list may have captured references to the      old encoded name, change them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|update_non_lazy_ptrs
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|update_stubs
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the effects of the above.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|darwin_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
index|[
literal|0
index|]
operator|==
literal|'!'
condition|?
name|str
operator|+
literal|4
else|:
name|str
return|;
block|}
end_function

begin_comment
comment|/* Scan the list of non-lazy pointers and update any recorded names whose    stripped name matches the argument.  */
end_comment

begin_function
specifier|static
name|void
name|update_non_lazy_ptrs
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|name1
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'!'
condition|)
block|{
name|name2
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: This breaks the identifier hash table.  */
name|IDENTIFIER_NODE_CHECK
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|->
name|identifier
operator|.
name|id
operator|.
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the list of stubs and update any recorded names whose    stripped name matches the argument.  */
end_comment

begin_function
specifier|static
name|void
name|update_stubs
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|name1
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'!'
condition|)
block|{
name|name2
operator|=
name|darwin_strip_name_encoding
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: This breaks the identifier hash table.  */
name|IDENTIFIER_NODE_CHECK
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|->
name|identifier
operator|.
name|id
operator|.
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|machopic_select_section
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|base_function
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
if|if
condition|(
name|decl_readonly_section_1
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|MACHOPIC_INDIRECT
argument_list|)
condition|)
name|base_function
operator|=
name|readonly_data_section
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
condition|)
name|base_function
operator|=
name|const_data_section
expr_stmt|;
else|else
name|base_function
operator|=
name|data_section
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
operator|==
name|strlen
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
operator|&&
operator|!
name|flag_writable_strings
condition|)
name|cstring_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|&&
name|flag_merge_constants
condition|)
block|{
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|==
literal|4
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
name|literal4_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|==
literal|8
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
name|literal8_section
argument_list|()
expr_stmt|;
else|else
name|base_function
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"NSConstantString"
argument_list|)
condition|)
name|objc_constant_string_object_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"NXConstantString"
argument_list|)
condition|)
name|objc_string_object_section
argument_list|()
expr_stmt|;
else|else
name|base_function
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
literal|"_OBJC_"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_METHODS_"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_cls_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_INSTANCE_METHODS_"
argument_list|,
literal|23
argument_list|)
condition|)
name|objc_inst_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_CLASS_METHODS_"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_cat_cls_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS_"
argument_list|,
literal|23
argument_list|)
condition|)
name|objc_cat_inst_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_VARIABLES_"
argument_list|,
literal|22
argument_list|)
condition|)
name|objc_class_vars_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES_"
argument_list|,
literal|25
argument_list|)
condition|)
name|objc_instance_vars_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_PROTOCOLS_"
argument_list|,
literal|22
argument_list|)
condition|)
name|objc_cat_cls_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_NAME_"
argument_list|,
literal|17
argument_list|)
condition|)
name|objc_class_names_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METH_VAR_NAME_"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_meth_var_names_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METH_VAR_TYPE_"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_meth_var_types_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_REFERENCES"
argument_list|,
literal|22
argument_list|)
condition|)
name|objc_cls_refs_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_"
argument_list|,
literal|12
argument_list|)
condition|)
name|objc_class_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METACLASS_"
argument_list|,
literal|16
argument_list|)
condition|)
name|objc_meta_class_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_"
argument_list|,
literal|15
argument_list|)
condition|)
name|objc_category_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES"
argument_list|,
literal|25
argument_list|)
condition|)
name|objc_selector_refs_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SELECTOR_FIXUP"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_selector_fixup_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SYMBOLS"
argument_list|,
literal|13
argument_list|)
condition|)
name|objc_symbols_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_MODULES"
argument_list|,
literal|13
argument_list|)
condition|)
name|objc_module_info_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_IMAGE_INFO"
argument_list|,
literal|16
argument_list|)
condition|)
name|objc_image_info_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_INSTANCE_METHODS_"
argument_list|,
literal|32
argument_list|)
condition|)
name|objc_cat_inst_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_CLASS_METHODS_"
argument_list|,
literal|29
argument_list|)
condition|)
name|objc_cat_cls_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_REFS_"
argument_list|,
literal|20
argument_list|)
condition|)
name|objc_cat_cls_meth_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_"
argument_list|,
literal|15
argument_list|)
condition|)
name|objc_protocol_section
argument_list|()
expr_stmt|;
else|else
name|base_function
argument_list|()
expr_stmt|;
block|}
else|else
name|base_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This can be called with address expressions as "rtx".    They must go in "const".  */
end_comment

begin_function
name|void
name|machopic_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
condition|)
name|literal8_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|literal4_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|const_data_section
argument_list|()
expr_stmt|;
else|else
name|const_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|mod_init_section
argument_list|()
expr_stmt|;
else|else
name|constructor_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .constructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|mod_term_section
argument_list|()
expr_stmt|;
else|else
name|destructor_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .destructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_"
argument_list|,
literal|6
argument_list|)
condition|)
name|default_globalize_label
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to set visibility for a symbol.  The    only supported visibilities are VISIBILITY_DEFAULT and    VISIBILITY_HIDDEN; the latter corresponds to Darwin's "private    extern".  There is no MACH-O equivalent of ELF's    VISIBILITY_INTERNAL or VISIBILITY_PROTECTED. */
end_comment

begin_function
name|void
name|darwin_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
if|if
condition|(
name|vis
operator|==
name|VISIBILITY_DEFAULT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|vis
operator|==
name|VISIBILITY_HIDDEN
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.private_extern "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"internal and protected visibility attributes not supported"
literal|"in this configuration; ignored"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a difference of two labels that will be an assembly time    constant if the two labels are local.  (.long lab1-lab2 will be    very different if lab1 is at the boundary between two sections; it    will be relocated according to the second section, not the first,    so one ends up with a difference between labels in different    sections, which is bad in the dwarf2 eh context for instance.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|darwin_dwarf_label_counter
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|darwin_asm_output_dwarf_delta
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|lab1
parameter_list|,
specifier|const
name|char
modifier|*
name|lab2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|lab1
operator|+
operator|(
name|lab1
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
decl_stmt|;
name|int
name|islocaldiff
init|=
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
decl_stmt|;
if|if
condition|(
name|islocaldiff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set L$set$%d,"
argument_list|,
name|darwin_dwarf_label_counter
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t"
argument_list|,
literal|".long"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|lab2
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocaldiff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.long L$set$%d"
argument_list|,
name|darwin_dwarf_label_counter
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|machopic_finish
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constructor_section
argument_list|()
expr_stmt|;
name|destructor_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-darwin.h"
end_include

end_unit

