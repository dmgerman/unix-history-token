begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 128-bit long double support routines for Darwin.    Copyright (C) 1993, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Implementations of floating-point long double basic arithmetic    functions called by the IBM C compiler when generating code for    PowerPC platforms.  In particular, the following functions are    implemented: _xlqadd, _xlqsub, _xlqmul, and _xlqdiv.  Double-double    algorithms are based on the paper "Doubled-Precision IEEE Standard    754 Floating-Point Arithmetic" by W. Kahan, February 26, 1987.  An    alternative published reference is "Software for Doubled-Precision    Floating-Point Computations", by Seppo Linnainmaa, ACM TOMS vol 7    no 3, September 1961, pages 272-283.  */
end_comment

begin_comment
comment|/* Each long double is made up of two IEEE doubles.  The value of the    long double is the sum of the values of the two parts.  The most    significant part is required to be the value of the long double    rounded to the nearest double, as specified by IEEE.  For Inf    values, the least significant part is required to be one of +0.0 or    -0.0.  No other requirements are made; so, for example, 1.0 may be    represented as (1.0, +0.0) or (1.0, -0.0), and the low part of a    NaN is don't-care.     This code currently assumes big-endian.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|_SOFT_FLOAT
operator|&&
operator|(
name|defined
argument_list|(
name|__MACH__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|fabs
parameter_list|(
name|x
parameter_list|)
value|__builtin_fabs(x)
end_define

begin_define
define|#
directive|define
name|unlikely
parameter_list|(
name|x
parameter_list|)
value|__builtin_expect ((x), 0)
end_define

begin_comment
comment|/* All these routines actually take two long doubles as parameters,    but GCC currently generates poor code when a union is used to turn    a long double into a pair of doubles.  */
end_comment

begin_function_decl
specifier|extern
name|long
name|double
name|__gcc_qadd
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|double
name|__gcc_qsub
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|double
name|__gcc_qmul
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|double
name|__gcc_qdiv
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
name|__ELF__
operator|&&
name|defined
name|IN_LIBGCC2_S
end_if

begin_comment
comment|/* Provide definitions of the old symbol names to statisfy apps and    shared libs built against an older libgcc.  To access the _xlq    symbols an explicit version reference is needed, so these won't    satisfy an unadorned reference like _xlqadd.  If dot symbols are    not needed, the assembler will remove the aliases from the symbol    table.  */
end_comment

begin_asm
asm|__asm__ (".symver __gcc_qadd,_xlqadd@GCC_3.4\n\t"          ".symver __gcc_qsub,_xlqsub@GCC_3.4\n\t"          ".symver __gcc_qmul,_xlqmul@GCC_3.4\n\t"          ".symver __gcc_qdiv,_xlqdiv@GCC_3.4\n\t"          ".symver .__gcc_qadd,._xlqadd@GCC_3.4\n\t"          ".symver .__gcc_qsub,._xlqsub@GCC_3.4\n\t"          ".symver .__gcc_qmul,._xlqmul@GCC_3.4\n\t"          ".symver .__gcc_qdiv,._xlqdiv@GCC_3.4");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|long
name|double
name|ldval
decl_stmt|;
name|double
name|dval
index|[
literal|2
index|]
decl_stmt|;
block|}
name|longDblUnion
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|double
name|FPKINF
init|=
literal|1.0
operator|/
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add two 'long double' values and return the result.	*/
end_comment

begin_function
name|long
name|double
name|__gcc_qadd
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|longDblUnion
name|z
decl_stmt|;
name|double
name|t
decl_stmt|,
name|tau
decl_stmt|,
name|u
decl_stmt|,
name|FPR_zero
decl_stmt|,
name|FPR_PosInf
decl_stmt|;
name|FPR_zero
operator|=
literal|0.0
expr_stmt|;
name|FPR_PosInf
operator|=
name|FPKINF
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|a
operator|!=
name|a
argument_list|)
operator|||
name|unlikely
argument_list|(
name|c
operator|!=
name|c
argument_list|)
condition|)
return|return
name|a
operator|+
name|c
return|;
comment|/* NaN result.  */
comment|/* Ordered operands are arranged in order of their magnitudes.  */
comment|/* Switch inputs if |(c,d)|> |(a,b)|. */
if|if
condition|(
name|fabs
argument_list|(
name|c
argument_list|)
operator|>
name|fabs
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|t
operator|=
name|a
expr_stmt|;
name|tau
operator|=
name|b
expr_stmt|;
name|a
operator|=
name|c
expr_stmt|;
name|b
operator|=
name|d
expr_stmt|;
name|c
operator|=
name|t
expr_stmt|;
name|d
operator|=
name|tau
expr_stmt|;
block|}
comment|/* b<- second largest magnitude double. */
if|if
condition|(
name|fabs
argument_list|(
name|c
argument_list|)
operator|>
name|fabs
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|t
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|t
expr_stmt|;
block|}
comment|/* Thanks to commutivity, sum is invariant w.r.t. the next      conditional exchange. */
name|tau
operator|=
name|d
operator|+
name|c
expr_stmt|;
comment|/* Order the smallest magnitude doubles.  */
if|if
condition|(
name|fabs
argument_list|(
name|d
argument_list|)
operator|>
name|fabs
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|t
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|=
operator|(
name|tau
operator|+
name|b
operator|)
operator|+
name|a
expr_stmt|;
comment|/* Sum values in ascending magnitude order.  */
comment|/* Infinite or zero result.  */
if|if
condition|(
name|unlikely
argument_list|(
name|t
operator|==
name|FPR_zero
argument_list|)
operator|||
name|unlikely
argument_list|(
name|fabs
argument_list|(
name|t
argument_list|)
operator|==
name|FPR_PosInf
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Usual case.  */
name|tau
operator|=
operator|(
operator|(
operator|(
name|a
operator|-
name|t
operator|)
operator|+
name|b
operator|)
operator|+
name|c
operator|)
operator|+
name|d
expr_stmt|;
name|u
operator|=
name|t
operator|+
name|tau
expr_stmt|;
name|z
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|u
expr_stmt|;
comment|/* Final fixup for long double result.  */
name|z
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|(
name|t
operator|-
name|u
operator|)
operator|+
name|tau
expr_stmt|;
return|return
name|z
operator|.
name|ldval
return|;
block|}
end_function

begin_function
name|long
name|double
name|__gcc_qsub
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
return|return
name|__gcc_qadd
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|-
name|c
argument_list|,
operator|-
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|long
name|double
name|__gcc_qmul
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|longDblUnion
name|z
decl_stmt|;
name|double
name|t
decl_stmt|,
name|tau
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|,
name|FPR_zero
decl_stmt|,
name|FPR_PosInf
decl_stmt|;
name|FPR_zero
operator|=
literal|0.0
expr_stmt|;
name|FPR_PosInf
operator|=
name|FPKINF
expr_stmt|;
name|t
operator|=
name|a
operator|*
name|c
expr_stmt|;
comment|/* Highest order double term.  */
if|if
condition|(
name|unlikely
argument_list|(
name|t
operator|!=
name|t
argument_list|)
operator|||
name|unlikely
argument_list|(
name|t
operator|==
name|FPR_zero
argument_list|)
operator|||
name|unlikely
argument_list|(
name|fabs
argument_list|(
name|t
argument_list|)
operator|==
name|FPR_PosInf
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Finite nonzero result requires summing of terms of two highest      orders.	*/
comment|/* Use fused multiply-add to get low part of a * c.	 */
asm|asm ("fmsub %0,%1,%2,%3" : "=f"(tau) : "f"(a), "f"(c), "f"(t));
name|v
operator|=
name|a
operator|*
name|d
expr_stmt|;
name|w
operator|=
name|b
operator|*
name|c
expr_stmt|;
name|tau
operator|+=
name|v
operator|+
name|w
expr_stmt|;
comment|/* Add in other second-order terms.	 */
name|u
operator|=
name|t
operator|+
name|tau
expr_stmt|;
comment|/* Construct long double result.  */
name|z
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|u
expr_stmt|;
name|z
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|(
name|t
operator|-
name|u
operator|)
operator|+
name|tau
expr_stmt|;
return|return
name|z
operator|.
name|ldval
return|;
block|}
end_function

begin_function
name|long
name|double
name|__gcc_qdiv
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|longDblUnion
name|z
decl_stmt|;
name|double
name|s
decl_stmt|,
name|sigma
decl_stmt|,
name|t
decl_stmt|,
name|tau
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|,
name|FPR_zero
decl_stmt|,
name|FPR_PosInf
decl_stmt|;
name|FPR_zero
operator|=
literal|0.0
expr_stmt|;
name|FPR_PosInf
operator|=
name|FPKINF
expr_stmt|;
name|t
operator|=
name|a
operator|/
name|c
expr_stmt|;
comment|/* highest order double term */
if|if
condition|(
name|unlikely
argument_list|(
name|t
operator|!=
name|t
argument_list|)
operator|||
name|unlikely
argument_list|(
name|t
operator|==
name|FPR_zero
argument_list|)
operator|||
name|unlikely
argument_list|(
name|fabs
argument_list|(
name|t
argument_list|)
operator|==
name|FPR_PosInf
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Finite nonzero result requires corrections to the highest order term.  */
name|s
operator|=
name|c
operator|*
name|t
expr_stmt|;
comment|/* (s,sigma) = c*t exactly. */
name|w
operator|=
operator|-
operator|(
operator|-
name|b
operator|+
name|d
operator|*
name|t
operator|)
expr_stmt|;
comment|/* Written to get fnmsub for speed, but not 			   numerically necessary.  */
comment|/* Use fused multiply-add to get low part of c * t.	 */
asm|asm ("fmsub %0,%1,%2,%3" : "=f"(sigma) : "f"(c), "f"(t), "f"(s));
name|v
operator|=
name|a
operator|-
name|s
expr_stmt|;
name|tau
operator|=
operator|(
operator|(
name|v
operator|-
name|sigma
operator|)
operator|+
name|w
operator|)
operator|/
name|c
expr_stmt|;
comment|/* Correction to t. */
name|u
operator|=
name|t
operator|+
name|tau
expr_stmt|;
comment|/* Construct long double result. */
name|z
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|u
expr_stmt|;
name|z
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|(
name|t
operator|-
name|u
operator|)
operator|+
name|tau
expr_stmt|;
return|return
name|z
operator|.
name|ldval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

