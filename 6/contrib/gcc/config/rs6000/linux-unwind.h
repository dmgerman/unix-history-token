begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     In addition to the permissions in the GNU General Public License,    the Free Software Foundation gives you unlimited permission to link    the compiled version of this file with other programs, and to    distribute those programs without any restriction coming from the    use of this file.  (The General Public License restrictions do    apply in other respects; for example, they cover modification of    the file, and distribution when not linked into another program.)     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file defines our own versions of various kernel and user    structs, so that system headers are not needed, which otherwise    can make bootstrapping a new toolchain difficult.  Do not use    these structs elsewhere;  Many fields are missing, particularly    from the end of the structures.  */
end_comment

begin_struct
struct|struct
name|gcc_vregs
block|{
name|__attribute__
argument_list|(
argument|(vector_size (
literal|16
argument|))
argument_list|)
name|int
name|vr
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|unsigned
name|int
name|pad1
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|int
name|vscr
decl_stmt|;
name|unsigned
name|int
name|vsave
decl_stmt|;
name|unsigned
name|int
name|pad2
index|[
literal|3
index|]
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|vsave
decl_stmt|;
name|unsigned
name|int
name|pad
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|vscr
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_regs
block|{
name|unsigned
name|long
name|gpr
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|long
name|nip
decl_stmt|;
name|unsigned
name|long
name|msr
decl_stmt|;
name|unsigned
name|long
name|orig_gpr3
decl_stmt|;
name|unsigned
name|long
name|ctr
decl_stmt|;
name|unsigned
name|long
name|link
decl_stmt|;
name|unsigned
name|long
name|xer
decl_stmt|;
name|unsigned
name|long
name|ccr
decl_stmt|;
name|unsigned
name|long
name|softe
decl_stmt|;
name|unsigned
name|long
name|trap
decl_stmt|;
name|unsigned
name|long
name|dar
decl_stmt|;
name|unsigned
name|long
name|dsisr
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|long
name|pad1
index|[
literal|4
index|]
decl_stmt|;
name|double
name|fpr
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|pad2
decl_stmt|;
name|unsigned
name|int
name|fpscr
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|struct
name|gcc_vregs
modifier|*
name|vp
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|pad3
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcc_vregs
name|vregs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_ucontext
block|{
ifdef|#
directive|ifdef
name|__powerpc64__
name|unsigned
name|long
name|pad
index|[
literal|28
index|]
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|pad
index|[
literal|12
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcc_regs
modifier|*
name|regs
decl_stmt|;
name|struct
name|gcc_regs
name|rsave
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc64__
end_ifdef

begin_enum
enum|enum
block|{
name|SIGNAL_FRAMESIZE
init|=
literal|128
block|}
enum|;
end_enum

begin_comment
comment|/* If the current unwind info (FS) does not contain explicit info    saving R2, then we have to do a minor amount of code reading to    figure out if it was saved.  The big problem here is that the    code that does the save/restore is generated by the linker, so    we have no good way to determine at compile time what to do.  */
end_comment

begin_define
define|#
directive|define
name|MD_FROB_UPDATE_CONTEXT
parameter_list|(
name|CTX
parameter_list|,
name|FS
parameter_list|)
define|\
value|do {									\     if ((FS)->regs.reg[2].how == REG_UNSAVED)				\       {									\ 	unsigned int *insn						\ 	  = (unsigned int *)						\ 	    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);		\ 	if (*insn == 0xE8410028)					\ 	  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);			\       }									\   } while (0)
end_define

begin_comment
comment|/* If PC is at a sigreturn trampoline, return a pointer to the    regs.  Otherwise return NULL.  */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_GET_REGS
parameter_list|(
name|CONTEXT
parameter_list|)
define|\
value|({									\   const unsigned char *pc = (CONTEXT)->ra;				\   struct gcc_regs *regs = NULL;						\ 									\
comment|/* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */
value|\
comment|/* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */
value|\   if (*(unsigned int *) (pc + 0) != 0x38210000 + SIGNAL_FRAMESIZE	\       || *(unsigned int *) (pc + 8) != 0x44000002)			\     ;									\   else if (*(unsigned int *) (pc + 4) == 0x38000077)			\     {									\       struct sigframe {							\ 	char gap[SIGNAL_FRAMESIZE];					\ 	unsigned long pad[7];						\ 	struct gcc_regs *regs;						\       } *frame = (struct sigframe *) (CONTEXT)->cfa;			\       regs = frame->regs;						\     }									\   else if (*(unsigned int *) (pc + 4) == 0x380000AC)			\     {									\
comment|/* This works for 2.4 kernels, but not for 2.6 kernels with vdso	\ 	 because pc isn't pointing into the stack.  Can be removed when	\ 	 no one is running 2.4.19 or 2.4.20, the first two ppc64	\ 	 kernels released.  */
value|\       struct rt_sigframe_24 {						\ 	int tramp[6];							\ 	void *pinfo;							\ 	struct gcc_ucontext *puc;					\       } *frame24 = (struct rt_sigframe_24 *) pc;			\ 									\
comment|/* Test for magic value in *puc of vdso.  */
value|\       if ((long) frame24->puc != -21 * 8)				\ 	regs = frame24->puc->regs;					\       else								\ 	{								\
comment|/* This works for 2.4.21 and later kernels.  */
value|\ 	  struct rt_sigframe {						\ 	    char gap[SIGNAL_FRAMESIZE];					\ 	    struct gcc_ucontext uc;					\ 	    unsigned long pad[2];					\ 	    int tramp[6];						\ 	    void *pinfo;						\ 	    struct gcc_ucontext *puc;					\ 	  } *frame = (struct rt_sigframe *) (CONTEXT)->cfa;		\ 	  regs = frame->uc.regs;					\ 	}								\     }									\   regs;									\ })
end_define

begin_define
define|#
directive|define
name|LINUX_HWCAP_DEFAULT
value|0xc0000000
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_VREGS
parameter_list|(
name|REGS
parameter_list|)
value|(REGS)->vp
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__powerpc64__ */
end_comment

begin_enum
enum|enum
block|{
name|SIGNAL_FRAMESIZE
init|=
literal|64
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|PPC_LINUX_GET_REGS
parameter_list|(
name|CONTEXT
parameter_list|)
define|\
value|({									\   const unsigned char *pc = (CONTEXT)->ra;				\   struct gcc_regs *regs = NULL;						\ 									\
comment|/* li r0, 0x7777; sc  (sigreturn old)  */
value|\
comment|/* li r0, 0x0077; sc  (sigreturn new)  */
value|\
comment|/* li r0, 0x6666; sc  (rt_sigreturn old)  */
value|\
comment|/* li r0, 0x00AC; sc  (rt_sigreturn new)  */
value|\   if (*(unsigned int *) (pc + 4) != 0x44000002)				\     ;									\   else if (*(unsigned int *) (pc + 0) == 0x38007777			\ 	   || *(unsigned int *) (pc + 0) == 0x38000077)			\     {									\       struct sigframe {							\ 	char gap[SIGNAL_FRAMESIZE];					\ 	unsigned long pad[7];						\ 	struct gcc_regs *regs;						\       } *frame = (struct sigframe *) (CONTEXT)->cfa;			\       regs = frame->regs;						\     }									\   else if (*(unsigned int *) (pc + 0) == 0x38006666			\ 	   || *(unsigned int *) (pc + 0) == 0x380000AC)			\     {									\       struct rt_sigframe {						\ 	char gap[SIGNAL_FRAMESIZE + 16];				\ 	char siginfo[128];						\ 	struct gcc_ucontext uc;						\       } *frame = (struct rt_sigframe *) (CONTEXT)->cfa;			\       regs = frame->uc.regs;						\     }									\   regs;									\ })
end_define

begin_define
define|#
directive|define
name|LINUX_HWCAP_DEFAULT
value|0x80000000
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_VREGS
parameter_list|(
name|REGS
parameter_list|)
value|&(REGS)->vregs
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
parameter_list|(
name|CONTEXT
parameter_list|,
name|FS
parameter_list|,
name|SUCCESS
parameter_list|)
define|\
value|do {									\     static long hwcap = 0;						\     struct gcc_regs *regs = PPC_LINUX_GET_REGS (CONTEXT);		\     long new_cfa;							\     int i;								\ 									\     if (regs == NULL)							\       break;								\     									\     new_cfa = regs->gpr[STACK_POINTER_REGNUM];				\     (FS)->cfa_how = CFA_REG_OFFSET;					\     (FS)->cfa_reg = STACK_POINTER_REGNUM;				\     (FS)->cfa_offset = new_cfa - (long) (CONTEXT)->cfa;			\     									\     for (i = 0; i< 32; i++)						\       if (i != STACK_POINTER_REGNUM)					\ 	{	    							\ 	  (FS)->regs.reg[i].how = REG_SAVED_OFFSET;			\ 	  (FS)->regs.reg[i].loc.offset 					\ 	    = (long)&regs->gpr[i] - new_cfa;				\ 	}								\ 									\     (FS)->regs.reg[CR2_REGNO].how = REG_SAVED_OFFSET;			\     (FS)->regs.reg[CR2_REGNO].loc.offset				\       = (long)&regs->ccr - new_cfa;					\ 									\     (FS)->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;	\     (FS)->regs.reg[LINK_REGISTER_REGNUM].loc.offset 			\       = (long)&regs->link - new_cfa;					\ 									\     (FS)->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;		\     (FS)->regs.reg[ARG_POINTER_REGNUM].loc.offset 			\       = (long)&regs->nip - new_cfa;					\     (FS)->retaddr_column = ARG_POINTER_REGNUM;				\ 									\     if (hwcap == 0)							\       {									\
comment|/* __libc_stack_end holds the original stack passed to a	\ 	   process.  */
value|\ 	extern long *__libc_stack_end;					\ 	long argc;							\ 	char **argv;							\ 	char **envp;							\ 	struct auxv							\ 	{								\ 	  long a_type;							\ 	  long a_val;							\ 	} *auxp;							\ 									\
comment|/* The Linux kernel puts argc first on the stack.  */
value|\ 	argc = __libc_stack_end[0];					\
comment|/* Followed by argv, NULL terminated.  */
value|\ 	argv = (char **) __libc_stack_end + 1;				\
comment|/* Followed by environment string pointers, NULL terminated. */
value|\ 	envp = argv + argc + 1;						\ 	while (*envp++)							\ 	  continue;							\
comment|/* Followed by the aux vector, zero terminated.  */
value|\ 	for (auxp = (struct auxv *) envp; auxp->a_type != 0; ++auxp)	\ 	  if (auxp->a_type == 16)					\ 	    {								\ 	      hwcap = auxp->a_val;					\ 	      break;							\ 	    }								\ 									\
comment|/* These will already be set if we found AT_HWCAP.  A non-zero	\ 	   value stops us looking again if for some reason we couldn't	\ 	   find AT_HWCAP.  */
value|\ 	hwcap |= LINUX_HWCAP_DEFAULT;					\       }									\ 									\
comment|/* If we have a FPU...  */
value|\     if (hwcap& 0x08000000)						\       for (i = 0; i< 32; i++)						\ 	{								\ 	  (FS)->regs.reg[i + 32].how = REG_SAVED_OFFSET;		\ 	  (FS)->regs.reg[i + 32].loc.offset				\ 	    = (long)&regs->fpr[i] - new_cfa;				\ 	}								\ 									\
comment|/* If we have a VMX unit...  */
value|\     if (hwcap& 0x10000000)						\       {									\ 	struct gcc_vregs *vregs;					\ 	vregs = PPC_LINUX_VREGS (regs);					\ 	if (regs->msr& (1<< 25))					\ 	  {								\ 	    for (i = 0; i< 32; i++)					\ 	      {								\ 		(FS)->regs.reg[i + FIRST_ALTIVEC_REGNO].how		\ 		  = REG_SAVED_OFFSET;					\ 		(FS)->regs.reg[i + FIRST_ALTIVEC_REGNO].loc.offset	\ 		  = (long)&vregs[i] - new_cfa;				\ 	      }								\ 									\ 	    (FS)->regs.reg[VSCR_REGNO].how = REG_SAVED_OFFSET;		\ 	    (FS)->regs.reg[VSCR_REGNO].loc.offset			\ 	      = (long)&vregs->vscr - new_cfa;				\ 	  }								\ 									\ 	(FS)->regs.reg[VRSAVE_REGNO].how = REG_SAVED_OFFSET;		\ 	(FS)->regs.reg[VRSAVE_REGNO].loc.offset				\ 	  = (long)&vregs->vsave - new_cfa;				\       }									\ 									\     goto SUCCESS;							\   } while (0)
end_define

end_unit

