begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_comment
comment|/* In grokdeclarator, distinguish syntactic contexts of declarators.  */
end_comment

begin_enum
enum|enum
name|decl_context
block|{
name|NORMAL
block|,
comment|/* Ordinary declaration */
name|FUNCDEF
block|,
comment|/* Function definition */
name|PARM
block|,
comment|/* Declaration of parm before function body */
name|FIELD
block|,
comment|/* Declaration inside struct or union */
name|TYPENAME
block|}
enum|;
end_enum

begin_comment
comment|/* Typename (inside cast or sizeof)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
name|location_t
name|pending_invalid_xref_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  Note that will do not have to save this or `enum_overflow'    around nested function definition since such a definition could only    occur in an enum value expression and we don't use these variables in    that case.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain of parameter decls here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and a chain of structure and enum types declared in the    parmlist here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and a chain of all non-parameter declarations (such as    CONST_DECLs from enumerations) here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_others
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts the list of parameter names or chain of decls here    for `store_parm_decls' to find.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And for last_function_parm_others.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_others
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for the file and line that the prototype came from if this is    an old-style definition.  */
end_comment

begin_decl_stmt
specifier|static
name|location_t
name|current_function_prototype_locus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current statement tree.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|stmt_tree_s
name|c_stmt_tree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The current scope statement stack.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|c_scope_stmt_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* State saving variables.  */
end_comment

begin_decl_stmt
name|int
name|c_in_iteration_stmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c_in_case_stmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of external DECLs that appeared at block scope when there was    some other global meaning for that identifier.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|truly_local_externals
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* All the builtins; this is a subset of the entries of global_scope.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|first_builtin_decl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|last_builtin_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A DECL for the current file-scope context.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|current_file_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a call to a noreturn function is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_abnormally
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function declared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Each c_scope structure describes the complete contents of one scope.    Three scopes are distinguished specially: the innermost or current    scope, the innermost function scope, and the outermost or file scope.     Most declarations are recorded in the current scope.     All normal label declarations are recorded in the innermost    function scope, as are bindings of undeclared identifiers to    error_mark_node.  (GCC permits nested functions as an extension,    hence the 'innermost' qualifier.)  Explicitly declared labels    (using the __label__ extension) appear in the current scope.     Being in the global scope (current_scope == global_scope) causes    special behavior in several places below.  Also, under some    conditions the Objective-C front end records declarations in the    global scope even though that isn't the current scope.     The order of the names, parms, and blocks lists matters, and they    are frequently appended to.  To avoid having to walk all the way to    the end of the list on each insertion, or reverse the lists later,    we maintain a pointer to the last list entry for each of the lists.     The order of the tags, shadowed, and shadowed_tags    lists does not matter, so we just prepend to these lists.  */
end_comment

begin_decl_stmt
name|struct
name|c_scope
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The scope containing this one.  */
name|struct
name|c_scope
modifier|*
name|outer
decl_stmt|;
comment|/* The next outermost function scope.  */
name|struct
name|c_scope
modifier|*
name|outer_function
decl_stmt|;
comment|/* All variables, constants, functions, labels, and typedef names.  */
name|tree
name|names
decl_stmt|;
name|tree
name|names_last
decl_stmt|;
comment|/* All parameter declarations.  Used only in the outermost scope of      a function.  */
name|tree
name|parms
decl_stmt|;
name|tree
name|parms_last
decl_stmt|;
comment|/* All structure, union, and enum type tags.  */
name|tree
name|tags
decl_stmt|;
comment|/* For each scope, a list of shadowed outer-scope definitions      to be restored when this scope is popped.      Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and      whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* For each scope, a list of shadowed outer-scope tag definitions      to be restored when this scope is popped.      Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and      whose TREE_VALUE is its old definition (a kind of ..._TYPE node).  */
name|tree
name|shadowed_tags
decl_stmt|;
comment|/* For each scope (except the global one), a chain of BLOCK nodes      for all the scopes that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
name|tree
name|blocks_last
decl_stmt|;
comment|/* True if we are currently filling this scope with parameter      declarations.  */
name|BOOL_BITFIELD
name|parm_flag
range|:
literal|1
decl_stmt|;
comment|/* True if we already complained about forward parameter decls      in this scope.  This prevents double warnings on      foo (int a; int b; ...)  */
name|BOOL_BITFIELD
name|warned_forward_parm_decls
range|:
literal|1
decl_stmt|;
comment|/* True if this is the outermost block scope of a function body.      This scope contains the parameters, the local variables declared      in the outermost block, and all the labels (except those in      nested functions, or declared at block scope with __label__).  */
name|BOOL_BITFIELD
name|function_body
range|:
literal|1
decl_stmt|;
comment|/* True means make a BLOCK for this scope no matter what.  */
name|BOOL_BITFIELD
name|keep
range|:
literal|1
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The scope currently in effect.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|current_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A chain of c_scope structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
expr|struct
name|c_scope
operator|*
name|scope_freelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The innermost function scope.  Ordinary (not explicitly declared)    labels, bindings to error_mark_node, and the lazily-created    bindings of __func__ and its friends get this scope.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|current_function_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The outermost scope, corresponding to the C "file scope".  This is    created when the compiler is started and exists through the entire run.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|global_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Append VAR to LIST in scope SCOPE.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_LIST_APPEND
parameter_list|(
name|scope
parameter_list|,
name|list
parameter_list|,
name|decl
parameter_list|)
value|do {	\   struct c_scope *s_ = (scope);				\   tree d_ = (decl);					\   if (s_->list##_last)					\     TREE_CHAIN (s_->list##_last) = d_;			\   else							\     s_->list = d_;					\   s_->list##_last = d_;					\ } while (0)
end_define

begin_comment
comment|/* Concatenate FROM in scope FSCOPE onto TO in scope TSCOPE.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_LIST_CONCAT
parameter_list|(
name|tscope
parameter_list|,
name|to
parameter_list|,
name|fscope
parameter_list|,
name|from
parameter_list|)
value|do {	\   struct c_scope *t_ = (tscope);				\   struct c_scope *f_ = (fscope);				\   if (t_->to##_last)						\     TREE_CHAIN (t_->to##_last) = f_->from;			\   else								\     t_->to = f_->from;						\   t_->to##_last = f_->from##_last;				\ } while (0)
end_define

begin_comment
comment|/* True means unconditionally make a BLOCK for the next scope pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means the next call to pushlevel will be the outermost scope    of a function body, so do not push a new scope, merely cease    expecting parameter decls.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|next_is_function_body
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions called automatically at the beginning and end of execution.  */
end_comment

begin_decl_stmt
name|tree
name|static_ctors
decl_stmt|,
name|static_dtors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|c_scope
modifier|*
name|make_scope
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_scope
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_label
parameter_list|(
name|tree
parameter_list|,
name|location_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bind_label
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|struct
name|c_scope
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|implicit_decl_warning
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|decl_context
parameter_list|,
name|int
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grokparms
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_parm_decls_newstyle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_parm_decls_oldstyle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_make_fname_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_expand_body_1
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|any_external_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_external_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_if_shadowing
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_bitfield_type_and_width
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clone_underlying_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|flexible_array_type_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|link_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* States indicating how grokdeclarator() should handle declspecs marked    with __attribute__((deprecated)).  An object declared as    __attribute__((deprecated)) suppresses warnings of uses of other    deprecated items.  */
end_comment

begin_enum
enum|enum
name|deprecated_states
block|{
name|DEPRECATED_NORMAL
block|,
name|DEPRECATED_SUPPRESS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|deprecated_states
name|deprecated_state
init|=
name|DEPRECATED_NORMAL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|c_print_identifier
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"symbol"
argument_list|,
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"tag"
argument_list|,
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|tree
name|rid
init|=
name|ridpointers
index|[
name|C_RID_CODE
argument_list|(
name|node
argument_list|)
index|]
decl_stmt|;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rid "
name|HOST_PTR_PRINTF
literal|" \"%s\""
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rid
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called at end of compilation to assume 1 elt    for a file-scope tentative array defn that wasn't complete before.  */
end_comment

begin_function
name|void
name|c_finish_incomplete_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"%Jarray '%D' assumed to have one element"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reuse or create a struct for this scope.  */
end_comment

begin_function
specifier|static
name|struct
name|c_scope
modifier|*
name|make_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|scope_freelist
condition|)
block|{
name|result
operator|=
name|scope_freelist
expr_stmt|;
name|scope_freelist
operator|=
name|result
operator|->
name|outer
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_scope
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remove the topmost scope from the stack and add it to the    free list, updating current_function_scope if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|pop_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|current_scope
decl_stmt|;
name|current_scope
operator|=
name|scope
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|scope
operator|->
name|function_body
condition|)
name|current_function_scope
operator|=
name|scope
operator|->
name|outer_function
expr_stmt|;
name|memset
argument_list|(
name|scope
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|c_scope
argument_list|)
argument_list|)
expr_stmt|;
name|scope
operator|->
name|outer
operator|=
name|scope_freelist
expr_stmt|;
name|scope_freelist
operator|=
name|scope
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The Objective-C front-end often needs to determine the current scope.  */
end_comment

begin_function
name|void
modifier|*
name|get_current_scope
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
return|;
block|}
end_function

begin_comment
comment|/* The following function is used only by Objective-C.  It needs to live here    because it accesses the innards of c_scope.  */
end_comment

begin_function
name|void
name|objc_mark_locals_volatile
parameter_list|(
name|void
modifier|*
name|enclosing_blk
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|scope
decl_stmt|;
for|for
control|(
name|scope
operator|=
name|current_scope
init|;
name|scope
operator|&&
name|scope
operator|!=
name|enclosing_blk
condition|;
name|scope
operator|=
name|scope
operator|->
name|outer
control|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|scope
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Do not climb up past the current function.  */
if|if
condition|(
name|scope
operator|->
name|function_body
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global scope.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
operator|==
name|global_scope
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|(
name|void
parameter_list|)
block|{
name|keep_next_level_flag
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify this scope as currently being filled with parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|(
name|void
parameter_list|)
block|{
name|current_scope
operator|->
name|parm_flag
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if currently making parm declarations.  */
end_comment

begin_function
name|int
name|in_parm_level_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
operator|->
name|parm_flag
return|;
block|}
end_function

begin_comment
comment|/* Enter a new scope.  The dummy parameter is for signature    compatibility with lang_hooks.decls.pushlevel.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|next_is_function_body
condition|)
block|{
comment|/* This is the transition from the parameters to the top level 	 of the function body.  These are the same scope 	 (C99 6.2.1p4,6) so we do not push another scope structure. 	 next_is_function_body is set only by store_parm_decls, which 	 in turn is called when and only when we are about to 	 encounter the opening curly brace for the function body.  	 The outermost block of a function always gets a BLOCK node, 	 because the debugging output routines expect that each 	 function has at least one BLOCK.  */
name|current_scope
operator|->
name|parm_flag
operator|=
name|false
expr_stmt|;
name|current_scope
operator|->
name|function_body
operator|=
name|true
expr_stmt|;
name|current_scope
operator|->
name|keep
operator|=
name|true
expr_stmt|;
name|current_scope
operator|->
name|outer_function
operator|=
name|current_function_scope
expr_stmt|;
name|current_function_scope
operator|=
name|current_scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
name|next_is_function_body
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|make_scope
argument_list|()
decl_stmt|;
name|scope
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
name|scope
operator|->
name|outer
operator|=
name|current_scope
expr_stmt|;
name|current_scope
operator|=
name|scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exit a scope.  Restore the state of the identifier-decl mappings    that were in effect when this scope was entered.     If KEEP is KEEP_YES (1), this scope had explicit declarations, so    create a BLOCK node to record its declarations and subblocks for    debugging output.  If KEEP is KEEP_MAYBE, do so only if the names    or tags lists are nonempty.     The second parameter is ignored; it is present only for    signature compatibility with lang_hooks.decls.poplevel.     If FUNCTIONBODY is nonzero, this level is the body of a function,    even if current_scope->function_body is not set.  This is used    by language-independent code that generates synthetic functions,    and cannot set current_scope->function_body.     FIXME: Eliminate the need for all arguments.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|int
name|keep
parameter_list|,
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|functionbody
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|current_scope
decl_stmt|;
name|tree
name|block
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|p
decl_stmt|;
comment|/* The following line does not use |= due to a bug in HP's C compiler.  */
name|scope
operator|->
name|function_body
operator|=
name|scope
operator|->
name|function_body
operator||
name|functionbody
expr_stmt|;
if|if
condition|(
name|keep
operator|==
name|KEEP_MAYBE
condition|)
name|keep
operator|=
operator|(
name|scope
operator|->
name|names
operator|||
name|scope
operator|->
name|tags
operator|)
expr_stmt|;
name|keep
operator||=
name|scope
operator|->
name|keep
expr_stmt|;
name|keep
operator||=
name|scope
operator|->
name|function_body
expr_stmt|;
comment|/* If appropriate, create a BLOCK to record the decls for the life      of this function.  */
name|block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
condition|)
block|{
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|scope
operator|->
name|names
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|scope
operator|->
name|blocks
expr_stmt|;
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|blocks
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|p
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the variable bindings in this scope.       Propagate TREE_ADDRESSABLE from nested functions to their      containing functions.       Issue warnings for unused variables and labels, and errors for      undefined labels, if there are any.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|names
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jlabel `%D' used but not defined"
argument_list|,
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
name|warn_unused_label
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jlabel `%D' defined but not used"
argument_list|,
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%Jlabel `%D' declared but not defined"
argument_list|,
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
operator|!=
name|p
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|normal
goto|;
case|case
name|VAR_DECL
case|:
comment|/* Keep this in sync with stmt.c:warn_about_unused_variables. 	     No warnings when the global scope is popped because the 	     global scope isn't popped for the last translation unit, 	     so the warnings are done in c_write_global_declaration.  */
if|if
condition|(
name|warn_unused_variable
operator|&&
name|scope
operator|!=
name|global_scope
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|p
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Junused variable `%D'"
argument_list|,
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* fall through */
default|default:
name|normal
label|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|p
argument_list|)
operator|&&
name|scope
operator|!=
name|global_scope
condition|)
comment|/* External decls stay in the symbol-value slot but are 		   inaccessible.  */
name|C_DECL_INVISIBLE
argument_list|(
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Clear out the parameter bindings in this scope, if any.      Unused-parameter warnings are handled by function.c.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|parms
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
condition|)
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the tag-meanings declared in this scope.       Set the TYPE_CONTEXTs for all of the tagged types belonging to      this scope so that they point to the appropriate construct, i.e.      either to the current FUNCTION_DECL node, or else to the BLOCK      node we just constructed.       Note that for tagged types whose scope is just the formal      parameter list for some function type specification, we can't      properly set their TYPE_CONTEXTs here, because we don't have a      pointer to the appropriate FUNCTION_TYPE node readily available      to us.  For those cases, the TYPE_CONTEXTs of the relevant tagged      type nodes get set in `grokdeclarator' as soon as we have created      the FUNCTION_TYPE node which will represent the "scope" for these      "parameter list local" tagged types.  */
name|decl
operator|=
name|scope
operator|->
name|function_body
condition|?
name|current_function_decl
else|:
name|block
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|tags
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
condition|)
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Restore all name- and label-meanings from outer scopes that were      shadowed by this scope.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|shadowed
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Restore all tag-meanings from outer scopes that were shadowed by      this scope.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|shadowed_tags
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Dispose of the block that we just made inside some higher level.  */
if|if
condition|(
name|scope
operator|->
name|function_body
operator|&&
name|current_function_decl
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|scope
operator|->
name|outer
condition|)
block|{
if|if
condition|(
name|block
condition|)
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
operator|->
name|outer
argument_list|,
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the scope just exited, any 	 blocks made for inner scopes must be carried forward so they 	 will later become subblocks of something else.  */
elseif|else
if|if
condition|(
name|scope
operator|->
name|blocks
condition|)
name|SCOPE_LIST_CONCAT
argument_list|(
name|scope
operator|->
name|outer
argument_list|,
name|blocks
argument_list|,
name|scope
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the current scope, and free the structure for reuse.  */
name|pop_scope
argument_list|()
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the current    scope.  This is used when a BIND_EXPR is expanded, to handle the    BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|current_scope
argument_list|,
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope (the one we are    currently in).  The RTL expansion machinery requires us to provide    this hook, but it is not useful in function-at-a-time mode.  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|tree
name|block
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition or a declaration of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|b
init|=
name|current_scope
decl_stmt|;
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|b
operator|->
name|shadowed_tags
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|b
operator|->
name|shadowed_tags
argument_list|)
expr_stmt|;
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
name|b
operator|->
name|tags
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the      tagged type we just added to the current scope.  This fake      NULL-named TYPE_DECL node helps dwarfout.c to know when it needs      to output a representation of a tagged type, and it also gives      us a convenient place to record the "scope start" address for the      tagged type.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An approximation for now, so we can tell this is a function-scope tag.      This will be updated in poplevel.  */
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of compare_decls.  Allow harmless mismatches in return    and argument types provided that the type modes match.  This function    return a unified type given a suitable match, and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|match_builtin_function_types
parameter_list|(
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|newrettype
decl_stmt|,
name|oldrettype
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|oldargs
decl_stmt|;
name|tree
name|trytype
decl_stmt|,
name|tryargs
decl_stmt|;
comment|/* Accept the return type of the new declaration if same modes.  */
name|oldrettype
operator|=
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newrettype
operator|=
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|oldrettype
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|newrettype
argument_list|)
condition|)
return|return
literal|0
return|;
name|oldargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
name|tryargs
operator|=
name|newargs
expr_stmt|;
while|while
condition|(
name|oldargs
operator|||
name|newargs
condition|)
block|{
if|if
condition|(
operator|!
name|oldargs
operator|||
operator|!
name|newargs
operator|||
operator|!
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
operator|||
operator|!
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|oldargs
operator|=
name|TREE_CHAIN
argument_list|(
name|oldargs
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TREE_CHAIN
argument_list|(
name|newargs
argument_list|)
expr_stmt|;
block|}
name|trytype
operator|=
name|build_function_type
argument_list|(
name|newrettype
argument_list|,
name|tryargs
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|trytype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of diagnose_mismathed_decls.  Check for function type    mismatch involving an empty arglist vs a nonempty one and give clearer    diagnostics. */
end_comment

begin_function
specifier|static
name|void
name|diagnose_arglist_conflict
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|COMPARE_STRICT
argument_list|)
operator|||
operator|!
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return;
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|inform
argument_list|(
literal|"a parameter list with an ellipsis can't match "
literal|"an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
operator|!=
name|type
condition|)
block|{
name|inform
argument_list|(
literal|"an argument type that has a default promotion can't match "
literal|"an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Another subroutine of diagnose_mismatched_decls.  OLDDECL is an    old-style function definition, NEWDECL is a prototype declaration.    Diagnose inconsistencies in the argument list.  Returns TRUE if    the prototype is compatible, FALSE if not.  */
end_comment

begin_function
specifier|static
name|bool
name|validate_proto_after_old_defn
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|newargs
decl_stmt|,
name|oldargs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* ??? Elsewhere TYPE_MAIN_VARIANT is not used in this context.  */
define|#
directive|define
name|END_OF_ARGLIST
parameter_list|(
name|t
parameter_list|)
value|(TYPE_MAIN_VARIANT (t) == void_type_node)
name|oldargs
operator|=
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tree
name|oldargtype
init|=
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
decl_stmt|;
name|tree
name|newargtype
init|=
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
decl_stmt|;
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|oldargtype
argument_list|)
operator|&&
name|END_OF_ARGLIST
argument_list|(
name|newargtype
argument_list|)
condition|)
break|break;
comment|/* Reaching the end of just one list means the two decls don't 	 agree on the number of arguments.  */
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|oldargtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jprototype for '%D' declares more arguments "
literal|"than previous old-style definition"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|newargtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jprototype for '%D' declares fewer arguments "
literal|"than previous old-style definition"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Type for passing arg must be consistent with that declared 	 for the arg.  */
elseif|else
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|oldargtype
argument_list|,
name|newargtype
argument_list|,
name|COMPARE_STRICT
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jprototype for '%D' declares arg %d with incompatible type"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|oldargs
operator|=
name|TREE_CHAIN
argument_list|(
name|oldargs
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TREE_CHAIN
argument_list|(
name|newargs
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we get here, no errors were found, but do issue a warning      for this poor-style construct.  */
name|warning
argument_list|(
literal|"%Jprototype for '%D' follows non-prototype definition"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
undef|#
directive|undef
name|END_OF_ARGLIST
block|}
end_function

begin_comment
comment|/* Subroutine of diagnose_mismatched_decls.  Report the location of DECL,    first in a pair of mismatched declarations, using the diagnostic    function DIAG.  */
end_comment

begin_function
specifier|static
name|void
name|locate_old_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|void
function_decl|(
modifier|*
name|diag
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|diag
argument_list|(
name|N_
argument_list|(
literal|"%Jprevious definition of '%D' was here"
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
condition|)
name|diag
argument_list|(
name|N_
argument_list|(
literal|"%Jprevious implicit declaration of '%D' was here"
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|diag
argument_list|(
name|N_
argument_list|(
literal|"%Jprevious declaration of '%D' was here"
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of duplicate_decls.  Compare NEWDECL to OLDDECL.    Returns true if the caller should proceed to merge the two, false    if OLDDECL should simply be discarded.  As a side effect, issues    all necessary diagnostics for invalid or poor-style combinations.    If it returns true, writes the types of NEWDECL and OLDDECL to    *NEWTYPEP and *OLDTYPEP - these may have been adjusted from    TREE_TYPE (NEWDECL, OLDDECL) respectively.  */
end_comment

begin_function
specifier|static
name|bool
name|diagnose_mismatched_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
modifier|*
name|newtypep
parameter_list|,
name|tree
modifier|*
name|oldtypep
parameter_list|)
block|{
name|tree
name|newtype
decl_stmt|,
name|oldtype
decl_stmt|;
name|bool
name|pedwarned
init|=
name|false
decl_stmt|;
name|bool
name|warned
init|=
name|false
decl_stmt|;
comment|/* If we have error_mark_node for either decl or type, just discard      the previous decl - we're in an error cascade already.  */
if|if
condition|(
name|olddecl
operator|==
name|error_mark_node
operator|||
name|newdecl
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
operator|*
name|oldtypep
operator|=
name|oldtype
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
operator|*
name|newtypep
operator|=
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|==
name|error_mark_node
operator|||
name|newtype
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Two different categories of symbol altogether.  This is an error      unless OLDDECL is a builtin.  OLDDECL will be discarded in any case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%J'%D' redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jbuilt-in function '%D' declared as non-function"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_shadow
condition|)
name|warning
argument_list|(
literal|"%Jshadowing built-in function '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Enumerators have no linkage, so may only be declared once in a      given scope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%Jredeclaration of enumerator `%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|oldtype
argument_list|,
name|newtype
argument_list|,
name|COMPARE_STRICT
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Accept harmless mismatch in function types. 	     This is for the ffs and fprintf builtins.  */
name|tree
name|trytype
init|=
name|match_builtin_function_types
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trytype
operator|&&
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|trytype
argument_list|,
name|COMPARE_STRICT
argument_list|)
condition|)
operator|*
name|oldtypep
operator|=
name|oldtype
operator|=
name|trytype
expr_stmt|;
else|else
block|{
comment|/* If types don't match for a built-in, throw away the 		 built-in.  No point in calling locate_old_decl here, it 		 won't print anything. */
name|warning
argument_list|(
literal|"%Jconflicting types for built-in function '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A conflicting function declaration for a predeclared 	     function that isn't actually built in.  Objective C uses 	     these.  The new declaration silently overrides everything 	     but the volatility (i.e. noreturn) indication.  See also 	     below.  FIXME: Make Objective C use normal builtins.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Permit void foo (...) to match int foo (...) if the latter is 	 the definition and implicit int was used.  See 	 c-torture/compile/920625-2.c.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"%Jconflicting types for '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Make sure we keep void as the return type.  */
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
operator|*
name|newtypep
operator|=
name|newtype
operator|=
name|oldtype
expr_stmt|;
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pedwarned
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%Jconflicting types for '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|diagnose_arglist_conflict
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Redeclaration of a type is a constraint violation (6.7.2.3p1),      but silently ignore the redeclaration if either is in a system      header.  (Conflicting redeclarations were handled above.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* allow OLDDECL to continue in use */
name|error
argument_list|(
literal|"%Jredefinition of typedef '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Function declarations can either be 'static' or 'extern' (no      qualifier is equivalent to 'extern' - C99 6.2.2p5) and therefore      can never conflict with each other on account of linkage (6.2.2p4).      Multiple definitions are not allowed (6.9p3,5) but GCC permits      two definitions if one is 'extern inline' and one is not.  The non-      extern-inline definition supersedes the extern-inline definition.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If you declare a built-in function name as static, or 	 define the built-in with an old-style definition (so we 	 can't validate the argument list) the built-in definition is 	 overridden, but optionally warn this was a bad choice of name.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|warn_shadow
condition|)
name|warning
argument_list|(
literal|"%Jshadowing built-in function '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
name|false
return|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jredefinition of '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* If we have a prototype after an old-style function definition, 	 the argument types must be checked specially.  */
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|&&
operator|!
name|validate_proto_after_old_defn
argument_list|(
name|newdecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
condition|)
block|{
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Mismatched non-static and static is considered poor style.          We only diagnose static then non-static if -Wtraditional, 	 because it is the most convenient way to get some effects 	 (see e.g.  what unwind-dw2-fde-glibc.c does to the definition 	 of _Unwind_Find_FDE in unwind-dw2-fde.c).  Revisit?  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* A static function declaration for a predeclared function 	     that isn't actually built in, silently overrides the 	     default.  Objective C uses these.  See also above. 	     FIXME: Make Objective C use normal builtins.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
else|else
block|{
name|warning
argument_list|(
literal|"%Jstatic declaration of '%D' follows "
literal|"non-static declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|warn_traditional
condition|)
block|{
name|warning
argument_list|(
literal|"%Jnon-static declaration of '%D' follows "
literal|"static declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Only variables can be thread-local, and all declarations must 	 agree on this property.  */
if|if
condition|(
name|DECL_THREAD_LOCAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_THREAD_LOCAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_THREAD_LOCAL
argument_list|(
name|newdecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jthread-local declaration of '%D' follows "
literal|"non-thread-local declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jnon-thread-local declaration of '%D' follows "
literal|"thread-local declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Multiple initialized definitions are not allowed (6.9p3,5).  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jredefinition of '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Objects declared at file scope: if at least one is 'extern', 	 it's fine (6.2.2p4); otherwise the linkage must agree (6.2.2p7).  */
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jnon-static declaration of '%D' follows "
literal|"static declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jstatic declaration of '%D' follows "
literal|"non-static declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Two objects with the same name declared at the same block 	 scope must both be external references (6.7p3).  */
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jextern declaration of '%D' follows "
literal|"declaration with no linkage"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jdeclaration of '%D' with no linkage follows "
literal|"extern declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jredeclaration of '%D' with no linkage"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* warnings */
comment|/* All decls must agree on a non-default visibility.  */
if|if
condition|(
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%Jredeclaration of '%D' with different visibility "
literal|"(old visibility preserved)"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Diagnose inline __attribute__ ((noinline)) which is silly.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%Jinline declaration of '%D' follows "
literal|"declaration with attribute noinline"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%Jdeclaration of '%D' with attribute noinline follows "
literal|"inline declaration "
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* Inline declaration after use or definition. 	 ??? Should we still warn about this now we have unit-at-a-time 	 mode and can get it right?  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%J'%D' declared inline after being called"
argument_list|,
name|olddecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%J'%D' declared inline after its definition"
argument_list|,
name|olddecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* PARM_DECL, VAR_DECL */
block|{
comment|/* Redeclaration of a PARM_DECL is invalid unless this is the 	 real position of a forward-declared parameter (GCC extension).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
operator|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jredefinition of parameter '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* These bits are only type qualifiers when applied to objects.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jvolatile declaration of '%D' follows "
literal|"non-volatile declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%Jnon-volatile declaration of '%D' follows "
literal|"volatile declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarned
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jconst declaration of '%D' follows "
literal|"non-const declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"%Jnon-const declaration of '%D' follows "
literal|"const declaration"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|pedwarned
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Optional warning for completely redundant decls.  */
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|pedwarned
operator|&&
name|warn_redundant_decls
comment|/* Don't warn about a function declaration followed by a 	 definition.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|)
comment|/* Don't warn about redundant redeclarations of builtins. */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
operator|)
comment|/* Don't warn about an extern followed by a definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about forward parameter decls.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about a variable definition following a declaration.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"%Jredundant redeclaration of '%D'"
argument_list|,
name|newdecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* Report location of previous decl/defn in a consistent manner.  */
if|if
condition|(
name|warned
operator|||
name|pedwarned
condition|)
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|pedwarned
condition|?
name|pedwarn
else|:
name|warning
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of duplicate_decls.  NEWDECL has been found to be    consistent with OLDDECL, but carries new information.  Merge the    new information into OLDDECL.  This function issues no    diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|merge_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|int
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
comment|/* For real parm decl following a forward decl, return 1 so old decl      will be reused.  Only allow this to happen once.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_decl_attributes
call|)
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|common_type
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_MODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Keep the old rtl since we can safely use it.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|make_var_volatile
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Keep source location of definition rather than declaration.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_SOURCE_LOCATION
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the unused-warning information.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the section attribute.      We want to issue an error if the sections conflict but that must be      done later in decl_attributes since we are called before attributes      are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Copy the assembler name.      Currently, it can only be defined in the prototype.  */
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If either declaration has a nondefault visibility, use it.  */
if|if
condition|(
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|VISIBILITY_DEFAULT
condition|)
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_LIMIT_STACK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_LIMIT_STACK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_MALLOC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_MALLOC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_PURE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_PURE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|merge_weak
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	 copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* An extern decl does not override previous storage class.  */
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If we're redefining a function previously defined as extern 	 inline, make sure we emit debug info for the inline before we 	 throw it away, in case it was inlined into a function that hasn't 	 been written out yet.  */
if|if
condition|(
name|new_is_definition
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
comment|/* In unit-at-a-time mode we never inline re-defined extern 	         inline functions.  */
operator|&&
operator|!
name|flag_unit_at_a_time
operator|&&
name|cgraph_function_possibly_inlined_p
argument_list|(
name|olddecl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* The new defn must not be inline.  */
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If either decl says `inline', this fn is inline, 	     unless its definition was passed already.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* If redeclaring a builtin function, it stays built in.  */
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Also preserve various other info from the definition.  */
if|if
condition|(
operator|!
name|new_is_definition
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Set DECL_INLINE on the declaration if we've got a body 	     from which to instantiate.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If a previous declaration said inline, mark the 	     definition as inlinable.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Copy most of the decl-specific fields of NEWDECL into OLDDECL.      But preserve OLDDECL's DECL_UID and C_DECL_INVISIBLE.  */
block|{
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|unsigned
name|olddecl_invisible
init|=
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
name|C_DECL_INVISIBLE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_invisible
expr_stmt|;
block|}
comment|/* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl      so that encode_section_info has a chance to look at the new decl      flags and attributes.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
name|make_decl_rtl
argument_list|(
name|olddecl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return    true.  Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|duplicate_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|tree
name|newtype
decl_stmt|,
name|oldtype
decl_stmt|;
if|if
condition|(
operator|!
name|diagnose_mismatched_decls
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
operator|&
name|newtype
argument_list|,
operator|&
name|oldtype
argument_list|)
condition|)
return|return
name|false
return|;
name|merge_decls
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return any external DECL associated with ID, whether or not it is    currently in scope.  */
end_comment

begin_function
specifier|static
name|tree
name|any_external_decl
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|decl
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|decl
return|;
name|t
operator|=
name|purpose_member
argument_list|(
name|id
argument_list|,
name|truly_local_externals
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record an external decl DECL.  This only does something if a    shadowing decl already exists.  */
end_comment

begin_function
specifier|static
name|void
name|record_external_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|truly_local_externals
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|truly_local_externals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether decl-node X shadows an existing declaration.    OLD is the old IDENTIFIER_SYMBOL_VALUE of the DECL_NAME of X,    which might be a NULL_TREE.  */
end_comment

begin_function
specifier|static
name|void
name|warn_if_shadowing
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|old
parameter_list|)
block|{
comment|/* Nothing to shadow?  */
if|if
condition|(
name|old
operator|==
literal|0
comment|/* Shadow warnings not wanted?  */
operator|||
operator|!
name|warn_shadow
comment|/* No shadow warnings for internally generated vars.  */
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
comment|/* No shadow warnings for vars made for inlining.  */
operator|||
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
comment|/* Don't warn about the parm names in function declarator 	 within a function declarator. 	 It would be nice to avoid warning in any function 	 declarator in a declaration, as opposed to a definition, 	 but there is no way to tell it's not a definition.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|current_scope
operator|->
name|outer
operator|->
name|parm_flag
operator|)
comment|/* Shadow warnings only apply to local variables and parameters.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warning
argument_list|(
literal|"%Jdeclaration of '%D' shadows a parameter"
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|old
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jdeclaration of '%D' shadows a global declaration"
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%Jdeclaration of '%D' shadows a previous local"
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"%Jshadowed declaration is here"
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of pushdecl.     X is a TYPE_DECL for a typedef statement.  Create a brand new    ..._TYPE node (which will be just a variant of the existing    ..._TYPE node with identical properties) and then install X    as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.     The whole point here is to end up with a situation where each    and every ..._TYPE node the compiler creates will be uniquely    associated with AT MOST one node representing a typedef name.    This way, even though the compiler substitutes corresponding    ..._TYPE nodes for TYPE_DECL (i.e. "typedef name") nodes very    early on, later parts of the compiler can always do the reverse    translation and get back the corresponding typedef name.  For    example, given:          typedef struct S MY_TYPE; 	MY_TYPE object;     Later parts of the compiler might only know that `object' was of    type `struct S' if it were not for code just below.  With this    code however, later parts of the compiler see something like:  	struct S' == struct S 	typedef struct S' MY_TYPE; 	struct S' object;      And they can then deduce (from the node for type struct S') that     the original object declaration was:  		MY_TYPE object;      Being able to do this is important for proper support of protoize,     and also for generating precise symbolic debugging information     which takes full account of the programmer's (typedef) vocabulary.      Obviously, we don't want to generate a duplicate ..._TYPE node if     the TYPE_DECL node that we are now processing really represents a     standard built-in type.      Since all standard types are effectively declared at line zero     in the source file, we can easily check to see if we are working     on a standard type by checking the current value of lineno.  */
end_comment

begin_function
specifier|static
name|void
name|clone_underlying_type
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
name|tt
operator|=
name|build_type_copy
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|tt
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_USED
argument_list|(
name|tt
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|current_scope
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|error_mark_node
operator|==
literal|0
condition|)
comment|/* Called too early.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Functions need the lang_decl data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A local extern declaration for a function doesn't constitute nesting.      A local auto declaration does, since it's a forward decl      for a nested function coming later.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_file_decl
expr_stmt|;
else|else
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|tree
name|old
decl_stmt|;
if|if
condition|(
name|warn_nested_externs
operator|&&
name|scope
operator|!=
name|global_scope
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|warning
argument_list|(
literal|"nested extern declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|old
argument_list|)
condition|)
block|{
comment|/* For PARM_DECLs, old may be a forward declaration. 	     If so, we want to remove it from its old location 	     (in the variables chain) and rechain it in the 	     location given by the new declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|scope
operator|->
name|names
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|old
condition|)
block|{
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
argument_list|,
name|parms
argument_list|,
name|old
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|old
return|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|||
name|scope
operator|==
name|global_scope
condition|)
block|{
comment|/* Find and check against a previous, not-in-scope, external 	     decl for this identifier.  (C99 6.2.7p2: All declarations 	     that refer to the same object or function shall have 	     compatible type; otherwise, the behavior is undefined.)  */
name|tree
name|ext
init|=
name|any_external_decl
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|ext
argument_list|)
condition|)
name|x
operator|=
name|copy_node
argument_list|(
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
name|record_external_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|clone_underlying_type
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If storing a local value, there may already be one 	 (inherited).  If so, record it for restoration when this 	 scope ends.  Take care not to do this if we are replacing an 	 older decl in the same scope (i.e.  duplicate_decls returned 	 false, above).  */
if|if
condition|(
name|scope
operator|!=
name|global_scope
condition|)
block|{
name|tree
name|inherited_decl
init|=
name|lookup_name
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|inherited_decl
operator|&&
name|inherited_decl
operator|!=
name|old
condition|)
block|{
name|warn_if_shadowing
argument_list|(
name|x
argument_list|,
name|inherited_decl
argument_list|)
expr_stmt|;
name|scope
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|inherited_decl
argument_list|,
name|scope
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Install the new declaration in the requested scope.  */
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|C_DECL_INVISIBLE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If x's type is incomplete because it's based on a 	 structure or union which has not yet been fully declared, 	 attach it to that structure or union type, so we can go 	 back and complete the variable declaration later, if the 	 structure or union gets fully declared.  	 If the input is erroneous, we can have error_mark in the type 	 slot (e.g. "f(void a, ...)") - that doesn't count as an 	 incomplete type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|element
argument_list|)
condition|)
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|element
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
argument_list|,
name|parms
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
argument_list|,
name|names
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Record X as belonging to the global scope (C99 "file scope").    This is used only internally by the Objective-C front end,    and is limited to its needs.  duplicate_decls is not called;    if there is any preexisting decl for this identifier, it is an ICE.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_file_decl
expr_stmt|;
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|global_scope
argument_list|,
name|names
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID as a    function of type int ().  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|tree
name|functionid
parameter_list|)
block|{
name|tree
name|decl
init|=
name|any_external_decl
argument_list|(
name|functionid
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
comment|/* Implicit declaration of a function already declared 	 (somehow) in a different scope, or as a built-in. 	 If this is the first time this has happened, warn; 	 then recycle the old declaration.  */
if|if
condition|(
operator|!
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|implicit_decl_warning
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jprevious declaration of '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this function is global, then it must already be in the 	 global scope, so there's no need to push it again.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
return|return
name|decl
return|;
comment|/* If this is a local declaration, make a copy; we can't have 	 the same DECL listed in two different scopes.  */
return|return
name|pushdecl
argument_list|(
name|copy_node
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
comment|/* Not seen before.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|implicit_decl_warning
argument_list|(
name|functionid
argument_list|)
expr_stmt|;
comment|/* C89 says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* No need to call objc_check_decl here - it's a function type.  */
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write a record describing this implicit function declaration      to the prototypes file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Possibly apply some default attributes to this implicit declaration.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|implicit_decl_warning
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|mesg_implicit_function_declaration
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mesg_implicit_function_declaration
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message for a reference to an undeclared variable    ID, including a reference to a builtin outside of function-call    context.  Establish a binding of the identifier to error_mark_node    in an appropriate scope, which will suppress further errors for the    same identifier.  */
end_comment

begin_function
name|void
name|undeclared_variable
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
specifier|static
name|bool
name|already
init|=
name|false
decl_stmt|;
name|struct
name|c_scope
modifier|*
name|scope
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' undeclared here (not in a function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|scope
operator|=
name|current_scope
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"`%s' undeclared (first use in this function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"for each function it appears in.)"
argument_list|)
expr_stmt|;
name|already
operator|=
name|true
expr_stmt|;
block|}
name|scope
operator|=
name|current_function_scope
expr_stmt|;
block|}
name|scope
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|scope
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of lookup_label, declare_label, define_label: construct a    LABEL_DECL with all the proper frills.  */
end_comment

begin_function
specifier|static
name|tree
name|make_label
parameter_list|(
name|tree
name|name
parameter_list|,
name|location_t
name|location
parameter_list|)
block|{
name|tree
name|label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|label
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|location
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Another subroutine of lookup_label, declare_label, define_label:    set up the binding of name to LABEL_DECL in the given SCOPE.  */
end_comment

begin_function
specifier|static
name|void
name|bind_label
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|label
parameter_list|,
name|struct
name|c_scope
modifier|*
name|scope
parameter_list|)
block|{
if|if
condition|(
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|scope
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|scope
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|label
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
argument_list|,
name|names
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier NAME as a label.    Create one if none exists so far for the current function.    This is called when a label is used in a goto expression or    has its address taken.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|label
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %s referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use a label already defined or ref'd with this name, but not if      it is inherited from a containing function and wasn't declared      using __label__.  */
name|label
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
operator|||
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|)
condition|)
block|{
comment|/* If the label has only been declared, update its apparent 	 location to point here, for better diagnostics if it 	 turns out not to have been defined.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|input_location
expr_stmt|;
return|return
name|label
return|;
block|}
comment|/* No label binding for that identifier; make one.  */
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* Ordinary labels go in the current function scope.  */
name|bind_label
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_function_scope
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function, shadowing silently    any that may be inherited from containing functions or containing    scopes.  This is called for __label__ declarations.  */
end_comment

begin_comment
comment|/* Note that valid use, if the label being shadowed comes from another    scope in the same function, requires calling declare_nonlocal_label    right away.  (Is this still true?  -zw 2003-07-17)  */
end_comment

begin_function
name|tree
name|declare_label
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|label
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|dup
decl_stmt|;
comment|/* Check to make sure that the label hasn't already been declared      at this scope */
for|for
control|(
name|dup
operator|=
name|current_scope
operator|->
name|names
init|;
name|dup
condition|;
name|dup
operator|=
name|TREE_CHAIN
argument_list|(
name|dup
argument_list|)
control|)
if|if
condition|(
name|dup
operator|==
name|label
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label declaration `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jthis is a previous declaration"
argument_list|,
name|dup
argument_list|)
expr_stmt|;
comment|/* Just use the previous declaration.  */
return|return
name|dup
return|;
block|}
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Declared labels go in the current scope.  */
name|bind_label
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_scope
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|location_t
name|location
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|label
decl_stmt|;
comment|/* Find any preexisting label with this name.  It is an error      if that label has already been defined in this function, or      if there is a containing function with a declared label with      the same name.  */
name|label
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
operator|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|!=
name|current_function_decl
operator|&&
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Hduplicate label `%D'"
argument_list|,
operator|&
name|location
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
condition|)
name|error
argument_list|(
literal|"%J`%D' previously defined here"
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%J`%D' previously declared here"
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|label
operator|&&
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
condition|)
block|{
comment|/* The label has been used or declared already in this function, 	 but not defined.  Update its location to point to this 	 definition.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|location
expr_stmt|;
block|}
else|else
block|{
comment|/* No label binding for that identifier; make one.  */
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* Ordinary labels go in the current function scope.  */
name|bind_label
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_function_scope
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Htraditional C lacks a separate namespace for labels, "
literal|"identifier `%s' conflicts"
argument_list|,
operator|&
name|location
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current scope.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
operator|->
name|names
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    If THISLEVEL_ONLY is nonzero, searches only the current_scope.    CODE says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|thislevel_only
parameter_list|)
block|{
name|tree
name|tag
init|=
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|thislevel
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
return|return
literal|0
return|;
comment|/* We only care about whether it's in this level if      thislevel_only was set or it might be a type clash.  */
if|if
condition|(
name|thislevel_only
operator|||
name|TREE_CODE
argument_list|(
name|tag
argument_list|)
operator|!=
name|code
condition|)
block|{
if|if
condition|(
name|current_scope
operator|==
name|global_scope
operator|||
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_scope
operator|->
name|tags
argument_list|)
condition|)
name|thislevel
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|thislevel
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tag
argument_list|)
operator|!=
name|code
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|pending_invalid_xref
operator|=
name|name
expr_stmt|;
name|pending_invalid_xref_location
operator|=
name|input_location
expr_stmt|;
comment|/* If in the same binding level as a declaration as a tag 	 of a different type, this must not be allowed to 	 shadow that tag, so give the error immediately. 	 (For example, "struct foo; union foo;" is invalid.)  */
if|if
condition|(
name|thislevel
condition|)
name|pending_xref_error
argument_list|()
expr_stmt|;
block|}
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Print an error message now    for a recent invalid struct, union or enum cross reference.    We don't print them immediately because they are not invalid    when used in the `struct foo;' construct for shadowing.  */
end_comment

begin_function
name|void
name|pending_xref_error
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pending_invalid_xref
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"%H`%s' defined as wrong kind of tag"
argument_list|,
operator|&
name|pending_invalid_xref_location
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|pending_invalid_xref
argument_list|)
argument_list|)
expr_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current scope and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
literal|0
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|C_DECL_INVISIBLE
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at the current scope.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
literal|0
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
name|C_DECL_INVISIBLE
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
return|return
name|decl
return|;
comment|/* Scan the current scope for a decl with name NAME.      For PARM_DECLs, we have to look at both ->parms and ->names, since      forward parameter declarations wind up on the ->names list.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|chain_member
argument_list|(
name|decl
argument_list|,
name|current_scope
operator|->
name|parms
argument_list|)
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|chain_member
argument_list|(
name|decl
argument_list|,
name|current_scope
operator|->
name|names
argument_list|)
condition|)
return|return
name|decl
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *) 0).    Initialize the global scope.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|c_init_decl_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|endlink
decl_stmt|;
name|tree
name|ptr_ftype_void
decl_stmt|,
name|ptr_ftype_ptr
decl_stmt|;
name|location_t
name|save_loc
init|=
name|input_location
decl_stmt|;
comment|/* Adds some ggc roots, and reserved words for c-parse.in.  */
name|c_parse_init
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
comment|/* Make the c_scope structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_scope
operator|=
name|current_scope
expr_stmt|;
comment|/* Declarations from c_common_nodes_and_builtins must not be associated      with this input file, lest we get differences between using and not      using preprocessed headers.  */
name|input_location
operator|.
name|file
operator|=
literal|"<internal>"
expr_stmt|;
name|input_location
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Make the DECL for the toplevel file scope.  */
name|current_file_decl
operator|=
name|build_decl
argument_list|(
name|TRANSLATION_UNIT_DECL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|build_common_tree_nodes
argument_list|(
name|flag_signed_char
argument_list|)
expr_stmt|;
name|c_common_nodes_and_builtins
argument_list|()
expr_stmt|;
comment|/* In C, comparisons and TRUTH_* expressions have type int.  */
name|truthvalue_type_node
operator|=
name|integer_type_node
expr_stmt|;
name|truthvalue_true_node
operator|=
name|integer_one_node
expr_stmt|;
name|truthvalue_false_node
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Even in C99, which has a real boolean type.  */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"_Bool"
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|ptr_ftype_void
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|save_loc
expr_stmt|;
name|pedantic_lvalues
operator|=
name|pedantic
expr_stmt|;
name|make_fname_decl
operator|=
name|c_make_fname_decl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
name|first_builtin_decl
operator|=
name|global_scope
operator|->
name|names
expr_stmt|;
name|last_builtin_decl
operator|=
name|global_scope
operator|->
name|names_last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the    decl, NAME is the initialization string and TYPE_DEP indicates whether    NAME depended on the type of the function.  As we don't yet implement    delayed emission of static data, we mark the decl as emitted    so it is not placed in the output.  Anything using it must therefore pull    out the STRING_CST initializer directly.  FIXME.  */
end_comment

begin_function
specifier|static
name|tree
name|c_make_fname_decl
parameter_list|(
name|tree
name|id
parameter_list|,
name|int
name|type_dep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|fname_as_string
argument_list|(
name|type_dep
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|length
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|decl
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|current_function_scope
argument_list|,
name|names
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  If    ATTRS is nonzero, use that for the function's attribute list.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|function_code
parameter_list|,
name|enum
name|built_in_class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|library_name
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|library_name
argument_list|)
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|class
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
comment|/* Warn if a function in the namespace for users      is used without an occasion to consider it declared.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|C_DECL_INVISIBLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Possibly apply some default attributes to this built-in function.  */
if|if
condition|(
name|attrs
condition|)
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
name|ATTR_FLAG_BUILT_IN
argument_list|)
expr_stmt|;
else|else
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|tree
name|declspecs
parameter_list|)
block|{
name|shadow_tag_warned
argument_list|(
name|declspecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shadow_tag_warned
parameter_list|(
name|tree
name|declspecs
parameter_list|,
name|int
name|warned
parameter_list|)
comment|/* 1 => we have done a pedwarn.  2 => we have done a warning, but 	no pedwarn.  */
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|tree
name|link
decl_stmt|;
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
comment|/* Remove the attributes from declspecs, since they will confuse the      following code.  */
name|split_specs_attrs
argument_list|(
name|declspecs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|specs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|found_tag
operator|++
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
condition|)
comment|/* Empty unnamed enum OK */
block|{
name|pedwarn
argument_list|(
literal|"unnamed struct/union that defines no instances"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|in_system_header
condition|)
block|{
name|warning
argument_list|(
literal|"useless keyword or type name in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"two types specified in one empty declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct an array declarator.  EXPR is the expression inside [], or    NULL_TREE.  QUALS are the type qualifiers inside the [] (to be applied    to the pointer to which a parameter array is converted).  STATIC_P is    nonzero if "static" is inside the [], zero otherwise.  VLA_UNSPEC_P    is nonzero is the array is [*], a VLA of unspecified length which is    nevertheless a complete type (not currently implemented by GCC),    zero otherwise.  The declarator is constructed as an ARRAY_REF    (to be decoded by grokdeclarator), whose operand 0 is what's on the    left of the [] (filled by in set_array_declarator_type) and operand 1    is the expression inside; whose TREE_TYPE is the type qualifiers and    which has TREE_STATIC set if "static" is used.  */
end_comment

begin_function
name|tree
name|build_array_declarator
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|quals
parameter_list|,
name|int
name|static_p
parameter_list|,
name|int
name|vla_unspec_p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|quals
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|static_p
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|static_p
operator|||
name|quals
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `static' or type qualifiers in parameter array declarators"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vla_unspec_p
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `[*]' array declarators"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vla_unspec_p
condition|)
name|warning
argument_list|(
literal|"GCC does not yet properly implement `[*]' array declarators"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Set the type of an array declarator.  DECL is the declarator, as    constructed by build_array_declarator; TYPE is what appears on the left    of the [] and goes in operand 0.  ABSTRACT_P is nonzero if it is an    abstract declarator, zero otherwise; this is used to reject static and    type qualifiers in abstract declarators, where they are not in the    C99 grammar.  */
end_comment

begin_function
name|tree
name|set_array_declarator_type
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|abstract_p
parameter_list|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|abstract_p
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"static or type qualifiers in abstract declarator"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|tree
name|typename
parameter_list|)
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
name|split_specs_attrs
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
name|typename
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|specs
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Apply attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|typename
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|typename
return|;
block|}
end_function

begin_comment
comment|/* Return a PARM_DECL node for a given pair of specs and declarator.  */
end_comment

begin_function
name|tree
name|groktypename_in_parm_context
parameter_list|(
name|tree
name|typename
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_function
name|tree
name|start_decl
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|tree
name|declspecs
parameter_list|,
name|int
name|initialized
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* An object declared as __attribute__((deprecated)) suppresses      warnings of uses of other deprecated items.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"deprecated"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|deprecated_state
operator|=
name|DEPRECATED_NORMAL
expr_stmt|;
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%J'%D' is usually a function"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
name|error
argument_list|(
literal|"typedef `%s' is initialized (use __typeof__ instead)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* DECL_INITIAL in a PARM_DECL is really DECL_ARG_TYPE.  */
name|error
argument_list|(
literal|"parameter `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
comment|/* This can happen if the array size is an undefined macro.  We already 	   gave a warning, so we don't need another one.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|initialized
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A complete type is ok if size is fixed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is a function declaration, write a record describing it to the      prototypes file (if requested).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* ANSI specifies that a tentative definition which is not merged with      a non-tentative definition behaves exactly like a definition with an      initializer equal to zero.  (Section 3.7.2)       -fno-common gives strict ANSI behavior, though this tends to break      a large body of code that grew up without this rule.       Thread-local variables are never common, since there's no entrenched      body of code to break, and it allows more efficient variable references      in the presence of dynamic linking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|initialized
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_common
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ce
init|=
name|declarator
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ce
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|ce
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ce
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|args
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|args
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jinline function '%D' given attribute noinline"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current scope.      TEM may equal DECL or it may be a previous decl of the same name.  */
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a local variable, define the RTL now.  */
if|if
condition|(
name|current_scope
operator|!=
name|global_scope
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|asmspec_tree
operator|=
name|maybe_apply_renaming_pragma
argument_list|(
name|decl
argument_list|,
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
comment|/* Don't crash if parm is initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|)
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
comment|/* Get the completed type made by complete_array_type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"%Jinitializer fails to determine size of '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error
argument_list|(
literal|"%Jarray size missing in '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, 	     make it extern as well as static, so it does not get 	     allocated. 	     If it is not `static', then do not mark extern; 	     finish_incomplete_decl will give it a default size 	     and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* TYPE_MAX_VALUE is always one less than the number of elements 	 in the array, because we start counting at zero.  Therefore, 	 warn only if the value is less than zero.  */
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"%Jzero or negative size array '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
comment|/* Don't give an error if we already gave one earlier.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|?
comment|/* A static variable with an incomplete type 		   is an error if it is initialized. 		   Also if it is not file scope. 		   Otherwise, let it through, but if it is not `extern' 		   then it may cause an error message later.  */
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|)
else|:
comment|/* An automatic variable with an incomplete type 		   is an error.  */
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jstorage size of '%D' isn't known"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jstorage size of '%D' isn't constant"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_USED
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a function and an assembler name is specified, reset DECL_RTL      so we can give it its new name.  Also, update built_in_decls if it      was a normal built-in.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|asmspec
condition|)
block|{
comment|/* ASMSPEC is given, and not the name of a register.  Mark the       name with a star so assemble_name won't munge it.  */
name|char
modifier|*
name|starred
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|starred
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
name|starred
operator|+
literal|1
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
block|{
name|tree
name|builtin
init|=
name|built_in_decls
index|[
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
index|]
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|builtin
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|builtin
argument_list|,
name|get_identifier
argument_list|(
name|starred
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_MEMCPY
condition|)
name|init_block_move_fn
argument_list|(
name|starred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_MEMSET
condition|)
name|init_block_clear_fn
argument_list|(
name|starred
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_BCOPY
condition|)
name|init_block_move_fn
argument_list|(
name|starred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_BZERO
condition|)
name|init_block_clear_fn
argument_list|(
name|starred
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|starred
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If #pragma weak was used, mark the decl weak now.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* Don't output anything 	       when a tentative file-scope definition is seen. 	       But at end of compilation, do output code for them.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a local variable.  If there is an ASMSPEC, the 	     user has requested that we handle it specially.  */
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* In conjunction with an ASMSPEC, the `register' 		 keyword indicates that we should place the variable 		 in a particular register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_C_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is not a static variable, issue a warning. 		 It doesn't make any sense to give an ASMSPEC for an 		 ordinary, non-register local variable.  Historically, 		 GCC has accepted -- but ignored -- the ASMSPEC in 		 this case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jignoring asm-specifier for non-static local "
literal|"variable '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* If this was marked 'used', be sure it will be output.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|mark_referenced
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At the end of a declaration, throw away any variable type sizes      of types defined inside that declaration.  There is no use      computing them in the following function definition.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* Install a cleanup (aka destructor) if one was given.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"cleanup"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
specifier|static
name|bool
name|eh_initialized_p
decl_stmt|;
name|tree
name|cleanup_id
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cleanup_decl
init|=
name|lookup_name
argument_list|(
name|cleanup_id
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Build "cleanup(&decl)" for the destructor.  */
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|cleanup_decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Don't warn about decl unused; the cleanup uses it.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Initialize EH, if we've been told to do so.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|eh_initialized_p
condition|)
block|{
name|eh_initialized_p
operator|=
name|true
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gcc_personality_sj0"
else|:
literal|"__gcc_personality_v0"
argument_list|)
expr_stmt|;
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
block|}
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|decl
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration, decode it into a PARM_DECL    and push that on the current scope.  */
end_comment

begin_function
name|void
name|push_parm_decl
parameter_list|(
name|tree
name|parm
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|old_dont_save_pending_sizes_p
init|=
literal|0
decl_stmt|;
comment|/* Don't attempt to expand sizes while parsing this decl.      (We can get here with i_s_e 1 somehow from Objective-C.)  */
name|int
name|save_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
comment|/* If this is a nested function, we do want to keep SAVE_EXPRs for      the argument sizes, regardless of the parent's setting.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|old_dont_save_pending_sizes_p
operator|=
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
condition|)
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
name|old_dont_save_pending_sizes_p
expr_stmt|;
name|immediate_size_expand
operator|=
name|save_immediate_size_expand
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all the parameter declarations to date as forward decls,    shift them to the variables list, and reset the parameters list.    Also diagnose use of this extension.  */
end_comment

begin_function
name|void
name|mark_forward_parm_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|current_scope
operator|->
name|warned_forward_parm_decls
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C forbids forward parameter declarations"
argument_list|)
expr_stmt|;
name|current_scope
operator|->
name|warned_forward_parm_decls
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|parm
operator|=
name|current_scope
operator|->
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|TREE_ASM_WRITTEN
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SCOPE_LIST_CONCAT
argument_list|(
name|current_scope
argument_list|,
name|names
argument_list|,
name|current_scope
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|current_scope
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|current_scope
operator|->
name|parms_last
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|compound_literal_number
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound    literal, which may be an incomplete array type completed by the    initializer; INIT is a CONSTRUCTOR that initializes the compound    literal.  */
end_comment

begin_function
name|tree
name|build_compound_literal
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
comment|/* We do not use start_decl here because we have a type, not a declarator;      and do not use finish_decl because the decl should be stored inside      the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_STMT.  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|complit
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_scope
operator|==
name|global_scope
operator|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|complit
operator|=
name|build1
argument_list|(
name|COMPOUND_LITERAL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|complit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* This decl needs a name for the assembler output.  We also need 	 a unique suffix to be added to the name.  */
name|char
modifier|*
name|name
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|name
argument_list|,
literal|"__compound_literal"
argument_list|,
name|compound_literal_number
argument_list|)
expr_stmt|;
name|compound_literal_number
operator|++
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|complit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|initial_value
parameter_list|,
name|int
name|do_default
parameter_list|)
block|{
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|maxindex
operator|=
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
expr_stmt|;
else|else
name|maxindex
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|maxindex
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether TYPE is a structure with a flexible array member,    or a union containing such a structure (possibly recursively).  */
end_comment

begin_function
specifier|static
name|bool
name|flexible_array_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|UNION_TYPE
case|:
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
operator|!=
name|NULL_TREE
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Performs sanity checks on the TYPE and WIDTH of the bit-field NAME,    replacing with appropriate values if they are invalid.  */
end_comment

begin_function
specifier|static
name|void
name|check_bitfield_type_and_width
parameter_list|(
name|tree
modifier|*
name|type
parameter_list|,
name|tree
modifier|*
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_name
parameter_list|)
block|{
name|tree
name|type_mv
decl_stmt|;
name|unsigned
name|int
name|max_width
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|orig_name
condition|?
name|orig_name
else|:
name|_
argument_list|(
literal|"<anonymous>"
argument_list|)
decl_stmt|;
comment|/* Necessary?  */
name|STRIP_NOPS
argument_list|(
operator|*
name|width
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width and process valid      field widths.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|width
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"bit-field `%s' width not an integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
block|{
name|constant_expression_warning
argument_list|(
operator|*
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
operator|*
name|width
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"negative width in bit-field `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
operator|*
name|width
argument_list|)
operator|&&
name|orig_name
condition|)
block|{
name|error
argument_list|(
literal|"zero width for bit-field `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"bit-field `%s' has invalid type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
name|type_mv
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|type_mv
operator|!=
name|integer_type_node
operator|&&
name|type_mv
operator|!=
name|unsigned_type_node
operator|&&
name|type_mv
operator|!=
name|boolean_type_node
condition|)
name|pedwarn
argument_list|(
literal|"type of bit-field `%s' is a GCC extension"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_mv
operator|==
name|boolean_type_node
condition|)
name|max_width
operator|=
name|CHAR_TYPE_SIZE
expr_stmt|;
else|else
name|max_width
operator|=
name|TYPE_PRECISION
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|compare_tree_int
argument_list|(
operator|*
name|width
argument_list|,
name|max_width
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"width of `%s' exceeds its type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|w
operator|=
name|max_width
expr_stmt|;
operator|*
name|width
operator|=
name|build_int_2
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|w
operator|=
name|tree_low_cst
argument_list|(
operator|*
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|w
operator|<
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|||
name|w
operator|<
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' is narrower than values of its type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.    INITIALIZED is 1 if the decl has an initializer.    WIDTH is non-NULL for bit-fields, and is a pointer to an INTEGER_CST node    representing the width of the bit-field.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.  */
end_comment

begin_function
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|tree
name|declspecs
parameter_list|,
name|enum
name|decl_context
name|decl_context
parameter_list|,
name|int
name|initialized
parameter_list|,
name|tree
modifier|*
name|width
parameter_list|)
block|{
name|int
name|specbits
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|restrictp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
name|int
name|inlinep
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|orig_name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
name|tree
name|decl_attr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|array_ptr_quals
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|array_parm_static
init|=
literal|0
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|bitfield
init|=
name|width
operator|!=
name|NULL
decl_stmt|;
name|tree
name|element_type
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|orig_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* If this looks like a function definition, make it one,      even if it occurs where parms are expected.      Then store_parm_decls will reject it and not use it as a parm.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|funcdef_flag
operator|&&
name|current_scope
operator|->
name|parm_flag
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT or EXPLICIT_CHAR if the type is `int' or `char'      and did not come from a user typedef.       Set LONGLONG if `long' is mentioned twice.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
comment|/* If the entire declaration is itself tagged as deprecated then          suppress reports of deprecated items.  */
if|if
condition|(
name|id
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|deprecated_state
operator|!=
name|DEPRECATED_SUPPRESS
condition|)
name|warn_deprecated_use
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|enum
name|rid
name|i
init|=
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|RID_LONG
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `long long'"
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|RID_CONST
operator|||
name|i
operator|==
name|RID_VOLATILE
operator|||
name|i
operator|==
name|RID_RESTRICT
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Diagnose "__thread extern".  Recall that this list 		 is in the reverse order seen in the text.  */
if|if
condition|(
name|i
operator|==
name|RID_THREAD
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|error
argument_list|(
literal|"`__thread' before `extern'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`__thread' before `static'"
argument_list|)
expr_stmt|;
block|}
name|specbits
operator||=
literal|1
operator|<<
operator|(
name|int
operator|)
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Actual typedefs come to us as TYPE_DECL nodes.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* Allow the type to default to int to avoid cascading errors.  */
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|decl_attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|id
expr_stmt|;
block|}
block|}
comment|/* Built-in types come as identifiers.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|size_varies
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
operator|)
operator|)
operator|)
comment|/* Don't warn about typedef foo = bar.  */
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|&&
name|initialized
operator|)
operator|&&
operator|!
name|in_system_header
condition|)
block|{
comment|/* Issue a warning if this is an ISO C 99 program or if -Wreturn-type 	     and this is a function, or if -Wimplicit; prefer the former 	     warning since it is more explicit.  */
if|if
condition|(
operator|(
name|warn_implicit_int
operator|||
name|warn_return_type
operator|||
name|flag_isoc99
operator|)
operator|&&
name|funcdef_flag
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_implicit_int
operator|||
name|flag_isoc99
condition|)
name|pedwarn_c99
argument_list|(
literal|"type defaults to `int' in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|defaulted_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|!
name|longlong
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
condition|)
name|error
argument_list|(
literal|"both long and short specified for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
specifier|static
name|int
name|already
init|=
literal|0
decl_stmt|;
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
operator|&&
operator|!
name|pedantic
condition|)
block|{
name|error
argument_list|(
literal|"the only valid combination is `long double'"
argument_list|)
expr_stmt|;
name|already
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
condition|)
name|error
argument_list|(
literal|"both signed and unsigned specified for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
condition|)
block|{
name|error
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"complex invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
expr_stmt|;
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bit-fields as signed by default.  */
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|defaulted_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
literal|0
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support complex types"
argument_list|)
expr_stmt|;
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support plain `complex' meaning `double complex'"
argument_list|)
expr_stmt|;
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Figure out the type qualifiers for the declaration.  There are      two ways a declaration can become qualified.  One is something      like `const int i' where the `const' is explicit.  Another is      something like `typedef const int CI; CI i' where the type of the      declaration contains the `const'.  A third possibility is that      there is a type qualifier on the element type of a typedefed      array type, in which case we should extract that qualifier so      that c_apply_type_quals_to_decls receives the full list of      qualifiers to work with (C90 is not entirely clear about whether      duplicate qualifiers should be diagnosed in this case, but it      seems most appropriate to do so).  */
name|element_type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_CONST
operator|)
operator|+
name|TYPE_READONLY
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|restrictp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_RESTRICT
operator|)
operator|+
name|TYPE_RESTRICT
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VOLATILE
operator|)
operator|+
name|TYPE_VOLATILE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_gen_aux_info
operator|&&
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
block|{
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* "static __thread" and "extern __thread" are allowed.  */
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain        kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|funcdef_flag
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|&&
operator|(
name|pedantic
operator|||
name|current_scope
operator|==
name|global_scope
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"function definition declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|error
argument_list|(
literal|"function definition declared `register'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|error
argument_list|(
literal|"function definition declared `typedef'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
condition|)
name|error
argument_list|(
literal|"function definition declared `__thread'"
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
empty_stmt|;
else|else
block|{
switch|switch
condition|(
name|decl_context
condition|)
block|{
case|case
name|FIELD
case|:
name|error
argument_list|(
literal|"storage class specified for structure field `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM
case|:
name|error
argument_list|(
literal|"storage class specified for parameter `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"storage class specified for typename"
argument_list|)
expr_stmt|;
break|break;
block|}
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
comment|/* `extern' with initialization is invalid if not at file scope.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|error
argument_list|(
literal|"file-scope declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"function-scope `%s' implicitly auto and declared `__thread'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 a TREE_LIST (for nested attributes), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|array_ptr_quals
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
condition|)
block|{
comment|/* Only the innermost declarator (making a parameter be of 	     array type which is converted to pointer type) 	     may have static or type qualifiers.  */
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* We encode a declarator with embedded attributes using 	     a TREE_LIST.  */
name|tree
name|attrs
init|=
name|TREE_PURPOSE
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
decl_stmt|;
name|int
name|attr_flags
init|=
literal|0
decl_stmt|;
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|inner_decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|inner_decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|inner_decl
operator|=
name|TREE_VALUE
argument_list|(
name|inner_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
expr_stmt|;
name|returned_attrs
operator|=
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
name|attrs
argument_list|)
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The index is a signed object `sizetype' bits wide.  */
name|tree
name|index_type
init|=
name|c_common_signed_type
argument_list|(
name|sizetype
argument_list|)
decl_stmt|;
name|array_ptr_quals
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|array_parm_static
operator|=
name|TREE_STATIC
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|flexible_array_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid use of structure with flexible array member"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* If size was specified, set ITYPE to a range-type for that size. 	     Otherwise, ITYPE remains null.  finish_decl may figure it out 	     from an initial value.  */
if|if
condition|(
name|size
condition|)
block|{
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the array size remains visibly nonconstant 		     even if it is (eg) a const variable with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids array `%s' whose size can't be evaluated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C90 forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* A zero-length array cannot be represented with an 		     unsigned index type, which is what we'll get with 		     build_index_type.  Create an open-ended range instead.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute the maximum valid index, that is, size - 1. 		     Do the calculation in index_type, so that if it is 		     a variable the computations will be done in the 		     proper mode.  */
name|itype
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that overflowed, the array is too big. 		     ??? While a size of INT_MAX+1 technically shouldn't 		     cause an overflow (because we subtract 1), the overflow 		     is recorded during the conversion to index_type, before 		     the subtraction.  Handling this case seems like an 		     unnecessary complication.  */
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|size_varies
condition|)
block|{
comment|/* We must be able to distinguish the 			 SAVE_EXPR_CONTEXT for the variably-sized type 			 so that we can set it correctly in 			 set_save_expr_context.  The convention is 			 that all SAVE_EXPRs that need to be reset 			 have NULL_TREE for their SAVE_EXPR_CONTEXT.  */
name|tree
name|cfd
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|current_function_decl
operator|=
name|cfd
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support flexible array members"
argument_list|)
expr_stmt|;
comment|/* ISO C99 Flexible array members are effectively identical 		 to GCC's zero-length array extension.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If pedantic, complain about arrays of incomplete types.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"array type has incomplete element type"
argument_list|)
expr_stmt|;
comment|/* Build the array type itself, then merge any constancy or 	     volatility into the target type.  We must do it in this order 	     to ensure that the TYPE_MAIN_VARIANT field of the array type 	     is set correctly.  */
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The GCC extension for zero-length arrays differs from 	     ISO flexible array members in that sizeof yields zero.  */
if|if
condition|(
name|size
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|!=
name|PARM
operator|&&
operator|(
name|array_ptr_quals
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
comment|/* Say it's a definition only for the declarator closest to 	     the identifier, apart possibly from some attributes.  */
name|bool
name|really_funcdef
init|=
name|false
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|really_funcdef
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
expr_stmt|;
block|}
comment|/* Declaring a function type. 	     Make sure we have a valid type for the function to return.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|size_varies
operator|=
literal|0
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	     inner layer of declarator.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|really_funcdef
argument_list|)
expr_stmt|;
comment|/* Type qualifiers before the return type of the function 	     qualify the return type, not the function type.  */
if|if
condition|(
name|type_quals
condition|)
block|{
comment|/* Type qualifiers on a function return type are normally 		 permitted by the standard but have no effect, so give a 		 warning at -Wextra.  Qualifiers on a void return type have 		 meaning as a GNU extension, and are banned on function 		 definitions in ISO C.  FIXME: strictly we shouldn't 		 pedwarn for qualified void return types except on function 		 definitions, but not doing so could lead to the undesirable 		 state of a "volatile void" function return type not being 		 warned about, and a use of the function being compiled 		 with GNU semantics, with no diagnostics under -pedantic.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified void function return type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|type_quals
operator|==
name|TYPE_QUAL_VOLATILE
operator|)
condition|)
name|warning
argument_list|(
literal|"type qualifiers ignored on function return type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for each tagged type which is local to 	     the formal parameter list of this FUNCTION_TYPE to point to 	     the FUNCTION_TYPE node itself.  */
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|last_function_parm_tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords 	     (such as const or volatile) that were given inside the `*'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_CONST
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_VOLATILE
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_RESTRICT
condition|)
name|restrictp
operator|++
expr_stmt|;
else|else
name|erred
operator|++
expr_stmt|;
block|}
else|else
name|erred
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|erred
condition|)
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* Check the type and width of a bit-field.  */
if|if
condition|(
name|bitfield
condition|)
name|check_bitfield_type_and_width
argument_list|(
operator|&
name|type
argument_list|,
name|width
argument_list|,
name|orig_name
argument_list|)
expr_stmt|;
comment|/* Did array size calculations overflow?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we proceed with the array type as it is, we'll eventually 	 crash in tree_low_cst().  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|typedef_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* Aside from typedefs and type names (handle above),      `void' at top level (not within pointer)      is allowed only in public variables.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
operator|!
operator|(
operator|(
name|decl_context
operator|!=
name|FIELD
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|||
operator|(
name|current_scope
operator|==
name|global_scope
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|tree
name|type_as_written
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|array_ptr_quals
condition|)
block|{
name|tree
name|new_ptr_quals
decl_stmt|,
name|new_ptr_attrs
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|array_ptr_quals
argument_list|,
operator|&
name|new_ptr_quals
argument_list|,
operator|&
name|new_ptr_attrs
argument_list|)
expr_stmt|;
comment|/* We don't yet implement attributes in this context.  */
if|if
condition|(
name|new_ptr_attrs
operator|!=
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"attributes in parameter array declarator ignored"
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|new_ptr_quals
condition|;
name|new_ptr_quals
operator|=
name|TREE_CHAIN
argument_list|(
name|new_ptr_quals
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|new_ptr_quals
argument_list|)
decl_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_CONST
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_VOLATILE
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_RESTRICT
condition|)
name|restrictp
operator|++
expr_stmt|;
else|else
name|erred
operator|++
expr_stmt|;
block|}
else|else
name|erred
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|erred
condition|)
name|error
argument_list|(
literal|"invalid type modifier within array declarator"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
name|size_varies
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type_as_written
operator|=
name|type
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|promoted_type
operator|=
name|type
expr_stmt|;
else|else
name|promoted_type
operator|=
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|promoted_type
expr_stmt|;
name|DECL_ARG_TYPE_AS_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
name|type_as_written
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* Structure field.  It may not be a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' declared as a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|!
name|COMPLETE_OR_UNBOUND_ARRAY_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type_quals
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
name|bitfield
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Every function declaration is "external" 	   except for those which are inside a function body 	   in which `auto' is used. 	   That is a case not specified by ANSI C, 	   and we use it for forward declarations for nested functions.  */
name|int
name|extern_ref
init|=
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|||
name|current_scope
operator|==
name|global_scope
operator|)
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|&&
operator|(
name|pedantic
operator|||
name|current_scope
operator|==
name|global_scope
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at file scope. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_scope
operator|!=
name|global_scope
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl_attribute_variant
argument_list|(
name|decl
argument_list|,
name|decl_attr
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
comment|/* GNU C interprets a `volatile void' return type to indicate 	   that the function does not return.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`noreturn' function returns non-void value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extern_ref
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record absence of global scope for `static' or `auto'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|defaulted_int
condition|)
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
if|if
condition|(
name|inlinep
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inlinep
condition|)
block|{
comment|/* Record that the function is declared `inline'.  */
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do not mark bare declarations as DECL_INLINE.  Doing so 	       in the presence of multiple declarations can result in 	       the abstract origin pointing between the declarations, 	       which will confuse dwarf2out.  */
if|if
condition|(
name|initialized
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If -finline-functions, assume it can be inlined.  This does 	   two things: let the function be deferred until it is actually 	   needed, and let dwarf2 know that the function is inlinable.  */
elseif|else
if|if
condition|(
name|flag_inline_trees
operator|==
literal|2
operator|&&
name|initialized
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|int
name|extern_ref
init|=
operator|!
name|initialized
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
decl_stmt|;
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type_quals
condition|)
block|{
name|int
name|saved_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|saved_align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* It is invalid to create an `extern' declaration for a 	   variable if there is a global declaration that is 	   `static' and the global declaration is not visible.  */
if|if
condition|(
name|extern_ref
operator|&&
name|current_scope
operator|!=
name|global_scope
condition|)
block|{
name|tree
name|global_decl
decl_stmt|;
name|global_decl
operator|=
name|identifier_global_value
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_decl
operator|&&
name|TREE_CODE
argument_list|(
name|global_decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|lookup_name
argument_list|(
name|declarator
argument_list|)
operator|!=
name|global_decl
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|global_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"variable previously declared `static' redeclared "
literal|"`extern'"
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|pedwarn
argument_list|(
literal|"%Jvariable '%D' declared `inline'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
comment|/* At file scope, the presence of a `static' or `register' storage 	   class specifier, or the absence of all storage class specifiers 	   makes this declaration a definition (perhaps tentative).  Also, 	   the absence of both `static' and `register' makes it public.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|extern_ref
expr_stmt|;
block|}
comment|/* Not at file scope, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_tls
condition|)
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
comment|/* A mere warning is sure to result in improper semantics 		 at runtime.  Don't bother to allow this to compile.  */
name|error
argument_list|(
literal|"thread-local storage not supported for this target"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a type has volatile components, it should be stored in memory.        Otherwise, the fact that those components are volatile        will be ignored, and would even crash the compiler.  */
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|c_mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* This is the earliest point at which we might know the assembler      name of a variable.  Thus, if it's known before this, die horribly.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode the parameter-list info for a function type or function definition.    The argument is the value returned by `get_parm_info' (or made in parse.y    if there is an identifier list instead of a parameter decl list).    These two functions are separate because when a function returns    or receives functions then each is called multiple times but the order    of calls is different.  The last call to `grokparms' is always the one    that contains the formal parameter names of a function definition.     Store in `last_function_parms' a chain of the decls of parms.    Also store in `last_function_parm_tags' a chain of the struct, union,    and enum tags declared among the parms.     Return a list of arg types to use in the FUNCTION_TYPE for this function.     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|tree
name|parms_info
parameter_list|,
name|int
name|funcdef_flag
parameter_list|)
block|{
name|tree
name|first_parm
init|=
name|TREE_CHAIN
argument_list|(
name|parms_info
argument_list|)
decl_stmt|;
name|last_function_parms
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|TREE_VALUE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
name|last_function_parm_others
operator|=
name|TREE_TYPE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|first_parm
operator|==
literal|0
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_parm
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|typelt
decl_stmt|;
comment|/* If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
for|for
control|(
name|parm
operator|=
name|last_function_parms
operator|,
name|typelt
operator|=
name|first_parm
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
comment|/* Skip over any enumeration constants declared here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Barf if the parameter itself has an incomplete type.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
expr_stmt|;
block|}
return|return
name|first_parm
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a tree_list node with info on a parameter list just parsed.    The TREE_PURPOSE is a list of decls of those parms.    The TREE_VALUE is a list of structure, union and enum tags defined.    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.    The TREE_TYPE is a list of non-parameter decls which appeared with the    parameters.    This tree_list node is later fed to `grokparms'.     VOID_AT_END nonzero means append `void' to the end of the type-list.    Zero means the parmlist ended with an ellipsis so don't append `void'.  */
end_comment

begin_function
name|tree
name|get_parm_info
parameter_list|(
name|int
name|void_at_end
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|list
decl_stmt|;
name|tree
name|types
init|=
literal|0
decl_stmt|;
name|tree
modifier|*
name|last_type
init|=
operator|&
name|types
decl_stmt|;
name|tree
name|tags
init|=
name|current_scope
operator|->
name|tags
decl_stmt|;
name|tree
name|parms
init|=
name|current_scope
operator|->
name|parms
decl_stmt|;
name|tree
name|others
init|=
name|current_scope
operator|->
name|names
decl_stmt|;
specifier|static
name|bool
name|explained_incomplete_types
init|=
name|false
decl_stmt|;
name|bool
name|gave_void_only_once_err
init|=
name|false
decl_stmt|;
comment|/* Just "void" (and no ellipsis) is special.  There are really no parms.      But if the "void" is qualified (by "const" or "volatile"), or has a      storage class specifier ("register"), then the behavior is undefined;      issue an error.  Typedefs for "void" are OK (see DR#157).  */
if|if
condition|(
name|void_at_end
operator|&&
name|parms
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|parms
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"void\" as only parameter may not be qualified"
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Sanity check all of the parameter declarations.  */
for|for
control|(
name|decl
operator|=
name|parms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Since there is a prototype, args are passed in their 	 declared types.  The back end may override this.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Check for (..., void, ...) and issue an error.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|gave_void_only_once_err
condition|)
block|{
name|error
argument_list|(
literal|"\"void\" must be the only parameter"
argument_list|)
expr_stmt|;
name|gave_void_only_once_err
operator|=
name|true
expr_stmt|;
block|}
name|type
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|*
name|last_type
operator|=
name|type
expr_stmt|;
name|last_type
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Check the list of non-parameter decls for any forward parm decls      that never got real decls.  */
for|for
control|(
name|decl
operator|=
name|others
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"%Jparameter \"%D\" has just a forward declaration"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about any struct, union or enum tags defined within this      list.  The scope of such types is limited to this declaration,      which is rarely if ever desirable (it's impossible to call such      a function with type-correct arguments).  */
for|for
control|(
name|decl
operator|=
name|tags
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyword
decl_stmt|;
comment|/* An anonymous union parm type is meaningful as a GNU extension. 	 So don't warn for that.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|pedantic
condition|)
continue|continue;
comment|/* The keyword should not be translated.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|keyword
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|keyword
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|keyword
operator|=
literal|"enum"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The first %s will be one of 'struct', 'union', or 'enum'.  */
name|warning
argument_list|(
literal|"\"%s %s\" declared inside parameter list"
argument_list|,
name|keyword
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* The %s will be one of 'struct', 'union', or 'enum'.  */
name|warning
argument_list|(
literal|"anonymous %s declared inside parameter list"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained_incomplete_types
condition|)
block|{
name|warning
argument_list|(
literal|"its scope is only this definition or declaration,"
literal|" which is probably not what you want"
argument_list|)
expr_stmt|;
name|explained_incomplete_types
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|void_at_end
condition|)
block|{
name|type
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
operator|*
name|last_type
operator|=
name|type
expr_stmt|;
block|}
name|list
operator|=
name|tree_cons
argument_list|(
name|parms
argument_list|,
name|tags
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|others
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this is the right type of tag, return what we found.      (This reference will be shadowed by shadow_tag later if appropriate.)      If this is the wrong type of tag, do not return it.  If it was the      wrong type in the same scope, we will have had an error      message already; if in a different scope and declaring      a name, pending_xref_error will give an error message; but if in a      different scope and not declaring a name, this tag should      shadow the previous declaration of a different type of tag, and      this would not work properly if we return the reference found.      (For example, with "struct foo" in an outer scope, "union foo;"      must shadow that tag with a new one of union type.)  */
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
return|return
name|ref
return|;
comment|/* If no such tag is yet defined, create a forward-reference node      and record it as the "definition".      When a real declaration of this type is found,      the forward-reference will be altered into a real type.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* Give the type a default layout like unsigned int 	 to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
block|}
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current scope*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.  */
end_comment

begin_function
name|tree
name|start_struct
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* If there is already a tag defined at this scope      (as a forward reference), just return it.  */
name|tree
name|ref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `union %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"redefinition of `struct %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"nested redefinition of `union %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"nested redefinition of `struct %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|ref
argument_list|)
operator|=
name|flag_pack_struct
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|tree
name|declspecs
parameter_list|,
name|tree
name|width
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|&&
name|width
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* This is an unnamed decl.  	 If we have something of the form "union { list } ;" then this 	 is the anonymous union extension.  Similarly for struct.  	 If this is something of the form "struct foo;", then 	   If MS extensions are enabled, this is handled as an 	     anonymous struct. 	   Otherwise this is a forward declaration of a structure tag.  	 If this is something of the form "foo;" and foo is a TYPE_DECL, then 	   If MS extensions are enabled and foo names a structure, then 	     again this is an anonymous struct. 	   Otherwise this is an error.  	 Oh what a horrid tangled web we weave.  I wonder if MS consciously 	 took this from Plan 9 or if it was an accident of implementation 	 that took root before someone noticed the bug...  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_ms_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|flag_ms_extensions
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
name|flag_iso
condition|)
goto|goto
name|warn_unnamed_field
goto|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* ok */
else|else
goto|goto
name|warn_unnamed_field
goto|;
block|}
else|else
block|{
name|warn_unnamed_field
label|:
name|warning
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
literal|0
argument_list|,
name|width
condition|?
operator|&
name|width
else|:
name|NULL
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an error for any duplicate field names in FIELDLIST.  Munge    the list such that this does not present a problem later.  */
end_comment

begin_function
specifier|static
name|void
name|detect_field_duplicates
parameter_list|(
name|tree
name|fieldlist
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
comment|/* First, see if there are more than "a few" fields.      This is trivially true if there are zero or one fields.  */
if|if
condition|(
operator|!
name|fieldlist
condition|)
return|return;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
do|do
block|{
name|timeout
operator|--
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|timeout
operator|>
literal|0
operator|&&
name|x
condition|)
do|;
comment|/* If there were "few" fields, avoid the overhead of allocating      a hash table.  Instead just do the nested traversal thing.  */
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|y
operator|=
name|fieldlist
init|;
name|y
operator|!=
name|x
condition|;
name|y
operator|=
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jduplicate member '%D'"
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|htab_t
name|htab
init|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
operator|(
name|y
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|y
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
block|{
name|error
argument_list|(
literal|"%Jduplicate member '%D'"
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|*
name|slot
operator|=
name|y
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.    FIELDLIST is a chain of FIELD_DECL nodes for the fields.    ATTRIBUTES are attributes to be applied to the structure.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|fieldlist
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|int
name|toplevel
init|=
name|global_scope
operator|==
name|current_scope
decl_stmt|;
name|int
name|saw_named_field
decl_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Nameless union parm types are useful as GCC extension.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|pedantic
condition|)
comment|/* Otherwise, warn about any struct or union def. in parmlist.  */
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"%s defined inside parms"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%s defined inside parms"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"%s has no %s"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"struct"
argument_list|)
argument_list|,
name|fieldlist
condition|?
name|_
argument_list|(
literal|"named members"
argument_list|)
else|:
name|_
argument_list|(
literal|"members"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Install struct as DECL_CONTEXT of each field decl.      Also process specified field sizes,m which is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
name|saw_named_field
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any field that is volatile means variables of this type must be 	 treated in some ways as volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Any field of nominal variable size implies structure is too.  */
if|if
condition|(
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|tree_low_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Detect flexible array member in an invalid context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member not at end of struct"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|saw_named_field
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member in otherwise empty struct"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jinvalid use of structure with flexible array member"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|saw_named_field
operator|=
literal|1
expr_stmt|;
block|}
name|detect_field_duplicates
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
comment|/* Now we have the nearly final fieldlist.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the fieldlist.  */
block|{
name|tree
modifier|*
name|fieldlistp
init|=
operator|&
name|fieldlist
decl_stmt|;
while|while
condition|(
operator|*
name|fieldlistp
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldlistp
argument_list|)
condition|)
operator|*
name|fieldlistp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldlistp
argument_list|)
expr_stmt|;
else|else
name|fieldlistp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldlistp
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the truly final field list.      Store it in this type and in the variants.  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
comment|/* If there are lots of fields, sort so we can look through them fast.      We arbitrarily consider 16 or more elts to be "a lot".  */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|len
operator|>
literal|15
operator|||
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|len
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|15
condition|)
block|{
name|tree
modifier|*
name|field_array
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|space
decl_stmt|;
name|struct
name|sorted_fields_type
modifier|*
name|space2
decl_stmt|;
name|len
operator|+=
name|list_length
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Use the same allocation policy here that make_node uses, to           ensure that this lives as long as the rest of the struct decl.           All decls in an inline function need to be saved.  */
name|space
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|space2
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sorted_fields_type
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|space
operator|->
name|s
operator|=
name|space2
expr_stmt|;
name|field_array
operator|=
operator|&
name|space2
operator|->
name|elts
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|field_array
index|[
name|len
operator|++
index|]
operator|=
name|x
expr_stmt|;
comment|/* If there is anonymous struct or union, break out of the loop.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Found no anonymous struct/union.  Add the TYPE_LANG_SPECIFIC.  */
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|space
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|s
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|field_array
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|s
operator|->
name|elts
expr_stmt|;
name|qsort
argument_list|(
name|field_array
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|field_decl_cmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|x
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TYPE_FIELDS
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this was supposed to be a transparent union, but we can't      make it one, warn and turn off the flag.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"union cannot be made transparent"
argument_list|)
expr_stmt|;
block|}
comment|/* If this structure or union completes the type of any previous      variable declaration, lay it out and output its rtl.  */
for|for
control|(
name|x
operator|=
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Lay out the type T, and its element type, and so on.  */
end_comment

begin_function
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"nested redefinition of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_short_enums
condition|)
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object, VALUES a list of decl-value pairs,    and ATTRIBUTES are the specified attributes.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|tree
name|enumtype
parameter_list|,
name|tree
name|values
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|pair
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|minnode
init|=
literal|0
decl_stmt|,
name|maxnode
init|=
literal|0
decl_stmt|,
name|enum_value_type
decl_stmt|;
name|int
name|precision
decl_stmt|,
name|unsign
decl_stmt|;
name|int
name|toplevel
init|=
operator|(
name|global_scope
operator|==
name|current_scope
operator|)
decl_stmt|;
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
name|warning
argument_list|(
literal|"enum defined inside parms"
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|enumtype
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
operator|==
name|error_mark_node
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|minnode
operator|=
name|maxnode
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/* Construct the final type of this enumeration.  It is the same      as one of the integral types - the narrowest one that fits, except      that normally we only go as narrow as int - and signed iff any of      the values are negative.  */
name|unsign
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsign
argument_list|)
argument_list|,
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsign
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|||
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|narrowest
init|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
name|unsign
argument_list|)
decl_stmt|;
if|if
condition|(
name|narrowest
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"enumeration values exceed range of largest integer"
argument_list|)
expr_stmt|;
name|narrowest
operator|=
name|long_long_integer_type_node
expr_stmt|;
block|}
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|narrowest
argument_list|)
expr_stmt|;
block|}
else|else
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|enum_value_type
operator|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|enum_value_type
operator|=
name|enumtype
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|minnode
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|maxnode
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
name|unsign
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the precision of the type was specific with an attribute and it      was too small, give an error.  Otherwise, use it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"specified mode too small for enumeral values"
argument_list|)
expr_stmt|;
block|}
else|else
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|precision
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Change the type of the enumerators to be the enum type.  We 	 need to do this irrespective of the size of the enum, for 	 proper type checking.  Replace the DECL_INITIALs of the 	 enumerators, and the value slots of the list, with copies 	 that have the enum type; they cannot be modified in place 	 because they may be shared (e.g.  integer_zero_node) Finally, 	 change the purpose slots to point to the names of the decls.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|enu
init|=
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|enu
argument_list|)
operator|=
name|enumtype
expr_stmt|;
comment|/* The ISO C Standard mandates enumerators to have type int, 	     even though the underlying type of an enum type is 	     unspecified.  Here we convert any enumerators that fit in 	     an int to type int, to avoid promotions to unsigned types 	     when comparing integers with enumerators that fit in the 	     int range.  When -pedantic is given, build_enumerator() 	     would have already taken care of those that don't fit.  */
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|,
name|enum_value_type
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
operator|=
name|convert
argument_list|(
name|enum_value_type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
operator|=
name|convert
argument_list|(
name|enumtype
argument_list|,
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|enu
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
expr_stmt|;
block|}
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
block|}
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|tem
operator|==
name|enumtype
condition|)
continue|continue;
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the CONST_DECL and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
comment|/* Validate and default VALUE.  */
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
comment|/* It should no longer be possible to have NON_LVALUE_EXPR      in the default.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|error
argument_list|(
literal|"overflow in enumeration values"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C restricts enumerator values to range of `int'"
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Now create a declaration for the enum value name.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS, DECLARATOR and ATTRIBUTES are the parts of    the declaration; they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|tree
name|declspecs
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|decl1
decl_stmt|,
name|old_decl
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
comment|/* Assume, until we see it does.  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|current_function_returns_abnormally
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|c_in_iteration_stmt
operator|=
literal|0
expr_stmt|;
name|c_in_case_stmt
operator|=
literal|0
expr_stmt|;
comment|/* Don't expand any sizes in the return type of the function.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
condition|)
block|{
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
return|return
literal|0
return|;
block|}
name|decl_attributes
argument_list|(
operator|&
name|decl1
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl1
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jinline function '%D' given attribute noinline"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"return type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|pedwarn_c99
argument_list|(
literal|"return type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
name|current_function_parm_others
operator|=
name|last_function_parm_others
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.      But not if what we had before was a builtin function.  */
name|old_decl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Optionally warn of old-fashioned def with no previous prototype.  */
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|C_DECL_ISNT_PROTOTYPE
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous prototype.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|&&
name|C_DECL_ISNT_PROTOTYPE
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jno previous prototype for '%D'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous prototype      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"%J'%D' was used with no prototype before its definition"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous declaration.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
name|old_decl
operator|==
literal|0
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jno previous declaration for '%D'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous declaration      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|C_DECL_IMPLICIT
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%J`%D' was used with no declaration before its definition"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* This is a definition, not a reference.      So normally clear DECL_EXTERNAL.      However, `extern inline' acts like a declaration      except for defining how to inline.  So set DECL_EXTERNAL in that case.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* A nested function is not global.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* This is the earliest point at which we might know the assembler      name of the function.  Thus, if it's set before this, die horribly.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If #pragma weak was used, mark the decl weak now.  */
if|if
condition|(
name|current_scope
operator|==
name|global_scope
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Warn for unlikely, improbable, or stupid declarations of `main'.  */
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|int
name|argct
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn
argument_list|(
literal|"%Jreturn type of '%D' is not `int'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
break|break;
operator|++
name|argct
expr_stmt|;
switch|switch
condition|(
name|argct
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn
argument_list|(
literal|"%Jfirst argument of '%D' should be `int'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jsecond argument of '%D' should be 'char **'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jthird argument of '%D' should probably be "
literal|"'char **'"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* It is intentional that this message does not mention the third 	 argument because it's only mentioned in an appendix of the 	 standard.  */
if|if
condition|(
name|argct
operator|>
literal|0
operator|&&
operator|(
name|argct
operator|<
literal|2
operator|||
name|argct
operator|>
literal|3
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"%J'%D' takes only zero or two arguments"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%J'%D' is normally a non-static function"
argument_list|,
name|decl1
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_parm_level
argument_list|()
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if not really getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of store_parm_decls which handles new-style function    definitions (prototype format). The parms already have decls, so we    need only record them as in effect and complain if any redundant    old-style parm decls were written.  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls_newstyle
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|parms
init|=
name|current_function_parms
decl_stmt|;
name|tree
name|tags
init|=
name|current_function_parm_tags
decl_stmt|;
name|tree
name|others
init|=
name|current_function_parm_others
decl_stmt|;
if|if
condition|(
name|current_scope
operator|->
name|parms
operator|||
name|current_scope
operator|->
name|names
operator|||
name|current_scope
operator|->
name|tags
condition|)
block|{
name|error
argument_list|(
literal|"%Jold-style parameter declarations in prototyped "
literal|"function definition"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Get rid of the old-style declarations.  */
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now make all the parameter declarations visible in the function body.      We can bypass most of the grunt work of pushdecl.  */
for|for
control|(
name|last
operator|=
literal|0
operator|,
name|decl
operator|=
name|parms
init|;
name|decl
condition|;
name|last
operator|=
name|decl
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%Jparameter name omitted"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|current_scope
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|current_scope
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
block|}
name|current_scope
operator|->
name|parms
operator|=
name|parms
expr_stmt|;
name|current_scope
operator|->
name|parms_last
operator|=
name|last
expr_stmt|;
comment|/* Record the parameter list in the function declaration.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|parms
expr_stmt|;
comment|/* Now make all the ancillary declarations visible, likewise.  */
for|for
control|(
name|last
operator|=
literal|0
operator|,
name|decl
operator|=
name|others
init|;
name|decl
condition|;
name|last
operator|=
name|decl
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|current_scope
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|current_scope
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
block|}
name|current_scope
operator|->
name|names
operator|=
name|others
expr_stmt|;
name|current_scope
operator|->
name|names_last
operator|=
name|last
expr_stmt|;
comment|/* And all the tag declarations.  */
for|for
control|(
name|decl
operator|=
name|tags
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|current_scope
operator|->
name|shadowed_tags
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|current_scope
operator|->
name|shadowed_tags
argument_list|)
expr_stmt|;
name|IDENTIFIER_TAG_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|current_scope
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of store_parm_decls which handles old-style function    definitions (separate parameter list and declarations).  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls_oldstyle
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|,
name|decl
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/* This is the identifier list from the function declarator.  */
name|tree
name|parmids
init|=
name|current_function_parms
decl_stmt|;
comment|/* We use DECL_WEAK as a flag to show which parameters have been      seen already, since it is not used on PARM_DECL.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|parm
operator|=
name|current_scope
operator|->
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|parm
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Match each formal parameter name with its declaration.  Save each      decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */
for|for
control|(
name|parm
operator|=
name|parmids
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%Jparameter name missing from parameter list"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|decl
operator|=
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|fndecl
condition|)
block|{
comment|/* If we got something other than a PARM_DECL it is an error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|error
argument_list|(
literal|"%J\"%D\" declared as a non-parameter"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If the declaration is already marked, we have a duplicate 	     name.  Complain and ignore the duplicate.  */
elseif|else
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jmultiple parameters named \"%D\""
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If the declaration says "void", complain and turn it into 	     an int.  */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jparameter \"%D\" declared void"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If no declaration found, default to int.  */
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"%Jtype of \"%D\" defaults to \"int\""
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"%Jtype of \"%D\" defaults to \"int\""
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|decl
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now examine the parms chain for incomplete declarations      and declarations with no corresponding names.  */
for|for
control|(
name|parm
operator|=
name|current_scope
operator|->
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jparameter \"%D\" has incomplete type"
argument_list|,
name|parm
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jdeclaration for parameter \"%D\" but no such parameter"
argument_list|,
name|parm
argument_list|,
name|parm
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 	     This gets us to a standard state and minimizes 	     further error messages.  */
name|parmids
operator|=
name|chainon
argument_list|(
name|parmids
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Chain the declarations together in the order of the list of      names.  Store that chain in the function decl, replacing the      list of names.  Update the current scope to match.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parmids
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
break|break;
if|if
condition|(
name|parm
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|last
expr_stmt|;
name|current_scope
operator|->
name|parms
operator|=
name|last
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|current_scope
operator|->
name|parms_last
operator|=
name|last
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If there was a previous prototype,      set the DECL_ARG_TYPE of each argument according to      the type previously specified, and report any mismatches.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
init|;
name|parm
operator|||
operator|(
name|type
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|parm
operator|==
literal|0
operator|||
name|type
operator|==
literal|0
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"number of arguments doesn't match prototype"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent with that 	     declared for the arg.  ISO C says we take the unqualified 	     type for parameters declared with qualified type.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|COMPARE_STRICT
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Adjust argument to match prototype.  E.g. a previous 		     `int foo(float);' prototype causes 		     `int foo(x) float x; {...}' to be treated like 		     `int foo(float x) {...}'.  This is particularly 		     useful for argument types like uid_t.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"promoted argument \"%D\" "
literal|"doesn't match prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"argument \"%D\" doesn't match prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, create a prototype that would match.  */
else|else
block|{
name|tree
name|actual
init|=
literal|0
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
name|last
operator|=
name|type
expr_stmt|;
block|}
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
comment|/* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES 	 of the type of this function, but we need to avoid having this 	 affect the types of other similarly-typed functions, so we must 	 first force the generation of an identical (but separate) type 	 node for the relevant function type.  The new node we create 	 will be a variant of the main variant of the original function 	 type.  */
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_type_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|actual
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     For an old-style definition, construct a prototype out of the old-style    parameter declarations and inject it into the function's type.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/* True if this definition is written with a prototype.  */
name|bool
name|prototype
init|=
operator|(
name|current_function_parms
operator|&&
name|TREE_CODE
argument_list|(
name|current_function_parms
argument_list|)
operator|!=
name|TREE_LIST
operator|)
decl_stmt|;
if|if
condition|(
name|prototype
condition|)
name|store_parm_decls_newstyle
argument_list|()
expr_stmt|;
else|else
name|store_parm_decls_oldstyle
argument_list|()
expr_stmt|;
comment|/* The next call to pushlevel will be a function body.  */
name|next_is_function_body
operator|=
name|true
expr_stmt|;
comment|/* Write a record describing this function definition to the prototypes      file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|prototype
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|allocate_struct_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Begin the statement tree for this function.  */
name|begin_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save away the sizes of any variable-size types so that we can      expand them when generating RTL.  */
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|->
name|pending_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* This function is being processed in whole-function mode.  */
name|cfun
operator|->
name|x_whole_function_mode_p
operator|=
literal|1
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/* When a function declaration is totally empty, e.g.         void foo(void) { }      (the argument list is irrelevant) the compstmt rule will not      bother calling pushlevel/poplevel, which means we get here with      the scope stack out of sync.  Detect this situation by noticing      that current_scope is still as store_parm_decls left it, and do      a dummy push/pop to get back to consistency.      Note that the call to pushlevel does not actually push another      scope - see there for details.  */
if|if
condition|(
name|current_scope
operator|->
name|parm_flag
operator|&&
name|next_is_function_body
condition|)
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|args
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|flag_hosted
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned. 	     If warn_main is -1 (-Wno-main) we don't want to be warned.  */
if|if
condition|(
operator|!
name|warn_main
condition|)
name|pedwarn
argument_list|(
literal|"%Jreturn type of '%D' is not `int'"
argument_list|,
name|fndecl
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEFAULT_MAIN_RETURN
comment|/* Make it so that `main' always returns success by default.  */
name|DEFAULT_MAIN_RETURN
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_isoc99
condition|)
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* Tie off the statement tree for this function.  */
name|finish_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Complain if there's just no return statement.  */
if|if
condition|(
name|warn_return_type
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
operator|!
name|current_function_returns_value
operator|&&
operator|!
name|current_function_returns_null
comment|/* Don't complain if we abort.  */
operator|&&
operator|!
name|current_function_returns_abnormally
comment|/* Don't warn for main().  */
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
comment|/* Or if they didn't actually specify a return type.  */
operator|&&
operator|!
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|fndecl
argument_list|)
comment|/* Normally, with -Wreturn-type, flow will complain.  Unless we're an 	 inline function, as we might never be compiled separately.  */
operator|&&
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"no return statement in function returning non-void"
argument_list|)
expr_stmt|;
comment|/* With just -Wextra, complain only if function returns both with      and without a value.  */
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* We're leaving the context of this function, so zap cfun.  It's still in      DECL_SAVED_INSNS, and we'll restore it in tree_rest_of_compilation.  */
name|cfun
operator|=
name|NULL
expr_stmt|;
comment|/* ??? Objc emits functions after finalizing the compilation unit.      This should be cleaned up later and this conditional removed.  */
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
name|cgraph_finalize_function
argument_list|(
name|fndecl
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|c_expand_body
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a deferred function FNDECL.  */
end_comment

begin_function
name|void
name|c_expand_deferred_function
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
comment|/* DECL_INLINE or DECL_RESULT might got cleared after the inline      function was deferred, e.g. in duplicate_decls.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_inline_trees
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|optimize_inline_calls
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
block|}
name|c_expand_body
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for the body of FNDECL.  If NESTED_P is nonzero,    then we are already in the process of generating RTL for another    function.  */
end_comment

begin_function
specifier|static
name|void
name|c_expand_body_1
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|nested_p
parameter_list|)
block|{
if|if
condition|(
name|nested_p
condition|)
comment|/* Squirrel away our current state.  */
name|push_function_context
argument_list|()
expr_stmt|;
comment|/* Make sure that we will evaluate variable-sized types involved      in our function's type.  */
name|put_pending_sizes
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|->
name|pending_sizes
argument_list|)
expr_stmt|;
name|tree_rest_of_compilation
argument_list|(
name|fndecl
argument_list|,
name|nested_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_p
condition|)
comment|/* Return to the enclosing function.  */
name|pop_function_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
call|)
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
else|else
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|destructor
call|)
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
else|else
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like c_expand_body_1 but only for unnested functions.  */
end_comment

begin_function
name|void
name|c_expand_body
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|c_expand_body_1
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the declarations given in a for-loop for satisfying the C99    constraints.  */
end_comment

begin_function
name|void
name|check_for_loop_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
block|{
comment|/* If we get here, declarations have been used in a for loop without 	 the C99 for loop scope.  This doesn't make much sense, so don't 	 allow it.  */
name|error
argument_list|(
literal|"'for' loop initial declaration used outside C99 mode"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* C99 subclause 6.8.5 paragraph 3:         [#3]  The  declaration  part  of  a for statement shall only        declare identifiers for objects having storage class auto or        register.       It isn't clear whether, in this sentence, "identifiers" binds to      "shall only declare" or to "objects" - that is, whether all identifiers      declared must be identifiers for objects, or whether the restriction      only applies to those that are.  (A question on this in comp.std.c      in November 2000 received no answer.)  We implement the strictest      interpretation, to avoid creating an extension which later causes      problems.  */
for|for
control|(
name|t
operator|=
name|current_scope
operator|->
name|tags
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|error
argument_list|(
literal|"'struct %s' declared in 'for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"'union %s' declared in 'for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"'enum %s' declared in 'for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|getdecls
argument_list|()
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jdeclaration of non-variable '%D' in 'for' loop "
literal|"initial declaration"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jdeclaration of static variable '%D' in 'for' loop "
literal|"initial declaration"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jdeclaration of 'extern' variable '%D' in 'for' loop "
literal|"initial declaration"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_push_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|language_function
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
operator|=
name|c_stmt_tree
expr_stmt|;
name|p
operator|->
name|base
operator|.
name|x_scope_stmt_stack
operator|=
name|c_scope_stmt_stack
expr_stmt|;
name|p
operator|->
name|x_in_iteration_stmt
operator|=
name|c_in_iteration_stmt
expr_stmt|;
name|p
operator|->
name|x_in_case_stmt
operator|=
name|c_in_case_stmt
expr_stmt|;
name|p
operator|->
name|returns_value
operator|=
name|current_function_returns_value
expr_stmt|;
name|p
operator|->
name|returns_null
operator|=
name|current_function_returns_null
expr_stmt|;
name|p
operator|->
name|returns_abnormally
operator|=
name|current_function_returns_abnormally
expr_stmt|;
name|p
operator|->
name|warn_about_return_type
operator|=
name|warn_about_return_type
expr_stmt|;
name|p
operator|->
name|extern_inline
operator|=
name|current_extern_inline
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the variables used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_pop_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|p
init|=
name|f
operator|->
name|language
decl_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|current_function_decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|c_stmt_tree
operator|=
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
expr_stmt|;
name|c_scope_stmt_stack
operator|=
name|p
operator|->
name|base
operator|.
name|x_scope_stmt_stack
expr_stmt|;
name|c_in_iteration_stmt
operator|=
name|p
operator|->
name|x_in_iteration_stmt
expr_stmt|;
name|c_in_case_stmt
operator|=
name|p
operator|->
name|x_in_case_stmt
expr_stmt|;
name|current_function_returns_value
operator|=
name|p
operator|->
name|returns_value
expr_stmt|;
name|current_function_returns_null
operator|=
name|p
operator|->
name|returns_null
expr_stmt|;
name|current_function_returns_abnormally
operator|=
name|p
operator|->
name|returns_abnormally
expr_stmt|;
name|warn_about_return_type
operator|=
name|p
operator|->
name|warn_about_return_type
expr_stmt|;
name|current_extern_inline
operator|=
name|p
operator|->
name|extern_inline
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the DECL_LANG_SPECIFIC data associated with DECL.  */
end_comment

begin_function
name|void
name|c_dup_lang_specific_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|ld
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|ld
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions below are required for functionality of doing    function at once processing in the C front end. Currently these    functions are not called from anywhere in the C front end, but as    these changes continue, that will change.  */
end_comment

begin_comment
comment|/* Returns nonzero if the current statement is a full expression,    i.e. temporaries created during that statement should be destroyed    at the end of the statement.  */
end_comment

begin_function
name|int
name|stmts_are_full_exprs_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|c_stmt_tree
return|;
block|}
end_function

begin_comment
comment|/* Returns the stack of SCOPE_STMTs for the current function.  */
end_comment

begin_function
name|tree
modifier|*
name|current_scope_stmt_stack
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|c_scope_stmt_stack
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in    C.  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|tree
name|node
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dummy function in place of callback used by C++.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Return a new COMPOUND_STMT, after adding it to the current    statement tree.  */
end_comment

begin_function
name|tree
name|c_begin_compound_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Create the COMPOUND_STMT.  */
name|stmt
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|error_mark_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Expand T (a DECL_STMT) if it declares an entity not handled by the    common code.  */
end_comment

begin_function
name|void
name|c_expand_decl_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|decl
init|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Expand nested functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|c_expand_body_1
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the global value of T as a symbol.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_SYMBOL_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
literal|0
operator|||
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|decl
return|;
comment|/* Shadowed by something else; find the true global value.  */
for|for
control|(
name|decl
operator|=
name|global_scope
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|t
condition|)
return|return
name|decl
return|;
comment|/* Only local values for this decl.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record a builtin type for C.  If NAME is non-NULL, it is the name used;    otherwise the name is found in ridpointers from RID_INDEX.  */
end_comment

begin_function
name|void
name|record_builtin_type
parameter_list|(
name|enum
name|rid
name|rid_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|id
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
else|else
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the void_list_node (void_type_node having been created).  */
end_comment

begin_function
name|tree
name|build_void_list_node
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS_ATTRS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers, possible mixed    with attributes.     We return an INDIRECT_REF whose "contents" are TARGET (inside a TREE_LIST,    if attributes are present) and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|tree
name|type_quals_attrs
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|quals
decl_stmt|,
name|attrs
decl_stmt|;
name|tree
name|itarget
init|=
name|target
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|type_quals_attrs
argument_list|,
operator|&
name|quals
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
operator|!=
name|NULL_TREE
condition|)
name|itarget
operator|=
name|tree_cons
argument_list|(
name|attrs
argument_list|,
name|target
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|quals
argument_list|,
name|itarget
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A wrapper around lhd_set_decl_assembler_name that gives static    variables their C names if they are at file scope and only one    translation unit is being compiled, for backwards compatibility    with certain bizarre assembler hacks (like crtstuff.c).  */
end_comment

begin_function
name|void
name|c_static_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|num_in_fnames
operator|==
literal|1
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|TRANSLATION_UNIT_DECL
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lhd_set_decl_assembler_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash and equality functions for link_hash_table: key off    DECL_ASSEMBLER_NAME.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|link_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x_p
parameter_list|)
block|{
name|tree
name|x
init|=
operator|(
name|tree
operator|)
name|x_p
decl_stmt|;
return|return
operator|(
name|hashval_t
operator|)
operator|(
name|long
operator|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|x2_p
parameter_list|)
block|{
name|tree
name|x1
init|=
operator|(
name|tree
operator|)
name|x1_p
decl_stmt|;
name|tree
name|x2
init|=
operator|(
name|tree
operator|)
name|x2_p
decl_stmt|;
return|return
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x1
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Propagate information between definitions and uses between multiple    translation units in TU_LIST based on linkage rules.  */
end_comment

begin_function
name|void
name|merge_translation_unit_decls
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|tree
name|tu_list
init|=
name|current_file_decl
decl_stmt|;
name|tree
name|tu
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|htab_t
name|link_hash_table
decl_stmt|;
name|tree
name|block
decl_stmt|;
comment|/* Create the BLOCK that poplevel would have created, but don't      actually call poplevel since that's expensive.  */
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|current_scope
operator|->
name|names
expr_stmt|;
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|current_file_decl
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* If only one translation unit seen, no copying necessary.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tu_list
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
name|link_hash_table
operator|=
name|htab_create
argument_list|(
literal|1021
argument_list|,
name|link_hash_hash
argument_list|,
name|link_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Enter any actual definitions into the hash table.  */
for|for
control|(
name|tu
operator|=
name|tu_list
init|;
name|tu
condition|;
name|tu
operator|=
name|TREE_CHAIN
argument_list|(
name|tu
argument_list|)
control|)
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|tu
argument_list|)
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|PTR
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|link_hash_table
argument_list|,
name|decl
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If we've already got a definition, work out which one is 	     the real one, put it into the hash table, and make the 	     other one DECL_EXTERNAL.  This is important to avoid 	     putting out two definitions of the same symbol in the 	     assembly output.  */
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
block|{
name|tree
name|old_decl
init|=
operator|(
name|tree
operator|)
operator|*
name|slot
decl_stmt|;
comment|/* If this is weak or common or whatever, suppress it 		 in favor of the other definition.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|old_decl
argument_list|)
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|old_decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|old_decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|old_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|slot
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%Jredefinition of global '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%J'%D' previously defined here"
argument_list|,
name|old_decl
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|slot
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Now insert the desired information from all the definitions      into any plain declarations.  */
for|for
control|(
name|tu
operator|=
name|tu_list
init|;
name|tu
condition|;
name|tu
operator|=
name|TREE_CHAIN
argument_list|(
name|tu
argument_list|)
control|)
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|tu
argument_list|)
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|global_decl
decl_stmt|;
name|global_decl
operator|=
name|htab_find
argument_list|(
name|link_hash_table
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|global_decl
condition|)
continue|continue;
comment|/* Print any appropriate error messages, and partially merge 	     the decls.  */
operator|(
name|void
operator|)
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|global_decl
argument_list|)
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|link_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform final processing on file-scope data.  */
end_comment

begin_function
name|void
name|c_write_global_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|current_file_decl
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|globals
init|=
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Process the decls in the order they were written.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|i
index|]
operator|=
name|decl
expr_stmt|;
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset the parser's state in preparation for a new file.  */
end_comment

begin_function
name|void
name|c_reset_state
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|file_scope_decl
decl_stmt|;
comment|/* Pop the global scope.  */
if|if
condition|(
name|current_scope
operator|!=
name|global_scope
condition|)
name|current_scope
operator|=
name|global_scope
expr_stmt|;
name|file_scope_decl
operator|=
name|current_file_decl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|file_scope_decl
argument_list|)
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|file_scope_decl
argument_list|)
argument_list|)
operator|=
name|file_scope_decl
expr_stmt|;
name|truly_local_externals
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Start a new global binding level.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_scope
operator|=
name|current_scope
expr_stmt|;
name|current_file_decl
operator|=
name|build_decl
argument_list|(
name|TRANSLATION_UNIT_DECL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|current_file_decl
argument_list|)
operator|=
name|file_scope_decl
expr_stmt|;
comment|/* Reintroduce the builtin declarations.  */
for|for
control|(
name|link
operator|=
name|first_builtin_decl
init|;
name|link
operator|!=
name|TREE_CHAIN
argument_list|(
name|last_builtin_decl
argument_list|)
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|pushdecl
argument_list|(
name|copy_node
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-decl.h"
end_include

end_unit

