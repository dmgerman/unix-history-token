begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* "Bag-of-pages" zone garbage collector for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin    (dberlin@dberlin.org)    This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VALGRIND_MEMCHECK_H
end_ifdef

begin_include
include|#
directive|include
file|<valgrind/memcheck.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
name|HAVE_MEMCHECK_H
end_elif

begin_include
include|#
directive|include
file|<memcheck.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<valgrind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid #ifdef:s when we can help it.  */
end_comment

begin_define
define|#
directive|define
name|VALGRIND_DISCARD
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|VALGRIND_MALLOCLIKE_BLOCK
parameter_list|(
name|w
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_define
define|#
directive|define
name|VALGRIND_FREELIKE_BLOCK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a    file open.  Prefer either to valloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_MMAP_DEV_ZERO
end_undef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USING_MMAP
end_ifndef

begin_error
error|#
directive|error
literal|"Zone collector requires mmap"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|GCC_VERSION
operator|<
literal|3001
operator|)
end_if

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|((void) X)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|__builtin_prefetch (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTES:    If we track inter-zone pointers, we can mark single zones at a    time.    If we have a zone where we guarantee no inter-zone pointers, we    could mark that zone separately.    The garbage zone should not be marked, and we should return 1 in    ggc_set_mark for any object in the garbage zone, which cuts off    marking quickly.  */
end_comment

begin_comment
comment|/* Stategy:     This garbage-collecting allocator segregates objects into zones.    It also segregates objects into "large" and "small" bins.  Large    objects are greater or equal to page size.     Pages for small objects are broken up into chunks, each of which    are described by a struct alloc_chunk.  One can walk over all    chunks on the page by adding the chunk size to the chunk's data    address.  The free space for a page exists in the free chunk bins.     Each page-entry also has a context depth, which is used to track    pushing and popping of allocation contexts.  Only objects allocated    in the current (highest-numbered) context may be collected.     Empty pages (of all sizes) are kept on a single page cache list,    and are considered first when new pages are required; they are    deallocated at the start of the next collection if they haven't    been recycled by then.  */
end_comment

begin_comment
comment|/* Define GGC_DEBUG_LEVEL to print debugging information.      0: No debugging output.      1: GC statistics only.      2: Page-entry allocations/deallocations as well.      3: Object allocations as well.      4: Object marks as well.  */
end_comment

begin_define
define|#
directive|define
name|GGC_DEBUG_LEVEL
value|(0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|CHUNK_MAGIC
value|0x95321123
end_define

begin_define
define|#
directive|define
name|DEADCHUNK_MAGIC
value|0x12817317
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure manages small chunks.  When the chunk is free, it's    linked with other chunks via free_next.  When the chunk is allocated,    the data starts at u.  Large chunks are allocated one at a time to    their own page, and so don't come in here.     The "type" field is a placeholder for a future change to do    generational collection.  At present it is 0 when free and    and 1 when allocated.  */
end_comment

begin_struct
struct|struct
name|alloc_chunk
block|{
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
name|unsigned
name|int
name|magic
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|type
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|typecode
range|:
literal|14
decl_stmt|;
name|unsigned
name|int
name|large
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|size
range|:
literal|15
decl_stmt|;
name|unsigned
name|int
name|mark
range|:
literal|1
decl_stmt|;
union|union
block|{
name|struct
name|alloc_chunk
modifier|*
name|next_free
decl_stmt|;
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* Make sure the data is sufficiently aligned.  */
name|HOST_WIDEST_INT
name|align_i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|long
name|double
name|align_d
decl_stmt|;
else|#
directive|else
name|double
name|align_d
decl_stmt|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|CHUNK_OVERHEAD
value|(offsetof (struct alloc_chunk, u))
end_define

begin_comment
comment|/* We maintain several bins of free lists for chunks for very small    objects.  We never exhaustively search other bins -- if we don't    find one of the proper size, we allocate from the "larger" bin.  */
end_comment

begin_comment
comment|/* Decreasing the number of free bins increases the time it takes to allocate.    Similar with increasing max_free_bin_size without increasing num_free_bins.     After much histogramming of allocation sizes and time spent on gc,    on a PowerPC G4 7450 - 667 mhz, and a Pentium 4 - 2.8ghz,    these were determined to be the optimal values.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FREE_BINS
value|64
end_define

begin_define
define|#
directive|define
name|MAX_FREE_BIN_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|FREE_BIN_DELTA
value|(MAX_FREE_BIN_SIZE / NUM_FREE_BINS)
end_define

begin_define
define|#
directive|define
name|SIZE_BIN_UP
parameter_list|(
name|SIZE
parameter_list|)
value|(((SIZE) + FREE_BIN_DELTA - 1) / FREE_BIN_DELTA)
end_define

begin_define
define|#
directive|define
name|SIZE_BIN_DOWN
parameter_list|(
name|SIZE
parameter_list|)
value|((SIZE) / FREE_BIN_DELTA)
end_define

begin_comment
comment|/* Marker used as chunk->size for a large object.  Should correspond    to the size of the bitfield above.  */
end_comment

begin_define
define|#
directive|define
name|LARGE_OBJECT_SIZE
value|0x7fff
end_define

begin_comment
comment|/* We use this structure to determine the alignment required for    allocations.  For power-of-two sized allocations, that's not a    problem, but it does matter for odd-sized allocations.  */
end_comment

begin_struct
struct|struct
name|max_alignment
block|{
name|char
name|c
decl_stmt|;
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|long
name|double
name|d
decl_stmt|;
else|#
directive|else
name|double
name|d
decl_stmt|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The biggest alignment required.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(offsetof (struct max_alignment, u))
end_define

begin_comment
comment|/* Compute the smallest nonnegative number which when added to X gives    a multiple of F.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP_VALUE
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|((f) - 1 - ((f) - 1 + (x)) % (f))
end_define

begin_comment
comment|/* Compute the smallest multiple of F that is>= X.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(CEIL (x, f) * (f))
end_define

begin_comment
comment|/* A page_entry records the status of an allocation page.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_entry
block|{
comment|/* The next page-entry with objects of the same size, or NULL if      this is the last page-entry.  */
name|struct
name|page_entry
modifier|*
name|next
decl_stmt|;
comment|/* The number of bytes allocated.  (This will always be a multiple      of the host system page size.)  */
name|size_t
name|bytes
decl_stmt|;
comment|/* How many collections we've survived.  */
name|size_t
name|survived
decl_stmt|;
comment|/* The address at which the memory is allocated.  */
name|char
modifier|*
name|page
decl_stmt|;
comment|/* Context depth of this page.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* Does this page contain small objects, or one large object?  */
name|bool
name|large_p
decl_stmt|;
comment|/* The zone that this page entry belongs to.  */
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
block|}
name|page_entry
typedef|;
end_typedef

begin_comment
comment|/* The global variables.  */
end_comment

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* The linked list of zones.  */
name|struct
name|alloc_zone
modifier|*
name|zones
decl_stmt|;
comment|/* The system's page size.  */
name|size_t
name|pagesize
decl_stmt|;
name|size_t
name|lg_pagesize
decl_stmt|;
comment|/* A file descriptor open to /dev/zero for reading.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP_DEV_ZERO
argument_list|)
name|int
name|dev_zero_fd
decl_stmt|;
endif|#
directive|endif
comment|/* The file descriptor for debugging output.  */
name|FILE
modifier|*
name|debug_file
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/*  The zone allocation structure.  */
end_comment

begin_struct
struct|struct
name|alloc_zone
block|{
comment|/* Name of the zone.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Linked list of pages in a zone.  */
name|page_entry
modifier|*
name|pages
decl_stmt|;
comment|/* Linked lists of free storage.  Slots 1 ... NUM_FREE_BINS have chunks of size      FREE_BIN_DELTA.  All other chunks are in slot 0.  */
name|struct
name|alloc_chunk
modifier|*
name|free_chunks
index|[
name|NUM_FREE_BINS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Bytes currently allocated.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Bytes currently allocated at the end of the last collection.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Total amount of memory mapped.  */
name|size_t
name|bytes_mapped
decl_stmt|;
comment|/* Bit N set if any allocations have been done at context depth N.  */
name|unsigned
name|long
name|context_depth_allocations
decl_stmt|;
comment|/* Bit N set if any collections have been done at context depth N.  */
name|unsigned
name|long
name|context_depth_collections
decl_stmt|;
comment|/* The current depth in the context stack.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* A cache of free system pages.  */
name|page_entry
modifier|*
name|free_pages
decl_stmt|;
comment|/* Next zone in the linked list of zones.  */
name|struct
name|alloc_zone
modifier|*
name|next_zone
decl_stmt|;
comment|/* True if this zone was collected during this collection.  */
name|bool
name|was_collected
decl_stmt|;
comment|/* True if this zone should be destroyed after the next collection.  */
name|bool
name|dead
decl_stmt|;
block|}
name|main_zone
struct|;
end_struct

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|rtl_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|garbage_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|tree_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate pages in chunks of this size, to throttle calls to memory    allocation routines.  The first page is used, the rest go onto the    free list.  This cannot be larger than HOST_BITS_PER_INT for the    in_use bitmask for page_group.  */
end_comment

begin_define
define|#
directive|define
name|GGC_QUIRE_SIZE
value|16
end_define

begin_function_decl
specifier|static
name|int
name|ggc_allocated_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|page_entry
modifier|*
name|alloc_small_page
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|page_entry
modifier|*
name|alloc_large_page
parameter_list|(
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_chunk
parameter_list|(
name|struct
name|alloc_chunk
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_page
parameter_list|(
name|struct
name|page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ggc_alloc_zone_1
parameter_list|(
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ggc_collect_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_cookies
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns nonzero if P was allocated in GC'able memory.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ggc_allocated_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|CHUNK_OVERHEAD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chunk
operator|->
name|type
operator|==
literal|1
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_comment
comment|/* Allocate SIZE bytes of anonymous memory, preferably near PREF,    (if non-null).  The ifdef structure here is intended to cause a    compile error unless exactly one of the HAVE_* is defined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
name|pref
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|G
operator|.
name|dev_zero_fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|VALGRIND_MALLOCLIKE_BLOCK
argument_list|(
name|page
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
operator|(
name|char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|zone
operator|->
name|bytes_mapped
operator|+=
name|size
expr_stmt|;
comment|/* Pretend we don't have access to the allocated pages.  We'll enable      access to smaller pieces of the area in ggc_alloc.  Discard the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|page
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a new page for allocating objects of size 2^ORDER,    and return an entry for it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|page_entry
modifier|*
name|alloc_small_page
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|NULL
expr_stmt|;
comment|/* Check the list of free pages for one we can use.  */
name|entry
operator|=
name|zone
operator|->
name|free_pages
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* Recycle the allocated memory from this page ...  */
name|zone
operator|->
name|free_pages
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|page
operator|=
name|entry
operator|->
name|page
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USING_MMAP
else|else
block|{
comment|/* We want just one page.  Allocate a bunch of them and put the 	 extras on the freelist.  (Can only do this optimization with 	 mmap for backing store.)  */
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|zone
operator|->
name|free_pages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
operator|*
name|GGC_QUIRE_SIZE
argument_list|,
name|zone
argument_list|)
expr_stmt|;
comment|/* This loop counts down so that the chain will be in ascending 	 memory order.  */
for|for
control|(
name|i
operator|=
name|GGC_QUIRE_SIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|e
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|page
operator|+
operator|(
name|i
operator|<<
name|G
operator|.
name|lg_pagesize
operator|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
block|}
name|zone
operator|->
name|free_pages
operator|=
name|f
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|page
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
name|zone
operator|->
name|context_depth
expr_stmt|;
name|entry
operator|->
name|large_p
operator|=
name|false
expr_stmt|;
name|entry
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|zone
operator|->
name|context_depth_allocations
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|zone
operator|->
name|context_depth
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating %s page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|page
argument_list|,
name|page
operator|+
name|G
operator|.
name|pagesize
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Compute the smallest multiple of F that is>= X.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(CEIL (x, f) * (f))
end_define

begin_comment
comment|/* Allocate a large page of size SIZE in ZONE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|page_entry
modifier|*
name|alloc_large_page
parameter_list|(
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
name|CHUNK_OVERHEAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
operator|(
name|page
operator|+
name|size
operator|+
name|CHUNK_OVERHEAD
operator|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|page
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
name|zone
operator|->
name|context_depth
expr_stmt|;
name|entry
operator|->
name|large_p
operator|=
name|true
expr_stmt|;
name|entry
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|zone
operator|->
name|context_depth_allocations
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|zone
operator|->
name|context_depth
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating %s large page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|page
argument_list|,
name|page
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* For a page that is no longer needed, put it on the free page list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_page
parameter_list|(
name|page_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating %s page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|page
operator|+
name|entry
operator|->
name|bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|large_p
condition|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|page
argument_list|)
expr_stmt|;
name|VALGRIND_FREELIKE_BLOCK
argument_list|(
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark the page as inaccessible.  Discard the handle to 	 avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|zone
operator|->
name|free_pages
expr_stmt|;
name|entry
operator|->
name|zone
operator|->
name|free_pages
operator|=
name|entry
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release the free page cache to the system.  */
end_comment

begin_function
specifier|static
name|void
name|release_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USING_MMAP
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Gather up adjacent pages so they are unmapped together.  */
name|p
operator|=
name|zone
operator|->
name|free_pages
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|start
operator|=
name|p
operator|->
name|page
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|page
operator|==
name|start
operator|+
name|len
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|+=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|munmap
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|zone
operator|->
name|bytes_mapped
operator|-=
name|len
expr_stmt|;
block|}
name|zone
operator|->
name|free_pages
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Place CHUNK of size SIZE on the free list for ZONE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_chunk
parameter_list|(
name|struct
name|alloc_chunk
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|size_t
name|bin
init|=
literal|0
decl_stmt|;
name|bin
operator|=
name|SIZE_BIN_DOWN
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bin
operator|>
name|NUM_FREE_BINS
condition|)
name|bin
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
operator|&&
name|chunk
operator|->
name|magic
operator|!=
name|DEADCHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
name|chunk
operator|->
name|magic
operator|=
name|DEADCHUNK_MAGIC
expr_stmt|;
endif|#
directive|endif
name|chunk
operator|->
name|u
operator|.
name|next_free
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
expr_stmt|;
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
operator|=
name|chunk
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating object, chunk=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|)
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_READABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a chunk of memory of SIZE bytes.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ggc_alloc_zone_1
parameter_list|(
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|size_t
name|bin
init|=
literal|0
decl_stmt|;
name|size_t
name|lsize
init|=
literal|0
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|lchunk
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
comment|/* Align size, so that we're assured of aligned allocations.  */
if|if
condition|(
name|size
operator|<
name|FREE_BIN_DELTA
condition|)
name|size
operator|=
name|FREE_BIN_DELTA
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|MAX_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|MAX_ALIGNMENT
expr_stmt|;
comment|/* Large objects are handled specially.  */
if|if
condition|(
name|size
operator|>=
name|G
operator|.
name|pagesize
operator|-
literal|2
operator|*
name|CHUNK_OVERHEAD
operator|-
name|FREE_BIN_DELTA
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|entry
operator|=
name|alloc_large_page
argument_list|(
name|size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|entry
operator|->
name|survived
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|zone
operator|->
name|pages
expr_stmt|;
name|entry
operator|->
name|zone
operator|->
name|pages
operator|=
name|entry
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|entry
operator|->
name|page
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|large
operator|=
literal|1
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* First look for a tiny object already segregated into its own      size bucket.  */
name|bin
operator|=
name|SIZE_BIN_UP
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|<=
name|NUM_FREE_BINS
condition|)
block|{
name|chunk
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
expr_stmt|;
if|if
condition|(
name|chunk
condition|)
block|{
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
operator|=
name|chunk
operator|->
name|u
operator|.
name|next_free
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* Failing that, look through the "other" bucket for a chunk      that is large enough.  */
name|pp
operator|=
operator|&
operator|(
name|zone
operator|->
name|free_chunks
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|chunk
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|chunk
operator|&&
name|chunk
operator|->
name|size
operator|<
name|size
condition|)
block|{
name|pp
operator|=
operator|&
name|chunk
operator|->
name|u
operator|.
name|next_free
expr_stmt|;
name|chunk
operator|=
operator|*
name|pp
expr_stmt|;
block|}
comment|/* Failing that, allocate new storage.  */
if|if
condition|(
operator|!
name|chunk
condition|)
block|{
name|entry
operator|=
name|alloc_small_page
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|zone
operator|->
name|pages
expr_stmt|;
name|entry
operator|->
name|zone
operator|->
name|pages
operator|=
name|entry
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|entry
operator|->
name|page
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|G
operator|.
name|pagesize
operator|-
name|CHUNK_OVERHEAD
expr_stmt|;
name|chunk
operator|->
name|large
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|=
name|chunk
operator|->
name|u
operator|.
name|next_free
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|large
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Release extra memory from a chunk that's too big.  */
name|lsize
operator|=
name|chunk
operator|->
name|size
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|lsize
operator|>=
name|CHUNK_OVERHEAD
operator|+
name|FREE_BIN_DELTA
condition|)
block|{
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|lsize
operator|-=
name|CHUNK_OVERHEAD
expr_stmt|;
name|lchunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|size
operator|)
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|lchunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
name|lchunk
operator|->
name|magic
operator|=
name|CHUNK_MAGIC
expr_stmt|;
endif|#
directive|endif
name|lchunk
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|lchunk
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|lchunk
operator|->
name|size
operator|=
name|lsize
expr_stmt|;
name|lchunk
operator|->
name|large
operator|=
literal|0
expr_stmt|;
name|free_chunk
argument_list|(
name|lchunk
argument_list|,
name|lsize
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the object's address.  */
name|found
label|:
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
name|chunk
operator|->
name|magic
operator|=
name|CHUNK_MAGIC
expr_stmt|;
endif|#
directive|endif
name|chunk
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|chunk
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|typecode
operator|=
name|type
expr_stmt|;
name|result
operator|=
name|chunk
operator|->
name|u
operator|.
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the      exact same semantics in presence of memory bugs, regardless of      ENABLE_VALGRIND_CHECKING.  We override this request below.  Drop the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `Poison' the entire allocated object.  */
name|memset
argument_list|(
name|result
argument_list|,
literal|0xaf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell Valgrind that the memory is there, but its content isn't      defined.  The bytes at the end of the object are still marked      unaccessible.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of how many bytes are being allocated.  This      information is used in deciding when to collect.  */
name|zone
operator|->
name|allocated
operator|+=
name|size
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating object, chunk=%p size=%lu at %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Allocate a SIZE of chunk memory of GTE type, into an appropriate zone    for that type.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_typed
parameter_list|(
name|enum
name|gt_types_enum
name|gte
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|gte
condition|)
block|{
case|case
name|gt_ggc_e_14lang_tree_node
case|:
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
name|tree_zone
argument_list|,
name|gte
argument_list|)
return|;
case|case
name|gt_ggc_e_7rtx_def
case|:
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
name|rtl_zone
argument_list|,
name|gte
argument_list|)
return|;
case|case
name|gt_ggc_e_9rtvec_def
case|:
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
name|rtl_zone
argument_list|,
name|gte
argument_list|)
return|;
default|default:
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
operator|&
name|main_zone
argument_list|,
name|gte
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Normal ggc_alloc simply allocates into the main zone.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
operator|&
name|main_zone
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Zone allocation allocates into the specified zone.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_zone
parameter_list|(
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
return|return
name|ggc_alloc_zone_1
argument_list|(
name|size
argument_list|,
name|zone
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If P is not marked, mark it and return false.  Otherwise return true.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|CHUNK_OVERHEAD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chunk
operator|->
name|mark
condition|)
return|return
literal|1
return|;
name|chunk
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Marking %p\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|CHUNK_OVERHEAD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|chunk
operator|->
name|mark
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|CHUNK_OVERHEAD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chunk
operator|->
name|large
condition|)
return|return
name|chunk
operator|->
name|size
operator|*
literal|1024
return|;
return|return
name|chunk
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Initialize the ggc-zone-mmap allocator.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up the main zone by hand.  */
name|main_zone
operator|.
name|name
operator|=
literal|"Main zone"
expr_stmt|;
name|G
operator|.
name|zones
operator|=
operator|&
name|main_zone
expr_stmt|;
comment|/* Allocate the default zones.  */
name|rtl_zone
operator|=
name|new_ggc_zone
argument_list|(
literal|"RTL zone"
argument_list|)
expr_stmt|;
name|tree_zone
operator|=
name|new_ggc_zone
argument_list|(
literal|"Tree zone"
argument_list|)
expr_stmt|;
name|garbage_zone
operator|=
name|new_ggc_zone
argument_list|(
literal|"Garbage zone"
argument_list|)
expr_stmt|;
name|G
operator|.
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|G
operator|.
name|lg_pagesize
operator|=
name|exact_log2
argument_list|(
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|G
operator|.
name|dev_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|dev_zero_fd
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|G.debug_file = fopen ("ggc-mmap.debug", "w");   setlinebuf (G.debug_file);
else|#
directive|else
name|G
operator|.
name|debug_file
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MMAP
comment|/* StunOS has an amazing off-by-one error for the first mmap allocation      after fiddling with RLIMIT_STACK.  The result, as hard as it is to      believe, is an unaligned page allocation, which would cause us to      hork badly if we tried to use it.  */
block|{
name|char
modifier|*
name|p
init|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|,
operator|&
name|main_zone
argument_list|)
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* How losing.  Discard this one and try another.  If we still 	   can't get something useful, give up.  */
name|p
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|,
operator|&
name|main_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We have a good page, might as well hold onto it...  */
name|e
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|p
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|main_zone
operator|.
name|free_pages
expr_stmt|;
name|main_zone
operator|.
name|free_pages
operator|=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Start a new GGC zone.  */
end_comment

begin_function
name|struct
name|alloc_zone
modifier|*
name|new_ggc_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|new_zone
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_zone
argument_list|)
argument_list|)
decl_stmt|;
name|new_zone
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new_zone
operator|->
name|next_zone
operator|=
name|G
operator|.
name|zones
operator|->
name|next_zone
expr_stmt|;
name|G
operator|.
name|zones
operator|->
name|next_zone
operator|=
name|new_zone
expr_stmt|;
return|return
name|new_zone
return|;
block|}
end_function

begin_comment
comment|/* Destroy a GGC zone.  */
end_comment

begin_function
name|void
name|destroy_ggc_zone
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|dead_zone
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|z
decl_stmt|;
for|for
control|(
name|z
operator|=
name|G
operator|.
name|zones
init|;
name|z
operator|&&
name|z
operator|->
name|next_zone
operator|!=
name|dead_zone
condition|;
name|z
operator|=
name|z
operator|->
name|next_zone
control|)
comment|/* Just find that zone.  */
empty_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* We should have found the zone in the list.  Anything else is fatal.  */
if|if
condition|(
operator|!
name|z
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* z is dead, baby. z is dead.  */
name|z
operator|->
name|dead
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Increment the `GC context'.  Objects allocated in an outer context    are never freed, eliminating the need to register their roots.  */
end_comment

begin_function
name|void
name|ggc_push_context
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
operator|++
operator|(
name|zone
operator|->
name|context_depth
operator|)
expr_stmt|;
comment|/* Die on wrap.  */
if|if
condition|(
name|main_zone
operator|.
name|context_depth
operator|>=
name|HOST_BITS_PER_LONG
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decrement the `GC context'.  All objects allocated since the    previous ggc_push_context are migrated to the outer context.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_pop_context_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|unsigned
name|long
name|omask
decl_stmt|;
name|unsigned
name|depth
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|;
name|depth
operator|=
operator|--
operator|(
name|zone
operator|->
name|context_depth
operator|)
expr_stmt|;
name|omask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|depth
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|zone
operator|->
name|context_depth_allocations
operator||
name|zone
operator|->
name|context_depth_collections
operator|)
operator|&
name|omask
operator|)
condition|)
return|return;
name|zone
operator|->
name|context_depth_allocations
operator||=
operator|(
name|zone
operator|->
name|context_depth_allocations
operator|&
name|omask
operator|)
operator|>>
literal|1
expr_stmt|;
name|zone
operator|->
name|context_depth_allocations
operator|&=
name|omask
operator|-
literal|1
expr_stmt|;
name|zone
operator|->
name|context_depth_collections
operator|&=
name|omask
operator|-
literal|1
expr_stmt|;
comment|/* Any remaining pages in the popped context are lowered to the new      current context; i.e. objects allocated in the popped context and      left over are imported into the previous context.  */
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|context_depth
operator|>
name|depth
condition|)
name|p
operator|->
name|context_depth
operator|=
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop all the zone contexts.  */
end_comment

begin_function
name|void
name|ggc_pop_context
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
name|ggc_pop_context_1
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Poison the chunk.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|poison_chunk
parameter_list|(
name|CHUNK
parameter_list|,
name|SIZE
parameter_list|)
define|\
value|memset ((CHUNK)->u.data, 0xa5, (SIZE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|poison_chunk
parameter_list|(
name|CHUNK
parameter_list|,
name|SIZE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free all empty pages and objects within a page for a given zone  */
end_comment

begin_function
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|last_free
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|last_free_size
decl_stmt|,
name|allocated
init|=
literal|0
decl_stmt|;
name|bool
name|nomarksinpage
decl_stmt|;
comment|/* First, reset the free_chunks lists, since we are going to      re-free free chunks in hopes of coalescing them into large chunks.  */
name|memset
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|zone
operator|->
name|pages
expr_stmt|;
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Large pages are all or none affairs. Either they are 	 completely empty, or they are completely full. 	  	 XXX: Should we bother to increment allocated.  */
if|if
condition|(
name|p
operator|->
name|large_p
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
operator|)
operator|->
name|mark
operator|==
literal|1
condition|)
block|{
operator|(
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
operator|)
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|=
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Poison the page.  */
name|memset
argument_list|(
name|p
operator|->
name|page
argument_list|,
literal|0xb5
argument_list|,
name|p
operator|->
name|bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* This page has now survived another collection.  */
name|p
operator|->
name|survived
operator|++
expr_stmt|;
comment|/* Which leaves full and partial pages.  Step through all chunks, 	 consolidate those that are free and insert them into the free 	 lists.  Note that consolidation slows down collection 	 slightly.  */
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
expr_stmt|;
name|end
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|p
operator|->
name|page
operator|+
name|G
operator|.
name|pagesize
operator|)
expr_stmt|;
name|last_free
operator|=
name|NULL
expr_stmt|;
name|last_free_size
operator|=
literal|0
expr_stmt|;
name|nomarksinpage
operator|=
name|true
expr_stmt|;
do|do
block|{
name|prefetch
argument_list|(
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|chunk
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|mark
operator|||
name|p
operator|->
name|context_depth
operator|<
name|zone
operator|->
name|context_depth
condition|)
block|{
name|nomarksinpage
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|last_free
condition|)
block|{
name|last_free
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|last_free
operator|->
name|size
operator|=
name|last_free_size
expr_stmt|;
name|last_free
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|poison_chunk
argument_list|(
name|last_free
argument_list|,
name|last_free_size
argument_list|)
expr_stmt|;
name|free_chunk
argument_list|(
name|last_free
argument_list|,
name|last_free_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|last_free
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chunk
operator|->
name|mark
condition|)
block|{
name|allocated
operator|+=
name|chunk
operator|->
name|size
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
block|}
name|chunk
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|last_free
condition|)
block|{
name|last_free_size
operator|+=
name|CHUNK_OVERHEAD
operator|+
name|chunk
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|last_free
operator|=
name|chunk
expr_stmt|;
name|last_free_size
operator|=
name|chunk
operator|->
name|size
expr_stmt|;
block|}
block|}
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|chunk
operator|->
name|size
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|chunk
operator|<
name|end
condition|)
do|;
if|if
condition|(
name|nomarksinpage
condition|)
block|{
operator|*
name|pp
operator|=
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Poison the page.  */
name|memset
argument_list|(
name|p
operator|->
name|page
argument_list|,
literal|0xb5
argument_list|,
name|p
operator|->
name|bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|last_free
condition|)
block|{
name|last_free
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|last_free
operator|->
name|size
operator|=
name|last_free_size
expr_stmt|;
name|last_free
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|poison_chunk
argument_list|(
name|last_free
argument_list|,
name|last_free_size
argument_list|)
expr_stmt|;
name|free_chunk
argument_list|(
name|last_free
argument_list|,
name|last_free_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
name|zone
operator|->
name|allocated
operator|=
name|allocated
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mark-and-sweep routine for collecting a single zone.  NEED_MARKING    is true if we need to mark before sweeping, false if some other    zone collection has already performed marking for us.  Returns true    if we collected, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|ggc_collect_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|,
name|bool
name|need_marking
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zone
operator|->
name|dead
condition|)
block|{
comment|/* Avoid frequent unnecessary work by skipping collection if the 	 total allocations haven't expanded much since the last 	 collection.  */
name|float
name|allocated_last_gc
init|=
name|MAX
argument_list|(
name|zone
operator|->
name|allocated_last_gc
argument_list|,
operator|(
name|size_t
operator|)
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|float
name|min_expand
init|=
name|allocated_last_gc
operator|*
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|allocated
operator|<
name|allocated_last_gc
operator|+
name|min_expand
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {%s GC %luk -> "
argument_list|,
name|zone
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zone
operator|->
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* Zero the total allocated bytes.  This will be recalculated in the      sweep phase.  */
name|zone
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* Release the pages we freed the last time we collected, but didn't      reuse in the interim.  */
name|release_pages
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Indicate that we've seen collections at this context depth.  */
name|zone
operator|->
name|context_depth_collections
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|zone
operator|->
name|context_depth
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|need_marking
condition|)
name|ggc_mark_roots
argument_list|()
expr_stmt|;
name|sweep_pages
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|was_collected
operator|=
name|true
expr_stmt|;
name|zone
operator|->
name|allocated_last_gc
operator|=
name|zone
operator|->
name|allocated
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zone
operator|->
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Calculate the average page survival rate in terms of number of    collections.  */
end_comment

begin_function
specifier|static
name|float
name|calculate_average_page_survival
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|float
name|count
init|=
literal|0.0
decl_stmt|;
name|float
name|survival
init|=
literal|0.0
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|count
operator|+=
literal|1.0
expr_stmt|;
name|survival
operator|+=
name|p
operator|->
name|survived
expr_stmt|;
block|}
return|return
name|survival
operator|/
name|count
return|;
block|}
end_function

begin_comment
comment|/* Check the magic cookies all of the chunks contain, to make sure we    aren't doing anything stupid, like stomping on alloc_chunk    structures.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|check_cookies
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|COOKIE_CHECKING
name|page_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|large_p
condition|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
decl_stmt|;
name|struct
name|alloc_chunk
modifier|*
name|end
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|p
operator|->
name|page
operator|+
name|G
operator|.
name|pagesize
operator|)
decl_stmt|;
do|do
block|{
if|if
condition|(
name|chunk
operator|->
name|magic
operator|!=
name|CHUNK_MAGIC
operator|&&
name|chunk
operator|->
name|magic
operator|!=
name|DEADCHUNK_MAGIC
condition|)
name|abort
argument_list|()
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|chunk
operator|->
name|size
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|chunk
operator|<
name|end
condition|)
do|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Top level collection routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
name|bool
name|marked
init|=
name|false
decl_stmt|;
name|float
name|f
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
name|check_cookies
argument_list|()
expr_stmt|;
comment|/* Start by possibly collecting the main zone.  */
name|main_zone
operator|.
name|was_collected
operator|=
name|false
expr_stmt|;
name|marked
operator||=
name|ggc_collect_1
argument_list|(
operator|&
name|main_zone
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* In order to keep the number of collections down, we don't      collect other zones unless we are collecting the main zone.  This      gives us roughly the same number of collections as we used to      have with the old gc.  The number of collection is important      because our main slowdown (according to profiling) is now in      marking.  So if we mark twice as often as we used to, we'll be      twice as slow.  Hopefully we'll avoid this cost when we mark      zone-at-a-time.  */
if|if
condition|(
name|main_zone
operator|.
name|was_collected
condition|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|main_zone
operator|.
name|next_zone
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|check_cookies
argument_list|()
expr_stmt|;
name|zone
operator|->
name|was_collected
operator|=
name|false
expr_stmt|;
name|marked
operator||=
name|ggc_collect_1
argument_list|(
name|zone
argument_list|,
operator|!
name|marked
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print page survival stats, if someone wants them.  */
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
if|if
condition|(
name|zone
operator|->
name|was_collected
condition|)
block|{
name|f
operator|=
name|calculate_average_page_survival
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Average page survival in zone `%s' is %f\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Since we don't mark zone at a time right now, marking in any      zone means marking in every zone. So we have to clear all the      marks in all the zones that weren't collected already.  */
if|if
condition|(
name|marked
condition|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
if|if
condition|(
name|zone
operator|->
name|was_collected
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|large_p
condition|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
decl_stmt|;
name|struct
name|alloc_chunk
modifier|*
name|end
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|p
operator|->
name|page
operator|+
name|G
operator|.
name|pagesize
operator|)
decl_stmt|;
do|do
block|{
name|prefetch
argument_list|(
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|chunk
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|mark
operator|||
name|p
operator|->
name|context_depth
operator|<
name|zone
operator|->
name|context_depth
condition|)
block|{
name|chunk
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
name|chunk
operator|->
name|u
operator|.
name|data
operator|+
name|chunk
operator|->
name|size
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|chunk
operator|<
name|end
condition|)
do|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|p
operator|->
name|page
operator|)
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Free dead zones.  */
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
operator|&&
name|zone
operator|->
name|next_zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
if|if
condition|(
name|zone
operator|->
name|next_zone
operator|->
name|dead
condition|)
block|{
name|struct
name|alloc_zone
modifier|*
name|dead_zone
init|=
name|zone
operator|->
name|next_zone
decl_stmt|;
name|printf
argument_list|(
literal|"Zone `%s' is dead and will be freed.\n"
argument_list|,
name|dead_zone
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* The zone must be empty.  */
if|if
condition|(
name|dead_zone
operator|->
name|allocated
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Unchain the dead zone, release all its pages and free it.  */
name|zone
operator|->
name|next_zone
operator|=
name|zone
operator|->
name|next_zone
operator|->
name|next_zone
expr_stmt|;
name|release_pages
argument_list|(
name|dead_zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dead_zone
argument_list|)
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print allocation statistics.  */
end_comment

begin_function
name|void
name|ggc_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_struct
struct|struct
name|ggc_pch_data
block|{
struct|struct
name|ggc_pch_ondisk
block|{
name|unsigned
name|total
decl_stmt|;
block|}
name|d
struct|;
name|size_t
name|base
decl_stmt|;
name|size_t
name|written
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize the PCH datastructure.  */
end_comment

begin_function
name|struct
name|ggc_pch_data
modifier|*
name|init_ggc_pch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ggc_pch_data
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add the size of object X to the size of the PCH data.  */
end_comment

begin_function
name|void
name|ggc_pch_count_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_string
condition|)
block|{
name|d
operator|->
name|d
operator|.
name|total
operator|+=
name|size
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
block|}
else|else
name|d
operator|->
name|d
operator|.
name|total
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the total size of the PCH data.  */
end_comment

begin_function
name|size_t
name|ggc_pch_total_size
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|)
block|{
return|return
name|d
operator|->
name|d
operator|.
name|total
return|;
block|}
end_function

begin_comment
comment|/* Set the base address for the objects in the PCH file.  */
end_comment

begin_function
name|void
name|ggc_pch_this_base
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|base
parameter_list|)
block|{
name|d
operator|->
name|base
operator|=
operator|(
name|size_t
operator|)
name|base
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a place for object X of size SIZE in the PCH file.  */
end_comment

begin_function
name|char
modifier|*
name|ggc_pch_alloc_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|is_string
condition|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|x
operator|-
name|CHUNK_OVERHEAD
operator|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|->
name|large
condition|)
name|d
operator|->
name|base
operator|+=
name|ggc_get_size
argument_list|(
name|x
argument_list|)
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
else|else
name|d
operator|->
name|base
operator|+=
name|chunk
operator|->
name|size
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
return|return
name|result
operator|+
name|CHUNK_OVERHEAD
return|;
block|}
else|else
block|{
name|d
operator|->
name|base
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare to write out the PCH data to file F.  */
end_comment

begin_function
name|void
name|ggc_pch_prepare_write
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Nothing to do.  */
block|}
end_function

begin_comment
comment|/* Write out object X of SIZE to file F.  */
end_comment

begin_function
name|void
name|ggc_pch_write_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|newx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_string
condition|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|x
operator|-
name|CHUNK_OVERHEAD
operator|)
decl_stmt|;
name|size
operator|=
name|ggc_get_size
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|chunk
argument_list|,
name|size
operator|+
name|CHUNK_OVERHEAD
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
name|d
operator|->
name|written
operator|+=
name|size
operator|+
name|CHUNK_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
name|d
operator|->
name|written
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|written
operator|==
name|d
operator|->
name|d
operator|.
name|total
operator|&&
name|fseek
argument_list|(
name|f
argument_list|,
name|ROUND_UP_VALUE
argument_list|(
name|d
operator|->
name|d
operator|.
name|total
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ggc_pch_finish
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|d
operator|->
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ggc_pch_read
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ggc_pch_ondisk
name|d
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|alloc_zone
modifier|*
name|pch_zone
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|d
operator|.
name|total
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|addr
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
literal|0
expr_stmt|;
name|pch_zone
operator|=
name|new_ggc_zone
argument_list|(
literal|"PCH zone"
argument_list|)
expr_stmt|;
name|entry
operator|->
name|zone
operator|=
name|pch_zone
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|zone
operator|->
name|pages
expr_stmt|;
name|entry
operator|->
name|zone
operator|->
name|pages
operator|=
name|entry
expr_stmt|;
block|}
end_function

end_unit

