begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library - traditional lexical analysis and macro expansion.    Copyright (C) 2002, 2004 Free Software Foundation, Inc.    Contributed by Neil Booth, May 2002  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_comment
comment|/* The replacement text of a function-like macro is stored as a    contiguous sequence of aligned blocks, each representing the text    between subsequent parameters.     Each block comprises the text between its surrounding parameters,    the length of that text, and the one-based index of the following    parameter.  The final block in the replacement text is easily    recognizable as it has an argument index of zero.  */
end_comment

begin_struct
struct|struct
name|block
block|{
name|unsigned
name|int
name|text_len
decl_stmt|;
name|unsigned
name|short
name|arg_index
decl_stmt|;
name|uchar
name|text
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BLOCK_HEADER_LEN
value|offsetof (struct block, text)
end_define

begin_define
define|#
directive|define
name|BLOCK_LEN
parameter_list|(
name|TEXT_LEN
parameter_list|)
value|CPP_ALIGN (BLOCK_HEADER_LEN + (TEXT_LEN))
end_define

begin_comment
comment|/* Structure holding information about a function-like macro    invocation.  */
end_comment

begin_struct
struct|struct
name|fun_macro
block|{
comment|/* Memory buffer holding the trad_arg array.  */
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
comment|/* An array of size the number of macro parameters + 1, containing      the offsets of the start of each macro argument in the output      buffer.  The argument continues until the character before the      start of the next one.  */
name|size_t
modifier|*
name|args
decl_stmt|;
comment|/* The hashnode of the macro.  */
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
comment|/* The offset of the macro name in the output buffer.  */
name|size_t
name|offset
decl_stmt|;
comment|/* The line the macro name appeared on.  */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Zero-based index of argument being currently lexed.  */
name|unsigned
name|int
name|argc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lexing state.  It is mostly used to prevent macro expansion.  */
end_comment

begin_enum
enum|enum
name|ls
block|{
name|ls_none
init|=
literal|0
block|,
comment|/* Normal state.  */
name|ls_fun_open
block|,
comment|/* When looking for '('.  */
name|ls_fun_close
block|,
comment|/* When looking for ')'.  */
name|ls_defined
block|,
comment|/* After defined.  */
name|ls_defined_close
block|,
comment|/* Looking for ')' of defined().  */
name|ls_hash
block|,
comment|/* After # in preprocessor conditional.  */
name|ls_predicate
block|,
comment|/* After the predicate, maybe paren?  */
name|ls_answer
block|}
enum|;
end_enum

begin_comment
comment|/* In answer to predicate.  */
end_comment

begin_comment
comment|/* Lexing TODO: Maybe handle space in escaped newlines.  Stop cpplex.c    from recognizing comments and directives during its lexing pass.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|uchar
modifier|*
name|skip_whitespace
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_hashnode
modifier|*
name|lex_identifier
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|uchar
modifier|*
name|copy_comment
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_output_buffer
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_replacement_text
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|scan_parameters
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|recursive_macro
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_replacement_text
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_start_funlike
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|struct
name|fun_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_argument
parameter_list|(
name|struct
name|fun_macro
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_args_and_push
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|struct
name|fun_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|canonicalize_text
parameter_list|(
name|uchar
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Ensures we have N bytes' space in the output buffer, and    reallocates it if not.  */
end_comment

begin_function
specifier|static
name|void
name|check_output_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
comment|/* We might need two bytes to terminate an unterminated comment, and      one more to terminate the line with a NUL.  */
name|n
operator|+=
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
call|(
name|size_t
call|)
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|limit
operator|-
name|pfile
operator|->
name|out
operator|.
name|cur
argument_list|)
condition|)
block|{
name|size_t
name|size
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
decl_stmt|;
name|size_t
name|new_size
init|=
operator|(
name|size
operator|+
name|n
operator|)
operator|*
literal|3
operator|/
literal|2
decl_stmt|;
name|pfile
operator|->
name|out
operator|.
name|base
operator|=
name|xrealloc
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|limit
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|new_size
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip a C-style block comment in a macro as a result of -CC.    Buffer->cur points to the initial asterisk of the comment.  */
end_comment

begin_function
specifier|static
name|void
name|skip_macro_block_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|cur
init|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
decl_stmt|;
name|cur
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
condition|)
name|cur
operator|++
expr_stmt|;
comment|/* People like decorating comments with '*', so check for '/'      instead for efficiency.  */
while|while
condition|(
operator|!
operator|(
operator|*
name|cur
operator|++
operator|==
literal|'/'
operator|&&
name|cur
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|)
condition|)
empty_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CUR points to the asterisk introducing a comment in the current    context.  IN_DEFINE is true if we are in the replacement text of a    macro.     The asterisk and following comment is copied to the buffer pointed    to by pfile->out.cur, which must be of sufficient size.    Unterminated comments are diagnosed, and correctly terminated in    the output.  pfile->out.cur is updated depending upon IN_DEFINE,    -C, -CC and pfile->state.in_directive.     Returns a pointer to the first character after the comment in the    input buffer.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|copy_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|cur
parameter_list|,
name|int
name|in_define
parameter_list|)
block|{
name|bool
name|unterminated
decl_stmt|,
name|copy
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|from_line
init|=
name|pfile
operator|->
name|line
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|prev
condition|)
name|unterminated
operator|=
name|false
operator|,
name|skip_macro_block_comment
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
name|unterminated
operator|=
name|_cpp_skip_block_comment
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|unterminated
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|from_line
argument_list|,
literal|0
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
comment|/* Comments in directives become spaces so that tokens are properly      separated when the ISO preprocessor re-lexes the line.  The      exception is #define.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
block|{
if|if
condition|(
name|in_define
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
condition|)
name|pfile
operator|->
name|out
operator|.
name|cur
operator|--
expr_stmt|;
else|else
name|copy
operator|=
name|true
expr_stmt|;
block|}
else|else
name|pfile
operator|->
name|out
operator|.
name|cur
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
condition|)
name|pfile
operator|->
name|out
operator|.
name|cur
operator|--
expr_stmt|;
else|else
name|copy
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
name|size_t
name|len
init|=
call|(
name|size_t
call|)
argument_list|(
name|buffer
operator|->
name|cur
operator|-
name|cur
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|cur
argument_list|,
name|cur
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|unterminated
condition|)
block|{
operator|*
name|pfile
operator|->
name|out
operator|.
name|cur
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|pfile
operator|->
name|out
operator|.
name|cur
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
return|return
name|buffer
operator|->
name|cur
return|;
block|}
end_function

begin_comment
comment|/* CUR points to any character in the input buffer.  Skips over all    contiguous horizontal white space and NULs, including comments if    SKIP_COMMENTS, until reaching the first non-horizontal-whitespace    character or the end of the current context.  Escaped newlines are    removed.     The whitespace is copied verbatim to the output buffer, except that    comments are handled as described in copy_comment().    pfile->out.cur is updated.     Returns a pointer to the first character after the whitespace in    the input buffer.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|skip_whitespace
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|cur
parameter_list|,
name|int
name|skip_comments
parameter_list|)
block|{
name|uchar
modifier|*
name|out
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|cur
operator|++
decl_stmt|;
operator|*
name|out
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|is_nvspace
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|*
name|cur
operator|==
literal|'*'
operator|&&
name|skip_comments
condition|)
block|{
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
expr_stmt|;
name|cur
operator|=
name|copy_comment
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|,
name|false
comment|/* in_define */
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
continue|continue;
block|}
name|out
operator|--
expr_stmt|;
break|break;
block|}
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
expr_stmt|;
return|return
name|cur
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Lexes and outputs an identifier starting at CUR, which is assumed    to point to a valid first character of an identifier.  Returns    the hashnode, and updates out.cur.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|lex_identifier
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|cur
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|uchar
modifier|*
name|out
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
decl_stmt|;
name|cpp_hashnode
modifier|*
name|result
decl_stmt|;
do|do
operator|*
name|out
operator|++
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
do|while
condition|(
name|is_numchar
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
do|;
name|CUR
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|=
name|cur
expr_stmt|;
name|len
operator|=
name|out
operator|-
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
name|result
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|)
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|cur
argument_list|,
name|len
argument_list|,
name|HT_ALLOC
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Overlays the true file buffer temporarily with text of length LEN    starting at START.  The true buffer is restored upon calling    restore_buff().  */
end_comment

begin_function
name|void
name|_cpp_overlay_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|start
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|pfile
operator|->
name|overlaid_buffer
operator|=
name|buffer
expr_stmt|;
name|buffer
operator|->
name|saved_cur
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|buffer
operator|->
name|saved_rlimit
operator|=
name|buffer
operator|->
name|rlimit
expr_stmt|;
comment|/* Prevent the ISO lexer from scanning a fresh line.  */
name|pfile
operator|->
name|saved_line
operator|=
name|pfile
operator|->
name|line
operator|--
expr_stmt|;
name|buffer
operator|->
name|need_line
operator|=
name|false
expr_stmt|;
name|buffer
operator|->
name|cur
operator|=
name|start
expr_stmt|;
name|buffer
operator|->
name|rlimit
operator|=
name|start
operator|+
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restores a buffer overlaid by _cpp_overlay_buffer().  */
end_comment

begin_function
name|void
name|_cpp_remove_overlay
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|overlaid_buffer
decl_stmt|;
name|buffer
operator|->
name|cur
operator|=
name|buffer
operator|->
name|saved_cur
expr_stmt|;
name|buffer
operator|->
name|rlimit
operator|=
name|buffer
operator|->
name|saved_rlimit
expr_stmt|;
name|buffer
operator|->
name|need_line
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|overlaid_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|line
operator|=
name|pfile
operator|->
name|saved_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reads a logical line into the output buffer.  Returns TRUE if there    is more text left in the buffer.  */
end_comment

begin_function
name|bool
name|_cpp_read_logical_line_trad
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|need_line
operator|&&
operator|!
name|_cpp_get_fresh_line
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
name|false
return|;
block|}
do|while
condition|(
operator|!
name|_cpp_scan_out_logical_line
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
operator|||
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
do|;
return|return
name|pfile
operator|->
name|buffer
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set up state for finding the opening '(' of a function-like    macro.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_start_funlike
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
specifier|const
name|uchar
modifier|*
name|start
parameter_list|,
name|struct
name|fun_macro
modifier|*
name|macro
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|paramc
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|buff
condition|)
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|macro
operator|->
name|buff
argument_list|)
expr_stmt|;
name|macro
operator|->
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|macro
operator|->
name|args
operator|=
operator|(
name|size_t
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|macro
operator|->
name|buff
argument_list|)
expr_stmt|;
name|macro
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|macro
operator|->
name|offset
operator|=
name|start
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
name|macro
operator|->
name|argc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the OFFSET of the start of the next argument to MACRO.  */
end_comment

begin_function
specifier|static
name|void
name|save_argument
parameter_list|(
name|struct
name|fun_macro
modifier|*
name|macro
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|macro
operator|->
name|argc
operator|++
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|argc
operator|<=
name|macro
operator|->
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|paramc
condition|)
name|macro
operator|->
name|args
index|[
name|macro
operator|->
name|argc
index|]
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies the next logical line in the current buffer (starting at    buffer->cur) to the output buffer.  The output is guaranteed to    terminate with a NUL character.  buffer->cur is updated.     If MACRO is non-NULL, then we are scanning the replacement list of    MACRO, and we call save_replacement_text() every time we meet an    argument.  */
end_comment

begin_function
name|bool
name|_cpp_scan_out_logical_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
name|bool
name|result
init|=
name|true
decl_stmt|;
name|cpp_context
modifier|*
name|context
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|cur
decl_stmt|;
name|uchar
modifier|*
name|out
decl_stmt|;
name|struct
name|fun_macro
name|fmacro
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|paren_depth
init|=
literal|0
decl_stmt|,
name|quote
decl_stmt|;
name|enum
name|ls
name|lex_state
init|=
name|ls_none
decl_stmt|;
name|bool
name|header_ok
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|start_of_input_line
decl_stmt|;
name|fmacro
operator|.
name|buff
operator|=
name|NULL
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
name|header_ok
operator|=
name|pfile
operator|->
name|state
operator|.
name|angled_headers
expr_stmt|;
name|CUR
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
name|RLIMIT
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|first_line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
comment|/* start_of_input_line is needed to make sure that directives really,      really start at the first character of the line.  */
name|start_of_input_line
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
name|new_context
label|:
name|context
operator|=
name|pfile
operator|->
name|context
expr_stmt|;
name|cur
operator|=
name|CUR
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|check_output_buffer
argument_list|(
name|pfile
argument_list|,
name|RLIMIT
argument_list|(
name|context
argument_list|)
operator|-
name|cur
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|prev
operator|&&
name|cur
operator|>=
name|pfile
operator|->
name|buffer
operator|->
name|notes
index|[
name|pfile
operator|->
name|buffer
operator|->
name|cur_note
index|]
operator|.
name|pos
condition|)
block|{
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|_cpp_process_line_notes
argument_list|(
name|pfile
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Whitespace should "continue" out of the switch, 	 non-whitespace should "break" out of it.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'\n'
case|:
comment|/* If this is a macro's expansion, pop it.  */
if|if
condition|(
name|context
operator|->
name|prev
condition|)
block|{
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
operator|-
literal|1
expr_stmt|;
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
goto|goto
name|new_context
goto|;
block|}
comment|/* Omit the newline from the output buffer.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
operator|-
literal|1
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|need_line
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|lex_state
operator|==
name|ls_fun_open
operator|||
name|lex_state
operator|==
name|ls_fun_close
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|_cpp_get_fresh_line
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
comment|/* Newlines in arguments become a space, but we don't 		 clear any in-progress quote.  */
if|if
condition|(
name|lex_state
operator|==
name|ls_fun_close
condition|)
name|out
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|cur
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
continue|continue;
block|}
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
if|if
condition|(
name|header_ok
condition|)
name|quote
operator|=
literal|'>'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|c
operator|==
name|quote
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|c
operator|==
name|quote
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|quote
condition|)
name|quote
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Skip escaped quotes here, it's easier than above.  */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'\\'
operator|||
operator|*
name|cur
operator|==
literal|'"'
operator|||
operator|*
name|cur
operator|==
literal|'\''
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* Traditional CPP does not recognize comments within 	     literals.  */
if|if
condition|(
operator|!
name|quote
operator|&&
operator|*
name|cur
operator|==
literal|'*'
condition|)
block|{
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
expr_stmt|;
name|cur
operator|=
name|copy_comment
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|,
name|macro
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|&&
operator|(
name|quote
operator|==
literal|0
operator|||
name|macro
operator|)
condition|)
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|uchar
modifier|*
name|out_start
init|=
name|out
operator|-
literal|1
decl_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out_start
expr_stmt|;
name|node
operator|=
name|lex_identifier
argument_list|(
name|pfile
argument_list|,
name|cur
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
name|cur
operator|=
name|CUR
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
comment|/* Should we expand for ls_answer?  */
operator|&&
operator|(
name|lex_state
operator|==
name|ls_none
operator|||
name|lex_state
operator|==
name|ls_fun_open
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
condition|)
block|{
comment|/* Macros invalidate MI optimization.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|fun_like
condition|)
block|{
name|maybe_start_funlike
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|out_start
argument_list|,
operator|&
name|fmacro
argument_list|)
expr_stmt|;
name|lex_state
operator|=
name|ls_fun_open
expr_stmt|;
name|fmacro
operator|.
name|line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|recursive_macro
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
condition|)
block|{
comment|/* Remove the object-like macro's name from the 			 output, and push its replacement text.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out_start
expr_stmt|;
name|push_replacement_text
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|lex_state
operator|=
name|ls_none
expr_stmt|;
goto|goto
name|new_context
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|macro
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_MACRO_ARG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Found a parameter in the replacement text of a 		     #define.  Remove its name from the output.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out_start
expr_stmt|;
name|save_replacement_text
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|node
operator|->
name|value
operator|.
name|arg_index
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lex_state
operator|==
name|ls_hash
condition|)
block|{
name|lex_state
operator|=
name|ls_predicate
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_expression
operator|&&
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_defined
condition|)
block|{
name|lex_state
operator|=
name|ls_defined
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|quote
operator|==
literal|0
condition|)
block|{
name|paren_depth
operator|++
expr_stmt|;
if|if
condition|(
name|lex_state
operator|==
name|ls_fun_open
condition|)
block|{
if|if
condition|(
name|recursive_macro
argument_list|(
name|pfile
argument_list|,
name|fmacro
operator|.
name|node
argument_list|)
condition|)
name|lex_state
operator|=
name|ls_none
expr_stmt|;
else|else
block|{
name|lex_state
operator|=
name|ls_fun_close
expr_stmt|;
name|paren_depth
operator|=
literal|1
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|fmacro
operator|.
name|offset
expr_stmt|;
name|fmacro
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|fmacro
operator|.
name|offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lex_state
operator|==
name|ls_predicate
condition|)
name|lex_state
operator|=
name|ls_answer
expr_stmt|;
elseif|else
if|if
condition|(
name|lex_state
operator|==
name|ls_defined
condition|)
name|lex_state
operator|=
name|ls_defined_close
expr_stmt|;
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|quote
operator|==
literal|0
operator|&&
name|lex_state
operator|==
name|ls_fun_close
operator|&&
name|paren_depth
operator|==
literal|1
condition|)
name|save_argument
argument_list|(
operator|&
name|fmacro
argument_list|,
name|out
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|quote
operator|==
literal|0
condition|)
block|{
name|paren_depth
operator|--
expr_stmt|;
if|if
condition|(
name|lex_state
operator|==
name|ls_fun_close
operator|&&
name|paren_depth
operator|==
literal|0
condition|)
block|{
name|cpp_macro
modifier|*
name|m
init|=
name|fmacro
operator|.
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
name|m
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|lex_state
operator|=
name|ls_none
expr_stmt|;
name|save_argument
argument_list|(
operator|&
name|fmacro
argument_list|,
name|out
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|)
expr_stmt|;
comment|/* A single zero-length argument is no argument.  */
if|if
condition|(
name|fmacro
operator|.
name|argc
operator|==
literal|1
operator|&&
name|m
operator|->
name|paramc
operator|==
literal|0
operator|&&
name|out
operator|==
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|fmacro
operator|.
name|offset
operator|+
literal|1
condition|)
name|fmacro
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_cpp_arguments_ok
argument_list|(
name|pfile
argument_list|,
name|m
argument_list|,
name|fmacro
operator|.
name|node
argument_list|,
name|fmacro
operator|.
name|argc
argument_list|)
condition|)
block|{
comment|/* Remove the macro's invocation from the 			 output, and push its replacement text.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
operator|(
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|fmacro
operator|.
name|offset
operator|)
expr_stmt|;
name|CUR
argument_list|(
name|context
argument_list|)
operator|=
name|cur
expr_stmt|;
name|replace_args_and_push
argument_list|(
name|pfile
argument_list|,
operator|&
name|fmacro
argument_list|)
expr_stmt|;
goto|goto
name|new_context
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|lex_state
operator|==
name|ls_answer
operator|||
name|lex_state
operator|==
name|ls_defined_close
condition|)
name|lex_state
operator|=
name|ls_none
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|cur
operator|-
literal|1
operator|==
name|start_of_input_line
comment|/* A '#' from a macro doesn't start a directive.  */
operator|&&
operator|!
name|pfile
operator|->
name|context
operator|->
name|prev
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
block|{
comment|/* A directive.  With the way _cpp_handle_directive 		 currently works, we only want to call it if either we 		 know the directive is OK, or we want it to fail and 		 be removed from the output.  If we want it to be 		 passed through (the assembler case) then we must not 		 call _cpp_handle_directive.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|out
expr_stmt|;
name|cur
operator|=
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|,
name|true
comment|/* skip_comments */
argument_list|)
expr_stmt|;
name|out
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'\n'
condition|)
block|{
comment|/* Null directive.  Ignore it and don't invalidate 		     the MI optimization.  */
name|pfile
operator|->
name|buffer
operator|->
name|need_line
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|bool
name|do_it
init|=
name|false
decl_stmt|;
if|if
condition|(
name|is_numstart
argument_list|(
operator|*
name|cur
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
name|do_it
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|is_idstart
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
comment|/* Check whether we know this directive, but don't 		       advance.  */
name|do_it
operator|=
name|lex_identifier
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|)
operator|->
name|is_directive
expr_stmt|;
if|if
condition|(
name|do_it
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
block|{
comment|/* This is a kludge.  We want to have the ISO 			 preprocessor lex the next token.  */
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|false
comment|/* indented */
argument_list|)
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_expression
condition|)
block|{
name|lex_state
operator|=
name|ls_hash
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Non-whitespace disables MI optimization and stops treating 	 '<' as a quote in #include.  */
name|header_ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|lex_state
operator|==
name|ls_none
condition|)
continue|continue;
comment|/* Some of these transitions of state are syntax errors.  The 	 ISO preprocessor will issue errors later.  */
if|if
condition|(
name|lex_state
operator|==
name|ls_fun_open
condition|)
comment|/* Missing '('.  */
name|lex_state
operator|=
name|ls_none
expr_stmt|;
elseif|else
if|if
condition|(
name|lex_state
operator|==
name|ls_hash
operator|||
name|lex_state
operator|==
name|ls_predicate
operator|||
name|lex_state
operator|==
name|ls_defined
condition|)
name|lex_state
operator|=
name|ls_none
expr_stmt|;
comment|/* ls_answer and ls_defined_close keep going until ')'.  */
block|}
name|done
label|:
if|if
condition|(
name|fmacro
operator|.
name|buff
condition|)
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|fmacro
operator|.
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_state
operator|==
name|ls_fun_close
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|fmacro
operator|.
name|line
argument_list|,
literal|0
argument_list|,
literal|"unterminated argument list invoking macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|fmacro
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Push a context holding the replacement text of the macro NODE on    the context stack.  NODE is either object-like, or a function-like    macro with no arguments.  */
end_comment

begin_function
specifier|static
name|void
name|push_replacement_text
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|text
decl_stmt|;
name|uchar
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
condition|)
block|{
name|text
operator|=
name|_cpp_builtin_macro_text
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|len
operator|=
name|ustrlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|buf
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|text
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
name|macro
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|text
operator|=
name|macro
operator|->
name|exp
operator|.
name|text
expr_stmt|;
name|len
operator|=
name|macro
operator|->
name|count
expr_stmt|;
block|}
name|_cpp_push_text_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if traditional macro recursion is detected.  */
end_comment

begin_function
specifier|static
name|bool
name|recursive_macro
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|bool
name|recursing
init|=
operator|!
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_DISABLED
operator|)
decl_stmt|;
comment|/* Object-like macros that are already expanding are necessarily      recursive.       However, it is possible to have traditional function-like macros      that are not infinitely recursive but recurse to any given depth.      Further, it is easy to construct examples that get ever longer      until the point they stop recursing.  So there is no easy way to      detect true recursion; instead we assume any expansion more than      20 deep since the first invocation of this macro must be      recursing.  */
if|if
condition|(
name|recursing
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|fun_like
condition|)
block|{
name|size_t
name|depth
init|=
literal|0
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
do|do
block|{
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|macro
operator|==
name|node
operator|&&
name|depth
operator|>
literal|20
condition|)
break|break;
name|context
operator|=
name|context
operator|->
name|prev
expr_stmt|;
block|}
do|while
condition|(
name|context
condition|)
do|;
name|recursing
operator|=
name|context
operator|!=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|recursing
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"detected recursion whilst expanding macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|recursing
return|;
block|}
end_function

begin_comment
comment|/* Return the length of the replacement text of a function-like or    object-like non-builtin macro.  */
end_comment

begin_function
name|size_t
name|_cpp_replacement_text_len
parameter_list|(
specifier|const
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|fun_like
operator|&&
operator|(
name|macro
operator|->
name|paramc
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|exp
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|exp
operator|=
name|macro
operator|->
name|exp
operator|.
name|text
init|;
condition|;
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp
decl_stmt|;
name|len
operator|+=
name|b
operator|->
name|text_len
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|arg_index
operator|==
literal|0
condition|)
break|break;
name|len
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|b
operator|->
name|arg_index
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|exp
operator|+=
name|BLOCK_LEN
argument_list|(
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|len
operator|=
name|macro
operator|->
name|count
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Copy the replacement text of MACRO to DEST, which must be of    sufficient size.  It is not NUL-terminated.  The next character is    returned.  */
end_comment

begin_function
name|uchar
modifier|*
name|_cpp_copy_replacement_text
parameter_list|(
specifier|const
name|cpp_macro
modifier|*
name|macro
parameter_list|,
name|uchar
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|macro
operator|->
name|fun_like
operator|&&
operator|(
name|macro
operator|->
name|paramc
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|exp
decl_stmt|;
for|for
control|(
name|exp
operator|=
name|macro
operator|->
name|exp
operator|.
name|text
init|;
condition|;
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp
decl_stmt|;
name|cpp_hashnode
modifier|*
name|param
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|b
operator|->
name|text
argument_list|,
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|b
operator|->
name|text_len
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|arg_index
operator|==
literal|0
condition|)
break|break;
name|param
operator|=
name|macro
operator|->
name|params
index|[
name|b
operator|->
name|arg_index
operator|-
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|NODE_NAME
argument_list|(
name|param
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|NODE_LEN
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|exp
operator|+=
name|BLOCK_LEN
argument_list|(
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|macro
operator|->
name|exp
operator|.
name|text
argument_list|,
name|macro
operator|->
name|count
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|macro
operator|->
name|count
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Push a context holding the replacement text of the macro NODE on    the context stack.  NODE is either object-like, or a function-like    macro with no arguments.  */
end_comment

begin_function
specifier|static
name|void
name|replace_args_and_push
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|fun_macro
modifier|*
name|fmacro
parameter_list|)
block|{
name|cpp_macro
modifier|*
name|macro
init|=
name|fmacro
operator|->
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
name|push_replacement_text
argument_list|(
name|pfile
argument_list|,
name|fmacro
operator|->
name|node
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|uchar
modifier|*
name|exp
decl_stmt|;
name|uchar
modifier|*
name|p
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
comment|/* Calculate the length of the argument-replaced text.  */
for|for
control|(
name|exp
operator|=
name|macro
operator|->
name|exp
operator|.
name|text
init|;
condition|;
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp
decl_stmt|;
name|len
operator|+=
name|b
operator|->
name|text_len
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|arg_index
operator|==
literal|0
condition|)
break|break;
name|len
operator|+=
operator|(
name|fmacro
operator|->
name|args
index|[
name|b
operator|->
name|arg_index
index|]
operator|-
name|fmacro
operator|->
name|args
index|[
name|b
operator|->
name|arg_index
operator|-
literal|1
index|]
operator|-
literal|1
operator|)
expr_stmt|;
name|exp
operator|+=
name|BLOCK_LEN
argument_list|(
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate room for the expansion plus \n.  */
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy the expansion and replace arguments.  */
name|p
operator|=
name|BUFF_FRONT
argument_list|(
name|buff
argument_list|)
expr_stmt|;
for|for
control|(
name|exp
operator|=
name|macro
operator|->
name|exp
operator|.
name|text
init|;
condition|;
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp
decl_stmt|;
name|size_t
name|arglen
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|b
operator|->
name|text
argument_list|,
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|b
operator|->
name|text_len
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|arg_index
operator|==
literal|0
condition|)
break|break;
name|arglen
operator|=
operator|(
name|fmacro
operator|->
name|args
index|[
name|b
operator|->
name|arg_index
index|]
operator|-
name|fmacro
operator|->
name|args
index|[
name|b
operator|->
name|arg_index
operator|-
literal|1
index|]
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|base
operator|+
name|fmacro
operator|->
name|args
index|[
name|b
operator|->
name|arg_index
operator|-
literal|1
index|]
argument_list|,
name|arglen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|arglen
expr_stmt|;
name|exp
operator|+=
name|BLOCK_LEN
argument_list|(
name|b
operator|->
name|text_len
argument_list|)
expr_stmt|;
block|}
comment|/* \n-terminate.  */
operator|*
name|p
operator|=
literal|'\n'
expr_stmt|;
name|_cpp_push_text_context
argument_list|(
name|pfile
argument_list|,
name|fmacro
operator|->
name|node
argument_list|,
name|BUFF_FRONT
argument_list|(
name|buff
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* So we free buffer allocation when macro is left.  */
name|pfile
operator|->
name|context
operator|->
name|buff
operator|=
name|buff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read and record the parameters, if any, of a function-like macro    definition.  Destroys pfile->out.cur.     Returns true on success, false on failure (syntax error or a    duplicate parameter).  On success, CUR (pfile->context) is just    past the closing parenthesis.  */
end_comment

begin_function
specifier|static
name|bool
name|scan_parameters
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|cur
init|=
name|CUR
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|+
literal|1
decl_stmt|;
name|bool
name|ok
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cur
operator|=
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|,
name|true
comment|/* skip_comments */
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idstart
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
block|{
name|ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|_cpp_save_parameter
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|lex_identifier
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|)
argument_list|)
condition|)
break|break;
name|cur
operator|=
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|CUR
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
argument_list|,
name|true
comment|/* skip_comments */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|','
condition|)
block|{
name|cur
operator|++
expr_stmt|;
continue|continue;
block|}
name|ok
operator|=
operator|(
operator|*
name|cur
operator|==
literal|')'
operator|)
expr_stmt|;
break|break;
block|}
name|ok
operator|=
operator|(
operator|*
name|cur
operator|==
literal|')'
operator|&&
name|macro
operator|->
name|paramc
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"syntax error in macro parameter list"
argument_list|)
expr_stmt|;
name|CUR
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|=
name|cur
operator|+
operator|(
operator|*
name|cur
operator|==
literal|')'
operator|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Save the text from pfile->out.base to pfile->out.cur as    the replacement text for the current macro, followed by argument    ARG_INDEX, with zero indicating the end of the replacement    text.  */
end_comment

begin_function
specifier|static
name|void
name|save_replacement_text
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|,
name|unsigned
name|int
name|arg_index
parameter_list|)
block|{
name|size_t
name|len
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
decl_stmt|;
name|uchar
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
block|{
comment|/* Object-like and function-like macros without parameters 	 simply store their \n-terminated replacement text.  */
name|exp
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|exp
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|exp
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|macro
operator|->
name|exp
operator|.
name|text
operator|=
name|exp
expr_stmt|;
name|macro
operator|->
name|count
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Store the text's length (unsigned int), the argument index 	 (unsigned short, base 1) and then the text.  */
name|size_t
name|blen
init|=
name|BLOCK_LEN
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|count
operator|+
name|blen
operator|>
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
name|macro
operator|->
name|count
operator|+
name|blen
argument_list|)
expr_stmt|;
name|exp
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
operator|(
name|exp
operator|+
name|macro
operator|->
name|count
operator|)
expr_stmt|;
name|macro
operator|->
name|exp
operator|.
name|text
operator|=
name|exp
expr_stmt|;
comment|/* Write out the block information.  */
name|block
operator|->
name|text_len
operator|=
name|len
expr_stmt|;
name|block
operator|->
name|arg_index
operator|=
name|arg_index
expr_stmt|;
name|memcpy
argument_list|(
name|block
operator|->
name|text
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Lex the rest into the start of the output buffer.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
name|macro
operator|->
name|count
operator|+=
name|blen
expr_stmt|;
comment|/* If we've finished, commit the memory.  */
if|if
condition|(
name|arg_index
operator|==
literal|0
condition|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|+=
name|macro
operator|->
name|count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze and save the replacement text of a macro.  Returns true on    success.  */
end_comment

begin_function
name|bool
name|_cpp_create_trad_definition
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|cur
decl_stmt|;
name|uchar
modifier|*
name|limit
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
comment|/* The context has not been set up for command line defines, and CUR      has not been updated for the macro name for in-file defines.  */
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
name|CUR
argument_list|(
name|context
argument_list|)
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
name|RLIMIT
argument_list|(
name|context
argument_list|)
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
expr_stmt|;
name|check_output_buffer
argument_list|(
name|pfile
argument_list|,
name|RLIMIT
argument_list|(
name|context
argument_list|)
operator|-
name|CUR
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is this a function-like macro?  */
if|if
condition|(
operator|*
name|CUR
argument_list|(
name|context
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|bool
name|ok
init|=
name|scan_parameters
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
decl_stmt|;
comment|/* Remember the params so we can clear NODE_MACRO_ARG flags.  */
name|macro
operator|->
name|params
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
comment|/* Setting macro to NULL indicates an error occurred, and 	 prevents unnecessary work in _cpp_scan_out_logical_line.  */
if|if
condition|(
operator|!
name|ok
condition|)
name|macro
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|=
operator|(
name|uchar
operator|*
operator|)
operator|&
name|macro
operator|->
name|params
index|[
name|macro
operator|->
name|paramc
index|]
expr_stmt|;
name|macro
operator|->
name|fun_like
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Skip leading whitespace in the replacement text.  */
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|CUR
argument_list|(
name|context
argument_list|)
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|_cpp_scan_out_logical_line
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|macro
condition|)
return|return
name|false
return|;
comment|/* Skip trailing white space.  */
name|cur
operator|=
name|pfile
operator|->
name|out
operator|.
name|base
expr_stmt|;
name|limit
operator|=
name|pfile
operator|->
name|out
operator|.
name|cur
expr_stmt|;
while|while
condition|(
name|limit
operator|>
name|cur
operator|&&
name|is_space
argument_list|(
name|limit
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|limit
operator|--
expr_stmt|;
name|pfile
operator|->
name|out
operator|.
name|cur
operator|=
name|limit
expr_stmt|;
name|save_replacement_text
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy SRC of length LEN to DEST, but convert all contiguous    whitespace to a single space, provided it is not in quotes.  The    quote currently in effect is pointed to by PQUOTE, and is updated    by the function.  Returns the number of bytes copied.  */
end_comment

begin_function
specifier|static
name|size_t
name|canonicalize_text
parameter_list|(
name|uchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar
modifier|*
name|pquote
parameter_list|)
block|{
name|uchar
modifier|*
name|orig_dest
init|=
name|dest
decl_stmt|;
name|uchar
name|quote
init|=
operator|*
name|pquote
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|is_space
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
operator|!
name|quote
condition|)
block|{
do|do
name|src
operator|++
operator|,
name|len
operator|--
expr_stmt|;
do|while
condition|(
name|len
operator|&&
name|is_space
argument_list|(
operator|*
name|src
argument_list|)
condition|)
do|;
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\''
operator|||
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|quote
condition|)
name|quote
operator|=
operator|*
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|quote
operator|==
operator|*
name|src
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
block|}
operator|*
name|pquote
operator|=
name|quote
expr_stmt|;
return|return
name|dest
operator|-
name|orig_dest
return|;
block|}
end_function

begin_comment
comment|/* Returns true if MACRO1 and MACRO2 have expansions different other    than in the form of their whitespace.  */
end_comment

begin_function
name|bool
name|_cpp_expansions_different_trad
parameter_list|(
specifier|const
name|cpp_macro
modifier|*
name|macro1
parameter_list|,
specifier|const
name|cpp_macro
modifier|*
name|macro2
parameter_list|)
block|{
name|uchar
modifier|*
name|p1
init|=
name|xmalloc
argument_list|(
name|macro1
operator|->
name|count
operator|+
name|macro2
operator|->
name|count
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|p2
init|=
name|p1
operator|+
name|macro1
operator|->
name|count
decl_stmt|;
name|uchar
name|quote1
init|=
literal|0
decl_stmt|,
name|quote2
init|=
literal|0
decl_stmt|;
name|bool
name|mismatch
decl_stmt|;
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
name|macro1
operator|->
name|paramc
operator|>
literal|0
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|exp1
init|=
name|macro1
operator|->
name|exp
operator|.
name|text
decl_stmt|,
modifier|*
name|exp2
init|=
name|macro2
operator|->
name|exp
operator|.
name|text
decl_stmt|;
name|mismatch
operator|=
name|true
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|block
modifier|*
name|b1
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp1
decl_stmt|;
name|struct
name|block
modifier|*
name|b2
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|exp2
decl_stmt|;
if|if
condition|(
name|b1
operator|->
name|arg_index
operator|!=
name|b2
operator|->
name|arg_index
condition|)
break|break;
name|len1
operator|=
name|canonicalize_text
argument_list|(
name|p1
argument_list|,
name|b1
operator|->
name|text
argument_list|,
name|b1
operator|->
name|text_len
argument_list|,
operator|&
name|quote1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|canonicalize_text
argument_list|(
name|p2
argument_list|,
name|b2
operator|->
name|text
argument_list|,
name|b2
operator|->
name|text_len
argument_list|,
operator|&
name|quote2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
operator|||
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|b1
operator|->
name|arg_index
operator|==
literal|0
condition|)
block|{
name|mismatch
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|exp1
operator|+=
name|BLOCK_LEN
argument_list|(
name|b1
operator|->
name|text_len
argument_list|)
expr_stmt|;
name|exp2
operator|+=
name|BLOCK_LEN
argument_list|(
name|b2
operator|->
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len1
operator|=
name|canonicalize_text
argument_list|(
name|p1
argument_list|,
name|macro1
operator|->
name|exp
operator|.
name|text
argument_list|,
name|macro1
operator|->
name|count
argument_list|,
operator|&
name|quote1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|canonicalize_text
argument_list|(
name|p2
argument_list|,
name|macro2
operator|->
name|exp
operator|.
name|text
argument_list|,
name|macro2
operator|->
name|count
argument_list|,
operator|&
name|quote2
argument_list|)
expr_stmt|;
name|mismatch
operator|=
operator|(
name|len1
operator|!=
name|len2
operator|||
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len1
argument_list|)
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
return|return
name|mismatch
return|;
block|}
end_function

end_unit

