begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform simple optimizations to clean up the result of reload.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_function_decl
specifier|static
name|int
name|reload_cse_noop_set_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_cse_simplify
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_cse_regs_1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reload_cse_simplify_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reload_cse_simplify_operands
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_combine
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_combine_note_use
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_combine_note_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_cse_move2add
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move2add_note_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Call cse / combine like post-reload optimization phases.    FIRST is the first instruction.  */
end_comment

begin_function
name|void
name|reload_cse_regs
parameter_list|(
name|rtx
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|reload_combine
argument_list|()
expr_stmt|;
name|reload_cse_move2add
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See whether a single set SET is a noop.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_noop_set_p
parameter_list|(
name|rtx
name|set
parameter_list|)
block|{
if|if
condition|(
name|cselib_reg_set_mode
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_for_cselib_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to simplify INSN.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_simplify
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|testreg
parameter_list|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Simplify even if we may think it is a no-op.          We may think a memory load of a value smaller than WORD_SIZE          is redundant because we haven't taken into account possible          implicit extension.  reload_cse_simplify_set() will bring          this out, so it's safer to simplify before we delete.  */
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|&&
name|reload_cse_noop_set_p
argument_list|(
name|body
argument_list|)
condition|)
block|{
name|rtx
name|value
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|value
argument_list|)
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|,
name|testreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|value
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Registers mentioned in the clobber list for an asm cannot be reused 	 within the body of the asm.  Invalidate those registers now so that 	 we don't try to substitute values for them.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|cselib_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If every action in a PARALLEL is a noop, we can delete 	 the entire PARALLEL.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|!
name|reload_cse_noop_set_p
argument_list|(
name|part
argument_list|)
condition|)
break|break;
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|part
argument_list|)
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|part
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
condition|)
break|break;
name|value
operator|=
name|SET_DEST
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We're done with this insn.  */
return|return;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|,
name|testreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a very simple CSE pass over the hard registers.     This function detects no-op moves where we happened to assign two    different pseudo-registers to the same hard register, and then    copied one to the other.  Reload will generate a useless    instruction copying a register to itself.     This function also detects cases where we load a value from memory    into two different registers, and (if memory is more expensive than    registers) changes it to simply copy the first register into the    second register.     Another optimization is performed that scans the operands of each    instruction to see whether the value is already available in a    hard register.  It then replaces the operand with the hard register    if possible, much like an optional reload would.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_regs_1
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|testreg
init|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|cselib_init
argument_list|()
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_simplify
argument_list|(
name|insn
argument_list|,
name|testreg
argument_list|)
expr_stmt|;
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to simplify a single SET instruction.  SET is the set pattern.    INSN is the instruction it came from.    This function only handles one case: if we set a register to a value    which is not a register, we try to find that value in some other register    and change the set into a register copy.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_set
parameter_list|(
name|rtx
name|set
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|did_change
init|=
literal|0
decl_stmt|;
name|int
name|dreg
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|enum
name|reg_class
name|dclass
decl_stmt|;
name|int
name|old_cost
decl_stmt|;
name|cselib_val
modifier|*
name|val
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
name|enum
name|rtx_code
name|extend_op
init|=
name|NIL
decl_stmt|;
endif|#
directive|endif
name|dreg
operator|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|true_regnum
argument_list|(
name|src
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|dclass
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|dreg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* When replacing a memory with a register, we need to honor assumptions      that combine made wrt the contents of sign bits.  We'll do this by      generating an extend instruction instead of a reg->reg copy.  Thus      the destination must be a register that we can widen.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
name|extend_op
operator|=
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
operator|!=
name|NIL
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|val
operator|=
name|cselib_lookup
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
comment|/* If memory loads are cheaper than register copies, don't change them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|old_cost
operator|=
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
name|old_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
else|else
name|old_cost
operator|=
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|val
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|rtx
name|this_rtx
init|=
name|l
operator|->
name|loc
decl_stmt|;
name|int
name|this_cost
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|this_rtx
argument_list|)
operator|&&
operator|!
name|references_value_p
argument_list|(
name|this_rtx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|extend_op
operator|!=
name|NIL
condition|)
block|{
name|HOST_WIDE_INT
name|this_val
decl_stmt|;
comment|/* ??? I'm lazy and don't wish to handle CONST_DOUBLE.  Other 		 constants, such as SYMBOL_REF, cannot be extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
name|this_val
operator|=
name|INTVAL
argument_list|(
name|this_rtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extend_op
condition|)
block|{
case|case
name|ZERO_EXTEND
case|:
name|this_val
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* ??? In theory we're already extended.  */
if|if
condition|(
name|this_val
operator|==
name|trunc_int_for_mode
argument_list|(
name|this_val
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|this_rtx
operator|=
name|GEN_INT
argument_list|(
name|this_val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|this_cost
operator|=
name|rtx_cost
argument_list|(
name|this_rtx
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|extend_op
operator|!=
name|NIL
condition|)
block|{
name|this_rtx
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|extend_op
argument_list|,
name|word_mode
argument_list|,
name|this_rtx
argument_list|)
expr_stmt|;
name|this_cost
operator|=
name|rtx_cost
argument_list|(
name|this_rtx
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|this_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|this_rtx
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|this_rtx
argument_list|)
argument_list|)
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If equal costs, prefer registers over anything else.  That 	 tends to lead to smaller instructions on some machines.  */
if|if
condition|(
name|this_cost
operator|<
name|old_cost
operator|||
operator|(
name|this_cost
operator|==
name|old_cost
operator|&&
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|extend_op
operator|!=
name|NIL
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
name|CANNOT_CHANGE_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|wide_dest
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|wide_dest
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|wide_dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|this_rtx
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_cost
operator|=
name|this_cost
operator|,
name|did_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|did_change
return|;
block|}
end_function

begin_comment
comment|/* Try to replace operands in INSN with equivalent values that are already    in registers.  This can be viewed as optional reloading.     For each non-register operand in the insn, see if any hard regs are    known to be equivalent to that operand.  Record the alternatives which    can accept these hard registers.  Among all alternatives, select the    ones which are better or equal to the one currently matching, where    "better" is in terms of '?' and '!' constraints.  Among the remaining    alternatives, select the one which replaces most operands with    hard registers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_operands
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|testreg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* For each operand, all registers that are equivalent to it.  */
name|HARD_REG_SET
name|equiv_regs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Vector recording how bad an alternative is.  */
name|int
modifier|*
name|alternative_reject
decl_stmt|;
comment|/* Vector recording how many registers can be introduced by choosing      this alternative.  */
name|int
modifier|*
name|alternative_nregs
decl_stmt|;
comment|/* Array of vectors recording, for each operand and each alternative,      which hard register to substitute, or -1 if the operand should be      left as it is.  */
name|int
modifier|*
name|op_alt_regno
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Array of alternatives, sorted in order of decreasing desirability.  */
name|int
modifier|*
name|alternative_order
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
operator|||
name|recog_data
operator|.
name|n_operands
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Figure out which alternative currently matches.  */
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|alternative_reject
operator|=
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_nregs
operator|=
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_order
operator|=
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|alternative_reject
argument_list|,
literal|0
argument_list|,
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|alternative_nregs
argument_list|,
literal|0
argument_list|,
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each operand, find out which regs are equivalent.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|cselib_val
modifier|*
name|v
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem 	 right, so avoid the problem here.  Likewise if we have a constant          and the insn pattern doesn't tell us the mode we need.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
operator|)
condition|)
continue|continue;
name|op
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
operator|!=
name|NIL
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We might have multiple sets, some of which do implict 	     extension.  Punt on this for now.  */
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
comment|/* If the destination is a also MEM or a STRICT_LOW_PART, no 	     extension applies. 	     Also, if there is an explicit extension, we don't have to 	     worry about an implicit one.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
empty_stmt|;
comment|/* Continue ordinary processing.  */
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
comment|/* If the register cannot change mode to word_mode, it follows that 	     it cannot have been used in word_mode.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CANNOT_CHANGE_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Continue ordinary processing.  */
endif|#
directive|endif
comment|/* If this is a straight load, make the extension explicit.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|recog_data
operator|.
name|n_operands
operator|==
literal|2
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|op
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|recog_data
operator|.
name|operand
index|[
literal|1
operator|-
name|i
index|]
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|op
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
literal|1
operator|-
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|,
name|testreg
argument_list|)
return|;
block|}
else|else
comment|/* ??? There might be arithmetic operations with memory that are 	       safe to optimize, but is it worth the trouble?  */
continue|continue;
block|}
endif|#
directive|endif
comment|/* LOAD_EXTEND_OP */
name|v
operator|=
name|cselib_lookup
argument_list|(
name|op
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
for|for
control|(
name|l
operator|=
name|v
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|,
name|REGNO
argument_list|(
name|l
operator|->
name|loc
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|op_alt_regno
index|[
name|i
index|]
operator|=
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|=
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
expr_stmt|;
comment|/* Add the reject values for each alternative given by the constraints 	 for this operand.  */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|j
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|300
expr_stmt|;
block|}
comment|/* We won't change operands which are already registers.  We 	 also don't want to modify output operands.  */
name|regno
operator|=
name|true_regnum
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
continue|continue;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
continue|continue;
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|=
name|regno
expr_stmt|;
name|PUT_MODE
argument_list|(
name|testreg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* We found a register equal to this operand.  Now look for all 	     alternatives that can accept this register and have not been 	     assigned a register they can use yet.  */
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
operator|(
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|,
name|p
argument_list|)
index|]
operator|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|'\0'
case|:
comment|/* See if REGNO fits this alternative, and set it up as the 		     replacement register if we don't have one for this 		     alternative yet and the operand being replaced is not 		     a cheap CONST_INT.  */
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_fits_class_p
argument_list|(
name|testreg
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|rtx_cost
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|SET
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|testreg
argument_list|,
name|SET
argument_list|)
operator|)
operator|)
condition|)
block|{
name|alternative_nregs
index|[
name|j
index|]
operator|++
expr_stmt|;
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|regno
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
block|}
comment|/* Record all alternatives which are better or equal to the currently      matching one in the alternative_order array.  */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alternative_reject
index|[
name|i
index|]
operator|<=
name|alternative_reject
index|[
name|which_alternative
index|]
condition|)
name|alternative_order
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
name|j
expr_stmt|;
comment|/* Sort it.  Given a small number of alternatives, a dumb algorithm      won't hurt too much.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_alternatives
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|best
init|=
name|i
decl_stmt|;
name|int
name|best_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|best_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|int
name|this_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
name|int
name|this_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
if|if
condition|(
name|this_reject
operator|<
name|best_reject
operator|||
operator|(
name|this_reject
operator|==
name|best_reject
operator|&&
name|this_nregs
operator|<
name|best_nregs
operator|)
condition|)
block|{
name|best
operator|=
name|j
expr_stmt|;
name|best_reject
operator|=
name|this_reject
expr_stmt|;
name|best_nregs
operator|=
name|this_nregs
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|alternative_order
index|[
name|best
index|]
expr_stmt|;
name|alternative_order
index|[
name|best
index|]
operator|=
name|alternative_order
index|[
name|i
index|]
expr_stmt|;
name|alternative_order
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Substitute the operands as determined by op_alt_regno for the best      alternative.  */
name|j
operator|=
name|alternative_order
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|op
init|=
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|recog_data
operator|.
name|operand_mode
index|[
name|op
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg    addressing now.    This code might also be useful when reload gave up on reg+reg addressing    because of clashes between the return register and INDEX_REG_CLASS.  */
end_comment

begin_comment
comment|/* The maximum number of uses of a register we can keep track of to    replace them with reg+reg addressing.  */
end_comment

begin_define
define|#
directive|define
name|RELOAD_COMBINE_MAX_USES
value|6
end_define

begin_comment
comment|/* INSN is the insn where a register has ben used, and USEP points to the    location of the register within the rtl.  */
end_comment

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|insn
decl_stmt|,
modifier|*
name|usep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the register is used in some unknown fashion, USE_INDEX is negative.    If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID    indicates where it becomes live again.    Otherwise, USE_INDEX is the index of the last encountered use of the    register (which is first among these we have seen since we scan backwards),    OFFSET contains the constant offset that is added to the register in    all encountered uses, and USE_RUID indicates the first encountered, i.e.    last, of these uses.    STORE_RUID is always meaningful if we only want to use a value in a    register in a different place: it denotes the next insn in the insn    stream (i.e. the last encountered) that sets or clobbers the register.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|reg_use
name|reg_use
index|[
name|RELOAD_COMBINE_MAX_USES
index|]
decl_stmt|;
name|int
name|use_index
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|store_ruid
decl_stmt|;
name|int
name|use_ruid
decl_stmt|;
block|}
name|reg_state
index|[
name|FIRST_PSEUDO_REGISTER
index|]
struct|;
end_struct

begin_comment
comment|/* Reverse linear uid.  This is increased in reload_combine while scanning    the instructions from last to first.  It is used to set last_label_ruid    and the store_ruid / use_ruid fields in reg_state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_combine_ruid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LABEL_LIVE
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])
end_define

begin_function
specifier|static
name|void
name|reload_combine
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|int
name|first_index_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|last_index_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
name|int
name|last_label_ruid
decl_stmt|;
name|int
name|min_labelno
decl_stmt|,
name|n_labels
decl_stmt|;
name|HARD_REG_SET
name|ever_live_at_start
decl_stmt|,
modifier|*
name|label_live
decl_stmt|;
comment|/* If reg+reg can be used in offsetable memory addresses, the main chunk of      reload has already used it where appropriate, so there is no use in      trying to generate it now.  */
if|if
condition|(
name|double_reg_address_ok
operator|&&
name|INDEX_REG_CLASS
operator|!=
name|NO_REGS
condition|)
return|return;
comment|/* To avoid wasting too much time later searching for an index register,      determine the minimum and maximum index register numbers.  */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|first_index_reg
operator|==
operator|-
literal|1
condition|)
name|first_index_reg
operator|=
name|r
expr_stmt|;
name|last_index_reg
operator|=
name|r
expr_stmt|;
block|}
comment|/* If no index register is available, we can quit now.  */
if|if
condition|(
name|first_index_reg
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime      information is a bit fuzzy immediately after reload, but it's      still good enough to determine which registers are live at a jump      destination.  */
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|n_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|min_labelno
expr_stmt|;
name|label_live
operator|=
name|xmalloc
argument_list|(
name|n_labels
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|HARD_REG_SET
name|live
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|live
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|LABEL_LIVE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|live
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */
name|last_label_ruid
operator|=
name|reload_combine_ruid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
block|{
name|reg_state
index|[
name|r
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
if|if
condition|(
name|fixed_regs
index|[
name|r
index|]
condition|)
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* We cannot do our optimization across labels.  Invalidating all the use 	 information we have would be costly, so we just note where the label 	 is and then later disable any optimization that would cross it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_label_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|r
index|]
condition|)
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|reload_combine_ruid
operator|++
expr_stmt|;
comment|/* Look for (set (REGX) (CONST_INT)) 	 (set (REGX) (PLUS (REGX) (REGY))) 	 ... 	 ... (MEM (REGX)) ... 	 and convert it to 	 (set (REGZ) (CONST_INT)) 	 ... 	 ... (MEM (PLUS (REGZ) (REGY)))... .  	 First, check that we have (set (REGX) (PLUS (REGX) (REGY))) 	 and that we know all uses of REGX before it dies.   	 Also, explicitly check that REGX != REGY; our life information 	 does not yet show whether REGY changes in this insn.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|last_label_ruid
operator|<
name|reg_state
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|use_ruid
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|plus
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|plus
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_set
init|=
name|prev
condition|?
name|single_set
argument_list|(
name|prev
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|const_reg
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|reg_sum
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Now, we need an index register. 	     We'll set index_reg to this index register, const_reg to the 	     register that is to be loaded with the constant 	     (denoted as REGZ in the substitution illustration above), 	     and reg_sum to the register-register that we want to use to 	     substitute uses of REG (typically in MEMs) with. 	     First check REG and BASE for being index registers; 	     we can use them even if they are not dead.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|const_reg
operator|=
name|reg
expr_stmt|;
name|reg_sum
operator|=
name|plus
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, look for a free index register.  Since we have 		 checked above that neither REG nor BASE are index registers, 		 if we find anything at all, it will be different from these 		 two registers.  */
for|for
control|(
name|i
operator|=
name|first_index_reg
init|;
name|i
operator|<=
name|last_index_reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|==
name|RELOAD_COMBINE_MAX_USES
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|index_reg
init|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|const_reg
operator|=
name|index_reg
expr_stmt|;
name|reg_sum
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|index_reg
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that 	     (REGY), i.e. BASE, is not clobbered before the last use we'll 	     create.  */
if|if
condition|(
name|prev_set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|&&
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|>=
literal|0
operator|&&
operator|(
name|reg_state
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|)
operator|&&
name|reg_sum
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Change destination register and, if necessary, the 		 constant value in PREV, the constant loading instruction.  */
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|const_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now for every use of REG that we have recorded, replace REG 		 with REG_SUM.  */
for|for
control|(
name|i
operator|=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
init|;
name|i
operator|<
name|RELOAD_COMBINE_MAX_USES
condition|;
name|i
operator|++
control|)
name|validate_change
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|usep
argument_list|,
comment|/* Each change must have its own 				    replacement.  */
name|copy_rtx
argument_list|(
name|reg_sum
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|rtx
modifier|*
name|np
decl_stmt|;
comment|/* Delete the reg-reg addition.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
comment|/* Previous REG_EQUIV / REG_EQUAL notes for PREV 		       are now invalid.  */
for|for
control|(
name|np
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
operator|*
name|np
condition|;
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUIV
condition|)
operator|*
name|np
operator|=
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|np
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|REGNO
argument_list|(
name|const_reg
argument_list|)
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_combine_note_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|r
index|]
condition|)
block|{
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|r
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|usage_rtx
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|usage_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|start_reg
init|=
name|REGNO
argument_list|(
name|usage_rtx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|num_regs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|start_reg
argument_list|,
name|GET_MODE
argument_list|(
name|usage_rtx
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|end_reg
init|=
name|start_reg
operator|+
name|num_regs
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start_reg
init|;
name|i
operator|<=
name|end_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
else|else
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
comment|/* Non-spill registers might be used at the call destination in 	     some unknown fashion, so we have to mark the unknown use.  */
name|HARD_REG_SET
modifier|*
name|live
decl_stmt|;
if|if
condition|(
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|live
operator|=
operator|&
name|LABEL_LIVE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|live
operator|=
operator|&
name|ever_live_at_start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|live
argument_list|,
name|i
argument_list|)
condition|)
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|reload_combine_note_use
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|label_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if DST is a register or a subreg of a register; if it is,    update reg_state[regno].store_ruid and reg_state[regno].use_index    accordingly.  Called via note_stores from reload_combine.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_store
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|set
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* note_stores might have stripped a STRICT_LOW_PART, so we have to be      careful with registers / register parts that are not full words.       Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XP points to a piece of rtl that has to be checked for any uses of    registers.    *XP is the pattern of INSN, or a part of it.    Called from reload_combine, and recursively by itself.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_use
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|x
operator|->
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
comment|/* For the REG case below.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reload_combine_note_use
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|USE
case|:
comment|/* If this is the USE of a return value, we can't change it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Mark the return register as used in an unknown fashion.  */
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|nregs
operator|>=
literal|0
condition|)
name|reg_state
index|[
name|regno
operator|+
name|nregs
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* No spurious CLOBBERs of pseudo registers may remain.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* We are interested in (plus (reg) (const_int)) .  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
name|offset
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|use_index
decl_stmt|;
name|int
name|nregs
decl_stmt|;
comment|/* No spurious USEs of pseudo registers may remain.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't substitute into multi-hard-reg uses.  */
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
block|{
while|while
condition|(
operator|--
name|nregs
operator|>=
literal|0
condition|)
name|reg_state
index|[
name|regno
operator|+
name|nregs
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this register is already used in some unknown fashion, we 	   can't do anything. 	   If we decrement the index from zero to -1, we can't store more 	   uses, so this register becomes used in an unknown fashion.  */
name|use_index
operator|=
operator|--
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
expr_stmt|;
if|if
condition|(
name|use_index
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|use_index
operator|!=
name|RELOAD_COMBINE_MAX_USES
operator|-
literal|1
condition|)
block|{
comment|/* We have found another use for a register that is already 	       used later.  Check if the offsets match; if not, mark the 	       register as used in an unknown fashion.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|offset
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
condition|)
block|{
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* This is the first use of this register we have seen since we 	       marked it as dead.  */
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|usep
operator|=
name|xp
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
comment|/* Recursively process the components of X.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if we can reduce the cost of a constant by replacing a move    with an add.  We track situations in which a register is set to a    constant or to a register plus a constant.  */
end_comment

begin_comment
comment|/* We cannot do our optimization across labels.  Invalidating all the    information about register contents we have would be costly, so we    use move2add_last_label_luid to note where the label is and then    later disable any optimization that would cross it.    reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if    reg_set_luid[n] is greater than move2add_last_label_luid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_luid
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg_base_reg[n] is negative, register n has been set to    reg_offset[n] in mode reg_mode[n] .    If reg_base_reg[n] is non-negative, register n has been set to the    sum of reg_offset[n] and the value of register reg_base_reg[n]    before reg_set_luid[n], calculated in mode reg_mode[n] .  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_base_reg
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|reg_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move2add_luid is linearly increased while scanning the instructions    from first to last.  It is used to set reg_set_luid in    reload_cse_move2add and move2add_note_store.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move2add_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move2add_last_label_luid is set whenever a label is found.  Labels    invalidate all previously collected reg_offset data.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move2add_last_label_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? We don't know how zero / sign extension is handled, hence we    can't go from a narrower to a wider mode.  */
end_comment

begin_define
define|#
directive|define
name|MODES_OK_FOR_MOVE2ADD
parameter_list|(
name|OUTMODE
parameter_list|,
name|INMODE
parameter_list|)
define|\
value|(GET_MODE_SIZE (OUTMODE) == GET_MODE_SIZE (INMODE) \    || (GET_MODE_SIZE (OUTMODE)<= GET_MODE_SIZE (INMODE) \&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \ 				 GET_MODE_BITSIZE (INMODE))))
end_define

begin_function
specifier|static
name|void
name|reload_cse_move2add
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|move2add_last_label_luid
operator|=
literal|0
expr_stmt|;
name|move2add_luid
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|,
name|move2add_luid
operator|++
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|move2add_last_label_luid
operator|=
name|move2add_luid
expr_stmt|;
comment|/* We're going to increment move2add_luid twice after a 	     label, so that we can use move2add_last_label_luid + 1 as 	     the luid for constants.  */
name|move2add_luid
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* For simplicity, we only perform this optimization on 	 straightforward SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* Check if we have valid information on the contents of this 	     register in the mode of REG.  */
if|if
condition|(
name|reg_set_luid
index|[
name|regno
index|]
operator|>
name|move2add_last_label_luid
operator|&&
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg_mode
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* Try to transform (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (CONST_INT B)) 		 to 				  (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A))) 		 or 				  (set (REGX) (CONST_INT A)) 				  ... 				  (set (STRICT_LOW_PART (REGX)) (CONST_INT B)) 	      */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|<
literal|0
condition|)
block|{
name|rtx
name|new_src
init|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|-
name|reg_offset
index|[
name|regno
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* (set (reg) (plus (reg) (const_int 0))) is not canonical; 		     use (set (reg) (reg)) instead. 		     We don't delete this insn, nor do we convert it into a 		     note, to avoid losing register notes or the return 		     value flag.  jump2 already knows how to get rid of 		     no-op moves.  */
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
block|{
comment|/* If the constants are different, this is a 			 truncation, that, if turned into (set (reg) 			 (reg)), would be discarded.  Maybe we should 			 try a truncMN pattern?  */
if|if
condition|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|==
name|reg_offset
index|[
name|regno
index|]
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
operator|&&
name|have_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
condition|)
block|{
name|rtx
name|newpat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|)
decl_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|narrow_mode
decl_stmt|;
for|for
control|(
name|narrow_mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|narrow_mode
operator|!=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
condition|;
name|narrow_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|narrow_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|have_insn_for
argument_list|(
name|STRICT_LOW_PART
argument_list|,
name|narrow_mode
argument_list|)
operator|&&
operator|(
operator|(
name|reg_offset
index|[
name|regno
index|]
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|narrow_mode
argument_list|)
operator|)
operator|==
operator|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|narrow_mode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|narrow_reg
init|=
name|gen_rtx_REG
argument_list|(
name|narrow_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|narrow_src
init|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|src
argument_list|)
argument_list|,
name|narrow_mode
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_set
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|narrow_reg
argument_list|)
argument_list|,
name|narrow_src
argument_list|)
decl_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_set
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Try to transform (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT B))) 		 to 				  (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|reg_set_luid
index|[
name|regno
index|]
operator|==
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|==
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|&&
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|src3
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|added_offset
init|=
name|INTVAL
argument_list|(
name|src3
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|base_offset
init|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|regno_offset
init|=
name|reg_offset
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|new_src
init|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|added_offset
operator|+
name|base_offset
operator|-
name|regno_offset
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
comment|/* See above why we create (set (reg) (reg)) here.  */
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|src3
argument_list|,
name|SET
argument_list|)
operator|)
operator|&&
name|have_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
condition|)
block|{
name|rtx
name|newpat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|)
decl_stmt|;
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|trunc_int_for_mode
argument_list|(
name|added_offset
operator|+
name|base_offset
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Reset the information about this register.  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_set_luid
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|move2add_note_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If INSN is a conditional branch, we try to extract an 	 implicit set out of it.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|cnd
init|=
name|fis_get_condition
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnd
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|cnd
argument_list|)
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
comment|/* The following two checks, which are also in 		 move2add_note_store, are intended to reduce the 		 number of calls to gen_rtx_SET to avoid memory 		 allocation if possible.  */
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|implicit_set
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cnd
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|move2add_note_store
argument_list|(
name|SET_DEST
argument_list|(
name|implicit_set
argument_list|)
argument_list|,
name|implicit_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a CALL_INSN, all call used registers are stored with 	 unknown values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
comment|/* Reset the information about this register.  */
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* SET is a SET or CLOBBER that sets DST.    Update reg_set_luid, reg_offset and reg_base_reg accordingly.    Called from reload_cse_move2add via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|move2add_note_store
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|set
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* Some targets do argument pushes without adding REG_INC notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|POST_DEC
condition|)
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|base_regno
decl_stmt|;
comment|/* This may be different from mode, if SET_DEST (set) is a 	 SUBREG.  */
name|enum
name|machine_mode
name|dst_mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base_reg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|>
name|move2add_last_label_luid
operator|)
operator|&&
operator|(
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|<
literal|0
condition|)
name|offset
operator|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Maybe the first register is known to be a 		     constant.  */
elseif|else
if|if
condition|(
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
operator|>
name|move2add_last_label_luid
operator|&&
operator|(
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
operator|)
operator|&&
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
expr_stmt|;
name|base_reg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|invalidate
goto|;
block|}
else|else
goto|goto
name|invalidate
goto|;
break|break;
block|}
goto|goto
name|invalidate
goto|;
case|case
name|REG
case|:
name|base_reg
operator|=
name|src
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
comment|/* Start tracking the register as a constant.  */
name|reg_base_reg
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We assign the same luid to all registers set to constants.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_last_label_luid
operator|+
literal|1
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
return|return;
default|default:
name|invalidate
label|:
comment|/* Invalidate the contents of the register.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|base_regno
operator|=
name|REGNO
argument_list|(
name|base_reg
argument_list|)
expr_stmt|;
comment|/* If information about the base register is not valid, set it 	 up as a new base register, pretending its value is known 	 starting from the current insn.  */
if|if
condition|(
name|reg_set_luid
index|[
name|base_regno
index|]
operator|<=
name|move2add_last_label_luid
condition|)
block|{
name|reg_base_reg
index|[
name|base_regno
index|]
operator|=
name|base_regno
expr_stmt|;
name|reg_offset
index|[
name|base_regno
index|]
operator|=
literal|0
expr_stmt|;
name|reg_set_luid
index|[
name|base_regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|base_regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|base_regno
index|]
argument_list|)
condition|)
goto|goto
name|invalidate
goto|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
comment|/* Copy base information from our base register.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|reg_set_luid
index|[
name|base_regno
index|]
expr_stmt|;
name|reg_base_reg
index|[
name|regno
index|]
operator|=
name|reg_base_reg
index|[
name|base_regno
index|]
expr_stmt|;
comment|/* Compute the sum of the offsets or constants.  */
name|reg_offset
index|[
name|regno
index|]
operator|=
name|trunc_int_for_mode
argument_list|(
name|offset
operator|+
name|reg_offset
index|[
name|base_regno
index|]
argument_list|,
name|dst_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
comment|/* Reset the information about this register.  */
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

