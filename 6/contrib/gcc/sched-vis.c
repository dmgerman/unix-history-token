begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* target_units bitmask has 1 for each unit in the cpu.  It should be    possible to compute this variable from the machine description.    But currently it is computed by examining the insn list.  Since    this is only needed for visualization, it seems an acceptable    solution.  (For understanding the mapping of bits to units, see    definition of function_units[] in "insn-attrtab.c".)  The scheduler    using only DFA description should never use the following variable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_units
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|safe_concat
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_visual_tbl_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_exp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_value
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_pattern
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print names of units on which insn can/should execute, for debugging.  */
end_comment

begin_function
name|void
name|insn_print_units
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%s"
argument_list|,
name|function_units
index|[
name|unit
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
name|unit
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%s"
argument_list|,
name|function_units
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MAX_VISUAL_LINES is the maximum number of lines in visualization table    of a basic block.  If more lines are needed, table is split to two.    n_visual_lines is the number of lines printed so far for a block.    visual_tbl contains the block visualization info.    vis_no_unit holds insns in a cycle that are not mapped to any unit.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VISUAL_LINES
value|100
end_define

begin_define
define|#
directive|define
name|INSN_LEN
value|30
end_define

begin_decl_stmt
name|int
name|n_visual_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|visual_tbl_line_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|visual_tbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vis_no_unit
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_VISUAL_NO_UNIT
value|20
end_define

begin_decl_stmt
name|rtx
name|vis_no_unit
index|[
name|MAX_VISUAL_NO_UNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Finds units that are in use in this function.  Required only    for visualization.  */
end_comment

begin_function
name|void
name|init_target_units
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|unit
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
name|target_units
operator||=
operator|~
name|unit
expr_stmt|;
else|else
name|target_units
operator||=
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of the visualization table.  */
end_comment

begin_function
specifier|static
name|int
name|get_visual_tbl_length
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
name|visual_tbl_line_length
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
comment|/* Can't return 0 because that will cause problems                    with alloca.  */
block|}
comment|/* Compute length of one field in line.  */
name|s
operator|=
name|alloca
argument_list|(
name|INSN_LEN
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"  %33s"
argument_list|,
literal|"uname"
argument_list|)
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Compute length of one line.  */
name|n
operator|=
name|strlen
argument_list|(
literal|";; "
argument_list|)
expr_stmt|;
name|n
operator|+=
name|n1
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|n
operator|+=
name|n1
expr_stmt|;
name|n
operator|+=
name|n1
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
literal|"\n"
argument_list|)
operator|+
literal|2
expr_stmt|;
name|visual_tbl_line_length
operator|=
name|n
expr_stmt|;
comment|/* Compute length of visualization string.  */
return|return
operator|(
name|MAX_VISUAL_LINES
operator|*
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Init block visualization debugging info.  */
end_comment

begin_function
name|void
name|init_block_visualization
parameter_list|(
name|void
parameter_list|)
block|{
name|strcpy
argument_list|(
name|visual_tbl
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|n_visual_lines
operator|=
literal|0
expr_stmt|;
name|n_vis_no_unit
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_LEN
value|2048
end_define

begin_function
specifier|static
name|char
modifier|*
name|safe_concat
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|cur
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|buf
operator|+
name|BUF_LEN
operator|-
literal|2
decl_stmt|;
comment|/* Leave room for null.  */
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cur
operator|>
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
return|return
name|end
return|;
block|}
while|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cur
return|;
block|}
end_function

begin_comment
comment|/* This recognizes rtx, I classified as expressions.  These are always    represent some action on values or results of other expression, that    may be stored in objects representing values.  */
end_comment

begin_function
specifier|static
name|void
name|print_exp
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|tmp
index|[
name|BUF_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|st
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fun
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|rtx
name|op
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|st
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|op
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"+"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LO_SUM
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"+low("
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|")"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
name|fun
operator|=
literal|"cmp"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"*"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"/"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fun
operator|=
literal|"udiv"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"%"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fun
operator|=
literal|"umod"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|fun
operator|=
literal|"smin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|fun
operator|=
literal|"smax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|fun
operator|=
literal|"umin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|fun
operator|=
literal|"umax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"!"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"&"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"|"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"^"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|" 0>>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<-<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">->"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|fun
operator|=
literal|"abs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
name|fun
operator|=
literal|"sqrt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|fun
operator|=
literal|"ffs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"=="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"!="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fun
operator|=
literal|"gtu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fun
operator|=
literal|"ltu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fun
operator|=
literal|"geu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fun
operator|=
literal|"leu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extract"
else|:
literal|"sxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extract"
else|:
literal|"zxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extend"
else|:
literal|"sxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extend"
else|:
literal|"zxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_extend"
else|:
literal|"fxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"trunc"
else|:
literal|"trn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_trunc"
else|:
literal|"ftr"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float"
else|:
literal|"flt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_float"
else|:
literal|"ufl"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX
case|:
name|fun
operator|=
literal|"fix"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_fix"
else|:
literal|"ufx"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"--"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"++"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"--"
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"++"
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"call "
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|" argc:"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"{("
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|")?"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|":"
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|st
index|[
literal|3
index|]
operator|=
literal|"}"
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|fun
operator|=
literal|"trap_if"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREFETCH
case|:
name|fun
operator|=
literal|"prefetch"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"unspec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC_VOLATILE
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"/v"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|tmp
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|","
expr_stmt|;
block|}
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* If (verbose) debug_rtx (x);  */
name|st
index|[
literal|0
index|]
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Print this as a function?  */
if|if
condition|(
name|fun
condition|)
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|st
index|[
name|i
index|]
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|st
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|fun
operator|&&
name|i
operator|!=
literal|0
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|tmp
argument_list|,
name|op
index|[
name|i
index|]
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fun
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print_exp */
end_comment

begin_comment
comment|/* Prints rtxes, I customarily classified as values.  They're constants,    registers, labels, symbols and memory accesses.  */
end_comment

begin_function
specifier|static
name|void
name|print_value
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|real_to_decimal
argument_list|(
name|t
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"<0x%lx,0x%lx>"
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"const("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIGH
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"high("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|c
init|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"r%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"#%d"
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCRATCH
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"scratch"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC0
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"cc0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_exp
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* print_value */
end_comment

begin_comment
comment|/* The next step in insn detalization, its pattern recognition.  */
end_comment

begin_function
specifier|static
name|void
name|print_pattern
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t1
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t2
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t3
index|[
name|BUF_LEN
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|t2
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|print_exp
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"clobber %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"use %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|EQ
operator|&&
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|t1
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|print_value
argument_list|(
name|t1
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
name|print_value
argument_list|(
name|t1
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%s) %s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEQUENCE
case|:
comment|/* Should never see SEQUENCE codes until after reorg.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|ASM_INPUT
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"asm {%s}"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_VEC
case|:
break|break;
case|case
name|ADDR_DIFF_VEC
case|:
name|print_value
argument_list|(
name|buf
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"trap_if %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec/v{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_value
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_pattern */
end_comment

begin_comment
comment|/* This is the main function in rtl visualization mechanism. It    accepts an rtx and tries to recognize it as an insn, then prints it    properly in human readable form, resembling assembler mnemonics.    For every insn it prints its UID and BB the insn belongs too.    (Probably the last "option" should be extended somehow, since it    depends now on sched.c inner variables ...)  */
end_comment

begin_function
name|void
name|print_insn
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|rtx
name|insn
init|=
name|x
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: jump %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_pattern
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"call<...>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L%d:"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i% 4d: barrier"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%4d note \"%s\" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|x
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|verbose
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Not an INSN at all\n"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i%-4d<What?>"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_insn */
end_comment

begin_comment
comment|/* Print visualization debugging info.  The scheduler using only DFA    description should never use the following function.  */
end_comment

begin_function
name|void
name|print_block_visualization
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
comment|/* Print header.  */
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;   ==================== scheduling visualization %s \n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Print names of units.  */
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %-8s"
argument_list|,
literal|"clock"
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %-33s"
argument_list|,
name|function_units
index|[
name|unit
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %-8s\n"
argument_list|,
literal|"no-unit"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %-8s"
argument_list|,
literal|"====="
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %-33s"
argument_list|,
literal|"=============================="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %-8s\n"
argument_list|,
literal|"======="
argument_list|)
expr_stmt|;
comment|/* Print insns in each cycle.  */
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%s\n"
argument_list|,
name|visual_tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print insns in the 'no_unit' column of visualization.  */
end_comment

begin_function
name|void
name|visualize_no_unit
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|n_vis_no_unit
operator|<
name|MAX_VISUAL_NO_UNIT
condition|)
block|{
name|vis_no_unit
index|[
name|n_vis_no_unit
index|]
operator|=
name|insn
expr_stmt|;
name|n_vis_no_unit
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print insns scheduled in clock, for visualization.  */
end_comment

begin_function
name|void
name|visualize_scheduled_insns
parameter_list|(
name|int
name|clock
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|;
comment|/* If no more room, split table into two.  */
if|if
condition|(
name|n_visual_lines
operator|>=
name|MAX_VISUAL_LINES
condition|)
block|{
name|print_block_visualization
argument_list|(
literal|"(incomplete)"
argument_list|)
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
name|n_visual_lines
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|";;   %-8d"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
block|{
name|int
name|instance
init|=
name|unit
operator|+
name|i
operator|*
name|FUNCTION_UNITS_SIZE
decl_stmt|;
name|rtx
name|insn
init|=
name|get_unit_last_insn
argument_list|(
name|instance
argument_list|)
decl_stmt|;
comment|/* Print insns that still keep the unit busy.  */
if|if
condition|(
name|insn
operator|&&
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
name|str
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|print_insn
argument_list|(
name|str
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
index|[
name|INSN_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-33s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-33s"
argument_list|,
literal|"------------------------------"
argument_list|)
expr_stmt|;
block|}
comment|/* Print insns that are not assigned to any unit.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vis_no_unit
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-8d"
argument_list|,
name|INSN_UID
argument_list|(
name|vis_no_unit
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n_vis_no_unit
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print stalled cycles.  */
end_comment

begin_function
name|void
name|visualize_stall_cycles
parameter_list|(
name|int
name|stalls
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|prefix
init|=
literal|";;       "
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
literal|"\n"
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If no more room, split table into two.  */
if|if
condition|(
name|n_visual_lines
operator|>=
name|MAX_VISUAL_LINES
condition|)
block|{
name|print_block_visualization
argument_list|(
literal|"(incomplete)"
argument_list|)
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
name|n_visual_lines
operator|++
expr_stmt|;
name|p
operator|=
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|stalls
operator|>
name|visual_tbl_line_length
operator|-
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
name|strlen
argument_list|(
name|suffix
argument_list|)
condition|)
block|{
name|suffix
operator|=
literal|"[...]\n"
expr_stmt|;
name|stalls
operator|=
name|visual_tbl_line_length
operator|-
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|p
operator|+=
name|stalls
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate data used for visualization during scheduling.  */
end_comment

begin_function
name|void
name|visualize_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|visual_tbl
operator|=
name|xmalloc
argument_list|(
name|get_visual_tbl_length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data used for visualization.  */
end_comment

begin_function
name|void
name|visualize_free
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|visual_tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

