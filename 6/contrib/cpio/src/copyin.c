begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* copyin.c - extract or list a cpio archive    Copyright (C) 1990,1991,1992,2001,2002,2003,2004 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<system.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"filetypes.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"defer.h"
end_include

begin_include
include|#
directive|include
file|"dirname.h"
end_include

begin_include
include|#
directive|include
file|<rmt.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FNM_PATHNAME
end_ifndef

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LCHOWN
end_ifndef

begin_define
define|#
directive|define
name|lchown
value|chown
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|copyin_regular_file
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|warn_junk_bytes
parameter_list|(
name|long
name|bytes_skipped
parameter_list|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ngettext
argument_list|(
literal|"warning: skipped %ld byte of junk"
argument_list|,
literal|"warning: skipped %ld bytes of junk"
argument_list|,
name|bytes_skipped
argument_list|)
argument_list|,
name|bytes_skipped
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|query_rename
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|FILE
modifier|*
name|tty_in
parameter_list|,
name|FILE
modifier|*
name|tty_out
parameter_list|,
name|FILE
modifier|*
name|rename_in
parameter_list|)
block|{
name|char
modifier|*
name|str_res
decl_stmt|;
comment|/* Result for string function.  */
specifier|static
name|dynamic_string
name|new_name
decl_stmt|;
comment|/* New file name for rename option.  */
specifier|static
name|int
name|initialized_new_name
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|initialized_new_name
condition|)
block|{
name|ds_init
argument_list|(
operator|&
name|new_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|initialized_new_name
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|rename_flag
condition|)
block|{
name|fprintf
argument_list|(
name|tty_out
argument_list|,
name|_
argument_list|(
literal|"rename %s -> "
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
name|str_res
operator|=
name|ds_fgets
argument_list|(
name|tty_in
argument_list|,
operator|&
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str_res
operator|=
name|ds_fgetstr
argument_list|(
name|rename_in
argument_list|,
operator|&
name|new_name
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str_res
operator|==
name|NULL
operator|||
name|str_res
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
comment|/* Debian hack: file_hrd.c_name is sometimes set to      point to static memory by code in tar.c.  This      causes a segfault.  This has been fixed and an      additional check to ensure that the file name      is not too long has been added.  (Reported by      Horst Knobloch.)  This bug has been reported to      "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
name|xstrdup
argument_list|(
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_tar_filename_too_long
argument_list|(
name|new_name
operator|.
name|ds_string
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: file name too long"
argument_list|)
argument_list|,
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip the padding on IN_FILE_DES after a header or file,    up to the next header.    The number of bytes skipped is based on OFFSET -- the current offset    from the last start of a header (or file) -- and the current    header type.  */
end_comment

begin_function
specifier|static
name|void
name|tape_skip_padding
parameter_list|(
name|int
name|in_file_des
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|pad
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
operator|||
name|archive_format
operator|==
name|arf_newascii
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|%
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_binary
operator|||
name|archive_format
operator|==
name|arf_hpbinary
condition|)
name|pad
operator|=
operator|(
literal|2
operator|-
operator|(
name|offset
operator|%
literal|2
operator|)
operator|)
operator|%
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
name|pad
operator|=
operator|(
literal|512
operator|-
operator|(
name|offset
operator|%
literal|512
operator|)
operator|)
operator|%
literal|512
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|list_file
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
block|{
if|if
condition|(
name|verbose_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|char
modifier|*
name|link_name
init|=
name|NULL
decl_stmt|;
comment|/* Name of hard and symbolic links.  */
name|link_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_filesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|link_name
index|[
name|file_hdr
operator|->
name|c_filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|link_name
argument_list|,
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|long_format
argument_list|(
name|file_hdr
argument_list|,
name|link_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|long_format
argument_list|(
name|file_hdr
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
endif|#
directive|endif
name|long_format
argument_list|(
name|file_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Debian hack: Modified to print a list of filenames 	 terminiated by a null character when the -t and -0 	 flags are used.  This has been submitted as a 	 suggestion to "bug-gnu-utils@prep.ai.mit.edu".  -BEM */
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|name_end
argument_list|)
expr_stmt|;
block|}
name|crc
operator|=
literal|0
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_verify_crc_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
block|{
return|return;
comment|/* links don't have a checksum */
block|}
endif|#
directive|endif
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|->
name|c_chksum
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|try_existing_file
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|,
name|int
modifier|*
name|existing_dir
parameter_list|)
block|{
name|struct
name|stat
name|file_stat
decl_stmt|;
operator|*
name|existing_dir
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFDIR
operator|)
condition|)
block|{
comment|/* If there is already a directory there that 	     we are trying to create, don't complain about 	     it.  */
operator|*
name|existing_dir
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|unconditional_flag
operator|&&
name|file_hdr
operator|->
name|c_mtime
operator|<=
name|file_stat
operator|.
name|st_mtime
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s not created: newer or same age version exists"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Go to the next file.  */
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|?
name|rmdir
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
else|:
name|unlink
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot remove current %s"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Go to the next file.  */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The newc and crc formats store multiply linked copies of the same file     in the archive only once.  The actual data is attached to the last link     in the archive, and the other links all have a filesize of 0.  When a     file in the archive has multiple links and a filesize of 0, its data is     probably "attatched" to another file in the archive, so we can't create    it right away.  We have to "defer" creating it until we have created    the file that has the data "attatched" to it.  We keep a list of the    "defered" links on deferments.  */
end_comment

begin_decl_stmt
name|struct
name|deferment
modifier|*
name|deferments
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a file header to the deferments list.  For now they all just    go on one list, although we could optimize this if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|defer_copyin
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|)
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|create_deferment
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|deferments
expr_stmt|;
name|deferments
operator|=
name|d
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* We just created a file that (probably) has some other links to it    which have been defered.  Go through all of the links on the deferments    list and create any which are links to this file.  */
end_comment

begin_function
specifier|static
name|void
name|create_defered_links
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|)
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|struct
name|deferment
modifier|*
name|d_prev
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|link_res
decl_stmt|;
name|ino
operator|=
name|file_hdr
operator|->
name|c_ino
expr_stmt|;
name|maj
operator|=
name|file_hdr
operator|->
name|c_dev_maj
expr_stmt|;
name|min
operator|=
name|file_hdr
operator|->
name|c_dev_min
expr_stmt|;
name|d
operator|=
name|deferments
expr_stmt|;
name|d_prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|header
operator|.
name|c_ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_maj
operator|==
name|maj
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_min
operator|==
name|min
operator|)
condition|)
block|{
name|struct
name|deferment
modifier|*
name|d_free
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot link %s to %s"
argument_list|)
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_prev
operator|!=
name|NULL
condition|)
name|d_prev
operator|->
name|next
operator|=
name|d
operator|->
name|next
expr_stmt|;
else|else
name|deferments
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d_free
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free_deferment
argument_list|(
name|d_free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_prev
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We are skipping a file but there might be other links to it that we    did not skip, so we have to copy its data for the other links.  Find    the first link that we didn't skip and try to create that.  That will    then create the other deferred links.  */
end_comment

begin_function
specifier|static
name|int
name|create_defered_links_to_skipped
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|struct
name|deferment
modifier|*
name|d_prev
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|link_res
decl_stmt|;
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|==
literal|0
condition|)
block|{
comment|/* The file doesn't have any data attached to it so we don't have          to bother.  */
return|return
operator|-
literal|1
return|;
block|}
name|ino
operator|=
name|file_hdr
operator|->
name|c_ino
expr_stmt|;
name|maj
operator|=
name|file_hdr
operator|->
name|c_dev_maj
expr_stmt|;
name|min
operator|=
name|file_hdr
operator|->
name|c_dev_min
expr_stmt|;
name|d
operator|=
name|deferments
expr_stmt|;
name|d_prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|header
operator|.
name|c_ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_maj
operator|==
name|maj
operator|)
operator|&&
operator|(
name|d
operator|->
name|header
operator|.
name|c_dev_min
operator|==
name|min
operator|)
condition|)
block|{
if|if
condition|(
name|d_prev
operator|!=
name|NULL
condition|)
name|d_prev
operator|->
name|next
operator|=
name|d
operator|->
name|next
expr_stmt|;
else|else
name|deferments
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
name|xstrdup
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|free_deferment
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|copyin_regular_file
argument_list|(
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|d_prev
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If we had a multiply linked file that really was empty then we would    have defered all of its links, since we never found any with data    "attached", and they will still be on the deferment list even when    we are done reading the whole archive.  Write out all of these    empty links that are still on the deferments list.  */
end_comment

begin_function
specifier|static
name|void
name|create_final_defers
parameter_list|()
block|{
name|struct
name|deferment
modifier|*
name|d
decl_stmt|;
name|int
name|link_res
decl_stmt|;
name|int
name|out_file_des
decl_stmt|;
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deferments
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
comment|/* Debian hack: A line, which could cause an endless loop, was          removed (97/1/2).  It was reported by Ronald F. Guilmette to          the upstream maintainers. -BEM */
comment|/* Debian hack:  This was reported by Horst Knobloch. This bug has          been reported to "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM          */
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_dev_maj
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_dev_min
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|out_file_des
operator|=
name|open
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_file_des
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
name|out_file_des
operator|=
name|open
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*        *  Avoid race condition.        *  Set chown and chmod before closing the file desc.        *  pvrabec@redhat.com        */
comment|/* File is now copied; set attributes.  */
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|fchown
argument_list|(
name|out_file_des
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|d
operator|->
name|header
operator|.
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|d
operator|->
name|header
operator|.
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|fchmod
argument_list|(
name|out_file_des
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|header
operator|.
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|out_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|d
operator|->
name|header
operator|.
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|d
operator|->
name|header
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copyin_regular_file
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
block|{
name|int
name|out_file_des
decl_stmt|;
comment|/* Output file descriptor.  */
if|if
condition|(
name|to_stdout_option
condition|)
name|out_file_des
operator|=
name|STDOUT_FILENO
expr_stmt|;
else|else
block|{
comment|/* Can the current file be linked to a previously copied file? */
if|if
condition|(
name|file_hdr
operator|->
name|c_nlink
operator|>
literal|1
operator|&&
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
condition|)
block|{
name|int
name|link_res
decl_stmt|;
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|==
literal|0
condition|)
block|{
comment|/* The newc and crc formats store multiply linked copies 		 of the same file in the archive only once.  The 		 actual data is attached to the last link in the 		 archive, and the other links all have a filesize 		 of 0.  Since this file has multiple links and a 		 filesize of 0, its data is probably attatched to 		 another file in the archive.  Save the link, and 		 process it later when we get the actual data.  We 		 can't just create it with length 0 and add the 		 data later, in case the file is readonly.  We still 		 lose if its parent directory is readonly (and we aren't 		 running as root), but there's nothing we can do about 		 that.  */
name|defer_copyin
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the file has data (filesize != 0), then presumably 	     any other links have already been defer_copyin'ed(), 	     but GNU cpio version 2.0-2.2 didn't do that, so we 	     still have to check for links here (and also in case 	     the archive was created and later appeneded to). */
comment|/* Debian hack: (97/1/2) This was reported by Ronald 	     F. Guilmette to the upstream maintainers. -BEM */
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
name|file_hdr
operator|->
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|file_hdr
operator|->
name|c_nlink
operator|>
literal|1
operator|&&
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|int
name|link_res
decl_stmt|;
comment|/* Debian hack: (97/1/2) This was reported by Ronald 	     F. Guilmette to the upstream maintainers. -BEM */
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
name|file_hdr
operator|->
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
operator|)
operator|&&
name|file_hdr
operator|->
name|c_tar_linkname
operator|&&
name|file_hdr
operator|->
name|c_tar_linkname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot link %s to %s"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If not linked, copy the contents of the file.  */
name|out_file_des
operator|=
name|open
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_file_des
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|out_file_des
operator|=
name|open
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_file_des
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|crc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swap_halfwords_flag
condition|)
block|{
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_filesize
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
name|swapping_halfwords
operator|=
name|true
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"cannot swap halfwords of %s: odd number of halfwords"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_bytes_flag
condition|)
block|{
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_filesize
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
name|swapping_bytes
operator|=
name|true
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"cannot swap bytes of %s: odd number of bytes"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
name|copy_files_tape_to_disk
argument_list|(
name|in_file_des
argument_list|,
name|out_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|disk_empty_output_buffer
argument_list|(
name|out_file_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_stdout_option
condition|)
block|{
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|->
name|c_chksum
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
block|}
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Debian hack to fix a bug in the --sparse option.      This bug has been reported to      "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
if|if
condition|(
name|delayed_seek_count
operator|>
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|out_file_des
argument_list|,
name|delayed_seek_count
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|out_file_des
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|delayed_seek_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    *  Avoid race condition.    *  Set chown and chmod before closing the file desc.    *  pvrabec@redhat.com    */
comment|/* File is now copied; set attributes.  */
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|fchown
argument_list|(
name|out_file_des
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|->
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|->
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|fchmod
argument_list|(
name|out_file_des
argument_list|,
operator|(
name|int
operator|)
name|file_hdr
operator|->
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|out_file_des
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|->
name|c_chksum
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|->
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|->
name|c_nlink
operator|>
literal|1
operator|&&
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
condition|)
block|{
comment|/* (see comment above for how the newc and crc formats  	 store multiple links).  Now that we have the data  	 for this file, create any other links to it which 	 we defered.  */
name|create_defered_links
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copyin_directory
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|existing_dir
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
comment|/* Result of various function calls.  */
ifdef|#
directive|ifdef
name|HPUX_CDF
name|int
name|cdf_flag
decl_stmt|;
comment|/* True if file is a CDF.  */
name|int
name|cdf_char
decl_stmt|;
comment|/* Index of `+' char indicating a CDF.  */
endif|#
directive|endif
if|if
condition|(
name|to_stdout_option
condition|)
return|return;
comment|/* Strip any trailing `/'s off the filename; tar puts      them on.  We might as well do it here in case anybody      else does too, since they cause strange things to happen.  */
name|strip_trailing_slashes
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* Ignore the current directory.  It must already exist,      and we don't want to change its permission, ownership      or time.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|file_hdr
operator|->
name|c_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|HPUX_CDF
name|cdf_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|existing_dir
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUX_CDF
comment|/* If the directory name ends in a + and is SUID, 	 then it is a CDF.  Strip the trailing + from 	 the name before creating it.  */
name|cdf_char
operator|=
name|strlen
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cdf_char
operator|>
literal|0
operator|)
operator|&&
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
literal|04000
operator|)
operator|&&
operator|(
name|file_hdr
operator|->
name|c_name
index|[
name|cdf_char
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|file_hdr
operator|->
name|c_name
index|[
name|cdf_char
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cdf_flag
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|mkdir
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|res
operator|=
name|mkdir
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|/* In some odd cases where the file_hdr->c_name includes `.', 	 the directory may have actually been created by 	 create_all_directories(), so the mkdir will fail 	 because the directory exists.  If that's the case, 	 don't complain about it.  */
name|struct
name|stat
name|file_stat
decl_stmt|;
if|if
condition|(
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|lstat
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|->
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|->
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|(
name|int
operator|)
name|file_hdr
operator|->
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
if|if
condition|(
name|cdf_flag
condition|)
comment|/* Once we "hide" the directory with the chmod(),        we have to refer to it using name+ instead of name.  */
name|file_hdr
operator|->
name|c_name
index|[
name|cdf_char
index|]
operator|=
literal|'+'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|->
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copyin_device
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
comment|/* Result of various function calls.  */
if|if
condition|(
name|to_stdout_option
condition|)
return|return;
if|if
condition|(
name|file_hdr
operator|->
name|c_nlink
operator|>
literal|1
operator|&&
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|int
name|link_res
decl_stmt|;
comment|/* Debian hack:  This was reported by Horst 	 Knobloch. This bug has been reported to 	 "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
name|link_res
operator|=
name|link_to_maj_min_ino
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
name|file_hdr
operator|->
name|c_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|archive_format
operator|==
name|arf_ustar
operator|&&
name|file_hdr
operator|->
name|c_tar_linkname
operator|&&
name|file_hdr
operator|->
name|c_tar_linkname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|link_res
decl_stmt|;
name|link_res
operator|=
name|link_to_name
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot link %s to %s"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* Something must be wrong, because we couldn't 	     find the file to link to.  But can we assume 	     that the device maj/min numbers are correct 	     and fall through to the mknod?  It's probably 	     safer to just return, rather than possibly 	     creating a bogus device file.  */
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|CP_IFIFO
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFIFO
condition|)
name|res
operator|=
name|mkfifo
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|mknod
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|,
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_IFIFO
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFIFO
condition|)
name|res
operator|=
name|mkfifo
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|mknod
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|,
name|makedev
argument_list|(
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|chown
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|->
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|->
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* chown may have turned off some permissions we wanted. */
if|if
condition|(
name|chmod
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|retain_time_flag
condition|)
block|{
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* For setting file times.  */
comment|/* Initialize this in case it has members we don't know to set.  */
name|bzero
argument_list|(
operator|&
name|times
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utimbuf
argument_list|)
argument_list|)
expr_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|file_hdr
operator|->
name|c_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copyin_link
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
block|{
name|char
modifier|*
name|link_name
init|=
name|NULL
decl_stmt|;
comment|/* Name of hard and symbolic links.  */
name|int
name|res
decl_stmt|;
comment|/* Result of various function calls.  */
if|if
condition|(
name|to_stdout_option
condition|)
return|return;
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|link_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_filesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|link_name
index|[
name|file_hdr
operator|->
name|c_filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|link_name
argument_list|,
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_name
operator|=
name|xstrdup
argument_list|(
name|file_hdr
operator|->
name|c_tar_linkname
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|UMASKED_SYMLINK
argument_list|(
name|link_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|create_dir_flag
condition|)
block|{
name|create_all_directories
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|res
operator|=
name|UMASKED_SYMLINK
argument_list|(
name|link_name
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|,
name|file_hdr
operator|->
name|c_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|no_chown_flag
condition|)
if|if
condition|(
operator|(
name|lchown
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|set_owner_flag
condition|?
name|set_owner
else|:
name|file_hdr
operator|->
name|c_uid
argument_list|,
name|set_group_flag
condition|?
name|set_group
else|:
name|file_hdr
operator|->
name|c_gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copyin_file
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_file_des
parameter_list|)
block|{
name|int
name|existing_dir
decl_stmt|;
if|if
condition|(
operator|!
name|to_stdout_option
operator|&&
name|try_existing_file
argument_list|(
name|file_hdr
argument_list|,
name|in_file_des
argument_list|,
operator|&
name|existing_dir
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* Do the real copy or link.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFREG
case|:
name|copyin_regular_file
argument_list|(
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_IFDIR
case|:
name|copyin_directory
argument_list|(
name|file_hdr
argument_list|,
name|existing_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
name|copyin_device
argument_list|(
name|file_hdr
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CP_IFLNK
case|case
name|CP_IFLNK
case|:
name|copyin_link
argument_list|(
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: unknown file type"
argument_list|)
argument_list|,
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Current time for verbose table.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the file described by FILE_HDR in long format.    If LINK_NAME is nonzero, it is the name of the file that    this file is a symbolic link to.  */
end_comment

begin_function
name|void
name|long_format
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|char
modifier|*
name|link_name
parameter_list|)
block|{
name|char
name|mbuf
index|[
literal|11
index|]
decl_stmt|;
name|char
name|tbuf
index|[
literal|40
index|]
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|char
modifier|*
name|ptbuf
decl_stmt|;
specifier|static
name|int
name|d_first
init|=
operator|-
literal|1
decl_stmt|;
name|mode_string
argument_list|(
name|file_hdr
operator|->
name|c_mode
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|mbuf
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get time values ready to print.  */
name|when
operator|=
name|file_hdr
operator|->
name|c_mtime
expr_stmt|;
if|if
condition|(
name|d_first
operator|<
literal|0
condition|)
name|d_first
operator|=
operator|(
operator|*
name|nl_langinfo
argument_list|(
name|D_MD_ORDER
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
if|if
condition|(
name|current_time
operator|-
name|when
operator|>
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
operator|||
name|current_time
operator|-
name|when
operator|<
literal|0L
condition|)
name|ptbuf
operator|=
name|d_first
condition|?
literal|"%e %b  %Y"
else|:
literal|"%b %e  %Y"
expr_stmt|;
else|else
name|ptbuf
operator|=
name|d_first
condition|?
literal|"%e %b %R"
else|:
literal|"%b %e %R"
expr_stmt|;
name|strftime
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
name|ptbuf
argument_list|,
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|)
expr_stmt|;
name|ptbuf
operator|=
name|tbuf
expr_stmt|;
name|printf
argument_list|(
literal|"%s %3lu "
argument_list|,
name|mbuf
argument_list|,
name|file_hdr
operator|->
name|c_nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_uid
condition|)
name|printf
argument_list|(
literal|"%-8u %-8u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|file_hdr
operator|->
name|c_gid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8.8s %-8.8s "
argument_list|,
name|getuser
argument_list|(
name|file_hdr
operator|->
name|c_uid
argument_list|)
argument_list|,
name|getgroup
argument_list|(
name|file_hdr
operator|->
name|c_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFCHR
operator|||
operator|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFBLK
condition|)
name|printf
argument_list|(
literal|"%3lu, %3lu "
argument_list|,
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
name|file_hdr
operator|->
name|c_rdev_min
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%8lu "
argument_list|,
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|ptbuf
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_name
condition|)
block|{
name|printf
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|link_name
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_name_with_quoting
parameter_list|(
specifier|register
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|printf
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|printf
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a pattern file (for the -E option).  Put a list of    `num_patterns' elements in `save_patterns'.  Any patterns that were    already in `save_patterns' (from the command line) are preserved.  */
end_comment

begin_function
specifier|static
name|void
name|read_pattern_file
parameter_list|()
block|{
name|int
name|max_new_patterns
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_save_patterns
decl_stmt|;
name|int
name|new_num_patterns
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dynamic_string
name|pattern_name
decl_stmt|;
name|FILE
modifier|*
name|pattern_fp
decl_stmt|;
if|if
condition|(
name|num_patterns
operator|<
literal|0
condition|)
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|max_new_patterns
operator|=
literal|1
operator|+
name|num_patterns
expr_stmt|;
name|new_save_patterns
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_new_patterns
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_num_patterns
operator|=
name|num_patterns
expr_stmt|;
name|ds_init
argument_list|(
operator|&
name|pattern_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|pattern_fp
operator|=
name|fopen
argument_list|(
name|pattern_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|pattern_file_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ds_fgetstr
argument_list|(
name|pattern_fp
argument_list|,
operator|&
name|pattern_name
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|new_num_patterns
operator|>=
name|max_new_patterns
condition|)
block|{
name|max_new_patterns
operator|+=
literal|1
expr_stmt|;
name|new_save_patterns
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_save_patterns
argument_list|,
name|max_new_patterns
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_save_patterns
index|[
name|new_num_patterns
index|]
operator|=
name|xstrdup
argument_list|(
name|pattern_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
operator|++
name|new_num_patterns
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|pattern_fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|pattern_fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|pattern_file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
condition|;
operator|++
name|i
control|)
name|new_save_patterns
index|[
name|i
index|]
operator|=
name|save_patterns
index|[
name|i
index|]
expr_stmt|;
name|save_patterns
operator|=
name|new_save_patterns
expr_stmt|;
name|num_patterns
operator|=
name|new_num_patterns
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 16-bit integer I with the bytes swapped.  */
end_comment

begin_define
define|#
directive|define
name|swab_short
parameter_list|(
name|i
parameter_list|)
value|((((i)<< 8)& 0xff00) | (((i)>> 8)& 0x00ff))
end_define

begin_comment
comment|/* Read the header, including the name of the file, from file    descriptor IN_DES into FILE_HDR.  */
end_comment

begin_function
name|void
name|read_in_header
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_des
parameter_list|)
block|{
name|long
name|bytes_skipped
init|=
literal|0
decl_stmt|;
comment|/* Bytes of junk found before magic number.  */
comment|/* Search for a valid magic number.  */
if|if
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|check_tar
decl_stmt|;
name|int
name|peeked_bytes
decl_stmt|;
while|while
condition|(
name|archive_format
operator|==
name|arf_unknown
condition|)
block|{
name|peeked_bytes
operator|=
name|tape_buffered_peek
argument_list|(
name|tmpbuf
argument_list|,
name|in_des
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|peeked_bytes
operator|<
literal|6
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"premature end of archive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070701"
argument_list|,
literal|6
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_newascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070707"
argument_list|,
literal|6
argument_list|)
condition|)
name|archive_format
operator|=
name|arf_oldascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"070702"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|archive_format
operator|=
name|arf_crcascii
expr_stmt|;
name|crc_i_flag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|tmpbuf
operator|)
operator|==
literal|070707
operator|)
operator|||
operator|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|tmpbuf
operator|)
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
operator|)
condition|)
name|archive_format
operator|=
name|arf_binary
expr_stmt|;
elseif|else
if|if
condition|(
name|peeked_bytes
operator|>=
literal|512
operator|&&
operator|(
name|check_tar
operator|=
name|is_tar_header
argument_list|(
name|tmpbuf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|check_tar
operator|==
literal|2
condition|)
name|archive_format
operator|=
name|arf_ustar
expr_stmt|;
else|else
name|archive_format
operator|=
name|arf_tar
expr_stmt|;
block|}
else|else
block|{
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
operator|++
name|bytes_skipped
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_tar
operator|||
name|archive_format
operator|==
name|arf_ustar
condition|)
block|{
if|if
condition|(
name|append_flag
condition|)
name|last_header_start
operator|=
name|input_bytes
operator|-
name|io_block_size
operator|+
operator|(
name|in_buff
operator|-
name|input_buffer
operator|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|warn_junk_bytes
argument_list|(
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_tar_header
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
return|return;
block|}
name|file_hdr
operator|->
name|c_tar_linkname
operator|=
name|NULL
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
name|in_des
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|append_flag
condition|)
name|last_header_start
operator|=
name|input_bytes
operator|-
name|io_block_size
operator|+
operator|(
name|in_buff
operator|-
name|input_buffer
operator|)
operator|-
literal|6
expr_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070701"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|warn_junk_bytes
argument_list|(
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_new_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|archive_format
operator|==
name|arf_crcascii
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070702"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|warn_junk_bytes
argument_list|(
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_new_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_oldascii
operator|||
name|archive_format
operator|==
name|arf_hpoldascii
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|"070707"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|warn_junk_bytes
argument_list|(
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_old_ascii
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|archive_format
operator|==
name|arf_binary
operator|||
name|archive_format
operator|==
name|arf_hpbinary
operator|)
operator|&&
operator|(
name|file_hdr
operator|->
name|c_magic
operator|==
literal|070707
operator|||
name|file_hdr
operator|->
name|c_magic
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
operator|)
condition|)
block|{
comment|/* Having to skip 1 byte because of word alignment is normal.  */
if|if
condition|(
name|bytes_skipped
operator|>
literal|0
condition|)
name|warn_junk_bytes
argument_list|(
name|bytes_skipped
argument_list|)
expr_stmt|;
name|read_in_binary
argument_list|(
name|file_hdr
argument_list|,
name|in_des
argument_list|)
expr_stmt|;
break|break;
block|}
name|bytes_skipped
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_hdr
operator|+
literal|5
argument_list|,
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading an old-format ASCII format cpio header from    file descriptor IN_DES, except for the magic number, which is    already filled in.  */
end_comment

begin_function
name|void
name|read_in_old_ascii
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_des
parameter_list|)
block|{
name|char
name|ascii_header
index|[
literal|78
index|]
decl_stmt|;
name|unsigned
name|long
name|dev
decl_stmt|;
name|unsigned
name|long
name|rdev
decl_stmt|;
name|tape_buffered_read
argument_list|(
name|ascii_header
argument_list|,
name|in_des
argument_list|,
literal|70L
argument_list|)
expr_stmt|;
name|ascii_header
index|[
literal|70
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ascii_header
argument_list|,
literal|"%6lo%6lo%6lo%6lo%6lo%6lo%6lo%11lo%6lo%11lo"
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_ino
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mode
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_gid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_nlink
argument_list|,
operator|&
name|rdev
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mtime
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_namesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_maj
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_min
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
comment|/* HP/UX cpio creates archives that look just like ordinary archives,      but for devices it sets major = 0, minor = 1, and puts the      actual major/minor number in the filesize field.  See if this      is an HP/UX cpio archive, and if so fix it.  We have to do this      here because process_copy_in() assumes filesize is always 0      for devices.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|!=
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_maj
operator|==
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_min
operator|==
literal|1
condition|)
block|{
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading a new-format ASCII format cpio header from    file descriptor IN_DES, except for the magic number, which is    already filled in.  */
end_comment

begin_function
name|void
name|read_in_new_ascii
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_des
parameter_list|)
block|{
name|char
name|ascii_header
index|[
literal|112
index|]
decl_stmt|;
name|tape_buffered_read
argument_list|(
name|ascii_header
argument_list|,
name|in_des
argument_list|,
literal|104L
argument_list|)
expr_stmt|;
name|ascii_header
index|[
literal|104
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ascii_header
argument_list|,
literal|"%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx"
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_ino
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mode
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_uid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_gid
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_nlink
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_mtime
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_filesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_dev_maj
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_dev_min
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_rdev_maj
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_rdev_min
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_namesize
argument_list|,
operator|&
name|file_hdr
operator|->
name|c_chksum
argument_list|)
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
comment|/* In SVR4 ASCII format, the amount of space allocated for the header      is rounded up to the next long-word, so we might need to drop      1-3 bytes.  */
name|tape_skip_padding
argument_list|(
name|in_des
argument_list|,
name|file_hdr
operator|->
name|c_namesize
operator|+
literal|110
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in FILE_HDR by reading a binary format cpio header from    file descriptor IN_DES, except for the first 6 bytes (the magic    number, device, and inode number), which are already filled in.  */
end_comment

begin_function
name|void
name|read_in_binary
parameter_list|(
name|struct
name|new_cpio_header
modifier|*
name|file_hdr
parameter_list|,
name|int
name|in_des
parameter_list|)
block|{
name|struct
name|old_cpio_header
name|short_hdr
decl_stmt|;
comment|/* Copy the data into the short header, then later transfer      it into the argument long header.  */
name|short_hdr
operator|.
name|c_dev
operator|=
operator|(
operator|(
expr|struct
name|old_cpio_header
operator|*
operator|)
name|file_hdr
operator|)
operator|->
name|c_dev
expr_stmt|;
name|short_hdr
operator|.
name|c_ino
operator|=
operator|(
operator|(
expr|struct
name|old_cpio_header
operator|*
operator|)
name|file_hdr
operator|)
operator|->
name|c_ino
expr_stmt|;
name|tape_buffered_read
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|short_hdr
operator|)
operator|+
literal|6
argument_list|,
name|in_des
argument_list|,
literal|20L
argument_list|)
expr_stmt|;
comment|/* If the magic number is byte swapped, fix the header.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_magic
operator|==
name|swab_short
argument_list|(
operator|(
name|unsigned
name|short
operator|)
literal|070707
argument_list|)
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
comment|/* Alert the user that they might have to do byte swapping on 	 the file contents.  */
if|if
condition|(
name|warned
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"warning: archive header has reverse byte-order"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|swab_array
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|short_hdr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
name|file_hdr
operator|->
name|c_dev_maj
operator|=
name|major
argument_list|(
name|short_hdr
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_dev_min
operator|=
name|minor
argument_list|(
name|short_hdr
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_ino
operator|=
name|short_hdr
operator|.
name|c_ino
expr_stmt|;
name|file_hdr
operator|->
name|c_mode
operator|=
name|short_hdr
operator|.
name|c_mode
expr_stmt|;
name|file_hdr
operator|->
name|c_uid
operator|=
name|short_hdr
operator|.
name|c_uid
expr_stmt|;
name|file_hdr
operator|->
name|c_gid
operator|=
name|short_hdr
operator|.
name|c_gid
expr_stmt|;
name|file_hdr
operator|->
name|c_nlink
operator|=
name|short_hdr
operator|.
name|c_nlink
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|short_hdr
operator|.
name|c_rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|short_hdr
operator|.
name|c_rdev
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_mtime
operator|=
operator|(
name|unsigned
name|long
operator|)
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|0
index|]
operator|<<
literal|16
operator||
name|short_hdr
operator|.
name|c_mtimes
index|[
literal|1
index|]
expr_stmt|;
name|file_hdr
operator|->
name|c_namesize
operator|=
name|short_hdr
operator|.
name|c_namesize
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
operator|(
name|unsigned
name|long
operator|)
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|0
index|]
operator|<<
literal|16
operator||
name|short_hdr
operator|.
name|c_filesizes
index|[
literal|1
index|]
expr_stmt|;
comment|/* Read file name from input.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|tape_buffered_read
argument_list|(
name|file_hdr
operator|->
name|c_name
argument_list|,
name|in_des
argument_list|,
operator|(
name|long
operator|)
name|file_hdr
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
comment|/* In binary mode, the amount of space allocated in the header for      the filename is `c_namesize' rounded up to the next short-word,      so we might need to drop a byte.  */
if|if
condition|(
name|file_hdr
operator|->
name|c_namesize
operator|%
literal|2
condition|)
name|tape_toss_input
argument_list|(
name|in_des
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|/* HP/UX cpio creates archives that look just like ordinary archives,      but for devices it sets major = 0, minor = 1, and puts the      actual major/minor number in the filesize field.  See if this      is an HP/UX cpio archive, and if so fix it.  We have to do this      here because process_copy_in() assumes filesize is always 0      for devices.  */
switch|switch
condition|(
name|file_hdr
operator|->
name|c_mode
operator|&
name|CP_IFMT
condition|)
block|{
case|case
name|CP_IFCHR
case|:
case|case
name|CP_IFBLK
case|:
ifdef|#
directive|ifdef
name|CP_IFSOCK
case|case
name|CP_IFSOCK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_IFIFO
case|case
name|CP_IFIFO
case|:
endif|#
directive|endif
if|if
condition|(
name|file_hdr
operator|->
name|c_filesize
operator|!=
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_maj
operator|==
literal|0
operator|&&
name|file_hdr
operator|->
name|c_rdev_min
operator|==
literal|1
condition|)
block|{
name|file_hdr
operator|->
name|c_rdev_maj
operator|=
name|major
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_rdev_min
operator|=
name|minor
argument_list|(
name|file_hdr
operator|->
name|c_filesize
argument_list|)
expr_stmt|;
name|file_hdr
operator|->
name|c_filesize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Exchange the bytes of each element of the array of COUNT shorts    starting at PTR.  */
end_comment

begin_function
name|void
name|swab_array
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|char
name|tmp
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
name|tmp
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a safer suffix of FILE_NAME, or "." if it has no safer    suffix.  Check for fully specified file names and other atrocities.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|safer_name_suffix
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Skip file system prefixes, leading file name components that contain      "..", and leading slashes.  */
name|size_t
name|prefix_len
init|=
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|file_name
operator|+
name|prefix_len
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|ISSLASH
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|p
index|[
literal|2
index|]
operator|)
condition|)
name|prefix_len
operator|=
name|p
operator|+
literal|2
operator|-
name|file_name
expr_stmt|;
do|do
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|ISSLASH
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|p
condition|)
do|;
block|}
for|for
control|(
name|p
operator|=
name|file_name
operator|+
name|prefix_len
init|;
name|ISSLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|prefix_len
operator|=
name|p
operator|-
name|file_name
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
block|{
name|char
modifier|*
name|prefix
init|=
name|alloca
argument_list|(
name|prefix_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|prefix
argument_list|,
name|file_name
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|prefix
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Removing leading `%s' from member names"
argument_list|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|p
operator|=
literal|"."
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Read the collection from standard input and create files    in the file system.  */
end_comment

begin_function
name|void
name|process_copy_in
parameter_list|()
block|{
name|char
name|done
init|=
name|false
decl_stmt|;
comment|/* True if trailer reached.  */
name|FILE
modifier|*
name|tty_in
decl_stmt|;
comment|/* Interactive file for rename option.  */
name|FILE
modifier|*
name|tty_out
decl_stmt|;
comment|/* Interactive file for rename option.  */
name|FILE
modifier|*
name|rename_in
decl_stmt|;
comment|/* Batch file for rename option.  */
name|struct
name|stat
name|file_stat
decl_stmt|;
comment|/* Output file stat record.  */
name|struct
name|new_cpio_header
name|file_hdr
decl_stmt|;
comment|/* Output header information.  */
name|int
name|in_file_des
decl_stmt|;
comment|/* Input file descriptor.  */
name|char
name|skip_file
decl_stmt|;
comment|/* Flag for use with patterns.  */
name|int
name|i
decl_stmt|;
comment|/* Loop index variable.  */
comment|/* Initialize the copy in.  */
if|if
condition|(
name|pattern_file_name
condition|)
block|{
name|read_pattern_file
argument_list|()
expr_stmt|;
block|}
name|file_hdr
operator|.
name|c_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rename_batch_file
condition|)
block|{
name|rename_in
operator|=
name|fopen
argument_list|(
name|rename_batch_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_in
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|TTY_NAME
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rename_flag
condition|)
block|{
comment|/* Open interactive file pair for rename operation.  */
name|tty_in
operator|=
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_in
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|TTY_NAME
argument_list|)
expr_stmt|;
block|}
name|tty_out
operator|=
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_out
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|TTY_NAME
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get date and time if needed for processing the table option.  */
if|if
condition|(
name|table_flag
operator|&&
name|verbose_flag
condition|)
block|{
name|time
argument_list|(
operator|&
name|current_time
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether the input file might be a tape.  */
name|in_file_des
operator|=
name|archive_des
expr_stmt|;
if|if
condition|(
name|_isrmt
argument_list|(
name|in_file_des
argument_list|)
condition|)
block|{
name|input_is_special
operator|=
literal|1
expr_stmt|;
name|input_is_seekable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|in_file_des
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"standard input is closed"
argument_list|)
argument_list|)
expr_stmt|;
name|input_is_special
operator|=
ifdef|#
directive|ifdef
name|S_ISBLK
name|S_ISBLK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|||
endif|#
directive|endif
name|S_ISCHR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|input_is_seekable
operator|=
name|S_ISREG
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
name|output_is_seekable
operator|=
name|true
expr_stmt|;
comment|/* While there is more input in the collection, process the input.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|swapping_halfwords
operator|=
name|swapping_bytes
operator|=
name|false
expr_stmt|;
comment|/* Start processing the next file by reading the header.  */
name|read_in_header
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CPIO
if|if
condition|(
name|debug_flag
condition|)
block|{
name|struct
name|new_cpio_header
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|&
name|file_hdr
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"magic = 0%o, ino = %d, mode = 0%o, uid = %d, gid = %d\n"
argument_list|,
name|h
operator|->
name|c_magic
argument_list|,
name|h
operator|->
name|c_ino
argument_list|,
name|h
operator|->
name|c_mode
argument_list|,
name|h
operator|->
name|c_uid
argument_list|,
name|h
operator|->
name|c_gid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nlink = %d, mtime = %d, filesize = %d, dev_maj = 0x%x\n"
argument_list|,
name|h
operator|->
name|c_nlink
argument_list|,
name|h
operator|->
name|c_mtime
argument_list|,
name|h
operator|->
name|c_filesize
argument_list|,
name|h
operator|->
name|c_dev_maj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dev_min = 0x%x, rdev_maj = 0x%x, rdev_min = 0x%x, namesize = %d\n"
argument_list|,
name|h
operator|->
name|c_dev_min
argument_list|,
name|h
operator|->
name|c_rdev_maj
argument_list|,
name|h
operator|->
name|c_rdev_min
argument_list|,
name|h
operator|->
name|c_namesize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chksum = %d, name = \"%s\", tar_linkname = \"%s\"\n"
argument_list|,
name|h
operator|->
name|c_chksum
argument_list|,
name|h
operator|->
name|c_name
argument_list|,
name|h
operator|->
name|c_tar_linkname
condition|?
name|h
operator|->
name|c_tar_linkname
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Is this the header for the TRAILER file?  */
if|if
condition|(
name|strcmp
argument_list|(
literal|"TRAILER!!!"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Do we have to ignore absolute paths, and if so, does the filename          have an absolute path?  */
if|if
condition|(
operator|!
name|abs_paths_flag
operator|&&
name|file_hdr
operator|.
name|c_name
operator|&&
name|file_hdr
operator|.
name|c_name
index|[
literal|0
index|]
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|safer_name_suffix
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|file_hdr
operator|.
name|c_name
condition|)
block|{
comment|/* Debian hack: file_hrd.c_name is sometimes set to                  point to static memory by code in tar.c.  This                  causes a segfault.  Therefore, memmove is used                  instead of freeing and reallocating.  (Reported by                  Horst Knobloch.)  This bug has been reported to                  "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|file_hdr
operator|.
name|c_name
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Does the file name match one of the given patterns?  */
if|if
condition|(
name|num_patterns
operator|<=
literal|0
condition|)
name|skip_file
operator|=
name|false
expr_stmt|;
else|else
block|{
name|skip_file
operator|=
name|copy_matching_files
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_patterns
operator|&&
name|skip_file
operator|==
name|copy_matching_files
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|save_patterns
index|[
name|i
index|]
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|skip_file
operator|=
operator|!
name|copy_matching_files
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip_file
condition|)
block|{
comment|/* If we're skipping a file with links, there might be other 	     links that we didn't skip, and this file might have the 	     data for the links.  If it does, we'll copy in the data 	     to the links, but not to this file.  */
if|if
condition|(
name|file_hdr
operator|.
name|c_nlink
operator|>
literal|1
operator|&&
operator|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
operator|)
condition|)
block|{
if|if
condition|(
name|create_defered_links_to_skipped
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|table_flag
condition|)
block|{
name|list_file
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|append_flag
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|only_verify_crc_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|CP_IFLNK
if|if
condition|(
operator|(
name|file_hdr
operator|.
name|c_mode
operator|&
name|CP_IFMT
operator|)
operator|==
name|CP_IFLNK
condition|)
block|{
if|if
condition|(
name|archive_format
operator|!=
name|arf_tar
operator|&&
name|archive_format
operator|!=
name|arf_ustar
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
name|crc
operator|=
literal|0
expr_stmt|;
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|file_hdr
operator|.
name|c_chksum
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: checksum error (0x%x, should be 0x%x)"
argument_list|)
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|,
name|crc
argument_list|,
name|file_hdr
operator|.
name|c_chksum
argument_list|)
expr_stmt|;
block|}
comment|/* Debian hack: -v and -V now work with --only-verify-crc.             (99/11/10) -BEM */
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dot_flag
condition|)
block|{
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Copy the input file into the directory structure.  */
comment|/* Do we need to rename the file? */
if|if
condition|(
name|rename_flag
operator|||
name|rename_batch_file
condition|)
block|{
if|if
condition|(
name|query_rename
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|tty_in
argument_list|,
name|tty_out
argument_list|,
name|rename_in
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tape_toss_input
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
name|tape_skip_padding
argument_list|(
name|in_file_des
argument_list|,
name|file_hdr
operator|.
name|c_filesize
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|copyin_file
argument_list|(
operator|&
name|file_hdr
argument_list|,
name|in_file_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|file_hdr
operator|.
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dot_flag
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_flag
condition|)
return|return;
if|if
condition|(
name|archive_format
operator|==
name|arf_newascii
operator|||
name|archive_format
operator|==
name|arf_crcascii
condition|)
block|{
name|create_final_defers
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|int
name|blocks
decl_stmt|;
name|blocks
operator|=
operator|(
name|input_bytes
operator|+
name|io_block_size
operator|-
literal|1
operator|)
operator|/
name|io_block_size
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ngettext
argument_list|(
literal|"%d block\n"
argument_list|,
literal|"%d blocks\n"
argument_list|,
name|blocks
argument_list|)
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

