begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Getopt for GNU.    NOTE: getopt is now part of the C library, so if you don't know what    "Keep this file name-space clean" means, talk to drepper@gnu.org    before changing it!    Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001,2002,2003,2004 	Free Software Foundation, Inc.    This file is part of the GNU C Library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This tells Alpha OSF/1 not to define a getopt prototype in<stdio.h>.    Ditto for AIX 3.2 and<stdlib.h>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_NO_PROTO
end_ifndef

begin_define
define|#
directive|define
name|_NO_PROTO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* This needs to come after some library #include    to get __GNU_LIBRARY__ defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* Don't include stdlib.h for non-GNU C libraries because some of them    contain conflicting prototypes for getopt.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNU C library.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<unixlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|msgid
parameter_list|)
value|gettext (msgid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
end_if

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|attribute_hidden
end_ifndef

begin_define
define|#
directive|define
name|attribute_hidden
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Unlike standard Unix `getopt', functions like `getopt_long'    let the user intersperse the options with the other arguments.     As `getopt_long' works, it permutes the elements of ARGV so that,    when it is done, all the options precede everything else.  Thus    all application programs are extended to handle flexible argument order.     Using `getopt' or setting the environment variable POSIXLY_CORRECT    disables permutation.    Then the application's behavior is completely standard.     GNU application programs can use a third alternative mode in which    they can distinguish the relative order of options and other arguments.  */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"getopt_int.h"
end_include

begin_comment
comment|/* For communication from `getopt' to the caller.    When `getopt' finds an option that takes an argument,    the argument value is returned here.    Also, when `ordering' is RETURN_IN_ORDER,    each non-option ARGV-element is returned here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in ARGV of the next element to be scanned.    This is used for communication to and from the caller    and for communication between successive calls to `getopt'.     On entry to `getopt', zero means this is the first call; initialize.     When `getopt' returns -1, this is the index of the first of the    non-option elements that the caller should itself scan.     Otherwise, `optind' communicates from one call to the next    how much of ARGV has been scanned so far.  */
end_comment

begin_comment
comment|/* 1003.2 says this must be 1 before any call.  */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callers store zero here to inhibit the error message    for unrecognized options.  */
end_comment

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to an option character which was unrecognized.    This must be initialized on some systems to avoid linking in the    system's own getopt implementation.  */
end_comment

begin_decl_stmt
name|int
name|optopt
init|=
literal|'?'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a global copy of all internal members of getopt_data.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_getopt_data
name|getopt_data
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|__GNU_LIBRARY__
end_ifndef

begin_comment
comment|/* Avoid depending on library functions or files    whose names are inconsistent.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|getenv
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNU_LIBRARY__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Stored original parameters.    XXX This is no good solution.  We should rather copy the args so    that we can compare them later.  But we must not use malloc(3).  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|__libc_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|__libc_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bash 2.0 gives us an environment variable containing flags    indicating ARGV elements that should not be considered arguments.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NONOPTION_FLAGS
end_ifdef

begin_comment
comment|/* Defined in getopt_init.c  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__getopt_nonoption_flags
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NONOPTION_FLAGS
end_ifdef

begin_define
define|#
directive|define
name|SWAP_FLAGS
parameter_list|(
name|ch1
parameter_list|,
name|ch2
parameter_list|)
define|\
value|if (d->__nonoption_flags_len> 0)					      \     {									      \       char __tmp = __getopt_nonoption_flags[ch1];			      \       __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \       __getopt_nonoption_flags[ch2] = __tmp;				      \     }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SWAP_FLAGS
parameter_list|(
name|ch1
parameter_list|,
name|ch2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_LIBC */
end_comment

begin_define
define|#
directive|define
name|SWAP_FLAGS
parameter_list|(
name|ch1
parameter_list|,
name|ch2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBC */
end_comment

begin_comment
comment|/* Exchange two adjacent subsequences of ARGV.    One subsequence is elements [first_nonopt,last_nonopt)    which contains all the non-options that have been skipped so far.    The other is elements [last_nonopt,optind), which contains all    the options processed since those non-options were skipped.     `first_nonopt' and `last_nonopt' are relocated so that they describe    the new indices of the non-options in ARGV after they are moved.  */
end_comment

begin_function
specifier|static
name|void
name|exchange
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|struct
name|_getopt_data
modifier|*
name|d
parameter_list|)
block|{
name|int
name|bottom
init|=
name|d
operator|->
name|__first_nonopt
decl_stmt|;
name|int
name|middle
init|=
name|d
operator|->
name|__last_nonopt
decl_stmt|;
name|int
name|top
init|=
name|d
operator|->
name|optind
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* Exchange the shorter segment with the far end of the longer segment.      That puts the shorter segment into the right place.      It leaves the longer segment in the right place overall,      but it consists of two parts that need to be swapped next.  */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_NONOPTION_FLAGS
comment|/* First make sure the handling of the `__getopt_nonoption_flags'      string can work normally.  Our top argument must be in the range      of the string.  */
if|if
condition|(
name|d
operator|->
name|__nonoption_flags_len
operator|>
literal|0
operator|&&
name|top
operator|>=
name|d
operator|->
name|__nonoption_flags_max_len
condition|)
block|{
comment|/* We must extend the array.  The user plays games with us and 	 presents new arguments.  */
name|char
modifier|*
name|new_str
init|=
name|malloc
argument_list|(
name|top
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_str
operator|==
name|NULL
condition|)
name|d
operator|->
name|__nonoption_flags_len
operator|=
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
name|__mempcpy
argument_list|(
name|new_str
argument_list|,
name|__getopt_nonoption_flags
argument_list|,
name|d
operator|->
name|__nonoption_flags_max_len
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|top
operator|+
literal|1
operator|-
name|d
operator|->
name|__nonoption_flags_max_len
argument_list|)
expr_stmt|;
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
name|top
operator|+
literal|1
expr_stmt|;
name|__getopt_nonoption_flags
operator|=
name|new_str
expr_stmt|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
name|top
operator|>
name|middle
operator|&&
name|middle
operator|>
name|bottom
condition|)
block|{
if|if
condition|(
name|top
operator|-
name|middle
operator|>
name|middle
operator|-
name|bottom
condition|)
block|{
comment|/* Bottom segment is the short one.  */
name|int
name|len
init|=
name|middle
operator|-
name|bottom
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the top part of the top segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|SWAP_FLAGS
argument_list|(
name|bottom
operator|+
name|i
argument_list|,
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Exclude the moved bottom segment from further swapping.  */
name|top
operator|-=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Top segment is the short one.  */
name|int
name|len
init|=
name|top
operator|-
name|middle
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the bottom part of the bottom segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|middle
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|middle
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|SWAP_FLAGS
argument_list|(
name|bottom
operator|+
name|i
argument_list|,
name|middle
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Exclude the moved top segment from further swapping.  */
name|bottom
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Update records for the slots the non-options now occupy.  */
name|d
operator|->
name|__first_nonopt
operator|+=
operator|(
name|d
operator|->
name|optind
operator|-
name|d
operator|->
name|__last_nonopt
operator|)
expr_stmt|;
name|d
operator|->
name|__last_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the internal data when the first call is made.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_getopt_initialize
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|optstring
parameter_list|,
name|int
name|posixly_correct
parameter_list|,
name|struct
name|_getopt_data
modifier|*
name|d
parameter_list|)
block|{
comment|/* Start processing options with ARGV-element 1 (since ARGV-element 0      is the program name); the sequence of previously skipped      non-option ARGV-elements is empty.  */
name|d
operator|->
name|__first_nonopt
operator|=
name|d
operator|->
name|__last_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
name|d
operator|->
name|__nextchar
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|__posixly_correct
operator|=
name|posixly_correct
operator|||
operator|!
operator|!
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
expr_stmt|;
comment|/* Determine how to handle the ordering of options and nonoptions.  */
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|d
operator|->
name|__ordering
operator|=
name|RETURN_IN_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|d
operator|->
name|__ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|__posixly_correct
condition|)
name|d
operator|->
name|__ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
else|else
name|d
operator|->
name|__ordering
operator|=
name|PERMUTE
expr_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_NONOPTION_FLAGS
if|if
condition|(
operator|!
name|d
operator|->
name|__posixly_correct
operator|&&
name|argc
operator|==
name|__libc_argc
operator|&&
name|argv
operator|==
name|__libc_argv
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|__nonoption_flags_max_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__getopt_nonoption_flags
operator|==
name|NULL
operator|||
name|__getopt_nonoption_flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|orig_str
init|=
name|__getopt_nonoption_flags
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
name|strlen
argument_list|(
name|orig_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|__nonoption_flags_max_len
operator|<
name|argc
condition|)
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
name|argc
expr_stmt|;
name|__getopt_nonoption_flags
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|__nonoption_flags_max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|__getopt_nonoption_flags
operator|==
name|NULL
condition|)
name|d
operator|->
name|__nonoption_flags_max_len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|memset
argument_list|(
name|__mempcpy
argument_list|(
name|__getopt_nonoption_flags
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|d
operator|->
name|__nonoption_flags_max_len
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|__nonoption_flags_len
operator|=
name|d
operator|->
name|__nonoption_flags_max_len
expr_stmt|;
block|}
else|else
name|d
operator|->
name|__nonoption_flags_len
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|optstring
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan elements of ARGV (whose length is ARGC) for option characters    given in OPTSTRING.     If an element of ARGV starts with '-', and is not exactly "-" or "--",    then it is an option element.  The characters of this element    (aside from the initial '-') are option characters.  If `getopt'    is called repeatedly, it returns successively each of the option characters    from each of the option elements.     If `getopt' finds another option character, it returns that character,    updating `optind' and `nextchar' so that the next call to `getopt' can    resume the scan with the following option character or ARGV-element.     If there are no more option characters, `getopt' returns -1.    Then `optind' is the index in ARGV of the first ARGV-element    that is not an option.  (The ARGV-elements have been permuted    so that those that are not options now come last.)     OPTSTRING is a string containing the legitimate option characters.    If an option character is seen that is not listed in OPTSTRING,    return '?' after printing an error message.  If you set `opterr' to    zero, the error message is suppressed but we still return '?'.     If a char in OPTSTRING is followed by a colon, that means it wants an arg,    so the following text in the same ARGV-element, or the text of the following    ARGV-element, is returned in `optarg'.  Two colons mean an option that    wants an optional arg; if there is text in the current ARGV-element,    it is returned in `optarg', otherwise `optarg' is set to zero.     If OPTSTRING starts with `-' or `+', it requests different methods of    handling the non-option ARGV-elements.    See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.     Long-named options begin with `--' instead of `-'.    Their names may be abbreviated as long as the abbreviation is unique    or is an exact match for some defined option.  If they have an    argument, it follows the option name in the same ARGV-element, separated    from the option name by a `=', or else the in next ARGV-element.    When `getopt' finds a long-named option, it returns 0 if that option's    `flag' field is nonzero, the value of the option's `val' field    if the `flag' field is zero.     LONGOPTS is a vector of `struct option' terminated by an    element containing a name which is zero.     LONGIND returns the index in LONGOPT of the long-named option found.    It is only valid when a long-named option has been found by the most    recent call.     If LONG_ONLY is nonzero, '-' as well as '--' can introduce    long-named options.     If POSIXLY_CORRECT is nonzero, behave as if the POSIXLY_CORRECT    environment variable were set.  */
end_comment

begin_function
name|int
name|_getopt_internal_r
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|optstring
parameter_list|,
specifier|const
name|struct
name|option
modifier|*
name|longopts
parameter_list|,
name|int
modifier|*
name|longind
parameter_list|,
name|int
name|long_only
parameter_list|,
name|int
name|posixly_correct
parameter_list|,
name|struct
name|_getopt_data
modifier|*
name|d
parameter_list|)
block|{
name|int
name|print_errors
init|=
name|d
operator|->
name|opterr
decl_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|print_errors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|d
operator|->
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|optind
operator|==
literal|0
operator|||
operator|!
name|d
operator|->
name|__initialized
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|optind
operator|==
literal|0
condition|)
name|d
operator|->
name|optind
operator|=
literal|1
expr_stmt|;
comment|/* Don't scan ARGV[0], the program name.  */
name|optstring
operator|=
name|_getopt_initialize
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstring
argument_list|,
name|posixly_correct
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|__initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Test whether ARGV[optind] points to a non-option argument.      Either it does not have option syntax, or there is an environment flag      from the shell indicating it is not an option.  The later information      is only used when the used in the GNU libc.  */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_NONOPTION_FLAGS
define|#
directive|define
name|NONOPTION_P
value|(argv[d->optind][0] != '-' || argv[d->optind][1] == '\0' \ 		      || (d->optind< d->__nonoption_flags_len		      \&& __getopt_nonoption_flags[d->optind] == '1'))
else|#
directive|else
define|#
directive|define
name|NONOPTION_P
value|(argv[d->optind][0] != '-' || argv[d->optind][1] == '\0')
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|__nextchar
operator|==
name|NULL
operator|||
operator|*
name|d
operator|->
name|__nextchar
operator|==
literal|'\0'
condition|)
block|{
comment|/* Advance to the next ARGV-element.  */
comment|/* Give FIRST_NONOPT& LAST_NONOPT rational values if OPTIND has been 	 moved back by the user (who may also have changed the arguments).  */
if|if
condition|(
name|d
operator|->
name|__last_nonopt
operator|>
name|d
operator|->
name|optind
condition|)
name|d
operator|->
name|__last_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|__first_nonopt
operator|>
name|d
operator|->
name|optind
condition|)
name|d
operator|->
name|__first_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|__ordering
operator|==
name|PERMUTE
condition|)
block|{
comment|/* If we have just processed some options following some non-options, 	     exchange them so that the options come first.  */
if|if
condition|(
name|d
operator|->
name|__first_nonopt
operator|!=
name|d
operator|->
name|__last_nonopt
operator|&&
name|d
operator|->
name|__last_nonopt
operator|!=
name|d
operator|->
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|__last_nonopt
operator|!=
name|d
operator|->
name|optind
condition|)
name|d
operator|->
name|__first_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
comment|/* Skip any additional non-options 	     and extend the range of non-options previously skipped.  */
while|while
condition|(
name|d
operator|->
name|optind
operator|<
name|argc
operator|&&
name|NONOPTION_P
condition|)
name|d
operator|->
name|optind
operator|++
expr_stmt|;
name|d
operator|->
name|__last_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
block|}
comment|/* The special ARGV-element `--' means premature end of options. 	 Skip it like a null option, 	 then exchange with previous non-options as if it were an option, 	 then skip everything else like a non-option.  */
if|if
condition|(
name|d
operator|->
name|optind
operator|!=
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|d
operator|->
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|d
operator|->
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|__first_nonopt
operator|!=
name|d
operator|->
name|__last_nonopt
operator|&&
name|d
operator|->
name|__last_nonopt
operator|!=
name|d
operator|->
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|__first_nonopt
operator|==
name|d
operator|->
name|__last_nonopt
condition|)
name|d
operator|->
name|__first_nonopt
operator|=
name|d
operator|->
name|optind
expr_stmt|;
name|d
operator|->
name|__last_nonopt
operator|=
name|argc
expr_stmt|;
name|d
operator|->
name|optind
operator|=
name|argc
expr_stmt|;
block|}
comment|/* If we have done all the ARGV-elements, stop the scan 	 and back over any non-options that we skipped and permuted.  */
if|if
condition|(
name|d
operator|->
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Set the next-arg-index to point at the non-options 	     that we previously skipped, so the caller will digest them.  */
if|if
condition|(
name|d
operator|->
name|__first_nonopt
operator|!=
name|d
operator|->
name|__last_nonopt
condition|)
name|d
operator|->
name|optind
operator|=
name|d
operator|->
name|__first_nonopt
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If we have come to a non-option and did not permute it, 	 either stop the scan or describe it to the caller and pass it by.  */
if|if
condition|(
name|NONOPTION_P
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|__ordering
operator|==
name|REQUIRE_ORDER
condition|)
return|return
operator|-
literal|1
return|;
name|d
operator|->
name|optarg
operator|=
name|argv
index|[
name|d
operator|->
name|optind
operator|++
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We have found another option-ARGV-element. 	 Skip the initial punctuation.  */
name|d
operator|->
name|__nextchar
operator|=
operator|(
name|argv
index|[
name|d
operator|->
name|optind
index|]
operator|+
literal|1
operator|+
operator|(
name|longopts
operator|!=
name|NULL
operator|&&
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Decode the current option-ARGV-element.  */
comment|/* Check whether the ARGV-element is a long option.       If long_only and the ARGV-element has the form "-f", where f is      a valid short option, don't consider it an abbreviated form of      a long option that starts with f.  Otherwise there would be no      way to give the -f short option.       On the other hand, if there's a long option "fubar" and      the ARGV-element is "-fu", do consider that an abbreviation of      the long option, just like "--fu", and not "-f" with arg "u".       This distinction seems to be the most useful approach.  */
if|if
condition|(
name|longopts
operator|!=
name|NULL
operator|&&
operator|(
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
operator|(
name|long_only
operator|&&
operator|(
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|2
index|]
operator|||
operator|!
name|strchr
argument_list|(
name|optstring
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|nameend
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
name|NULL
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
name|int
name|indfound
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|option_index
decl_stmt|;
for|for
control|(
name|nameend
operator|=
name|d
operator|->
name|__nextchar
init|;
operator|*
name|nameend
operator|&&
operator|*
name|nameend
operator|!=
literal|'='
condition|;
name|nameend
operator|++
control|)
comment|/* Do nothing.  */
empty_stmt|;
comment|/* Test all long options for either exact match 	 or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|longopts
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|,
name|nameend
operator|-
name|d
operator|->
name|__nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|nameend
operator|-
name|d
operator|->
name|__nextchar
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
name|NULL
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|long_only
operator|||
name|pfound
operator|->
name|has_arg
operator|!=
name|p
operator|->
name|has_arg
operator|||
name|pfound
operator|->
name|flag
operator|!=
name|p
operator|->
name|flag
operator|||
name|pfound
operator|->
name|val
operator|!=
name|p
operator|->
name|val
condition|)
comment|/* Second or later nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
name|d
operator|->
name|optind
operator|++
expr_stmt|;
name|d
operator|->
name|optopt
operator|=
literal|0
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
name|d
operator|->
name|optind
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nameend
condition|)
block|{
comment|/* Don't test has_arg with>, because some C compilers don't 		 allow it to be used on enums.  */
if|if
condition|(
name|pfound
operator|->
name|has_arg
condition|)
name|d
operator|->
name|optarg
operator|=
name|nameend
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* --option */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `--%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `--%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* +option or -option */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `%c%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `%c%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
name|d
operator|->
name|optopt
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|optind
operator|<
name|argc
condition|)
name|d
operator|->
name|optarg
operator|=
name|argv
index|[
name|d
operator|->
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
name|d
operator|->
name|optopt
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|':'
else|:
literal|'?'
return|;
block|}
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|longind
operator|!=
name|NULL
condition|)
operator|*
name|longind
operator|=
name|option_index
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
comment|/* Can't find it as a long option.  If this is not getopt_long_only, 	 or the option starts with '--' or is not a valid short 	 option, then it's an error. 	 Otherwise interpret it as a short option.  */
if|if
condition|(
operator|!
name|long_only
operator|||
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
name|strchr
argument_list|(
name|optstring
argument_list|,
operator|*
name|d
operator|->
name|__nextchar
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* --option */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `--%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `--%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* +option or -option */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `%c%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `%c%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|=
operator|(
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|d
operator|->
name|optind
operator|++
expr_stmt|;
name|d
operator|->
name|optopt
operator|=
literal|0
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
comment|/* Look at and handle the next short option-character.  */
block|{
name|char
name|c
init|=
operator|*
name|d
operator|->
name|__nextchar
operator|++
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|strchr
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
decl_stmt|;
comment|/* Increment `optind' when we start to process its last character.  */
if|if
condition|(
operator|*
name|d
operator|->
name|__nextchar
operator|==
literal|'\0'
condition|)
operator|++
name|d
operator|->
name|optind
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|__posixly_correct
condition|)
block|{
comment|/* 1003.2 specifies the format of this message.  */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: illegal option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: illegal option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|n
operator|=
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: invalid option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: invalid option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|optopt
operator|=
name|c
expr_stmt|;
return|return
literal|'?'
return|;
block|}
comment|/* Convenience. Treat POSIX -W foo same as long option --foo */
if|if
condition|(
name|temp
index|[
literal|0
index|]
operator|==
literal|'W'
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|char
modifier|*
name|nameend
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
name|NULL
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
name|int
name|indfound
init|=
literal|0
decl_stmt|;
name|int
name|option_index
decl_stmt|;
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|d
operator|->
name|__nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|d
operator|->
name|optarg
operator|=
name|d
operator|->
name|__nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 	       we must advance to the next element now.  */
name|d
operator|->
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
comment|/* 1003.2 specifies the format of this message.  */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|optopt
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|c
operator|=
literal|':'
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
comment|/* We already incremented `d->optind' once; 	     increment it again when taking next ARGV-elt as argument.  */
name|d
operator|->
name|optarg
operator|=
name|argv
index|[
name|d
operator|->
name|optind
operator|++
index|]
expr_stmt|;
comment|/* optarg is now the argument, see if it's in the 	   table of longopts.  */
for|for
control|(
name|d
operator|->
name|__nextchar
operator|=
name|nameend
operator|=
name|d
operator|->
name|optarg
init|;
operator|*
name|nameend
operator|&&
operator|*
name|nameend
operator|!=
literal|'='
condition|;
name|nameend
operator|++
control|)
comment|/* Do nothing.  */
empty_stmt|;
comment|/* Test all long options for either exact match 	   or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|longopts
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|d
operator|->
name|__nextchar
argument_list|,
name|nameend
operator|-
name|d
operator|->
name|__nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|nameend
operator|-
name|d
operator|->
name|__nextchar
argument_list|)
operator|==
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
name|NULL
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
else|else
comment|/* Second or later nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"%s: option `-W %s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `-W %s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
name|d
operator|->
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
if|if
condition|(
operator|*
name|nameend
condition|)
block|{
comment|/* Don't test has_arg with>, because some C compilers don't 		   allow it to be used on enums.  */
if|if
condition|(
name|pfound
operator|->
name|has_arg
condition|)
name|d
operator|->
name|optarg
operator|=
name|nameend
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `-W %s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `-W %s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|optind
operator|<
name|argc
condition|)
name|d
operator|->
name|optarg
operator|=
name|argv
index|[
name|d
operator|->
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|d
operator|->
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
return|return
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|':'
else|:
literal|'?'
return|;
block|}
block|}
name|d
operator|->
name|__nextchar
operator|+=
name|strlen
argument_list|(
name|d
operator|->
name|__nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|longind
operator|!=
name|NULL
condition|)
operator|*
name|longind
operator|=
name|option_index
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
name|d
operator|->
name|__nextchar
operator|=
name|NULL
expr_stmt|;
return|return
literal|'W'
return|;
comment|/* Let the application handle it.   */
block|}
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|temp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* This is an option that accepts an argument optionally.  */
if|if
condition|(
operator|*
name|d
operator|->
name|__nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|d
operator|->
name|optarg
operator|=
name|d
operator|->
name|__nextchar
expr_stmt|;
name|d
operator|->
name|optind
operator|++
expr_stmt|;
block|}
else|else
name|d
operator|->
name|optarg
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|__nextchar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|d
operator|->
name|__nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|d
operator|->
name|optarg
operator|=
name|d
operator|->
name|__nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 		   we must advance to the next element now.  */
name|d
operator|->
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|print_errors
condition|)
block|{
comment|/* 1003.2 specifies the format of this message.  */
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_
argument_list|(
literal|"\ %s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|_IO_flockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|int
name|old_flags2
init|=
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
decl_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator||=
name|_IO_FLAGS2_NOTCANCEL
expr_stmt|;
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stderr
argument_list|,
literal|L"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|stderr
operator|)
operator|->
name|_flags2
operator|=
name|old_flags2
expr_stmt|;
name|_IO_funlockfile
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|optopt
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|c
operator|=
literal|':'
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
comment|/* We already incremented `optind' once; 		 increment it again when taking next ARGV-elt as argument.  */
name|d
operator|->
name|optarg
operator|=
name|argv
index|[
name|d
operator|->
name|optind
operator|++
index|]
expr_stmt|;
name|d
operator|->
name|__nextchar
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
name|int
name|_getopt_internal
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|optstring
parameter_list|,
specifier|const
name|struct
name|option
modifier|*
name|longopts
parameter_list|,
name|int
modifier|*
name|longind
parameter_list|,
name|int
name|long_only
parameter_list|,
name|int
name|posixly_correct
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|getopt_data
operator|.
name|optind
operator|=
name|optind
expr_stmt|;
name|getopt_data
operator|.
name|opterr
operator|=
name|opterr
expr_stmt|;
name|result
operator|=
name|_getopt_internal_r
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstring
argument_list|,
name|longopts
argument_list|,
name|longind
argument_list|,
name|long_only
argument_list|,
name|posixly_correct
argument_list|,
operator|&
name|getopt_data
argument_list|)
expr_stmt|;
name|optind
operator|=
name|getopt_data
operator|.
name|optind
expr_stmt|;
name|optarg
operator|=
name|getopt_data
operator|.
name|optarg
expr_stmt|;
name|optopt
operator|=
name|getopt_data
operator|.
name|optopt
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* glibc gets a LSB-compliant getopt.    Standalone applications get a POSIX-compliant getopt.  */
end_comment

begin_if
if|#
directive|if
name|_LIBC
end_if

begin_enum
enum|enum
block|{
name|POSIXLY_CORRECT
init|=
literal|0
block|}
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_enum
enum|enum
block|{
name|POSIXLY_CORRECT
init|=
literal|1
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getopt
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|optstring
parameter_list|)
block|{
return|return
name|_getopt_internal
argument_list|(
name|argc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|optstring
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|POSIXLY_CORRECT
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Compile with -DTEST to make an executable for use in testing    the above definition of `getopt'.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|digit_optind
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|this_option_optind
init|=
name|optind
condition|?
name|optind
else|:
literal|1
decl_stmt|;
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abc:d:0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|digit_optind
operator|!=
literal|0
operator|&&
name|digit_optind
operator|!=
name|this_option_optind
condition|)
name|printf
argument_list|(
literal|"digits occur in two different argv-elements.\n"
argument_list|)
expr_stmt|;
name|digit_optind
operator|=
name|this_option_optind
expr_stmt|;
name|printf
argument_list|(
literal|"option %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"option a\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printf
argument_list|(
literal|"option b\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
literal|"option c with value `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"?? getopt returned character code 0%o ??\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"non-option ARGV-elements: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

