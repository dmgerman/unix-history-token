begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input_scrub.c - Break up input buffers into whole numbers of lines.    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    2000    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Need this to make errno declaration right */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"input-file.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"listing.h"
end_include

begin_comment
comment|/*  * O/S independent module to supply buffers of sanitised source code  * to rest of assembler.  We get sanitised input data of arbitrary length.  * We break these buffers on line boundaries, recombine pieces that  * were broken across buffers, and return a buffer of full lines to  * the caller.  * The last partial line begins the next buffer we build and return to caller.  * The buffer returned to caller is preceded by BEFORE_STRING and followed  * by AFTER_STRING, as sentinels. The last character before AFTER_STRING  * is a newline.  * Also looks after line numbers, for e.g. error messages.  */
end_comment

begin_comment
comment|/*  * We don't care how filthy our buffers are, but our callers assume  * that the following sanitation has already been done.  *  * No comments, reduce a comment to a space.  * Reduce a tab to a space unless it is 1st char of line.  * All multiple tabs and spaces collapsed into 1 char. Tab only  *   legal if 1st char of line.  * # line file statements converted to .line x;.file y; statements.  * Escaped newlines at end of line: remove them but add as many newlines  *   to end of statement as you removed in the middle, to synch line numbers.  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|BEFORE_STRING
value|("\n")
end_define

begin_define
define|#
directive|define
name|AFTER_STRING
value|("\0")
end_define

begin_comment
comment|/* memcpy of 0 chars might choke.  */
end_comment

begin_define
define|#
directive|define
name|BEFORE_SIZE
value|(1)
end_define

begin_define
define|#
directive|define
name|AFTER_SIZE
value|(1)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->1st char of full buffer area.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|partial_where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->after last full line in buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|partial_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>=0. Number of chars in partial line in buffer.  */
end_comment

begin_comment
comment|/* Because we need AFTER_STRING just after last full line, it clobbers    1st part of partial line. So we preserve 1st part of partial line    here.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_source
index|[
name|AFTER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What is the largest size buffer that input_file_give_next_buffer()    could return to us?  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index into an sb structure we are reading from.  -1 if none.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sb_index
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are reading from an sb structure, this is it.  */
end_comment

begin_decl_stmt
specifier|static
name|sb
name|from_sb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we do a conditional check on from_sb? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|from_sb_is_expansion
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nested sb structures we have included.  */
end_comment

begin_decl_stmt
name|int
name|macro_nest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can have more than one source file open at once, though the info for all    but the latest one are saved off in a struct input_save.  These files remain    open, so we are limited by the number of open files allowed by the    underlying OS. We may also sequentially read more than one source file in an    assembly.  */
end_comment

begin_comment
comment|/* We must track the physical file and line number for error messages. We also    track a "logical" file and line number corresponding to (C?)  compiler    source line numbers.  Whenever we open a file we must fill in    physical_input_file. So if it is NULL we have not opened any files yet.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|physical_input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logical_input_file
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
name|line_numberT
typedef|;
end_typedef

begin_comment
comment|/* 1-origin line number in a source file.  */
end_comment

begin_comment
comment|/* A line ends in '\n' or eof.  */
end_comment

begin_decl_stmt
specifier|static
name|line_numberT
name|physical_input_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logical_input_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Struct used to save the state of the input handler during include files */
end_comment

begin_struct
struct|struct
name|input_save
block|{
name|char
modifier|*
name|buffer_start
decl_stmt|;
name|char
modifier|*
name|partial_where
decl_stmt|;
name|int
name|partial_size
decl_stmt|;
name|char
name|save_source
index|[
name|AFTER_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|buffer_length
decl_stmt|;
name|char
modifier|*
name|physical_input_file
decl_stmt|;
name|char
modifier|*
name|logical_input_file
decl_stmt|;
name|line_numberT
name|physical_input_line
decl_stmt|;
name|int
name|logical_input_line
decl_stmt|;
name|int
name|sb_index
decl_stmt|;
name|sb
name|from_sb
decl_stmt|;
name|int
name|from_sb_is_expansion
decl_stmt|;
comment|/* Should we do a conditional check?  */
name|struct
name|input_save
modifier|*
name|next_saved_file
decl_stmt|;
comment|/* Chain of input_saves.  */
name|char
modifier|*
name|input_file_save
decl_stmt|;
comment|/* Saved state of input routines.  */
name|char
modifier|*
name|saved_position
decl_stmt|;
comment|/* Caller's saved position in buf.  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|input_save
modifier|*
name|input_scrub_push
parameter_list|(
name|char
modifier|*
name|saved_position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|input_scrub_pop
parameter_list|(
name|struct
name|input_save
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|as_1_char
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Saved information about the file that .include'd this one.  When we hit EOF,    we automatically pop to that file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|input_save
modifier|*
name|next_saved_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the state of input reading and scrubbing so that we can #include.    The return value is a 'void *' (fudged for old compilers) to a save    area, which can be restored by passing it to input_scrub_pop().  */
end_comment

begin_function
specifier|static
name|struct
name|input_save
modifier|*
name|input_scrub_push
parameter_list|(
name|char
modifier|*
name|saved_position
parameter_list|)
block|{
specifier|register
name|struct
name|input_save
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|(
expr|struct
name|input_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|saved
argument_list|)
expr_stmt|;
name|saved
operator|->
name|saved_position
operator|=
name|saved_position
expr_stmt|;
name|saved
operator|->
name|buffer_start
operator|=
name|buffer_start
expr_stmt|;
name|saved
operator|->
name|partial_where
operator|=
name|partial_where
expr_stmt|;
name|saved
operator|->
name|partial_size
operator|=
name|partial_size
expr_stmt|;
name|saved
operator|->
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|saved
operator|->
name|physical_input_file
operator|=
name|physical_input_file
expr_stmt|;
name|saved
operator|->
name|logical_input_file
operator|=
name|logical_input_file
expr_stmt|;
name|saved
operator|->
name|physical_input_line
operator|=
name|physical_input_line
expr_stmt|;
name|saved
operator|->
name|logical_input_line
operator|=
name|logical_input_line
expr_stmt|;
name|saved
operator|->
name|sb_index
operator|=
name|sb_index
expr_stmt|;
name|saved
operator|->
name|from_sb
operator|=
name|from_sb
expr_stmt|;
name|saved
operator|->
name|from_sb_is_expansion
operator|=
name|from_sb_is_expansion
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|save_source
argument_list|,
name|save_source
argument_list|,
sizeof|sizeof
argument_list|(
name|save_source
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|next_saved_file
operator|=
name|next_saved_file
expr_stmt|;
name|saved
operator|->
name|input_file_save
operator|=
name|input_file_push
argument_list|()
expr_stmt|;
name|input_file_begin
argument_list|()
expr_stmt|;
comment|/* Reinitialize! */
name|logical_input_line
operator|=
operator|-
literal|1
expr_stmt|;
name|logical_input_file
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|buffer_length
operator|=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|sb_index
operator|=
operator|-
literal|1
expr_stmt|;
name|buffer_start
operator|=
name|xmalloc
argument_list|(
operator|(
name|BEFORE_SIZE
operator|+
name|buffer_length
operator|+
name|buffer_length
operator|+
name|AFTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
argument_list|,
name|BEFORE_STRING
argument_list|,
operator|(
name|int
operator|)
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
return|return
name|saved
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|input_scrub_pop
parameter_list|(
name|struct
name|input_save
modifier|*
name|saved
parameter_list|)
block|{
name|char
modifier|*
name|saved_position
decl_stmt|;
name|input_scrub_end
argument_list|()
expr_stmt|;
comment|/* Finish off old buffer */
name|input_file_pop
argument_list|(
name|saved
operator|->
name|input_file_save
argument_list|)
expr_stmt|;
name|saved_position
operator|=
name|saved
operator|->
name|saved_position
expr_stmt|;
name|buffer_start
operator|=
name|saved
operator|->
name|buffer_start
expr_stmt|;
name|buffer_length
operator|=
name|saved
operator|->
name|buffer_length
expr_stmt|;
name|physical_input_file
operator|=
name|saved
operator|->
name|physical_input_file
expr_stmt|;
name|logical_input_file
operator|=
name|saved
operator|->
name|logical_input_file
expr_stmt|;
name|physical_input_line
operator|=
name|saved
operator|->
name|physical_input_line
expr_stmt|;
name|logical_input_line
operator|=
name|saved
operator|->
name|logical_input_line
expr_stmt|;
name|sb_index
operator|=
name|saved
operator|->
name|sb_index
expr_stmt|;
name|from_sb
operator|=
name|saved
operator|->
name|from_sb
expr_stmt|;
name|from_sb_is_expansion
operator|=
name|saved
operator|->
name|from_sb_is_expansion
expr_stmt|;
name|partial_where
operator|=
name|saved
operator|->
name|partial_where
expr_stmt|;
name|partial_size
operator|=
name|saved
operator|->
name|partial_size
expr_stmt|;
name|next_saved_file
operator|=
name|saved
operator|->
name|next_saved_file
expr_stmt|;
name|memcpy
argument_list|(
name|save_source
argument_list|,
name|saved
operator|->
name|save_source
argument_list|,
sizeof|sizeof
argument_list|(
name|save_source
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved
argument_list|)
expr_stmt|;
return|return
name|saved_position
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|input_scrub_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|know
argument_list|(
name|strlen
argument_list|(
name|BEFORE_STRING
argument_list|)
operator|==
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|strlen
argument_list|(
name|AFTER_STRING
argument_list|)
operator|==
name|AFTER_SIZE
operator|||
operator|(
name|AFTER_STRING
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|AFTER_SIZE
operator|==
literal|1
operator|)
argument_list|)
expr_stmt|;
name|input_file_begin
argument_list|()
expr_stmt|;
name|buffer_length
operator|=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|buffer_start
operator|=
name|xmalloc
argument_list|(
operator|(
name|BEFORE_SIZE
operator|+
name|buffer_length
operator|+
name|buffer_length
operator|+
name|AFTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
argument_list|,
name|BEFORE_STRING
argument_list|,
operator|(
name|int
operator|)
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
comment|/* Line number things.  */
name|logical_input_line
operator|=
operator|-
literal|1
expr_stmt|;
name|logical_input_file
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|physical_input_file
operator|=
name|NULL
expr_stmt|;
comment|/* No file read yet.  */
name|next_saved_file
operator|=
name|NULL
expr_stmt|;
comment|/* At EOF, don't pop to any other file */
name|do_scrub_begin
argument_list|(
name|flag_m68k_mri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|input_scrub_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|buffer_start
condition|)
block|{
name|free
argument_list|(
name|buffer_start
argument_list|)
expr_stmt|;
name|buffer_start
operator|=
literal|0
expr_stmt|;
name|input_file_end
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start reading input from a new file.    Return start of caller's part of buffer.  */
end_comment

begin_function
name|char
modifier|*
name|input_scrub_new_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|input_file_open
argument_list|(
name|filename
argument_list|,
operator|!
name|flag_no_comments
argument_list|)
expr_stmt|;
name|physical_input_file
operator|=
name|filename
index|[
literal|0
index|]
condition|?
name|filename
else|:
name|_
argument_list|(
literal|"{standard input}"
argument_list|)
expr_stmt|;
name|physical_input_line
operator|=
literal|0
expr_stmt|;
name|partial_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Include a file from the current file.  Save our state, cause it to    be restored on EOF, and begin handling a new file.  Same result as    input_scrub_new_file.  */
end_comment

begin_function
name|char
modifier|*
name|input_scrub_include_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|position
parameter_list|)
block|{
name|next_saved_file
operator|=
name|input_scrub_push
argument_list|(
name|position
argument_list|)
expr_stmt|;
return|return
name|input_scrub_new_file
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start getting input from an sb structure.  This is used when    expanding a macro.  */
end_comment

begin_function
name|void
name|input_scrub_include_sb
parameter_list|(
name|sb
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|position
parameter_list|,
name|int
name|is_expansion
parameter_list|)
block|{
if|if
condition|(
name|macro_nest
operator|>
name|max_macro_nest
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"macros nested too deeply"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|macro_nest
expr_stmt|;
ifdef|#
directive|ifdef
name|md_macro_start
if|if
condition|(
name|is_expansion
condition|)
block|{
name|md_macro_start
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|next_saved_file
operator|=
name|input_scrub_push
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|from_sb
argument_list|)
expr_stmt|;
name|from_sb_is_expansion
operator|=
name|is_expansion
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|len
operator|>=
literal|1
operator|&&
name|from
operator|->
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Add the sentinel required by read.c.  */
name|sb_add_char
argument_list|(
operator|&
name|from_sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|sb_add_sb
argument_list|(
operator|&
name|from_sb
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|sb_index
operator|=
literal|1
expr_stmt|;
comment|/* These variables are reset by input_scrub_push.  Restore them      since we are, after all, still at the same point in the file.  */
name|logical_input_line
operator|=
name|next_saved_file
operator|->
name|logical_input_line
expr_stmt|;
name|logical_input_file
operator|=
name|next_saved_file
operator|->
name|logical_input_file
expr_stmt|;
block|}
end_function

begin_function
name|void
name|input_scrub_close
parameter_list|(
name|void
parameter_list|)
block|{
name|input_file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|input_scrub_next_buffer
parameter_list|(
name|char
modifier|*
modifier|*
name|bufp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|limit
decl_stmt|;
comment|/*->just after last char of buffer.  */
if|if
condition|(
name|sb_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sb_index
operator|>=
name|from_sb
operator|.
name|len
condition|)
block|{
name|sb_kill
argument_list|(
operator|&
name|from_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_sb_is_expansion
condition|)
block|{
name|cond_finish_check
argument_list|(
name|macro_nest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_macro_end
comment|/* Allow the target to clean up per-macro expansion 	         data.  */
name|md_macro_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|--
name|macro_nest
expr_stmt|;
name|partial_where
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|next_saved_file
operator|!=
name|NULL
condition|)
operator|*
name|bufp
operator|=
name|input_scrub_pop
argument_list|(
name|next_saved_file
argument_list|)
expr_stmt|;
return|return
name|partial_where
return|;
block|}
name|partial_where
operator|=
name|from_sb
operator|.
name|ptr
operator|+
name|from_sb
operator|.
name|len
expr_stmt|;
name|partial_size
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|=
name|from_sb
operator|.
name|ptr
operator|+
name|sb_index
expr_stmt|;
name|sb_index
operator|=
name|from_sb
operator|.
name|len
expr_stmt|;
return|return
name|partial_where
return|;
block|}
operator|*
name|bufp
operator|=
name|buffer_start
operator|+
name|BEFORE_SIZE
expr_stmt|;
if|if
condition|(
name|partial_size
condition|)
block|{
name|memcpy
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
name|partial_where
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|partial_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
name|save_source
argument_list|,
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
name|limit
operator|=
name|input_file_give_next_buffer
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|+
name|partial_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find last newline.  */
for|for
control|(
name|p
operator|=
name|limit
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|--
name|p
control|)
empty_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|buffer_start
operator|+
name|BEFORE_SIZE
condition|)
block|{
name|int
name|limoff
decl_stmt|;
name|limoff
operator|=
name|limit
operator|-
name|buffer_start
expr_stmt|;
name|buffer_length
operator|+=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|buffer_start
operator|=
name|xrealloc
argument_list|(
name|buffer_start
argument_list|,
operator|(
name|BEFORE_SIZE
operator|+
literal|2
operator|*
name|buffer_length
operator|+
name|AFTER_SIZE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|buffer_start
operator|+
name|BEFORE_SIZE
expr_stmt|;
name|limit
operator|=
name|input_file_give_next_buffer
argument_list|(
name|buffer_start
operator|+
name|limoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"partial line at end of file ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|partial_where
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|next_saved_file
condition|)
operator|*
name|bufp
operator|=
name|input_scrub_pop
argument_list|(
name|next_saved_file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|p
operator|=
name|limit
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|--
name|p
control|)
empty_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|partial_where
operator|=
name|p
expr_stmt|;
name|partial_size
operator|=
name|limit
operator|-
name|p
expr_stmt|;
name|memcpy
argument_list|(
name|save_source
argument_list|,
name|partial_where
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|partial_where
argument_list|,
name|AFTER_STRING
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partial_where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial_size
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"partial line at end of file ignored"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the listing we've finished the file.  */
name|LISTING_EOF
argument_list|()
expr_stmt|;
comment|/* If we should pop to another file at EOF, do it.  */
if|if
condition|(
name|next_saved_file
condition|)
block|{
operator|*
name|bufp
operator|=
name|input_scrub_pop
argument_list|(
name|next_saved_file
argument_list|)
expr_stmt|;
comment|/* Pop state */
comment|/* partial_where is now correct to return, since we popped it.  */
block|}
block|}
return|return
operator|(
name|partial_where
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The remaining part of this file deals with line numbers, error    messages and so on.  Return TRUE if we opened any file.  */
end_comment

begin_function
name|int
name|seen_at_least_1_file
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|physical_input_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bump_line_counters
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sb_index
operator|<
literal|0
condition|)
block|{
operator|++
name|physical_input_line
expr_stmt|;
if|if
condition|(
name|logical_input_line
operator|>=
literal|0
condition|)
operator|++
name|logical_input_line
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tells us what the new logical line number and file are.    If the line_number is -1, we don't change the current logical line    number.  If it is -2, we decrement the logical line number (this is    to support the .appfile pseudo-op inserted into the stream by    do_scrub_chars).    If the fname is NULL, we don't change the current logical file name.    Returns nonzero if the filename actually changes.  */
end_comment

begin_function
name|int
name|new_logical_line
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* DON'T destroy it!  We point to it!  */
name|int
name|line_number
parameter_list|)
block|{
if|if
condition|(
name|line_number
operator|>=
literal|0
condition|)
name|logical_input_line
operator|=
name|line_number
expr_stmt|;
elseif|else
if|if
condition|(
name|line_number
operator|==
operator|-
literal|2
operator|&&
name|logical_input_line
operator|>
literal|0
condition|)
operator|--
name|logical_input_line
expr_stmt|;
if|if
condition|(
name|fname
operator|&&
operator|(
name|logical_input_file
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|logical_input_file
argument_list|,
name|fname
argument_list|)
operator|)
condition|)
block|{
name|logical_input_file
operator|=
name|fname
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the current file name and line number.    namep should be char * const *, but there are compilers which screw    up declarations like that, and it's easier to avoid it.  */
end_comment

begin_function
name|void
name|as_where
parameter_list|(
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|unsigned
name|int
modifier|*
name|linep
parameter_list|)
block|{
if|if
condition|(
name|logical_input_file
operator|!=
name|NULL
operator|&&
operator|(
name|linep
operator|==
name|NULL
operator|||
name|logical_input_line
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|namep
operator|=
name|logical_input_file
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|logical_input_line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|physical_input_file
operator|!=
name|NULL
condition|)
block|{
operator|*
name|namep
operator|=
name|physical_input_file
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|physical_input_line
expr_stmt|;
block|}
else|else
block|{
operator|*
name|namep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output to given stream how much of line we have scanned so far.    Assumes we have scanned up to and including input_line_pointer.    No free '\n' at end of line.  */
end_comment

begin_function
name|void
name|as_howmuch
parameter_list|(
name|FILE
modifier|*
name|stream
comment|/* Opened for write please.  */
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Scan input line.  */
for|for
control|(
name|p
operator|=
name|input_line_pointer
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|--
name|p
control|)
block|{     }
operator|++
name|p
expr_stmt|;
comment|/* p->1st char of line.  */
for|for
control|(
init|;
name|p
operator|<=
name|input_line_pointer
condition|;
name|p
operator|++
control|)
block|{
comment|/* Assume ASCII. EBCDIC& other micro-computer char sets ignored.  */
name|as_1_char
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|as_1_char
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'^'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|+=
literal|'@'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

