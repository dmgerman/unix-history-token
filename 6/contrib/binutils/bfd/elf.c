begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.     Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  SECTION  	ELF backends  	BFD support for ELF formats is being worked on. 	Currently, the best supported back ends are for sparc and i386 	(running svr4 or Solaris 2).  	Documentation of the internals of the support code still needs 	to be written.  The code is changing quickly enough that we 	haven't bothered yet.  */
end_comment

begin_comment
comment|/* For sparc64-cross-sparc32.  */
end_comment

begin_define
define|#
directive|define
name|_SYSCALL32
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_function_decl
specifier|static
name|int
name|elf_sort_sections
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|assign_file_positions_except_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|prep_headers
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|swap_out_syms
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_strtab_hash
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elfcore_read_notes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|file_ptr
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Swap version information in and out.  The version information is    currently size independent.  If that ever changes, this code will    need to move into elfcode.h.  */
end_comment

begin_comment
comment|/* Swap in a Verdef structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdef_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Verdef
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Verdef
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|vd_version
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_flags
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_ndx
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_cnt
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_hash
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_aux
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_next
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verdef structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdef_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Verdef
modifier|*
name|src
parameter_list|,
name|Elf_External_Verdef
modifier|*
name|dst
parameter_list|)
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_version
argument_list|,
name|dst
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_flags
argument_list|,
name|dst
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_ndx
argument_list|,
name|dst
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_cnt
argument_list|,
name|dst
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_hash
argument_list|,
name|dst
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_aux
argument_list|,
name|dst
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_next
argument_list|,
name|dst
operator|->
name|vd_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Verdaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdaux_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Verdaux
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Verdaux
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|vda_name
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vda_next
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verdaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdaux_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Verdaux
modifier|*
name|src
parameter_list|,
name|Elf_External_Verdaux
modifier|*
name|dst
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_name
argument_list|,
name|dst
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_next
argument_list|,
name|dst
operator|->
name|vda_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Verneed structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verneed_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Verneed
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Verneed
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|vn_version
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_cnt
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_file
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_aux
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_next
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verneed structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verneed_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Verneed
modifier|*
name|src
parameter_list|,
name|Elf_External_Verneed
modifier|*
name|dst
parameter_list|)
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_version
argument_list|,
name|dst
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_cnt
argument_list|,
name|dst
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_file
argument_list|,
name|dst
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_aux
argument_list|,
name|dst
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_next
argument_list|,
name|dst
operator|->
name|vn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Vernaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_vernaux_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Vernaux
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Vernaux
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|vna_hash
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_flags
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_other
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_name
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_next
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Vernaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_vernaux_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Vernaux
modifier|*
name|src
parameter_list|,
name|Elf_External_Vernaux
modifier|*
name|dst
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_hash
argument_list|,
name|dst
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_flags
argument_list|,
name|dst
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_other
argument_list|,
name|dst
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_name
argument_list|,
name|dst
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_next
argument_list|,
name|dst
operator|->
name|vna_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Versym structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_versym_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Versym
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Versym
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|vs_vers
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vs_vers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Versym structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_versym_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Versym
modifier|*
name|src
parameter_list|,
name|Elf_External_Versym
modifier|*
name|dst
parameter_list|)
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vs_vers
argument_list|,
name|dst
operator|->
name|vs_vers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Standard ELF hash function.  Do not change this function; you will    cause invalid hash tables to be generated.  */
end_comment

begin_function
name|unsigned
name|long
name|bfd_elf_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|namearg
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|name
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|namearg
decl_stmt|;
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
comment|/* The ELF ABI says `h&= ~g', but this is equivalent in 	     this case and on some machines one insn instead of two.  */
name|h
operator|^=
name|g
expr_stmt|;
block|}
block|}
return|return
name|h
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/* Read a specified number of bytes at a specified offset in an ELF    file, into a newly allocated buffer, and return a pointer to the    buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|elf_read
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* This just does initialization.  */
comment|/* coff_mkobject zalloc's space for tdata.coff_obj_data ...  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Since everything is done at close time, do we need any      initialization?  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf_mkcorefile
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* I think this can be done just like an object file.  */
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bfd_elf_get_str_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|shindex
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|NULL
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|shstrtabsize
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
literal|0
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|shstrtab
operator|=
operator|(
name|char
operator|*
operator|)
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
block|{
comment|/* No cached one, attempt to read, and cache what we read.  */
name|offset
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_offset
expr_stmt|;
name|shstrtabsize
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_size
expr_stmt|;
name|shstrtab
operator|=
name|elf_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|shstrtabsize
argument_list|)
expr_stmt|;
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|contents
operator|=
name|shstrtab
expr_stmt|;
block|}
return|return
name|shstrtab
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bfd_elf_string_from_elf_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|shindex
parameter_list|,
name|unsigned
name|int
name|strindex
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|strindex
operator|==
literal|0
condition|)
return|return
literal|""
return|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|bfd_elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strindex
operator|>=
name|hdr
operator|->
name|sh_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid string offset %u>= %lu for section `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|strindex
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hdr
operator|->
name|sh_size
argument_list|,
operator|(
operator|(
name|shindex
operator|==
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
operator|&&
name|strindex
operator|==
name|hdr
operator|->
name|sh_name
operator|)
condition|?
literal|".shstrtab"
else|:
name|elf_string_from_elf_strtab
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|->
name|contents
operator|)
operator|+
name|strindex
return|;
block|}
end_function

begin_comment
comment|/* Read and convert symbols to internal format.    SYMCOUNT specifies the number of symbols to read, starting from    symbol SYMOFFSET.  If any of INTSYM_BUF, EXTSYM_BUF or EXTSHNDX_BUF    are non-NULL, they are used to store the internal symbols, external    symbols, and symbol section index extensions, respectively.  */
end_comment

begin_function
name|Elf_Internal_Sym
modifier|*
name|bfd_elf_get_elf_syms
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|size_t
name|symcount
parameter_list|,
name|size_t
name|symoffset
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|intsym_buf
parameter_list|,
name|void
modifier|*
name|extsym_buf
parameter_list|,
name|Elf_External_Sym_Shndx
modifier|*
name|extshndx_buf
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|void
modifier|*
name|alloc_ext
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|alloc_extshndx
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|size_t
name|extsym_size
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
return|return
name|intsym_buf
return|;
comment|/* Normal syms might have section extension entries.  */
name|shndx_hdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|==
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
condition|)
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
comment|/* Read the symbols.  */
name|alloc_ext
operator|=
name|NULL
expr_stmt|;
name|alloc_extshndx
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|extsym_size
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
name|extsym_size
expr_stmt|;
name|pos
operator|=
name|symtab_hdr
operator|->
name|sh_offset
operator|+
name|symoffset
operator|*
name|extsym_size
expr_stmt|;
if|if
condition|(
name|extsym_buf
operator|==
name|NULL
condition|)
block|{
name|alloc_ext
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|extsym_buf
operator|=
name|alloc_ext
expr_stmt|;
block|}
if|if
condition|(
name|extsym_buf
operator|==
name|NULL
operator|||
name|bfd_seek
argument_list|(
name|ibfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|extsym_buf
argument_list|,
name|amt
argument_list|,
name|ibfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|intsym_buf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|shndx_hdr
operator|==
name|NULL
operator|||
name|shndx_hdr
operator|->
name|sh_size
operator|==
literal|0
condition|)
name|extshndx_buf
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|pos
operator|=
name|shndx_hdr
operator|->
name|sh_offset
operator|+
name|symoffset
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|extshndx_buf
operator|==
name|NULL
condition|)
block|{
name|alloc_extshndx
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|extshndx_buf
operator|=
name|alloc_extshndx
expr_stmt|;
block|}
if|if
condition|(
name|extshndx_buf
operator|==
name|NULL
operator|||
name|bfd_seek
argument_list|(
name|ibfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|extshndx_buf
argument_list|,
name|amt
argument_list|,
name|ibfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|intsym_buf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|intsym_buf
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
decl_stmt|;
name|intsym_buf
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|intsym_buf
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Convert the symbols to internal form.  */
name|isymend
operator|=
name|intsym_buf
operator|+
name|symcount
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|extsym_buf
operator|,
name|isym
operator|=
name|intsym_buf
operator|,
name|shndx
operator|=
name|extshndx_buf
init|;
name|isym
operator|<
name|isymend
condition|;
name|esym
operator|+=
name|extsym_size
operator|,
name|isym
operator|++
operator|,
name|shndx
operator|=
name|shndx
operator|!=
name|NULL
condition|?
name|shndx
operator|+
literal|1
else|:
name|NULL
control|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_symbol_in
call|)
argument_list|(
name|ibfd
argument_list|,
name|esym
argument_list|,
name|shndx
argument_list|,
name|isym
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|alloc_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_extshndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc_extshndx
argument_list|)
expr_stmt|;
return|return
name|intsym_buf
return|;
block|}
end_function

begin_comment
comment|/* Look up a symbol name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_elf_local_sym_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|)
block|{
name|unsigned
name|int
name|iname
init|=
name|isym
operator|->
name|st_name
decl_stmt|;
name|unsigned
name|int
name|shindex
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_link
decl_stmt|;
if|if
condition|(
name|iname
operator|==
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|iname
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|isym
operator|->
name|st_shndx
index|]
operator|->
name|sh_name
expr_stmt|;
name|shindex
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
expr_stmt|;
block|}
return|return
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|,
name|iname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Elf_Internal_Shdr->contents is an array of these for SHT_GROUP    sections.  The first element is the flags, the rest are section    pointers.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|elf_internal_group
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdr
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|}
name|Elf_Internal_Group
typedef|;
end_typedef

begin_comment
comment|/* Return the name of the group signature symbol.  Why isn't the    signature just a string?  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|group_signature
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|ghdr
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|char
name|esym
index|[
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
index|]
decl_stmt|;
name|Elf_External_Sym_Shndx
name|eshndx
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
comment|/* First we need to ensure the symbol table is available.  */
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|ghdr
operator|->
name|sh_link
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Go read the symbol.  */
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
literal|1
argument_list|,
name|ghdr
operator|->
name|sh_info
argument_list|,
operator|&
name|isym
argument_list|,
name|esym
argument_list|,
operator|&
name|eshndx
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|bfd_elf_local_sym_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|isym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set next_in_group list pointer, and group name for NEWSECT.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|setup_group
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|newsect
parameter_list|)
block|{
name|unsigned
name|int
name|num_group
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|num_group
decl_stmt|;
comment|/* If num_group is zero, read in all SHT_GROUP sections.  The count      is set to -1 if there are no SHT_GROUP sections.  */
if|if
condition|(
name|num_group
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|shnum
decl_stmt|;
comment|/* First count the number of groups.  If we have a SHT_GROUP 	 section with just a flag word (ie. sh_size is 4), ignore it.  */
name|shnum
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|num_group
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_GROUP
operator|&&
name|shdr
operator|->
name|sh_size
operator|>=
literal|8
condition|)
name|num_group
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_group
operator|==
literal|0
condition|)
name|num_group
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|num_group
operator|=
name|num_group
expr_stmt|;
if|if
condition|(
name|num_group
operator|>
literal|0
condition|)
block|{
comment|/* We keep a list of elf section headers for group sections, 	     so we can find them quickly.  */
name|bfd_size_type
name|amt
init|=
name|num_group
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
operator|*
argument_list|)
decl_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|group_sect_ptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|group_sect_ptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|num_group
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_GROUP
operator|&&
name|shdr
operator|->
name|sh_size
operator|>=
literal|8
condition|)
block|{
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Group
modifier|*
name|dest
decl_stmt|;
comment|/* Add to list of sections.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|group_sect_ptr
index|[
name|num_group
index|]
operator|=
name|shdr
expr_stmt|;
name|num_group
operator|+=
literal|1
expr_stmt|;
comment|/* Read the raw contents.  */
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|amt
operator|=
name|shdr
operator|->
name|sh_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
operator|/
literal|4
expr_stmt|;
name|shdr
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
operator|->
name|contents
operator|==
name|NULL
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|shdr
operator|->
name|contents
argument_list|,
name|shdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|shdr
operator|->
name|sh_size
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Translate raw contents, a flag word followed by an 		     array of elf section indices all in target byte order, 		     to the flag word followed by an array of elf section 		     pointers.  */
name|src
operator|=
name|shdr
operator|->
name|contents
operator|+
name|shdr
operator|->
name|sh_size
expr_stmt|;
name|dest
operator|=
operator|(
name|Elf_Internal_Group
operator|*
operator|)
operator|(
name|shdr
operator|->
name|contents
operator|+
name|amt
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|src
operator|-=
literal|4
expr_stmt|;
operator|--
name|dest
expr_stmt|;
name|idx
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|shdr
operator|->
name|contents
condition|)
block|{
name|dest
operator|->
name|flags
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|shdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
operator|(
name|idx
operator|&
name|GRP_COMDAT
operator|)
condition|)
name|shdr
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|idx
operator|>=
name|shnum
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid SHT_GROUP entry"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
name|dest
operator|->
name|shdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|num_group
operator|!=
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_group
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdr
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|group_sect_ptr
index|[
name|i
index|]
decl_stmt|;
name|Elf_Internal_Group
modifier|*
name|idx
init|=
operator|(
name|Elf_Internal_Group
operator|*
operator|)
name|shdr
operator|->
name|contents
decl_stmt|;
name|unsigned
name|int
name|n_elt
init|=
name|shdr
operator|->
name|sh_size
operator|/
literal|4
decl_stmt|;
comment|/* Look through this group's sections to see if current 	     section is a member.  */
while|while
condition|(
operator|--
name|n_elt
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
operator|++
name|idx
operator|)
operator|->
name|shdr
operator|==
name|hdr
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
comment|/* We are a member of this group.  Go looking through 		   other members to see if any others are linked via 		   next_in_group.  */
name|idx
operator|=
operator|(
name|Elf_Internal_Group
operator|*
operator|)
name|shdr
operator|->
name|contents
expr_stmt|;
name|n_elt
operator|=
name|shdr
operator|->
name|sh_size
operator|/
literal|4
expr_stmt|;
while|while
condition|(
operator|--
name|n_elt
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|s
operator|=
operator|(
operator|++
name|idx
operator|)
operator|->
name|shdr
operator|->
name|bfd_section
operator|)
operator|!=
name|NULL
operator|&&
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|n_elt
operator|!=
literal|0
condition|)
block|{
comment|/* Snarf the group name from other member, and 		       insert current section in circular list.  */
name|elf_group_name
argument_list|(
name|newsect
argument_list|)
operator|=
name|elf_group_name
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|elf_next_in_group
argument_list|(
name|newsect
argument_list|)
operator|=
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
operator|=
name|newsect
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|gname
decl_stmt|;
name|gname
operator|=
name|group_signature
argument_list|(
name|abfd
argument_list|,
name|shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_group_name
argument_list|(
name|newsect
argument_list|)
operator|=
name|gname
expr_stmt|;
comment|/* Start a circular list with one element.  */
name|elf_next_in_group
argument_list|(
name|newsect
argument_list|)
operator|=
name|newsect
expr_stmt|;
block|}
comment|/* If the group section has been created, point to the 		   new member.  */
if|if
condition|(
name|shdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
name|elf_next_in_group
argument_list|(
name|shdr
operator|->
name|bfd_section
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|i
operator|=
name|num_group
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|elf_group_name
argument_list|(
name|newsect
argument_list|)
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: no group info for section %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|newsect
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf_discard_group
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|group
parameter_list|)
block|{
name|asection
modifier|*
name|first
init|=
name|elf_next_in_group
argument_list|(
name|group
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|first
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|s
operator|=
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* These lists are circular.  */
if|if
condition|(
name|s
operator|==
name|first
condition|)
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Make a BFD section from an ELF section.  We store a pointer to the    BFD section in the bfd_section field of the header.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_make_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|newsect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Always use the real type/flags.  */
name|elf_section_type
argument_list|(
name|newsect
argument_list|)
operator|=
name|hdr
operator|->
name|sh_type
expr_stmt|;
name|elf_section_flags
argument_list|(
name|newsect
argument_list|)
operator|=
name|hdr
operator|->
name|sh_flags
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_addr
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|bfd_log2
argument_list|(
operator|(
name|bfd_vma
operator|)
name|hdr
operator|->
name|sh_addralign
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_GROUP
condition|)
name|flags
operator||=
name|SEC_GROUP
operator||
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_MERGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|SEC_MERGE
expr_stmt|;
name|newsect
operator|->
name|entsize
operator|=
name|hdr
operator|->
name|sh_entsize
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_STRINGS
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_STRINGS
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_GROUP
condition|)
if|if
condition|(
operator|!
name|setup_group
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|newsect
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_TLS
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_THREAD_LOCAL
expr_stmt|;
comment|/* The debugging sections appear to be recognized only by name, not      any sort of flag.  */
block|{
specifier|static
specifier|const
name|char
modifier|*
name|debug_sec_names
index|[]
init|=
block|{
literal|".debug"
block|,
literal|".gnu.linkonce.wi."
block|,
literal|".line"
block|,
literal|".stab"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|debug_sec_names
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|debug_sec_names
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|debug_sec_names
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
block|}
comment|/* As a GNU extension, if the name begins with .gnu.linkonce, we      only link a single copy of the section.  This is used to support      g++.  g++ will emit each template expansion in its own section.      The symbols will be defined as weak, so that multiple definitions      are permitted.  The GNU linker extension is to actually discard      all but one of the sections.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|elf_next_in_group
argument_list|(
name|newsect
argument_list|)
operator|==
name|NULL
condition|)
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_flags
condition|)
if|if
condition|(
operator|!
name|bed
operator|->
name|elf_backend_section_flags
argument_list|(
operator|&
name|flags
argument_list|,
name|hdr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Look through the phdrs to see if we need to adjust the lma.          If all the p_paddr fields are zero, we ignore them, since          some ELF linkers produce such output.  */
name|phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|phdr
operator|++
control|)
block|{
if|if
condition|(
name|phdr
operator|->
name|p_paddr
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
condition|)
block|{
name|phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|phdr
operator|++
control|)
block|{
comment|/* This section is part of this segment if its file 		 offset plus size lies within the segment's memory 		 span and, if the section is loaded, the extent of the 		 loaded data lies within the extent of the segment.  		 Note - we used to check the p_paddr field as well, and 		 refuse to set the LMA if it was 0.  This is wrong 		 though, as a perfectly valid initialised segment can 		 have a p_paddr of zero.  Some architectures, eg ARM, 	         place special significance on the address 0 and 	         executables need to be able to have a segment which 	         covers this address.  */
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|bfd_vma
operator|)
name|hdr
operator|->
name|sh_offset
operator|>=
name|phdr
operator|->
name|p_offset
operator|&&
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
operator|<=
name|phdr
operator|->
name|p_offset
operator|+
name|phdr
operator|->
name|p_memsz
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
operator|<=
name|phdr
operator|->
name|p_offset
operator|+
name|phdr
operator|->
name|p_filesz
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|newsect
operator|->
name|lma
operator|=
operator|(
name|phdr
operator|->
name|p_paddr
operator|+
name|hdr
operator|->
name|sh_addr
operator|-
name|phdr
operator|->
name|p_vaddr
operator|)
expr_stmt|;
else|else
comment|/* We used to use the same adjustment for SEC_LOAD 		       sections, but that doesn't work if the segment 		       is packed with code from multiple VMAs. 		       Instead we calculate the section LMA based on 		       the segment LMA.  It is assumed that the 		       segment will contain sections with contiguous 		       LMAs, even if the VMAs are not.  */
name|newsect
operator|->
name|lma
operator|=
operator|(
name|phdr
operator|->
name|p_paddr
operator|+
name|hdr
operator|->
name|sh_offset
operator|-
name|phdr
operator|->
name|p_offset
operator|)
expr_stmt|;
comment|/* With contiguous segments, we can't tell from file 		     offsets whether a section with zero size should 		     be placed at the end of one segment or the 		     beginning of the next.  Decide based on vaddr.  */
if|if
condition|(
name|hdr
operator|->
name|sh_addr
operator|>=
name|phdr
operator|->
name|p_vaddr
operator|&&
operator|(
name|hdr
operator|->
name|sh_addr
operator|+
name|hdr
operator|->
name|sh_size
operator|<=
name|phdr
operator|->
name|p_vaddr
operator|+
name|phdr
operator|->
name|p_memsz
operator|)
condition|)
break|break;
block|}
block|}
block|}
block|}
name|hdr
operator|->
name|bfd_section
operator|=
name|newsect
expr_stmt|;
name|elf_section_data
argument_list|(
name|newsect
argument_list|)
operator|->
name|this_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_elf_find_section  SYNOPSIS 	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);  DESCRIPTION 	Helper functions for GDB to locate the string tables. 	Since BFD hides string tables from callers, GDB needs to use an 	internal hook to find them.  Sun's .stabstr, in particular, 	isn't even pointed to by the .stab section, so ordinary 	mechanisms wouldn't work to find it, even if we had some. */
end_comment

begin_function
name|struct
name|elf_internal_shdr
modifier|*
name|bfd_elf_find_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
block|{
name|shstrtab
operator|=
name|bfd_elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|shstrtab
index|[
name|i_shdrp
index|[
name|i
index|]
operator|->
name|sh_name
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|i_shdrp
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|bfd_elf_section_type_names
index|[]
init|=
block|{
literal|"SHT_NULL"
block|,
literal|"SHT_PROGBITS"
block|,
literal|"SHT_SYMTAB"
block|,
literal|"SHT_STRTAB"
block|,
literal|"SHT_RELA"
block|,
literal|"SHT_HASH"
block|,
literal|"SHT_DYNAMIC"
block|,
literal|"SHT_NOTE"
block|,
literal|"SHT_NOBITS"
block|,
literal|"SHT_REL"
block|,
literal|"SHT_SHLIB"
block|,
literal|"SHT_DYNSYM"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF relocs are against symbols.  If we are producing relocatable    output, and the reloc is against an external symbol, and nothing    has given us any additional addend, the resulting reloc will also    be against the same symbol.  In such a case, we don't want to    change anything about the way the reloc is handled, since it will    all be done at final link time.  Rather than put special case code    into bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocatable output against an external symbol.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure sec_info_type is cleared if sec_info is cleared too.  */
end_comment

begin_function
specifier|static
name|void
name|merge_sections_remove_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
argument_list|)
expr_stmt|;
name|sec
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish SHF_MERGE section merging.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_merge_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|merge_info
condition|)
name|_bfd_merge_sections
argument_list|(
name|abfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|merge_info
argument_list|,
name|merge_sections_remove_hook
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_link_just_syms
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sec
operator|->
name|output_offset
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return;
name|sec
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_JUST_SYMS
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the program header and other data from one object module to    another.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|)
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|=
name|elf_gp
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Print out the program headers.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|farg
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|p
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nProgram Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|pt
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
name|pt
operator|=
literal|"NULL"
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
name|pt
operator|=
literal|"LOAD"
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
name|pt
operator|=
literal|"DYNAMIC"
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
name|pt
operator|=
literal|"INTERP"
expr_stmt|;
break|break;
case|case
name|PT_NOTE
case|:
name|pt
operator|=
literal|"NOTE"
expr_stmt|;
break|break;
case|case
name|PT_SHLIB
case|:
name|pt
operator|=
literal|"SHLIB"
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
name|pt
operator|=
literal|"PHDR"
expr_stmt|;
break|break;
case|case
name|PT_TLS
case|:
name|pt
operator|=
literal|"TLS"
expr_stmt|;
break|break;
case|case
name|PT_GNU_EH_FRAME
case|:
name|pt
operator|=
literal|"EH_FRAME"
expr_stmt|;
break|break;
case|case
name|PT_GNU_STACK
case|:
name|pt
operator|=
literal|"STACK"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx"
argument_list|,
name|p
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|pt
operator|=
name|buf
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%8s off    0x"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|f
argument_list|,
name|p
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" vaddr 0x"
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|f
argument_list|,
name|p
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" paddr 0x"
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|f
argument_list|,
name|p
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" align 2**%u\n"
argument_list|,
name|bfd_log2
argument_list|(
name|p
operator|->
name|p_align
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"         filesz 0x"
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|f
argument_list|,
name|p
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" memsz 0x"
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|f
argument_list|,
name|p
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" flags %c%c%c"
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_R
operator|)
operator|!=
literal|0
condition|?
literal|'r'
else|:
literal|'-'
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
operator|!=
literal|0
condition|?
literal|'w'
else|:
literal|'-'
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_X
operator|)
operator|!=
literal|0
condition|?
literal|'x'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flags
operator|&
operator|~
call|(
name|unsigned
call|)
argument_list|(
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %lx"
argument_list|,
name|p
operator|->
name|p_flags
operator|&
operator|~
call|(
name|unsigned
call|)
argument_list|(
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|shlink
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|,
modifier|*
name|extdynend
decl_stmt|;
name|size_t
name|extdynsize
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_dyn_in
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|Elf_Internal_Dyn
modifier|*
parameter_list|)
function_decl|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nDynamic Section:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|bfd_malloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|dynbuf
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|shlink
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
name|extdynsize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
name|swap_dyn_in
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
expr_stmt|;
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|+=
name|extdynsize
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
name|bfd_boolean
name|stringp
decl_stmt|;
call|(
modifier|*
name|swap_dyn_in
call|)
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NULL
condition|)
break|break;
name|stringp
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dyn
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|name
operator|=
name|ab
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
name|name
operator|=
literal|"NEEDED"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|"PLTRELSZ"
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|"PLTGOT"
expr_stmt|;
break|break;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|"HASH"
expr_stmt|;
break|break;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|"STRTAB"
expr_stmt|;
break|break;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|"SYMTAB"
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|name
operator|=
literal|"RELA"
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|name
operator|=
literal|"RELASZ"
expr_stmt|;
break|break;
case|case
name|DT_RELAENT
case|:
name|name
operator|=
literal|"RELAENT"
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
name|name
operator|=
literal|"STRSZ"
expr_stmt|;
break|break;
case|case
name|DT_SYMENT
case|:
name|name
operator|=
literal|"SYMENT"
expr_stmt|;
break|break;
case|case
name|DT_INIT
case|:
name|name
operator|=
literal|"INIT"
expr_stmt|;
break|break;
case|case
name|DT_FINI
case|:
name|name
operator|=
literal|"FINI"
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|name
operator|=
literal|"SONAME"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|name
operator|=
literal|"RPATH"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_SYMBOLIC
case|:
name|name
operator|=
literal|"SYMBOLIC"
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
name|name
operator|=
literal|"REL"
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
name|name
operator|=
literal|"RELSZ"
expr_stmt|;
break|break;
case|case
name|DT_RELENT
case|:
name|name
operator|=
literal|"RELENT"
expr_stmt|;
break|break;
case|case
name|DT_PLTREL
case|:
name|name
operator|=
literal|"PLTREL"
expr_stmt|;
break|break;
case|case
name|DT_DEBUG
case|:
name|name
operator|=
literal|"DEBUG"
expr_stmt|;
break|break;
case|case
name|DT_TEXTREL
case|:
name|name
operator|=
literal|"TEXTREL"
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|"JMPREL"
expr_stmt|;
break|break;
case|case
name|DT_BIND_NOW
case|:
name|name
operator|=
literal|"BIND_NOW"
expr_stmt|;
break|break;
case|case
name|DT_INIT_ARRAY
case|:
name|name
operator|=
literal|"INIT_ARRAY"
expr_stmt|;
break|break;
case|case
name|DT_FINI_ARRAY
case|:
name|name
operator|=
literal|"FINI_ARRAY"
expr_stmt|;
break|break;
case|case
name|DT_INIT_ARRAYSZ
case|:
name|name
operator|=
literal|"INIT_ARRAYSZ"
expr_stmt|;
break|break;
case|case
name|DT_FINI_ARRAYSZ
case|:
name|name
operator|=
literal|"FINI_ARRAYSZ"
expr_stmt|;
break|break;
case|case
name|DT_RUNPATH
case|:
name|name
operator|=
literal|"RUNPATH"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_FLAGS
case|:
name|name
operator|=
literal|"FLAGS"
expr_stmt|;
break|break;
case|case
name|DT_PREINIT_ARRAY
case|:
name|name
operator|=
literal|"PREINIT_ARRAY"
expr_stmt|;
break|break;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
name|name
operator|=
literal|"PREINIT_ARRAYSZ"
expr_stmt|;
break|break;
case|case
name|DT_CHECKSUM
case|:
name|name
operator|=
literal|"CHECKSUM"
expr_stmt|;
break|break;
case|case
name|DT_PLTPADSZ
case|:
name|name
operator|=
literal|"PLTPADSZ"
expr_stmt|;
break|break;
case|case
name|DT_MOVEENT
case|:
name|name
operator|=
literal|"MOVEENT"
expr_stmt|;
break|break;
case|case
name|DT_MOVESZ
case|:
name|name
operator|=
literal|"MOVESZ"
expr_stmt|;
break|break;
case|case
name|DT_FEATURE
case|:
name|name
operator|=
literal|"FEATURE"
expr_stmt|;
break|break;
case|case
name|DT_POSFLAG_1
case|:
name|name
operator|=
literal|"POSFLAG_1"
expr_stmt|;
break|break;
case|case
name|DT_SYMINSZ
case|:
name|name
operator|=
literal|"SYMINSZ"
expr_stmt|;
break|break;
case|case
name|DT_SYMINENT
case|:
name|name
operator|=
literal|"SYMINENT"
expr_stmt|;
break|break;
case|case
name|DT_CONFIG
case|:
name|name
operator|=
literal|"CONFIG"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_DEPAUDIT
case|:
name|name
operator|=
literal|"DEPAUDIT"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_AUDIT
case|:
name|name
operator|=
literal|"AUDIT"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_PLTPAD
case|:
name|name
operator|=
literal|"PLTPAD"
expr_stmt|;
break|break;
case|case
name|DT_MOVETAB
case|:
name|name
operator|=
literal|"MOVETAB"
expr_stmt|;
break|break;
case|case
name|DT_SYMINFO
case|:
name|name
operator|=
literal|"SYMINFO"
expr_stmt|;
break|break;
case|case
name|DT_RELACOUNT
case|:
name|name
operator|=
literal|"RELACOUNT"
expr_stmt|;
break|break;
case|case
name|DT_RELCOUNT
case|:
name|name
operator|=
literal|"RELCOUNT"
expr_stmt|;
break|break;
case|case
name|DT_FLAGS_1
case|:
name|name
operator|=
literal|"FLAGS_1"
expr_stmt|;
break|break;
case|case
name|DT_VERSYM
case|:
name|name
operator|=
literal|"VERSYM"
expr_stmt|;
break|break;
case|case
name|DT_VERDEF
case|:
name|name
operator|=
literal|"VERDEF"
expr_stmt|;
break|break;
case|case
name|DT_VERDEFNUM
case|:
name|name
operator|=
literal|"VERDEFNUM"
expr_stmt|;
break|break;
case|case
name|DT_VERNEED
case|:
name|name
operator|=
literal|"VERNEED"
expr_stmt|;
break|break;
case|case
name|DT_VERNEEDNUM
case|:
name|name
operator|=
literal|"VERNEEDNUM"
expr_stmt|;
break|break;
case|case
name|DT_AUXILIARY
case|:
name|name
operator|=
literal|"AUXILIARY"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_USED
case|:
name|name
operator|=
literal|"USED"
expr_stmt|;
break|break;
case|case
name|DT_FILTER
case|:
name|name
operator|=
literal|"FILTER"
expr_stmt|;
name|stringp
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  %-11s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringp
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|string
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|==
name|NULL
operator|)
operator|||
operator|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_slurp_version_tables
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Verdef
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nVersion definitions:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vd_nextdef
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d 0x%2.2x 0x%8.8lx %s\n"
argument_list|,
name|t
operator|->
name|vd_ndx
argument_list|,
name|t
operator|->
name|vd_flags
argument_list|,
name|t
operator|->
name|vd_hash
argument_list|,
name|t
operator|->
name|vd_nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|vd_auxptr
operator|->
name|vda_nextptr
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Verdaux
modifier|*
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vd_auxptr
operator|->
name|vda_nextptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vda_nextptr
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|a
operator|->
name|vda_nodename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nVersion References:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"  required from %s:\n"
argument_list|)
argument_list|,
name|t
operator|->
name|vn_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    0x%8.8lx 0x%2.2x %2.2d %s\n"
argument_list|,
name|a
operator|->
name|vna_hash
argument_list|,
name|a
operator|->
name|vna_flags
argument_list|,
name|a
operator|->
name|vna_other
argument_list|,
name|a
operator|->
name|vna_nodename
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Display ELF-specific fields of a symbol.  */
end_comment

begin_function
name|void
name|bfd_elf_print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|filep
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_print_symbol_type
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"elf "
argument_list|)
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|unsigned
name|char
name|st_other
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_print_symbol_all
condition|)
name|name
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_print_symbol_all
call|)
argument_list|(
name|abfd
argument_list|,
name|filep
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
comment|/* Print the "other" value for a symbol.  For common symbols, 	   we've already printed the size; now print the alignment. 	   For other symbols, we have no specified alignment, and 	   we've printed the address; now print the size.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|val
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_value
expr_stmt|;
else|else
name|val
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* If we have version information, print it.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_section
operator|!=
literal|0
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_section
operator|!=
literal|0
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_section
operator|!=
literal|0
operator|)
condition|)
block|{
name|unsigned
name|int
name|vernum
decl_stmt|;
specifier|const
name|char
modifier|*
name|version_string
decl_stmt|;
name|vernum
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|version
operator|&
name|VERSYM_VERSION
expr_stmt|;
if|if
condition|(
name|vernum
operator|==
literal|0
condition|)
name|version_string
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|vernum
operator|==
literal|1
condition|)
name|version_string
operator|=
literal|"Base"
expr_stmt|;
elseif|else
if|if
condition|(
name|vernum
operator|<=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
condition|)
name|version_string
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
operator|.
name|vd_nodename
expr_stmt|;
else|else
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|version_string
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
if|if
condition|(
name|a
operator|->
name|vna_other
operator|==
name|vernum
condition|)
block|{
name|version_string
operator|=
name|a
operator|->
name|vna_nodename
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|version
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %-11s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%s)"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|10
operator|-
name|strlen
argument_list|(
name|version_string
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the st_other field is not zero, print it.  */
name|st_other
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
expr_stmt|;
switch|switch
condition|(
name|st_other
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|STV_INTERNAL
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" .internal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STV_HIDDEN
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" .hidden"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STV_PROTECTED
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" .protected"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Some other non-defined flags are also present, so print 	       everything hex.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" 0x%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|st_other
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an entry in an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
init|=
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|)
name|table
decl_stmt|;
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|dynstr_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|elf_hash_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|verinfo
operator|.
name|verdef
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|vtable_entries_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|vtable_entries_used
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|vtable_parent
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|got
operator|=
name|htab
operator|->
name|init_refcount
expr_stmt|;
name|ret
operator|->
name|plt
operator|=
name|htab
operator|->
name|init_refcount
expr_stmt|;
name|ret
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|type
operator|=
name|STT_NOTYPE
expr_stmt|;
name|ret
operator|->
name|other
operator|=
literal|0
expr_stmt|;
comment|/* Assume that we have been called by a non-ELF symbol reader.          This flag is then reset by the code which reads an ELF input          file.  This ensures that a symbol created by a non-ELF symbol          reader will have the flag set correctly.  */
name|ret
operator|->
name|elf_link_hash_flags
operator|=
name|ELF_LINK_NON_ELF
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Copy data from an indirect symbol to its direct symbol, hiding the    old indirect symbol.  Also used for copying flags to a weakdef.  */
end_comment

begin_function
name|void
name|_bfd_elf_link_hash_copy_indirect
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|bfd_signed_vma
name|tmp
decl_stmt|;
name|bfd_signed_vma
name|lowest_valid
init|=
name|bed
operator|->
name|can_refcount
decl_stmt|;
comment|/* Copy down any references that we may have already seen to the      symbol which just became indirect.  */
name|dir
operator|->
name|elf_link_hash_flags
operator||=
name|ind
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_NON_GOT_REF
operator||
name|ELF_LINK_HASH_NEEDS_PLT
operator||
name|ELF_LINK_POINTER_EQUALITY_NEEDED
operator|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
comment|/* Copy over the global and procedure linkage table refcount entries.      These may have been already set up by a check_relocs routine.  */
name|tmp
operator|=
name|dir
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|lowest_valid
condition|)
block|{
name|dir
operator|->
name|got
operator|.
name|refcount
operator|=
name|ind
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
name|ind
operator|->
name|got
operator|.
name|refcount
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|got
operator|.
name|refcount
operator|<
name|lowest_valid
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|dir
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|lowest_valid
condition|)
block|{
name|dir
operator|->
name|plt
operator|.
name|refcount
operator|=
name|ind
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
name|ind
operator|->
name|plt
operator|.
name|refcount
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|plt
operator|.
name|refcount
operator|<
name|lowest_valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dir
operator|->
name|dynindx
operator|=
name|ind
operator|->
name|dynindx
expr_stmt|;
name|dir
operator|->
name|dynstr_index
operator|=
name|ind
operator|->
name|dynstr_index
expr_stmt|;
name|ind
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ind
operator|->
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|dynindx
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_link_hash_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|h
operator|->
name|plt
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_offset
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
if|if
condition|(
name|force_local
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_FORCED_LOCAL
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize an ELF linker hash table.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|_bfd_elf_link_hash_table_init
argument_list|(
expr|struct
name|elf_link_hash_table
operator|*
name|table
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
name|newfunc
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
block|{
name|bfd_boolean
name|ret
decl_stmt|;
name|table
operator|->
name|dynamic_sections_created
operator|=
name|FALSE
expr_stmt|;
name|table
operator|->
name|dynobj
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure can_refcount is extended to the width and signedness of      init_refcount before we subtract one from it.  */
name|table
operator|->
name|init_refcount
operator|.
name|refcount
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|can_refcount
expr_stmt|;
name|table
operator|->
name|init_refcount
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
name|table
operator|->
name|init_offset
operator|.
name|offset
operator|=
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
comment|/* The first dynamic symbol is a dummy.  */
name|table
operator|->
name|dynsymcount
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|dynstr
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|bucketcount
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|needed
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|hgot
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|stab_info
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|merge_info
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|table
operator|->
name|eh_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|eh_info
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|dynlocal
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|runpath
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|tls_sec
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|tls_size
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|loaded
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
expr_stmt|;
name|table
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_elf_hash_table
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* This is a hook for the ELF emulation code in the generic linker to    tell the backend linker what file name to use for the DT_NEEDED    entry for a dynamic object.  */
end_comment

begin_function
name|void
name|bfd_elf_set_dt_needed_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_elf_set_dyn_lib_class
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|lib_class
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|=
name|lib_class
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the list of DT_NEEDED entries for a link.  This is a hook for    the linker ELF emulation code.  */
end_comment

begin_function
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_elf_get_needed_list
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|needed
return|;
block|}
end_function

begin_comment
comment|/* Get the list of DT_RPATH/DT_RUNPATH entries for a link.  This is a    hook for the linker ELF emulation code.  */
end_comment

begin_function
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_elf_get_runpath_list
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|runpath
return|;
block|}
end_function

begin_comment
comment|/* Get the name actually used for a dynamic object for a link.  This    is the SONAME entry if there is one.  Otherwise, it is the string    passed to bfd_elf_set_dt_needed_name, or it is the filename.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_elf_get_dt_soname
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
return|return
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get the list of DT_NEEDED entries from a BFD.  This is a hook for    the ELF linker emulation code.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_get_bfd_needed_list
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_needed_list
modifier|*
modifier|*
name|pneeded
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|shlink
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|,
modifier|*
name|extdynend
decl_stmt|;
name|size_t
name|extdynsize
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_dyn_in
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|Elf_Internal_Dyn
modifier|*
parameter_list|)
function_decl|;
operator|*
name|pneeded
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
return|return
name|TRUE
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|dynbuf
operator|=
name|bfd_malloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|dynbuf
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|shlink
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
name|extdynsize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
name|swap_dyn_in
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
expr_stmt|;
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|+=
name|extdynsize
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
call|(
modifier|*
name|swap_dyn_in
call|)
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NULL
condition|)
break|break;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|bfd_link_needed_list
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|string
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|l
expr_stmt|;
name|l
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|l
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|string
expr_stmt|;
name|l
operator|->
name|next
operator|=
operator|*
name|pneeded
expr_stmt|;
operator|*
name|pneeded
operator|=
name|l
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate an ELF string table--force the first byte to be zero.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_elf_stringtab_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|loc
decl_stmt|;
name|loc
operator|=
name|_bfd_stringtab_add
argument_list|(
name|ret
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc
operator|==
literal|0
operator|||
name|loc
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|_bfd_stringtab_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file reading */
end_comment

begin_comment
comment|/* Create a new bfd section from an ELF section header.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|shindex
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|elf_string_from_elf_strtab
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
comment|/* Inactive section. Throw it away.  */
return|return
name|TRUE
return|;
case|case
name|SHT_PROGBITS
case|:
comment|/* Normal section with contents.  */
case|case
name|SHT_NOBITS
case|:
comment|/* .bss section.  */
case|case
name|SHT_HASH
case|:
comment|/* .hash section.  */
case|case
name|SHT_NOTE
case|:
comment|/* .note section.  */
case|case
name|SHT_INIT_ARRAY
case|:
comment|/* .init_array section.  */
case|case
name|SHT_FINI_ARRAY
case|:
comment|/* .fini_array section.  */
case|case
name|SHT_PREINIT_ARRAY
case|:
comment|/* .preinit_array section.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_DYNAMIC
case|:
comment|/* Dynamic linking information.  */
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|!=
name|SHT_STRTAB
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|dynsymhdr
decl_stmt|;
comment|/* The shared libraries distributed with hpux11 have a bogus 	     sh_link field for the ".dynamic" section.  Find the 	     string table for the ".dynsym" section instead.  */
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dynsymhdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
index|]
expr_stmt|;
name|hdr
operator|->
name|sh_link
operator|=
name|dynsymhdr
operator|->
name|sh_link
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|num_sec
decl_stmt|;
name|num_sec
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_sec
condition|;
name|i
operator|++
control|)
block|{
name|dynsymhdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dynsymhdr
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
name|hdr
operator|->
name|sh_link
operator|=
name|dynsymhdr
operator|->
name|sh_link
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
case|case
name|SHT_SYMTAB
case|:
comment|/* A symbol table */
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Sometimes a shared object will map in the symbol table.  If          SHF_ALLOC is set, and this is a shared object, then we also          treat this section as a BFD section.  We can not base the          decision purely on SHF_ALLOC, because that flag is sometimes          set in a relocatable object file, which would confuse the          linker.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|SHT_DYNSYM
case|:
comment|/* A dynamic symbol table */
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Besides being a symbol table, we also treat this as a regular 	 section, so that objcopy can handle it.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
comment|/* Symbol section indices when>64k sections */
if|if
condition|(
name|elf_symtab_shndx
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|TRUE
return|;
comment|/* Get the associated symbol table.  */
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|)
operator|||
name|hdr
operator|->
name|sh_link
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_symtab_shndx
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|SHT_STRTAB
case|:
comment|/* A string table */
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ehdr
operator|->
name|e_shstrndx
operator|==
name|shindex
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|num_sec
decl_stmt|;
name|num_sec
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_sec
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr2
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hdr2
operator|->
name|sh_link
operator|==
name|shindex
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
expr_stmt|;
comment|/* We also treat this as a regular section, so 		       that objcopy can handle it.  */
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Not handling other string tables specially right now.  */
block|hdr2 = elf_elfsections (abfd)[i];
comment|/* in case it moved */
comment|/* We have a strtab for some random other section.  */
block|newsect = (asection *) hdr2->bfd_section; 		if (!newsect) 		  break; 		hdr->bfd_section = newsect; 		hdr2 =&elf_section_data (newsect)->str_hdr; 		*hdr2 = *hdr; 		elf_elfsections (abfd)[shindex] = hdr2;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* *These* do a lot of work -- but build no sections!  */
block|{
name|asection
modifier|*
name|target_sect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr2
decl_stmt|;
name|unsigned
name|int
name|num_sec
init|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Check for a bogus link to avoid crashing.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_link
operator|>=
name|SHN_LORESERVE
operator|&&
name|hdr
operator|->
name|sh_link
operator|<=
name|SHN_HIRESERVE
operator|)
operator|||
name|hdr
operator|->
name|sh_link
operator|>=
name|num_sec
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid link %lu for reloc section %s (index %u)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|name
argument_list|,
name|shindex
argument_list|)
operator|)
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/* For some incomprehensible reason Oracle distributes 	   libraries for Solaris in which some of the objects have 	   bogus sh_link fields.  It would be nice if we could just 	   reject them, but, unfortunately, some people need to use 	   them.  We scan through the section headers; if we find only 	   one suitable symbol table, we clobber the sh_link to point 	   to it.  I hope this doesn't break anything.  */
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
block|{
name|unsigned
name|int
name|scan
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan
operator|=
literal|1
init|;
name|scan
operator|<
name|num_sec
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|scan
index|]
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|scan
index|]
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found
operator|=
name|scan
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_link
operator|=
name|found
expr_stmt|;
block|}
comment|/* Get the symbol table.  */
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|&&
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If this reloc section does not use the main symbol table we 	   don't treat it as a reloc section.  BFD can't adequately 	   represent such a section, so at least for now, we don't 	   try.  We just present it as a normal section.  We also 	   can't use it as a reloc section if it points to the null 	   section.  */
if|if
condition|(
name|hdr
operator|->
name|sh_link
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|||
name|hdr
operator|->
name|sh_info
operator|==
name|SHN_UNDEF
condition|)
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|target_sect
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|target_sect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|target_sect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|hdr2
operator|=
operator|&
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr2
argument_list|)
expr_stmt|;
name|hdr2
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr2
operator|=
name|hdr2
expr_stmt|;
block|}
operator|*
name|hdr2
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr2
expr_stmt|;
name|target_sect
operator|->
name|reloc_count
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|target_sect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|target_sect
operator|->
name|relocation
operator|=
name|NULL
expr_stmt|;
name|target_sect
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
comment|/* In the section to which the relocations apply, mark whether 	   its relocations are of the REL or RELA variety.  */
if|if
condition|(
name|hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
name|target_sect
operator|->
name|use_rela_p
operator|=
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
return|return
name|TRUE
return|;
block|}
break|break;
case|case
name|SHT_GNU_verdef
case|:
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_GNU_versym
case|:
name|elf_dynversym
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_GNU_verneed
case|:
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_SHLIB
case|:
return|return
name|TRUE
return|;
case|case
name|SHT_GROUP
case|:
comment|/* We need a BFD section for objcopy and relocatable linking, 	 and it's handy to have the signature available as the section 	 name.  */
name|name
operator|=
name|group_signature
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Group
modifier|*
name|idx
init|=
operator|(
name|Elf_Internal_Group
operator|*
operator|)
name|hdr
operator|->
name|contents
decl_stmt|;
name|unsigned
name|int
name|n_elt
init|=
name|hdr
operator|->
name|sh_size
operator|/
literal|4
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|idx
operator|->
name|flags
operator|&
name|GRP_COMDAT
condition|)
name|hdr
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
while|while
condition|(
operator|--
name|n_elt
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|s
operator|=
operator|(
operator|++
name|idx
operator|)
operator|->
name|shdr
operator|->
name|bfd_section
operator|)
operator|!=
name|NULL
operator|&&
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|elf_next_in_group
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
comment|/* Check for any processor-specific section types.  */
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_shdr
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_shdr
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section for the local symbol specified by ABFD, R_SYMNDX.    Return SEC for sections that have no elf section, and NULL on error.  */
end_comment

begin_function
name|asection
modifier|*
name|bfd_section_from_r_symndx
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|sym_sec_cache
modifier|*
name|cache
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|char
name|esym
index|[
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
index|]
decl_stmt|;
name|Elf_External_Sym_Shndx
name|eshndx
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
name|unsigned
name|int
name|ent
init|=
name|r_symndx
operator|%
name|LOCAL_SYM_CACHE_SIZE
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|abfd
operator|==
name|abfd
operator|&&
name|cache
operator|->
name|indx
index|[
name|ent
index|]
operator|==
name|r_symndx
condition|)
return|return
name|cache
operator|->
name|sec
index|[
name|ent
index|]
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
literal|1
argument_list|,
name|r_symndx
argument_list|,
operator|&
name|isym
argument_list|,
name|esym
argument_list|,
operator|&
name|eshndx
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|cache
operator|->
name|abfd
operator|!=
name|abfd
condition|)
block|{
name|memset
argument_list|(
name|cache
operator|->
name|indx
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cache
operator|->
name|indx
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
block|}
name|cache
operator|->
name|indx
index|[
name|ent
index|]
operator|=
name|r_symndx
expr_stmt|;
name|cache
operator|->
name|sec
index|[
name|ent
index|]
operator|=
name|sec
expr_stmt|;
if|if
condition|(
operator|(
name|isym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|)
operator|||
name|isym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|cache
operator|->
name|sec
index|[
name|ent
index|]
operator|=
name|s
expr_stmt|;
block|}
return|return
name|cache
operator|->
name|sec
index|[
name|ent
index|]
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF section number, retrieve the corresponding BFD    section.  */
end_comment

begin_function
name|asection
modifier|*
name|bfd_section_from_elf_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|index
index|]
operator|->
name|bfd_section
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|special_sections
index|[]
init|=
block|{
block|{
literal|".bss"
block|,
literal|4
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".comment"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".data"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".data1"
block|,
literal|6
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".debug"
block|,
literal|6
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".fini"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".init"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".line"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".rodata"
block|,
literal|7
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".rodata1"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".tbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_TLS
block|}
block|,
block|{
literal|".tdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_TLS
block|}
block|,
block|{
literal|".text"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".init_array"
block|,
literal|11
block|,
literal|0
block|,
name|SHT_INIT_ARRAY
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".fini_array"
block|,
literal|11
block|,
literal|0
block|,
name|SHT_FINI_ARRAY
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".preinit_array"
block|,
literal|14
block|,
literal|0
block|,
name|SHT_PREINIT_ARRAY
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".debug_line"
block|,
literal|11
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".debug_info"
block|,
literal|11
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".debug_abbrev"
block|,
literal|13
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".debug_aranges"
block|,
literal|14
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".dynamic"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_DYNAMIC
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".dynstr"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_STRTAB
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".dynsym"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_DYNSYM
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".got"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".hash"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_HASH
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".interp"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
literal|".plt"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".shstrtab"
block|,
literal|9
block|,
literal|0
block|,
name|SHT_STRTAB
block|,
literal|0
block|}
block|,
block|{
literal|".strtab"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_STRTAB
block|,
literal|0
block|}
block|,
block|{
literal|".symtab"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_SYMTAB
block|,
literal|0
block|}
block|,
block|{
literal|".gnu.version"
block|,
literal|12
block|,
literal|0
block|,
name|SHT_GNU_versym
block|,
literal|0
block|}
block|,
block|{
literal|".gnu.version_d"
block|,
literal|14
block|,
literal|0
block|,
name|SHT_GNU_verdef
block|,
literal|0
block|}
block|,
block|{
literal|".gnu.version_r"
block|,
literal|14
block|,
literal|0
block|,
name|SHT_GNU_verneed
block|,
literal|0
block|}
block|,
block|{
literal|".note"
block|,
literal|5
block|,
operator|-
literal|1
block|,
name|SHT_NOTE
block|,
literal|0
block|}
block|,
block|{
literal|".rela"
block|,
literal|5
block|,
operator|-
literal|1
block|,
name|SHT_RELA
block|,
literal|0
block|}
block|,
block|{
literal|".rel"
block|,
literal|4
block|,
operator|-
literal|1
block|,
name|SHT_REL
block|,
literal|0
block|}
block|,
block|{
literal|".stabstr"
block|,
literal|5
block|,
literal|3
block|,
name|SHT_STRTAB
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|get_special_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|special_sections
parameter_list|,
name|unsigned
name|int
name|rela
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|special_sections
index|[
name|i
index|]
operator|.
name|prefix
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|suffix_len
decl_stmt|;
name|int
name|prefix_len
init|=
name|special_sections
index|[
name|i
index|]
operator|.
name|prefix_length
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|prefix_len
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|name
argument_list|,
name|special_sections
index|[
name|i
index|]
operator|.
name|prefix
argument_list|,
name|prefix_len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|suffix_len
operator|=
name|special_sections
index|[
name|i
index|]
operator|.
name|suffix_length
expr_stmt|;
if|if
condition|(
name|suffix_len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|name
index|[
name|prefix_len
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|suffix_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|name
index|[
name|prefix_len
index|]
operator|!=
literal|'.'
operator|&&
operator|(
name|suffix_len
operator|==
operator|-
literal|2
operator|||
operator|(
name|rela
operator|&&
name|special_sections
index|[
name|i
index|]
operator|.
name|type
operator|==
name|SHT_REL
operator|)
operator|)
condition|)
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|len
operator|<
name|prefix_len
operator|+
name|suffix_len
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|name
operator|+
name|len
operator|-
name|suffix_len
argument_list|,
name|special_sections
index|[
name|i
index|]
operator|.
name|prefix
operator|+
name|prefix_len
argument_list|,
name|suffix_len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
return|return
operator|&
name|special_sections
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|_bfd_elf_get_sec_type_attr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|ssect
init|=
name|NULL
decl_stmt|;
comment|/* See if this is one of the special sections.  */
if|if
condition|(
name|name
condition|)
block|{
name|unsigned
name|int
name|rela
init|=
name|bed
operator|->
name|default_use_rela_p
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|special_sections
condition|)
name|ssect
operator|=
name|get_special_section
argument_list|(
name|name
argument_list|,
name|bed
operator|->
name|special_sections
argument_list|,
name|rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssect
condition|)
name|ssect
operator|=
name|get_special_section
argument_list|(
name|name
argument_list|,
name|special_sections
argument_list|,
name|rela
argument_list|)
expr_stmt|;
block|}
return|return
name|ssect
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|sdata
decl_stmt|;
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|ssect
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|bfd_elf_section_data
operator|*
operator|)
name|sec
operator|->
name|used_by_bfd
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
block|{
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
name|elf_section_type
argument_list|(
name|sec
argument_list|)
operator|=
name|SHT_NULL
expr_stmt|;
name|ssect
operator|=
name|_bfd_elf_get_sec_type_attr
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssect
operator|!=
name|NULL
condition|)
block|{
name|elf_section_type
argument_list|(
name|sec
argument_list|)
operator|=
name|ssect
operator|->
name|type
expr_stmt|;
name|elf_section_flags
argument_list|(
name|sec
argument_list|)
operator|=
name|ssect
operator|->
name|attr
expr_stmt|;
block|}
comment|/* Indicate whether or not this section should use RELA relocations.  */
name|sec
operator|->
name|use_rela_p
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|default_use_rela_p
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a new bfd section from an ELF program header.     Since program segments have no names, we generate a synthetic name    of the form segment<NUM>, where NUM is generally the index in the    program header table.  For segments that are split (see below) we    generate the names segment<NUM>a and segment<NUM>b.     Note that some program segments may have a file size that is different than    (less than) the memory size.  All this means is that at execution the    system must allocate the amount of memory specified by the memory size,    but only initialize it with the first "file size" bytes read from the    file.  This would occur for example, with program segments consisting    of combined data+bss.     To handle the above situation, this routine generates TWO bfd sections    for the single program segment.  The first has the length specified by    the file size of the segment, and the second has the length specified    by the difference between the two sizes.  In effect, the segment is split    into it's initialized and uninitialized parts.   */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_make_section_from_phdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|hdr
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|64
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|split
decl_stmt|;
name|split
operator|=
operator|(
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
name|hdr
operator|->
name|p_filesz
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%s%d%s"
argument_list|,
name|typename
argument_list|,
name|index
argument_list|,
name|split
condition|?
literal|"a"
else|:
literal|""
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
expr_stmt|;
name|newsect
operator|->
name|lma
operator|=
name|hdr
operator|->
name|p_paddr
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
name|bfd_log2
argument_list|(
name|hdr
operator|->
name|p_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
block|{
comment|/* FIXME: all we known is that it has execute PERMISSION, 	     may be data.  */
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|split
condition|)
block|{
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%s%db"
argument_list|,
name|typename
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|lma
operator|=
name|hdr
operator|->
name|p_paddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_memsz
operator|-
name|hdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_section_from_phdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|hdr
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"null"
argument_list|)
return|;
case|case
name|PT_LOAD
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"load"
argument_list|)
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"dynamic"
argument_list|)
return|;
case|case
name|PT_INTERP
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"interp"
argument_list|)
return|;
case|case
name|PT_NOTE
case|:
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"note"
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elfcore_read_notes
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|,
name|hdr
operator|->
name|p_filesz
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|PT_SHLIB
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"shlib"
argument_list|)
return|;
case|case
name|PT_PHDR
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"phdr"
argument_list|)
return|;
case|case
name|PT_GNU_EH_FRAME
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"eh_frame_hdr"
argument_list|)
return|;
case|case
name|PT_GNU_STACK
case|:
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"stack"
argument_list|)
return|;
default|default:
comment|/* Check for any processor-specific program segment types.          If no handler for them, default to making "segment" sections.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_phdr
condition|)
return|return
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_phdr
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|)
return|;
else|else
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
literal|"segment"
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize REL_HDR, the section-header for new section, containing    relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA    relocations; otherwise, we use REL relocations.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_init_reloc_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|bfd_boolean
name|use_rela_p
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|".rela"
operator|+
name|strlen
argument_list|(
name|asect
operator|->
name|name
argument_list|)
decl_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|use_rela_p
condition|?
literal|".rela"
else|:
literal|".rel"
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
name|rel_hdr
operator|->
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|rel_hdr
operator|->
name|sh_type
operator|=
name|use_rela_p
condition|?
name|SHT_RELA
else|:
name|SHT_REL
expr_stmt|;
name|rel_hdr
operator|->
name|sh_entsize
operator|=
operator|(
name|use_rela_p
condition|?
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
else|:
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
expr_stmt|;
name|rel_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
name|rel_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|rel_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|rel_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|rel_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up an ELF internal section header for a section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|failedptrarg
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_boolean
modifier|*
name|failedptr
init|=
name|failedptrarg
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
if|if
condition|(
operator|*
name|failedptr
condition|)
block|{
comment|/* We already failed; just get out of the bfd_map_over_sections          loop.  */
return|return;
block|}
name|this_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|this_hdr
operator|->
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|asect
operator|->
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_hdr
operator|->
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|failedptr
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|this_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|||
name|asect
operator|->
name|user_set_vma
condition|)
name|this_hdr
operator|->
name|sh_addr
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
else|else
name|this_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
name|asect
operator|->
name|_raw_size
expr_stmt|;
name|this_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|asect
operator|->
name|alignment_power
expr_stmt|;
comment|/* The sh_entsize and sh_info fields may have been set already by      copy_private_section_data.  */
name|this_hdr
operator|->
name|bfd_section
operator|=
name|asect
expr_stmt|;
name|this_hdr
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
comment|/* If the section type is unspecified, we set it based on      asect->flags.  */
if|if
condition|(
name|this_hdr
operator|->
name|sh_type
operator|==
name|SHT_NULL
condition|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|asect
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|!=
literal|0
operator|)
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
else|else
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
switch|switch
condition|(
name|this_hdr
operator|->
name|sh_type
condition|)
block|{
default|default:
break|break;
case|case
name|SHT_STRTAB
case|:
case|case
name|SHT_INIT_ARRAY
case|:
case|case
name|SHT_FINI_ARRAY
case|:
case|case
name|SHT_PREINIT_ARRAY
case|:
case|case
name|SHT_NOTE
case|:
case|case
name|SHT_NOBITS
case|:
case|case
name|SHT_PROGBITS
case|:
break|break;
case|case
name|SHT_HASH
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
expr_stmt|;
break|break;
case|case
name|SHT_DYNSYM
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
break|break;
case|case
name|SHT_DYNAMIC
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|may_use_rela_p
condition|)
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|may_use_rel_p
condition|)
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
break|break;
case|case
name|SHT_GNU_versym
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_GNU_verdef
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
comment|/* objcopy or strip will copy over sh_info, but may not set          cverdefs.  The linker will set cverdefs, but sh_info will be          zero.  */
if|if
condition|(
name|this_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_info
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
operator|==
literal|0
operator|||
name|this_hdr
operator|->
name|sh_info
operator|==
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_GNU_verneed
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
comment|/* objcopy or strip will copy over sh_info, but may not set          cverrefs.  The linker will set cverrefs, but sh_info will be          zero.  */
if|if
condition|(
name|this_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_info
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
operator|==
literal|0
operator|||
name|this_hdr
operator|->
name|sh_info
operator|==
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_GROUP
case|:
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_EXECINSTR
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_MERGE
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|asect
operator|->
name|entsize
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_STRINGS
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_STRINGS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|==
literal|0
operator|&&
name|elf_group_name
argument_list|(
name|asect
argument_list|)
operator|!=
name|NULL
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_GROUP
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_TLS
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|_raw_size
operator|==
literal|0
operator|&&
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|o
decl_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|asect
operator|->
name|link_order_head
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|this_hdr
operator|->
name|sh_size
operator|<
name|o
operator|->
name|offset
operator|+
name|o
operator|->
name|size
condition|)
name|this_hdr
operator|->
name|sh_size
operator|=
name|o
operator|->
name|offset
operator|+
name|o
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|this_hdr
operator|->
name|sh_size
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
block|}
comment|/* Check for processor-specific section types.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_fake_sections
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_fake_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|this_hdr
argument_list|,
name|asect
argument_list|)
condition|)
operator|*
name|failedptr
operator|=
name|TRUE
expr_stmt|;
comment|/* If the section has relocs, set up a section header for the      SHT_REL[A] section.  If two relocation sections are required for      this section, it is up to the processor-specific back-end to      create the other.  */
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|_bfd_elf_init_reloc_shdr
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|asect
argument_list|,
name|asect
operator|->
name|use_rela_p
argument_list|)
condition|)
operator|*
name|failedptr
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in the contents of a SHT_GROUP section.  */
end_comment

begin_function
name|void
name|bfd_elf_set_group_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|failedptrarg
parameter_list|)
block|{
name|bfd_boolean
modifier|*
name|failedptr
init|=
name|failedptrarg
decl_stmt|;
name|unsigned
name|long
name|symindx
decl_stmt|;
name|asection
modifier|*
name|elt
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|l
decl_stmt|;
name|bfd_boolean
name|gas
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_GROUP
operator|||
operator|*
name|failedptr
condition|)
return|return;
name|symindx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elf_group_id
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
name|symindx
operator|=
name|elf_group_id
argument_list|(
name|sec
argument_list|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|symindx
operator|==
literal|0
condition|)
block|{
comment|/* If called from the assembler, swap_out_syms will have set up 	 elf_section_syms;  If called for "ld -r", use target_index.  */
if|if
condition|(
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
name|symindx
operator|=
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|sec
operator|->
name|index
index|]
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|symindx
operator|=
name|sec
operator|->
name|target_index
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|symindx
expr_stmt|;
comment|/* The contents won't be allocated for "ld -r" or objcopy.  */
name|gas
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|gas
operator|=
name|FALSE
expr_stmt|;
name|sec
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* Arrange for the section to be written out.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|sec
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedptr
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
block|}
name|loc
operator|=
name|sec
operator|->
name|contents
operator|+
name|sec
operator|->
name|_raw_size
expr_stmt|;
comment|/* Get the pointer to the first section in the group that gas      squirreled away here.  objcopy arranges for this to be set to the      start of the input section group.  */
name|first
operator|=
name|elt
operator|=
name|elf_next_in_group
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* First element is a flag word.  Rest of section is elf section      indices for all the sections of the group.  Write them backwards      just to keep the group in the same order as given in .section      directives, not that it matters.  */
while|while
condition|(
name|elt
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|loc
operator|-=
literal|4
expr_stmt|;
name|s
operator|=
name|elt
expr_stmt|;
if|if
condition|(
operator|!
name|gas
condition|)
name|s
operator|=
name|s
operator|->
name|output_section
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|idx
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|elt
operator|=
name|elf_next_in_group
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|first
condition|)
break|break;
block|}
comment|/* If this is a relocatable link, then the above did nothing because      SEC is the output section.  Look through the input sections      instead.  */
for|for
control|(
name|l
operator|=
name|sec
operator|->
name|link_order_head
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|elt
operator|=
name|elf_next_in_group
argument_list|(
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|do
block|{
name|loc
operator|-=
literal|4
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|elt
operator|->
name|output_section
argument_list|)
operator|->
name|this_idx
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|elt
operator|=
name|elf_next_in_group
argument_list|(
name|elt
argument_list|)
expr_stmt|;
comment|/* During a relocatable link, the lists are circular.  */
block|}
do|while
condition|(
name|elt
operator|!=
name|elf_next_in_group
argument_list|(
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
argument_list|)
condition|)
do|;
comment|/* With ld -r, merging SHT_GROUP sections results in wasted space      due to allowing for the flag word on each input.  We may well      duplicate entries too.  */
while|while
condition|(
operator|(
name|loc
operator|-=
literal|4
operator|)
operator|>
name|sec
operator|->
name|contents
condition|)
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|sec
operator|->
name|contents
condition|)
name|abort
argument_list|()
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
condition|?
name|GRP_COMDAT
else|:
literal|0
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assign all ELF section numbers.  The dummy first section is handled here    too.  The link/info pointers for the standard section types are filled    in here too, while we're at it.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|assign_section_numbers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf_obj_tdata
modifier|*
name|t
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|,
name|secn
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|section_number
operator|=
literal|1
expr_stmt|;
name|_bfd_elf_strtab_clear_all_refs
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|d
operator|->
name|this_idx
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|d
operator|->
name|this_hdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|rel_idx
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|d
operator|->
name|rel_idx
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|d
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|rel_hdr2
condition|)
block|{
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|d
operator|->
name|rel_idx2
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|d
operator|->
name|rel_hdr2
operator|->
name|sh_name
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|->
name|rel_idx2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|t
operator|->
name|shstrtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|t
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
operator|=
name|t
operator|->
name|shstrtab_section
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|t
operator|->
name|symtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|t
operator|->
name|symtab_hdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_number
operator|>
name|SHN_LORESERVE
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|t
operator|->
name|symtab_shndx_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|t
operator|->
name|symtab_shndx_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|".symtab_shndx"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|symtab_shndx_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|section_number
operator|==
name|SHN_LORESERVE
condition|)
name|section_number
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|t
operator|->
name|strtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|t
operator|->
name|strtab_hdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
block|}
name|_bfd_elf_strtab_finalize
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|shstrtab_hdr
operator|.
name|sh_size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|section_number
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
operator|=
name|section_number
expr_stmt|;
if|if
condition|(
name|section_number
operator|>
name|SHN_LORESERVE
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
operator|-=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
comment|/* Set up the list of section header pointers, in agreement with the      indices.  */
name|amt
operator|=
name|section_number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
operator|*
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_shdrp
expr_stmt|;
name|i_shdrp
index|[
name|t
operator|->
name|shstrtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|shstrtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
name|i_shdrp
index|[
name|t
operator|->
name|symtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|>
name|SHN_LORESERVE
condition|)
block|{
name|i_shdrp
index|[
name|t
operator|->
name|symtab_shndx_section
index|]
operator|=
operator|&
name|t
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|t
operator|->
name|symtab_shndx_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
block|}
name|i_shdrp
index|[
name|t
operator|->
name|strtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|strtab_hdr
expr_stmt|;
name|t
operator|->
name|symtab_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|strtab_section
expr_stmt|;
block|}
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|i_shdrp
index|[
name|d
operator|->
name|this_idx
index|]
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
name|i_shdrp
index|[
name|d
operator|->
name|rel_idx
index|]
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rel_idx2
operator|!=
literal|0
condition|)
name|i_shdrp
index|[
name|d
operator|->
name|rel_idx2
index|]
operator|=
name|d
operator|->
name|rel_hdr2
expr_stmt|;
comment|/* Fill in the sh_link and sh_info fields while we're at it.  */
comment|/* sh_link of a reloc section is the section index of the symbol 	 table.  sh_info is the section index of the section to which 	 the relocation entries apply.  */
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|rel_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
name|d
operator|->
name|rel_hdr
operator|.
name|sh_info
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|rel_idx2
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|rel_hdr2
operator|->
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
name|d
operator|->
name|rel_hdr2
operator|->
name|sh_info
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* A reloc section which we are treating as a normal BFD 	     section.  sh_link is the section index of the symbol 	     table.  sh_info is the section index of the section to 	     which the relocation entries apply.  We assume that an 	     allocated reloc section uses the dynamic symbol table. 	     FIXME: How can we be sure?  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
comment|/* We look up the section the relocs apply to by name.  */
name|name
operator|=
name|sec
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
condition|)
name|name
operator|+=
literal|4
expr_stmt|;
else|else
name|name
operator|+=
literal|5
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_STRTAB
case|:
comment|/* We assume that a section named .stab*str is a stabs 	     string section.  We look for a section with the same name 	     but without the trailing ``str'', and set its sh_link 	     field to point to this section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|alc
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|alc
operator|=
name|bfd_malloc
argument_list|(
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|alc
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
name|alc
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|alc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
comment|/* This is a .stab section.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|==
literal|0
condition|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
operator|+
literal|2
operator|*
name|bfd_get_arch_size
argument_list|(
name|abfd
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SHT_DYNAMIC
case|:
case|case
name|SHT_DYNSYM
case|:
case|case
name|SHT_GNU_verneed
case|:
case|case
name|SHT_GNU_verdef
case|:
comment|/* sh_link is the section header index of the string table 	     used for the dynamic entries, or the symbol table, or the 	     version strings.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_HASH
case|:
case|case
name|SHT_GNU_versym
case|:
comment|/* sh_link is the section header index of the symbol table 	     this hash table or version table is for.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_GROUP
case|:
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
block|}
block|}
for|for
control|(
name|secn
operator|=
literal|1
init|;
name|secn
operator|<
name|section_number
condition|;
operator|++
name|secn
control|)
if|if
condition|(
name|i_shdrp
index|[
name|secn
index|]
operator|==
name|NULL
condition|)
name|i_shdrp
index|[
name|secn
index|]
operator|=
name|i_shdrp
index|[
literal|0
index|]
expr_stmt|;
else|else
name|i_shdrp
index|[
name|secn
index|]
operator|->
name|sh_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|i_shdrp
index|[
name|secn
index|]
operator|->
name|sh_name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Map symbol from it's internal number to the external number, moving    all local symbols to be at the head of the list.  */
end_comment

begin_function
specifier|static
name|int
name|sym_is_global
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
comment|/* If the backend has a special mapping, use it.  */
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_sym_is_global
condition|)
return|return
call|(
modifier|*
name|bed
operator|->
name|elf_backend_sym_is_global
call|)
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
return|;
return|return
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_map_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sect_syms
decl_stmt|;
name|unsigned
name|int
name|num_locals
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_globals
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_locals2
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_globals2
init|=
literal|0
decl_stmt|;
name|int
name|max_index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|new_syms
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_map_symbols\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|max_index
operator|<
name|asect
operator|->
name|index
condition|)
name|max_index
operator|=
name|asect
operator|->
name|index
expr_stmt|;
block|}
name|max_index
operator|++
expr_stmt|;
name|amt
operator|=
name|max_index
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
name|sect_syms
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect_syms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|sect_syms
expr_stmt|;
name|elf_num_section_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|max_index
expr_stmt|;
comment|/* Init sect_syms entries for any section symbols we have already      decided to output.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|syms
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
name|sym
operator|->
name|value
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|sym
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|owner
operator|!=
name|abfd
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|output_offset
operator|!=
literal|0
condition|)
continue|continue;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* Empty sections in the input files may have had a 		     section symbol created for them.  (See the comment 		     near the end of _bfd_generic_link_output_symbols in 		     linker.c).  If the linker script discards such 		     sections then we will reach this point.  Since we know 		     that we cannot avoid this case, we detect it and skip 		     the abort and the assignment to the sect_syms array. 		     To reproduce this particular case try running the 		     linker testsuite test ld-scripts/weak.exp for an ELF 		     port that uses the generic linker.  */
if|if
condition|(
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|owner
operator|==
name|abfd
argument_list|)
expr_stmt|;
block|}
name|sect_syms
index|[
name|sec
operator|->
name|index
index|]
operator|=
name|syms
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Classify all of the symbols.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
condition|)
name|num_locals
operator|++
expr_stmt|;
else|else
name|num_globals
operator|++
expr_stmt|;
block|}
comment|/* We will be adding a section symbol for each BFD section.  Most normal      sections will already have a section symbol in outsymbols, but      eg. SHT_GROUP sections will not, and we need the section symbol mapped      at least in that case.  */
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|symbol
argument_list|)
condition|)
name|num_locals
operator|++
expr_stmt|;
else|else
name|num_globals
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now sort the symbols so the local symbols are first.  */
name|amt
operator|=
operator|(
name|num_locals
operator|+
name|num_globals
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
name|new_syms
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_syms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|syms
index|[
name|idx
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|i
operator|=
name|num_locals2
operator|++
expr_stmt|;
else|else
name|i
operator|=
name|num_locals
operator|+
name|num_globals2
operator|++
expr_stmt|;
name|new_syms
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|udata
operator|.
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|asect
operator|->
name|symbol
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|=
name|sym
expr_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|i
operator|=
name|num_locals2
operator|++
expr_stmt|;
else|else
name|i
operator|=
name|num_locals
operator|+
name|num_globals2
operator|++
expr_stmt|;
name|new_syms
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|udata
operator|.
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|new_syms
argument_list|,
name|num_locals
operator|+
name|num_globals
argument_list|)
expr_stmt|;
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_locals
expr_stmt|;
name|elf_num_globals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_globals
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Align to the maximum file alignment that could be required for any    ELF data structure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|file_ptr
name|align_file_position
parameter_list|(
name|file_ptr
name|off
parameter_list|,
name|int
name|align
parameter_list|)
block|{
return|return
operator|(
name|off
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assign a file position to a section, optionally aligning to the    required section alignment.  */
end_comment

begin_function
name|file_ptr
name|_bfd_elf_assign_file_position_for_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_boolean
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
condition|)
block|{
name|unsigned
name|int
name|al
decl_stmt|;
name|al
operator|=
name|i_shdrp
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|al
operator|>
literal|1
condition|)
name|offset
operator|=
name|BFD_ALIGN
argument_list|(
name|offset
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
name|i_shdrp
operator|->
name|sh_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
name|i_shdrp
operator|->
name|bfd_section
operator|->
name|filepos
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|offset
operator|+=
name|i_shdrp
operator|->
name|sh_size
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Compute the file positions we are going to put the sections at, and    otherwise prepare to begin writing out the ELF file.  If LINK_INFO    is not NULL, this is being called by the ELF backend linker.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_compute_section_file_positions
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_boolean
name|failed
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shstrtab_hdr
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
return|return
name|TRUE
return|;
comment|/* Do any elf backend specific processing first.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_begin_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_begin_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prep_headers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Post process the headers if necessary.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_post_process_headers
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_post_process_headers
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
name|failed
operator|=
name|FALSE
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_fake_sections
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|assign_section_numbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The backend linker builds symbol table information itself.  */
if|if
condition|(
name|link_info
operator|==
name|NULL
operator|&&
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Non-zero if doing a relocatable link.  */
name|int
name|relocatable_p
init|=
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|swap_out_syms
argument_list|(
name|abfd
argument_list|,
operator|&
name|strtab
argument_list|,
name|relocatable_p
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|link_info
operator|==
name|NULL
condition|)
block|{
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bfd_elf_set_group_contents
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
return|return
name|FALSE
return|;
block|}
name|shstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|shstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set in assign_file_positions_except_relocs.  */
name|shstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|assign_file_positions_except_relocs
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|link_info
operator|==
name|NULL
operator|&&
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
comment|/* Now that we know where the .strtab section goes, write it          out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|strtab
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|_bfd_stringtab_free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
name|abfd
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a mapping from a set of sections to a program segment.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_segment_map
modifier|*
name|make_mapping
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
modifier|*
name|sections
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|bfd_boolean
name|phdr
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|to
operator|-
name|from
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|,
name|hdrpp
operator|=
name|sections
operator|+
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
name|m
operator|->
name|sections
index|[
name|i
operator|-
name|from
index|]
operator|=
operator|*
name|hdrpp
expr_stmt|;
name|m
operator|->
name|count
operator|=
name|to
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|from
operator|==
literal|0
operator|&&
name|phdr
condition|)
block|{
comment|/* Include the headers in the first PT_LOAD segment.  */
name|m
operator|->
name|includes_filehdr
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Set up a mapping from BFD sections to program segments.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|map_sections_to_segments
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|mfirst
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|pm
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|asection
modifier|*
name|last_hdr
decl_stmt|;
name|bfd_vma
name|last_size
decl_stmt|;
name|unsigned
name|int
name|phdr_index
decl_stmt|;
name|bfd_vma
name|maxpagesize
decl_stmt|;
name|asection
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|bfd_boolean
name|phdr_in_segment
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|writable
decl_stmt|;
name|int
name|tls_count
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|first_tls
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|dynsec
decl_stmt|,
modifier|*
name|eh_frame_hdr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Select the allocated sections, and sort them.  */
name|amt
operator|=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|i
operator|<=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sections
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|elf_sort_sections
argument_list|)
expr_stmt|;
comment|/* Build the mapping.  */
name|mfirst
operator|=
name|NULL
expr_stmt|;
name|pm
operator|=
operator|&
name|mfirst
expr_stmt|;
comment|/* If we have a .interp section, then create a PT_PHDR segment for      the program headers and a PT_INTERP segment for the .interp      section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_PHDR
expr_stmt|;
comment|/* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
literal|1
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_INTERP
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* Look through the sections.  We put sections in the same program      segment when the start of the second section can be placed within      a few bytes of the end of the first section.  */
name|last_hdr
operator|=
name|NULL
expr_stmt|;
name|last_size
operator|=
literal|0
expr_stmt|;
name|phdr_index
operator|=
literal|0
expr_stmt|;
name|maxpagesize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxpagesize
expr_stmt|;
name|writable
operator|=
name|FALSE
expr_stmt|;
name|dynsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsec
operator|!=
name|NULL
operator|&&
operator|(
name|dynsec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|dynsec
operator|=
name|NULL
expr_stmt|;
comment|/* Deal with -Ttext or something similar such that the first section      is not adjacent to the program headers.  This is an      approximation, since at this point we don't know exactly how many      program headers we will need.  */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|phdr_size
decl_stmt|;
name|phdr_size
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
expr_stmt|;
if|if
condition|(
name|phdr_size
operator|==
literal|0
condition|)
name|phdr_size
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|==
literal|0
operator|||
name|sections
index|[
literal|0
index|]
operator|->
name|lma
operator|<
name|phdr_size
operator|||
name|sections
index|[
literal|0
index|]
operator|->
name|lma
operator|%
name|maxpagesize
operator|<
name|phdr_size
operator|%
name|maxpagesize
condition|)
name|phdr_in_segment
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|hdrpp
operator|=
name|sections
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|asection
modifier|*
name|hdr
decl_stmt|;
name|bfd_boolean
name|new_segment
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
comment|/* See if this section and the last one will fit in the same          segment.  */
if|if
condition|(
name|last_hdr
operator|==
name|NULL
condition|)
block|{
comment|/* If we don't have a segment yet, then we don't need a new 	     one (we build the last one after this loop).  */
name|new_segment
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_hdr
operator|->
name|lma
operator|-
name|last_hdr
operator|->
name|vma
operator|!=
name|hdr
operator|->
name|lma
operator|-
name|hdr
operator|->
name|vma
condition|)
block|{
comment|/* If this section has a different relation between the              virtual address and the load address, then we need a new              segment.  */
name|new_segment
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BFD_ALIGN
argument_list|(
name|last_hdr
operator|->
name|lma
operator|+
name|last_size
argument_list|,
name|maxpagesize
argument_list|)
operator|<
name|BFD_ALIGN
argument_list|(
name|hdr
operator|->
name|lma
argument_list|,
name|maxpagesize
argument_list|)
condition|)
block|{
comment|/* If putting this section in this segment would force us to              skip a page in the segment, then we need a new segment.  */
name|new_segment
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last_hdr
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|hdr
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We don't want to put a loadable section after a              nonloadable section in the same segment.              Consider .tbss sections as loadable for this purpose.  */
name|new_segment
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If the file is not demand paged, which means that we              don't require the sections to be correctly aligned in the              file, then there is no other reason for a new segment.  */
name|new_segment
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|writable
operator|&&
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|last_hdr
operator|->
name|lma
operator|+
name|last_size
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|maxpagesize
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|hdr
operator|->
name|lma
operator|&
operator|~
operator|(
name|maxpagesize
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We don't want to put a writable section in a read only              segment, unless they are on the same page in memory              anyhow.  We already know that the last section does not              bring us past the current section on the page, so the              only case in which the new section is not on the same              page as the previous section is when the previous section              ends precisely on a page boundary.  */
name|new_segment
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we can use the same segment.  */
name|new_segment
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_segment
condition|)
block|{
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|writable
operator|=
name|TRUE
expr_stmt|;
name|last_hdr
operator|=
name|hdr
expr_stmt|;
comment|/* .tbss sections effectively have zero size.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
operator|(
name|SEC_THREAD_LOCAL
operator||
name|SEC_LOAD
operator|)
operator|)
operator|!=
name|SEC_THREAD_LOCAL
condition|)
name|last_size
operator|=
name|hdr
operator|->
name|_raw_size
expr_stmt|;
else|else
name|last_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* We need a new program segment.  We must create a new program          header holding all the sections from phdr_index until hdr.  */
name|m
operator|=
name|make_mapping
argument_list|(
name|abfd
argument_list|,
name|sections
argument_list|,
name|phdr_index
argument_list|,
name|i
argument_list|,
name|phdr_in_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|writable
operator|=
name|TRUE
expr_stmt|;
else|else
name|writable
operator|=
name|FALSE
expr_stmt|;
name|last_hdr
operator|=
name|hdr
expr_stmt|;
comment|/* .tbss sections effectively have zero size.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
operator|(
name|SEC_THREAD_LOCAL
operator||
name|SEC_LOAD
operator|)
operator|)
operator|!=
name|SEC_THREAD_LOCAL
condition|)
name|last_size
operator|=
name|hdr
operator|->
name|_raw_size
expr_stmt|;
else|else
name|last_size
operator|=
literal|0
expr_stmt|;
name|phdr_index
operator|=
name|i
expr_stmt|;
name|phdr_in_segment
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Create a final PT_LOAD program segment.  */
if|if
condition|(
name|last_hdr
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|make_mapping
argument_list|(
name|abfd
argument_list|,
name|sections
argument_list|,
name|phdr_index
argument_list|,
name|i
argument_list|,
name|phdr_in_segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
if|if
condition|(
name|dynsec
operator|!=
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_DYNAMIC
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|dynsec
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* For each loadable .note section, add a PT_NOTE segment.  We don't      use bfd_get_section_by_name, because if we link together      nonloadable .note sections and loadable .note sections, we will      generate two .note sections in the output file.  FIXME: Using      names for section types is bogus anyhow.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".note"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
condition|)
block|{
if|if
condition|(
operator|!
name|tls_count
condition|)
name|first_tls
operator|=
name|s
expr_stmt|;
name|tls_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there are any SHF_TLS output sections, add PT_TLS segment.  */
if|if
condition|(
name|tls_count
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|tls_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_TLS
expr_stmt|;
name|m
operator|->
name|count
operator|=
name|tls_count
expr_stmt|;
comment|/* Mandated PF_R.  */
name|m
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tls_count
condition|;
operator|++
name|i
control|)
block|{
name|BFD_ASSERT
argument_list|(
name|first_tls
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
argument_list|)
expr_stmt|;
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|=
name|first_tls
expr_stmt|;
name|first_tls
operator|=
name|first_tls
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME      segment.  */
name|eh_frame_hdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|eh_frame_hdr
expr_stmt|;
if|if
condition|(
name|eh_frame_hdr
operator|!=
name|NULL
operator|&&
operator|(
name|eh_frame_hdr
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_GNU_EH_FRAME
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|eh_frame_hdr
operator|->
name|output_section
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|stack_flags
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_GNU_STACK
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|stack_flags
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|sections
operator|=
name|NULL
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|=
name|mfirst
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Sort sections by address.  */
end_comment

begin_function
specifier|static
name|int
name|elf_sort_sections
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|asection
modifier|*
name|sec1
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
name|sec2
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|bfd_size_type
name|size1
decl_stmt|,
name|size2
decl_stmt|;
comment|/* Sort by LMA first, since this is the address used to      place the section into a segment.  */
if|if
condition|(
name|sec1
operator|->
name|lma
operator|<
name|sec2
operator|->
name|lma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sec1
operator|->
name|lma
operator|>
name|sec2
operator|->
name|lma
condition|)
return|return
literal|1
return|;
comment|/* Then sort by VMA.  Normally the LMA and the VMA will be      the same, and this will do nothing.  */
if|if
condition|(
name|sec1
operator|->
name|vma
operator|<
name|sec2
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sec1
operator|->
name|vma
operator|>
name|sec2
operator|->
name|vma
condition|)
return|return
literal|1
return|;
comment|/* Put !SEC_LOAD sections after SEC_LOAD ones.  */
define|#
directive|define
name|TOEND
parameter_list|(
name|x
parameter_list|)
value|(((x)->flags& (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)
if|if
condition|(
name|TOEND
argument_list|(
name|sec1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TOEND
argument_list|(
name|sec2
argument_list|)
condition|)
block|{
comment|/* If the indicies are the same, do not return 0 	     here, but continue to try the next comparison.  */
if|if
condition|(
name|sec1
operator|->
name|target_index
operator|-
name|sec2
operator|->
name|target_index
operator|!=
literal|0
condition|)
return|return
name|sec1
operator|->
name|target_index
operator|-
name|sec2
operator|->
name|target_index
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TOEND
argument_list|(
name|sec2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|TOEND
comment|/* Sort by size, to put zero sized sections      before others at the same address.  */
name|size1
operator|=
operator|(
name|sec1
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|?
name|sec1
operator|->
name|_raw_size
else|:
literal|0
expr_stmt|;
name|size2
operator|=
operator|(
name|sec2
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|?
name|sec2
operator|->
name|_raw_size
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|size1
operator|<
name|size2
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size1
operator|>
name|size2
condition|)
return|return
literal|1
return|;
return|return
name|sec1
operator|->
name|target_index
operator|-
name|sec2
operator|->
name|target_index
return|;
block|}
end_function

begin_comment
comment|/* Ian Lance Taylor writes:     We shouldn't be using % with a negative signed number.  That's just    not good.  We have to make sure either that the number is not    negative, or that the number has an unsigned type.  When the types    are all the same size they wind up as unsigned.  When file_ptr is a    larger signed type, the arithmetic winds up as signed long long,    which is wrong.     What we're trying to say here is something like ``increase OFF by    the least amount that will cause it to be equal to the VMA modulo    the page size.''  */
end_comment

begin_comment
comment|/* In other words, something like:     vma_offset = m->sections[0]->vma % bed->maxpagesize;    off_offset = off % bed->maxpagesize;    if (vma_offset< off_offset)      adjustment = vma_offset + bed->maxpagesize - off_offset;    else      adjustment = vma_offset - off_offset;          which can can be collapsed into the expression below.  */
end_comment

begin_function
specifier|static
name|file_ptr
name|vma_page_aligned_bias
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|ufile_ptr
name|off
parameter_list|,
name|bfd_vma
name|maxpagesize
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vma
operator|-
name|off
operator|)
operator|%
name|maxpagesize
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assign file positions to the sections based on the mapping from    sections to segments.  This function also sets up some fields in    the file header, and writes out the program headers.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|assign_file_positions_for_segments
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|file_ptr
name|off
decl_stmt|,
name|voff
decl_stmt|;
name|bfd_vma
name|filehdr_vaddr
decl_stmt|,
name|filehdr_paddr
decl_stmt|;
name|bfd_vma
name|phdrs_vaddr
decl_stmt|,
name|phdrs_paddr
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|map_sections_to_segments
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* The placement algorithm assumes that non allocated sections are 	 not in PT_LOAD segments.  We ensure this here by removing such 	 sections from the segment map.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|new_count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
name|new_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|new_count
condition|)
name|m
operator|->
name|sections
index|[
name|new_count
index|]
operator|=
name|m
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
name|new_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_count
operator|!=
name|m
operator|->
name|count
condition|)
name|m
operator|->
name|count
operator|=
name|new_count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_modify_segment_map
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_modify_segment_map
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phoff
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phentsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If we already counted the number of program segments, make sure      that we allocated enough space.  This happens when SIZEOF_HEADERS      is used in a linker script.  */
name|alloc
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
if|if
condition|(
name|alloc
operator|!=
literal|0
operator|&&
name|count
operator|>
name|alloc
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Not enough room for program headers (allocated %u, need %u)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|alloc
argument_list|,
name|count
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
name|count
expr_stmt|;
name|amt
operator|=
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
expr_stmt|;
name|phdrs
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdrs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|off
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|off
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|filehdr_vaddr
operator|=
literal|0
expr_stmt|;
name|filehdr_paddr
operator|=
literal|0
expr_stmt|;
name|phdrs_vaddr
operator|=
literal|0
expr_stmt|;
name|phdrs_paddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|phdrs
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
comment|/* If elf_segment_map is not from map_sections_to_segments, the          sections may not be correctly ordered.  NOTE: sorting should 	 not be done to the PT_NOTE section of a corefile, which may 	 contain several pseudo-sections artificially created by bfd. 	 Sorting these pseudo-sections breaks things badly.  */
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|1
operator|&&
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_CORE
operator|&&
name|m
operator|->
name|p_type
operator|==
name|PT_NOTE
operator|)
condition|)
name|qsort
argument_list|(
name|m
operator|->
name|sections
argument_list|,
operator|(
name|size_t
operator|)
name|m
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|elf_sort_sections
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_type
operator|=
name|m
operator|->
name|p_type
expr_stmt|;
name|p
operator|->
name|p_flags
operator|=
name|m
operator|->
name|p_flags
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|m
operator|->
name|count
operator|>
literal|0
operator|&&
operator|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
name|vma_page_aligned_bias
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
argument_list|,
name|off
argument_list|,
name|bed
operator|->
name|maxpagesize
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|align
decl_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|secpp
operator|=
name|m
operator|->
name|sections
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|secpp
operator|++
control|)
block|{
name|bfd_size_type
name|secalign
decl_stmt|;
name|secalign
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
operator|*
name|secpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|secalign
operator|>
name|align
condition|)
name|align
operator|=
name|secalign
expr_stmt|;
block|}
name|off
operator|+=
name|vma_page_aligned_bias
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
argument_list|,
name|off
argument_list|,
literal|1
operator|<<
name|align
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|p_vaddr
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|m
operator|->
name|p_paddr
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|p_paddr
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|lma
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_align
operator|=
name|bed
operator|->
name|maxpagesize
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_align
operator|=
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
else|else
name|p
operator|->
name|p_align
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_vaddr
operator|<
operator|(
name|bfd_vma
operator|)
name|off
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Not enough room for program headers, try linking with -N"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|->
name|p_vaddr
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|-=
name|off
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|filehdr_vaddr
operator|=
name|p
operator|->
name|p_vaddr
expr_stmt|;
name|filehdr_paddr
operator|=
name|p
operator|->
name|p_paddr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|includes_phdrs
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|phdrs_vaddr
operator|=
name|p
operator|->
name|p_vaddr
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|phdrs_paddr
operator|=
name|p
operator|->
name|p_paddr
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|p_offset
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vaddr
operator|-=
name|off
operator|-
name|p
operator|->
name|p_offset
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|-=
name|off
operator|-
name|p
operator|->
name|p_offset
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|phdrs_vaddr
operator|=
name|p
operator|->
name|p_vaddr
expr_stmt|;
name|phdrs_paddr
operator|=
name|p
operator|->
name|p_paddr
expr_stmt|;
block|}
else|else
name|phdrs_vaddr
operator|=
name|bed
operator|->
name|maxpagesize
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
block|}
name|p
operator|->
name|p_filesz
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|||
operator|(
name|p
operator|->
name|p_type
operator|==
name|PT_NOTE
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_core
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|includes_filehdr
operator|&&
operator|!
name|m
operator|->
name|includes_phdrs
condition|)
name|p
operator|->
name|p_offset
operator|=
name|off
expr_stmt|;
else|else
block|{
name|file_ptr
name|adjust
decl_stmt|;
name|adjust
operator|=
name|off
operator|-
operator|(
name|p
operator|->
name|p_offset
operator|+
name|p
operator|->
name|p_filesz
operator|)
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
block|}
block|}
name|voff
operator|=
name|off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|secpp
operator|=
name|m
operator|->
name|sections
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|secpp
operator|++
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|align
decl_stmt|;
name|sec
operator|=
operator|*
name|secpp
expr_stmt|;
name|flags
operator|=
name|sec
operator|->
name|flags
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* The section may have artificial alignment forced by a 	     link script.  Notice this case by the gap between the 	     cumulative phdr lma and the section's lma.  */
if|if
condition|(
name|p
operator|->
name|p_paddr
operator|+
name|p
operator|->
name|p_memsz
operator|<
name|sec
operator|->
name|lma
condition|)
block|{
name|bfd_vma
name|adjust
init|=
name|sec
operator|->
name|lma
operator|-
operator|(
name|p
operator|->
name|p_paddr
operator|+
name|p
operator|->
name|p_memsz
operator|)
decl_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|||
operator|(
name|p
operator|->
name|p_type
operator|==
name|PT_NOTE
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_core
operator|)
condition|)
block|{
name|off
operator|+=
name|adjust
expr_stmt|;
name|voff
operator|+=
name|adjust
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|bfd_signed_vma
name|adjust
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|adjust
operator|=
name|sec
operator|->
name|lma
operator|-
operator|(
name|p
operator|->
name|p_paddr
operator|+
name|p
operator|->
name|p_memsz
operator|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|<
literal|0
condition|)
name|adjust
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The section VMA must equal the file position 		     modulo the page size.  FIXME: I'm not sure if 		     this adjustment is really necessary.  We used to 		     not have the SEC_LOAD case just above, and then 		     this was necessary, but now I'm not sure.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|adjust
operator|=
name|vma_page_aligned_bias
argument_list|(
name|sec
operator|->
name|vma
argument_list|,
name|voff
argument_list|,
name|bed
operator|->
name|maxpagesize
argument_list|)
expr_stmt|;
else|else
name|adjust
operator|=
name|vma_page_aligned_bias
argument_list|(
name|sec
operator|->
name|vma
argument_list|,
name|voff
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\ Error: First section in segment (%s) starts at 0x%x whereas the segment starts at 0x%x"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|sec
operator|->
name|lma
argument_list|,
name|p
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|->
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
name|off
operator|+=
name|adjust
expr_stmt|;
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
block|}
name|sec
operator|->
name|filepos
operator|=
name|off
expr_stmt|;
comment|/* We check SEC_HAS_CONTENTS here because if NOLOAD is                  used in a linker script we may have a section with                  SEC_LOAD clear but which is supposed to have                  contents.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|==
literal|0
operator|)
condition|)
name|voff
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_NOTE
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_core
condition|)
block|{
comment|/* The actual "note" segment has i == 0. 		 This is the one that actually contains everything.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|sec
operator|->
name|filepos
operator|=
name|off
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|off
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|voff
operator|=
name|off
expr_stmt|;
block|}
else|else
block|{
comment|/* Fake sections -- don't need to be written.  */
name|sec
operator|->
name|filepos
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|sec
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_align
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|==
literal|0
operator|||
name|p
operator|->
name|p_type
operator|==
name|PT_TLS
condition|)
name|p
operator|->
name|p_memsz
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_filesz
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_TLS
operator|&&
name|sec
operator|->
name|_raw_size
operator|==
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|o
decl_stmt|;
name|bfd_vma
name|tbss_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|o
operator|=
name|sec
operator|->
name|link_order_head
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|tbss_size
operator|<
name|o
operator|->
name|offset
operator|+
name|o
operator|->
name|size
condition|)
name|tbss_size
operator|=
name|o
operator|->
name|offset
operator|+
name|o
operator|->
name|size
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|tbss_size
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
name|p
operator|->
name|p_align
operator|&&
operator|(
name|p
operator|->
name|p_type
operator|!=
name|PT_LOAD
operator|||
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|==
literal|0
operator|)
condition|)
name|p
operator|->
name|p_align
operator|=
name|align
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
block|{
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that we have set the section file positions, we can set up      the file positions for the non PT_LOAD segments.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|phdrs
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_type
operator|!=
name|PT_LOAD
operator|&&
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|m
operator|->
name|includes_filehdr
operator|&&
operator|!
name|m
operator|->
name|includes_phdrs
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|filepos
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
name|p
operator|->
name|p_vaddr
operator|=
name|filehdr_vaddr
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|filehdr_paddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|includes_phdrs
condition|)
block|{
name|p
operator|->
name|p_vaddr
operator|=
name|phdrs_vaddr
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|phdrs_paddr
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear out any program headers we allocated but did not use.  */
for|for
control|(
init|;
name|count
operator|<
name|alloc
condition|;
name|count
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|phdrs
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
comment|/* Write out the program headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bed
operator|->
name|s
operator|->
name|write_out_phdrs
argument_list|(
name|abfd
argument_list|,
name|phdrs
argument_list|,
name|alloc
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the program header.     If this is called by the linker before any of the section VMA's are set, it    can't calculate the correct value for a strange memory layout.  This only    happens when SIZEOF_HEADERS is used in a linker script.  In this case,    SORTED_HDRS is NULL and we assume the normal scenario of one text and one    data segment (exclusive of .interp and .dynamic).     ??? User written scripts must either not use SIZEOF_HEADERS, or assume there    will be two segments.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|get_program_header_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|size_t
name|segs
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* We can't return a different result each time we're called.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|!=
literal|0
condition|)
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|segs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
operator|++
name|segs
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
name|segs
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
block|}
comment|/* Assume we will need exactly two PT_LOAD segments: one for text      and one for data.  */
name|segs
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we have a loadable interpreter section, we need a 	 PT_INTERP segment.  In this case, assume we also need a 	 PT_PHDR segment, although that may not be true for all 	 targets.  */
name|segs
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We need a PT_DYNAMIC segment.  */
operator|++
name|segs
expr_stmt|;
block|}
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|eh_frame_hdr
condition|)
block|{
comment|/* We need a PT_GNU_EH_FRAME segment.  */
operator|++
name|segs
expr_stmt|;
block|}
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|stack_flags
condition|)
block|{
comment|/* We need a PT_GNU_STACK segment.  */
operator|++
name|segs
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".note"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We need a PT_NOTE segment.  */
operator|++
name|segs
expr_stmt|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
condition|)
block|{
comment|/* We need a PT_TLS segment.  */
operator|++
name|segs
expr_stmt|;
break|break;
block|}
block|}
comment|/* Let the backend count up any program headers it might need.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_additional_program_headers
condition|)
block|{
name|int
name|a
decl_stmt|;
name|a
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_additional_program_headers
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|segs
operator|+=
name|a
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
name|segs
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
block|}
end_function

begin_comment
comment|/* Work out the file positions of all the sections.  This is called by    _bfd_elf_compute_section_file_positions.  All the section sizes and    VMAs must be known before this is called.     We do not consider reloc sections at this point, unless they form    part of the loadable image.  Reloc sections are assigned file    positions in assign_file_positions_for_relocs, which is called by    write_object_contents and final_link.     We also don't set the positions of the .symtab and .strtab here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|assign_file_positions_except_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|struct
name|elf_obj_tdata
modifier|*
specifier|const
name|tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
specifier|const
name|i_ehdrp
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
specifier|const
name|i_shdrpp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|num_sec
init|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_core
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Start after the ELF header.  */
name|off
operator|=
name|i_ehdrp
operator|->
name|e_ehsize
expr_stmt|;
comment|/* We are not creating an executable, which means that we are 	 not creating a program header, and that the actual order of 	 the sections in the file is unimportant.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|num_sec
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|||
name|i
operator|==
name|tdata
operator|->
name|symtab_section
operator|||
name|i
operator|==
name|tdata
operator|->
name|symtab_shndx_section
operator|||
name|i
operator|==
name|tdata
operator|->
name|strtab_section
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
block|{
name|i
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|hdrpp
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
comment|/* Assign file positions for the loaded sections based on the          assignment of sections to segments.  */
if|if
condition|(
operator|!
name|assign_file_positions_for_segments
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Assign file positions for the other sections.  */
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|num_sec
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|bfd_section
operator|->
name|filepos
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_offset
operator|=
name|hdr
operator|->
name|bfd_section
operator|->
name|filepos
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: allocated section `%s' not in segment"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|hdr
operator|->
name|bfd_section
operator|==
name|NULL
condition|?
literal|"*unknown*"
else|:
name|hdr
operator|->
name|bfd_section
operator|->
name|name
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
name|vma_page_aligned_bias
argument_list|(
name|hdr
operator|->
name|sh_addr
argument_list|,
name|off
argument_list|,
name|bed
operator|->
name|maxpagesize
argument_list|)
expr_stmt|;
else|else
name|off
operator|+=
name|vma_page_aligned_bias
argument_list|(
name|hdr
operator|->
name|sh_addr
argument_list|,
name|off
argument_list|,
name|hdr
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdr
operator|==
name|i_shdrpp
index|[
name|tdata
operator|->
name|symtab_section
index|]
operator|||
name|hdr
operator|==
name|i_shdrpp
index|[
name|tdata
operator|->
name|symtab_shndx_section
index|]
operator|||
name|hdr
operator|==
name|i_shdrpp
index|[
name|tdata
operator|->
name|strtab_section
index|]
condition|)
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
block|{
name|i
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|hdrpp
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
block|}
block|}
comment|/* Place the section headers.  */
name|off
operator|=
name|align_file_position
argument_list|(
name|off
argument_list|,
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shoff
operator|=
name|off
expr_stmt|;
name|off
operator|+=
name|i_ehdrp
operator|->
name|e_shnum
operator|*
name|i_ehdrp
operator|->
name|e_shentsize
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|prep_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
init|=
literal|0
decl_stmt|;
comment|/* Program header table, internal form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|struct
name|elf_strtab_hash
modifier|*
name|shstrtab
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shstrtab
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|bed
operator|->
name|s
operator|->
name|elfclass
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
name|ELFDATA2MSB
else|:
name|ELFDATA2LSB
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|bed
operator|->
name|s
operator|->
name|ev_current
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_DYN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_core
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
else|else
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_REL
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_unknown
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
break|break;
comment|/* There used to be a long list of cases here, each one setting 	 e_machine to the same EM_* macro #defined as ELF_MACHINE_CODE 	 in the corresponding bfd definition.  To avoid duplication, 	 the switch was removed.  Machines that need special handling 	 can generally do it in elf_backend_final_write_processing(), 	 unless they need the information earlier than the final write. 	 Such need can generally be supplied by replacing the tests for 	 e_machine with the conditions used to determine it.  */
default|default:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|bed
operator|->
name|elf_machine_code
expr_stmt|;
block|}
name|i_ehdrp
operator|->
name|e_version
operator|=
name|bed
operator|->
name|s
operator|->
name|ev_current
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ehsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
comment|/* No program header, for now.  */
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phnum
operator|=
literal|0
expr_stmt|;
comment|/* Each bfd section is section header entry.  */
name|i_ehdrp
operator|->
name|e_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shentsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_shdr
expr_stmt|;
comment|/* If we're building an executable, we'll need a program header table.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* It all happens later.  */
if|#
directive|if
literal|0
block|i_ehdrp->e_phentsize = sizeof (Elf_External_Phdr);
comment|/* elf_build_phdrs() returns a (NULL-terminated) array of 	 Elf_Internal_Phdrs.  */
block|i_phdrp = elf_build_phdrs (abfd, i_ehdrp, i_shdrp,&i_ehdrp->e_phnum);       i_ehdrp->e_phoff = outbase;       outbase += i_ehdrp->e_phentsize * i_ehdrp->e_phnum;
endif|#
directive|endif
block|}
else|else
block|{
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_phdrp
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".symtab"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".strtab"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_elf_strtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".shstrtab"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Assign file positions for all the reloc sections which are not part    of the loadable file image.  */
end_comment

begin_function
name|void
name|_bfd_elf_assign_file_positions_for_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|file_ptr
name|off
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|num_sec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|shdrpp
decl_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|num_sec
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|shdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|num_sec
condition|;
name|i
operator|++
operator|,
name|shdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdrp
decl_stmt|;
name|shdrp
operator|=
operator|*
name|shdrpp
expr_stmt|;
if|if
condition|(
operator|(
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|)
operator|&&
name|shdrp
operator|->
name|sh_offset
operator|==
operator|-
literal|1
condition|)
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|shdrp
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|bfd_boolean
name|failed
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|num_sec
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|failed
operator|=
name|FALSE
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|s
operator|->
name|write_relocs
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
return|return
name|FALSE
return|;
name|_bfd_elf_assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* After writing the headers, we need to write the sections too...  */
name|num_sec
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|num_sec
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
condition|)
block|{
name|bfd_size_type
name|amt
init|=
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_size
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|count
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
name|count
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
comment|/* Write out the section header names.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_elf_strtab_emit
argument_list|(
name|abfd
argument_list|,
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_final_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_final_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
argument_list|)
expr_stmt|;
return|return
name|bed
operator|->
name|s
operator|->
name|write_shdrs_and_ehdr
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_write_corefile_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* Hopefully this can be done just like an object file.  */
return|return
name|_bfd_elf_write_object_contents
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a section, search the header to find them.  */
end_comment

begin_function
name|int
name|_bfd_elf_section_from_bfd_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|asect
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|this_idx
operator|!=
literal|0
condition|)
return|return
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|this_idx
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|asect
argument_list|)
condition|)
name|index
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|asect
argument_list|)
condition|)
name|index
operator|=
name|SHN_COMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|asect
argument_list|)
condition|)
name|index
operator|=
name|SHN_UNDEF
expr_stmt|;
else|else
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|maxindex
init|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|hdr
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|bfd_section
operator|==
name|asect
condition|)
return|return
name|index
return|;
block|}
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_bfd_section
condition|)
block|{
name|int
name|retval
init|=
name|index
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_bfd_section
call|)
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
operator|&
name|retval
argument_list|)
condition|)
return|return
name|retval
return|;
block|}
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD symbol, return the index in the ELF symbol table, or -1    on error.  */
end_comment

begin_function
name|int
name|_bfd_elf_symbol_from_bfd_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|asym_ptr_ptr
parameter_list|)
block|{
name|asymbol
modifier|*
name|asym_ptr
init|=
operator|*
name|asym_ptr_ptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|flagword
name|flags
init|=
name|asym_ptr
operator|->
name|flags
decl_stmt|;
comment|/* When gas creates relocations against local labels, it creates its      own symbol for the section, but does put the symbol into the      symbol chain, so udata is 0.  When the linker is generating      relocatable output, this section symbol may be for one of the      input sections rather than the output section.  */
if|if
condition|(
name|asym_ptr
operator|->
name|udata
operator|.
name|i
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
name|asym_ptr
operator|->
name|section
condition|)
block|{
name|int
name|indx
decl_stmt|;
if|if
condition|(
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|index
expr_stmt|;
else|else
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|indx
operator|<
name|elf_num_section_syms
argument_list|(
name|abfd
argument_list|)
operator|&&
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
operator|!=
name|NULL
condition|)
name|asym_ptr
operator|->
name|udata
operator|.
name|i
operator|=
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
operator|->
name|udata
operator|.
name|i
expr_stmt|;
block|}
name|idx
operator|=
name|asym_ptr
operator|->
name|udata
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
comment|/* This case can occur when using --strip-symbol on a symbol          which is used in a relocation entry.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: symbol `%s' required but not present"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|asym_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|DEBUG
operator|&
literal|4
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n"
argument_list|,
operator|(
name|long
operator|)
name|asym_ptr
argument_list|,
name|asym_ptr
operator|->
name|name
argument_list|,
name|idx
argument_list|,
name|flags
argument_list|,
name|elf_symbol_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Copy private BFD data.  This copies any program header information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|iehdr
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|map
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|map_first
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|pointer_to_map
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|num_segments
decl_stmt|;
name|bfd_boolean
name|phdr_included
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|maxpagesize
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|phdr_adjust_seg
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|phdr_adjust_num
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|iehdr
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|map_first
operator|=
name|NULL
expr_stmt|;
name|pointer_to_map
operator|=
operator|&
name|map_first
expr_stmt|;
name|num_segments
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_phnum
expr_stmt|;
name|maxpagesize
operator|=
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|maxpagesize
expr_stmt|;
comment|/* Returns the end address of the segment + 1.  */
define|#
directive|define
name|SEGMENT_END
parameter_list|(
name|segment
parameter_list|,
name|start
parameter_list|)
define|\
value|(start + (segment->p_memsz> segment->p_filesz			\ 	    ? segment->p_memsz : segment->p_filesz))
define|#
directive|define
name|SECTION_SIZE
parameter_list|(
name|section
parameter_list|,
name|segment
parameter_list|)
define|\
value|(((section->flags& (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\     != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\    ? section->_raw_size : 0)
comment|/* Returns TRUE if the given section is contained within      the given segment.  VMA addresses are compared.  */
define|#
directive|define
name|IS_CONTAINED_BY_VMA
parameter_list|(
name|section
parameter_list|,
name|segment
parameter_list|)
define|\
value|(section->vma>= segment->p_vaddr					\&& (section->vma + SECTION_SIZE (section, segment)			\<= (SEGMENT_END (segment, segment->p_vaddr))))
comment|/* Returns TRUE if the given section is contained within      the given segment.  LMA addresses are compared.  */
define|#
directive|define
name|IS_CONTAINED_BY_LMA
parameter_list|(
name|section
parameter_list|,
name|segment
parameter_list|,
name|base
parameter_list|)
define|\
value|(section->lma>= base							\&& (section->lma + SECTION_SIZE (section, segment)			\<= SEGMENT_END (segment, base)))
comment|/* Special case: corefile "NOTE" section containing regs, prpsinfo etc.  */
define|#
directive|define
name|IS_COREFILE_NOTE
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(p->p_type == PT_NOTE							\&& bfd_get_format (ibfd) == bfd_core					\&& s->vma == 0&& s->lma == 0					\&& (bfd_vma) s->filepos>= p->p_offset				\&& ((bfd_vma) s->filepos + s->_raw_size				\<= p->p_offset + p->p_filesz))
comment|/* The complicated case when p_vaddr is 0 is to handle the Solaris      linker, which generates a PT_INTERP section with p_vaddr and      p_memsz set to 0.  */
define|#
directive|define
name|IS_SOLARIS_PT_INTERP
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(p->p_vaddr == 0							\&& p->p_paddr == 0							\&& p->p_memsz == 0							\&& p->p_filesz> 0							\&& (s->flags& SEC_HAS_CONTENTS) != 0				\&& s->_raw_size> 0							\&& (bfd_vma) s->filepos>= p->p_offset				\&& ((bfd_vma) s->filepos + s->_raw_size				\<= p->p_offset + p->p_filesz))
comment|/* Decide if the given section should be included in the given segment.      A section will be included if:        1. It is within the address space of the segment -- we use the LMA           if that is set for the segment and the VMA otherwise,        2. It is an allocated segment,        3. There is an output section associated with it,        4. The section has not already been allocated to a previous segment.        5. PT_GNU_STACK segments do not include any sections.        6. PT_TLS segment includes only SHF_TLS sections.        7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
define|#
directive|define
name|INCLUDE_SECTION_IN_SEGMENT
parameter_list|(
name|section
parameter_list|,
name|segment
parameter_list|,
name|bed
parameter_list|)
define|\
value|((((segment->p_paddr							\       ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\       : IS_CONTAINED_BY_VMA (section, segment))				\&& (section->flags& SEC_ALLOC) != 0)				\     || IS_COREFILE_NOTE (segment, section))				\&& section->output_section != NULL					\&& segment->p_type != PT_GNU_STACK					\&& (segment->p_type != PT_TLS					\        || (section->flags& SEC_THREAD_LOCAL))				\&& (segment->p_type == PT_LOAD					\        || segment->p_type == PT_TLS					\        || (section->flags& SEC_THREAD_LOCAL) == 0)			\&& ! section->segment_mark)
comment|/* Returns TRUE iff seg1 starts after the end of seg2.  */
define|#
directive|define
name|SEGMENT_AFTER_SEGMENT
parameter_list|(
name|seg1
parameter_list|,
name|seg2
parameter_list|,
name|field
parameter_list|)
define|\
value|(seg1->field>= SEGMENT_END (seg2, seg2->field))
comment|/* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both      their VMA address ranges and their LMA address ranges overlap.      It is possible to have overlapping VMA ranges without overlapping LMA      ranges.  RedBoot images for example can have both .data and .bss mapped      to the same VMA range, but with the .data section mapped to a different      LMA.  */
define|#
directive|define
name|SEGMENT_OVERLAPS
parameter_list|(
name|seg1
parameter_list|,
name|seg2
parameter_list|)
define|\
value|(   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\         || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\&& !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\         || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))
comment|/* Initialise the segment mark field.  */
for|for
control|(
name|section
operator|=
name|ibfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
name|section
operator|->
name|segment_mark
operator|=
name|FALSE
expr_stmt|;
comment|/* Scan through the segments specified in the program header      of the input BFD.  For this first scan we look for overlaps      in the loadable segments.  These can be created by weird      parameters to objcopy.  Also, fix some solaris weirdness.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
init|;
name|i
operator|<
name|num_segments
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|segment2
decl_stmt|;
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_INTERP
condition|)
for|for
control|(
name|section
operator|=
name|ibfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|IS_SOLARIS_PT_INTERP
argument_list|(
name|segment
argument_list|,
name|section
argument_list|)
condition|)
block|{
comment|/* Mininal change so that the normal section to segment 		 assignment code will work.  */
name|segment
operator|->
name|p_vaddr
operator|=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|segment
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
comment|/* Determine if this segment overlaps any previous segments.  */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|segment2
operator|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|segment2
operator|++
control|)
block|{
name|bfd_signed_vma
name|extra_length
decl_stmt|;
if|if
condition|(
name|segment2
operator|->
name|p_type
operator|!=
name|PT_LOAD
operator|||
operator|!
name|SEGMENT_OVERLAPS
argument_list|(
name|segment
argument_list|,
name|segment2
argument_list|)
condition|)
continue|continue;
comment|/* Merge the two segments together.  */
if|if
condition|(
name|segment2
operator|->
name|p_vaddr
operator|<
name|segment
operator|->
name|p_vaddr
condition|)
block|{
comment|/* Extend SEGMENT2 to include SEGMENT and then delete                  SEGMENT.  */
name|extra_length
operator|=
name|SEGMENT_END
argument_list|(
name|segment
argument_list|,
name|segment
operator|->
name|p_vaddr
argument_list|)
operator|-
name|SEGMENT_END
argument_list|(
name|segment2
argument_list|,
name|segment2
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_length
operator|>
literal|0
condition|)
block|{
name|segment2
operator|->
name|p_memsz
operator|+=
name|extra_length
expr_stmt|;
name|segment2
operator|->
name|p_filesz
operator|+=
name|extra_length
expr_stmt|;
block|}
name|segment
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
comment|/* Since we have deleted P we must restart the outer loop.  */
name|i
operator|=
literal|0
expr_stmt|;
name|segment
operator|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Extend SEGMENT to include SEGMENT2 and then delete                  SEGMENT2.  */
name|extra_length
operator|=
name|SEGMENT_END
argument_list|(
name|segment2
argument_list|,
name|segment2
operator|->
name|p_vaddr
argument_list|)
operator|-
name|SEGMENT_END
argument_list|(
name|segment
argument_list|,
name|segment
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_length
operator|>
literal|0
condition|)
block|{
name|segment
operator|->
name|p_memsz
operator|+=
name|extra_length
expr_stmt|;
name|segment
operator|->
name|p_filesz
operator|+=
name|extra_length
expr_stmt|;
block|}
name|segment2
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* The second scan attempts to assign sections to segments.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
init|;
name|i
operator|<
name|num_segments
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
name|unsigned
name|int
name|section_count
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|unsigned
name|int
name|isec
decl_stmt|;
name|bfd_vma
name|matching_lma
decl_stmt|;
name|bfd_vma
name|suggested_lma
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_NULL
condition|)
continue|continue;
comment|/* Compute how many sections might be placed into this segment.  */
for|for
control|(
name|section
operator|=
name|ibfd
operator|->
name|sections
operator|,
name|section_count
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|INCLUDE_SECTION_IN_SEGMENT
argument_list|(
name|section
argument_list|,
name|segment
argument_list|,
name|bed
argument_list|)
condition|)
operator|++
name|section_count
expr_stmt|;
comment|/* Allocate a segment map big enough to contain 	 all of the sections we have selected.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
operator|(
name|bfd_size_type
operator|)
name|section_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|map
operator|=
name|bfd_alloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Initialise the fields of the segment map.  Default to 	 using the physical address of the segment in the input BFD.  */
name|map
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|p_type
operator|=
name|segment
operator|->
name|p_type
expr_stmt|;
name|map
operator|->
name|p_flags
operator|=
name|segment
operator|->
name|p_flags
expr_stmt|;
name|map
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|p_paddr
operator|=
name|segment
operator|->
name|p_paddr
expr_stmt|;
name|map
operator|->
name|p_paddr_valid
operator|=
literal|1
expr_stmt|;
comment|/* Determine if this segment contains the ELF file header 	 and if it contains the program headers themselves.  */
name|map
operator|->
name|includes_filehdr
operator|=
operator|(
name|segment
operator|->
name|p_offset
operator|==
literal|0
operator|&&
name|segment
operator|->
name|p_filesz
operator|>=
name|iehdr
operator|->
name|e_ehsize
operator|)
expr_stmt|;
name|map
operator|->
name|includes_phdrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|phdr_included
operator|||
name|segment
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
block|{
name|map
operator|->
name|includes_phdrs
operator|=
operator|(
name|segment
operator|->
name|p_offset
operator|<=
operator|(
name|bfd_vma
operator|)
name|iehdr
operator|->
name|e_phoff
operator|&&
operator|(
name|segment
operator|->
name|p_offset
operator|+
name|segment
operator|->
name|p_filesz
operator|>=
operator|(
operator|(
name|bfd_vma
operator|)
name|iehdr
operator|->
name|e_phoff
operator|+
name|iehdr
operator|->
name|e_phnum
operator|*
name|iehdr
operator|->
name|e_phentsize
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|map
operator|->
name|includes_phdrs
condition|)
name|phdr_included
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|section_count
operator|==
literal|0
condition|)
block|{
comment|/* Special segments, such as the PT_PHDR segment, may contain 	     no sections, but ordinary, loadable segments should contain 	     something.  They are allowed by the ELF spec however, so only 	     a warning is produced.  */
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: Empty loadable segment detected, is this intentional ?\n"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|count
operator|=
literal|0
expr_stmt|;
operator|*
name|pointer_to_map
operator|=
name|map
expr_stmt|;
name|pointer_to_map
operator|=
operator|&
name|map
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Now scan the sections in the input BFD again and attempt 	 to add their corresponding output sections to the segment map. 	 The problem here is how to handle an output section which has 	 been moved (ie had its LMA changed).  There are four possibilities:  	 1. None of the sections have been moved. 	    In this case we can continue to use the segment LMA from the 	    input BFD.  	 2. All of the sections have been moved by the same amount. 	    In this case we can change the segment's LMA to match the LMA 	    of the first section.  	 3. Some of the sections have been moved, others have not. 	    In this case those sections which have not been moved can be 	    placed in the current segment which will have to have its size, 	    and possibly its LMA changed, and a new segment or segments will 	    have to be created to contain the other sections.  	 4. The sections have been moved, but not by the same amount. 	    In this case we can change the segment's LMA to match the LMA 	    of the first section and we will have to create a new segment 	    or segments to contain the other sections.  	 In order to save time, we allocate an array to hold the section 	 pointers that we are interested in.  As these sections get assigned 	 to a segment, they are removed from this array.  */
comment|/* Gcc 2.96 miscompiles this code on mips. Don't do casting here 	 to work around this long long bug.  */
name|amt
operator|=
name|section_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Step One: Scan for segment vs section LMA conflicts. 	 Also add the sections to the section array allocated above. 	 Also add the sections to the current segment.  In the common 	 case, where the sections have not been moved, this means that 	 we have completely filled the segment, and there is nothing 	 more to do.  */
name|isec
operator|=
literal|0
expr_stmt|;
name|matching_lma
operator|=
literal|0
expr_stmt|;
name|suggested_lma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|section
operator|=
name|ibfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INCLUDE_SECTION_IN_SEGMENT
argument_list|(
name|section
argument_list|,
name|segment
argument_list|,
name|bed
argument_list|)
condition|)
block|{
name|output_section
operator|=
name|section
operator|->
name|output_section
expr_stmt|;
name|sections
index|[
name|j
operator|++
index|]
operator|=
name|section
expr_stmt|;
comment|/* The Solaris native linker always sets p_paddr to 0. 		 We try to catch that case here, and set it to the 		 correct value.  Note - some backends require that 		 p_paddr be left as zero.  */
if|if
condition|(
name|segment
operator|->
name|p_paddr
operator|==
literal|0
operator|&&
name|segment
operator|->
name|p_vaddr
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|bed
operator|->
name|want_p_paddr_set_to_zero
operator|)
operator|&&
name|isec
operator|==
literal|0
operator|&&
name|output_section
operator|->
name|lma
operator|!=
literal|0
operator|&&
operator|(
name|output_section
operator|->
name|vma
operator|==
operator|(
name|segment
operator|->
name|p_vaddr
operator|+
operator|(
name|map
operator|->
name|includes_filehdr
condition|?
name|iehdr
operator|->
name|e_ehsize
else|:
literal|0
operator|)
operator|+
operator|(
name|map
operator|->
name|includes_phdrs
condition|?
operator|(
name|iehdr
operator|->
name|e_phnum
operator|*
name|iehdr
operator|->
name|e_phentsize
operator|)
else|:
literal|0
operator|)
operator|)
operator|)
condition|)
name|map
operator|->
name|p_paddr
operator|=
name|segment
operator|->
name|p_vaddr
expr_stmt|;
comment|/* Match up the physical address of the segment with the 		 LMA address of the output section.  */
if|if
condition|(
name|IS_CONTAINED_BY_LMA
argument_list|(
name|output_section
argument_list|,
name|segment
argument_list|,
name|map
operator|->
name|p_paddr
argument_list|)
operator|||
name|IS_COREFILE_NOTE
argument_list|(
name|segment
argument_list|,
name|section
argument_list|)
operator|||
operator|(
name|bed
operator|->
name|want_p_paddr_set_to_zero
operator|&&
name|IS_CONTAINED_BY_VMA
argument_list|(
name|output_section
argument_list|,
name|segment
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|matching_lma
operator|==
literal|0
condition|)
name|matching_lma
operator|=
name|output_section
operator|->
name|lma
expr_stmt|;
comment|/* We assume that if the section fits within the segment 		     then it does not overlap any other section within that 		     segment.  */
name|map
operator|->
name|sections
index|[
name|isec
operator|++
index|]
operator|=
name|output_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suggested_lma
operator|==
literal|0
condition|)
name|suggested_lma
operator|=
name|output_section
operator|->
name|lma
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|j
operator|==
name|section_count
argument_list|)
expr_stmt|;
comment|/* Step Two: Adjust the physical address of the current segment, 	 if necessary.  */
if|if
condition|(
name|isec
operator|==
name|section_count
condition|)
block|{
comment|/* All of the sections fitted within the segment as currently 	     specified.  This is the default case.  Add the segment to 	     the list of built segments and carry on to process the next 	     program header in the input BFD.  */
name|map
operator|->
name|count
operator|=
name|section_count
expr_stmt|;
operator|*
name|pointer_to_map
operator|=
name|map
expr_stmt|;
name|pointer_to_map
operator|=
operator|&
name|map
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|matching_lma
operator|!=
literal|0
condition|)
block|{
comment|/* At least one section fits inside the current segment. 		 Keep it, but modify its physical address to match the 		 LMA of the first section that fitted.  */
name|map
operator|->
name|p_paddr
operator|=
name|matching_lma
expr_stmt|;
block|}
else|else
block|{
comment|/* None of the sections fitted inside the current segment. 		 Change the current segment's physical address to match 		 the LMA of the first section.  */
name|map
operator|->
name|p_paddr
operator|=
name|suggested_lma
expr_stmt|;
block|}
comment|/* Offset the segment physical address from the lma 	     to allow for space taken up by elf headers.  */
if|if
condition|(
name|map
operator|->
name|includes_filehdr
condition|)
name|map
operator|->
name|p_paddr
operator|-=
name|iehdr
operator|->
name|e_ehsize
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|includes_phdrs
condition|)
block|{
name|map
operator|->
name|p_paddr
operator|-=
name|iehdr
operator|->
name|e_phnum
operator|*
name|iehdr
operator|->
name|e_phentsize
expr_stmt|;
comment|/* iehdr->e_phnum is just an estimate of the number 		 of program headers that we will need.  Make a note 		 here of the number we used and the segment we chose 		 to hold these headers, so that we can adjust the 		 offset when we know the correct value.  */
name|phdr_adjust_num
operator|=
name|iehdr
operator|->
name|e_phnum
expr_stmt|;
name|phdr_adjust_seg
operator|=
name|map
expr_stmt|;
block|}
block|}
comment|/* Step Three: Loop over the sections again, this time assigning 	 those that fit to the current segment and removing them from the 	 sections array; but making sure not to leave large gaps.  Once all 	 possible sections have been assigned to the current segment it is 	 added to the list of built segments and if sections still remain 	 to be assigned, a new segment is constructed before repeating 	 the loop.  */
name|isec
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|map
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|suggested_lma
operator|=
literal|0
expr_stmt|;
comment|/* Fill the current segment with sections that fit.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|section_count
condition|;
name|j
operator|++
control|)
block|{
name|section
operator|=
name|sections
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
continue|continue;
name|output_section
operator|=
name|section
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CONTAINED_BY_LMA
argument_list|(
name|output_section
argument_list|,
name|segment
argument_list|,
name|map
operator|->
name|p_paddr
argument_list|)
operator|||
name|IS_COREFILE_NOTE
argument_list|(
name|segment
argument_list|,
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|count
operator|==
literal|0
condition|)
block|{
comment|/* If the first section in a segment does not start at 			 the beginning of the segment, then something is 			 wrong.  */
if|if
condition|(
name|output_section
operator|->
name|lma
operator|!=
operator|(
name|map
operator|->
name|p_paddr
operator|+
operator|(
name|map
operator|->
name|includes_filehdr
condition|?
name|iehdr
operator|->
name|e_ehsize
else|:
literal|0
operator|)
operator|+
operator|(
name|map
operator|->
name|includes_phdrs
condition|?
name|iehdr
operator|->
name|e_phnum
operator|*
name|iehdr
operator|->
name|e_phentsize
else|:
literal|0
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|prev_sec
decl_stmt|;
name|prev_sec
operator|=
name|map
operator|->
name|sections
index|[
name|map
operator|->
name|count
operator|-
literal|1
index|]
expr_stmt|;
comment|/* If the gap between the end of the previous section 			 and the start of this section is more than 			 maxpagesize then we need to start a new segment.  */
if|if
condition|(
operator|(
name|BFD_ALIGN
argument_list|(
name|prev_sec
operator|->
name|lma
operator|+
name|prev_sec
operator|->
name|_raw_size
argument_list|,
name|maxpagesize
argument_list|)
operator|<
name|BFD_ALIGN
argument_list|(
name|output_section
operator|->
name|lma
argument_list|,
name|maxpagesize
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_sec
operator|->
name|lma
operator|+
name|prev_sec
operator|->
name|_raw_size
operator|)
operator|>
name|output_section
operator|->
name|lma
operator|)
condition|)
block|{
if|if
condition|(
name|suggested_lma
operator|==
literal|0
condition|)
name|suggested_lma
operator|=
name|output_section
operator|->
name|lma
expr_stmt|;
continue|continue;
block|}
block|}
name|map
operator|->
name|sections
index|[
name|map
operator|->
name|count
operator|++
index|]
operator|=
name|output_section
expr_stmt|;
operator|++
name|isec
expr_stmt|;
name|sections
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|section
operator|->
name|segment_mark
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suggested_lma
operator|==
literal|0
condition|)
name|suggested_lma
operator|=
name|output_section
operator|->
name|lma
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|map
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the current segment to the list of built segments.  */
operator|*
name|pointer_to_map
operator|=
name|map
expr_stmt|;
name|pointer_to_map
operator|=
operator|&
name|map
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|isec
operator|<
name|section_count
condition|)
block|{
comment|/* We still have not allocated all of the sections to 		 segments.  Create a new segment here, initialise it 		 and carry on looping.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
operator|(
name|bfd_size_type
operator|)
name|section_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|map
operator|=
name|bfd_alloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Initialise the fields of the segment map.  Set the physical 		 physical address to the LMA of the first section that has 		 not yet been assigned.  */
name|map
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|p_type
operator|=
name|segment
operator|->
name|p_type
expr_stmt|;
name|map
operator|->
name|p_flags
operator|=
name|segment
operator|->
name|p_flags
expr_stmt|;
name|map
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|p_paddr
operator|=
name|suggested_lma
expr_stmt|;
name|map
operator|->
name|p_paddr_valid
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|includes_filehdr
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|includes_phdrs
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|isec
operator|<
name|section_count
condition|)
do|;
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
block|}
comment|/* The Solaris linker creates program headers in which all the      p_paddr fields are zero.  When we try to objcopy or strip such a      file, we get confused.  Check for this case, and if we find it      reset the p_paddr_valid fields.  */
for|for
control|(
name|map
operator|=
name|map_first
init|;
name|map
operator|!=
name|NULL
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
if|if
condition|(
name|map
operator|->
name|p_paddr
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
for|for
control|(
name|map
operator|=
name|map_first
init|;
name|map
operator|!=
name|NULL
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
name|map
operator|->
name|p_paddr_valid
operator|=
literal|0
expr_stmt|;
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|segment_map
operator|=
name|map_first
expr_stmt|;
comment|/* If we had to estimate the number of program headers that were      going to be needed, then check our estimate now and adjust      the offset if necessary.  */
if|if
condition|(
name|phdr_adjust_seg
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|map
operator|=
name|map_first
init|;
name|map
operator|!=
name|NULL
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|phdr_adjust_num
condition|)
name|phdr_adjust_seg
operator|->
name|p_paddr
operator|-=
operator|(
name|count
operator|-
name|phdr_adjust_num
operator|)
operator|*
name|iehdr
operator|->
name|e_phentsize
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Final Step: Sort the segments into ascending order of physical      address.  */
block|if (map_first != NULL)     {       struct elf_segment_map *prev;        prev = map_first;       for (map = map_first->next; map != NULL; prev = map, map = map->next) 	{
comment|/* Yes I know - its a bubble sort....  */
block|if (map->next != NULL&& (map->next->p_paddr< map->p_paddr)) 	    {
comment|/* Swap map and map->next.  */
block|prev->next = map->next; 	      map->next = map->next->next; 	      prev->next->next = map;
comment|/* Restart loop.  */
block|map = map_first; 	    } 	}     }
endif|#
directive|endif
undef|#
directive|undef
name|SEGMENT_END
undef|#
directive|undef
name|SECTION_SIZE
undef|#
directive|undef
name|IS_CONTAINED_BY_VMA
undef|#
directive|undef
name|IS_CONTAINED_BY_LMA
undef|#
directive|undef
name|IS_COREFILE_NOTE
undef|#
directive|undef
name|IS_SOLARIS_PT_INTERP
undef|#
directive|undef
name|INCLUDE_SECTION_IN_SEGMENT
undef|#
directive|undef
name|SEGMENT_AFTER_SEGMENT
undef|#
directive|undef
name|SEGMENT_OVERLAPS
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy private section information.  This copies over the entsize    field, and sometimes the info field.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_copy_private_section_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|ihdr
decl_stmt|,
modifier|*
name|ohdr
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|segment_map
operator|==
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Only set up the segments if there are no more SEC_ALLOC 	   sections.  FIXME: This won't do the right thing if objcopy is 	   used to remove the last SEC_ALLOC section, since objcopy 	   won't call this routine in that case.  */
for|for
control|(
name|s
operator|=
name|isec
operator|->
name|next
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|ihdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|ohdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|ohdr
operator|->
name|sh_entsize
operator|=
name|ihdr
operator|->
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_GNU_verneed
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_GNU_verdef
condition|)
name|ohdr
operator|->
name|sh_info
operator|=
name|ihdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Set things up for objcopy.  The output SHT_GROUP section will      have its elf_next_in_group pointing back to the input group      members.  */
name|elf_next_in_group
argument_list|(
name|osec
argument_list|)
operator|=
name|elf_next_in_group
argument_list|(
name|isec
argument_list|)
expr_stmt|;
name|elf_group_name
argument_list|(
name|osec
argument_list|)
operator|=
name|elf_group_name
argument_list|(
name|isec
argument_list|)
expr_stmt|;
name|osec
operator|->
name|use_rela_p
operator|=
name|isec
operator|->
name|use_rela_p
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy private symbol information.  If this symbol is in a section    which we did not map into a BFD section, try to map the section    index correctly.  We use special macro definitions for the mapped    section indices; these definitions are interpreted by the    swap_out_syms function.  */
end_comment

begin_define
define|#
directive|define
name|MAP_ONESYMTAB
value|(SHN_HIOS + 1)
end_define

begin_define
define|#
directive|define
name|MAP_DYNSYMTAB
value|(SHN_HIOS + 2)
end_define

begin_define
define|#
directive|define
name|MAP_STRTAB
value|(SHN_HIOS + 3)
end_define

begin_define
define|#
directive|define
name|MAP_SHSTRTAB
value|(SHN_HIOS + 4)
end_define

begin_define
define|#
directive|define
name|MAP_SYM_SHNDX
value|(SHN_HIOS + 5)
end_define

begin_function
name|bfd_boolean
name|_bfd_elf_copy_private_symbol_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asymbol
modifier|*
name|isymarg
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asymbol
modifier|*
name|osymarg
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|isym
decl_stmt|,
modifier|*
name|osym
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|isym
operator|=
name|elf_symbol_from
argument_list|(
name|ibfd
argument_list|,
name|isymarg
argument_list|)
expr_stmt|;
name|osym
operator|=
name|elf_symbol_from
argument_list|(
name|obfd
argument_list|,
name|osymarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|!=
name|NULL
operator|&&
name|osym
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|isym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|shndx
decl_stmt|;
name|shndx
operator|=
name|isym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
expr_stmt|;
if|if
condition|(
name|shndx
operator|==
name|elf_onesymtab
argument_list|(
name|ibfd
argument_list|)
condition|)
name|shndx
operator|=
name|MAP_ONESYMTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_dynsymtab
argument_list|(
name|ibfd
argument_list|)
condition|)
name|shndx
operator|=
name|MAP_DYNSYMTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|strtab_section
condition|)
name|shndx
operator|=
name|MAP_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|shstrtab_section
condition|)
name|shndx
operator|=
name|MAP_SHSTRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_shndx_section
condition|)
name|shndx
operator|=
name|MAP_SYM_SHNDX
expr_stmt|;
name|osym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|=
name|shndx
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Swap out the symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|swap_out_syms
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_strtab_hash
modifier|*
modifier|*
name|sttp
parameter_list|,
name|int
name|relocatable_p
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|int
name|symcount
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|stt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_shndx_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|char
modifier|*
name|outbound_syms
decl_stmt|;
name|char
modifier|*
name|outbound_shndx
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_boolean
name|name_local_sections
decl_stmt|;
if|if
condition|(
operator|!
name|elf_map_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Dump out the symtabs.  */
name|stt
operator|=
name|_bfd_elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|stt
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
name|symtab_hdr
operator|->
name|sh_entsize
operator|*
operator|(
name|symcount
operator|+
literal|1
operator|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|amt
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|+
name|symcount
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|outbound_syms
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_syms
operator|==
name|NULL
condition|)
block|{
name|_bfd_stringtab_free
argument_list|(
name|stt
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|symtab_hdr
operator|->
name|contents
operator|=
name|outbound_syms
expr_stmt|;
name|outbound_shndx
operator|=
name|NULL
expr_stmt|;
name|symtab_shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|->
name|sh_name
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|+
name|symcount
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|outbound_shndx
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_shndx
operator|==
name|NULL
condition|)
block|{
name|_bfd_stringtab_free
argument_list|(
name|stt
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|symtab_shndx_hdr
operator|->
name|contents
operator|=
name|outbound_shndx
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB_SHNDX
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_size
operator|=
name|amt
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
block|}
comment|/* Now generate the data (for "contents").  */
block|{
comment|/* Fill in zeroth symbol and swap it out.  */
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|outbound_syms
argument_list|,
name|outbound_shndx
argument_list|)
expr_stmt|;
name|outbound_syms
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|outbound_shndx
operator|!=
name|NULL
condition|)
name|outbound_shndx
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
block|}
name|name_local_sections
operator|=
operator|(
name|bed
operator|->
name|elf_backend_name_local_section_symbols
operator|&&
name|bed
operator|->
name|elf_backend_name_local_section_symbols
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|syms
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|bfd_vma
name|value
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|value
decl_stmt|;
name|elf_symbol_type
modifier|*
name|type_ptr
decl_stmt|;
name|flagword
name|flags
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|flags
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|name_local_sections
operator|&&
operator|(
name|flags
operator|&
operator|(
name|BSF_SECTION_SYM
operator||
name|BSF_GLOBAL
operator|)
operator|)
operator|==
name|BSF_SECTION_SYM
condition|)
block|{
comment|/* Local section symbols have no name.  */
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|.
name|st_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|stt
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|_bfd_stringtab_free
argument_list|(
name|stt
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|type_ptr
operator|=
name|elf_symbol_from
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* ELF common symbols put the alignment into the `value' field, 	     and the size into the `size' field.  This is backwards from 	     how BFD handles it, so reverse it here.  */
name|sym
operator|.
name|st_size
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|type_ptr
operator|==
name|NULL
operator|||
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_value
operator|==
literal|0
condition|)
name|sym
operator|.
name|st_value
operator|=
name|value
operator|>=
literal|16
condition|?
literal|16
else|:
operator|(
literal|1
operator|<<
name|bfd_log2
argument_list|(
name|value
argument_list|)
operator|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_value
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_value
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|section
decl_stmt|;
name|int
name|shndx
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
block|{
name|value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
block|}
comment|/* Don't add in the section vma for relocatable output.  */
if|if
condition|(
operator|!
name|relocatable_p
condition|)
name|value
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|value
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|type_ptr
condition|?
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_size
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
name|type_ptr
operator|!=
name|NULL
operator|&&
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol is in a real ELF section which we did 		 not create as a BFD section.  Undo the mapping done 		 by copy_private_symbol_data.  */
name|shndx
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
expr_stmt|;
switch|switch
condition|(
name|shndx
condition|)
block|{
case|case
name|MAP_ONESYMTAB
case|:
name|shndx
operator|=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_DYNSYMTAB
case|:
name|shndx
operator|=
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_STRTAB
case|:
name|shndx
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_section
expr_stmt|;
break|break;
case|case
name|MAP_SHSTRTAB
case|:
name|shndx
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_section
expr_stmt|;
break|break;
case|case
name|MAP_SYM_SHNDX
case|:
name|shndx
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
operator|==
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sec2
decl_stmt|;
comment|/* Writing this would be a hell of a lot easier if 		     we had some decent documentation on bfd, and 		     knew what to expect of the library, and what to 		     demand of applications.  For example, it 		     appears that `objcopy' might not set the 		     section of a symbol to be a section that is 		     actually in the output file.  */
name|sec2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec2
operator|==
name|NULL
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ Unable to find equivalent output section for symbol '%s' from section '%s'"
argument_list|)
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|name
condition|?
name|syms
index|[
name|idx
index|]
operator|->
name|name
else|:
literal|"<Local sym>"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|_bfd_stringtab_free
argument_list|(
name|stt
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|shndx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sym
operator|.
name|st_shndx
operator|=
name|shndx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|STT_TLS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|STT_FUNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_OBJECT
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
else|else
name|type
operator|=
name|STT_NOTYPE
expr_stmt|;
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
condition|)
name|type
operator|=
name|STT_TLS
expr_stmt|;
comment|/* Processor-specific types.  */
if|if
condition|(
name|type_ptr
operator|!=
name|NULL
operator|&&
name|bed
operator|->
name|elf_backend_get_symbol_type
condition|)
name|type
operator|=
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_get_symbol_type
call|)
argument_list|(
operator|&
name|type_ptr
operator|->
name|internal_elf_sym
argument_list|,
name|type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
operator|(
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
condition|?
name|STB_WEAK
else|:
name|STB_GLOBAL
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_FILE
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FILE
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|bind
init|=
name|STB_LOCAL
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|bind
operator|=
name|STB_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_WEAK
condition|)
name|bind
operator|=
name|STB_WEAK
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|bind
operator|=
name|STB_GLOBAL
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_ptr
operator|!=
name|NULL
condition|)
name|sym
operator|.
name|st_other
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_other
expr_stmt|;
else|else
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|outbound_syms
argument_list|,
name|outbound_shndx
argument_list|)
expr_stmt|;
name|outbound_syms
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|outbound_shndx
operator|!=
name|NULL
condition|)
name|outbound_shndx
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
block|}
operator|*
name|sttp
operator|=
name|stt
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|stt
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to hold the symtab vector.     Note that we base it on the count plus 1, since we will null terminate    the vector allocated based on this size.  However, the ELF symbol table    always has a dummy entry as symbol #0, so it ends up even.  */
end_comment

begin_function
name|long
name|_bfd_elf_get_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|>
literal|0
condition|)
name|symtab_size
operator|-=
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_get_dynamic_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|>
literal|0
condition|)
name|symtab_size
operator|-=
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|sec_ptr
name|asect
parameter_list|)
block|{
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the relocs.  */
end_comment

begin_function
name|long
name|_bfd_elf_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bed
operator|->
name|s
operator|->
name|slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_canonicalize_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|allocation
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|long
name|symcount
init|=
name|bed
operator|->
name|s
operator|->
name|slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|allocation
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|symcount
operator|>=
literal|0
condition|)
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_canonicalize_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|allocation
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|long
name|symcount
init|=
name|bed
operator|->
name|s
operator|->
name|slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|allocation
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|symcount
operator|>=
literal|0
condition|)
name|bfd_get_dynamic_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the dynamic reloc entries.  Any    section that was actually installed in the BFD, and has type    SHT_REL or SHT_RELA, and uses the dynamic symbol table, is    considered to be a dynamic reloc section.  */
end_comment

begin_function
name|long
name|_bfd_elf_get_dynamic_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
name|ret
operator|+=
operator|(
operator|(
name|s
operator|->
name|_raw_size
operator|/
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the dynamic relocation entries.  Note that we return    the dynamic relocations as a single block, although they are    actually associated with particular sections; the interface, which    was designed for SunOS style shared libraries, expects that there    is only one set of dynamic relocs.  Any section that was actually    installed in the BFD, and has type SHT_REL or SHT_RELA, and uses    the dynamic symbol table, is considered to be a dynamic reloc    section.  */
end_comment

begin_function
name|long
name|_bfd_elf_canonicalize_dynamic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
modifier|*
name|storage
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|)
block|{
name|bfd_boolean
function_decl|(
modifier|*
name|slurp_relocs
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|ret
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|slurp_relocs
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_reloc_table
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
block|{
name|arelent
modifier|*
name|p
decl_stmt|;
name|long
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|slurp_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|syms
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
name|p
operator|++
expr_stmt|;
name|ret
operator|+=
name|count
expr_stmt|;
block|}
block|}
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the version information.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_slurp_version_tables
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|everdef
decl_stmt|;
name|Elf_Internal_Verdef
modifier|*
name|iverdef
decl_stmt|;
name|Elf_Internal_Verdef
modifier|*
name|iverdefarr
decl_stmt|;
name|Elf_Internal_Verdef
name|iverdefmem
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|maxidx
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|contents
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
comment|/* We know the number of entries in the section but not the maximum 	 index.  Therefore we have to run through all entries and find 	 the maximum.  */
name|everdef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|contents
expr_stmt|;
name|maxidx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|sh_info
condition|;
operator|++
name|i
control|)
block|{
name|_bfd_elf_swap_verdef_in
argument_list|(
name|abfd
argument_list|,
name|everdef
argument_list|,
operator|&
name|iverdefmem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iverdefmem
operator|.
name|vd_ndx
operator|&
operator|(
operator|(
name|unsigned
operator|)
name|VERSYM_VERSION
operator|)
operator|)
operator|>
name|maxidx
condition|)
name|maxidx
operator|=
name|iverdefmem
operator|.
name|vd_ndx
operator|&
operator|(
operator|(
name|unsigned
operator|)
name|VERSYM_VERSION
operator|)
expr_stmt|;
name|everdef
operator|=
operator|(
operator|(
name|Elf_External_Verdef
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdef
operator|+
name|iverdefmem
operator|.
name|vd_next
operator|)
operator|)
expr_stmt|;
block|}
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|maxidx
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verdef
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
operator|=
name|maxidx
expr_stmt|;
name|everdef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|contents
expr_stmt|;
name|iverdefarr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
block|{
name|Elf_External_Verdaux
modifier|*
name|everdaux
decl_stmt|;
name|Elf_Internal_Verdaux
modifier|*
name|iverdaux
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|_bfd_elf_swap_verdef_in
argument_list|(
name|abfd
argument_list|,
name|everdef
argument_list|,
operator|&
name|iverdefmem
argument_list|)
expr_stmt|;
name|iverdef
operator|=
operator|&
name|iverdefarr
index|[
operator|(
name|iverdefmem
operator|.
name|vd_ndx
operator|&
name|VERSYM_VERSION
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|iverdef
argument_list|,
operator|&
name|iverdefmem
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verdef
argument_list|)
argument_list|)
expr_stmt|;
name|iverdef
operator|->
name|vd_bfd
operator|=
name|abfd
expr_stmt|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|iverdef
operator|->
name|vd_cnt
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verdaux
argument_list|)
expr_stmt|;
name|iverdef
operator|->
name|vd_auxptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|iverdef
operator|->
name|vd_auxptr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|everdaux
operator|=
operator|(
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdef
operator|+
name|iverdef
operator|->
name|vd_aux
operator|)
operator|)
expr_stmt|;
name|iverdaux
operator|=
name|iverdef
operator|->
name|vd_auxptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iverdef
operator|->
name|vd_cnt
condition|;
name|j
operator|++
operator|,
name|iverdaux
operator|++
control|)
block|{
name|_bfd_elf_swap_verdaux_in
argument_list|(
name|abfd
argument_list|,
name|everdaux
argument_list|,
name|iverdaux
argument_list|)
expr_stmt|;
name|iverdaux
operator|->
name|vda_nodename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|iverdaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iverdaux
operator|->
name|vda_nodename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|iverdef
operator|->
name|vd_cnt
condition|)
name|iverdaux
operator|->
name|vda_nextptr
operator|=
name|iverdaux
operator|+
literal|1
expr_stmt|;
else|else
name|iverdaux
operator|->
name|vda_nextptr
operator|=
name|NULL
expr_stmt|;
name|everdaux
operator|=
operator|(
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdaux
operator|+
name|iverdaux
operator|->
name|vda_next
operator|)
operator|)
expr_stmt|;
block|}
name|iverdef
operator|->
name|vd_nodename
operator|=
name|iverdef
operator|->
name|vd_auxptr
operator|->
name|vda_nodename
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|hdr
operator|->
name|sh_info
condition|)
name|iverdef
operator|->
name|vd_nextdef
operator|=
name|iverdef
operator|+
literal|1
expr_stmt|;
else|else
name|iverdef
operator|->
name|vd_nextdef
operator|=
name|NULL
expr_stmt|;
name|everdef
operator|=
operator|(
operator|(
name|Elf_External_Verdef
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdef
operator|+
name|iverdef
operator|->
name|vd_next
operator|)
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_External_Verneed
modifier|*
name|everneed
decl_stmt|;
name|Elf_Internal_Verneed
modifier|*
name|iverneed
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_hdr
expr_stmt|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verneed
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|contents
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
name|everneed
operator|=
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|contents
expr_stmt|;
name|iverneed
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
operator|,
name|iverneed
operator|++
control|)
block|{
name|Elf_External_Vernaux
modifier|*
name|evernaux
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|ivernaux
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|_bfd_elf_swap_verneed_in
argument_list|(
name|abfd
argument_list|,
name|everneed
argument_list|,
name|iverneed
argument_list|)
expr_stmt|;
name|iverneed
operator|->
name|vn_bfd
operator|=
name|abfd
expr_stmt|;
name|iverneed
operator|->
name|vn_filename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|iverneed
operator|->
name|vn_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|iverneed
operator|->
name|vn_filename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|iverneed
operator|->
name|vn_cnt
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Vernaux
argument_list|)
expr_stmt|;
name|iverneed
operator|->
name|vn_auxptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|evernaux
operator|=
operator|(
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everneed
operator|+
name|iverneed
operator|->
name|vn_aux
operator|)
operator|)
expr_stmt|;
name|ivernaux
operator|=
name|iverneed
operator|->
name|vn_auxptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iverneed
operator|->
name|vn_cnt
condition|;
name|j
operator|++
operator|,
name|ivernaux
operator|++
control|)
block|{
name|_bfd_elf_swap_vernaux_in
argument_list|(
name|abfd
argument_list|,
name|evernaux
argument_list|,
name|ivernaux
argument_list|)
expr_stmt|;
name|ivernaux
operator|->
name|vna_nodename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|ivernaux
operator|->
name|vna_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivernaux
operator|->
name|vna_nodename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|iverneed
operator|->
name|vn_cnt
condition|)
name|ivernaux
operator|->
name|vna_nextptr
operator|=
name|ivernaux
operator|+
literal|1
expr_stmt|;
else|else
name|ivernaux
operator|->
name|vna_nextptr
operator|=
name|NULL
expr_stmt|;
name|evernaux
operator|=
operator|(
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|evernaux
operator|+
name|ivernaux
operator|->
name|vna_next
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|hdr
operator|->
name|sh_info
condition|)
name|iverneed
operator|->
name|vn_nextref
operator|=
name|iverneed
operator|+
literal|1
expr_stmt|;
else|else
name|iverneed
operator|->
name|vn_nextref
operator|=
name|NULL
expr_stmt|;
name|everneed
operator|=
operator|(
operator|(
name|Elf_External_Verneed
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everneed
operator|+
name|iverneed
operator|->
name|vn_next
operator|)
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|asymbol
modifier|*
name|_bfd_elf_make_empty_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|newsym
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
decl_stmt|;
name|newsym
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsym
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|newsym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|newsym
operator|->
name|symbol
return|;
block|}
block|}
end_function

begin_function
name|void
name|_bfd_elf_get_symbol_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|symbol_info
modifier|*
name|ret
parameter_list|)
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol name implies a local symbol.  Most targets    use this function for the is_local_label_name entry point, but some    override it.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Normal local symbols start with ``.L''.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
return|return
name|TRUE
return|;
comment|/* At least some SVR4 compilers (e.g., UnixWare 2.1 cc) generate      DWARF debugging symbols starting with ``..''.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|TRUE
return|;
comment|/* gcc will sometimes generate symbols beginning with ``_.L_'' when      emitting DWARF debugging output.  I suspect this is actually a      small bug in gcc (it calls ASM_OUTPUT_LABEL when it should call      ASM_GENERATE_INTERNAL_LABEL, and this causes the leading      underscore to be emitted on some ELF targets).  For ease of use,      we treat such symbols as local.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'_'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|alent
modifier|*
name|_bfd_elf_get_lineno
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_set_arch_mach
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|machine
parameter_list|)
block|{
comment|/* If this isn't the right architecture for this backend, and this      isn't the generic backend, fail.  */
if|if
condition|(
name|arch
operator|!=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|&&
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
return|return
name|FALSE
return|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the function to a particular section and offset,    for error reporting.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_find_function
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|asymbol
modifier|*
name|func
decl_stmt|;
name|bfd_vma
name|low_func
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
name|low_func
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|q
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|STT_FILE
case|:
name|filename
operator|=
name|bfd_asymbol_name
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_NOTYPE
case|:
case|case
name|STT_FUNC
case|:
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|section
operator|==
name|section
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
name|low_func
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|filename_ptr
condition|)
operator|*
name|filename_ptr
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|functionname_ptr
condition|)
operator|*
name|functionname_ptr
operator|=
name|bfd_asymbol_name
argument_list|(
name|func
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest line to a particular section and offset,    for error reporting.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|bfd_boolean
name|found
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf1_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|functionname_ptr
condition|)
name|elf_find_function
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
operator|*
name|filename_ptr
condition|?
name|NULL
else|:
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|functionname_ptr
condition|)
name|elf_find_function
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
operator|*
name|filename_ptr
condition|?
name|NULL
else|:
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_stab_section_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|found
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|line_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|found
operator|&&
operator|(
operator|*
name|functionname_ptr
operator|||
operator|*
name|line_ptr
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_find_function
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|_bfd_elf_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|reloc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
name|ret
operator|+=
name|get_program_header_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_signed_vma
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_no_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to convert a non-ELF reloc into an ELF one.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_validate_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|areloc
parameter_list|)
block|{
comment|/* Check whether we really have an ELF howto.  */
if|if
condition|(
operator|(
operator|*
name|areloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* Alien reloc: Try to determine its type to replace it with an 	 equivalent ELF reloc.  */
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|code
operator|=
name|BFD_RELOC_12_PCREL
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|code
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pcrel_offset
operator|!=
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
condition|)
name|areloc
operator|->
name|addend
operator|+=
name|areloc
operator|->
name|address
expr_stmt|;
else|else
name|areloc
operator|->
name|addend
operator|-=
name|areloc
operator|->
name|address
expr_stmt|;
comment|/* addend is unsigned!! */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|code
operator|=
name|BFD_RELOC_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|code
operator|=
name|BFD_RELOC_26
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|howto
condition|)
name|areloc
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
return|return
name|TRUE
return|;
name|fail
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unsupported relocation type %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|areloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_close_and_cleanup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
block|{
if|if
condition|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
name|_bfd_elf_strtab_free
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_generic_close_and_cleanup
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For Rel targets, we encode meaningful data for BFD_RELOC_VTABLE_ENTRY    in the relocation's offset.  Thus we cannot allow any sort of sanity    range-checking to interfere.  There is nothing else to do in processing    this reloc.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_elf_rel_vtable_reloc_fn
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|re
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_symbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|is
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Elf core file support.  Much of this only works on native    toolchains, since we rely on knowing the    machine-dependent procfs structure in order to pick    out details about the corefile.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXME: this is kinda wrong, but it's what gdb wants.  */
end_comment

begin_function
specifier|static
name|int
name|elfcore_make_pid
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
operator|(
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|<<
literal|16
operator|)
operator|+
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If there isn't a section called NAME, make one, using    data from SECT.  Note, this function will generate a    reference to NAME, so you shouldn't deallocate or    overwrite it.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfcore_maybe_make_sect
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|)
block|{
name|asection
modifier|*
name|sect2
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
name|sect2
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect2
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect2
operator|->
name|_raw_size
operator|=
name|sect
operator|->
name|_raw_size
expr_stmt|;
name|sect2
operator|->
name|filepos
operator|=
name|sect
operator|->
name|filepos
expr_stmt|;
name|sect2
operator|->
name|flags
operator|=
name|sect
operator|->
name|flags
expr_stmt|;
name|sect2
operator|->
name|alignment_power
operator|=
name|sect
operator|->
name|alignment_power
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a pseudosection containing SIZE bytes at FILEPOS.  This    actually creates up to two pseudosections:    - For the single-threaded case, a section named NAME, unless      such a section already exists.    - For the multi-threaded case, a section named "NAME/PID", where      PID is elfcore_make_pid (abfd).    Both pseudosections have identical contents. */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elfcore_make_pseudosection
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ufile_ptr
name|filepos
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|threaded_name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
comment|/* Build the section name.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%d"
argument_list|,
name|name
argument_list|,
name|elfcore_make_pid
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|threaded_name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|threaded_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|threaded_name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|threaded_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|,
name|sect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* prstatus_t exists on:      solaris 2.5+      linux 2.[01] + glibc      unixware 4.2 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS_T
argument_list|)
end_if

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|size_t
name|raw_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
condition|)
block|{
name|prstatus_t
name|prstat
decl_stmt|;
name|raw_size
operator|=
sizeof|sizeof
argument_list|(
name|prstat
operator|.
name|pr_reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offsetof
argument_list|(
name|prstatus_t
argument_list|,
name|pr_reg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|prstat
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|prstat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not overwrite the core signal if it 	 has already been set by another thread.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|==
literal|0
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|prstat
operator|.
name|pr_cursig
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|prstat
operator|.
name|pr_pid
expr_stmt|;
comment|/* pr_who exists on: 	 solaris 2.5+ 	 unixware 4.2 	 pr_who doesn't exist on: 	 linux 2.[01] 	 */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS_T_PR_WHO
argument_list|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
name|prstat
operator|.
name|pr_who
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS32_T
argument_list|)
elseif|else
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prstatus32_t
argument_list|)
condition|)
block|{
comment|/* 64-bit host, 32-bit corefile */
name|prstatus32_t
name|prstat
decl_stmt|;
name|raw_size
operator|=
sizeof|sizeof
argument_list|(
name|prstat
operator|.
name|pr_reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offsetof
argument_list|(
name|prstatus32_t
argument_list|,
name|pr_reg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|prstat
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|prstat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not overwrite the core signal if it 	 has already been set by another thread.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|==
literal|0
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|prstat
operator|.
name|pr_cursig
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|prstat
operator|.
name|pr_pid
expr_stmt|;
comment|/* pr_who exists on: 	 solaris 2.5+ 	 unixware 4.2 	 pr_who doesn't exist on: 	 linux 2.[01] 	 */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS32_T_PR_WHO
argument_list|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
name|prstat
operator|.
name|pr_who
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* HAVE_PRSTATUS32_T */
else|else
block|{
comment|/* Fail - we don't know how to handle any other 	 note size (ie. data object type).  */
return|return
name|TRUE
return|;
block|}
comment|/* Make a ".reg/999" section and a ".reg" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_PRSTATUS_T) */
end_comment

begin_comment
comment|/* Create a pseudosection containing the exact contents of NOTE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfcore_make_note_pseudosection
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|,
name|note
operator|->
name|descsz
argument_list|,
name|note
operator|->
name|descpos
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* There isn't a consistent prfpregset_t across platforms,    but it doesn't matter, because we don't have to pick this    data structure apart.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_prfpreg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|,
name|note
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linux dumps the Intel SSE regs in a note named "LINUX" with a note    type of 5 (NT_PRXFPREG).  Just include the whole note's contents    literally.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_prxfpreg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg-xfp"
argument_list|,
name|note
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO_T
argument_list|)
end_if

begin_typedef
typedef|typedef
name|prpsinfo_t
name|elfcore_psinfo_t
typedef|;
end_typedef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO32_T
argument_list|)
end_if

begin_comment
comment|/* Sparc64 cross Sparc32 */
end_comment

begin_typedef
typedef|typedef
name|prpsinfo32_t
name|elfcore_psinfo32_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSINFO_T
argument_list|)
end_if

begin_typedef
typedef|typedef
name|psinfo_t
name|elfcore_psinfo_t
typedef|;
end_typedef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSINFO32_T
argument_list|)
end_if

begin_comment
comment|/* Sparc64 cross Sparc32 */
end_comment

begin_typedef
typedef|typedef
name|psinfo32_t
name|elfcore_psinfo32_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* return a malloc'ed copy of a string at START which is at    most MAX bytes long, possibly without a terminating '\0'.    the copy will always have a terminating '\0'.  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_elfcore_strndup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
name|char
modifier|*
name|dups
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|memchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|,
name|max
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
name|len
operator|=
name|max
expr_stmt|;
else|else
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|dups
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dups
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|dups
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dups
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dups
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO_T
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PSINFO_T
argument_list|)
end_if

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|elfcore_psinfo_t
argument_list|)
condition|)
block|{
name|elfcore_psinfo_t
name|psinfo
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|psinfo
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|psinfo
operator|.
name|pr_fname
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|.
name|pr_fname
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|psinfo
operator|.
name|pr_psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|.
name|pr_psargs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO32_T
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PSINFO32_T
argument_list|)
elseif|else
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|elfcore_psinfo32_t
argument_list|)
condition|)
block|{
comment|/* 64-bit host, 32-bit corefile */
name|elfcore_psinfo32_t
name|psinfo
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|psinfo
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|psinfo
operator|.
name|pr_fname
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|.
name|pr_fname
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|psinfo
operator|.
name|pr_psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|.
name|pr_psargs
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* Fail - we don't know how to handle any other 	 note size (ie. data object type).  */
return|return
name|TRUE
return|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSTATUS_T
argument_list|)
end_if

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_pstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|pstatus_t
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PXSTATUS_T
argument_list|)
operator|||
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|pxstatus_t
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|pstatus_t
name|pstat
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|pstat
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|pstat
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|pstat
operator|.
name|pr_pid
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSTATUS32_T
argument_list|)
elseif|else
if|if
condition|(
name|note
operator|->
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|pstatus32_t
argument_list|)
condition|)
block|{
comment|/* 64-bit host, 32-bit corefile */
name|pstatus32_t
name|pstat
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|pstat
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|pstat
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|pstat
operator|.
name|pr_pid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Could grab some more details from the "representative"      lwpstatus_t in pstat.pr_lwp, but we'll catch it all in an      NT_LWPSTATUS note, presumably.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_PSTATUS_T) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T
argument_list|)
end_if

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_lwpstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|lwpstatus_t
name|lwpstat
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|descsz
operator|!=
sizeof|sizeof
argument_list|(
name|lwpstat
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPXSTATUS_T
argument_list|)
operator|&&
name|note
operator|->
name|descsz
operator|!=
sizeof|sizeof
argument_list|(
name|lwpxstatus_t
argument_list|)
endif|#
directive|endif
condition|)
return|return
name|TRUE
return|;
name|memcpy
argument_list|(
operator|&
name|lwpstat
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
argument_list|)
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
name|lwpstat
operator|.
name|pr_lwpid
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|lwpstat
operator|.
name|pr_cursig
expr_stmt|;
comment|/* Make a ".reg/999" section.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".reg/%d"
argument_list|,
name|elfcore_make_pid
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_CONTEXT
argument_list|)
name|sect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
operator|+
name|offsetof
argument_list|(
name|lwpstatus_t
argument_list|,
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_REG
argument_list|)
name|sect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_reg
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
operator|+
name|offsetof
argument_list|(
name|lwpstatus_t
argument_list|,
name|pr_reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|sect
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make a ".reg2/999" section */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".reg2/%d"
argument_list|,
name|elfcore_make_pid
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_CONTEXT
argument_list|)
name|sect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|fpregs
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
operator|+
name|offsetof
argument_list|(
name|lwpstatus_t
argument_list|,
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|fpregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_FPREG
argument_list|)
name|sect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_fpreg
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
operator|+
name|offsetof
argument_list|(
name|lwpstatus_t
argument_list|,
name|pr_fpreg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|,
name|sect
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_LWPSTATUS_T) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WIN32_PSTATUS_T
argument_list|)
end_if

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_win32pstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|win32_pstatus_t
name|pstatus
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|descsz
operator|<
sizeof|sizeof
argument_list|(
name|pstatus
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|memcpy
argument_list|(
operator|&
name|pstatus
argument_list|,
name|note
operator|->
name|descdata
argument_list|,
sizeof|sizeof
argument_list|(
name|pstatus
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pstatus
operator|.
name|data_type
condition|)
block|{
case|case
name|NOTE_INFO_PROCESS
case|:
comment|/* FIXME: need to add ->core_command.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|pstatus
operator|.
name|data
operator|.
name|process_info
operator|.
name|signal
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|pstatus
operator|.
name|data
operator|.
name|process_info
operator|.
name|pid
expr_stmt|;
break|break;
case|case
name|NOTE_INFO_THREAD
case|:
comment|/* Make a ".reg/999" section.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".reg/%d"
argument_list|,
name|pstatus
operator|.
name|data
operator|.
name|thread_info
operator|.
name|tid
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|pstatus
operator|.
name|data
operator|.
name|thread_info
operator|.
name|thread_context
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
operator|(
name|note
operator|->
name|descpos
operator|+
name|offsetof
argument_list|(
expr|struct
name|win32_pstatus
argument_list|,
name|data
operator|.
name|thread_info
operator|.
name|thread_context
argument_list|)
operator|)
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pstatus
operator|.
name|data
operator|.
name|thread_info
operator|.
name|is_active_thread
condition|)
if|if
condition|(
operator|!
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|sect
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|NOTE_INFO_MODULE
case|:
comment|/* Make a ".module/xxxxxxxx" section.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".module/%08x"
argument_list|,
name|pstatus
operator|.
name|data
operator|.
name|module_info
operator|.
name|base_address
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
name|note
operator|->
name|descsz
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_WIN32_PSTATUS_T */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|type
condition|)
block|{
default|default:
return|return
name|TRUE
return|;
case|case
name|NT_PRSTATUS
case|:
if|if
condition|(
name|bed
operator|->
name|elf_backend_grok_prstatus
condition|)
if|if
condition|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_grok_prstatus
call|)
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS_T
argument_list|)
return|return
name|elfcore_grok_prstatus
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSTATUS_T
argument_list|)
case|case
name|NT_PSTATUS
case|:
return|return
name|elfcore_grok_pstatus
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T
argument_list|)
case|case
name|NT_LWPSTATUS
case|:
return|return
name|elfcore_grok_lwpstatus
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
endif|#
directive|endif
case|case
name|NT_FPREGSET
case|:
comment|/* FIXME: rename to NT_PRFPREG */
return|return
name|elfcore_grok_prfpreg
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WIN32_PSTATUS_T
argument_list|)
case|case
name|NT_WIN32PSTATUS
case|:
return|return
name|elfcore_grok_win32pstatus
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
endif|#
directive|endif
case|case
name|NT_PRXFPREG
case|:
comment|/* Linux SSE extension */
if|if
condition|(
name|note
operator|->
name|namesz
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|note
operator|->
name|namedata
argument_list|,
literal|"LINUX"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|elfcore_grok_prxfpreg
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
else|else
return|return
name|TRUE
return|;
case|case
name|NT_PRPSINFO
case|:
case|case
name|NT_PSINFO
case|:
if|if
condition|(
name|bed
operator|->
name|elf_backend_grok_psinfo
condition|)
if|if
condition|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_grok_psinfo
call|)
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO_T
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PSINFO_T
argument_list|)
return|return
name|elfcore_grok_psinfo
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
case|case
name|NT_AUXV
case|:
block|{
name|asection
modifier|*
name|sect
init|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".auxv"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
name|note
operator|->
name|descsz
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|1
operator|+
name|bfd_get_arch_size
argument_list|(
name|abfd
argument_list|)
operator|/
literal|32
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_netbsd_get_lwpid
parameter_list|(
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|,
name|int
modifier|*
name|lwpidp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|note
operator|->
name|namedata
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|lwpidp
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_netbsd_procinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
comment|/* Signal number at offset 0x08. */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|note
operator|->
name|descdata
operator|+
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Process ID at offset 0x50. */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|note
operator|->
name|descdata
operator|+
literal|0x50
argument_list|)
expr_stmt|;
comment|/* Command name at 0x7c (max 32 bytes, including nul). */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|0x7c
argument_list|,
literal|31
argument_list|)
expr_stmt|;
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".note.netbsdcore.procinfo"
argument_list|,
name|note
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_netbsd_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|lwp
decl_stmt|;
if|if
condition|(
name|elfcore_netbsd_get_lwpid
argument_list|(
name|note
argument_list|,
operator|&
name|lwp
argument_list|)
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
name|lwp
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|type
operator|==
name|NT_NETBSDCORE_PROCINFO
condition|)
block|{
comment|/* NetBSD-specific core "procinfo".  Note that we expect to          find this note before any of the others, which is fine,          since the kernel writes this note out first when it          creates a core file.  */
return|return
name|elfcore_grok_netbsd_procinfo
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
block|}
comment|/* As of Jan 2002 there are no other machine-independent notes      defined for NetBSD core files.  If the note type is less      than the start of the machine-dependent note types, we don't      understand it.  */
if|if
condition|(
name|note
operator|->
name|type
operator|<
name|NT_NETBSDCORE_FIRSTMACH
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0 and        PT_GETFPREGS == mach+2.  */
case|case
name|bfd_arch_alpha
case|:
case|case
name|bfd_arch_sparc
case|:
switch|switch
condition|(
name|note
operator|->
name|type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|0
case|:
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|note
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|2
case|:
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|,
name|note
argument_list|)
return|;
default|default:
return|return
name|TRUE
return|;
block|}
comment|/* On all other arch's, PT_GETREGS == mach+1 and        PT_GETFPREGS == mach+3.  */
default|default:
switch|switch
condition|(
name|note
operator|->
name|type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|1
case|:
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|note
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|3
case|:
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|,
name|note
argument_list|)
return|;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_nto_status
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|,
name|pid_t
modifier|*
name|tid
parameter_list|)
block|{
name|void
modifier|*
name|ddata
init|=
name|note
operator|->
name|descdata
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|short
name|sig
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
comment|/* nto_procfs_status 'pid' field is at offset 0.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ddata
argument_list|)
expr_stmt|;
comment|/* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
operator|*
name|tid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ddata
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* nto_procfs_status 'flags' field is at offset 8.  */
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ddata
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* nto_procfs_status 'what' field is at offset 14.  */
if|if
condition|(
operator|(
name|sig
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ddata
operator|+
literal|14
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|sig
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
operator|*
name|tid
expr_stmt|;
block|}
comment|/* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores      do not come from signals so we make sure we set the current      thread just in case.  */
if|if
condition|(
name|flags
operator|&
literal|0x00000080
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|=
operator|*
name|tid
expr_stmt|;
comment|/* Make a ".qnx_core_status/%d" section.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".qnx_core_status/%d"
argument_list|,
operator|*
name|tid
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
name|note
operator|->
name|descsz
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
literal|".qnx_core_status"
argument_list|,
name|sect
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_nto_gregs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|,
name|pid_t
name|tid
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
comment|/* Make a ".reg/%d" section.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".reg/%d"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|_raw_size
operator|=
name|note
operator|->
name|descsz
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|note
operator|->
name|descpos
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
comment|/* This is the current thread.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_lwpid
operator|==
name|tid
condition|)
return|return
name|elfcore_maybe_make_sect
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|sect
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BFD_QNT_CORE_INFO
value|7
end_define

begin_define
define|#
directive|define
name|BFD_QNT_CORE_STATUS
value|8
end_define

begin_define
define|#
directive|define
name|BFD_QNT_CORE_GREG
value|9
end_define

begin_define
define|#
directive|define
name|BFD_QNT_CORE_FPREG
value|10
end_define

begin_function
specifier|static
name|bfd_boolean
name|elfcore_grok_nto_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
comment|/* Every GREG section has a STATUS section before it.  Store the      tid from the previous call to pass down to the next gregs      function.  */
specifier|static
name|pid_t
name|tid
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|type
condition|)
block|{
case|case
name|BFD_QNT_CORE_INFO
case|:
return|return
name|elfcore_make_note_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".qnx_core_info"
argument_list|,
name|note
argument_list|)
return|;
case|case
name|BFD_QNT_CORE_STATUS
case|:
return|return
name|elfcore_grok_nto_status
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|,
operator|&
name|tid
argument_list|)
return|;
case|case
name|BFD_QNT_CORE_GREG
case|:
return|return
name|elfcore_grok_nto_gregs
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|,
name|tid
argument_list|)
return|;
case|case
name|BFD_QNT_CORE_FPREG
case|:
return|return
name|elfcore_grok_prfpreg
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
return|;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function: elfcore_write_note     Inputs:      buffer to hold note      name of note      type of note      data for note      size of data for note     Return:    End of buffer containing note.  */
end_comment

begin_function
name|char
modifier|*
name|elfcore_write_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Elf_External_Note
modifier|*
name|xnp
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
name|size_t
name|pad
decl_stmt|;
name|size_t
name|newspace
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|namesz
operator|=
literal|0
expr_stmt|;
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pad
operator|=
operator|-
name|namesz
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|newspace
operator|=
literal|12
operator|+
name|namesz
operator|+
name|pad
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
operator|*
name|bufsiz
operator|+
name|newspace
argument_list|)
expr_stmt|;
name|dest
operator|=
name|p
operator|+
operator|*
name|bufsiz
expr_stmt|;
operator|*
name|bufsiz
operator|+=
name|newspace
expr_stmt|;
name|xnp
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
name|dest
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|namesz
argument_list|,
name|xnp
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|xnp
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|xnp
operator|->
name|type
argument_list|)
expr_stmt|;
name|dest
operator|=
name|xnp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|name
argument_list|,
name|namesz
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|namesz
expr_stmt|;
while|while
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|pad
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|dest
argument_list|,
name|input
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRPSINFO_T
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PSINFO_T
argument_list|)
end_if

begin_function
name|char
modifier|*
name|elfcore_write_prpsinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|psargs
parameter_list|)
block|{
name|int
name|note_type
decl_stmt|;
name|char
modifier|*
name|note_name
init|=
literal|"CORE"
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSINFO_T
argument_list|)
name|psinfo_t
name|data
decl_stmt|;
name|note_type
operator|=
name|NT_PSINFO
expr_stmt|;
else|#
directive|else
name|prpsinfo_t
name|data
decl_stmt|;
name|note_type
operator|=
name|NT_PRPSINFO
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|.
name|pr_fname
argument_list|,
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|.
name|pr_fname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|.
name|pr_psargs
argument_list|,
name|psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|.
name|pr_psargs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|note_type
argument_list|,
operator|&
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSINFO_T or PRPSINFO_T */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PRSTATUS_T
argument_list|)
end_if

begin_function
name|char
modifier|*
name|elfcore_write_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
name|cursig
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|prstatus_t
name|prstat
decl_stmt|;
name|char
modifier|*
name|note_name
init|=
literal|"CORE"
decl_stmt|;
name|memset
argument_list|(
operator|&
name|prstat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prstat
argument_list|)
argument_list|)
expr_stmt|;
name|prstat
operator|.
name|pr_pid
operator|=
name|pid
expr_stmt|;
name|prstat
operator|.
name|pr_cursig
operator|=
name|cursig
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|prstat
operator|.
name|pr_reg
argument_list|,
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|prstat
operator|.
name|pr_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|NT_PRSTATUS
argument_list|,
operator|&
name|prstat
argument_list|,
sizeof|sizeof
argument_list|(
name|prstat
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PRSTATUS_T */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T
argument_list|)
end_if

begin_function
name|char
modifier|*
name|elfcore_write_lwpstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
name|cursig
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|lwpstatus_t
name|lwpstat
decl_stmt|;
name|char
modifier|*
name|note_name
init|=
literal|"CORE"
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lwpstat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
argument_list|)
argument_list|)
expr_stmt|;
name|lwpstat
operator|.
name|pr_lwpid
operator|=
name|pid
operator|>>
literal|16
expr_stmt|;
name|lwpstat
operator|.
name|pr_cursig
operator|=
name|cursig
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_REG
argument_list|)
name|memcpy
argument_list|(
name|lwpstat
operator|.
name|pr_reg
argument_list|,
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_reg
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_LWPSTATUS_T_PR_CONTEXT
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|gregs
argument_list|)
name|memcpy
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|,
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|__gregs
argument_list|,
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|__gregs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|NT_LWPSTATUS
argument_list|,
operator|&
name|lwpstat
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstat
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LWPSTATUS_T */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PSTATUS_T
argument_list|)
end_if

begin_function
name|char
modifier|*
name|elfcore_write_pstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
name|cursig
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|pstatus_t
name|pstat
decl_stmt|;
name|char
modifier|*
name|note_name
init|=
literal|"CORE"
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pstat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pstat
argument_list|)
argument_list|)
expr_stmt|;
name|pstat
operator|.
name|pr_pid
operator|=
name|pid
operator|&
literal|0xffff
expr_stmt|;
name|buf
operator|=
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|NT_PSTATUS
argument_list|,
operator|&
name|pstat
argument_list|,
sizeof|sizeof
argument_list|(
name|pstat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PSTATUS_T */
end_comment

begin_function
name|char
modifier|*
name|elfcore_write_prfpreg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
specifier|const
name|void
modifier|*
name|fpregs
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|note_name
init|=
literal|"CORE"
decl_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|NT_FPREGSET
argument_list|,
name|fpregs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|elfcore_write_prxfpreg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
specifier|const
name|void
modifier|*
name|xfpregs
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|note_name
init|=
literal|"LINUX"
decl_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|note_name
argument_list|,
name|NT_PRXFPREG
argument_list|,
name|xfpregs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfcore_read_notes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|buf
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|error
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|buf
operator|+
name|size
condition|)
block|{
comment|/* FIXME: bad alignment assumption.  */
name|Elf_External_Note
modifier|*
name|xnp
init|=
operator|(
name|Elf_External_Note
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Internal_Note
name|in
decl_stmt|;
name|in
operator|.
name|type
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|xnp
operator|->
name|type
argument_list|)
expr_stmt|;
name|in
operator|.
name|namesz
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|xnp
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|in
operator|.
name|namedata
operator|=
name|xnp
operator|->
name|name
expr_stmt|;
name|in
operator|.
name|descsz
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|xnp
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|in
operator|.
name|descdata
operator|=
name|in
operator|.
name|namedata
operator|+
name|BFD_ALIGN
argument_list|(
name|in
operator|.
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|in
operator|.
name|descpos
operator|=
name|offset
operator|+
operator|(
name|in
operator|.
name|descdata
operator|-
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|.
name|namedata
argument_list|,
literal|"NetBSD-CORE"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elfcore_grok_netbsd_note
argument_list|(
name|abfd
argument_list|,
operator|&
name|in
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|.
name|namedata
argument_list|,
literal|"QNX"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elfcore_grok_nto_note
argument_list|(
name|abfd
argument_list|,
operator|&
name|in
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|elfcore_grok_note
argument_list|(
name|abfd
argument_list|,
operator|&
name|in
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|in
operator|.
name|descdata
operator|+
name|BFD_ALIGN
argument_list|(
name|in
operator|.
name|descsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Providing external access to the ELF program header table.  */
end_comment

begin_comment
comment|/* Return an upper bound on the number of bytes required to store a    copy of ABFD's program header table entries.  Return -1 if an error    occurs; bfd_get_error will return an appropriate code.  */
end_comment

begin_function
name|long
name|bfd_get_elf_phdr_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy ABFD's program header table entries to *PHDRS.  The entries    will be stored as an array of Elf_Internal_Phdr structures, as    defined in include/elf/internal.h.  To find out how large the    buffer needs to be, call bfd_get_elf_phdr_upper_bound.     Return the number of program header table entries read, or -1 if an    error occurs; bfd_get_error will return an appropriate code.  */
end_comment

begin_function
name|int
name|bfd_get_elf_phdrs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|phdrs
parameter_list|)
block|{
name|int
name|num_phdrs
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|num_phdrs
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
expr_stmt|;
name|memcpy
argument_list|(
name|phdrs
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
argument_list|,
name|num_phdrs
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|num_phdrs
return|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_sprintf_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|==
name|NULL
condition|)
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%016lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%08lx%08lx"
argument_list|,
name|_bfd_int64_high
argument_list|(
name|value
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%08lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|value
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_bfd_elf_fprintf_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|stream
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|==
name|NULL
condition|)
name|fprintf_vma
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
literal|"%016lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
literal|"%08lx%08lx"
argument_list|,
name|_bfd_int64_high
argument_list|(
name|value
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
literal|"%08lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|value
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf_vma
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|enum
name|elf_reloc_type_class
name|_bfd_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|reloc_class_normal
return|;
block|}
end_function

begin_comment
comment|/* For RELA architectures, return the relocation value for a    relocation against a local symbol.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_elf_rela_local_sym
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
modifier|*
name|psec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|asection
modifier|*
name|sec
init|=
operator|*
name|psec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
name|rel
operator|->
name|r_addend
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|abfd
argument_list|,
name|psec
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|sym
operator|->
name|st_value
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
operator|*
name|psec
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|-=
name|relocation
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
return|return
name|relocation
return|;
block|}
end_function

begin_function
name|bfd_vma
name|_bfd_elf_rel_local_sym
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
modifier|*
name|psec
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|asection
modifier|*
name|sec
init|=
operator|*
name|psec
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_MERGE
condition|)
return|return
name|sym
operator|->
name|st_value
operator|+
name|addend
return|;
return|return
name|_bfd_merged_section_offset
argument_list|(
name|abfd
argument_list|,
name|psec
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|sym
operator|->
name|st_value
operator|+
name|addend
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_vma
name|_bfd_elf_section_offset
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|sec_data
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sec
operator|->
name|sec_info_type
condition|)
block|{
case|case
name|ELF_INFO_TYPE_STABS
case|:
return|return
name|_bfd_stab_section_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|merge_info
argument_list|,
name|sec
argument_list|,
operator|&
name|sec_data
operator|->
name|sec_info
argument_list|,
name|offset
argument_list|)
return|;
case|case
name|ELF_INFO_TYPE_EH_FRAME
case|:
return|return
name|_bfd_elf_eh_frame_section_offset
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|offset
argument_list|)
return|;
default|default:
return|return
name|offset
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new BFD as if by bfd_openr.  Rather than opening a file,    reconstruct an ELF file by reading the segments out of remote memory    based on the ELF file header at EHDR_VMA and the ELF program headers it    points to.  If not null, *LOADBASEP is filled in with the difference    between the VMAs from which the segments were read, and the VMAs the    file headers (and hence BFD's idea of each section's VMA) put them at.     The function TARGET_READ_MEMORY is called to copy LEN bytes from the    remote memory at target address VMA into the local buffer at MYADDR; it    should return zero on success or an `errno' code on failure.  TEMPL must    be a BFD for an ELF target with the word size and byte order found in    the remote memory.  */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_elf_bfd_from_remote_memory
parameter_list|(
name|bfd
modifier|*
name|templ
parameter_list|,
name|bfd_vma
name|ehdr_vma
parameter_list|,
name|bfd_vma
modifier|*
name|loadbasep
parameter_list|,
name|int
function_decl|(
modifier|*
name|target_read_memory
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
return|return
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|templ
argument_list|)
operator|->
name|elf_backend_bfd_from_remote_memory
operator|)
operator|(
name|templ
operator|,
name|ehdr_vma
operator|,
name|loadbasep
operator|,
name|target_read_memory
operator|)
return|;
block|}
end_function

end_unit

