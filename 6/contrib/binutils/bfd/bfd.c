begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic BFD library interface and support routines.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION<<typedef bfd>>  	A BFD has type<<bfd>>; objects of this type are the 	cornerstone of any application using BFD. Using BFD 	consists of making references though the BFD and to data in the BFD.  	Here is the structure that defines the type<<bfd>>.  It 	contains the major data about the file and pointers 	to the rest of the data.  CODE_FRAGMENT . .struct bfd .{ .  {* A unique identifier of the BFD  *} .  unsigned int id; . .  {* The filename the application opened the BFD with.  *} .  const char *filename; . .  {* A pointer to the target jump table.  *} .  const struct bfd_target *xvec; . .  {* To avoid dragging too many header files into every file that .     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *", .     and MTIME as a "long".  Their correct types, to which they .     are cast when used, are "FILE *" and "time_t".    The iostream .     is the result of an fopen on the filename.  However, if the .     BFD_IN_MEMORY flag is set, then iostream is actually a pointer .     to a bfd_in_memory struct.  *} .  void *iostream; . .  {* Is the file descriptor being cached?  That is, can it be closed as .     needed, and re-opened when accessed later?  *} .  bfd_boolean cacheable; . .  {* Marks whether there was a default target specified when the .     BFD was opened. This is used to select which matching algorithm .     to use to choose the back end.  *} .  bfd_boolean target_defaulted; . .  {* The caching routines use these to maintain a .     least-recently-used list of BFDs.  *} .  struct bfd *lru_prev, *lru_next; . .  {* When a file is closed by the caching routines, BFD retains .     state information on the file here...  *} .  ufile_ptr where; . .  {* ... and here: (``once'' means at least once).  *} .  bfd_boolean opened_once; . .  {* Set if we have a locally maintained mtime value, rather than .     getting it from the file each time.  *} .  bfd_boolean mtime_set; . .  {* File modified time, if mtime_set is TRUE.  *} .  long mtime; . .  {* Reserved for an unimplemented file locking extension.  *} .  int ifd; . .  {* The format which belongs to the BFD. (object, core, etc.)  *} .  bfd_format format; . .  {* The direction with which the BFD was opened.  *} .  enum bfd_direction .    { .      no_direction = 0, .      read_direction = 1, .      write_direction = 2, .      both_direction = 3 .    } .  direction; . .  {* Format_specific flags.  *} .  flagword flags; . .  {* Currently my_archive is tested before adding origin to .     anything. I believe that this can become always an add of .     origin, with origin set to 0 for non archive files.  *} .  ufile_ptr origin; . .  {* Remember when output has begun, to stop strange things .     from happening.  *} .  bfd_boolean output_has_begun; . .  {* A hash table for section names.  *} .  struct bfd_hash_table section_htab; . .  {* Pointer to linked list of sections.  *} .  struct bfd_section *sections; . .  {* The place where we add to the section list.  *} .  struct bfd_section **section_tail; . .  {* The number of sections.  *} .  unsigned int section_count; . .  {* Stuff only useful for object files: .     The start address.  *} .  bfd_vma start_address; . .  {* Used for input and output.  *} .  unsigned int symcount; . .  {* Symbol table for output BFD (with symcount entries).  *} .  struct bfd_symbol  **outsymbols; . .  {* Used for slurped dynamic symbol tables.  *} .  unsigned int dynsymcount; . .  {* Pointer to structure which contains architecture information.  *} .  const struct bfd_arch_info *arch_info; . .  {* Stuff only useful for archives.  *} .  void *arelt_data; .  struct bfd *my_archive;      {* The containing archive BFD.  *} .  struct bfd *next;            {* The next BFD in the archive.  *} .  struct bfd *archive_head;    {* The first BFD in the archive.  *} .  bfd_boolean has_armap; . .  {* A chain of BFD structures involved in a link.  *} .  struct bfd *link_next; . .  {* A field used by _bfd_generic_link_add_archive_symbols.  This will .     be used only for archive elements.  *} .  int archive_pass; . .  {* Used by the back end to hold private data.  *} .  union .    { .      struct aout_data_struct *aout_data; .      struct artdata *aout_ar_data; .      struct _oasys_data *oasys_obj_data; .      struct _oasys_ar_data *oasys_ar_data; .      struct coff_tdata *coff_obj_data; .      struct pe_tdata *pe_obj_data; .      struct xcoff_tdata *xcoff_obj_data; .      struct ecoff_tdata *ecoff_obj_data; .      struct ieee_data_struct *ieee_data; .      struct ieee_ar_data_struct *ieee_ar_data; .      struct srec_data_struct *srec_data; .      struct ihex_data_struct *ihex_data; .      struct tekhex_data_struct *tekhex_data; .      struct elf_obj_tdata *elf_obj_data; .      struct nlm_obj_tdata *nlm_obj_data; .      struct bout_data_struct *bout_data; .      struct mmo_data_struct *mmo_data; .      struct sun_core_struct *sun_core_data; .      struct sco5_core_struct *sco5_core_data; .      struct trad_core_struct *trad_core_data; .      struct som_data_struct *som_data; .      struct hpux_core_struct *hpux_core_data; .      struct hppabsd_core_struct *hppabsd_core_data; .      struct sgi_core_struct *sgi_core_data; .      struct lynx_core_struct *lynx_core_data; .      struct osf_core_struct *osf_core_data; .      struct cisco_core_struct *cisco_core_data; .      struct versados_data_struct *versados_data; .      struct netbsd_core_struct *netbsd_core_data; .      struct mach_o_data_struct *mach_o_data; .      struct mach_o_fat_data_struct *mach_o_fat_data; .      struct bfd_pef_data_struct *pef_data; .      struct bfd_pef_xlib_data_struct *pef_xlib_data; .      struct bfd_sym_data_struct *sym_data; .      void *any; .    } .  tdata; . .  {* Used by the application to hold private data.  *} .  void *usrdata; . .  {* Where all the allocated stuff under this BFD goes.  This is a .     struct objalloc *, but we use void * to avoid requiring the inclusion .     of objalloc.h.  *} .  void *memory; .}; . */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdver.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_undef
undef|#
directive|undef
name|obj_symbols
end_undef

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* provide storage for subsystem, stack and heap data which may have been    passed in on the command line.  Ld puts this data into a bfd_link_info    struct which ultimately gets passed in to the bfd.  When it arrives, copy    it to the following struct so that the data will be available in coffcode.h    where it is needed.  The typedef's used are defined in bfd.h */
end_comment

begin_escape
end_escape

begin_comment
comment|/* SECTION 	Error reporting  	Most BFD functions return nonzero on success (check their 	individual documentation for precise semantics).  On an error, 	they call<<bfd_set_error>> to set an error condition that callers 	can check by calling<<bfd_get_error>>.         If that returns<<bfd_error_system_call>>, then check<<errno>>.  	The easiest way to report a BFD error to the user is to 	use<<bfd_perror>>.  SUBSECTION 	Type<<bfd_error_type>>  	The values returned by<<bfd_get_error>> are defined by the 	enumerated type<<bfd_error_type>>.  CODE_FRAGMENT . .typedef enum bfd_error .{ .  bfd_error_no_error = 0, .  bfd_error_system_call, .  bfd_error_invalid_target, .  bfd_error_wrong_format, .  bfd_error_wrong_object_format, .  bfd_error_invalid_operation, .  bfd_error_no_memory, .  bfd_error_no_symbols, .  bfd_error_no_armap, .  bfd_error_no_more_archived_files, .  bfd_error_malformed_archive, .  bfd_error_file_not_recognized, .  bfd_error_file_ambiguously_recognized, .  bfd_error_no_contents, .  bfd_error_nonrepresentable_section, .  bfd_error_no_debug_section, .  bfd_error_bad_value, .  bfd_error_file_truncated, .  bfd_error_file_too_big, .  bfd_error_invalid_error_code .} .bfd_error_type; . */
end_comment

begin_decl_stmt
specifier|static
name|bfd_error_type
name|bfd_error
init|=
name|bfd_error_no_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|bfd_errmsgs
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"No error"
argument_list|)
block|,
name|N_
argument_list|(
literal|"System call error"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Invalid bfd target"
argument_list|)
block|,
name|N_
argument_list|(
literal|"File in wrong format"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Archive object file in wrong format"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Invalid operation"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Memory exhausted"
argument_list|)
block|,
name|N_
argument_list|(
literal|"No symbols"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Archive has no index; run ranlib to add one"
argument_list|)
block|,
name|N_
argument_list|(
literal|"No more archived files"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Malformed archive"
argument_list|)
block|,
name|N_
argument_list|(
literal|"File format not recognized"
argument_list|)
block|,
name|N_
argument_list|(
literal|"File format is ambiguous"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Section has no contents"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Nonrepresentable section on output"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Symbol needs debug section which does not exist"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Bad value"
argument_list|)
block|,
name|N_
argument_list|(
literal|"File truncated"
argument_list|)
block|,
name|N_
argument_list|(
literal|"File too big"
argument_list|)
block|,
name|N_
argument_list|(
literal|"#<Invalid error code>"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_get_error  SYNOPSIS 	bfd_error_type bfd_get_error (void);  DESCRIPTION 	Return the current BFD error condition. */
end_comment

begin_function
name|bfd_error_type
name|bfd_get_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|bfd_error
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_error  SYNOPSIS 	void bfd_set_error (bfd_error_type error_tag);  DESCRIPTION 	Set the BFD error condition to be @var{error_tag}. */
end_comment

begin_function
name|void
name|bfd_set_error
parameter_list|(
name|bfd_error_type
name|error_tag
parameter_list|)
block|{
name|bfd_error
operator|=
name|error_tag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_errmsg  SYNOPSIS 	const char *bfd_errmsg (bfd_error_type error_tag);  DESCRIPTION 	Return a string describing the error @var{error_tag}, or 	the system error if @var{error_tag} is<<bfd_error_system_call>>. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_errmsg
parameter_list|(
name|bfd_error_type
name|error_tag
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|errno
specifier|extern
name|int
name|errno
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error_tag
operator|==
name|bfd_error_system_call
condition|)
return|return
name|xstrerror
argument_list|(
name|errno
argument_list|)
return|;
if|if
condition|(
name|error_tag
operator|>
name|bfd_error_invalid_error_code
condition|)
name|error_tag
operator|=
name|bfd_error_invalid_error_code
expr_stmt|;
comment|/* sanity check */
return|return
name|_
argument_list|(
name|bfd_errmsgs
index|[
name|error_tag
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_perror  SYNOPSIS 	void bfd_perror (const char *message);  DESCRIPTION 	Print to the standard error stream a string describing the 	last BFD error that occurred, or the last system error if 	the last BFD error was a system call failure.  If @var{message} 	is non-NULL and non-empty, the error string printed is preceded 	by @var{message}, a colon, and a space.  It is followed by a newline. */
end_comment

begin_function
name|void
name|bfd_perror
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_system_call
condition|)
comment|/* Must be a system error then.  */
name|perror
argument_list|(
operator|(
name|char
operator|*
operator|)
name|message
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|message
operator|==
name|NULL
operator|||
operator|*
name|message
operator|==
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|message
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* SUBSECTION 	BFD error handler  	Some BFD functions want to print messages describing the 	problem.  They call a BFD error handler function.  This 	function may be overridden by the program.  	The BFD error handler acts like printf.  CODE_FRAGMENT . .typedef void (*bfd_error_handler_type) (const char *, ...); . */
end_comment

begin_comment
comment|/* The program name used when printing BFD error messages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_bfd_error_program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the default routine to handle BFD error messages.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_default_error_handler
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|p
decl_stmt|;
if|if
condition|(
name|_bfd_error_program_name
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|_bfd_error_program_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BFD: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a function pointer to the routine which should handle BFD    error messages.  It is called when a BFD routine encounters an    error for which it wants to print a message.  Going through a    function pointer permits a program linked against BFD to intercept    the messages and deal with them itself.  */
end_comment

begin_decl_stmt
name|bfd_error_handler_type
name|_bfd_error_handler
init|=
name|_bfd_default_error_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_error_handler  SYNOPSIS 	bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);  DESCRIPTION 	Set the BFD error handler function.  Returns the previous 	function. */
end_comment

begin_function
name|bfd_error_handler_type
name|bfd_set_error_handler
parameter_list|(
name|bfd_error_handler_type
name|pnew
parameter_list|)
block|{
name|bfd_error_handler_type
name|pold
decl_stmt|;
name|pold
operator|=
name|_bfd_error_handler
expr_stmt|;
name|_bfd_error_handler
operator|=
name|pnew
expr_stmt|;
return|return
name|pold
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_error_program_name  SYNOPSIS 	void bfd_set_error_program_name (const char *);  DESCRIPTION 	Set the program name to use when printing a BFD error.  This 	is printed before the error message followed by a colon and 	space.  The string must not be changed after it is passed to 	this function. */
end_comment

begin_function
name|void
name|bfd_set_error_program_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|_bfd_error_program_name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_error_handler  SYNOPSIS 	bfd_error_handler_type bfd_get_error_handler (void);  DESCRIPTION 	Return the BFD error handler function. */
end_comment

begin_function
name|bfd_error_handler_type
name|bfd_get_error_handler
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_bfd_error_handler
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_archive_filename  SYNOPSIS 	const char *bfd_archive_filename (bfd *);  DESCRIPTION 	For a BFD that is a component of an archive, returns a string 	with both the archive name and file name.  For other BFDs, just 	returns the file name. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_archive_filename
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
return|return
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
return|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
block|{
specifier|static
name|size_t
name|curr
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|needed
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|curr
condition|)
block|{
if|if
condition|(
name|curr
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|curr
operator|=
name|needed
operator|+
operator|(
name|needed
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|bfd_malloc
argument_list|(
name|curr
argument_list|)
expr_stmt|;
comment|/* If we can't malloc, fail safe by returning just the file 	     name. This function is only used when building error 	     messages.  */
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|curr
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
return|;
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
return|return
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* SECTION 	Symbols */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_get_reloc_upper_bound  SYNOPSIS 	long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);  DESCRIPTION 	Return the number of bytes required to store the 	relocation information associated with section @var{sect} 	attached to bfd @var{abfd}.  If an error occurs, return -1.  */
end_comment

begin_function
name|long
name|bfd_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_canonicalize_reloc  SYNOPSIS 	long bfd_canonicalize_reloc 	  (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);  DESCRIPTION 	Call the back end associated with the open BFD 	@var{abfd} and translate the external form of the relocation 	information attached to @var{sec} into the internal canonical 	form.  Place the table into memory at @var{loc}, which has 	been preallocated, usually by a call to<<bfd_get_reloc_upper_bound>>.  Returns the number of relocs, or 	-1 on error.  	The @var{syms} table is also needed for horrible internal magic 	reasons.  */
end_comment

begin_function
name|long
name|bfd_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|,
name|arelent
modifier|*
modifier|*
name|location
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|location
operator|,
name|symbols
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_reloc  SYNOPSIS 	void bfd_set_reloc 	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count);  DESCRIPTION 	Set the relocation pointer and count within 	section @var{sec} to the values @var{rel} and @var{count}. 	The argument @var{abfd} is ignored.  */
end_comment

begin_function
name|void
name|bfd_set_reloc
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|sec_ptr
name|asect
parameter_list|,
name|arelent
modifier|*
modifier|*
name|location
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|asect
operator|->
name|orelocation
operator|=
name|location
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_file_flags  SYNOPSIS 	bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);  DESCRIPTION 	Set the flag word in the BFD @var{abfd} to the value @var{flags}.  	Possible errors are: 	o<<bfd_error_wrong_format>> - The target bfd was not of object format. 	o<<bfd_error_invalid_operation>> - The target bfd was open for reading. 	o<<bfd_error_invalid_operation>> - 	The flag word contained a bit which was not applicable to the 	type of file.  E.g., an attempt was made to set the<<D_PAGED>> bit 	on a BFD format which does not support demand paging.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_set_file_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|bfd_applicable_file_flags
argument_list|(
name|abfd
argument_list|)
operator|)
operator|!=
name|flags
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|bfd_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"BFD %s assertion fail %s:%d"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A more or less friendly abort message.  In libbfd.h abort is    defined to call this function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef

begin_define
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_bfd_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"BFD %s internal error, aborting at %s line %d in %s\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"BFD %s internal error, aborting at %s line %d\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Please report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_arch_size  SYNOPSIS  	int bfd_get_arch_size (bfd *abfd);  DESCRIPTION 	Returns the architecture address size, in bits, as determined 	by the object file's format.  For ELF, this information is 	included in the header.  RETURNS 	Returns the arch size in bits if known,<<-1>> otherwise. */
end_comment

begin_function
name|int
name|bfd_get_arch_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
return|return
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_sign_extend_vma  SYNOPSIS  	int bfd_get_sign_extend_vma (bfd *abfd);  DESCRIPTION 	Indicates if the target architecture "naturally" sign extends 	an address.  Some architectures implicitly sign extend address 	values when they are converted to types larger than the size 	of an address.  For instance, bfd_get_start_address() will 	return an address sign extended to fill a bfd_vma when this is 	the case.  RETURNS 	Returns<<1>> if the target architecture is known to sign 	extend addresses,<<0>> if the target architecture is known to 	not sign extend addresses, and<<-1>> otherwise. */
end_comment

begin_function
name|int
name|bfd_get_sign_extend_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
return|return
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
return|;
name|name
operator|=
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Return a proper value for DJGPP COFF (an x86 COFF variant).      This function is required for DWARF2 support, but there is      no place to store this information in the COFF back end.      Should enough other COFF targets add support for DWARF2,      a place will have to be found.  Until then, this hack will do.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"coff-go32"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"coff-go32"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_start_address  SYNOPSIS  	bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);  DESCRIPTION 	Make @var{vma} the entry point of output BFD @var{abfd}.  RETURNS 	Returns<<TRUE>> on success,<<FALSE>> otherwise. */
end_comment

begin_function
name|bfd_boolean
name|bfd_set_start_address
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|vma
parameter_list|)
block|{
name|abfd
operator|->
name|start_address
operator|=
name|vma
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_gp_size  SYNOPSIS 	unsigned int bfd_get_gp_size (bfd *abfd);  DESCRIPTION 	Return the maximum size of objects to be optimized using the GP 	register under MIPS ECOFF.  This is typically set by the<<-G>> 	argument to the compiler, assembler or linker. */
end_comment

begin_function
name|unsigned
name|int
name|bfd_get_gp_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|==
name|bfd_object
condition|)
block|{
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_ecoff_flavour
condition|)
return|return
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp_size
return|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
return|return
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_gp_size  SYNOPSIS 	void bfd_set_gp_size (bfd *abfd, unsigned int i);  DESCRIPTION 	Set the maximum size of objects to be optimized using the GP 	register under ECOFF or MIPS ELF.  This is typically set by 	the<<-G>> argument to the compiler, assembler or linker. */
end_comment

begin_function
name|void
name|bfd_set_gp_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
comment|/* Don't try to set GP size on an archive or core file!  */
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
return|return;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_ecoff_flavour
condition|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp_size
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the GP value.  This is an internal function used by some of the    relocation special_function routines on targets which support a GP    register.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_get_gp_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_ecoff_flavour
condition|)
return|return
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
return|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
return|return
name|elf_gp
argument_list|(
name|abfd
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the GP value.  */
end_comment

begin_function
name|void
name|_bfd_set_gp_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
condition|)
name|BFD_FAIL
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
return|return;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_ecoff_flavour
condition|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
operator|=
name|v
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_scan_vma  SYNOPSIS 	bfd_vma bfd_scan_vma (const char *string, const char **end, int base);  DESCRIPTION 	Convert, like<<strtoul>>, a numerical expression 	@var{string} into a<<bfd_vma>> integer, and return that integer. 	(Though without as many bells and whistles as<<strtoul>>.) 	The expression is assumed to be unsigned (i.e., positive). 	If given a @var{base}, it is used as the base for conversion. 	A base of 0 causes the function to interpret the string 	in hex if a leading "0x" or "0X" is found, otherwise 	in octal if a leading zero is found, otherwise in decimal.  	If the value would overflow, the maximum<<bfd_vma>> value is 	returned. */
end_comment

begin_function
name|bfd_vma
name|bfd_scan_vma
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|cutoff
decl_stmt|;
name|unsigned
name|int
name|cutlim
decl_stmt|;
name|int
name|overflow
decl_stmt|;
comment|/* Let the host do it if possible.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
return|return
name|strtoul
argument_list|(
name|string
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|end
argument_list|,
name|base
argument_list|)
return|;
ifdef|#
directive|ifdef
name|HAVE_STRTOULL
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
name|long
operator|)
condition|)
return|return
name|strtoull
argument_list|(
name|string
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|end
argument_list|,
name|base
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|base
operator|=
literal|16
expr_stmt|;
else|else
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|base
operator|<
literal|2
operator|)
operator|||
operator|(
name|base
operator|>
literal|36
operator|)
condition|)
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|string
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|string
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|&&
name|ISXDIGIT
argument_list|(
name|string
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|string
operator|+=
literal|2
expr_stmt|;
block|}
name|cutoff
operator|=
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|/
operator|(
name|bfd_vma
operator|)
name|base
expr_stmt|;
name|cutlim
operator|=
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|%
operator|(
name|bfd_vma
operator|)
name|base
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|int
name|digit
decl_stmt|;
name|digit
operator|=
operator|*
name|string
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|digit
argument_list|)
condition|)
name|digit
operator|=
name|digit
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|digit
argument_list|)
condition|)
name|digit
operator|=
name|TOUPPER
argument_list|(
name|digit
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|digit
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|base
condition|)
break|break;
if|if
condition|(
name|value
operator|>
name|cutoff
operator|||
operator|(
name|value
operator|==
name|cutoff
operator|&&
name|digit
operator|>
name|cutlim
operator|)
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|value
operator|*
name|base
operator|+
name|digit
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
name|value
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|string
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_copy_private_bfd_data  SYNOPSIS 	bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);  DESCRIPTION 	Copy private BFD information from the BFD @var{ibfd} to the 	the BFD @var{obfd}.  Return<<TRUE>> on success,<<FALSE>> on error. 	Possible error returns are:  	o<<bfd_error_no_memory>> - 	Not enough memory exists to create private data for @var{obfd}.  .#define bfd_copy_private_bfd_data(ibfd, obfd) \ .     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \ .		(ibfd, obfd))  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_merge_private_bfd_data  SYNOPSIS 	bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);  DESCRIPTION 	Merge private BFD information from the BFD @var{ibfd} to the 	the output file BFD @var{obfd} when linking.  Return<<TRUE>> 	on success,<<FALSE>> on error.  Possible error returns are:  	o<<bfd_error_no_memory>> - 	Not enough memory exists to create private data for @var{obfd}.  .#define bfd_merge_private_bfd_data(ibfd, obfd) \ .     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \ .		(ibfd, obfd))  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_set_private_flags  SYNOPSIS 	bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);  DESCRIPTION 	Set private BFD flag information in the BFD @var{abfd}. 	Return<<TRUE>> on success,<<FALSE>> on error.  Possible error 	returns are:  	o<<bfd_error_no_memory>> - 	Not enough memory exists to create private data for @var{obfd}.  .#define bfd_set_private_flags(abfd, flags) \ .     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))  */
end_comment

begin_comment
comment|/* FUNCTION 	Other functions  DESCRIPTION 	The following functions exist but have not yet been documented.  .#define bfd_sizeof_headers(abfd, reloc) \ .       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc)) . .#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \ .       BFD_SEND (abfd, _bfd_find_nearest_line, \ .                 (abfd, sec, syms, off, file, func, line)) . .#define bfd_debug_info_start(abfd) \ .       BFD_SEND (abfd, _bfd_debug_info_start, (abfd)) . .#define bfd_debug_info_end(abfd) \ .       BFD_SEND (abfd, _bfd_debug_info_end, (abfd)) . .#define bfd_debug_info_accumulate(abfd, section) \ .       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section)) . .#define bfd_stat_arch_elt(abfd, stat) \ .       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat)) . .#define bfd_update_armap_timestamp(abfd) \ .       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd)) . .#define bfd_set_arch_mach(abfd, arch, mach)\ .       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach)) . .#define bfd_relax_section(abfd, section, link_info, again) \ .       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again)) . .#define bfd_gc_sections(abfd, link_info) \ .	BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info)) . .#define bfd_merge_sections(abfd, link_info) \ .	BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info)) . .#define bfd_discard_group(abfd, sec) \ .	BFD_SEND (abfd, _bfd_discard_group, (abfd, sec)) . .#define bfd_link_hash_table_create(abfd) \ .	BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd)) . .#define bfd_link_hash_table_free(abfd, hash) \ .	BFD_SEND (abfd, _bfd_link_hash_table_free, (hash)) . .#define bfd_link_add_symbols(abfd, info) \ .	BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info)) . .#define bfd_link_just_syms(sec, info) \ .	BFD_SEND (abfd, _bfd_link_just_syms, (sec, info)) . .#define bfd_final_link(abfd, info) \ .	BFD_SEND (abfd, _bfd_final_link, (abfd, info)) . .#define bfd_free_cached_info(abfd) \ .       BFD_SEND (abfd, _bfd_free_cached_info, (abfd)) . .#define bfd_get_dynamic_symtab_upper_bound(abfd) \ .	BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd)) . .#define bfd_print_private_bfd_data(abfd, file)\ .	BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file)) . .#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \ .	BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols)) . .#define bfd_get_dynamic_reloc_upper_bound(abfd) \ .	BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd)) . .#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \ .	BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms)) . .extern bfd_byte *bfd_get_relocated_section_contents .  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *, .   bfd_boolean, asymbol **); .  */
end_comment

begin_function
name|bfd_byte
modifier|*
name|bfd_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd2
decl_stmt|;
name|bfd_byte
modifier|*
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|abfd2
operator|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|abfd2
operator|==
name|NULL
condition|)
name|abfd2
operator|=
name|abfd
expr_stmt|;
block|}
else|else
name|abfd2
operator|=
name|abfd
expr_stmt|;
name|fn
operator|=
name|abfd2
operator|->
name|xvec
operator|->
name|_bfd_get_relocated_section_contents
expr_stmt|;
return|return
call|(
modifier|*
name|fn
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record information about an ELF program header.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_record_phdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|type
parameter_list|,
name|bfd_boolean
name|flags_valid
parameter_list|,
name|flagword
name|flags
parameter_list|,
name|bfd_boolean
name|at_valid
parameter_list|,
name|bfd_vma
name|at
parameter_list|,
name|bfd_boolean
name|includes_filehdr
parameter_list|,
name|bfd_boolean
name|includes_phdrs
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|,
name|asection
modifier|*
modifier|*
name|secs
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
operator|(
name|bfd_size_type
operator|)
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|m
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|type
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
name|flags
expr_stmt|;
name|m
operator|->
name|p_paddr
operator|=
name|at
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
name|flags_valid
expr_stmt|;
name|m
operator|->
name|p_paddr_valid
operator|=
name|at_valid
expr_stmt|;
name|m
operator|->
name|includes_filehdr
operator|=
name|includes_filehdr
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
name|includes_phdrs
expr_stmt|;
name|m
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|m
operator|->
name|sections
argument_list|,
name|secs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|bfd_sprintf_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_fprintf_vma
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|stream
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|stream
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf_vma
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|stream
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_alt_mach_code  SYNOPSIS 	bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);  DESCRIPTION  	When more than one machine code number is available for the 	same machine type, this function can be used to switch between 	the preferred one (alternative == 0) and any others.  Currently, 	only ELF supports this feature, with up to two alternate 	machine codes. */
end_comment

begin_function
name|bfd_boolean
name|bfd_alt_mach_code
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|alternative
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|int
name|code
decl_stmt|;
switch|switch
condition|(
name|alternative
condition|)
block|{
case|case
literal|0
case|:
name|code
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_machine_code
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|code
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_machine_alt1
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_machine_alt2
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|=
name|code
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* CODE_FRAGMENT  .struct bfd_preserve .{ .  void *marker; .  void *tdata; .  flagword flags; .  const struct bfd_arch_info *arch_info; .  struct bfd_section *sections; .  struct bfd_section **section_tail; .  unsigned int section_count; .  struct bfd_hash_table section_htab; .}; . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_preserve_save  SYNOPSIS 	bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);  DESCRIPTION 	When testing an object for compatibility with a particular 	target back-end, the back-end object_p function needs to set 	up certain fields in the bfd on successfully recognizing the 	object.  This typically happens in a piecemeal fashion, with 	failures possible at many points.  On failure, the bfd is 	supposed to be restored to its initial state, which is 	virtually impossible.  However, restoring a subset of the bfd 	state works in practice.  This function stores the subset and 	reinitializes the bfd.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_preserve_save
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_preserve
modifier|*
name|preserve
parameter_list|)
block|{
name|preserve
operator|->
name|tdata
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|any
expr_stmt|;
name|preserve
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
expr_stmt|;
name|preserve
operator|->
name|flags
operator|=
name|abfd
operator|->
name|flags
expr_stmt|;
name|preserve
operator|->
name|sections
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
name|preserve
operator|->
name|section_tail
operator|=
name|abfd
operator|->
name|section_tail
expr_stmt|;
name|preserve
operator|->
name|section_count
operator|=
name|abfd
operator|->
name|section_count
expr_stmt|;
name|preserve
operator|->
name|section_htab
operator|=
name|abfd
operator|->
name|section_htab
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|abfd
operator|->
name|section_htab
argument_list|,
name|bfd_section_hash_newfunc
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|abfd
operator|->
name|flags
operator|&=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|section_tail
operator|=
operator|&
name|abfd
operator|->
name|sections
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_preserve_restore  SYNOPSIS 	void bfd_preserve_restore (bfd *, struct bfd_preserve *);  DESCRIPTION 	This function restores bfd state saved by bfd_preserve_save. 	If MARKER is non-NULL in struct bfd_preserve then that block 	and all subsequently bfd_alloc'd memory is freed.  */
end_comment

begin_function
name|void
name|bfd_preserve_restore
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_preserve
modifier|*
name|preserve
parameter_list|)
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|abfd
operator|->
name|section_htab
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|preserve
operator|->
name|tdata
expr_stmt|;
name|abfd
operator|->
name|arch_info
operator|=
name|preserve
operator|->
name|arch_info
expr_stmt|;
name|abfd
operator|->
name|flags
operator|=
name|preserve
operator|->
name|flags
expr_stmt|;
name|abfd
operator|->
name|section_htab
operator|=
name|preserve
operator|->
name|section_htab
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|preserve
operator|->
name|sections
expr_stmt|;
name|abfd
operator|->
name|section_tail
operator|=
name|preserve
operator|->
name|section_tail
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
name|preserve
operator|->
name|section_count
expr_stmt|;
comment|/* bfd_release frees all memory more recently bfd_alloc'd than      its arg, as well as its arg.  */
if|if
condition|(
name|preserve
operator|->
name|marker
operator|!=
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|preserve
operator|->
name|marker
argument_list|)
expr_stmt|;
name|preserve
operator|->
name|marker
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_preserve_finish  SYNOPSIS 	void bfd_preserve_finish (bfd *, struct bfd_preserve *);  DESCRIPTION 	This function should be called when the bfd state saved by 	bfd_preserve_save is no longer needed.  ie. when the back-end 	object_p function returns with success.  */
end_comment

begin_function
name|void
name|bfd_preserve_finish
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_preserve
modifier|*
name|preserve
parameter_list|)
block|{
comment|/* It would be nice to be able to free more memory here, eg. old      tdata, but that's not possible since these blocks are sitting      inside bfd_alloc'd memory.  The section hash is on a separate      objalloc.  */
name|bfd_hash_table_free
argument_list|(
operator|&
name|preserve
operator|->
name|section_htab
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

