begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2004 Michael J. Silbersack. All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * $FreeBSD$  * The goal of this program is to see if fstat reports the correct  * data count for a pipe.  Prior to revision 1.172 of sys_pipe.c,  * 0 would be returned once the pipe entered direct write mode.  *  * Linux (2.6) always returns zero, so it's not a valuable platform  * for comparison.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|32768
index|]
decl_stmt|,
name|buffer2
index|[
literal|32768
index|]
decl_stmt|;
name|int
name|desc
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|successes
decl_stmt|;
name|struct
name|stat
name|status
decl_stmt|;
name|pid_t
name|new_pid
decl_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Couldn't allocate fds\n"
argument_list|)
expr_stmt|;
name|new_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_pid
operator|==
literal|0
condition|)
block|{
name|write
argument_list|(
name|desc
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|,
literal|145
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|desc
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|desc
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|desc
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|,
literal|8191
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|desc
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|successes
operator|<
literal|5
condition|)
block|{
name|usleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|read
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|buffer2
argument_list|,
literal|32768
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|st_size
operator|!=
name|error
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"FAILURE: stat size %d read size %d\n"
argument_list|,
operator|(
name|int
operator|)
name|status
operator|.
name|st_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SUCCESS at stat size %d read size %d\n"
argument_list|,
operator|(
name|int
operator|)
name|status
operator|.
name|st_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|successes
operator|++
expr_stmt|;
comment|/* Sleep to avoid the natural race in reading st_size. */
name|usleep
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

