begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Server Cache Synchronization Protocol (SCSP) Support  * ----------------------------------------------------  *  * Cache Alignment finite state machine  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"scsp_msg.h"
end_include

begin_include
include|#
directive|include
file|"scsp_if.h"
end_include

begin_include
include|#
directive|include
file|"scsp_var.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CA FSM actions  */
end_comment

begin_define
define|#
directive|define
name|CA_ACTION_CNT
value|20
end_define

begin_function_decl
name|int
name|scsp_ca_act_00
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_01
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_02
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_03
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_04
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_05
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_06
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_07
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_08
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_09
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_10
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_11
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_12
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_13
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_14
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_15
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_16
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_17
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_18
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scsp_ca_act_19
parameter_list|(
name|Scsp_dcs
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|scsp_ca_act_vec
index|[
name|CA_ACTION_CNT
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|scsp_ca_act_00
operator|,
function_decl|scsp_ca_act_01
operator|,
function_decl|scsp_ca_act_02
operator|,
function_decl|scsp_ca_act_03
operator|,
function_decl|scsp_ca_act_04
operator|,
function_decl|scsp_ca_act_05
operator|,
function_decl|scsp_ca_act_06
operator|,
function_decl|scsp_ca_act_07
operator|,
function_decl|scsp_ca_act_08
operator|,
function_decl|scsp_ca_act_09
operator|,
function_decl|scsp_ca_act_10
operator|,
function_decl|scsp_ca_act_11
operator|,
function_decl|scsp_ca_act_12
operator|,
function_decl|scsp_ca_act_13
operator|,
function_decl|scsp_ca_act_14
operator|,
function_decl|scsp_ca_act_15
operator|,
function_decl|scsp_ca_act_16
operator|,
function_decl|scsp_ca_act_17
operator|,
function_decl|scsp_ca_act_18
operator|,
function_decl|scsp_ca_act_19
end_function_decl

begin_comment
unit|};
comment|/*  * CA FSM state table  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ca_state_table
index|[
name|SCSP_CAFSM_EVENT_CNT
index|]
index|[
name|SCSP_CAFSM_STATE_CNT
index|]
init|=
block|{
comment|/* 0   1   2   3   4   5	      */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/*  0 */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/*  1 */
block|{
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|15
block|,
literal|15
block|}
block|,
comment|/*  2 */
block|{
literal|0
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|7
block|,
literal|7
block|}
block|,
comment|/*  3 */
block|{
literal|0
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/*  4 */
block|{
literal|0
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|10
block|,
literal|10
block|}
block|,
comment|/*  5 */
block|{
literal|0
block|,
literal|6
block|,
literal|6
block|,
literal|0
block|,
literal|9
block|,
literal|9
block|}
block|,
comment|/*  6 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/*  7 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|13
block|,
literal|13
block|}
block|,
comment|/*  8 */
block|{
literal|18
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|11
block|,
literal|11
block|}
block|,
comment|/*  9 */
block|{
literal|0
block|,
literal|19
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|16
block|}
block|,
comment|/* 10 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Cache Alignment finite state machine  *  * Arguments:  *	dcsp	pointer to a DCS control block for the neighbor  *	event	the event which has occurred  *	p	pointer to further parameter, if there is one  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_cafsm
parameter_list|(
name|dcsp
parameter_list|,
name|event
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|int
name|event
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|action
decl_stmt|,
name|rc
decl_stmt|,
name|state
decl_stmt|;
comment|/* 	 * Select an action from the state table 	 */
name|state
operator|=
name|dcsp
operator|->
name|sd_ca_state
expr_stmt|;
name|action
operator|=
name|ca_state_table
index|[
name|event
index|]
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|scsp_trace_mode
operator|&
name|SCSP_TRACE_CAFSM
condition|)
block|{
name|scsp_trace
argument_list|(
literal|"CAFSM: state=%d, event=%d, action=%d\n"
argument_list|,
name|state
argument_list|,
name|event
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|>=
name|CA_ACTION_CNT
operator|||
name|action
operator|<
literal|0
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CA FSM--invalid action state=%d, event=%d, action=%d"
argument_list|,
name|state
argument_list|,
name|event
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Perform the selected action 	 */
name|rc
operator|=
name|scsp_ca_act_vec
index|[
name|action
index|]
operator|(
name|dcsp
operator|,
name|p
operator|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 0  * Unexpected action -- log an error message and go to Master/Slave  * Negotiation.  The unexpected action is probably from a protocol  * error.  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	EOPNOTSUPP	always returns EOPNOTSUPP  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_00
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Log an error message 	 */
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CA FSM error--unexpected action, state=%d"
argument_list|,
name|dcsp
operator|->
name|sd_ca_state
argument_list|)
expr_stmt|;
comment|/* 	 * Set the new state 	 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
comment|/* 	 * Clear out the DCS block 	 */
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
comment|/* 	 * Notify the client I/F FSM 	 */
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_DOWN
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 1  * Hello FSM has reached Bidirectional state -- go to Master/Slave  * Negotiation state, make a copy of the client's cache, send first CA  * message.  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_01
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|,
modifier|*
name|dupp
decl_stmt|;
comment|/* 	 * Set the new state 	 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
comment|/* 	 * Make a copy of client's cache entries for cache alignment 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCSP_HASHSZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|csep
operator|=
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_cache
index|[
name|i
index|]
init|;
name|csep
condition|;
name|csep
operator|=
name|csep
operator|->
name|sc_next
control|)
block|{
name|dupp
operator|=
name|scsp_dup_cse
argument_list|(
name|csep
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|dupp
argument_list|,
name|Scsp_cse
argument_list|,
name|dcsp
operator|->
name|sd_ca_csas
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Select an initial sequence number 	 */
name|dcsp
operator|->
name|sd_ca_seq
operator|=
operator|(
name|int
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Send a CA message 	 */
name|rc
operator|=
name|scsp_send_ca
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 2  * Hello FSM has gone down -- go to Down state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_02
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Set the new state 	 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_DOWN
expr_stmt|;
comment|/* 	 * Clear out the DCS block 	 */
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
comment|/* 	 * Notify the client I/F FSM 	 */
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_DOWN
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 3  * CA message received -- select Cache Summarize Master or Slave state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_03
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * Check for slave role for LS 	 */
if|if
condition|(
name|msg
operator|->
name|sc_ca
operator|->
name|ca_m
operator|&&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_i
operator|&&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_o
operator|&&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_mcp
operator|.
name|rec_cnt
operator|==
literal|0
operator|&&
name|scsp_cmp_id
argument_list|(
operator|&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_mcp
operator|.
name|sid
argument_list|,
operator|&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_mcp
operator|.
name|rid
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Stop the retransmit timer 		 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 		 * Set the new state 		 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_SLAVE
expr_stmt|;
operator|(
name|void
operator|)
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_SUMM
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Save the master's sequence number 		 */
name|dcsp
operator|->
name|sd_ca_seq
operator|=
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
expr_stmt|;
comment|/* 		 * Send a CA message 		 */
name|rc
operator|=
name|scsp_send_ca
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* 	 * Check for master role for LS 	 */
if|if
condition|(
operator|!
name|msg
operator|->
name|sc_ca
operator|->
name|ca_m
operator|&&
operator|!
name|msg
operator|->
name|sc_ca
operator|->
name|ca_i
operator|&&
name|scsp_cmp_id
argument_list|(
operator|&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_mcp
operator|.
name|sid
argument_list|,
operator|&
name|msg
operator|->
name|sc_ca
operator|->
name|ca_mcp
operator|.
name|rid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Stop the retransmit timer 		 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 		 * Set the new state 		 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_MASTER
expr_stmt|;
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_SUMM
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Process the CA message 		 */
name|scsp_process_ca
argument_list|(
name|dcsp
argument_list|,
name|msg
operator|->
name|sc_ca
argument_list|)
expr_stmt|;
comment|/* 		 * Increment the sequence number 		 */
name|dcsp
operator|->
name|sd_ca_seq
operator|++
expr_stmt|;
comment|/* 		 * Send a CA in reply 		 */
name|rc
operator|=
name|scsp_send_ca
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Ignore the message, go to Master/Slave Negotiation 		 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 4  * CA message received while in Cache Summarize Master state -- process  * CA message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_04
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * If the other side thinks he's the master, or if the 	 * initialization bit is set, or if the message is out 	 * of sequence, go back to Master/Slave Negotiation state 	 */
if|if
condition|(
name|msg
operator|->
name|sc_ca
operator|->
name|ca_m
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_i
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|<
name|dcsp
operator|->
name|sd_ca_seq
operator|-
literal|1
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|>
name|dcsp
operator|->
name|sd_ca_seq
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsp_ca_act_01
argument_list|(
name|dcsp
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Ignore any duplicate messages 	 */
if|if
condition|(
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|==
name|dcsp
operator|->
name|sd_ca_seq
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Stop the retransmission timer 	 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 	 * Process the CA message 	 */
name|scsp_process_ca
argument_list|(
name|dcsp
argument_list|,
name|msg
operator|->
name|sc_ca
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the CA sequence number 	 */
name|dcsp
operator|->
name|sd_ca_seq
operator|++
expr_stmt|;
comment|/* 	 * If we have no more CSAS records to send and the slave sent 	 * a message with the 'O' bit off, we're done with Summarize 	 * state 	 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_ca_csas
operator|&&
operator|!
name|msg
operator|->
name|sc_ca
operator|->
name|ca_o
condition|)
block|{
comment|/* 		 * Free any CA message saved for retransmission 		 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 		 * If the CRL is empty, we go directly to Aligned state; 		 * otherwise, we go to Update Cache and send a CSUS 		 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_crl
condition|)
block|{
comment|/* 			 * Go to Aligned state 			 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_ALIGNED
expr_stmt|;
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_ALIGN
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go to Cache Update state 			 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_UPDATE
expr_stmt|;
operator|(
name|void
operator|)
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_UPD
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|scsp_send_csus
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * There are more CSAS records to be exchanged-- 		 * continue the cache exchange 		 */
name|rc
operator|=
name|scsp_send_ca
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 5  * CA message received while in Cache Summarize Slave state -- process  * CA message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_05
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * If the other side thinks we're the master, or if the 	 * initialization bit is set, or if the message is out 	 * of sequence, go back to Master/Slave Negotiation state 	 */
if|if
condition|(
operator|!
name|msg
operator|->
name|sc_ca
operator|->
name|ca_m
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_i
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|<
name|dcsp
operator|->
name|sd_ca_seq
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|>
name|dcsp
operator|->
name|sd_ca_seq
operator|+
literal|1
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsp_ca_act_01
argument_list|(
name|dcsp
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If this is a duplicate, retransmit the last message 	 */
if|if
condition|(
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|==
name|dcsp
operator|->
name|sd_ca_seq
condition|)
block|{
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|rc
operator|=
name|scsp_send_msg
argument_list|(
name|dcsp
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * Free the last CA message 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Process the CA message 	 */
name|scsp_process_ca
argument_list|(
name|dcsp
argument_list|,
name|msg
operator|->
name|sc_ca
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the CA sequence number 	 */
name|dcsp
operator|->
name|sd_ca_seq
operator|++
expr_stmt|;
comment|/* 	 * Answer the CA message 	 */
name|rc
operator|=
name|scsp_send_ca
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * If we're done sending CSAS records and the other side is, 	 * too, we're done with Summarize state 	 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_ca_csas
operator|&&
operator|!
name|msg
operator|->
name|sc_ca
operator|->
name|ca_o
condition|)
block|{
comment|/* 		 * If the CRL is empty, we go directly to Aligned state; 		 * otherwise, we go to Update Cache and send a CSUS 		 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_crl
condition|)
block|{
comment|/* 			 * Go to Aligned state 			 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_ALIGNED
expr_stmt|;
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_ALIGN
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go to Cache Update state 			 */
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_UPDATE
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_UPD
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|scsp_send_csus
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 6  * Retransmit timer expired -- retransmit last CA message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_06
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Resend the CA message 	 */
name|rc
operator|=
name|scsp_send_msg
argument_list|(
name|dcsp
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
comment|/* 	 * Restart the retransmit timer 	 */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 7  * CSU Solicit received -- send it to the client interface FSM  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_07
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * Cancel the CA retransmit timer and free any CA message 	 * saved for retransmission 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Pass the CSUS to the client interface FSM 	 */
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CSU_SOL
argument_list|,
name|msg
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 8  * CSU Request received -- pass it to the client interface FSM  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_08
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Check whether this messages answers a CSUS 	 */
name|scsp_csus_ack
argument_list|(
name|dcsp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * If all CSAs requestd in CSUS messages have been 	 * received, the cache is aligned, so go to Aligned State 	 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_csus_rexmt_msg
operator|&&
operator|!
name|dcsp
operator|->
name|sd_crl
operator|&&
name|dcsp
operator|->
name|sd_ca_state
operator|!=
name|SCSP_CAFSM_ALIGNED
condition|)
block|{
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_ALIGNED
expr_stmt|;
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CA_ALIGN
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pass the CSU Req to the client interface FSM 	 */
name|rc
operator|=
name|scsp_cfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CIFSM_CSU_REQ
argument_list|,
name|msg
argument_list|,
operator|(
name|Scsp_if_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Move the CSA chain from the message to the list of 	 * requests that need acknowledgements 	 */
for|for
control|(
name|csap
operator|=
name|msg
operator|->
name|sc_csu_msg
operator|->
name|csu_csa_rec
init|;
name|csap
condition|;
name|csap
operator|=
name|csap
operator|->
name|next
control|)
block|{
name|LINK2TAIL
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_csu_ack_pend
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|msg
operator|->
name|sc_csu_msg
operator|->
name|csu_csa_rec
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 9  * CA Retransmit timer expired in Update Cache or Aligned state--free  * the saved CA message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_09
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
comment|/* 	 * Free any CA message saved for retransmission 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 10  * CSU Reply received -- Process the message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_10
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_csu_rexmt
modifier|*
name|rxp
decl_stmt|,
modifier|*
name|next_rxp
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|next_csap
decl_stmt|,
modifier|*
name|mcp
decl_stmt|;
comment|/* 	 * Dequeue acknowledged CSAs.  For each CSAS in the received 	 * message, find the corresponding CSA on the CSU Request 	 * retransmit queue.  Remove the CSA from the queue;  if this 	 * results in the retransmit queue entry being empty, delete 	 * the entry.  If the DCS has a newer CSA, send a CSUS to 	 * request it. 	 * 	 * Caution--potentially confusing lack of indentation ahead. 	 */
for|for
control|(
name|mcp
operator|=
name|msg
operator|->
name|sc_csu_msg
operator|->
name|csu_csa_rec
init|;
name|mcp
condition|;
name|mcp
operator|=
name|mcp
operator|->
name|next
control|)
block|{
for|for
control|(
name|rxp
operator|=
name|dcsp
operator|->
name|sd_csu_rexmt
init|;
name|rxp
condition|;
name|rxp
operator|=
name|next_rxp
control|)
block|{
name|next_rxp
operator|=
name|rxp
operator|->
name|sr_next
expr_stmt|;
for|for
control|(
name|csap
operator|=
name|rxp
operator|->
name|sr_csa
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csap
control|)
block|{
name|next_csap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|scsp_cmp_key
argument_list|(
operator|&
name|csap
operator|->
name|key
argument_list|,
operator|&
name|mcp
operator|->
name|key
argument_list|)
operator|||
name|scsp_cmp_id
argument_list|(
operator|&
name|csap
operator|->
name|oid
argument_list|,
operator|&
name|mcp
operator|->
name|oid
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Found a CSA whose key and ID are equal to 		 * those in the CSU Reply 		 */
if|if
condition|(
name|csap
operator|->
name|seq
operator|==
name|mcp
operator|->
name|seq
condition|)
block|{
comment|/* 			 * The queued seq no is equal to the 			 * received seq no--the CSA is acknowledged 			 */
name|UNLINK
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|rxp
operator|->
name|sr_csa
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|csap
operator|->
name|seq
operator|<
name|mcp
operator|->
name|seq
condition|)
block|{
comment|/* 			 * Queued seq no is less than received. 			 * We must dequeue the CSA and send a 			 * CSUS to request the more-up-to-date 			 * cache entry. 			 */
name|UNLINK
argument_list|(
name|mcp
argument_list|,
name|Scsp_csa
argument_list|,
name|msg
operator|->
name|sc_csu_msg
operator|->
name|csu_csa_rec
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|mcp
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_crl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|rxp
operator|->
name|sr_csa
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_csus_rexmt_msg
condition|)
block|{
name|rc
operator|=
name|scsp_send_csus
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
block|}
comment|/* 			 * Queued seq no is greater than 			 * received.  Ignore the received CSAS. 			 */
comment|/* 		 * If the retransmission block is empty, stop the 		 * timer and free it 		 */
if|if
condition|(
operator|!
name|rxp
operator|->
name|sr_csa
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|rxp
operator|->
name|sr_t
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|rxp
argument_list|,
name|Scsp_csu_rexmt
argument_list|,
name|dcsp
operator|->
name|sd_csu_rexmt
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rxp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* for (csap = ... */
block|}
comment|/* for (rxp = ... */
block|}
comment|/* for (mcp = ... */
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 11  * Updated cache entry -- update the summary cache and send a  * CSU Request  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to CSA describing new cache entry  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_11
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|state
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
init|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
comment|/* 	 * Get the state of the CSA 	 */
switch|switch
condition|(
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_pid
condition|)
block|{
case|case
name|SCSP_PROTO_ATMARP
case|:
name|state
operator|=
name|csap
operator|->
name|atmarp_data
operator|->
name|sa_state
expr_stmt|;
break|break;
default|default:
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|<
name|SCSP_ASTATE_NEW
operator|||
name|state
operator|>
name|SCSP_ASTATE_DEL
condition|)
block|{
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Look up the cache summary entry for the CSA 	 */
name|SCSP_LOOKUP
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
operator|&
name|csap
operator|->
name|key
argument_list|,
name|csep
argument_list|)
expr_stmt|;
comment|/* 	 * Process ATMARP entries 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_pid
operator|==
name|SCSP_PROTO_ATMARP
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SCSP_ASTATE_NEW
case|:
case|case
name|SCSP_ASTATE_UPD
case|:
comment|/* 			 * Add the entry if we don't have it already 			 */
if|if
condition|(
operator|!
name|csep
condition|)
block|{
name|csep
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csep
operator|==
name|NULL
condition|)
name|scsp_mem_err
argument_list|(
literal|"scsp_ca_act_11: sizeof(Scsp_cse)"
argument_list|)
expr_stmt|;
name|csep
operator|->
name|sc_key
operator|=
name|csap
operator|->
name|key
expr_stmt|;
name|SCSP_ADD
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Update the cache summary entry 			 */
name|csep
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
break|break;
case|case
name|SCSP_ASTATE_DEL
case|:
comment|/* 			 * Delete any entry, but don't send the 			 * delete to the DCS 			 */
if|if
condition|(
name|csep
condition|)
block|{
name|SCSP_DELETE
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Send the CSA in a CSU Request 	 */
name|csap
operator|->
name|trans_ct
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|scsp_send_csu_req
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 12  * CSUS retransmit timer expired--send a CSUS with any pending CSA  * records  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_12
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|scsp_send_csus
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 13  * CSU retransmit timer fired in Update or Aligned state--  * retransmit CSU Req  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to retransmission block whose timer fired  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_13
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_csu_rexmt
modifier|*
name|rxp
init|=
operator|(
name|Scsp_csu_rexmt
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|csap1
decl_stmt|,
modifier|*
name|next_csap
decl_stmt|;
comment|/* 	 * Unlink and free the retransmit request block 	 */
name|csap
operator|=
name|rxp
operator|->
name|sr_csa
expr_stmt|;
name|UNLINK
argument_list|(
name|rxp
argument_list|,
name|Scsp_csu_rexmt
argument_list|,
name|dcsp
operator|->
name|sd_csu_rexmt
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rxp
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the transmission count for the CSAs in the request 	 */
for|for
control|(
name|csap1
operator|=
name|csap
init|;
name|csap1
condition|;
name|csap1
operator|=
name|next_csap
control|)
block|{
name|next_csap
operator|=
name|csap1
operator|->
name|next
expr_stmt|;
name|csap1
operator|->
name|trans_ct
operator|++
expr_stmt|;
if|if
condition|(
name|csap1
operator|->
name|trans_ct
operator|>=
name|dcsp
operator|->
name|sd_csu_rexmt_max
condition|)
block|{
comment|/* 			 * We've already sent this as many times as 			 * the limit allows.  Drop this CSA. 			 */
name|UNLINK
argument_list|(
name|csap1
argument_list|,
name|Scsp_csa
argument_list|,
name|csap
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Send another CSU Request with the CSA list, if it isn't 	 * empty now 	 */
if|if
condition|(
name|csap
condition|)
block|{
name|rc
operator|=
name|scsp_send_csu_req
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 14  * Updated cache entry in Master/Slave Negotiation, Master, or  * Slave state--add entry to cache and CSA list  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to new cache summary entry  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_14
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
init|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|,
modifier|*
name|csep1
decl_stmt|;
comment|/* 	 * Check to see whether we already have this 	 */
name|SCSP_LOOKUP
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
operator|&
name|csap
operator|->
name|key
argument_list|,
name|csep
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't already have it and it's not being deleted, 	 * build a new cache summary entry 	 */
if|if
condition|(
operator|!
name|csep
operator|&&
operator|!
name|csap
operator|->
name|null
condition|)
block|{
comment|/* 		 * Get memory for a new entry 		 */
name|csep
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csep
operator|==
name|NULL
condition|)
name|scsp_mem_err
argument_list|(
literal|"scsp_ca_act_14: sizeof(Scsp_cse)"
argument_list|)
expr_stmt|;
comment|/* 		 * Fill out the new cache entry 		 */
name|csep
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep
operator|->
name|sc_key
operator|=
name|csap
operator|->
name|key
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
comment|/* 		 * Duplicate the new cache entry 		 */
name|csep1
operator|=
name|scsp_dup_cse
argument_list|(
name|csep
argument_list|)
expr_stmt|;
comment|/* 		 * Add entry to the summary cache and the CSAS list 		 */
name|SCSP_ADD
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|csep1
argument_list|,
name|Scsp_cse
argument_list|,
name|dcsp
operator|->
name|sd_ca_csas
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We already have the entry.  Find it on the CSAS 		 * list. 		 */
for|for
control|(
name|csep1
operator|=
name|dcsp
operator|->
name|sd_ca_csas
init|;
name|csep1
condition|;
name|csep1
operator|=
name|csep1
operator|->
name|sc_next
control|)
block|{
if|if
condition|(
name|scsp_cmp_key
argument_list|(
operator|&
name|csep
operator|->
name|sc_key
argument_list|,
operator|&
name|csep1
operator|->
name|sc_key
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 		 * Update or delete the entry 		 */
if|if
condition|(
name|csap
operator|->
name|null
condition|)
block|{
comment|/* 			 * The null flag is set--delete the entry 			 */
name|SCSP_DELETE
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|csep
argument_list|)
expr_stmt|;
if|if
condition|(
name|csep1
condition|)
block|{
name|UNLINK
argument_list|(
name|csep1
argument_list|,
name|Scsp_cse
argument_list|,
name|dcsp
operator|->
name|sd_ca_csas
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|csep1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Update the entry 			 */
name|csep
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
if|if
condition|(
operator|!
name|csep1
condition|)
block|{
name|csep1
operator|=
name|scsp_dup_cse
argument_list|(
name|csep
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|csep1
argument_list|,
name|Scsp_cse
argument_list|,
name|dcsp
operator|->
name|sd_ca_csas
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|csep1
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep1
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 15  * CA message received in Update Cache state--if we have a saved CA  * message, retransmit it;  otherwise, go to Master/Slave Negotiation  * state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_15
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * If we don't have a saved CA message, or the sequence no. in 	 * the received message isn't right, fall back to Master/Slave 	 * Negotiation state 	 */
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|||
name|msg
operator|->
name|sc_ca
operator|->
name|ca_seq
operator|!=
name|dcsp
operator|->
name|sd_ca_seq
condition|)
block|{
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_NEG
expr_stmt|;
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|scsp_ca_act_01
argument_list|(
name|dcsp
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Retransmit the saved CA message and reset the 		 * CA timer 		 */
name|rc
operator|=
name|scsp_send_msg
argument_list|(
name|dcsp
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|,
name|dcsp
operator|->
name|sd_ca_rexmt_int
argument_list|,
name|scsp_ca_retran_timeout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 16  * Update Response received from client in Update Cache or Aligned  * state.  Move the acknowledged CSA to the acknowledged queue.  If  * the list of CSAs pending acknowledgement is empty, send a CSU  * Reply.  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to message from client  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_16
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|Scsp_if_msg
modifier|*
name|cmsg
init|=
operator|(
name|Scsp_if_msg
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Find the acknowledged CSA 	 */
for|for
control|(
name|csap
operator|=
name|dcsp
operator|->
name|sd_csu_ack_pend
operator|,
name|found
operator|=
literal|0
init|;
name|csap
operator|&&
operator|!
name|found
condition|;
name|csap
operator|=
name|csap
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_pid
condition|)
block|{
case|case
name|SCSP_PROTO_ATMARP
case|:
name|found
operator|=
operator|(
operator|(
name|scsp_cmp_key
argument_list|(
operator|&
name|csap
operator|->
name|key
argument_list|,
operator|&
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_key
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|scsp_cmp_id
argument_list|(
operator|&
name|csap
operator|->
name|oid
argument_list|,
operator|&
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_oid
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Protocol not implemented 			 */
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|scsp_trace_mode
operator|&
name|SCSP_TRACE_CAFSM
condition|)
block|{
name|scsp_trace
argument_list|(
literal|"scsp_ca_act_16: can't find CSA entry for Update Response\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cmsg
operator|->
name|si_rc
operator|==
name|SCSP_RSP_OK
condition|)
block|{
comment|/* 		 * The server accepted the cache entry 		 */
comment|/* 		 * Update SCSP's cache 		 */
name|scsp_update_cache
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
comment|/* 		 * Send this CSA to any other DCSs in the server group 		 */
name|rc
operator|=
name|scsp_propagate_csa
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Move the CSA from the ACK pending queue to the 	 * acknowledged queue 	 */
name|UNLINK
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_csu_ack_pend
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_csu_ack
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dcsp
operator|->
name|sd_csu_ack_pend
condition|)
block|{
comment|/* 		 * ACK pending list is empty--send a CSU Reply 		 */
name|csap
operator|=
name|dcsp
operator|->
name|sd_csu_ack
expr_stmt|;
name|dcsp
operator|->
name|sd_csu_ack
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
literal|0
expr_stmt|;
name|rc
operator|=
name|scsp_send_csu_reply
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 17  * Ignore an event.  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	ignored  *  * Returns:  *	always returns 0  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_17
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 18  * Updated cache entry in Down state--add entry to summary cache  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to new cache summary entry  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_18
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
init|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 	 * Update the cache as appropriate 	 */
name|scsp_update_cache
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CA finite state machine action 19  * Update Response received from client in Master/Slave Negotiation  * state.  Update the cache as appropriate.  *  * Arguments:  *	dcsp	pointer to DCS control block  *	p	pointer to message from client  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_ca_act_19
parameter_list|(
name|dcsp
parameter_list|,
name|p
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|Scsp_if_msg
modifier|*
name|cmsg
init|=
operator|(
name|Scsp_if_msg
operator|*
operator|)
name|p
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Ignore the message if the client rejected the update 	 */
if|if
condition|(
name|cmsg
operator|->
name|si_rc
operator|!=
name|SCSP_RSP_OK
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Create a CSAS from the client's update 	 */
name|csap
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csap
operator|==
name|NULL
condition|)
name|scsp_mem_err
argument_list|(
literal|"scsp_ca_act_19: sizeof(Scsp_csa)"
argument_list|)
expr_stmt|;
name|csap
operator|->
name|hops
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_pid
condition|)
block|{
case|case
name|SCSP_PROTO_ATMARP
case|:
name|csap
operator|->
name|null
operator|=
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_state
operator|==
name|SCSP_ASTATE_DEL
expr_stmt|;
name|csap
operator|->
name|seq
operator|=
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_seq
expr_stmt|;
name|csap
operator|->
name|key
operator|=
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_key
expr_stmt|;
name|csap
operator|->
name|oid
operator|=
name|cmsg
operator|->
name|si_atmarp
operator|.
name|sa_oid
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Update SCSP's cache 	 */
name|scsp_update_cache
argument_list|(
name|dcsp
argument_list|,
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

