begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Edward Wang at The University of California, Berkeley.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ww.h"
end_include

begin_include
include|#
directive|include
file|"tt.h"
end_include

begin_comment
comment|/* special */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_decl_stmt
name|int
name|cc_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cc_trace_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tunable parameters */
end_comment

begin_decl_stmt
name|int
name|cc_reverse
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc_sort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc_chop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc_token_max
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<= TOKEN_MAX */
end_comment

begin_decl_stmt
name|int
name|cc_token_min
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*> tt.tt_put_token_cost */
end_comment

begin_decl_stmt
name|int
name|cc_npass0
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc_npass1
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc_bufsize
init|=
literal|1024
operator|*
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, or 80 * 24 * 2 */
end_comment

begin_decl_stmt
name|int
name|cc_ntoken
init|=
literal|8192
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cc_weight
value|XXX
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|cc_weight
end_ifndef

begin_decl_stmt
name|int
name|cc_weight
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TOKEN_MAX
value|16
end_define

begin_struct
struct|struct
name|cc
block|{
name|char
name|string
index|[
name|TOKEN_MAX
index|]
decl_stmt|;
name|char
name|length
decl_stmt|;
name|char
name|flag
decl_stmt|;
ifndef|#
directive|ifndef
name|cc_weight
name|short
name|weight
decl_stmt|;
endif|#
directive|endif
name|long
name|time
decl_stmt|;
comment|/* time last seen */
name|short
name|bcount
decl_stmt|;
comment|/* count in this buffer */
name|short
name|ccount
decl_stmt|;
comment|/* count in compression */
name|short
name|places
decl_stmt|;
comment|/* places in the buffer */
name|short
name|code
decl_stmt|;
comment|/* token code */
name|struct
name|cc
modifier|*
name|qforw
decl_stmt|,
modifier|*
name|qback
decl_stmt|;
name|struct
name|cc
modifier|*
name|hforw
decl_stmt|,
modifier|*
modifier|*
name|hback
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|short
name|cc_thresholds
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|thresh
parameter_list|(
name|length
parameter_list|)
value|(cc_thresholds[length])
end_define

begin_define
define|#
directive|define
name|threshp
parameter_list|(
name|code
parameter_list|,
name|count
parameter_list|,
name|length
parameter_list|)
define|\
value|((code)>= 0 || (short) (count)>= cc_thresholds[length])
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|cc_weight
end_ifndef

begin_decl_stmt
name|short
name|cc_wthresholds
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|wthresh
parameter_list|(
name|length
parameter_list|)
value|(cc_wthresholds[length])
end_define

begin_define
define|#
directive|define
name|wthreshp
parameter_list|(
name|weight
parameter_list|,
name|length
parameter_list|)
value|((short) (weight)>= cc_wthresholds[length])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|wthreshp
parameter_list|(
name|weight
parameter_list|,
name|length
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|cc_weight
end_ifndef

begin_decl_stmt
name|short
name|cc_wlimits
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|wlimit
parameter_list|(
name|length
parameter_list|)
value|(cc_wlimits[length])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|put_token_score
parameter_list|(
name|length
parameter_list|)
value|((length) - tt.tt_put_token_cost)
end_define

begin_decl_stmt
name|int
name|cc_score_adjustments
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, 8> max of cc_thresholds */
end_comment

begin_define
define|#
directive|define
name|score_adjust
parameter_list|(
name|score
parameter_list|,
name|p
parameter_list|)
define|\
value|do { \ 		int length = (p)->length; \ 		int ccount = (p)->ccount; \ 		if (threshp((p)->code, ccount, length) || \ 		    wthreshp((p)->weight, length))
comment|/* XXX */
value|\ 			(score) -= length - tt.tt_put_token_cost; \ 		else \ 			(score) += cc_score_adjustments[length][ccount]; \ 	} while (0)
end_define

begin_decl_stmt
name|int
name|cc_initial_scores
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, 8> max of cc_thresholds */
end_comment

begin_decl_stmt
name|struct
name|cc
name|cc_q0a
decl_stmt|,
name|cc_q0b
decl_stmt|,
name|cc_q1a
decl_stmt|,
name|cc_q1b
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|qinsert
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
define|\
value|do { \ 		register struct cc *forw = (p1)->qforw; \ 		register struct cc *back = (p1)->qback; \ 		back->qforw = forw; \ 		forw->qback = back; \ 		forw = (p2)->qforw; \ 		(p1)->qforw = forw; \ 		forw->qback = (p1); \ 		(p2)->qforw = (p1); \ 		(p1)->qback = (p2); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|qinsertq
parameter_list|(
name|q
parameter_list|,
name|p
parameter_list|)
define|\
value|((q)->qforw == (q) ? 0 : \ 	 ((q)->qback->qforw = (p)->qforw, \ 	  (p)->qforw->qback = (q)->qback, \ 	  (q)->qforw->qback = (p), \ 	  (p)->qforw = (q)->qforw, \ 	  (q)->qforw = (q), \ 	  (q)->qback = (q)))
end_define

begin_define
define|#
directive|define
name|H
value|(14)
end_define

begin_define
define|#
directive|define
name|HSIZE
value|(1<< H)
end_define

begin_define
define|#
directive|define
name|hash
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((((h)>> H - 8 | (h)<< 8) ^ (c))& HSIZE - 1)
end_define

begin_decl_stmt
name|char
modifier|*
name|cc_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|cc_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the output array */
end_comment

begin_decl_stmt
name|short
modifier|*
name|cc_places
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|cc_hashcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for computing hashcodes */
end_comment

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|cc_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the hash table */
end_comment

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|cc_tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds all the active tokens */
end_comment

begin_struct
struct|struct
name|cc_undo
block|{
name|struct
name|cc
modifier|*
modifier|*
name|pos
decl_stmt|;
name|struct
name|cc
modifier|*
name|val
decl_stmt|;
block|}
modifier|*
name|cc_undo
struct|;
end_struct

begin_decl_stmt
name|long
name|cc_time
decl_stmt|,
name|cc_time0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cc_tt_ob
decl_stmt|,
modifier|*
name|cc_tt_obe
decl_stmt|;
end_decl_stmt

begin_macro
name|ccinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_max
operator|>
name|cc_token_max
condition|)
name|tt
operator|.
name|tt_token_max
operator|=
name|cc_token_max
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_min
operator|<
name|cc_token_min
condition|)
name|tt
operator|.
name|tt_token_min
operator|=
name|cc_token_min
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_min
operator|>
name|tt
operator|.
name|tt_token_max
condition|)
block|{
name|tt
operator|.
name|tt_ntoken
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tt
operator|.
name|tt_ntoken
operator|>
name|cc_ntoken
operator|/
literal|2
condition|)
comment|/* not likely */
name|tt
operator|.
name|tt_ntoken
operator|=
name|cc_ntoken
operator|/
literal|2
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|(sizeof (x) / sizeof *(x))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|C
argument_list|(
name|cc_thresholds
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|h
init|=
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
decl_stmt|;
if|if
condition|(
name|h
operator|>
literal|0
condition|)
name|cc_thresholds
index|[
name|i
index|]
operator|=
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
literal|1
operator|+
name|h
operator|-
literal|1
operator|)
operator|/
name|h
operator|+
literal|1
expr_stmt|;
else|else
name|cc_thresholds
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|C
argument_list|(
name|cc_score_adjustments
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|cc_thresholds
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|C
argument_list|(
operator|*
name|cc_score_adjustments
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|t
condition|)
name|cc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|<
name|t
operator|-
literal|1
condition|)
name|cc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* 				 * cost now is 				 *	length * (ccount + 1)		a 				 * cost before was 				 *	set-token-cost + length + 				 *		ccount * put-token-cost	b 				 * the score adjustment is (b - a) 				 */
name|cc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|tt
operator|.
name|tt_set_token_cost
operator|+
name|i
operator|+
name|j
operator|*
name|tt
operator|.
name|tt_put_token_cost
operator|-
name|i
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|t
condition|)
name|cc_initial_scores
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* 				 * - (set-token-cost + 				 *	(length - put-token-cost) - 				 *	(length - put-token-cost) * ccount) 				 */
name|cc_initial_scores
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|-
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|*
name|j
operator|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|cc_weight
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|C
argument_list|(
name|cc_wthresholds
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cc_wthresholds
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|/
name|i
operator|+
name|i
operator|/
literal|5
operator|+
literal|1
operator|)
operator|*
name|cc_weight
operator|+
literal|1
expr_stmt|;
name|cc_wlimits
index|[
name|i
index|]
operator|=
name|cc_wthresholds
index|[
name|i
index|]
operator|+
name|cc_weight
expr_stmt|;
block|}
endif|#
directive|endif
undef|#
directive|undef
name|C
if|if
condition|(
operator|(
name|cc_output
operator|=
operator|(
expr|struct
name|cc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_bufsize
operator|*
sizeof|sizeof
expr|*
name|cc_output
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|cc_hashcodes
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_bufsize
operator|*
sizeof|sizeof
expr|*
name|cc_hashcodes
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|cc_htab
operator|=
operator|(
expr|struct
name|cc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|HSIZE
operator|*
sizeof|sizeof
expr|*
name|cc_htab
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|cc_tokens
operator|=
operator|(
expr|struct
name|cc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|cc_ntoken
operator|+
name|tt
operator|.
name|tt_token_max
operator|-
name|tt
operator|.
name|tt_token_min
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|cc_tokens
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|cc_undo
operator|=
operator|(
expr|struct
name|cc_undo
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_bufsize
operator|*
sizeof|sizeof
expr|*
name|cc_undo
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|i
operator|=
name|tt
operator|.
name|tt_token_min
init|;
name|i
operator|<=
name|tt
operator|.
name|tt_token_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cc_places
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_bufsize
operator|*
sizeof|sizeof
expr|*
operator|*
name|cc_places
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|cc_q0a
operator|.
name|qforw
operator|=
name|cc_q0a
operator|.
name|qback
operator|=
operator|&
name|cc_q0a
expr_stmt|;
name|cc_q0b
operator|.
name|qforw
operator|=
name|cc_q0b
operator|.
name|qback
operator|=
operator|&
name|cc_q0b
expr_stmt|;
name|cc_q1a
operator|.
name|qforw
operator|=
name|cc_q1a
operator|.
name|qback
operator|=
operator|&
name|cc_q1a
expr_stmt|;
name|cc_q1b
operator|.
name|qforw
operator|=
name|cc_q1b
operator|.
name|qback
operator|=
operator|&
name|cc_q1b
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|cc
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_ntoken
operator|*
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tt
operator|.
name|tt_ntoken
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|code
operator|=
name|i
expr_stmt|;
name|p
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|qback
operator|=
name|cc_q0a
operator|.
name|qback
expr_stmt|;
name|p
operator|->
name|qforw
operator|=
operator|&
name|cc_q0a
expr_stmt|;
name|p
operator|->
name|qback
operator|->
name|qforw
operator|=
name|p
expr_stmt|;
name|cc_q0a
operator|.
name|qback
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|cc_ntoken
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|code
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|qback
operator|=
name|cc_q1a
operator|.
name|qback
expr_stmt|;
name|p
operator|->
name|qforw
operator|=
operator|&
name|cc_q1a
expr_stmt|;
name|p
operator|->
name|qback
operator|->
name|qforw
operator|=
name|p
expr_stmt|;
name|cc_q1a
operator|.
name|qback
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|cc_tt_ob
operator|=
name|tt_ob
expr_stmt|;
name|cc_tt_obe
operator|=
name|tt_obe
expr_stmt|;
if|if
condition|(
operator|(
name|cc_buffer
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|cc_bufsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
return|return
literal|0
return|;
name|nomem
label|:
name|wwerrno
operator|=
name|WWE_NOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|ccstart
argument_list|()
end_macro

begin_block
block|{
name|int
name|ccflush
parameter_list|()
function_decl|;
name|ttflush
argument_list|()
expr_stmt|;
name|tt_obp
operator|=
name|tt_ob
operator|=
name|cc_buffer
expr_stmt|;
name|tt_obe
operator|=
name|tt_ob
operator|+
name|cc_bufsize
expr_stmt|;
name|tt
operator|.
name|tt_flush
operator|=
name|ccflush
expr_stmt|;
if|if
condition|(
name|cc_trace
condition|)
block|{
name|cc_trace_fp
operator|=
name|fopen
argument_list|(
literal|"window-trace"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|cc_trace_fp
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ccreset
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ccreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cc_htab
argument_list|,
name|HSIZE
operator|*
sizeof|sizeof
expr|*
name|cc_htab
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cc_q0a
operator|.
name|qforw
init|;
name|p
operator|!=
operator|&
name|cc_q0a
condition|;
name|p
operator|=
name|p
operator|->
name|qforw
control|)
name|p
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cc_q1a
operator|.
name|qforw
init|;
name|p
operator|!=
operator|&
name|cc_q1a
condition|;
name|p
operator|=
name|p
operator|->
name|qforw
control|)
name|p
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|ccend
argument_list|()
end_macro

begin_block
block|{
name|ttflush
argument_list|()
expr_stmt|;
name|tt_obp
operator|=
name|tt_ob
operator|=
name|cc_tt_ob
expr_stmt|;
name|tt_obe
operator|=
name|cc_tt_obe
expr_stmt|;
name|tt
operator|.
name|tt_flush
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_trace_fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cc_trace_fp
argument_list|)
expr_stmt|;
name|cc_trace_fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ccflush
argument_list|()
end_macro

begin_block
block|{
name|int
name|bufsize
init|=
name|tt_obp
operator|-
name|tt_ob
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tt_ob
operator|!=
name|cc_buffer
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc_trace_fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|tt_ob
argument_list|,
literal|1
argument_list|,
name|bufsize
argument_list|,
name|cc_trace_fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|-
literal|1
argument_list|,
name|cc_trace_fp
argument_list|)
expr_stmt|;
block|}
name|tt
operator|.
name|tt_flush
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_compress
call|)
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|<
name|tt
operator|.
name|tt_token_min
condition|)
block|{
name|ttflush
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tt_obp
operator|=
name|tt_ob
operator|=
name|cc_tt_ob
expr_stmt|;
name|tt_obe
operator|=
name|cc_tt_obe
expr_stmt|;
name|cc_time0
operator|=
name|cc_time
expr_stmt|;
name|cc_time
operator|+=
name|bufsize
expr_stmt|;
name|n
operator|=
name|cc_sweep_phase
argument_list|(
name|cc_buffer
argument_list|,
name|bufsize
argument_list|,
name|cc_tokens
argument_list|)
expr_stmt|;
name|cc_compress_phase
argument_list|(
name|cc_output
argument_list|,
name|bufsize
argument_list|,
name|cc_tokens
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cc_output_phase
argument_list|(
name|cc_buffer
argument_list|,
name|cc_output
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ttflush
argument_list|()
expr_stmt|;
name|tt_obp
operator|=
name|tt_ob
operator|=
name|cc_buffer
expr_stmt|;
name|tt_obe
operator|=
name|cc_buffer
operator|+
name|cc_bufsize
expr_stmt|;
name|out
label|:
call|(
modifier|*
name|tt
operator|.
name|tt_compress
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tt
operator|.
name|tt_flush
operator|=
name|ccflush
expr_stmt|;
block|}
end_block

begin_macro
name|cc_sweep_phase
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
specifier|register
name|i
operator|,
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|int
name|nn
decl_stmt|,
name|ii
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Sweep:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc_sweep0
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|tt
operator|.
name|tt_token_min
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|ntoken_stat
operator|=
literal|0
expr_stmt|;
name|nn
operator|=
literal|0
expr_stmt|;
name|ii
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|tt
operator|.
name|tt_token_min
init|;
name|i
operator|<=
name|tt
operator|.
name|tt_token_max
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ii
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"\n      "
argument_list|)
expr_stmt|;
name|ii
operator|=
literal|0
expr_stmt|;
block|}
name|ii
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" (%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|n
operator|=
name|cc_sweep
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nn
operator|+=
name|n
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|qinsertq
argument_list|(
operator|&
name|cc_q1b
argument_list|,
operator|&
name|cc_q1a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n       %d tokens, %d candidates\n"
argument_list|,
name|ntoken_stat
argument_list|,
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|pp
operator|-
name|tokens
return|;
block|}
end_block

begin_macro
name|cc_sweep0
argument_list|(
argument|buffer
argument_list|,
argument|n
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|short
modifier|*
name|hc
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|short
name|c
decl_stmt|;
specifier|register
name|short
name|pc
init|=
name|tt
operator|.
name|tt_padc
decl_stmt|;
comment|/* n and length are at least 1 */
name|p
operator|=
name|buffer
operator|++
expr_stmt|;
name|hc
operator|=
name|cc_hashcodes
expr_stmt|;
name|i
operator|=
name|n
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|hc
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|pc
condition|)
name|hc
index|[
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
while|while
condition|(
operator|--
name|length
condition|)
block|{
name|p
operator|=
name|buffer
operator|++
expr_stmt|;
name|hc
operator|=
name|cc_hashcodes
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|--
init|;
operator|--
name|i
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|pc
operator|||
operator|*
name|hc
operator|<
literal|0
condition|)
name|c
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|hash
argument_list|(
operator|*
name|hc
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|*
name|hc
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cc_sweep
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|short
modifier|*
name|hc
decl_stmt|;
name|short
modifier|*
name|places
init|=
name|cc_places
index|[
name|length
index|]
decl_stmt|;
name|struct
name|cc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
name|short
name|threshold
init|=
name|thresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|cc_weight
name|short
name|wthreshold
init|=
name|wthresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|short
name|limit
init|=
name|wlimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|time
decl_stmt|;
name|short
name|pc
init|=
name|tt
operator|.
name|tt_padc
decl_stmt|;
name|i
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|bufsize
operator|-=
name|i
expr_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|i
expr_stmt|;
name|hc
operator|=
name|cc_hashcodes
expr_stmt|;
name|time
operator|=
name|cc_time0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
condition|;
name|i
operator|++
operator|,
name|time
operator|++
control|)
block|{
name|struct
name|cc
modifier|*
modifier|*
name|h
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
name|hc1
init|=
name|hc
decl_stmt|;
specifier|register
name|short
name|c
init|=
operator|*
name|cp
operator|++
decl_stmt|;
specifier|register
name|short
name|hh
decl_stmt|;
if|if
condition|(
operator|(
name|hh
operator|=
operator|*
name|hc1
operator|)
operator|<
literal|0
operator|||
name|c
operator|==
name|pc
condition|)
block|{
operator|*
name|hc1
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|hc
operator|=
name|hc1
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|cc_htab
operator|+
operator|(
operator|*
name|hc1
operator|++
operator|=
name|hash
argument_list|(
name|hh
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
name|hc
operator|=
name|hc1
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
operator|*
name|h
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|hforw
control|)
if|if
condition|(
name|p
operator|->
name|length
operator|==
operator|(
name|char
operator|)
name|length
condition|)
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|p
operator|->
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|cp
operator|-
name|length
decl_stmt|;
specifier|register
name|n
operator|=
name|length
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
goto|goto
name|fail
goto|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
break|break;
name|fail
label|:
empty_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|cc_q1a
operator|.
name|qback
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|cc_q1a
operator|||
name|p
operator|->
name|time
operator|>=
name|cc_time0
operator|&&
name|p
operator|->
name|length
operator|==
operator|(
name|char
operator|)
name|length
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hback
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
operator|*
name|p
operator|->
name|hback
operator|=
name|p
operator|->
name|hforw
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|hforw
operator|->
name|hback
operator|=
name|p
operator|->
name|hback
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|p
operator|->
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|cp
operator|-
name|length
decl_stmt|;
specifier|register
name|n
operator|=
name|length
expr_stmt|;
do|do
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
name|p
operator|->
name|length
operator|=
name|length
expr_stmt|;
ifndef|#
directive|ifndef
name|cc_weight
name|p
operator|->
name|weight
operator|=
name|cc_weight
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|hforw
operator|=
operator|*
name|h
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|hforw
operator|->
name|hback
operator|=
operator|&
name|p
operator|->
name|hforw
expr_stmt|;
operator|*
name|h
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|hback
operator|=
name|h
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q1a
argument_list|)
expr_stmt|;
name|places
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|ntoken_stat
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|time
operator|<
name|cc_time0
condition|)
block|{
ifndef|#
directive|ifndef
name|cc_weight
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|p
operator|->
name|time
operator|-
name|time
operator|)
operator|<
literal|0
condition|)
name|p
operator|->
name|weight
operator|=
name|cc_weight
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|cc_weight
operator|)
operator|>
name|limit
condition|)
name|p
operator|->
name|weight
operator|=
name|limit
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
block|}
elseif|else
ifndef|#
directive|ifndef
name|cc_weight
if|if
condition|(
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q1b
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q1a
argument_list|)
expr_stmt|;
block|}
name|places
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|ntoken_stat
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|time
operator|+
name|length
operator|>
name|time
condition|)
block|{
comment|/* 			 * overlapping token, don't count as two and 			 * don't update time, but do adjust weight to offset 			 * the difference 			 */
ifndef|#
directive|ifndef
name|cc_weight
if|if
condition|(
name|cc_weight
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|p
operator|->
name|weight
operator|+=
name|time
operator|-
name|p
operator|->
name|time
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q1b
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|places
index|[
name|i
index|]
operator|=
name|p
operator|->
name|places
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|cc_weight
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|p
operator|->
name|time
operator|-
name|time
operator|)
operator|<
literal|0
condition|)
name|p
operator|->
name|weight
operator|=
name|cc_weight
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|cc_weight
operator|)
operator|>
name|limit
condition|)
name|p
operator|->
name|weight
operator|=
name|limit
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
comment|/* code must be< 0 if flag false here */
operator|(
name|p
operator|->
name|bcount
operator|>=
name|threshold
ifndef|#
directive|ifndef
name|cc_weight
operator|||
name|p
operator|->
name|weight
operator|>=
name|wthreshold
endif|#
directive|endif
operator|)
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q1b
argument_list|)
expr_stmt|;
block|}
name|places
index|[
name|i
index|]
operator|=
name|p
operator|->
name|places
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|pp
operator|-
name|tokens
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_reverse
condition|)
name|cc_sweep_reverse
argument_list|(
name|tokens
argument_list|,
name|places
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc_sort
operator|&&
name|i
operator|>
literal|1
condition|)
block|{
name|int
name|cc_token_compare
parameter_list|()
function_decl|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tokens
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|tokens
argument_list|,
name|cc_token_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_chop
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|i
operator|*
name|cc_chop
operator|/
literal|100
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_block

begin_expr_stmt
name|cc_sweep_reverse
argument_list|(
name|pp
argument_list|,
name|places
argument_list|)
specifier|register
expr|struct
name|cc
operator|*
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
name|places
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|;
specifier|register
name|short
name|front
decl_stmt|,
name|back
decl_stmt|,
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|back
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|places
expr_stmt|;
comment|/* the list is never empty */
do|do
block|{
name|front
operator|=
name|places
index|[
name|t
index|]
expr_stmt|;
name|places
index|[
name|t
index|]
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|t
operator|=
name|front
operator|)
operator|>=
literal|0
condition|)
do|;
name|p
operator|->
name|places
operator|=
name|back
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cc_compress_phase
argument_list|(
argument|output
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|,
argument|ntoken
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output
argument_list|,
name|bufsize
operator|*
sizeof|sizeof
expr|*
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc_npass0
condition|;
name|i
operator|++
control|)
name|cc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc_npass1
condition|;
name|i
operator|++
control|)
name|cc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc_compress_cleanup
argument_list|(
name|output
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|cc
operator|*
operator|*
name|output
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|nt
init|=
literal|0
decl_stmt|,
name|cc
init|=
literal|0
decl_stmt|,
name|nc
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Compress:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pp
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
name|pp
operator|<
name|tokens
operator|+
name|ntoken
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|ntoken_stat
operator|=
literal|0
expr_stmt|;
name|ccount_stat
operator|=
literal|0
expr_stmt|;
name|ncover_stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n         "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" (%d"
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pp
operator|+=
name|cc_compress
argument_list|(
name|output
argument_list|,
name|pp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %dt %du %dc)"
argument_list|,
name|ntoken_stat
argument_list|,
name|ccount_stat
argument_list|,
name|ncover_stat
argument_list|)
expr_stmt|;
name|nt
operator|+=
name|ntoken_stat
expr_stmt|;
name|cc
operator|+=
name|ccount_stat
expr_stmt|;
name|nc
operator|+=
name|ncover_stat
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n   total: (%dt %du %dc)\n"
argument_list|,
name|nt
argument_list|,
name|cc
argument_list|,
name|nc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|cc_compress_cleanup
argument_list|(
name|output
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|cc
operator|*
operator|*
name|output
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|end
decl_stmt|;
comment|/* the previous output phase may have been interrupted */
name|qinsertq
argument_list|(
operator|&
name|cc_q0b
argument_list|,
operator|&
name|cc_q0a
argument_list|)
expr_stmt|;
for|for
control|(
name|end
operator|=
name|output
operator|+
name|bufsize
init|;
name|output
operator|<
name|end
condition|;
control|)
block|{
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|;
specifier|register
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|output
operator|)
operator|==
literal|0
condition|)
block|{
name|output
operator|++
expr_stmt|;
continue|continue;
block|}
name|length
operator|=
name|p
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
condition|)
block|{ 		}
elseif|else
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q0b
argument_list|)
expr_stmt|;
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|ccount
operator|>=
name|thresh
argument_list|(
name|length
argument_list|)
ifndef|#
directive|ifndef
name|cc_weight
operator|||
name|wthreshp
argument_list|(
name|p
operator|->
name|weight
argument_list|,
name|length
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
operator|*
name|output
operator|=
literal|0
expr_stmt|;
block|}
name|output
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cc_compress
argument_list|(
argument|output
argument_list|,
argument|tokens
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
specifier|register
name|struct
name|cc
modifier|*
name|p
init|=
operator|*
name|pp
operator|++
decl_stmt|;
name|int
name|length
init|=
name|p
operator|->
name|length
decl_stmt|;
name|int
name|threshold
init|=
name|thresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|cc_weight
name|short
name|wthreshold
init|=
name|wthresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|short
modifier|*
name|places
init|=
name|cc_places
index|[
name|length
index|]
decl_stmt|;
name|int
modifier|*
name|initial_scores
init|=
name|cc_initial_scores
index|[
name|length
index|]
decl_stmt|;
name|int
name|initial_score0
init|=
name|put_token_score
argument_list|(
name|length
argument_list|)
decl_stmt|;
do|do
block|{
name|int
name|score
decl_stmt|;
specifier|register
name|struct
name|cc_undo
modifier|*
name|undop
decl_stmt|;
name|int
name|ccount
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|int
name|ncover
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|ccount
operator|=
name|p
operator|->
name|ccount
expr_stmt|;
if|if
condition|(
operator|(
name|short
operator|)
name|ccount
operator|>=
name|p
operator|->
name|bcount
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
operator|||
name|ccount
operator|>=
name|threshold
condition|)
name|score
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|cc_weight
elseif|else
if|if
condition|(
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
comment|/* allow one fewer match than normal */
comment|/* XXX, should adjust for ccount */
name|score
operator|=
operator|-
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
endif|#
directive|endif
else|else
name|score
operator|=
name|initial_scores
index|[
name|ccount
index|]
expr_stmt|;
name|undop
operator|=
name|cc_undo
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|ncover
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|p
operator|->
name|places
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|places
index|[
name|i
index|]
control|)
block|{
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|cc
modifier|*
name|x
decl_stmt|;
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|ip
init|=
name|output
operator|+
name|i
decl_stmt|;
specifier|register
name|score0
operator|=
name|initial_score0
expr_stmt|;
name|struct
name|cc
modifier|*
modifier|*
name|iip
init|=
name|ip
operator|+
name|length
decl_stmt|;
name|struct
name|cc_undo
modifier|*
name|undop1
init|=
name|undop
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
operator|*
operator|(
name|jp
operator|=
name|ip
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|z
goto|;
while|while
condition|(
operator|--
name|jp
operator|>=
name|output
condition|)
if|if
condition|(
operator|(
name|x
operator|=
operator|*
name|jp
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|jp
operator|+
name|x
operator|->
name|length
operator|>
name|ip
condition|)
goto|goto
name|z
goto|;
break|break;
block|}
name|jp
operator|=
name|ip
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|jp
operator|<
name|iip
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
operator|*
name|jp
operator|)
operator|==
literal|0
condition|)
block|{
name|jp
operator|++
expr_stmt|;
continue|continue;
block|}
name|z
label|:
if|if
condition|(
name|x
operator|==
name|p
condition|)
goto|goto
name|undo
goto|;
ifdef|#
directive|ifdef
name|STATS
name|ncover
operator|++
expr_stmt|;
endif|#
directive|endif
name|undop
operator|->
name|pos
operator|=
name|jp
expr_stmt|;
name|undop
operator|->
name|val
operator|=
name|x
expr_stmt|;
name|undop
operator|++
expr_stmt|;
operator|*
name|jp
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|ccount
operator|--
expr_stmt|;
name|score_adjust
argument_list|(
name|score0
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|score0
operator|<
literal|0
operator|&&
name|flag
condition|)
goto|goto
name|undo
goto|;
name|jp
operator|+=
name|x
operator|->
name|length
expr_stmt|;
block|}
name|undop
operator|->
name|pos
operator|=
name|ip
expr_stmt|;
name|undop
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|undop
operator|++
expr_stmt|;
operator|*
name|ip
operator|=
name|p
expr_stmt|;
name|ccount
operator|++
expr_stmt|;
name|score
operator|+=
name|score0
expr_stmt|;
continue|continue;
name|undo
label|:
while|while
condition|(
operator|--
name|undop
operator|>=
name|undop1
condition|)
if|if
condition|(
operator|*
name|undop
operator|->
name|pos
operator|=
name|x
operator|=
name|undop
operator|->
name|val
condition|)
name|x
operator|->
name|ccount
operator|++
expr_stmt|;
name|undop
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
name|ccount_stat
operator|+=
name|ccount
operator|-
name|p
operator|->
name|ccount
expr_stmt|;
name|ntoken_stat
operator|++
expr_stmt|;
name|ncover_stat
operator|+=
name|ncover
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|ccount
operator|=
name|ccount
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|cc_undo
modifier|*
name|u
init|=
name|cc_undo
decl_stmt|;
while|while
condition|(
operator|--
name|undop
operator|>=
name|u
condition|)
block|{
specifier|register
name|struct
name|cc
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|*
name|undop
operator|->
name|pos
operator|=
name|x
operator|=
name|undop
operator|->
name|val
condition|)
name|x
operator|->
name|ccount
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|++
operator|)
operator|!=
literal|0
condition|)
do|;
return|return
name|pp
operator|-
name|tokens
return|;
block|}
end_block

begin_expr_stmt
name|cc_output_phase
argument_list|(
name|buffer
argument_list|,
name|output
argument_list|,
name|bufsize
argument_list|)
specifier|register
name|char
operator|*
name|buffer
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|cc
modifier|*
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|bufsize
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|cc
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|output
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|ttputc
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q0a
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_put_token
call|)
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokuse
operator|++
expr_stmt|;
name|wwntoksave
operator|+=
name|put_token_score
argument_list|(
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p1
operator|=
name|cc_q0a
operator|.
name|qback
operator|)
operator|!=
operator|&
name|cc_q0a
condition|)
block|{
name|p
operator|->
name|code
operator|=
name|p1
operator|->
name|code
expr_stmt|;
name|p1
operator|->
name|code
operator|=
operator|-
literal|1
expr_stmt|;
name|qinsert
argument_list|(
name|p1
argument_list|,
operator|&
name|cc_q1a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q0a
argument_list|)
expr_stmt|;
else|else
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|cc_q0b
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_set_token
call|)
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokdef
operator|++
expr_stmt|;
name|wwntoksave
operator|-=
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|ccount
operator|--
expr_stmt|;
name|ttwrite
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokbad
operator|++
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
block|}
name|wwntokc
operator|+=
name|bufsize
expr_stmt|;
block|}
end_block

begin_macro
name|cc_token_compare
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cc
modifier|*
modifier|*
name|p1
decl_stmt|,
modifier|*
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|*
name|p2
operator|)
operator|->
name|bcount
operator|-
operator|(
operator|*
name|p1
operator|)
operator|->
name|bcount
return|;
block|}
end_block

end_unit

