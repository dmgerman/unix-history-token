begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2001, PADL Software Pty Ltd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of PADL Software  nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY PADL SOFTWARE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL PADL SOFTWARE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hdb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: hdb-ldap.c,v 1.10.4.1 2003/09/18 20:49:09 lha Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENLDAP
end_ifdef

begin_include
include|#
directive|include
file|<lber.h>
end_include

begin_include
include|#
directive|include
file|<ldap.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_function_decl
specifier|static
name|krb5_error_code
name|LDAP__connect
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|krb5_error_code
name|LDAP_message2entry
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|LDAPMessage
modifier|*
name|msg
parameter_list|,
name|hdb_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|krb5kdcentry_attrs
index|[]
init|=
block|{
literal|"krb5PrincipalName"
block|,
literal|"cn"
block|,
literal|"krb5PrincipalRealm"
block|,
literal|"krb5KeyVersionNumber"
block|,
literal|"krb5Key"
block|,
literal|"krb5ValidStart"
block|,
literal|"krb5ValidEnd"
block|,
literal|"krb5PasswordEnd"
block|,
literal|"krb5MaxLife"
block|,
literal|"krb5MaxRenew"
block|,
literal|"krb5KDCFlags"
block|,
literal|"krb5EncryptionType"
block|,
literal|"modifiersName"
block|,
literal|"modifyTimestamp"
block|,
literal|"creatorsName"
block|,
literal|"createTimestamp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|krb5principal_attrs
index|[]
init|=
block|{
literal|"krb5PrincipalName"
block|,
literal|"cn"
block|,
literal|"krb5PrincipalRealm"
block|,
literal|"modifiersName"
block|,
literal|"modifyTimestamp"
block|,
literal|"creatorsName"
block|,
literal|"createTimestamp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|krb5_error_code
name|LDAP__setmod
parameter_list|(
name|LDAPMod
modifier|*
modifier|*
modifier|*
name|modlist
parameter_list|,
name|int
name|modop
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|int
modifier|*
name|pIndex
parameter_list|)
block|{
name|int
name|cMods
decl_stmt|;
if|if
condition|(
operator|*
name|modlist
operator|==
name|NULL
condition|)
block|{
operator|*
name|modlist
operator|=
operator|(
name|LDAPMod
operator|*
operator|*
operator|)
name|ber_memcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|LDAPMod
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|modlist
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
block|}
for|for
control|(
name|cMods
operator|=
literal|0
init|;
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|!=
name|NULL
condition|;
name|cMods
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|->
name|mod_op
operator|==
name|modop
operator|&&
name|strcasecmp
argument_list|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|->
name|mod_type
argument_list|,
name|attribute
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|pIndex
operator|=
name|cMods
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|==
name|NULL
condition|)
block|{
name|LDAPMod
modifier|*
name|mod
decl_stmt|;
operator|*
name|modlist
operator|=
operator|(
name|LDAPMod
operator|*
operator|*
operator|)
name|ber_memrealloc
argument_list|(
operator|*
name|modlist
argument_list|,
operator|(
name|cMods
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|LDAPMod
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|modlist
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|=
operator|(
name|LDAPMod
operator|*
operator|)
name|ber_memalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LDAPMod
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|mod
operator|=
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
expr_stmt|;
name|mod
operator|->
name|mod_op
operator|=
name|modop
expr_stmt|;
name|mod
operator|->
name|mod_type
operator|=
name|ber_strdup
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|->
name|mod_type
operator|==
name|NULL
condition|)
block|{
name|ber_memfree
argument_list|(
name|mod
argument_list|)
expr_stmt|;
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|modop
operator|&
name|LDAP_MOD_BVALUES
condition|)
block|{
name|mod
operator|->
name|mod_bvalues
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mod
operator|->
name|mod_values
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_addmod_len
parameter_list|(
name|LDAPMod
modifier|*
modifier|*
modifier|*
name|modlist
parameter_list|,
name|int
name|modop
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|unsigned
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|cMods
decl_stmt|,
name|cValues
init|=
literal|0
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|LDAP__setmod
argument_list|(
name|modlist
argument_list|,
name|modop
operator||
name|LDAP_MOD_BVALUES
argument_list|,
name|attribute
argument_list|,
operator|&
name|cMods
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|struct
name|berval
modifier|*
name|bValue
decl_stmt|;
name|struct
name|berval
modifier|*
modifier|*
modifier|*
name|pbValues
init|=
operator|&
operator|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|->
name|mod_bvalues
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|pbValues
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cValues
operator|=
literal|0
init|;
operator|(
operator|*
name|pbValues
operator|)
index|[
name|cValues
index|]
operator|!=
name|NULL
condition|;
name|cValues
operator|++
control|)
empty_stmt|;
operator|*
name|pbValues
operator|=
operator|(
expr|struct
name|berval
operator|*
operator|*
operator|)
name|ber_memrealloc
argument_list|(
operator|*
name|pbValues
argument_list|,
operator|(
name|cValues
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|berval
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pbValues
operator|=
operator|(
expr|struct
name|berval
operator|*
operator|*
operator|)
name|ber_memalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|berval
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pbValues
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|pbValues
operator|)
index|[
name|cValues
index|]
operator|=
operator|(
expr|struct
name|berval
operator|*
operator|)
name|ber_memalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|berval
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|pbValues
operator|)
index|[
name|cValues
index|]
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|bValue
operator|=
operator|(
operator|*
name|pbValues
operator|)
index|[
name|cValues
index|]
expr_stmt|;
name|bValue
operator|->
name|bv_val
operator|=
name|value
expr_stmt|;
name|bValue
operator|->
name|bv_len
operator|=
name|len
expr_stmt|;
operator|(
operator|*
name|pbValues
operator|)
index|[
name|cValues
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_addmod
parameter_list|(
name|LDAPMod
modifier|*
modifier|*
modifier|*
name|modlist
parameter_list|,
name|int
name|modop
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|cMods
decl_stmt|,
name|cValues
init|=
literal|0
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|LDAP__setmod
argument_list|(
name|modlist
argument_list|,
name|modop
argument_list|,
name|attribute
argument_list|,
operator|&
name|cMods
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
modifier|*
name|pValues
init|=
operator|&
operator|(
operator|(
operator|*
name|modlist
operator|)
index|[
name|cMods
index|]
operator|->
name|mod_values
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|pValues
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cValues
operator|=
literal|0
init|;
operator|(
operator|*
name|pValues
operator|)
index|[
name|cValues
index|]
operator|!=
name|NULL
condition|;
name|cValues
operator|++
control|)
empty_stmt|;
operator|*
name|pValues
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ber_memrealloc
argument_list|(
operator|*
name|pValues
argument_list|,
operator|(
name|cValues
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pValues
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ber_memalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pValues
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|pValues
operator|)
index|[
name|cValues
index|]
operator|=
name|ber_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pValues
operator|)
index|[
name|cValues
index|]
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|pValues
operator|)
index|[
name|cValues
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_addmod_generalized_time
parameter_list|(
name|LDAPMod
modifier|*
modifier|*
modifier|*
name|mods
parameter_list|,
name|int
name|modop
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|KerberosTime
modifier|*
name|time
parameter_list|)
block|{
name|char
name|buf
index|[
literal|22
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
comment|/* XXX not threadsafe */
name|tm
operator|=
name|gmtime
argument_list|(
name|time
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%Y%m%d%H%M%SZ"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return
name|LDAP_addmod
argument_list|(
name|mods
argument_list|,
name|modop
argument_list|,
name|attribute
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_get_string_value
parameter_list|(
name|HDB
modifier|*
name|db
parameter_list|,
name|LDAPMessage
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|vals
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|vals
operator|=
name|ldap_get_values
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|entry
argument_list|,
operator|(
name|char
operator|*
operator|)
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
operator|*
name|ptr
operator|=
name|strdup
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_get_integer_value
parameter_list|(
name|HDB
modifier|*
name|db
parameter_list|,
name|LDAPMessage
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|vals
decl_stmt|;
name|vals
operator|=
name|ldap_get_values
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|entry
argument_list|,
operator|(
name|char
operator|*
operator|)
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
operator|*
name|ptr
operator|=
name|atoi
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_get_generalized_time_value
parameter_list|(
name|HDB
modifier|*
name|db
parameter_list|,
name|LDAPMessage
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
name|KerberosTime
modifier|*
name|kt
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|gentime
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|kt
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|LDAP_get_string_value
argument_list|(
name|db
argument_list|,
name|entry
argument_list|,
name|attribute
argument_list|,
operator|&
name|gentime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|tmp
operator|=
name|strptime
argument_list|(
name|gentime
argument_list|,
literal|"%Y%m%d%H%M%SZ"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|gentime
argument_list|)
expr_stmt|;
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
name|free
argument_list|(
name|gentime
argument_list|)
expr_stmt|;
operator|*
name|kt
operator|=
name|timegm
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_entry2mods
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|hdb_entry
modifier|*
name|ent
parameter_list|,
name|LDAPMessage
modifier|*
name|msg
parameter_list|,
name|LDAPMod
modifier|*
modifier|*
modifier|*
name|pmods
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_boolean
name|is_new_entry
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|LDAPMod
modifier|*
modifier|*
name|mods
init|=
name|NULL
decl_stmt|;
name|hdb_entry
name|orig
decl_stmt|;
name|unsigned
name|long
name|oflags
decl_stmt|,
name|nflags
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|LDAP_message2entry
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|msg
argument_list|,
operator|&
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|is_new_entry
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* to make it perfectly obvious we're depending on 	 * orig being intiialized to zero */
name|memset
argument_list|(
operator|&
name|orig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|is_new_entry
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|is_new_entry
condition|)
block|{
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"objectClass"
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* person is the structural object class */
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"objectClass"
argument_list|,
literal|"person"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"objectClass"
argument_list|,
literal|"krb5Principal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"objectClass"
argument_list|,
literal|"krb5KDCEntry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|is_new_entry
operator|||
name|krb5_principal_compare
argument_list|(
name|context
argument_list|,
name|ent
operator|->
name|principal
argument_list|,
name|orig
operator|.
name|principal
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|ret
operator|=
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|ent
operator|->
name|principal
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5PrincipalName"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|kvno
operator|!=
name|orig
operator|.
name|kvno
condition|)
block|{
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|ent
operator|->
name|kvno
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5KeyVersionNumber"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|valid_start
condition|)
block|{
if|if
condition|(
name|orig
operator|.
name|valid_end
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|ent
operator|->
name|valid_start
operator|)
operator|!=
operator|*
operator|(
name|orig
operator|.
name|valid_start
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|LDAP_addmod_generalized_time
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5ValidStart"
argument_list|,
name|ent
operator|->
name|valid_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|valid_end
condition|)
block|{
if|if
condition|(
name|orig
operator|.
name|valid_end
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|ent
operator|->
name|valid_end
operator|)
operator|!=
operator|*
operator|(
name|orig
operator|.
name|valid_end
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|LDAP_addmod_generalized_time
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5ValidEnd"
argument_list|,
name|ent
operator|->
name|valid_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|pw_end
condition|)
block|{
if|if
condition|(
name|orig
operator|.
name|pw_end
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|ent
operator|->
name|pw_end
operator|)
operator|!=
operator|*
operator|(
name|orig
operator|.
name|pw_end
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|LDAP_addmod_generalized_time
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5PasswordEnd"
argument_list|,
name|ent
operator|->
name|pw_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|max_life
condition|)
block|{
if|if
condition|(
name|orig
operator|.
name|max_life
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|ent
operator|->
name|max_life
operator|)
operator|!=
operator|*
operator|(
name|orig
operator|.
name|max_life
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|ent
operator|->
name|max_life
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5MaxLife"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|max_renew
condition|)
block|{
if|if
condition|(
name|orig
operator|.
name|max_renew
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|ent
operator|->
name|max_renew
operator|)
operator|!=
operator|*
operator|(
name|orig
operator|.
name|max_renew
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|ent
operator|->
name|max_renew
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5MaxRenew"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|oflags
operator|=
name|HDBFlags2int
argument_list|(
name|orig
operator|.
name|flags
argument_list|)
expr_stmt|;
name|nflags
operator|=
name|HDBFlags2int
argument_list|(
name|ent
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|oflags
operator|!=
name|nflags
condition|)
block|{
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%lu"
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_REPLACE
argument_list|,
literal|"krb5KDCFlags"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|is_new_entry
operator|==
name|FALSE
operator|&&
name|orig
operator|.
name|keys
operator|.
name|len
operator|>
literal|0
condition|)
block|{
comment|/* for the moment, clobber and replace keys. */
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_DELETE
argument_list|,
literal|"krb5Key"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|keys
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|Key
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|ent
operator|->
name|keys
operator|.
name|val
index|[
name|i
index|]
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* addmod_len _owns_ the key, doesn't need to copy it */
name|ret
operator|=
name|LDAP_addmod_len
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"krb5Key"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|etypes
condition|)
block|{
comment|/* clobber and replace encryption types. */
if|if
condition|(
name|is_new_entry
operator|==
name|FALSE
condition|)
block|{
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_DELETE
argument_list|,
literal|"krb5EncryptionType"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|etypes
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|ent
operator|->
name|etypes
operator|->
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"krb5EncryptionType"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* for clarity */
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
operator|*
name|pmods
operator|=
name|mods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mods
operator|!=
name|NULL
condition|)
block|{
name|ldap_mods_free
argument_list|(
name|mods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|pmods
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|hdb_free_entry
argument_list|(
name|context
argument_list|,
operator|&
name|orig
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_dn2principal
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dn
parameter_list|,
name|krb5_principal
modifier|*
name|principal
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|limit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|LDAPMessage
modifier|*
name|res
init|=
name|NULL
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|rc
operator|=
name|ldap_set_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_SIZELIMIT
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_set_option: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_BADVERSION
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ldap_search_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|dn
argument_list|,
name|LDAP_SCOPE_BASE
argument_list|,
literal|"(objectclass=krb5Principal)"
argument_list|,
name|krb5principal_attrs
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_search_s: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|e
operator|=
name|ldap_first_entry
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|values
operator|=
name|ldap_get_values
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|e
argument_list|,
literal|"krb5PrincipalName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|krb5_parse_name
argument_list|(
name|context
argument_list|,
name|values
index|[
literal|0
index|]
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|ldap_value_free
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|ldap_msgfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP__lookup_princ
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|princname
parameter_list|,
name|LDAPMessage
modifier|*
modifier|*
name|msg
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|limit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|filter
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|LDAP__connect
argument_list|(
name|context
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|rc
operator|=
name|asprintf
argument_list|(
operator|&
name|filter
argument_list|,
literal|"(&(objectclass=krb5KDCEntry)(krb5PrincipalName=%s))"
argument_list|,
name|princname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ldap_set_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_SIZELIMIT
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_set_option: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_BADVERSION
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ldap_search_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|db
operator|->
name|name
argument_list|,
name|LDAP_SCOPE_ONELEVEL
argument_list|,
name|filter
argument_list|,
name|krb5kdcentry_attrs
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_search_s: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|filter
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_principal2message
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|krb5_principal
name|princ
parameter_list|,
name|LDAPMessage
modifier|*
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|princname
init|=
name|NULL
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|princ
argument_list|,
operator|&
name|princname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|LDAP__lookup_princ
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|princname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|princname
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Construct an hdb_entry from a directory entry.  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|LDAP_message2entry
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|LDAPMessage
modifier|*
name|msg
parameter_list|,
name|hdb_entry
modifier|*
name|ent
parameter_list|)
block|{
name|char
modifier|*
name|unparsed_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|dn
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
name|struct
name|berval
modifier|*
modifier|*
name|keys
decl_stmt|;
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|memset
argument_list|(
name|ent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|flags
operator|=
name|int2HDBFlags
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|LDAP_get_string_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5PrincipalName"
argument_list|,
operator|&
name|unparsed_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|krb5_parse_name
argument_list|(
name|context
argument_list|,
name|unparsed_name
argument_list|,
operator|&
name|ent
operator|->
name|principal
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_integer_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5KeyVersionNumber"
argument_list|,
operator|&
name|ent
operator|->
name|kvno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ent
operator|->
name|kvno
operator|=
literal|0
expr_stmt|;
block|}
name|keys
operator|=
name|ldap_get_values_len
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5Key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|ent
operator|->
name|keys
operator|.
name|len
operator|=
name|ldap_count_values_len
argument_list|(
name|keys
argument_list|)
expr_stmt|;
name|ent
operator|->
name|keys
operator|.
name|val
operator|=
operator|(
name|Key
operator|*
operator|)
name|calloc
argument_list|(
name|ent
operator|->
name|keys
operator|.
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|Key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|keys
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"calloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|keys
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decode_Key
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|keys
index|[
name|i
index|]
operator|->
name|bv_val
argument_list|,
operator|(
name|size_t
operator|)
name|keys
index|[
name|i
index|]
operator|->
name|bv_len
argument_list|,
operator|&
name|ent
operator|->
name|keys
operator|.
name|val
index|[
name|i
index|]
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
name|ber_bvecfree
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|1
comment|/* 	 * This violates the ASN1 but it allows a principal to 	 * be related to a general directory entry without creating 	 * the keys. Hopefully it's OK. 	 */
name|ent
operator|->
name|keys
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|keys
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
block|}
name|ret
operator|=
name|LDAP_get_generalized_time_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"createTimestamp"
argument_list|,
operator|&
name|ent
operator|->
name|created_by
operator|.
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ent
operator|->
name|created_by
operator|.
name|time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|created_by
operator|.
name|principal
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|LDAP_get_string_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"creatorsName"
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LDAP_dn2principal
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|dn
argument_list|,
operator|&
name|ent
operator|->
name|created_by
operator|.
name|principal
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ent
operator|->
name|created_by
operator|.
name|principal
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|modified_by
operator|=
operator|(
name|Event
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|modified_by
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_generalized_time_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"modifyTimestamp"
argument_list|,
operator|&
name|ent
operator|->
name|modified_by
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|LDAP_get_string_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"modifiersName"
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LDAP_dn2principal
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|dn
argument_list|,
operator|&
name|ent
operator|->
name|modified_by
operator|->
name|principal
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ent
operator|->
name|modified_by
operator|->
name|principal
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|ent
operator|->
name|modified_by
argument_list|)
expr_stmt|;
name|ent
operator|->
name|modified_by
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ent
operator|->
name|valid_start
operator|=
operator|(
name|KerberosTime
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KerberosTime
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_generalized_time_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5ValidStart"
argument_list|,
name|ent
operator|->
name|valid_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* OPTIONAL */
name|free
argument_list|(
name|ent
operator|->
name|valid_start
argument_list|)
expr_stmt|;
name|ent
operator|->
name|valid_start
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ent
operator|->
name|valid_end
operator|=
operator|(
name|KerberosTime
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KerberosTime
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_generalized_time_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5ValidEnd"
argument_list|,
name|ent
operator|->
name|valid_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* OPTIONAL */
name|free
argument_list|(
name|ent
operator|->
name|valid_end
argument_list|)
expr_stmt|;
name|ent
operator|->
name|valid_end
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ent
operator|->
name|pw_end
operator|=
operator|(
name|KerberosTime
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KerberosTime
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_generalized_time_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5PasswordEnd"
argument_list|,
name|ent
operator|->
name|pw_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* OPTIONAL */
name|free
argument_list|(
name|ent
operator|->
name|pw_end
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pw_end
operator|=
name|NULL
expr_stmt|;
block|}
name|ent
operator|->
name|max_life
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|max_life
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_integer_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5MaxLife"
argument_list|,
name|ent
operator|->
name|max_life
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|max_life
argument_list|)
expr_stmt|;
name|ent
operator|->
name|max_life
operator|=
name|NULL
expr_stmt|;
block|}
name|ent
operator|->
name|max_renew
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|max_renew
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_get_integer_value
argument_list|(
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5MaxRenew"
argument_list|,
name|ent
operator|->
name|max_renew
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|max_renew
argument_list|)
expr_stmt|;
name|ent
operator|->
name|max_renew
operator|=
name|NULL
expr_stmt|;
block|}
name|values
operator|=
name|ldap_get_values
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5KDCFlags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|ULONG_MAX
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"strtoul: could not convert flag"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
name|ent
operator|->
name|flags
operator|=
name|int2HDBFlags
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|values
operator|=
name|ldap_get_values
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|,
literal|"krb5EncryptionType"
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ent
operator|->
name|etypes
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ent
operator|->
name|etypes
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|etypes
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ent
operator|->
name|etypes
operator|->
name|len
operator|=
name|ldap_count_values
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|ent
operator|->
name|etypes
operator|->
name|val
operator|=
name|calloc
argument_list|(
name|ent
operator|->
name|etypes
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|etypes
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|->
name|etypes
operator|->
name|val
index|[
name|i
index|]
operator|=
name|atoi
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ldap_value_free
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|unparsed_name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|unparsed_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* I don't think this frees ent itself. */
name|hdb_free_entry
argument_list|(
name|context
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_close
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|)
block|{
name|ldap_unbind_ext
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_lock
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|int
name|operation
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_unlock
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_seq
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|msgid
decl_stmt|,
name|rc
decl_stmt|,
name|parserc
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|LDAPMessage
modifier|*
name|e
decl_stmt|;
name|msgid
operator|=
name|db
operator|->
name|openp
expr_stmt|;
comment|/* BOGUS OVERLOADING */
if|if
condition|(
name|msgid
operator|<
literal|0
condition|)
block|{
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
do|do
block|{
name|rc
operator|=
name|ldap_result
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msgid
argument_list|,
name|LDAP_MSG_ONE
argument_list|,
name|NULL
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|LDAP_RES_SEARCH_ENTRY
case|:
comment|/* We have an entry. Parse it. */
name|ret
operator|=
name|LDAP_message2entry
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|e
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ldap_msgfree
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_SEARCH_RESULT
case|:
comment|/* We're probably at the end of the results. If not, abandon. */
name|parserc
operator|=
name|ldap_parse_result
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parserc
operator|!=
name|LDAP_SUCCESS
operator|&&
name|parserc
operator|!=
name|LDAP_MORE_RESULTS_TO_RETURN
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_parse_result: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|parserc
argument_list|)
argument_list|)
expr_stmt|;
name|ldap_abandon
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
name|db
operator|->
name|openp
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
operator|-
literal|1
case|:
default|default:
comment|/* Some unspecified error (timeout?). Abandon. */
name|ldap_msgfree
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ldap_abandon
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
name|db
operator|->
name|openp
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|rc
operator|==
name|LDAP_RES_SEARCH_REFERENCE
condition|)
do|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|master_key_set
operator|&&
operator|(
name|flags
operator|&
name|HDB_F_DECRYPT
operator|)
condition|)
block|{
name|ret
operator|=
name|hdb_unseal_keys
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|hdb_free_entry
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_firstkey
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|msgid
decl_stmt|,
name|limit
init|=
name|LDAP_NO_LIMIT
decl_stmt|,
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|LDAP__connect
argument_list|(
name|context
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ldap_set_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_SIZELIMIT
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_set_option: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|HDB_ERR_BADVERSION
return|;
block|}
name|msgid
operator|=
name|ldap_search
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|db
operator|->
name|name
argument_list|,
name|LDAP_SCOPE_ONELEVEL
argument_list|,
literal|"(objectclass=krb5KDCEntry)"
argument_list|,
name|krb5kdcentry_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgid
operator|<
literal|0
condition|)
block|{
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
name|db
operator|->
name|openp
operator|=
name|msgid
expr_stmt|;
return|return
name|LDAP_seq
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|flags
argument_list|,
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_nextkey
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
return|return
name|LDAP_seq
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|flags
argument_list|,
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_rename
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
return|return
name|HDB_ERR_DB_INUSE
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP__connect
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|version
init|=
name|LDAP_VERSION3
decl_stmt|;
comment|/*      * Empty credentials to do a SASL bind with LDAP. Note that empty      * different from NULL credentials. If you provide NULL      * credentials instead of empty credentials you will get a SASL      * bind in progress message.      */
name|struct
name|berval
name|bv
init|=
block|{
literal|0
block|,
literal|""
block|}
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
comment|/* connection has been opened. ping server. */
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|socklen_t
name|len
decl_stmt|;
name|int
name|sd
decl_stmt|;
if|if
condition|(
name|ldap_get_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_DESC
argument_list|,
operator|&
name|sd
argument_list|)
operator|==
literal|0
operator|&&
name|getpeername
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* the other end has died. reopen. */
name|LDAP_close
argument_list|(
name|context
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|db
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
comment|/* server is UP */
return|return
literal|0
return|;
block|}
name|rc
operator|=
name|ldap_initialize
argument_list|(
operator|(
name|LDAP
operator|*
operator|*
operator|)
operator|&
name|db
operator|->
name|db
argument_list|,
literal|"ldapi:///"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_initialize: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|HDB_ERR_NOENTRY
return|;
block|}
name|rc
operator|=
name|ldap_set_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_PROTOCOL_VERSION
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_set_option: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ldap_unbind_ext
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
return|return
name|HDB_ERR_BADVERSION
return|;
block|}
name|rc
operator|=
name|ldap_sasl_bind_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
literal|"EXTERNAL"
argument_list|,
operator|&
name|bv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_sasl_bind_s: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ldap_unbind_ext
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
return|return
name|HDB_ERR_BADVERSION
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_open
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
comment|/* Not the right place for this. */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGACTION */
return|return
name|LDAP__connect
argument_list|(
name|context
argument_list|,
name|db
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_fetch
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
name|LDAPMessage
modifier|*
name|msg
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|LDAP_principal2message
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
operator|->
name|principal
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|e
operator|=
name|ldap_first_entry
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_message2entry
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|e
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|master_key_set
operator|&&
operator|(
name|flags
operator|&
name|HDB_F_DECRYPT
operator|)
condition|)
block|{
name|ret
operator|=
name|hdb_unseal_keys
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|hdb_free_entry
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|ldap_msgfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_store
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
name|LDAPMod
modifier|*
modifier|*
name|mods
init|=
name|NULL
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|errfn
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|LDAPMessage
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dn
init|=
name|NULL
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|entry
operator|->
name|principal
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP__lookup_princ
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|name
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|e
operator|=
name|ldap_first_entry
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|hdb_seal_keys
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* turn new entry into LDAPMod array */
name|ret
operator|=
name|LDAP_entry2mods
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
argument_list|,
name|e
argument_list|,
operator|&
name|mods
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
comment|/* Doesn't exist yet. */
name|char
modifier|*
name|p
decl_stmt|;
name|e
operator|=
name|NULL
expr_stmt|;
comment|/* normalize the naming attribute */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We could do getpwnam() on the local component of 	 * the principal to find cn/sn but that's probably 	 * bad thing to do from inside a KDC. Better leave 	 * it to management tools. 	 */
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"cn"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|LDAP_addmod
argument_list|(
operator|&
name|mods
argument_list|,
name|LDAP_MOD_ADD
argument_list|,
literal|"sn"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|db
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|dn
argument_list|,
literal|"cn=%s,%s"
argument_list|,
name|name
argument_list|,
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A bit bogus, but we don't have a search base */
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|dn
argument_list|,
literal|"cn=%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"asprintf: out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HDB_F_REPLACE
condition|)
block|{
comment|/* Entry exists, and we're allowed to replace it. */
name|dn
operator|=
name|ldap_get_dn
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Entry exists, but we're not allowed to replace it. Bail. */
name|ret
operator|=
name|HDB_ERR_EXISTS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* write entry into directory */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
comment|/* didn't exist before */
name|rc
operator|=
name|ldap_add_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|dn
argument_list|,
name|mods
argument_list|)
expr_stmt|;
name|errfn
operator|=
literal|"ldap_add_s"
expr_stmt|;
block|}
else|else
block|{
comment|/* already existed, send deltas only */
name|rc
operator|=
name|ldap_modify_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|dn
argument_list|,
name|mods
argument_list|)
expr_stmt|;
name|errfn
operator|=
literal|"ldap_modify_s"
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|LDAP_SUCCESS
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"%s: %s (dn=%s) %s"
argument_list|,
name|errfn
argument_list|,
name|name
argument_list|,
name|dn
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_CANT_LOCK_DB
expr_stmt|;
block|}
name|out
label|:
comment|/* free stuff */
if|if
condition|(
name|dn
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|ldap_msgfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mods
operator|!=
name|NULL
condition|)
block|{
name|ldap_mods_free
argument_list|(
name|mods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_remove
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|hdb_entry
modifier|*
name|entry
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|LDAPMessage
modifier|*
name|msg
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|dn
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|limit
init|=
name|LDAP_NO_LIMIT
decl_stmt|;
name|ret
operator|=
name|LDAP_principal2message
argument_list|(
name|context
argument_list|,
name|db
argument_list|,
name|entry
operator|->
name|principal
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|e
operator|=
name|ldap_first_entry
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dn
operator|=
name|ldap_get_dn
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HDB_ERR_NOENTRY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ldap_set_option
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|LDAP_OPT_SIZELIMIT
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_set_option: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_BADVERSION
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ldap_delete_s
argument_list|(
operator|(
name|LDAP
operator|*
operator|)
name|db
operator|->
name|db
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|LDAP_SUCCESS
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"ldap_delete_s: %s"
argument_list|,
name|ldap_err2string
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HDB_ERR_CANT_LOCK_DB
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|dn
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|ldap_msgfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP__get
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|krb5_data
name|key
parameter_list|,
name|krb5_data
modifier|*
name|reply
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LDAP__get not implemented\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP__put
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|int
name|replace
parameter_list|,
name|krb5_data
name|key
parameter_list|,
name|krb5_data
name|value
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LDAP__put not implemented\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP__del
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|,
name|krb5_data
name|key
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LDAP__del not implemented\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|LDAP_destroy
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
name|db
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|hdb_clear_master_key
argument_list|(
name|context
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|hdb_ldap_create
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|HDB
modifier|*
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
operator|*
name|db
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|db
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|db
operator|)
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	 * if no argument specified in the configuration file 	 * then use NULL, which tells OpenLDAP to look in 	 * the ldap.conf file. This doesn't work for 	 * writing entries because we don't know where to 	 * put new principals. 	 */
operator|(
operator|*
name|db
operator|)
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|db
operator|)
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|db
operator|)
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_string
argument_list|(
name|context
argument_list|,
literal|"strdup: out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|db
argument_list|)
expr_stmt|;
operator|*
name|db
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
operator|(
operator|*
name|db
operator|)
operator|->
name|master_key_set
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|openp
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|open
operator|=
name|LDAP_open
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|close
operator|=
name|LDAP_close
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|fetch
operator|=
name|LDAP_fetch
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|store
operator|=
name|LDAP_store
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|remove
operator|=
name|LDAP_remove
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|firstkey
operator|=
name|LDAP_firstkey
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|nextkey
operator|=
name|LDAP_nextkey
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|lock
operator|=
name|LDAP_lock
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|unlock
operator|=
name|LDAP_unlock
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|rename
operator|=
name|LDAP_rename
expr_stmt|;
comment|/* can we ditch these? */
operator|(
operator|*
name|db
operator|)
operator|->
name|_get
operator|=
name|LDAP__get
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|_put
operator|=
name|LDAP__put
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|_del
operator|=
name|LDAP__del
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|destroy
operator|=
name|LDAP_destroy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENLDAP */
end_comment

end_unit

