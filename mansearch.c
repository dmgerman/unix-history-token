begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mansearch.c,v 1.51 2014/11/27 01:58:21 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2013, 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|HAVE_OHASH
end_if

begin_include
include|#
directive|include
file|<ohash.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"compat_ohash.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sqlite3.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_DETERMINISTIC
end_ifndef

begin_define
define|#
directive|define
name|SQLITE_DETERMINISTIC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_include
include|#
directive|include
file|"mansearch.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|mansearch_keymax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|mansearch_keynames
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SQL_BIND_TEXT
parameter_list|(
name|_db
parameter_list|,
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|do { if (SQLITE_OK != sqlite3_bind_text \ 		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \ 		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|SQL_BIND_INT64
parameter_list|(
name|_db
parameter_list|,
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|do { if (SQLITE_OK != sqlite3_bind_int64 \ 		((_s), (_i)++, (_v))) \ 		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|SQL_BIND_BLOB
parameter_list|(
name|_db
parameter_list|,
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|do { if (SQLITE_OK != sqlite3_bind_blob \ 		((_s), (_i)++, (&_v), sizeof(_v), SQLITE_STATIC)) \ 		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \ 	} while (0)
end_define

begin_struct
struct|struct
name|expr
block|{
name|regex_t
name|regexp
decl_stmt|;
comment|/* compiled regexp, if applicable */
specifier|const
name|char
modifier|*
name|substr
decl_stmt|;
comment|/* to search for, if applicable */
name|struct
name|expr
modifier|*
name|next
decl_stmt|;
comment|/* next in sequence */
name|uint64_t
name|bits
decl_stmt|;
comment|/* type-mask */
name|int
name|equal
decl_stmt|;
comment|/* equality, not subsring match */
name|int
name|open
decl_stmt|;
comment|/* opening parentheses before */
name|int
name|and
decl_stmt|;
comment|/* logical AND before */
name|int
name|close
decl_stmt|;
comment|/* closing parentheses after */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|match
block|{
name|uint64_t
name|pageid
decl_stmt|;
comment|/* identifier in database */
name|uint64_t
name|bits
decl_stmt|;
comment|/* name type mask */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* manual page description */
name|int
name|form
decl_stmt|;
comment|/* bit field: formatted, zipped? */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|buildnames
parameter_list|(
name|struct
name|manpage
modifier|*
parameter_list|,
name|sqlite3
modifier|*
parameter_list|,
name|sqlite3_stmt
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|form
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|buildoutput
parameter_list|(
name|sqlite3
modifier|*
parameter_list|,
name|sqlite3_stmt
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|hash_alloc
parameter_list|(
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|hash_calloc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|exprcomp
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exprfree
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|exprspec
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|exprterm
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|manpage_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sql_append
parameter_list|(
name|char
modifier|*
modifier|*
name|sql
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|,
specifier|const
name|char
modifier|*
name|newstr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sql_match
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sql_regexp
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sql_statement
parameter_list|(
specifier|const
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|mansearch_setup
parameter_list|(
name|int
name|start
parameter_list|)
block|{
specifier|static
name|void
modifier|*
name|pagecache
decl_stmt|;
name|int
name|c
decl_stmt|;
define|#
directive|define
name|PC_PAGESIZE
value|1280
define|#
directive|define
name|PC_NUMPAGES
value|256
if|if
condition|(
name|start
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|pagecache
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pagecache already enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
name|pagecache
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|PC_PAGESIZE
operator|*
name|PC_NUMPAGES
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAP_FAILED
operator|==
name|pagecache
condition|)
block|{
name|perror
argument_list|(
literal|"mmap"
argument_list|)
expr_stmt|;
name|pagecache
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
operator|)
return|;
block|}
name|c
operator|=
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_PAGECACHE
argument_list|,
name|pagecache
argument_list|,
name|PC_PAGESIZE
argument_list|,
name|PC_NUMPAGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|==
name|c
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_OK
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pagecache: %s\n"
argument_list|,
name|sqlite3_errstr
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
name|pagecache
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pagecache missing\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|munmap
argument_list|(
name|pagecache
argument_list|,
name|PC_PAGESIZE
operator|*
name|PC_NUMPAGES
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"munmap"
argument_list|)
expr_stmt|;
name|pagecache
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
operator|)
return|;
block|}
name|pagecache
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mansearch
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
name|search
parameter_list|,
specifier|const
name|struct
name|manpaths
modifier|*
name|paths
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|rc
decl_stmt|,
name|c
decl_stmt|,
name|indexbit
decl_stmt|;
name|int64_t
name|pageid
decl_stmt|;
name|uint64_t
name|outbit
decl_stmt|,
name|iterbit
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|sql
decl_stmt|;
name|struct
name|manpage
modifier|*
name|mpage
decl_stmt|;
name|struct
name|expr
modifier|*
name|e
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|sqlite3
modifier|*
name|db
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|match
modifier|*
name|mp
decl_stmt|;
name|struct
name|ohash_info
name|info
decl_stmt|;
name|struct
name|ohash
name|htab
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cur
decl_stmt|,
name|maxres
decl_stmt|;
name|info
operator|.
name|calloc
operator|=
name|hash_calloc
expr_stmt|;
name|info
operator|.
name|alloc
operator|=
name|hash_alloc
expr_stmt|;
name|info
operator|.
name|free
operator|=
name|hash_free
expr_stmt|;
name|info
operator|.
name|key_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|match
argument_list|,
name|pageid
argument_list|)
expr_stmt|;
operator|*
name|sz
operator|=
name|cur
operator|=
name|maxres
operator|=
literal|0
expr_stmt|;
name|sql
operator|=
name|NULL
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|argc
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|e
operator|=
name|exprcomp
argument_list|(
name|search
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|outbit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|search
operator|->
name|outkey
condition|)
block|{
for|for
control|(
name|indexbit
operator|=
literal|0
operator|,
name|iterbit
operator|=
literal|1
init|;
name|indexbit
operator|<
name|mansearch_keymax
condition|;
name|indexbit
operator|++
operator|,
name|iterbit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|search
operator|->
name|outkey
argument_list|,
name|mansearch_keynames
index|[
name|indexbit
index|]
argument_list|)
condition|)
block|{
name|outbit
operator|=
name|iterbit
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Save a descriptor to the current working directory. 	 * Since pathnames in the "paths" variable might be relative, 	 * and we'll be chdir()ing into them, we need to keep a handle 	 * on our current directory from which to start the chdir(). 	 */
if|if
condition|(
name|NULL
operator|==
name|getcwd
argument_list|(
name|buf
argument_list|,
name|PATH_MAX
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"getcwd"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|-
literal|1
operator|==
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sql
operator|=
name|sql_statement
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over the directories (containing databases) for us to 	 * search. 	 * Don't let missing/bad databases/directories phase us. 	 * In each, try to open the resident database and, if it opens, 	 * scan it for our match expression. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|fchdir
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|paths
operator|->
name|paths
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|paths
operator|->
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|sqlite3_open_v2
argument_list|(
name|MANDOC_DB
argument_list|,
operator|&
name|db
argument_list|,
name|SQLITE_OPEN_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|c
condition|)
block|{
name|perror
argument_list|(
name|MANDOC_DB
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Define the SQL functions for substring 		 * and regular expression matching. 		 */
name|c
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"match"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
operator||
name|SQLITE_DETERMINISTIC
argument_list|,
name|NULL
argument_list|,
name|sql_match
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SQLITE_OK
operator|==
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"regexp"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
operator||
name|SQLITE_DETERMINISTIC
argument_list|,
name|NULL
argument_list|,
name|sql_regexp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SQLITE_OK
operator|==
name|c
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|c
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|e
init|;
name|NULL
operator|!=
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|ep
operator|->
name|substr
condition|)
block|{
name|SQL_BIND_BLOB
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|j
argument_list|,
name|ep
operator|->
name|regexp
argument_list|)
expr_stmt|;
block|}
else|else
name|SQL_BIND_TEXT
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|j
argument_list|,
name|ep
operator|->
name|substr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
operator|(
name|TYPE_Nd
operator||
name|TYPE_Nm
operator|)
operator|&
name|ep
operator|->
name|bits
operator|)
condition|)
name|SQL_BIND_INT64
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|j
argument_list|,
name|ep
operator|->
name|bits
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|htab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ohash
argument_list|)
argument_list|)
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|htab
argument_list|,
literal|4
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* 		 * Hash each entry on its [unique] document identifier. 		 * This is a uint64_t. 		 * Instead of using a hash function, simply convert the 		 * uint64_t to a uint32_t, the hash value's type. 		 * This gives good performance and preserves the 		 * distribution of buckets in the table. 		 */
while|while
condition|(
name|SQLITE_ROW
operator|==
operator|(
name|c
operator|=
name|sqlite3_step
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
name|pageid
operator|=
name|sqlite3_column_int64
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|idx
operator|=
name|ohash_lookup_memory
argument_list|(
operator|&
name|htab
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pageid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|pageid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ohash_find
argument_list|(
operator|&
name|htab
argument_list|,
name|idx
argument_list|)
condition|)
continue|continue;
name|mp
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|match
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|pageid
operator|=
name|pageid
expr_stmt|;
name|mp
operator|->
name|form
operator|=
name|sqlite3_column_int
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|->
name|bits
operator|=
name|sqlite3_column_int64
argument_list|(
name|s
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_Nd
operator|==
name|outbit
condition|)
name|mp
operator|->
name|desc
operator|=
name|mandoc_strdup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ohash_insert
argument_list|(
operator|&
name|htab
argument_list|,
name|idx
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQLITE_DONE
operator|!=
name|c
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
literal|"SELECT sec, arch, name, pageid FROM mlinks "
literal|"WHERE pageid=? ORDER BY sec, arch, name"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|c
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
literal|"SELECT bits, key, pageid FROM keys "
literal|"WHERE pageid=? AND bits& ?"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|s2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|c
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|ohash_first
argument_list|(
operator|&
name|htab
argument_list|,
operator|&
name|idx
argument_list|)
init|;
name|NULL
operator|!=
name|mp
condition|;
name|mp
operator|=
name|ohash_next
argument_list|(
operator|&
name|htab
argument_list|,
operator|&
name|idx
argument_list|)
control|)
block|{
if|if
condition|(
name|cur
operator|+
literal|1
operator|>
name|maxres
condition|)
block|{
name|maxres
operator|+=
literal|1024
expr_stmt|;
operator|*
name|res
operator|=
name|mandoc_reallocarray
argument_list|(
operator|*
name|res
argument_list|,
name|maxres
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpage
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mpage
operator|=
operator|*
name|res
operator|+
name|cur
expr_stmt|;
name|mpage
operator|->
name|ipath
operator|=
name|i
expr_stmt|;
name|mpage
operator|->
name|bits
operator|=
name|mp
operator|->
name|bits
expr_stmt|;
name|mpage
operator|->
name|sec
operator|=
literal|10
expr_stmt|;
name|mpage
operator|->
name|form
operator|=
name|mp
operator|->
name|form
expr_stmt|;
name|buildnames
argument_list|(
name|mpage
argument_list|,
name|db
argument_list|,
name|s
argument_list|,
name|mp
operator|->
name|pageid
argument_list|,
name|paths
operator|->
name|paths
index|[
name|i
index|]
argument_list|,
name|mp
operator|->
name|form
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|output
operator|=
name|TYPE_Nd
operator|&
name|outbit
condition|?
name|mp
operator|->
name|desc
else|:
name|outbit
condition|?
name|buildoutput
argument_list|(
name|db
argument_list|,
name|s2
argument_list|,
name|mp
operator|->
name|pageid
argument_list|,
name|outbit
argument_list|)
else|:
name|NULL
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|htab
argument_list|)
expr_stmt|;
comment|/* 		 * In man(1) mode, prefer matches in earlier trees 		 * over matches in later trees. 		 */
if|if
condition|(
name|cur
operator|&&
name|search
operator|->
name|firstmatch
condition|)
break|break;
block|}
name|qsort
argument_list|(
operator|*
name|res
argument_list|,
name|cur
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpage
argument_list|)
argument_list|,
name|manpage_compare
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|fd
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|fchdir
argument_list|(
name|fd
argument_list|)
condition|)
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|exprfree
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sql
argument_list|)
expr_stmt|;
operator|*
name|sz
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mansearch_free
parameter_list|(
name|struct
name|manpage
modifier|*
name|res
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|names
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|manpage_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|vp1
parameter_list|,
specifier|const
name|void
modifier|*
name|vp2
parameter_list|)
block|{
specifier|const
name|struct
name|manpage
modifier|*
name|mp1
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|mp1
operator|=
name|vp1
expr_stmt|;
name|mp2
operator|=
name|vp2
expr_stmt|;
return|return
operator|(
operator|(
name|diff
operator|=
name|mp2
operator|->
name|bits
operator|-
name|mp1
operator|->
name|bits
operator|)
condition|?
name|diff
else|:
operator|(
name|diff
operator|=
name|mp1
operator|->
name|sec
operator|-
name|mp2
operator|->
name|sec
operator|)
condition|?
name|diff
else|:
name|strcasecmp
argument_list|(
name|mp1
operator|->
name|names
argument_list|,
name|mp2
operator|->
name|names
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buildnames
parameter_list|(
name|struct
name|manpage
modifier|*
name|mpage
parameter_list|,
name|sqlite3
modifier|*
name|db
parameter_list|,
name|sqlite3_stmt
modifier|*
name|s
parameter_list|,
name|uint64_t
name|pageid
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|form
parameter_list|)
block|{
name|char
modifier|*
name|newnames
decl_stmt|,
modifier|*
name|prevsec
decl_stmt|,
modifier|*
name|prevarch
decl_stmt|;
specifier|const
name|char
modifier|*
name|oldnames
decl_stmt|,
modifier|*
name|sep1
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sep2
decl_stmt|,
modifier|*
name|arch
decl_stmt|,
modifier|*
name|fsec
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|mpage
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|mpage
operator|->
name|names
operator|=
name|NULL
expr_stmt|;
name|prevsec
operator|=
name|prevarch
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|pageid
argument_list|)
expr_stmt|;
while|while
condition|(
name|SQLITE_ROW
operator|==
operator|(
name|c
operator|=
name|sqlite3_step
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
comment|/* Decide whether we already have some names. */
if|if
condition|(
name|NULL
operator|==
name|mpage
operator|->
name|names
condition|)
block|{
name|oldnames
operator|=
literal|""
expr_stmt|;
name|sep1
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|oldnames
operator|=
name|mpage
operator|->
name|names
expr_stmt|;
name|sep1
operator|=
literal|", "
expr_stmt|;
block|}
comment|/* Fetch the next name. */
name|sec
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arch
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Remember the first section found. */
if|if
condition|(
literal|9
operator|<
name|mpage
operator|->
name|sec
operator|&&
literal|'1'
operator|<=
operator|*
name|sec
operator|&&
literal|'9'
operator|>=
operator|*
name|sec
condition|)
name|mpage
operator|->
name|sec
operator|=
operator|(
operator|*
name|sec
operator|-
literal|'1'
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* If the section changed, append the old one. */
if|if
condition|(
name|NULL
operator|!=
name|prevsec
operator|&&
operator|(
name|strcmp
argument_list|(
name|sec
argument_list|,
name|prevsec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|arch
argument_list|,
name|prevarch
argument_list|)
operator|)
condition|)
block|{
name|sep2
operator|=
literal|'\0'
operator|==
operator|*
name|prevarch
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|newnames
argument_list|,
literal|"%s(%s%s%s)"
argument_list|,
name|oldnames
argument_list|,
name|prevsec
argument_list|,
name|sep2
argument_list|,
name|prevarch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|names
argument_list|)
expr_stmt|;
name|oldnames
operator|=
name|mpage
operator|->
name|names
operator|=
name|newnames
expr_stmt|;
name|free
argument_list|(
name|prevsec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prevarch
argument_list|)
expr_stmt|;
name|prevsec
operator|=
name|prevarch
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Save the new section, to append it later. */
if|if
condition|(
name|NULL
operator|==
name|prevsec
condition|)
block|{
name|prevsec
operator|=
name|mandoc_strdup
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|prevarch
operator|=
name|mandoc_strdup
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* Append the new name. */
name|mandoc_asprintf
argument_list|(
operator|&
name|newnames
argument_list|,
literal|"%s%s%s"
argument_list|,
name|oldnames
argument_list|,
name|sep1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|names
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|names
operator|=
name|newnames
expr_stmt|;
comment|/* Also save the first file name encountered. */
if|if
condition|(
name|mpage
operator|->
name|file
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|form
operator|&
name|FORM_SRC
condition|)
block|{
name|sep1
operator|=
literal|"man"
expr_stmt|;
name|fsec
operator|=
name|sec
expr_stmt|;
block|}
else|else
block|{
name|sep1
operator|=
literal|"cat"
expr_stmt|;
name|fsec
operator|=
literal|"0"
expr_stmt|;
block|}
name|sep2
operator|=
operator|*
name|arch
operator|==
literal|'\0'
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|mpage
operator|->
name|file
argument_list|,
literal|"%s/%s%s%s%s/%s.%s"
argument_list|,
name|path
argument_list|,
name|sep1
argument_list|,
name|sec
argument_list|,
name|sep2
argument_list|,
name|arch
argument_list|,
name|name
argument_list|,
name|fsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|SQLITE_DONE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Append one final section to the names. */
if|if
condition|(
name|prevsec
operator|!=
name|NULL
condition|)
block|{
name|sep2
operator|=
operator|*
name|prevarch
operator|==
literal|'\0'
condition|?
literal|""
else|:
literal|"/"
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|newnames
argument_list|,
literal|"%s(%s%s%s)"
argument_list|,
name|mpage
operator|->
name|names
argument_list|,
name|prevsec
argument_list|,
name|sep2
argument_list|,
name|prevarch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|names
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|names
operator|=
name|newnames
expr_stmt|;
name|free
argument_list|(
name|prevsec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prevarch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|buildoutput
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|sqlite3_stmt
modifier|*
name|s
parameter_list|,
name|uint64_t
name|pageid
parameter_list|,
name|uint64_t
name|outbit
parameter_list|)
block|{
name|char
modifier|*
name|output
decl_stmt|,
modifier|*
name|newoutput
decl_stmt|;
specifier|const
name|char
modifier|*
name|oldoutput
decl_stmt|,
modifier|*
name|sep1
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|output
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|pageid
argument_list|)
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|db
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|outbit
argument_list|)
expr_stmt|;
while|while
condition|(
name|SQLITE_ROW
operator|==
operator|(
name|c
operator|=
name|sqlite3_step
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|output
condition|)
block|{
name|oldoutput
operator|=
literal|""
expr_stmt|;
name|sep1
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|oldoutput
operator|=
name|output
expr_stmt|;
name|sep1
operator|=
literal|" # "
expr_stmt|;
block|}
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|newoutput
argument_list|,
literal|"%s%s%s"
argument_list|,
name|oldoutput
argument_list|,
name|sep1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|output
operator|=
name|newoutput
expr_stmt|;
block|}
if|if
condition|(
name|SQLITE_DONE
operator|!=
name|c
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement substring match as an application-defined SQL function.  * Using the SQL LIKE or GLOB operators instead would be a bad idea  * because that would require escaping metacharacters in the string  * being searched for.  */
end_comment

begin_function
specifier|static
name|void
name|sql_match
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|assert
argument_list|(
literal|2
operator|==
name|argc
argument_list|)
expr_stmt|;
name|sqlite3_result_int
argument_list|(
name|context
argument_list|,
name|NULL
operator|!=
name|strcasestr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement regular expression match  * as an application-defined SQL function.  */
end_comment

begin_function
specifier|static
name|void
name|sql_regexp
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|assert
argument_list|(
literal|2
operator|==
name|argc
argument_list|)
expr_stmt|;
name|sqlite3_result_int
argument_list|(
name|context
argument_list|,
operator|!
name|regexec
argument_list|(
operator|(
name|regex_t
operator|*
operator|)
name|sqlite3_value_blob
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sql_append
parameter_list|(
name|char
modifier|*
modifier|*
name|sql
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|,
specifier|const
name|char
modifier|*
name|newstr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|size_t
name|newsz
decl_stmt|;
name|newsz
operator|=
literal|1
operator|<
name|count
condition|?
operator|(
name|size_t
operator|)
name|count
else|:
name|strlen
argument_list|(
name|newstr
argument_list|)
expr_stmt|;
operator|*
name|sql
operator|=
name|mandoc_realloc
argument_list|(
operator|*
name|sql
argument_list|,
operator|*
name|sz
operator|+
name|newsz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|count
condition|)
name|memset
argument_list|(
operator|*
name|sql
operator|+
operator|*
name|sz
argument_list|,
operator|*
name|newstr
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|*
name|sql
operator|+
operator|*
name|sz
argument_list|,
name|newstr
argument_list|,
name|newsz
argument_list|)
expr_stmt|;
operator|*
name|sz
operator|+=
name|newsz
expr_stmt|;
operator|(
operator|*
name|sql
operator|)
index|[
operator|*
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare the search SQL statement.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sql_statement
parameter_list|(
specifier|const
name|struct
name|expr
modifier|*
name|e
parameter_list|)
block|{
name|char
modifier|*
name|sql
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int
name|needop
decl_stmt|;
name|sql
operator|=
name|mandoc_strdup
argument_list|(
name|e
operator|->
name|equal
condition|?
literal|"SELECT desc, form, pageid, bits "
literal|"FROM mpages NATURAL JOIN names WHERE "
else|:
literal|"SELECT desc, form, pageid, 0 FROM mpages WHERE "
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|sql
argument_list|)
expr_stmt|;
for|for
control|(
name|needop
operator|=
literal|0
init|;
name|NULL
operator|!=
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|and
condition|)
name|sql_append
argument_list|(
operator|&
name|sql
argument_list|,
operator|&
name|sz
argument_list|,
literal|" AND "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|needop
condition|)
name|sql_append
argument_list|(
operator|&
name|sql
argument_list|,
operator|&
name|sz
argument_list|,
literal|" OR "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|open
condition|)
name|sql_append
argument_list|(
operator|&
name|sql
argument_list|,
operator|&
name|sz
argument_list|,
literal|"("
argument_list|,
name|e
operator|->
name|open
argument_list|)
expr_stmt|;
name|sql_append
argument_list|(
operator|&
name|sql
argument_list|,
operator|&
name|sz
argument_list|,
name|TYPE_Nd
operator|&
name|e
operator|->
name|bits
condition|?
operator|(
name|NULL
operator|==
name|e
operator|->
name|substr
condition|?
literal|"desc REGEXP ?"
else|:
literal|"desc MATCH ?"
operator|)
else|:
name|TYPE_Nm
operator|==
name|e
operator|->
name|bits
condition|?
operator|(
name|NULL
operator|==
name|e
operator|->
name|substr
condition|?
literal|"pageid IN (SELECT pageid FROM names "
literal|"WHERE name REGEXP ?)"
else|:
name|e
operator|->
name|equal
condition|?
literal|"name = ? "
else|:
literal|"pageid IN (SELECT pageid FROM names "
literal|"WHERE name MATCH ?)"
operator|)
else|:
operator|(
name|NULL
operator|==
name|e
operator|->
name|substr
condition|?
literal|"pageid IN (SELECT pageid FROM keys "
literal|"WHERE key REGEXP ? AND bits& ?)"
else|:
literal|"pageid IN (SELECT pageid FROM keys "
literal|"WHERE key MATCH ? AND bits& ?)"
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|close
condition|)
name|sql_append
argument_list|(
operator|&
name|sql
argument_list|,
operator|&
name|sz
argument_list|,
literal|")"
argument_list|,
name|e
operator|->
name|close
argument_list|)
expr_stmt|;
name|needop
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|sql
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compile a set of string tokens into an expression.  * Tokens in "argv" are assumed to be individual expression atoms (e.g.,  * "(", "foo=bar", etc.).  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|exprcomp
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
name|search
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|toopen
decl_stmt|,
name|logic
decl_stmt|,
name|igncase
decl_stmt|,
name|toclose
decl_stmt|;
name|struct
name|expr
modifier|*
name|first
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|first
operator|=
name|cur
operator|=
name|NULL
expr_stmt|;
name|logic
operator|=
name|igncase
operator|=
name|toclose
operator|=
literal|0
expr_stmt|;
name|toopen
operator|=
name|NULL
operator|!=
name|search
operator|->
name|sec
operator|||
name|NULL
operator|!=
name|search
operator|->
name|arch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"("
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|igncase
condition|)
goto|goto
name|fail
goto|;
name|toopen
operator|++
expr_stmt|;
name|toclose
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|")"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|toopen
operator|||
name|logic
operator|||
name|igncase
operator|||
name|NULL
operator|==
name|cur
condition|)
goto|goto
name|fail
goto|;
name|cur
operator|->
name|close
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|>
operator|--
name|toclose
condition|)
goto|goto
name|fail
goto|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"-a"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|toopen
operator|||
name|logic
operator|||
name|igncase
operator|||
name|NULL
operator|==
name|cur
condition|)
goto|goto
name|fail
goto|;
name|logic
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"-o"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|toopen
operator|||
name|logic
operator|||
name|igncase
operator|||
name|NULL
operator|==
name|cur
condition|)
goto|goto
name|fail
goto|;
name|logic
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"-i"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|igncase
condition|)
goto|goto
name|fail
goto|;
name|igncase
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|next
operator|=
name|exprterm
argument_list|(
name|search
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|igncase
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|next
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|==
name|first
condition|)
name|first
operator|=
name|next
expr_stmt|;
else|else
name|cur
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|prev
operator|=
name|cur
operator|=
name|next
expr_stmt|;
comment|/* 		 * Searching for descriptions must be split out 		 * because they are stored in the mpages table, 		 * not in the keys table. 		 */
for|for
control|(
name|mask
operator|=
name|TYPE_Nm
init|;
name|mask
operator|<=
name|TYPE_Nd
condition|;
name|mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|mask
operator|&
name|cur
operator|->
name|bits
operator|&&
operator|~
name|mask
operator|&
name|cur
operator|->
name|bits
condition|)
block|{
name|next
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|next
argument_list|,
name|cur
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|cur
operator|->
name|bits
operator|=
name|mask
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
name|cur
operator|->
name|bits
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
block|}
name|prev
operator|->
name|and
operator|=
operator|(
literal|1
operator|==
name|logic
operator|)
expr_stmt|;
name|prev
operator|->
name|open
operator|+=
name|toopen
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|prev
condition|)
name|cur
operator|->
name|close
operator|=
literal|1
expr_stmt|;
name|toopen
operator|=
name|logic
operator|=
name|igncase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|toopen
operator|||
name|logic
operator|||
name|igncase
operator|||
name|toclose
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|!=
name|search
operator|->
name|sec
operator|||
name|NULL
operator|!=
name|search
operator|->
name|arch
condition|)
name|cur
operator|->
name|close
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|search
operator|->
name|arch
condition|)
name|cur
operator|=
name|exprspec
argument_list|(
name|cur
argument_list|,
name|TYPE_arch
argument_list|,
name|search
operator|->
name|arch
argument_list|,
literal|"^(%s|any)$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|search
operator|->
name|sec
condition|)
name|exprspec
argument_list|(
name|cur
argument_list|,
name|TYPE_sec
argument_list|,
name|search
operator|->
name|sec
argument_list|,
literal|"^%s$"
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|NULL
operator|!=
name|first
condition|)
name|exprfree
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|exprspec
parameter_list|(
name|struct
name|expr
modifier|*
name|cur
parameter_list|,
name|uint64_t
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|char
name|errbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|irc
decl_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
name|format
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|->
name|and
operator|=
literal|1
expr_stmt|;
name|cur
operator|->
name|bits
operator|=
name|key
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|irc
operator|=
name|regcomp
argument_list|(
operator|&
name|cur
operator|->
name|regexp
argument_list|,
name|cp
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
operator||
name|REG_ICASE
argument_list|)
operator|)
condition|)
block|{
name|regerror
argument_list|(
name|irc
argument_list|,
operator|&
name|cur
operator|->
name|regexp
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regcomp: %s\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|cur
operator|->
name|substr
operator|=
name|value
expr_stmt|;
block|}
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|exprterm
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
name|search
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cs
parameter_list|)
block|{
name|char
name|errbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|uint64_t
name|iterbit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irc
decl_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|buf
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|e
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|->
name|argmode
operator|==
name|ARG_NAME
condition|)
block|{
name|e
operator|->
name|bits
operator|=
name|TYPE_Nm
expr_stmt|;
name|e
operator|->
name|substr
operator|=
name|buf
expr_stmt|;
name|e
operator|->
name|equal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
comment|/* 	 * Separate macro keys from search string. 	 * If needed, request regular expression handling 	 * by setting e->substr to NULL. 	 */
if|if
condition|(
name|search
operator|->
name|argmode
operator|==
name|ARG_WORD
condition|)
block|{
name|e
operator|->
name|bits
operator|=
name|TYPE_Nm
expr_stmt|;
name|e
operator|->
name|substr
operator|=
name|NULL
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|val
argument_list|,
literal|"[[:<:]]%s[[:>:]]"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|strpbrk
argument_list|(
name|buf
argument_list|,
literal|"=~"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|bits
operator|=
name|TYPE_Nm
operator||
name|TYPE_Nd
expr_stmt|;
name|e
operator|->
name|substr
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|==
name|buf
condition|)
name|e
operator|->
name|bits
operator|=
name|TYPE_Nm
operator||
name|TYPE_Nd
expr_stmt|;
if|if
condition|(
literal|'='
operator|==
operator|*
name|val
condition|)
name|e
operator|->
name|substr
operator|=
name|val
operator|+
literal|1
expr_stmt|;
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"arch"
argument_list|)
condition|)
name|cs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Compile regular expressions. */
if|if
condition|(
name|NULL
operator|==
name|e
operator|->
name|substr
condition|)
block|{
name|irc
operator|=
name|regcomp
argument_list|(
operator|&
name|e
operator|->
name|regexp
argument_list|,
name|val
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
operator||
operator|(
name|cs
condition|?
literal|0
else|:
name|REG_ICASE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|->
name|argmode
operator|==
name|ARG_WORD
condition|)
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|irc
condition|)
block|{
name|regerror
argument_list|(
name|irc
argument_list|,
operator|&
name|e
operator|->
name|regexp
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regcomp: %s\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|bits
condition|)
return|return
operator|(
name|e
operator|)
return|;
comment|/* 	 * Parse out all possible fields. 	 * If the field doesn't resolve, bail. 	 */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|key
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|","
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|key
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iterbit
operator|=
literal|1
init|;
name|i
operator|<
name|mansearch_keymax
condition|;
name|i
operator|++
operator|,
name|iterbit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|key
argument_list|,
name|mansearch_keynames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|e
operator|->
name|bits
operator||=
name|iterbit
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|mansearch_keymax
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"any"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|e
operator|->
name|bits
operator||=
operator|~
literal|0ULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exprfree
parameter_list|(
name|struct
name|expr
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|pp
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|p
condition|)
block|{
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hash_calloc
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|mandoc_calloc
argument_list|(
name|nmemb
argument_list|,
name|sz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hash_alloc
parameter_list|(
name|size_t
name|sz
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|mandoc_malloc
argument_list|(
name|sz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

