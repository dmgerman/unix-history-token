begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * $Id$  */
end_comment

begin_include
include|#
directive|include
file|<linux/version.h>
end_include

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|0
argument_list|)
end_if

begin_define
define|#
directive|define
name|__irq_h
value|1
end_define

begin_comment
comment|/* stop it being included! */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_LINUX_TCP_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/ip.h>
end_include

begin_include
include|#
directive|include
file|"ipf-linux.h"
end_include

begin_include
include|#
directive|include
file|<net/checksum.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<linux/random.h>
end_include

begin_include
include|#
directive|include
file|<asm/ioctls.h>
end_include

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|10
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|sysctl_ip_default_ttl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|ipf_main_softc_t
name|ipfmain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|ipid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ipf_timer_func
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ipf_send_ip
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
expr|struct
name|sk_buff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipfmutex_t
name|ipl_mutex
decl_stmt|,
name|ipf_auth_mx
decl_stmt|,
name|ipf_rw
decl_stmt|,
name|ipf_stinsert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipfmutex_t
name|ipf_nat_new
decl_stmt|,
name|ipf_natio
decl_stmt|,
name|ipf_timeoutlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipfrwlock_t
name|ipf_mutex
decl_stmt|,
name|ipf_global
decl_stmt|,
name|ipf_ipidfrag
decl_stmt|,
name|ipf_frcache
decl_stmt|,
name|ipf_tokens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipfrwlock_t
name|ipf_frag
decl_stmt|,
name|ipf_state
decl_stmt|,
name|ipf_nat
decl_stmt|,
name|ipf_natfrag
decl_stmt|,
name|ipf_authlk
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|18
argument_list|)
end_if

begin_function_decl
specifier|extern
name|int
name|ip_finish_output
parameter_list|(
name|struct
name|sk_buff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|u_int
name|ipf_linux_inout
name|__P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|sk_buff
operator|*
operator|,
specifier|const
expr|struct
name|net_device
operator|*
operator|,
specifier|const
expr|struct
name|net_device
operator|*
operator|,
name|int
argument_list|(
operator|*
name|okfn
argument_list|)
argument_list|(
expr|struct
name|sk_buff
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|u_int
name|ipf_linux_inout
name|__P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|sk_buff
operator|*
operator|*
operator|,
specifier|const
expr|struct
name|net_device
operator|*
operator|,
specifier|const
expr|struct
name|net_device
operator|*
operator|,
name|int
argument_list|(
operator|*
name|okfn
argument_list|)
argument_list|(
expr|struct
name|sk_buff
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|0
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|nf_hook_ops
name|ipf_hooks
index|[]
init|=
block|{
block|{
operator|.
name|hook
operator|=
name|ipf_linux_inout
block|,
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|pf
operator|=
name|PF_INET
block|,
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
operator|.
name|hooknum
operator|=
name|NF_INET_PRE_ROUTING
block|,
else|#
directive|else
operator|.
name|hooknum
operator|=
name|NF_IP_PRE_ROUTING
block|,
endif|#
directive|endif
operator|.
name|priority
operator|=
literal|200
block|, 	}
block|,
block|{
operator|.
name|hook
operator|=
name|ipf_linux_inout
block|,
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|pf
operator|=
name|PF_INET
block|,
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
operator|.
name|hooknum
operator|=
name|NF_INET_POST_ROUTING
block|,
else|#
directive|else
operator|.
name|hooknum
operator|=
name|NF_IP_POST_ROUTING
block|,
endif|#
directive|endif
operator|.
name|priority
operator|=
literal|200
block|, 	}
block|,
ifdef|#
directive|ifdef
name|USE_INET6
block|{
operator|.
name|hook
operator|=
name|ipf_linux_inout
block|,
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|pf
operator|=
name|PF_INET6
block|,
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
operator|.
name|hooknum
operator|=
name|NF_INET_PRE_ROUTING
block|,
else|#
directive|else
operator|.
name|hooknum
operator|=
name|NF_IP_PRE_ROUTING
block|,
endif|#
directive|endif
operator|.
name|priority
operator|=
literal|200
block|, 	}
block|,
block|{
operator|.
name|hook
operator|=
name|ipf_linux_inout
block|,
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|pf
operator|=
name|PF_INET6
block|,
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
operator|.
name|hooknum
operator|=
name|NF_INET_POST_ROUTING
block|,
else|#
directive|else
operator|.
name|hooknum
operator|=
name|NF_IP_POST_ROUTING
block|,
endif|#
directive|endif
operator|.
name|priority
operator|=
literal|200
block|, 	}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|nf_hook_ops
name|ipf_hooks
index|[]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* list */
name|ipf_linux_inout
block|,
comment|/* hook */
name|PF_INET
block|,
comment|/* pf */
name|NF_IP_PRE_ROUTING
block|,
comment|/* hooknum */
literal|200
comment|/* priority */
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* list */
name|ipf_linux_inout
block|,
comment|/* hook */
name|PF_INET
block|,
comment|/* pf */
name|NF_IP_POST_ROUTING
block|,
comment|/* hooknum */
literal|200
comment|/* priority */
block|}
block|,
ifdef|#
directive|ifdef
name|USE_INET6
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* list */
name|ipf_linux_inout
block|,
comment|/* hook */
name|PF_INET6
block|,
comment|/* pf */
name|NF_IP_PRE_ROUTING
block|,
comment|/* hooknum */
literal|200
comment|/* priority */
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* list */
name|ipf_linux_inout
block|,
comment|/* hook */
name|PF_INET6
block|,
comment|/* pf */
name|NF_IP_POST_ROUTING
block|,
comment|/* hooknum */
literal|200
comment|/* priority */
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Filter ioctl interface.  */
end_comment

begin_function
name|int
name|ipf_ioctl
parameter_list|(
name|struct
name|inode
modifier|*
name|in
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|u_long
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|unit
init|=
literal|0
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|unit
operator|=
name|MINOR
argument_list|(
name|in
operator|->
name|i_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>
name|IPL_LOGMAX
condition|)
return|return
operator|-
name|ENXIO
return|;
if|if
condition|(
name|ipfmain
operator|.
name|ipf_running
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|unit
operator|!=
name|IPL_LOGIPF
operator|&&
name|cmd
operator|!=
name|SIOCIPFINTERROR
condition|)
return|return
operator|-
name|EIO
return|;
if|if
condition|(
name|cmd
operator|!=
name|SIOCIPFGETNEXT
operator|&&
name|cmd
operator|!=
name|SIOCIPFGET
operator|&&
name|cmd
operator|!=
name|SIOCIPFSET
operator|&&
name|cmd
operator|!=
name|SIOCFRENB
operator|&&
name|cmd
operator|!=
name|SIOCGETFS
operator|&&
name|cmd
operator|!=
name|SIOCGETFF
operator|&&
name|cmd
operator|!=
name|SIOCIPFINTERROR
condition|)
return|return
operator|-
name|EIO
return|;
block|}
name|mode
operator|=
name|fp
operator|->
name|f_mode
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|ipf_ioctlswitch
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|unit
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|fp
operator|->
name|f_uid
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
block|{
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|error
operator|=
operator|-
name|error
expr_stmt|;
return|return
name|error
return|;
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|error
operator|=
operator|-
name|error
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|u_32_t
name|ipf_newisn
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|)
block|{
name|u_32_t
name|isn
decl_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
name|i6addr_t
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|fin
operator|->
name|fin_dst
argument_list|,
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fin
operator|->
name|fin_src
argument_list|,
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|isn
operator|=
name|secure_tcpv6_sequence_number
argument_list|(
operator|&
name|dst
operator|.
name|in4
operator|.
name|s_addr
argument_list|,
operator|&
name|src
operator|.
name|in4
operator|.
name|s_addr
argument_list|,
name|fin
operator|->
name|fin_dport
argument_list|,
name|fin
operator|->
name|fin_sport
argument_list|)
expr_stmt|;
else|#
directive|else
name|isn
operator|=
name|secure_tcp_sequence_number
argument_list|(
name|fin
operator|->
name|fin_daddr
argument_list|,
name|fin
operator|->
name|fin_saddr
argument_list|,
name|fin
operator|->
name|fin_dport
argument_list|,
name|fin
operator|->
name|fin_sport
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|isn
return|;
block|}
end_function

begin_function
name|int
name|ipf_send_reset
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|)
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|,
modifier|*
name|tcp2
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|hlen
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_checkl4sum
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|m
operator|=
name|skb_copy
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|tlen
operator|=
operator|(
name|tcp
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|tcp2
argument_list|)
expr_stmt|;
name|skb_trim
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|=
name|MTOD
argument_list|(
name|m
argument_list|,
name|ip_t
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
name|tcp2
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tcp2
argument_list|)
operator|)
expr_stmt|;
name|tcp2
operator|->
name|th_dport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|tcp2
operator|->
name|th_sport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_ACK
condition|)
block|{
name|tcp2
operator|->
name|th_seq
operator|=
name|tcp
operator|->
name|th_ack
expr_stmt|;
name|tcp2
operator|->
name|th_flags
operator|=
name|TH_RST
expr_stmt|;
block|}
else|else
block|{
name|tcp2
operator|->
name|th_ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|tcp2
operator|->
name|th_ack
operator|+=
name|tlen
expr_stmt|;
name|tcp2
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|tcp2
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|tcp2
operator|->
name|th_flags
operator|=
name|TH_RST
operator||
name|TH_ACK
expr_stmt|;
block|}
name|tcp2
operator|->
name|th_off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcp2
argument_list|)
operator|>>
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
name|ip6
operator|->
name|ip6_src
operator|=
name|fin
operator|->
name|fin_dst6
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|fin
operator|->
name|fin_src6
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_TCP
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|fin
operator|->
name|fin_daddr
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|fin
operator|->
name|fin_saddr
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|tcp2
operator|->
name|th_sum
operator|=
name|fr_cksum
argument_list|(
name|fin
argument_list|,
name|ip
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|tcp2
argument_list|)
expr_stmt|;
block|}
return|return
name|ipf_send_ip
argument_list|(
name|fin
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * On input, ip_len is in network byte order  */
end_comment

begin_function
specifier|static
name|int
name|ipf_send_ip
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|sk
parameter_list|)
block|{
name|fr_info_t
name|fnew
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|,
modifier|*
name|oip
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|ip
operator|=
name|MTOD
argument_list|(
name|sk
argument_list|,
name|ip_t
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fnew
argument_list|,
sizeof|sizeof
argument_list|(
name|fnew
argument_list|)
argument_list|)
expr_stmt|;
name|fnew
operator|.
name|fin_main_soft
operator|=
name|fin
operator|->
name|fin_main_soft
expr_stmt|;
name|oip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_v
condition|)
block|{
case|case
literal|4
case|:
name|fnew
operator|.
name|fin_v
operator|=
literal|4
expr_stmt|;
name|fnew
operator|.
name|fin_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fnew
operator|.
name|fin_plen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|oip
operator|->
name|ip_tos
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|10
argument_list|)
name|ip
operator|->
name|ip_ttl
operator|=
name|sysctl_ip_default_ttl
expr_stmt|;
else|#
directive|else
name|ip
operator|->
name|ip_ttl
operator|=
name|IPDEFTTL
expr_stmt|;
endif|#
directive|endif
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0x4000
expr_stmt|;
comment|/* IP_DF */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
break|break;
default|default :
return|return
name|EINVAL
return|;
block|}
name|fnew
operator|.
name|fin_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|fnew
operator|.
name|fin_flx
operator|=
name|FI_NOCKSUM
expr_stmt|;
name|fnew
operator|.
name|fin_m
operator|=
name|sk
expr_stmt|;
name|fnew
operator|.
name|fin_ip
operator|=
name|ip
expr_stmt|;
name|fnew
operator|.
name|fin_mp
operator|=
operator|&
name|sk
expr_stmt|;
name|fnew
operator|.
name|fin_hlen
operator|=
name|hlen
expr_stmt|;
name|fnew
operator|.
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_makefrip
argument_list|(
name|hlen
argument_list|,
name|ip
argument_list|,
operator|&
name|fnew
argument_list|)
expr_stmt|;
return|return
name|ipf_fastroute
argument_list|(
name|sk
argument_list|,
operator|&
name|sk
argument_list|,
operator|&
name|fnew
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ipf_send_icmp_err
parameter_list|(
name|int
name|type
parameter_list|,
name|fr_info_t
modifier|*
name|fin
parameter_list|,
name|int
name|isdst
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|,
name|code
decl_stmt|,
name|leader
decl_stmt|,
name|dlen
decl_stmt|;
name|struct
name|net_device
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_addr
name|dst4
decl_stmt|;
name|struct
name|icmp
modifier|*
name|icmp
decl_stmt|;
name|i6addr_t
name|dst6
decl_stmt|;
name|u_short
name|sz
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
name|mb_t
modifier|*
name|mb
decl_stmt|;
endif|#
directive|endif
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
name|ICMP_MAXTYPE
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|code
operator|=
name|fin
operator|->
name|fin_icode
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
operator|(
name|code
operator|<
literal|0
operator|)
operator|||
operator|(
name|code
operator|>
sizeof|sizeof
argument_list|(
name|icmptoicmp6unreach
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|ipf_checkl4sum
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|m0
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|MIN
argument_list|(
name|M_LEN
argument_list|(
name|m0
argument_list|)
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|dlen
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
name|type
operator|=
name|icmptoicmp6types
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ICMP6_DST_UNREACH
condition|)
name|code
operator|=
name|icmptoicmp6unreach
index|[
name|code
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_ICMP
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
condition|)
switch|switch
condition|(
name|ntohs
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|8
condition|)
block|{
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_TSTAMP
case|:
case|case
name|ICMP_IREQ
case|:
case|case
name|ICMP_MASKREQ
case|:
break|break;
default|default :
return|return
literal|0
return|;
block|}
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
name|dlen
operator|=
literal|8
expr_stmt|;
comment|/* 64 bits of data */
name|sz
operator|+=
name|dlen
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
expr_stmt|;
block|}
name|leader
operator|=
name|m0
operator|->
name|data
operator|-
name|m0
operator|->
name|head
expr_stmt|;
if|if
condition|(
operator|(
name|leader
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|leader
operator|+=
literal|16
operator|-
operator|(
name|leader
operator|&
literal|15
operator|)
expr_stmt|;
name|m
operator|=
name|alloc_skb
argument_list|(
name|sz
operator|+
name|leader
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set the data pointer */
name|skb_reserve
argument_list|(
name|m
argument_list|,
name|leader
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sz
argument_list|)
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
name|skb_put
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|skb_set_network_header
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|ip_hdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|nh
operator|.
name|iph
operator|=
operator|(
expr|struct
name|iphdr
operator|*
operator|)
name|skb_put
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|m
operator|->
name|nh
operator|.
name|iph
expr_stmt|;
endif|#
directive|endif
name|ip
operator|->
name|ip_v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
name|skb_put
argument_list|(
name|m
argument_list|,
name|hlen
operator|+
literal|4
operator|+
name|dlen
argument_list|)
expr_stmt|;
name|skb_set_transport_header
argument_list|(
name|m
argument_list|,
name|hlen
operator|+
literal|4
operator|+
name|dlen
argument_list|)
expr_stmt|;
name|icmp
operator|=
operator|(
name|icmphdr_t
operator|*
operator|)
name|icmp_hdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|h
operator|.
name|icmph
operator|=
operator|(
expr|struct
name|icmphdr
operator|*
operator|)
name|skb_put
argument_list|(
name|m
argument_list|,
name|hlen
operator|+
literal|4
operator|+
name|dlen
argument_list|)
expr_stmt|;
name|icmp
operator|=
operator|(
name|icmphdr_t
operator|*
operator|)
name|m
operator|->
name|h
operator|.
name|icmph
expr_stmt|;
endif|#
directive|endif
name|icmp
operator|->
name|icmp_type
operator|=
name|type
operator|&
literal|0xff
expr_stmt|;
name|icmp
operator|->
name|icmp_code
operator|=
name|code
operator|&
literal|0xff
expr_stmt|;
ifdef|#
directive|ifdef
name|icmp_nextmtu
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ICMP_UNREACH
operator|&&
name|fin
operator|->
name|fin_icode
operator|==
name|ICMP_UNREACH_NEEDFRAG
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_mtu
operator|!=
literal|0
condition|)
block|{
name|icmp
operator|->
name|icmp_nextmtu
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_mtu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|mtu
operator|!=
literal|0
condition|)
block|{
name|icmp
operator|->
name|icmp_nextmtu
operator|=
name|htons
argument_list|(
name|ifp
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|icmp
operator|->
name|icmp_nextmtu
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_plen
operator|-
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
name|int
name|csz
decl_stmt|;
if|if
condition|(
name|isdst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ipf_ifpaddr
argument_list|(
operator|&
name|ipfmain
argument_list|,
literal|6
argument_list|,
name|FRI_NORMAL
argument_list|,
name|fin
operator|->
name|fin_ifp
argument_list|,
operator|&
name|dst6
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|FREE_MB_T
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
name|dst6
operator|=
name|fin
operator|->
name|fin_dst6
expr_stmt|;
name|csz
operator|=
name|sz
expr_stmt|;
name|sz
operator|-=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|sz
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|ip6
operator|->
name|ip6_src
operator|=
name|dst6
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|fin
operator|->
name|fin_src6
expr_stmt|;
name|sz
operator|-=
name|offsetof
argument_list|(
expr|struct
name|icmp
argument_list|,
name|icmp_ip
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|icmp
operator|->
name|icmp_ip
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|icmp
operator|->
name|icmp_cksum
operator|=
name|csz
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ip
operator|=
name|MTOD
argument_list|(
name|m
argument_list|,
name|ip_t
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
operator|(
name|u_short
operator|)
name|sz
expr_stmt|;
if|if
condition|(
name|isdst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ipf_ifpaddr
argument_list|(
operator|&
name|ipfmain
argument_list|,
literal|4
argument_list|,
name|FRI_NORMAL
argument_list|,
name|fin
operator|->
name|fin_ifp
argument_list|,
operator|&
name|dst6
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|FREE_MB_T
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dst4
operator|=
name|dst6
operator|.
name|in4
expr_stmt|;
block|}
else|else
name|dst4
operator|=
name|fin
operator|->
name|fin_dst
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|dst4
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|fin
operator|->
name|fin_src
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|icmp
operator|->
name|icmp_ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
operator|->
name|fin_ip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|fin
operator|->
name|fin_hlen
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|icmp
operator|->
name|icmp_ip
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fin
operator|->
name|fin_ip
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|icmp
operator|->
name|icmp_cksum
operator|=
name|ip_compute_csum
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|icmp
argument_list|,
name|sz
operator|-
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Need to exit out of these so we don't recursively call rw_enter 	 * from fr_qout. 	 */
return|return
name|ipf_send_ip
argument_list|(
name|fin
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ipf_verifysrc
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ipf_checkv4sum
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_NOCKSUM
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fin
operator|->
name|fin_cksum
operator|!=
name|FI_CK_NEEDED
condition|)
return|return
operator|(
name|fin
operator|->
name|fin_cksum
operator|>
name|FI_CK_NEEDED
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
comment|/* 	 * Linux 2.4.20-8smp (RedHat 9) 	 * Because ip_input() on linux clears the checksum flag in the sk_buff 	 * before calling the netfilter hook, it is not possible to take 	 * advantage of the work already done by the hardware. 	 */
if|if
condition|(
name|ipf_checkl4sum
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u_short
name|ipf_nextipid
parameter_list|(
name|fr_info_t
modifier|*
name|fin
parameter_list|)
block|{
if|#
directive|if
literal|1
return|return
name|ipid
operator|++
return|;
else|#
directive|else
name|ip_t
name|ip
decl_stmt|;
name|__ip_select_ident
argument_list|(
operator|&
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ip
operator|.
name|ip_id
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * xmin - pointer to mbuf where the IP packet starts  * mpp - pointer to the mbuf pointer that is the start of the mbuf chain  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|ipf_fastroute
parameter_list|(
name|mb_t
modifier|*
name|xmin
parameter_list|,
name|mb_t
modifier|*
modifier|*
name|mpp
parameter_list|,
name|fr_info_t
modifier|*
name|fin
parameter_list|,
name|frdest_t
modifier|*
name|fdp
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|sifp
decl_stmt|;
name|struct
name|in_addr
name|dip
decl_stmt|;
name|struct
name|rtable
modifier|*
name|rt
decl_stmt|;
name|frdest_t
name|node
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|sout
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|ip
operator|=
name|MTOD
argument_list|(
name|xmin
argument_list|,
name|ip_t
operator|*
argument_list|)
expr_stmt|;
name|dip
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|(
name|fdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_dstlist_select_node
argument_list|(
name|fin
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|)
operator|==
literal|0
condition|)
name|fdp
operator|=
operator|&
name|node
expr_stmt|;
block|}
if|if
condition|(
name|fdp
operator|!=
name|NULL
condition|)
name|ifp
operator|=
name|fdp
operator|->
name|fd_ifp
expr_stmt|;
else|else
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|fr
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_FASTROUTE
operator|)
operator|)
condition|)
block|{
name|err
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|fdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ip
operator|.
name|s_addr
operator|)
condition|)
name|dip
operator|=
name|fdp
operator|->
name|fd_ip
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_v
condition|)
block|{
case|case
literal|4
case|:
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|0
argument_list|)
name|err
operator|=
name|ip_route_output
argument_list|(
operator|&
name|rt
argument_list|,
name|dip
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|,
name|RT_TOS
argument_list|(
name|ip
operator|->
name|ip_tos
argument_list|)
operator||
name|RTO_CONN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|err
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|rt
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|rt
operator|->
name|u
operator|.
name|dst
operator|.
name|dev
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
default|default :
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
block|{
name|sifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|sout
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|fin
operator|->
name|fin_ifp
operator|=
name|ifp
expr_stmt|;
name|fin
operator|->
name|fin_out
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_acctpkt
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fr
operator|||
operator|!
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_RETMASK
operator|)
condition|)
block|{
name|u_32_t
name|pass
decl_stmt|;
operator|(
name|void
operator|)
name|ipf_state_check
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ipf_nat_checkout
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
break|break;
block|}
name|fin
operator|->
name|fin_ifp
operator|=
name|sifp
expr_stmt|;
name|fin
operator|->
name|fin_out
operator|=
name|sout
expr_stmt|;
block|}
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xmin
operator|->
name|dst
operator|!=
name|NULL
condition|)
block|{
name|dst_release
argument_list|(
name|xmin
operator|->
name|dst
argument_list|)
expr_stmt|;
name|xmin
operator|->
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
name|xmin
operator|->
name|dst
operator|=
operator|&
name|rt
operator|->
name|u
operator|.
name|dst
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|4
operator|,
literal|21
argument_list|)
if|if
condition|(
name|xmin
operator|->
name|len
operator|>
name|xmin
operator|->
name|dst
operator|->
name|pmtu
condition|)
block|{
name|err
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|fin
operator|->
name|fin_v
condition|)
block|{
case|case
literal|4
case|:
name|ip
operator|->
name|ip_sum
operator|=
name|ip_fast_csum
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ip
argument_list|,
name|ip
operator|->
name|ip_hl
argument_list|)
expr_stmt|;
name|NF_HOOK
argument_list|(
name|PF_INET
argument_list|,
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
name|NF_INET_LOCAL_OUT
argument_list|,
else|#
directive|else
name|NF_IP_LOCAL_OUT
argument_list|,
endif|#
directive|endif
name|xmin
argument_list|,
name|NULL
argument_list|,
name|ifp
argument_list|,
name|ip_finish_output
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|xmin
operator|!=
name|NULL
condition|)
name|kfree_skb
argument_list|(
name|xmin
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|ipf_ifpaddr
parameter_list|(
name|ipf_main_softc_t
modifier|*
name|softc
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|atype
parameter_list|,
name|void
modifier|*
name|ifptr
parameter_list|,
name|i6addr_t
modifier|*
name|inp
parameter_list|,
name|i6addr_t
modifier|*
name|inpmask
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|,
name|sinmask
decl_stmt|;
name|struct
name|net_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_device
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ifptr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ifptr
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|dev
operator|=
name|ifptr
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|18
argument_list|)
name|ifp
operator|=
name|__in_dev_get_rtnl
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|=
name|__in_dev_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|v
operator|==
literal|4
condition|)
name|inp
operator|->
name|in4
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
name|ifa
operator|=
name|ifp
operator|->
name|ifa_list
expr_stmt|;
while|while
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFA_F_SECONDARY
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sinmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifa
operator|->
name|ifa_mask
expr_stmt|;
if|if
condition|(
name|atype
operator|==
name|FRI_BROADCAST
condition|)
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifa
operator|->
name|ifa_broadcast
expr_stmt|;
elseif|else
if|if
condition|(
name|atype
operator|==
name|FRI_PEERADDR
condition|)
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifa
operator|->
name|ifa_address
expr_stmt|;
else|else
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifa
operator|->
name|ifa_local
expr_stmt|;
return|return
name|ipf_ifpfillv4addr
argument_list|(
name|atype
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sinmask
argument_list|,
operator|&
name|inp
operator|->
name|in4
argument_list|,
operator|&
name|inpmask
operator|->
name|in4
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|m_copydata
parameter_list|(
name|mb_t
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|caddr_t
name|cp
parameter_list|)
block|{
name|bcopy
argument_list|(
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ipfattach
parameter_list|(
name|ipf_main_softc_t
modifier|*
name|softc
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
name|MUTEX_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_rw
argument_list|,
literal|"ipf rw mutex"
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|,
literal|"ipf timeout lock mutex"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|,
literal|"ipf token rwlock"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ipf_hooks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ipf_hooks
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|nf_register_hook
argument_list|(
operator|&
name|ipf_hooks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
block|}
if|if
condition|(
name|ipf_init_all
argument_list|(
name|softc
argument_list|)
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ipf_hooks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ipf_hooks
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|nf_unregister_hook
argument_list|(
operator|&
name|ipf_hooks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ipf_control_forwarding
operator|&
literal|1
condition|)
name|ipv4_devconf
operator|.
name|forwarding
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ipid
operator|=
literal|0
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timer
argument_list|)
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|18
argument_list|)
name|softc
operator|->
name|ipf_timer
operator|.
name|function
operator|=
name|ipf_timer_func
expr_stmt|;
name|softc
operator|->
name|ipf_timer
operator|.
name|data
operator|=
operator|(
name|unsigned
name|long
operator|)
name|softc
expr_stmt|;
else|#
directive|else
name|softc
operator|->
name|ipf_timer
operator|.
name|function
operator|=
name|ipf_timer_func
expr_stmt|;
name|softc
operator|->
name|ipf_timer
operator|.
name|data
operator|=
name|softc
expr_stmt|;
endif|#
directive|endif
name|softc
operator|->
name|ipf_timer
operator|.
name|expires
operator|=
operator|(
name|HZ
operator|/
name|IPF_HZ_DIVIDE
operator|)
operator|*
name|IPF_HZ_MULT
expr_stmt|;
name|add_timer
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timer
argument_list|)
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timer
argument_list|,
name|HZ
operator|/
literal|2
operator|+
name|jiffies
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ipfdetach
parameter_list|(
name|ipf_main_softc_t
modifier|*
name|softc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|del_timer
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timer
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ipf_hooks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ipf_hooks
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|nf_unregister_hook
argument_list|(
operator|&
name|ipf_hooks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ipf_control_forwarding
operator|&
literal|2
condition|)
name|ipv4_devconf
operator|.
name|forwarding
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ipf_fini_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_rw
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_int
name|ipf_linux_inout
argument_list|(
name|hooknum
argument_list|,
name|skbp
argument_list|,
name|inifp
argument_list|,
name|outifp
argument_list|,
name|okfn
argument_list|)
name|u_int
name|hooknum
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
end_if

begin_decl_stmt
name|struct
name|sk_buff
modifier|*
name|skbp
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|sk_buff
modifier|*
modifier|*
name|skbp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|struct
name|net_device
modifier|*
name|inifp
decl_stmt|,
modifier|*
name|outifp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|okfn
function_decl|)
parameter_list|(
name|struct
name|sk_buff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|result
decl_stmt|,
name|hlen
decl_stmt|,
name|dir
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mb_t
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|inifp
operator|==
name|NULL
operator|&&
name|outifp
operator|!=
name|NULL
condition|)
block|{
name|dir
operator|=
name|IPF_OUT
expr_stmt|;
name|ifp
operator|=
operator|(
name|void
operator|*
operator|)
name|outifp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inifp
operator|!=
name|NULL
operator|&&
name|outifp
operator|==
name|NULL
condition|)
block|{
name|dir
operator|=
name|IPF_IN
expr_stmt|;
name|ifp
operator|=
operator|(
name|void
operator|*
operator|)
name|inifp
expr_stmt|;
block|}
else|else
return|return
name|NF_DROP
return|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>=
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
name|sk
operator|=
name|skbp
expr_stmt|;
else|#
directive|else
name|sk
operator|=
operator|*
name|skbp
expr_stmt|;
endif|#
directive|endif
name|ip
operator|=
name|MTOD
argument_list|(
name|sk
argument_list|,
name|ip_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|==
literal|4
condition|)
block|{
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|==
literal|6
condition|)
block|{
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
return|return
name|NF_DROP
return|;
name|result
operator|=
name|ipf_check
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|,
operator|(
expr|struct
name|net_device
operator|*
operator|)
name|ifp
argument_list|,
name|dir
argument_list|,
operator|&
name|sk
argument_list|)
expr_stmt|;
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|23
argument_list|)
operator|*
name|skbp
operator|=
name|sk
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is kind of not always right...*skbp == NULL might really be 	 * a drop but Linux expects *skbp != NULL for NF_DROP. 	 */
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
return|return
name|NF_STOLEN
return|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|NF_DROP
return|;
return|return
name|NF_ACCEPT
return|;
block|}
end_block

begin_function
name|INLINE
name|void
name|ipf_read_enter
parameter_list|(
name|ipfrwlock_t
modifier|*
name|rwlk
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPFDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|rwlk
operator|->
name|ipf_magic
operator|!=
literal|0x97dd8b3a
condition|)
block|{
name|printk
argument_list|(
literal|"ipf_read_enter:rwlk %p ipf_magic 0x%x\n"
argument_list|,
name|rwlk
argument_list|,
name|rwlk
operator|->
name|ipf_magic
argument_list|)
expr_stmt|;
name|rwlk
operator|->
name|ipf_magic
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|rwlk
operator|->
name|ipf_magic
operator|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|read_lock_bh
argument_list|(
operator|&
name|rwlk
operator|->
name|ipf_lk
argument_list|)
expr_stmt|;
name|ATOMIC_INC32
argument_list|(
name|rwlk
operator|->
name|ipf_isr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|ipf_write_enter
parameter_list|(
name|ipfrwlock_t
modifier|*
name|rwlk
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPFDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|rwlk
operator|->
name|ipf_magic
operator|!=
literal|0x97dd8b3a
condition|)
block|{
name|printk
argument_list|(
literal|"ipf_write_enter:rwlk %p ipf_magic 0x%x\n"
argument_list|,
name|rwlk
argument_list|,
name|rwlk
operator|->
name|ipf_magic
argument_list|)
expr_stmt|;
name|rwlk
operator|->
name|ipf_magic
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|rwlk
operator|->
name|ipf_magic
operator|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|write_lock_bh
argument_list|(
operator|&
name|rwlk
operator|->
name|ipf_lk
argument_list|)
expr_stmt|;
name|rwlk
operator|->
name|ipf_isw
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|ipf_rw_exit
parameter_list|(
name|ipfrwlock_t
modifier|*
name|rwlk
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPFDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|rwlk
operator|->
name|ipf_magic
operator|!=
literal|0x97dd8b3a
condition|)
block|{
name|printk
argument_list|(
literal|"ipf_rw_exit:rwlk %p ipf_magic 0x%x\n"
argument_list|,
name|rwlk
argument_list|,
name|rwlk
operator|->
name|ipf_magic
argument_list|)
expr_stmt|;
name|rwlk
operator|->
name|ipf_magic
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|rwlk
operator|->
name|ipf_magic
operator|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rwlk
operator|->
name|ipf_isw
operator|>
literal|0
condition|)
block|{
name|rwlk
operator|->
name|ipf_isw
operator|=
literal|0
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|rwlk
operator|->
name|ipf_lk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rwlk
operator|->
name|ipf_isr
operator|>
literal|0
condition|)
block|{
name|ATOMIC_DEC32
argument_list|(
name|rwlk
operator|->
name|ipf_isr
argument_list|)
expr_stmt|;
name|read_unlock_bh
argument_list|(
operator|&
name|rwlk
operator|->
name|ipf_lk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"rwlk->ipf_isw %d isr %d rwlk %p name [%s]\n"
argument_list|,
name|rwlk
operator|->
name|ipf_isw
argument_list|,
name|rwlk
operator|->
name|ipf_isr
argument_list|,
name|rwlk
argument_list|,
name|rwlk
operator|->
name|ipf_lname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is not a perfect solution for a downgrade because we can lose the lock  * on the object of desire.  */
end_comment

begin_function
name|INLINE
name|void
name|ipf_rw_downgrade
parameter_list|(
name|ipfrwlock_t
modifier|*
name|rwlk
parameter_list|)
block|{
name|ipf_rw_exit
argument_list|(
name|rwlk
argument_list|)
expr_stmt|;
name|ipf_read_enter
argument_list|(
name|rwlk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipf_rw_init
parameter_list|(
name|rwlck
parameter_list|,
name|name
parameter_list|)
name|ipfrwlock_t
modifier|*
name|rwlck
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|memset
argument_list|(
name|rwlck
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rwlck
argument_list|)
argument_list|)
expr_stmt|;
name|rwlck
operator|->
name|ipf_lname
operator|=
name|name
expr_stmt|;
name|rwlock_init
argument_list|(
operator|&
name|rwlck
operator|->
name|ipf_lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void dumpskbuff(sk) 	struct sk_buff *sk; { 	char line[80], *t; 	u_char *s1, *s2; 	int len, i; 	u_char c;  	while (sk != NULL) { 		len = sk->end - sk->data;  		for (s1 = MTOD(sk, char *); len> 0; ) { 			t = line; 			s2 = s1; 			for (i = 0; i< len&& i< 16; i++)  { 				c = *s2++; 				sprintf(t, "%02x", c); 				t += 2; 				if (i&1) 					*t++ = ' '; 			} 			*t++ = ' '; 			*t++ = ' '; 			for (i = 0; i< len&& i< 16; i++)  { 				c = *s1++; 				*t++ = (c>= 32&& c< 127) ? c : '.'; 			} 			*t = '\0'; 			printf("%p@%03d %s\n", sk, s1 - MTOD(sk, u_char *), line); 			if (len> 16) { 				len -= 16; 				s1 += 16; 			} else 				len = 0; 		} 		sk = sk->next; 	} }
endif|#
directive|endif
end_endif

begin_function
name|mb_t
modifier|*
name|m_pullup
parameter_list|(
name|mb_t
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
name|M_LEN
argument_list|(
name|m
argument_list|)
condition|)
return|return
name|m
return|;
name|kfree_skb
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pullup                                                  */
end_comment

begin_comment
comment|/* Returns:     NULL == pullup failed, else pointer to protocol header      */
end_comment

begin_comment
comment|/* Parameters:  xmin(I)- pointer to buffer where data packet starts         */
end_comment

begin_comment
comment|/*              fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              len(I) - number of bytes to pullup                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Attempt to move at least len bytes (from the start of the buffer) into a */
end_comment

begin_comment
comment|/* single buffer for ease of access.  Operating system native functions are */
end_comment

begin_comment
comment|/* used to manage buffers - if necessary.  If the entire packet ends up in  */
end_comment

begin_comment
comment|/* a single buffer, set the FI_COALESCE flag even though ipf_coalesce() has */
end_comment

begin_comment
comment|/* not been called.  Both fin_ip and fin_dp are updated before exiting _IF_ */
end_comment

begin_comment
comment|/* and ONLY if the pullup succeeds.                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* We assume that 'min' is a pointer to a buffer that is part of the chain  */
end_comment

begin_comment
comment|/* of buffers that starts at *fin->fin_mp.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_pullup
parameter_list|(
name|mb_t
modifier|*
name|xmin
parameter_list|,
name|fr_info_t
modifier|*
name|fin
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|dpoff
decl_stmt|,
name|ipoff
decl_stmt|;
name|mb_t
modifier|*
name|m
init|=
name|xmin
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ip
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_COALESCE
operator|)
operator|!=
literal|0
condition|)
return|return
name|ip
return|;
name|ipoff
operator|=
name|fin
operator|->
name|fin_ipoff
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dp
operator|!=
name|NULL
condition|)
name|dpoff
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
operator|(
name|char
operator|*
operator|)
name|ip
expr_stmt|;
else|else
name|dpoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|M_LEN
argument_list|(
name|m
argument_list|)
operator|<
name|len
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|m
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ip
operator|=
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ipoff
expr_stmt|;
block|}
name|fin
operator|->
name|fin_ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dp
operator|!=
name|NULL
condition|)
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|dpoff
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fraghdr
operator|!=
name|NULL
condition|)
name|fin
operator|->
name|fin_fraghdr
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_fraghdr
operator|-
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|fin
operator|->
name|fin_plen
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_COALESCE
expr_stmt|;
return|return
name|ip
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ipf_random
end_ifndef

begin_comment
comment|/*  * In the face of no kernel random function, this is implemented...it is  * not meant to be random, just a fill in.  */
end_comment

begin_function
name|int
name|ipf_random
parameter_list|()
block|{
specifier|static
name|int
name|last
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|calls
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|number
decl_stmt|;
name|GETKTIME
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|last
operator|*=
name|tv
operator|.
name|tv_usec
operator|+
name|calls
operator|++
expr_stmt|;
name|last
operator|+=
operator|(
name|int
operator|)
operator|&
name|range
operator|*
name|ipfmain
operator|.
name|ipf_ticks
expr_stmt|;
name|number
operator|=
name|last
operator|+
name|tv
operator|.
name|tv_sec
expr_stmt|;
return|return
name|number
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ipf_inject
parameter_list|(
name|fin
parameter_list|,
name|m
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
block|{
name|FREE_MB_T
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data from a buffer back into the indicated mbuf chain,  * starting "off" bytes from the beginning, extending the mbuf  * chain if necessary.  */
end_comment

begin_function
name|void
name|m_copyback
parameter_list|(
name|m0
parameter_list|,
name|off0
parameter_list|,
name|len0
parameter_list|,
name|cp
parameter_list|)
name|mb_t
modifier|*
name|m0
decl_stmt|;
name|int
name|off0
decl_stmt|;
name|int
name|len0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
block|{
name|mb_t
modifier|*
name|m
init|=
name|m0
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|totlen
init|=
literal|0
decl_stmt|;
name|int
name|mlen
decl_stmt|;
name|int
name|off
init|=
name|off0
decl_stmt|;
name|int
name|len
init|=
name|len0
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|off
operator|>
operator|(
name|mlen
operator|=
name|m
operator|->
name|len
operator|)
condition|)
block|{
name|off
operator|-=
name|mlen
expr_stmt|;
name|totlen
operator|+=
name|mlen
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|alloc_skb
argument_list|(
name|off
argument_list|,
name|in_interrupt
argument_list|()
condition|?
name|GFP_ATOMIC
else|:
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
name|n
operator|->
name|len
operator|=
name|off
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|mlen
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|len
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|off
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|mlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|mlen
expr_stmt|;
name|len
operator|-=
name|mlen
expr_stmt|;
name|mlen
operator|+=
name|off
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|totlen
operator|+=
name|mlen
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|alloc_skb
argument_list|(
name|len
argument_list|,
name|in_interrupt
argument_list|()
condition|?
name|GFP_ATOMIC
else|:
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
name|n
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ipf_timer_func
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
operator|(
name|ipf_main_softc_t
operator|*
operator|)
name|value
decl_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
name|ipf_slowtimer
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|==
operator|-
literal|1
operator|||
name|softc
operator|->
name|ipf_running
operator|==
literal|1
condition|)
name|mod_timer
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timer
argument_list|,
name|HZ
operator|/
literal|2
operator|+
name|jiffies
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_function
name|INLINE
name|void
name|ipf_checkv6sum
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFILTER_CKSUM
if|if
condition|(
name|fr_checkl4sum
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

