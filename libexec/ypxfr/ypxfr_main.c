begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ypxfr_main.c,v 1.9 1997/03/28 15:48:21 imp Exp $  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_struct
struct|struct
name|dom_binding
block|{}
struct|;
end_struct

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/ypxfrd.h>
end_include

begin_include
include|#
directive|include
file|"ypxfr_extern.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ypxfr_main.c,v 1.9 1997/03/28 15:48:21 imp Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"ypxfr"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yp_dir
init|=
name|_PATH_YP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rpcpmstart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ypxfr_use_yplib
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assume the worst. */
end_comment

begin_decl_stmt
name|int
name|ypxfr_clear
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ypxfr_prognum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|ypxfr_callback_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yppushresp_xfr
name|ypxfr_resp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DB
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ypxfr_exit
parameter_list|(
name|retval
parameter_list|,
name|temp
parameter_list|)
name|ypxfrstat
name|retval
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|clnt
decl_stmt|;
name|int
name|sock
init|=
name|RPC_ANYSOCK
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
comment|/* Clean up no matter what happened previously. */
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dbp
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|temp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to unlink %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_rpcpmstart
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
literal|20
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|clnt
operator|=
name|clntudp_create
argument_list|(
operator|&
name|ypxfr_callback_addr
argument_list|,
name|ypxfr_prognum
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|,
operator|&
name|sock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s"
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"failed to \ establish callback handle"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ypxfr_resp
operator|.
name|status
operator|=
name|retval
expr_stmt|;
if|if
condition|(
name|yppushproc_xfrresp_1
argument_list|(
operator|&
name|ypxfr_resp
argument_list|,
name|clnt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s"
argument_list|,
name|clnt_sperror
argument_list|(
name|clnt
argument_list|,
literal|"callback failed"
argument_list|)
argument_list|)
expr_stmt|;
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yp_error
argument_list|(
literal|"Exiting: %s"
argument_list|,
name|ypxfrerr_string
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
if|if
condition|(
name|_rpcpmstart
condition|)
block|{
name|ypxfr_exit
argument_list|(
name|YPXFR_BADARGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-f] [-c] [-d target domain] \ [-h source host] [-s source domain]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t     [-p path] [-C taskid program-number \ ipaddr port] mapname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ypxfr_foreach
parameter_list|(
name|status
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|,
name|val
parameter_list|,
name|vallen
parameter_list|,
name|data
parameter_list|)
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|vallen
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|DBT
name|dbkey
decl_stmt|,
name|dbval
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|YP_TRUE
condition|)
return|return
operator|(
name|status
operator|)
return|;
comment|/* 	 * XXX Do not attempt to write zero-length keys or 	 * data into a Berkeley DB hash database. It causes a 	 * strange failure mode where sequential searches get 	 * caught in an infinite loop. 	 */
if|if
condition|(
name|keylen
condition|)
block|{
name|dbkey
operator|.
name|data
operator|=
name|key
expr_stmt|;
name|dbkey
operator|.
name|size
operator|=
name|keylen
expr_stmt|;
block|}
else|else
block|{
name|dbkey
operator|.
name|data
operator|=
literal|""
expr_stmt|;
name|dbkey
operator|.
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vallen
condition|)
block|{
name|dbval
operator|.
name|data
operator|=
name|val
expr_stmt|;
name|dbval
operator|.
name|size
operator|=
name|vallen
expr_stmt|;
block|}
else|else
block|{
name|dbval
operator|.
name|data
operator|=
literal|""
expr_stmt|;
name|dbval
operator|.
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|dbkey
argument_list|,
operator|&
name|dbval
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
return|return
operator|(
name|yp_errno
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|ypxfr_force
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ypxfr_dest_domain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ypxfr_source_host
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ypxfr_source_domain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ypxfr_local_domain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ypxfr_master
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|ypxfr_order
init|=
operator|-
literal|1
decl_stmt|,
name|ypxfr_skew_check
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|ypxfr_mapname
init|=
name|NULL
decl_stmt|;
name|int
name|ypxfr_args
init|=
literal|0
decl_stmt|;
name|char
name|ypxfr_temp_map
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|tempmap
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|int
name|remoteport
decl_stmt|;
name|int
name|interdom
init|=
literal|0
decl_stmt|;
name|int
name|secure
init|=
literal|0
decl_stmt|;
name|debug
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|openlog
argument_list|(
name|progname
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|_rpcpmstart
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fcd:h:s:p:C:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|my_optind
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|ypxfr_force
operator|++
expr_stmt|;
name|ypxfr_args
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ypxfr_clear
operator|=
literal|0
expr_stmt|;
name|ypxfr_args
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ypxfr_dest_domain
operator|=
name|optarg
expr_stmt|;
name|ypxfr_args
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|ypxfr_source_host
operator|=
name|optarg
expr_stmt|;
name|ypxfr_args
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ypxfr_source_domain
operator|=
name|optarg
expr_stmt|;
name|ypxfr_args
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|yp_dir
operator|=
name|optarg
expr_stmt|;
name|ypxfr_args
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* 			 * Whoever decided that the -C flag should take 			 * four arguments is a twit. 			 */
name|my_optind
operator|=
name|optind
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|my_optind
index|]
operator|==
name|NULL
operator|||
operator|!
name|strlen
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"transaction ID not specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|ypxfr_resp
operator|.
name|transid
operator|=
name|atol
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
expr_stmt|;
name|my_optind
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|my_optind
index|]
operator|==
name|NULL
operator|||
operator|!
name|strlen
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"RPC program number not specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|ypxfr_prognum
operator|=
name|atol
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
expr_stmt|;
name|my_optind
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|my_optind
index|]
operator|==
name|NULL
operator|||
operator|!
name|strlen
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"address not specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|,
operator|&
name|ypxfr_callback_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to convert '%s' to IP addr"
argument_list|,
name|argv
index|[
name|my_optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|my_optind
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|my_optind
index|]
operator|==
name|NULL
operator|||
operator|!
name|strlen
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"port not specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|ypxfr_callback_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|atoi
argument_list|(
name|argv
index|[
name|my_optind
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_args
operator|+=
literal|5
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|ypxfr_mapname
operator|=
name|argv
index|[
name|ypxfr_args
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ypxfr_mapname
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"no map name specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* Always the case. */
name|ypxfr_callback_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
comment|/* Determine if local NIS client facilities are turned on. */
if|if
condition|(
operator|!
name|yp_get_default_domain
argument_list|(
operator|&
name|ypxfr_local_domain
argument_list|)
operator|&&
name|_yp_check
argument_list|(
operator|&
name|ypxfr_local_domain
argument_list|)
condition|)
name|ypxfr_use_yplib
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If no destination domain is specified, assume that the 	 * local default domain is to be used and try to obtain it. 	 * Fails if NIS client facilities are turned off. 	 */
if|if
condition|(
name|ypxfr_dest_domain
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ypxfr_use_yplib
condition|)
block|{
name|yp_get_default_domain
argument_list|(
operator|&
name|ypxfr_dest_domain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yp_error
argument_list|(
literal|"no destination domain specified and \ the local domain name isn't set"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_BADARGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If a source domain is not specified, assume it to 	 * be the same as the destination domain. 	 */
if|if
condition|(
name|ypxfr_source_domain
operator|==
name|NULL
condition|)
block|{
name|ypxfr_source_domain
operator|=
name|ypxfr_dest_domain
expr_stmt|;
block|}
comment|/* 	 * If the source host is not specified, assume it to be the 	 * master for the specified map. If local NIS client facilities 	 * are turned on, we can figure this out using yp_master(). 	 * If not, we have to see if a local copy of the map exists 	 * and extract its YP_MASTER_NAME record. If _that_ fails, 	 * we are stuck and must ask the user for more information. 	 */
if|if
condition|(
name|ypxfr_source_host
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ypxfr_use_yplib
condition|)
block|{
comment|/* 		 * Double whammy: NIS isn't turned on and the user 		 * didn't specify a source host. 		 */
name|char
modifier|*
name|dptr
decl_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|ypxfr_dest_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"no source host specified"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_BADARGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dptr
operator|=
name|data
operator|.
name|data
expr_stmt|;
name|dptr
index|[
name|data
operator|.
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ypxfr_master
operator|=
name|ypxfr_source_host
operator|=
name|strdup
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ypxfr_use_yplib
condition|)
name|ypxfr_use_yplib
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ypxfr_master
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ypxfr_master
operator|=
name|ypxfr_get_master
argument_list|(
name|ypxfr_source_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
name|ypxfr_source_host
argument_list|,
name|ypxfr_use_yplib
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to find master of %s in domain %s: %s"
argument_list|,
name|ypxfr_mapname
argument_list|,
name|ypxfr_source_domain
argument_list|,
name|ypxfrerr_string
argument_list|(
name|yp_errno
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_MADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we got here and ypxfr_source_host is still undefined, 	 * it means we had to resort to using yp_master() to find the 	 * master server for the map. The source host and master should 	 * be identical. 	 */
if|if
condition|(
name|ypxfr_source_host
operator|==
name|NULL
condition|)
name|ypxfr_source_host
operator|=
name|ypxfr_master
expr_stmt|;
comment|/* 	 * Don't talk to ypservs on unprivileged ports. 	 */
name|remoteport
operator|=
name|getrpcport
argument_list|(
name|ypxfr_source_host
argument_list|,
name|YPPROG
argument_list|,
name|YPVERS
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|remoteport
operator|>=
name|IPPORT_RESERVED
condition|)
block|{
name|yp_error
argument_list|(
literal|"ypserv on %s not running on reserved port"
argument_list|,
name|ypxfr_source_host
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_REFUSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ypxfr_order
operator|=
name|ypxfr_get_order
argument_list|(
name|ypxfr_source_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
name|ypxfr_master
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to get order number of %s: %s"
argument_list|,
name|ypxfr_mapname
argument_list|,
name|yp_errno
operator|==
name|YPXFR_SUCC
condition|?
literal|"map has order 0"
else|:
name|ypxfrerr_string
argument_list|(
name|yp_errno
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_YPERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ypxfr_match
argument_list|(
name|ypxfr_master
argument_list|,
name|ypxfr_source_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
literal|"YP_INTERDOMAIN"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"YP_INTERDOMAIN"
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|interdom
operator|++
expr_stmt|;
if|if
condition|(
name|ypxfr_match
argument_list|(
name|ypxfr_master
argument_list|,
name|ypxfr_source_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
literal|"YP_SECURE"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"YP_SECURE"
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|secure
operator|++
expr_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_LAST_MODIFIED"
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* The order number is immaterial when the 'force' flag is set. */
if|if
condition|(
operator|!
name|ypxfr_force
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|ypxfr_dest_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
switch|switch
condition|(
name|yp_errno
condition|)
block|{
case|case
name|YP_NOKEY
case|:
name|ypxfr_exit
argument_list|(
name|YPXFR_FORCE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NOMAP
case|:
comment|/* 				 * If the map doesn't exist, we're 				 * creating it. Ignore the error. 				 */
name|ignore
operator|++
expr_stmt|;
break|break;
case|case
name|YP_BADDB
case|:
default|default:
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ignore
operator|&&
name|ypxfr_order
operator|<=
name|atoi
argument_list|(
name|data
operator|.
name|data
argument_list|)
condition|)
name|ypxfr_exit
argument_list|(
name|YPXFR_AGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Construct a temporary map file name */
name|snprintf
argument_list|(
name|tempmap
argument_list|,
sizeof|sizeof
argument_list|(
name|tempmap
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|ypxfr_mapname
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ypxfr_temp_map
argument_list|,
sizeof|sizeof
argument_list|(
name|ypxfr_temp_map
argument_list|)
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|yp_dir
argument_list|,
name|ypxfr_dest_domain
argument_list|,
name|tempmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|remoteport
operator|=
name|getrpcport
argument_list|(
name|ypxfr_source_host
argument_list|,
name|YPXFRD_FREEBSD_PROG
argument_list|,
name|YPXFRD_FREEBSD_VERS
argument_list|,
name|IPPROTO_TCP
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't talk to rpc.ypxfrds on unprovileged ports. */
if|if
condition|(
name|remoteport
operator|>=
name|IPPORT_RESERVED
condition|)
block|{
name|yp_error
argument_list|(
literal|"rpc.ypxfrd on %s not using privileged port"
argument_list|,
name|ypxfr_source_host
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_REFUSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Try to send using ypxfrd. If it fails, use old method. */
if|if
condition|(
operator|!
name|ypxfrd_get_map
argument_list|(
name|ypxfr_source_host
argument_list|,
name|ypxfr_mapname
argument_list|,
name|ypxfr_source_domain
argument_list|,
name|ypxfr_temp_map
argument_list|)
condition|)
goto|goto
name|leave
goto|;
block|}
comment|/* Open the temporary map read/write. */
if|if
condition|(
operator|(
name|dbp
operator|=
name|yp_open_db_rw
argument_list|(
name|ypxfr_dest_domain
argument_list|,
name|tempmap
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to open temporary map file"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the keys we already know, such as the order number, 	 * master name, input file name (we actually make up a bogus 	 * name for that) and output file name. 	 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ypxfr_order
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to write order number to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|ypxfr_master
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|ypxfr_master
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to write master name to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|data
operator|=
literal|"YP_DOMAIN_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_DOMAIN_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|ypxfr_dest_domain
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|ypxfr_dest_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to write domain name to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s:%s"
argument_list|,
name|ypxfr_source_host
argument_list|,
name|ypxfr_mapname
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_INPUT_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_INPUT_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
operator|&
name|buf
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to write input name to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|yp_dir
argument_list|,
name|ypxfr_dest_domain
argument_list|,
name|ypxfr_mapname
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_OUTPUT_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_OUTPUT_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
operator|&
name|buf
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to write output name to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interdom
condition|)
block|{
name|key
operator|.
name|data
operator|=
literal|"YP_INTERDOMAIN"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_INTERDOMAIN"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
literal|""
expr_stmt|;
name|data
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to add interdomain flag to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|secure
condition|)
block|{
name|key
operator|.
name|data
operator|=
literal|"YP_SECURE"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_SECURE"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|data
operator|.
name|data
operator|=
literal|""
expr_stmt|;
name|data
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yp_put_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to add secure flag to database"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_DBM
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now suck over the contents of the map from the master. */
if|if
condition|(
name|ypxfr_get_map
argument_list|(
name|ypxfr_mapname
argument_list|,
name|ypxfr_source_domain
argument_list|,
name|ypxfr_source_host
argument_list|,
name|ypxfr_foreach
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to retrieve map from source host"
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_YPERR
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|NULL
expr_stmt|;
comment|/*<- yes, it seems this is necessary. */
name|leave
label|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|yp_dir
argument_list|,
name|ypxfr_dest_domain
argument_list|,
name|ypxfr_mapname
argument_list|)
expr_stmt|;
comment|/* Peek at the order number again and check for skew. */
if|if
condition|(
operator|(
name|ypxfr_skew_check
operator|=
name|ypxfr_get_order
argument_list|(
name|ypxfr_source_domain
argument_list|,
name|ypxfr_mapname
argument_list|,
name|ypxfr_master
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to get order number of %s: %s"
argument_list|,
name|ypxfr_mapname
argument_list|,
name|yp_errno
operator|==
name|YPXFR_SUCC
condition|?
literal|"map has order 0"
else|:
name|ypxfrerr_string
argument_list|(
name|yp_errno
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_YPERR
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ypxfr_order
operator|!=
name|ypxfr_skew_check
condition|)
name|ypxfr_exit
argument_list|(
name|YPXFR_SKEW
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
comment|/* 	 * Send a YPPROC_CLEAR to the local ypserv. 	 */
if|if
condition|(
name|ypxfr_clear
condition|)
block|{
name|char
name|in
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|int
name|stat
decl_stmt|;
if|if
condition|(
operator|(
name|stat
operator|=
name|callrpc
argument_list|(
literal|"localhost"
argument_list|,
name|YPPROG
argument_list|,
name|YPVERS
argument_list|,
name|YPPROC_CLEAR
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|in
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|void
operator|*
operator|)
name|out
argument_list|)
operator|)
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to send 'clear' to local ypserv: %s"
argument_list|,
name|clnt_sperrno
argument_list|(
operator|(
expr|enum
name|clnt_stat
operator|)
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_CLEAR
argument_list|,
operator|&
name|ypxfr_temp_map
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Put the new map in place immediately. I'm not sure if the 	 * kernel does an unlink() and rename() atomically in the event 	 * that we move a new copy of a map over the top of an existing 	 * one, but there's less chance of a race condition happening 	 * than if we were to do the unlink() ourselves. 	 */
if|if
condition|(
name|rename
argument_list|(
name|ypxfr_temp_map
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"rename(%s,%s) failed: %s"
argument_list|,
name|ypxfr_temp_map
argument_list|,
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ypxfr_exit
argument_list|(
name|YPXFR_FILE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ypxfr_exit
argument_list|(
name|YPXFR_SUCC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

