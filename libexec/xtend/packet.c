begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1995 Eugene W. Stark  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Eugene W. Stark.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY EUGENE W. STARK (THE AUTHOR) ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"xtend.h"
end_include

begin_include
include|#
directive|include
file|"xten.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|X10housenames
index|[]
init|=
block|{
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|X10cmdnames
index|[]
init|=
block|{
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"AllUnitsOff"
block|,
literal|"AllLightsOn"
block|,
literal|"On"
block|,
literal|"Off"
block|,
literal|"Dim"
block|,
literal|"Bright"
block|,
literal|"AllLightsOff"
block|,
literal|"ExtendedCode"
block|,
literal|"HailRequest"
block|,
literal|"HailAcknowledge"
block|,
literal|"PreSetDim0"
block|,
literal|"PreSetDim1"
block|,
literal|"ExtendedData"
block|,
literal|"StatusOn"
block|,
literal|"StatusOff"
block|,
literal|"StatusRequest"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Log a packet and update device status accordingly  */
end_comment

begin_function
name|void
name|logpacket
parameter_list|(
name|p
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"%s:  %s %s "
argument_list|,
name|thedate
argument_list|()
argument_list|,
name|X10housenames
index|[
name|p
index|[
literal|1
index|]
index|]
argument_list|,
name|X10cmdnames
index|[
name|p
index|[
literal|2
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&
name|TW_RCV_LOCAL
condition|)
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"(loc,"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"(rem,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&
name|TW_RCV_ERROR
condition|)
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"err)"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|" ok)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received packet p, updating device status information both  * in core and on disk.  */
end_comment

begin_function
name|void
name|processpacket
parameter_list|(
name|p
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|h
decl_stmt|,
name|k
decl_stmt|;
name|STATUS
modifier|*
name|s
decl_stmt|;
comment|/*    * If the packet had the error flag set, there is no other useful info.    */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&
name|TW_RCV_ERROR
condition|)
return|return;
comment|/*    * First update in-core status information for the device.    */
name|h
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|k
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|16
condition|)
block|{
comment|/* We received a unit code, to select a particular device */
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|k
index|]
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|SELECTED
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We received a key code, to execute some function */
comment|/*      * Change in status depends on the key code received      */
if|if
condition|(
name|k
operator|==
name|DIM
condition|)
block|{
comment|/*        * We can't really track DIM/BRIGHT properly the way things are right        * now.  The TW523 reports the first, fourth, seventh, etc. Dim packet.        * We don't really have any way to tell when gaps occur, to cancel        * selection.  For now, we'll assume that successive sequences of        * Dim/Bright commands are never transmitted without some other        * intervening command, and we make a good guess about how many units of        * dim/bright are represented by each packet actually reported by the        * TW523.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|selected
condition|)
block|{
case|case
name|SELECTED
case|:
comment|/* Selected, but not being dimmed or brightened */
if|if
condition|(
name|s
operator|->
name|onoff
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
block|}
name|s
operator|->
name|brightness
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|brightness
operator|<
literal|0
condition|)
name|s
operator|->
name|brightness
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|DIMMING
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIMMING
case|:
comment|/* Selected and being dimmed */
name|s
operator|->
name|brightness
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|brightness
operator|<
literal|0
condition|)
name|s
operator|->
name|brightness
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BRIGHTENING
case|:
comment|/* Selected and being brightened (an error) */
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|==
name|BRIGHT
condition|)
block|{
comment|/*        * Same problem here...        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|selected
condition|)
block|{
case|case
name|SELECTED
case|:
comment|/* Selected, but not being dimmed or brightened */
if|if
condition|(
name|s
operator|->
name|onoff
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
block|}
name|s
operator|->
name|brightness
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|brightness
operator|>
literal|15
condition|)
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|BRIGHTENING
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIMMING
case|:
comment|/* Selected and being dimmed (an error) */
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BRIGHTENING
case|:
comment|/* Selected and being brightened */
name|s
operator|->
name|brightness
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|brightness
operator|>
literal|15
condition|)
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Other key codes besides Bright and Dim */
comment|/*        * We cancel brightening and dimming on ALL units on ALL house codes,        * because the arrival of a different packet indicates a gap that        * terminates any prior sequence of brightening and dimming        */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|BRIGHTENING
operator|||
name|s
operator|->
name|selected
operator|==
name|DIMMING
condition|)
block|{
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|ALLUNITSOFF
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|onoff
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ALLLIGHTSON
case|:
comment|/* Does AllLightsOn cancel selectedness of non-lights? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|devcap
operator|&
name|ISLIGHT
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UNITON
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|SELECTED
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|15
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UNITOFF
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|SELECTED
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ALLLIGHTSOFF
case|:
comment|/* Does AllLightsOff cancel selectedness of non-lights? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|devcap
operator|&
name|ISLIGHT
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXTENDEDCODE
case|:
break|break;
case|case
name|HAILREQUEST
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|SELECTED
condition|)
block|{
name|s
operator|->
name|selected
operator|=
name|HAILED
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HAILACKNOWLEDGE
case|:
comment|/* Do these commands cancel selection of devices not affected? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|HAILED
condition|)
block|{
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PRESETDIM0
case|:
case|case
name|PRESETDIM1
case|:
comment|/* I don't really understand these */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|SELECTED
condition|)
block|{
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXTENDEDDATA
case|:
comment|/* Who knows?  The TW523 can't receive these anyway. */
break|break;
case|case
name|STATUSON
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|REQUESTED
condition|)
block|{
name|s
operator|->
name|onoff
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|STATUSOFF
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|selected
operator|==
name|REQUESTED
condition|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|onoff
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|selected
operator|=
name|IDLE
expr_stmt|;
name|s
operator|->
name|brightness
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
case|case
name|STATUSREQUEST
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|Status
index|[
name|h
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|selected
condition|)
block|{
name|s
operator|->
name|selected
operator|=
name|REQUESTED
expr_stmt|;
name|s
operator|->
name|lastchange
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

end_unit

