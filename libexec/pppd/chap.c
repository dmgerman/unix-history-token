begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * chap.c - Crytographic Handshake Authentication Protocol.  *  * Copyright (c) 1991 Gregory M. Christy.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Gregory M. Christy.  The name of the author may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/*  * TODO:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/ppp.h>
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_decl_stmt
name|chap_state
name|chap
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CHAP state; one for each unit */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ChapTimeout
name|__ARGS
argument_list|(
operator|(
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapReceiveChallenge
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapReceiveResponse
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapReceiveSuccess
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapReceiveFailure
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapSendStatus
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapSendChallenge
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapSendResponse
name|__ARGS
argument_list|(
operator|(
name|chap_state
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChapGenChallenge
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|drand48
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|srand48
name|__ARGS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ChapInit - Initialize a CHAP unit.  */
end_comment

begin_function
name|void
name|ChapInit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cstate
operator|->
name|chal_str
index|[
literal|0
index|]
operator|=
literal|'\000'
expr_stmt|;
name|cstate
operator|->
name|chal_len
operator|=
literal|0
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_CLOSED
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_CLOSED
expr_stmt|;
name|cstate
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cstate
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|cstate
operator|->
name|timeouttime
operator|=
name|CHAP_DEFTIMEOUT
expr_stmt|;
name|cstate
operator|->
name|retransmits
operator|=
literal|0
expr_stmt|;
name|srand48
argument_list|(
operator|(
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* joggle random number generator */
block|}
end_function

begin_comment
comment|/*  * ChapAuthWithPeer - Authenticate us with our peer (start client).  *  */
end_comment

begin_function
name|void
name|ChapAuthWithPeer
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|flags
operator|&=
operator|~
name|CHAPF_AWPPENDING
expr_stmt|;
comment|/* Clear pending flag */
comment|/* Protect against programming errors that compromise security */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_CLOSED
operator|||
name|cstate
operator|->
name|flags
operator|&
name|CHAPF_APPENDING
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapAuthWithPeer: we were called already!"
argument|)
argument_list|)
return|return;
block|}
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_CHALLENGE_SENT
operator|||
comment|/* should we be here? */
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_OPEN
condition|)
return|return;
comment|/* Lower layer up? */
if|if
condition|(
operator|!
operator|(
name|cstate
operator|->
name|flags
operator|&
name|CHAPF_LOWERUP
operator|)
condition|)
block|{
name|cstate
operator|->
name|flags
operator||=
name|CHAPF_AWPPENDING
expr_stmt|;
comment|/* Nah, Wait */
return|return;
block|}
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
comment|/* crank it up dude! */
name|TIMEOUT
argument_list|(
name|ChapTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cstate
argument_list|,
name|cstate
operator|->
name|timeouttime
argument_list|)
expr_stmt|;
comment|/* set-up timeout */
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_CHALLENGE_SENT
expr_stmt|;
comment|/* update state */
name|cstate
operator|->
name|retransmits
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapAuthPeer - Authenticate our peer (start server).  */
end_comment

begin_function
name|void
name|ChapAuthPeer
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|flags
operator|&=
operator|~
name|CHAPF_APPENDING
expr_stmt|;
comment|/* Clear pending flag */
comment|/* Already authenticat{ed,ing}? */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_LISTEN
operator|||
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_OPEN
condition|)
return|return;
comment|/* Lower layer up? */
if|if
condition|(
operator|!
operator|(
name|cstate
operator|->
name|flags
operator|&
name|CHAPF_LOWERUP
operator|)
condition|)
block|{
name|cstate
operator|->
name|flags
operator||=
name|CHAPF_APPENDING
expr_stmt|;
comment|/* Wait for desired event */
return|return;
block|}
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_LISTEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapTimeout - Timeout expired.  */
end_comment

begin_function
specifier|static
name|void
name|ChapTimeout
parameter_list|(
name|arg
parameter_list|)
name|caddr_t
name|arg
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|(
name|chap_state
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* if we aren't sending challenges, don't worry.  then again we */
comment|/* probably shouldn't be here either */
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_CHALLENGE_SENT
condition|)
return|return;
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
comment|/* Send challenge */
name|TIMEOUT
argument_list|(
name|ChapTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cstate
argument_list|,
name|cstate
operator|->
name|timeouttime
argument_list|)
expr_stmt|;
operator|++
name|cstate
operator|->
name|retransmits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapLowerUp - The lower layer is up.  *  * Start up if we have pending requests.  */
end_comment

begin_function
name|void
name|ChapLowerUp
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|flags
operator||=
name|CHAPF_LOWERUP
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|flags
operator|&
name|CHAPF_AWPPENDING
condition|)
comment|/* were we attempting authwithpeer? */
name|ChapAuthWithPeer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Try it now */
if|if
condition|(
name|cstate
operator|->
name|flags
operator|&
name|CHAPF_APPENDING
condition|)
comment|/* or authpeer? */
name|ChapAuthPeer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapLowerDown - The lower layer is down.  *  * Cancel all timeouts.  */
end_comment

begin_function
name|void
name|ChapLowerDown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|flags
operator|&=
operator|~
name|CHAPF_LOWERUP
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_CHALLENGE_SENT
condition|)
comment|/* Timeout pending? */
name|UNTIMEOUT
argument_list|(
name|ChapTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cstate
argument_list|)
expr_stmt|;
comment|/* Cancel timeout */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_OPEN
condition|)
comment|/* have we successfully authed? */
name|LOGOUT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_CLOSED
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_CLOSED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapProtocolReject - Peer doesn't grok CHAP.  */
end_comment

begin_function
name|void
name|ChapProtocolReject
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|ChapLowerDown
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* shutdown chap */
comment|/* Note: should we bail here if chap is required? */
block|}
end_function

begin_comment
comment|/*  * ChapInput - Input CHAP packet.  */
end_comment

begin_function
name|void
name|ChapInput
parameter_list|(
name|unit
parameter_list|,
name|inpacket
parameter_list|,
name|packet_len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|inpacket
decl_stmt|;
name|int
name|packet_len
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|code
decl_stmt|,
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*    * Parse header (code, id and length).    * If packet too short, drop it.    */
name|inp
operator|=
name|inpacket
expr_stmt|;
if|if
condition|(
name|packet_len
operator|<
name|CHAP_HEADERLEN
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapInput: rcvd short header."
argument|)
argument_list|)
return|return;
block|}
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|CHAP_HEADERLEN
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapInput: rcvd illegal length."
argument|)
argument_list|)
return|return;
block|}
if|if
condition|(
name|len
operator|>
name|packet_len
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapInput: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|len
operator|-=
name|CHAP_HEADERLEN
expr_stmt|;
comment|/*    * Action depends on code.    */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAP_CHALLENGE
case|:
name|ChapReceiveChallenge
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_RESPONSE
case|:
name|ChapReceiveResponse
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_FAILURE
case|:
name|ChapReceiveFailure
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_SUCCESS
case|:
name|ChapReceiveSuccess
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Need code reject? */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unknown CHAP code (%d) received."
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * ChapReceiveChallenge - Receive Challenge.  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveChallenge
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
name|rchallenge_len
decl_stmt|;
name|u_char
modifier|*
name|rchallenge
decl_stmt|;
name|u_char
name|secret
index|[
name|MAX_SECRET_LEN
index|]
decl_stmt|;
name|int
name|secret_len
decl_stmt|;
name|u_char
name|rhostname
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveChallenge: Rcvd id %d."
argument|, id)
argument_list|)
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_LISTEN
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveChallenge: received challenge but not in listen state"
argument|)
argument_list|)
return|return;
block|}
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveChallenge: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|GETCHAR
argument_list|(
name|rchallenge_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|rchallenge_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveChallenge: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|rchallenge
operator|=
name|inp
expr_stmt|;
name|INCPTR
argument_list|(
name|rchallenge_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|inp
argument_list|,
name|rhostname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rhostname
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveChallenge: received name field: %s"
argument|, 	     rhostname)
argument_list|)
name|GETSECRET
argument_list|(
name|rhostname
argument_list|,
name|secret
argument_list|,
operator|&
name|secret_len
argument_list|)
expr_stmt|;
comment|/* get secret for specified host */
name|BCOPY
argument_list|(
name|rchallenge
argument_list|,
name|buf
argument_list|,
name|rchallenge_len
argument_list|)
expr_stmt|;
comment|/* copy challenge into buffer */
name|BCOPY
argument_list|(
name|secret
argument_list|,
name|buf
operator|+
name|rchallenge_len
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
comment|/* append secret */
comment|/*  generate MD based on negotiated type */
switch|switch
condition|(
name|lcp_hisoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|chap_mdtype
condition|)
block|{
case|case
name|CHAP_DIGEST_MD5
case|:
comment|/* only MD5 is defined for now */
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|buf
argument_list|,
name|rchallenge_len
operator|+
name|secret_len
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|ChapSendResponse
argument_list|(
name|cstate
argument_list|,
name|id
argument_list|,
operator|&
name|mdContext
operator|.
name|digest
index|[
literal|0
index|]
argument_list|,
name|MD5_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"unknown digest type %d"
argument|, 	       lcp_hisoptions[cstate->unit].chap_mdtype)
argument_list|)
block|}
block|}
end_function

begin_comment
comment|/*  * ChapReceiveResponse - Receive and process response.  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveResponse
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
modifier|*
name|remmd
decl_stmt|,
name|remmd_len
decl_stmt|;
name|u_char
name|secret
index|[
name|MAX_SECRET_LEN
index|]
decl_stmt|;
name|int
name|secret_len
decl_stmt|;
name|u_char
name|chal_len
init|=
name|cstate
operator|->
name|chal_len
decl_stmt|;
name|u_char
name|code
decl_stmt|;
name|u_char
name|rhostname
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
name|u_char
name|msg
index|[
literal|256
index|]
decl_stmt|,
name|msglen
decl_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveResponse: Rcvd id %d."
argument|, id)
argument_list|)
comment|/* sanity check */
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_CHALLENGE_SENT
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveResponse: received response but did not send a challenge"
argument|)
argument_list|)
return|return;
block|}
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveResponse: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|GETCHAR
argument_list|(
name|remmd_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* get length of MD */
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|remmd_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveResponse: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|remmd
operator|=
name|inp
expr_stmt|;
comment|/* get pointer to MD */
name|INCPTR
argument_list|(
name|remmd_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|inp
argument_list|,
name|rhostname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rhostname
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveResponse: received name field: %s"
argument|, 	     rhostname)
argument_list|)
name|GETSECRET
argument_list|(
name|rhostname
argument_list|,
name|secret
argument_list|,
operator|&
name|secret_len
argument_list|)
expr_stmt|;
comment|/* get secret for specified host */
name|BCOPY
argument_list|(
name|cstate
operator|->
name|chal_str
argument_list|,
name|buf
argument_list|,
name|chal_len
argument_list|)
expr_stmt|;
comment|/* copy challenge */
comment|/* into buffer */
name|BCOPY
argument_list|(
name|secret
argument_list|,
name|buf
operator|+
name|chal_len
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
comment|/* append secret */
comment|/*  generate MD based on negotiated type */
switch|switch
condition|(
name|lcp_gotoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|chap_mdtype
condition|)
block|{
case|case
name|CHAP_DIGEST_MD5
case|:
comment|/* only MD5 is defined for now */
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|buf
argument_list|,
name|chal_len
operator|+
name|secret_len
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
comment|/* compare local and remote MDs and send the appropriate status */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|mdContext
operator|.
name|digest
index|[
literal|0
index|]
argument_list|,
name|remmd
argument_list|,
name|MD5_SIGNATURE_SIZE
argument_list|)
condition|)
name|code
operator|=
name|CHAP_FAILURE
expr_stmt|;
comment|/* they ain't the same */
else|else
name|code
operator|=
name|CHAP_SUCCESS
expr_stmt|;
comment|/* they are the same! */
break|break;
default|default:
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"unknown digest type %d"
argument|, 		 lcp_gotoptions[cstate->unit].chap_mdtype)
argument_list|)
block|}
if|if
condition|(
name|code
operator|==
name|CHAP_SUCCESS
condition|)
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
literal|"Welcome to %s."
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
literal|"I don't like you.  Go 'way."
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ChapSendStatus
argument_list|(
name|cstate
argument_list|,
name|code
argument_list|,
name|id
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
comment|/* only crank up IPCP when either we aren't doing PAP, or if we are, */
comment|/* that it is in open state */
if|if
condition|(
name|code
operator|==
name|CHAP_SUCCESS
condition|)
block|{
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_OPEN
expr_stmt|;
if|if
condition|(
operator|!
name|lcp_hisoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|neg_upap
operator|||
operator|(
name|lcp_hisoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|neg_upap
operator|&&
name|upap
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|us_serverstate
operator|==
name|UPAPSS_OPEN
operator|)
condition|)
name|ipcp_activeopen
argument_list|(
name|cstate
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Start IPCP */
block|}
block|}
end_function

begin_comment
comment|/*  * ChapReceiveSuccess - Receive Success  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveSuccess
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveSuccess: Rcvd id %d."
argument|, id)
argument_list|)
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_CHALLENGE_SENT
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveSuccess: received success, but did not send a challenge."
argument|)
argument_list|)
return|return;
block|}
comment|/*    * Parse message.    */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveSuccess: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|GETCHAR
argument_list|(
name|msglen
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|msglen
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveSuccess: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|msg
operator|=
name|inp
expr_stmt|;
name|PRINTMSG
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_OPEN
expr_stmt|;
comment|/* only crank up IPCP when either we aren't doing PAP, or if we are, */
comment|/* that it is in open state */
if|if
condition|(
operator|!
name|lcp_gotoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|neg_chap
operator|||
operator|(
name|lcp_gotoptions
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|neg_chap
operator|&&
name|upap
index|[
name|cstate
operator|->
name|unit
index|]
operator|.
name|us_serverstate
operator|==
name|UPAPCS_OPEN
operator|)
condition|)
name|ipcp_activeopen
argument_list|(
name|cstate
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Start IPCP */
block|}
end_function

begin_comment
comment|/*  * ChapReceiveFailure - Receive failure.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveFailure
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveFailure: Rcvd id %d."
argument|, id)
argument_list|)
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_CHALLENGE_SENT
condition|)
comment|/* XXX */
return|return;
comment|/*    * Parse message.    */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveFailure: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|GETCHAR
argument_list|(
name|msglen
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|msglen
condition|)
block|{
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapReceiveFailure: rcvd short packet."
argument|)
argument_list|)
return|return;
block|}
name|msg
operator|=
name|inp
expr_stmt|;
name|PRINTMSG
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|flags
operator|&=
operator|~
name|CHAPF_UPVALID
expr_stmt|;
comment|/* Clear valid flag */
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_CLOSED
expr_stmt|;
comment|/* Pretend for a moment */
name|ChapAuthWithPeer
argument_list|(
name|cstate
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Restart */
block|}
end_function

begin_comment
comment|/*  * ChapSendChallenge - Send an Authenticate challenge.  */
end_comment

begin_function
specifier|static
name|void
name|ChapSendChallenge
parameter_list|(
name|cstate
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|u_char
name|chal_len
decl_stmt|;
name|int
name|outlen
decl_stmt|;
comment|/* pick a random challenge length between MIN_CHALLENGE_LENGTH and     MAX_CHALLENGE_LENGTH */
name|cstate
operator|->
name|chal_len
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|drand48
argument_list|()
operator|*
operator|(
name|MAX_CHALLENGE_LENGTH
operator|-
name|MIN_CHALLENGE_LENGTH
operator|)
operator|)
operator|+
name|MIN_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|chal_len
operator|=
name|cstate
operator|->
name|chal_len
expr_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|chal_len
operator|+
name|hostname_len
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|CHAP
argument_list|)
expr_stmt|;
comment|/* paste in a CHAP header */
name|PUTCHAR
argument_list|(
name|CHAP_CHALLENGE
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
operator|++
name|cstate
operator|->
name|id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|chal_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* put length of challenge */
name|ChapGenChallenge
argument_list|(
name|chal_len
argument_list|,
name|cstate
operator|->
name|chal_str
argument_list|)
expr_stmt|;
comment|/* generate a challenge string */
name|BCOPY
argument_list|(
name|cstate
operator|->
name|chal_str
argument_list|,
name|outp
argument_list|,
name|chal_len
argument_list|)
expr_stmt|;
comment|/* copy it the the output buffer */
name|INCPTR
argument_list|(
name|chal_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|hostname
argument_list|,
name|outp
argument_list|,
name|hostname_len
argument_list|)
expr_stmt|;
comment|/* append hostname */
name|INCPTR
argument_list|(
name|hostname_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|DLLHEADERLEN
argument_list|)
expr_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapSendChallenge: Sent id %d."
argument|, cstate->id)
argument_list|)
name|cstate
operator|->
name|clientstate
operator||=
name|CHAPCS_CHALLENGE_SENT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapSendStatus - Send a status response (ack or nak).  */
end_comment

begin_function
specifier|static
name|void
name|ChapSendStatus
parameter_list|(
name|cstate
parameter_list|,
name|code
parameter_list|,
name|id
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
name|code
decl_stmt|,
name|id
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
name|msglen
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|CHAP
argument_list|)
expr_stmt|;
comment|/* paste in a header */
name|PUTCHAR
argument_list|(
name|code
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|msg
argument_list|,
name|outp
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|DLLHEADERLEN
argument_list|)
expr_stmt|;
name|CHAPDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"ChapSendStatus: Sent code %d, id %d."
argument|, code, id)
argument_list|)
block|}
end_function

begin_comment
comment|/*  * ChapGenChallenge is used to generate a pseudo-random challenge string of  * a pseudo-random length between min_len and max_len and return the  * challenge string, and the message digest of the secret appended to  * the challenge string.  the message digest type is specified by mdtype.  *  * It returns with the string in the caller-supplied buffer str (which  * should be instantiated with a length of max_len + 1), and the  * length of the generated string into chal_len.  *  */
end_comment

begin_function
specifier|static
name|void
name|ChapGenChallenge
parameter_list|(
name|chal_len
parameter_list|,
name|str
parameter_list|)
name|u_char
name|chal_len
decl_stmt|;
name|u_char
modifier|*
name|str
decl_stmt|;
block|{
name|u_char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* generate a random string */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chal_len
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|drand48
argument_list|()
operator|*
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
comment|/* null terminate it so we can printf it */
block|}
end_function

begin_comment
comment|/*  * ChapSendResponse - send a response packet with the message  *                      digest specified by md and md_len  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ChapSendResponse
parameter_list|(
name|cstate
parameter_list|,
name|id
parameter_list|,
name|md
parameter_list|,
name|md_len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|u_char
modifier|*
name|md
decl_stmt|;
name|int
name|md_len
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|md_len
operator|+
name|hostname_len
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|CHAP
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CHAP_RESPONSE
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* we are a response */
name|PUTCHAR
argument_list|(
name|id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* copy id from challenge packet */
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* packet length */
name|PUTCHAR
argument_list|(
name|md_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* length of MD */
name|BCOPY
argument_list|(
name|md
argument_list|,
name|outp
argument_list|,
name|md_len
argument_list|)
expr_stmt|;
comment|/* copy MD to buffer */
name|INCPTR
argument_list|(
name|md_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|hostname
argument_list|,
name|outp
argument_list|,
name|hostname_len
argument_list|)
expr_stmt|;
comment|/* append hostname */
name|INCPTR
argument_list|(
name|hostname_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|DLLHEADERLEN
argument_list|)
expr_stmt|;
comment|/* bomb's away! */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DRAND48
end_ifdef

begin_function
name|double
name|drand48
parameter_list|()
block|{
return|return
operator|(
name|double
operator|)
name|random
argument_list|()
operator|/
operator|(
name|double
operator|)
literal|0x7fffffffL
return|;
comment|/* 2**31-1 */
block|}
end_function

begin_function
name|void
name|srand48
parameter_list|(
name|seedval
parameter_list|)
name|long
name|seedval
decl_stmt|;
block|{
name|srand
argument_list|(
operator|(
name|int
operator|)
name|seedval
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

