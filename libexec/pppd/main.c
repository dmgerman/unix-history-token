begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * main.c - Point-to-Point Protocol main module  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/*  * There are three scenarios:  * 1.  pppd used as daemon started from /etc/rc or perhaps /etc/ttys.  *	a.  server  *	b.  authentication necessary  *	c.  want to use constant local ip addr  *	d.  want to use constant remote ip addr, constant ip addr based on  *	    authenticated user, or request ip addr  * 2.  pppd used on /dev/tty after remote login.  *	a.  server  *	b.  no authentication necessary or allowed  *	c.  want to use constant local ip addr  *	d.  want to use constant remote ip addr, constant ip addr based on  *	    authenticated user, or request ip addr  * 3.  pppd used on line after tip'ing out.  *	a.  client  *	b.  remote end may request authentication  *	c.  want to use constant local ip addr or request ip addr  *	d.  want to use constant remote ip addr based on tip'd host, or  *	    request remote ip addr  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_include
include|#
directive|include
file|"ppp_str.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEVNAME_SIZE
value|128
end_define

begin_comment
comment|/* Buffer size for /dev filenames */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_define
define|#
directive|define
name|BSD
value|43
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BSD*/
end_comment

begin_include
include|#
directive|include
file|<net/ppp.h>
end_include

begin_include
include|#
directive|include
file|"magic.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*TRUE*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FALSE*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIDPATH
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pidpath
init|=
name|PIDPATH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename in which pid will be */
end_comment

begin_comment
comment|/* stored */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pidpath
init|=
name|_PATH_PIDFILE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIDFILE */
end_comment

begin_decl_stmt
specifier|static
name|char
name|uinfopath
index|[
name|DEVNAME_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface vars */
end_comment

begin_decl_stmt
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface name */
end_comment

begin_decl_stmt
name|int
name|ifunit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface unit number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of this program */
end_comment

begin_decl_stmt
name|char
name|hostname
index|[
name|MAX_HOSTNAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
name|u_char
name|hostname_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname length */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our pid */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|pgrpid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process Group ID */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pidfilename
index|[
name|DEVNAME_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|devname
index|[
name|DEVNAME_SIZE
index|]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device name */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_device
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use default device (stdin/out) */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device file descriptor */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initdisc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial TTY discipline */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STREAMS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|initsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial TTY sgttyb */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|termios
name|inittermios
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial TTY TIOCGETA */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|initfdflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial file descriptor flags */
end_comment

begin_decl_stmt
name|u_char
name|outpacket_buf
index|[
name|MTU
operator|+
name|DLLHEADERLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for outgoing packet */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|inpacket_buf
index|[
name|MTU
operator|+
name|DLLHEADERLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for incoming packet */
end_comment

begin_comment
comment|/* configured variables */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flag */
end_comment

begin_decl_stmt
specifier|static
name|char
name|user
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User name */
end_comment

begin_decl_stmt
specifier|static
name|char
name|passwd
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* password */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|connector
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "connect" command */
end_comment

begin_decl_stmt
specifier|static
name|char
name|inspeed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input/Output speed */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|netmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netmask to use on ppp interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|crtscts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use h/w flow control */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nodetach
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't fork */
end_comment

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|hup
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|intr
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|term
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alrm
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|io
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incdebug
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nodebug
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|sigcontext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getuserpasswd
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdebug
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpassive
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noopt
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnovj
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noupap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|requpap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nochap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reqchap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setspeed
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noaccomp
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noasyncmap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noipaddr
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomagicnumber
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setasyncmap
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setvjmode
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmru
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomru
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nopcomp
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setconnector
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdomain
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnetmask
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setcrtscts
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnodetach
name|__ARGS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|str_restore
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ttyname
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXMODULES
value|10
end_define

begin_comment
comment|/* max number of module names that we can save */
end_comment

begin_struct
specifier|static
struct|struct
name|modlist
block|{
name|char
name|modname
index|[
name|FMNAMESZ
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|str_modules
index|[
name|MAXMODULES
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|str_module_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Valid arguments.  */
end_comment

begin_struct
specifier|static
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmd_name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|cmd_func
function_decl|)
parameter_list|()
function_decl|;
block|}
name|cmds
index|[]
init|=
block|{
literal|"-all"
block|,
name|noopt
block|,
comment|/* Don't request/allow any options */
literal|"-ac"
block|,
name|noaccomp
block|,
comment|/* Disable Address/Control compress */
literal|"-am"
block|,
name|noasyncmap
block|,
comment|/* Disable asyncmap negotiation */
literal|"-as"
block|,
name|setasyncmap
block|,
comment|/* set the desired async map */
literal|"-d"
block|,
name|setdebug
block|,
comment|/* Increase debugging level */
literal|"-detach"
block|,
name|setnodetach
block|,
comment|/* don't fork */
literal|"-ip"
block|,
name|noipaddr
block|,
comment|/* Disable IP address negotiation */
literal|"-mn"
block|,
name|nomagicnumber
block|,
comment|/* Disable magic number negotiation */
literal|"-mru"
block|,
name|nomru
block|,
comment|/* Disable mru negotiation */
literal|"-p"
block|,
name|setpassive
block|,
comment|/* Set passive mode */
literal|"-pc"
block|,
name|nopcomp
block|,
comment|/* Disable protocol field compress */
literal|"+ua"
block|,
name|requpap
block|,
comment|/* Require UPAP authentication */
literal|"-ua"
block|,
name|noupap
block|,
comment|/* Don't allow UPAP authentication */
literal|"+chap"
block|,
name|reqchap
block|,
comment|/* Require CHAP authentication */
literal|"-chap"
block|,
name|nochap
block|,
comment|/* Don't allow CHAP authentication */
literal|"-vj"
block|,
name|setnovj
block|,
comment|/* disable VJ compression */
literal|"asyncmap"
block|,
name|setasyncmap
block|,
comment|/* set the desired async map */
literal|"connect"
block|,
name|setconnector
block|,
comment|/* A program to set up a connection */
literal|"crtscts"
block|,
name|setcrtscts
block|,
comment|/* set h/w flow control */
literal|"debug"
block|,
name|setdebug
block|,
comment|/* Increase debugging level */
literal|"domain"
block|,
name|setdomain
block|,
comment|/* Add given domain name to hostname*/
literal|"mru"
block|,
name|setmru
block|,
comment|/* Set MRU value for negotiation */
literal|"netmask"
block|,
name|setnetmask
block|,
comment|/* set netmask */
literal|"passive"
block|,
name|setpassive
block|,
comment|/* Set passive mode */
literal|"vjmode"
block|,
name|setvjmode
block|,
comment|/* set VJ compression mode */
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*  * PPP Data Link Layer "protocol" table.  * One entry per supported protocol.  */
end_comment

begin_struct
specifier|static
struct|struct
name|protent
block|{
name|u_short
name|protocol
decl_stmt|;
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|input
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|protrej
function_decl|)
parameter_list|()
function_decl|;
block|}
name|prottbl
index|[]
init|=
block|{
block|{
name|LCP
block|,
name|lcp_init
block|,
name|lcp_input
block|,
name|lcp_protrej
block|}
block|,
block|{
name|IPCP
block|,
name|ipcp_init
block|,
name|ipcp_input
block|,
name|ipcp_protrej
block|}
block|,
block|{
name|UPAP
block|,
name|upap_init
block|,
name|upap_input
block|,
name|upap_protrej
block|}
block|,
block|{
name|CHAP
block|,
name|ChapInit
block|,
name|ChapInput
block|,
name|ChapProtocolReject
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|usage
init|=
literal|"pppd version %s patch level %d\n\ Usage: %s [ arguments ], where arguments are:\n\ 	-all		Don't request/allow any options\n\ 	-ac		Disable Address/Control compression\n\ 	-am		Disable asyncmap negotiation\n\ 	-as<n>		Set the desired async map to hex<n>\n\ 	-d		Increase debugging level\n\ 	-detach		Don't fork to background\n\ 	-ip		Disable IP address negotiation\n\ 	-mn		Disable magic number negotiation\n\ 	-mru		Disable mru negotiation\n\ 	-p		Set passive mode\n\ 	-pc		Disable protocol field compression\n\ 	+ua<p>		Require UPAP authentication and use file<p> for\n\                         remote login data\n\ 	-ua		Don't allow UPAP authentication\n\ 	+chap		Require CHAP authentication\n\ 	-chap		Don't allow CHAP authentication\n\         -vj             disable VJ compression\n\         connect<p>     Invoke shell command<p> to set up the serial line\n\ 	crtscts		Use hardware RTS/CTS flow control\n\ 	debug		Increase debugging level\n\         domain<d>      Append domain name<d> to hostname for authentication\n\ 	mru<n>		Set MRU value to<n> for negotiation\n\ 	netmask<n>	Set interface netmask to<n>\n\ 	passive		Set passive mode\n\ 	vjmode<m>      VJ compression mode {old, rfc1172, rfc1132 (default)}\n\<device>	Communicate over the named device\n\<speed>		Set the baud rate to<speed>\n\<loc>:<rem>	Set the local and/or remote interface IP\n\ 			addresses.  Either one may be omitted.\n"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sigvec
name|sv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|FILE
modifier|*
name|pidfile
decl_stmt|;
ifndef|#
directive|ifndef
name|STREAMS
name|int
name|pppdisc
init|=
name|PPPDISC
decl_stmt|;
endif|#
directive|endif
comment|/*    * Initialize syslog system and magic number package.    */
if|#
directive|if
name|BSD
operator|>=
literal|43
operator|||
name|defined
argument_list|(
name|sun
argument_list|)
name|openlog
argument_list|(
literal|"pppd"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_PPP
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"pppd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
define|#
directive|define
name|LOG_UPTO
parameter_list|(
name|x
parameter_list|)
value|(x)
define|#
directive|define
name|setlogmask
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAMS
if|if
condition|(
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|strcpy
argument_list|(
name|devname
argument_list|,
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|magic_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
name|MAX_HOSTNAME_LEN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't get hostname: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Initialize to the standard option set and then parse the command    * line arguments.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|init
operator|)
operator|(
literal|0
operator|)
expr_stmt|;
name|progname
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
condition|;
control|)
block|{
comment|/*      * First see if it's a command.      */
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd_name
condition|;
name|cmdp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|cmdp
operator|->
name|cmd_name
argument_list|)
operator|&&
call|(
modifier|*
name|cmdp
operator|->
name|cmd_func
call|)
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
comment|/*      * Maybe a tty name, speed or IP address?      */
if|if
condition|(
name|cmdp
operator|->
name|cmd_name
operator|==
name|NULL
operator|&&
operator|!
name|setdevname
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|&&
operator|!
name|setspeed
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|&&
operator|!
name|setipaddr
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Starting pppd %s patch level %d"
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
comment|/*    * Initialize state.    */
define|#
directive|define
name|SETSID
ifdef|#
directive|ifdef
name|SETSID
if|if
condition|(
name|default_device
condition|)
block|{
comment|/* No device name was specified... inherit the old controlling        terminal */
if|if
condition|(
operator|(
name|pgrpid
operator|=
name|getpgrp
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getpgrp(0): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pgrpid
operator|!=
name|pid
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning... not a process group leader"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*default_device*/
block|{
comment|/* become session leader... */
if|if
condition|(
operator|!
name|nodetach
condition|)
block|{
comment|/* fork so we're not a process group leader */
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|xxx
elseif|else
comment|/* bag controlling terminal */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNOTTY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCNOTTY): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* create new session */
if|if
condition|(
operator|(
name|pgrpid
operator|=
name|setsid
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsid(): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* open i/o device */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
comment|/*| O_NDELAY*/
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open(%s): %m"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* drop dtr to hang up incase modem is off hook */
if|if
condition|(
operator|!
name|default_device
condition|)
block|{
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setdtr
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* set device to be controlling tty */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSCTTY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSCTTY): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* run connection script */
if|if
condition|(
name|connector
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Connecting with<%s>"
argument_list|,
name|connector
argument_list|)
expr_stmt|;
comment|/* set line speed */
name|set_up_tty
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_up_connection
argument_list|(
name|connector
argument_list|,
name|fd
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not set up connection"
argument_list|)
expr_stmt|;
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Connected..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket : %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if we exit, then try and restore the stream */
ifdef|#
directive|ifdef
name|sun
name|on_exit
argument_list|(
name|cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAMS
comment|/* go through and save the name of all the modules, then pop em */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_LOOK
argument_list|,
name|str_modules
index|[
name|str_module_count
index|]
operator|.
name|modname
argument_list|)
condition|)
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"popped stream module : %s"
argument|, 		str_modules[str_module_count].modname)
argument_list|)
if|if
condition|(
operator|!
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
condition|)
name|str_module_count
operator|++
expr_stmt|;
else|else
break|break;
block|}
comment|/* set line speed */
name|set_up_tty
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"about to push modules..."
argument_list|)
expr_stmt|;
comment|/* now push the async/fcs module */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"pppasync"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_PUSH, ppp_async): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* finally, push the ppp_if module that actually handles the */
comment|/* network interface */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"pppif"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_PUSH, ppp_if): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_SETSIG
argument_list|,
name|S_INPUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_SETSIG, S_INPUT): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read mode, message non-discard mode */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_SRDOPT
argument_list|,
name|RMSGN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_SRDOPT, RMSGN): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Flush any waiting messages, or we'll never get SIGPOLL */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_FLUSH
argument_list|,
name|FLUSHRW
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_FLUSH, FLUSHRW): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Find out which interface we were given.    * (ppp_if handles this ioctl)    */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGETU
argument_list|,
operator|&
name|ifunit
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(SIOCGETU): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if debug, set debug flags in driver */
block|{
name|int
name|flags
init|=
name|debug
condition|?
literal|0x3
else|:
literal|0
decl_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"debug 0x%x, flags 0x%x"
argument_list|,
name|debug
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCSIFDEBUG
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(SIOCSIFDEBUG): %m"
argument_list|)
expr_stmt|;
block|}
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"done pushing modules, ifunit %d"
argument_list|,
name|ifunit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* set line speed */
name|set_up_tty
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|initdisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCGETD): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|pppdisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETD): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Find out which interface we were given.    */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PPPIOCGUNIT
argument_list|,
operator|&
name|ifunit
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(PPPIOCGUNIT): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Using interface ppp%d"
argument_list|,
name|ifunit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ppp%d"
argument_list|,
name|ifunit
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pidfilename
argument_list|,
literal|"%s/%s.pid"
argument_list|,
name|pidpath
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
comment|/* write pid to file */
if|if
condition|(
operator|(
name|pidfile
operator|=
name|fopen
argument_list|(
name|pidfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|pidfile
argument_list|,
literal|"%d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
name|hostname_len
operator|=
operator|(
name|u_char
operator|)
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"hostname = %s"
argument|, hostname)
argument_list|)
ifdef|#
directive|ifdef
name|SETSID
if|if
condition|(
name|default_device
condition|)
block|{
name|int
name|id
init|=
name|tcgetpgrp
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|pgrpid
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: pppd is not the leader of a forground process group"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|fd
argument_list|,
name|pgrpid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tcsetpgrp(): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* set process group on tty so we get SIGIO's */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrpid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSPGRP): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*    * Compute mask of all interesting signals and install signal handlers    * for each.  Only one signal handler may be active at a time.  Therefore,    * all other signals should be masked when any handler is executing.    */
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMS
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv
operator|.
name|sv_handler
operator|=
name|hup
expr_stmt|;
comment|/* Hangup */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGHUP)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sv
operator|.
name|sv_handler
operator|=
name|intr
expr_stmt|;
comment|/* Interrupt */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGINT)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sv
operator|.
name|sv_handler
operator|=
name|term
expr_stmt|;
comment|/* Terminate */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGTERM)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sv
operator|.
name|sv_handler
operator|=
name|alrm
expr_stmt|;
comment|/* Timeout */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGALRM)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sv
operator|.
name|sv_handler
operator|=
name|io
expr_stmt|;
comment|/* Input available */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGIO
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGIO)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STREAMS
name|sv
operator|.
name|sv_handler
operator|=
name|io
expr_stmt|;
comment|/* Input available */
name|sv
operator|.
name|sv_mask
operator|=
name|mask
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGPOLL
argument_list|,
operator|&
name|sv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGPOLL)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__STDC__
comment|/* Increment debug flag */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|incdebug
argument_list|)
expr_stmt|;
comment|/* Reset debug flag */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|nodebug
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Increment debug flag */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|incdebug
argument_list|)
expr_stmt|;
comment|/* Reset debug flag */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|nodebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Record initial device flags, then set device to cause SIGIO    * signals to be generated.    */
if|if
condition|(
operator|(
name|initfdflags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_GETFL): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETFL, FNDELAY | FASYNC): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Block all signals, start opening the connection, and  wait for    * incoming signals (reply, timeout, etc.).    */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connect: %s<--> %s"
argument_list|,
name|ifname
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* Block signals now */
name|lcp_lowerup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Well, sort of... */
if|if
condition|(
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|passive
condition|)
name|lcp_passiveopen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start protocol in passive mode */
else|else
name|lcp_activeopen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start protocol in active mode */
for|for
control|(
init|;
condition|;
control|)
block|{
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for next signal */
comment|/* Need to read user/passwd? */
if|if
condition|(
name|upap
index|[
literal|0
index|]
operator|.
name|us_flags
operator|&
name|UPAPF_UPPENDING
condition|)
block|{
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow other signals to occur */
name|getuserpasswd
argument_list|()
expr_stmt|;
comment|/* Get user and passwd */
name|upap
index|[
literal|0
index|]
operator|.
name|us_flags
operator|&=
operator|~
name|UPAPF_UPPENDING
expr_stmt|;
name|upap
index|[
literal|0
index|]
operator|.
name|us_flags
operator||=
name|UPAPF_UPVALID
expr_stmt|;
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* Disallow signals */
name|upap_authwithpeer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|set_up_tty
argument_list|(
argument|fd
argument_list|,
argument|flow
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|STREAMS
name|int
name|new_cflag
decl_stmt|;
name|struct
name|termios
name|tios
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TCGETS): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|new_cflag
operator|=
name|CS8
operator||
name|CREAD
operator||
name|HUPCL
expr_stmt|;
name|new_cflag
operator||=
name|inspeed
condition|?
name|inspeed
else|:
operator|(
name|tios
operator|.
name|c_cflag
operator|&
name|CBAUD
operator|)
expr_stmt|;
if|if
condition|(
name|flow
condition|)
name|new_cflag
operator||=
name|crtscts
condition|?
name|CRTSCTS
else|:
literal|0
expr_stmt|;
name|tios
operator|.
name|c_cflag
operator|=
name|new_cflag
expr_stmt|;
name|tios
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TCSETS): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|SGTTY
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
comment|/*    * Put the tty in raw mode and set the discipline to PPP.    */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|initsgttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCGETP): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sgttyb
operator|=
name|initsgttyb
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator|=
name|RAW
operator||
name|ANYP
expr_stmt|;
if|if
condition|(
name|inspeed
condition|)
name|sgttyb
operator|.
name|sg_ispeed
operator|=
name|inspeed
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETP): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|termios
name|tios
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETA
argument_list|,
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCGETA): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|inittermios
operator|=
name|tios
expr_stmt|;
name|tios
operator|.
name|c_cflag
operator|=
name|CREAD
operator||
name|CS8
operator||
name|HUPCL
expr_stmt|;
if|if
condition|(
name|flow
condition|)
name|tios
operator|.
name|c_cflag
operator||=
name|crtscts
condition|?
name|CRTSCTS
else|:
literal|0
expr_stmt|;
name|tios
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|tios
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETA
argument_list|,
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETA): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * quit - Clean up state and exit.  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Quitting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|initfdflags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETFL, fdflags): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STREAMS
name|str_restore
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|initsgttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETP)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETA
argument_list|,
operator|&
name|inittermios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETA)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|initdisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETD)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* drop dtr to hang up */
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
literal|0
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|callout
modifier|*
name|callout
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callout list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|schedtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time last timeout was set */
end_comment

begin_comment
comment|/*  * timeout - Schedule a timeout.  *  * Note that this timeout takes the number of seconds, NOT hz (as in  * the kernel).  */
end_comment

begin_decl_stmt
name|void
name|timeout
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|time
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
name|newp
decl_stmt|,
modifier|*
modifier|*
name|oldpp
decl_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Timeout %x:%x in %d seconds."
argument|, 	    (int) func, (int) arg, time)
argument_list|)
comment|/*    * Allocate timeout.    */
if|if
condition|(
operator|(
name|newp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|callout
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Out of memory in timeout()!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|newp
operator|->
name|c_arg
operator|=
name|arg
expr_stmt|;
name|newp
operator|->
name|c_func
operator|=
name|func
expr_stmt|;
comment|/*    * Find correct place to link it in and decrement its time by the    * amount of time used by preceding timeouts.    */
for|for
control|(
name|oldpp
operator|=
operator|&
name|callout
init|;
operator|*
name|oldpp
operator|&&
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
operator|<=
name|time
condition|;
name|oldpp
operator|=
operator|&
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_next
control|)
name|time
operator|-=
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
expr_stmt|;
name|newp
operator|->
name|c_time
operator|=
name|time
expr_stmt|;
name|newp
operator|->
name|c_next
operator|=
operator|*
name|oldpp
expr_stmt|;
if|if
condition|(
operator|*
name|oldpp
condition|)
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
operator|-=
name|time
expr_stmt|;
operator|*
name|oldpp
operator|=
name|newp
expr_stmt|;
comment|/*    * If this is now the first callout then we have to set a new    * itimer.    */
if|if
condition|(
name|callout
operator|==
name|newp
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
operator|->
name|c_time
expr_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Setting itimer for %d seconds."
argument|, 	      itv.it_value.tv_sec)
argument_list|)
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * untimeout - Unschedule a timeout.  */
end_comment

begin_decl_stmt
name|void
name|untimeout
argument_list|(
name|func
argument_list|,
name|arg
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
modifier|*
name|copp
decl_stmt|,
modifier|*
name|freep
decl_stmt|;
name|int
name|reschedule
init|=
literal|0
decl_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Untimeout %x:%x."
argument|, (int) func, (int) arg)
argument_list|)
comment|/*    * If the first callout is unscheduled then we have to set a new    * itimer.    */
if|if
condition|(
name|callout
operator|&&
name|callout
operator|->
name|c_func
operator|==
name|func
operator|&&
name|callout
operator|->
name|c_arg
operator|==
name|arg
condition|)
name|reschedule
operator|=
literal|1
expr_stmt|;
comment|/*    * Find first matching timeout.  Add its time to the next timeouts    * time.    */
for|for
control|(
name|copp
operator|=
operator|&
name|callout
init|;
operator|*
name|copp
condition|;
name|copp
operator|=
operator|&
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_next
control|)
if|if
condition|(
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_func
operator|==
name|func
operator|&&
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_arg
operator|==
name|arg
condition|)
block|{
name|freep
operator|=
operator|*
name|copp
expr_stmt|;
operator|*
name|copp
operator|=
name|freep
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
operator|*
name|copp
condition|)
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_time
operator|+=
name|freep
operator|->
name|c_time
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|freep
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reschedule
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
condition|?
name|callout
operator|->
name|c_time
else|:
literal|0
expr_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Setting itimer for %d seconds."
argument|, 	      itv.it_value.tv_sec)
argument_list|)
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjtimeout - Decrement the first timeout by the amount of time since  * it was scheduled.  */
end_comment

begin_function
name|void
name|adjtimeout
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|timediff
decl_stmt|;
if|if
condition|(
name|callout
operator|==
name|NULL
condition|)
return|return;
comment|/*    * Make sure that the clock hasn't been warped dramatically.    * Account for recently expired, but blocked timer by adding    * small fudge factor.    */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|timediff
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|schedtime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|timediff
operator|<
literal|0
operator|||
name|timediff
operator|>
name|callout
operator|->
name|c_time
operator|+
literal|1
condition|)
return|return;
name|callout
operator|->
name|c_time
operator|-=
name|timediff
expr_stmt|;
comment|/* OK, Adjust time */
block|}
end_function

begin_comment
comment|/*  * output - Output PPP packet.  */
end_comment

begin_function
name|void
name|output
parameter_list|(
name|unit
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STREAMS
name|struct
name|strbuf
name|str
decl_stmt|;
name|str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|str
operator|.
name|buf
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|,
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"putmsg"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_WARNING,
literal|"output: unit != 0!"
argument|)
argument_list|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * hup - Catch SIGHUP signal.  *  * Indicates that the physical layer has been disconnected.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|hup
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Hangup (SIGHUP)"
argument_list|)
expr_stmt|;
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_lowerdown
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset connection */
block|}
end_function

begin_comment
comment|/*  * term - Catch SIGTERM signal.  *  * Indicates that we should initiate a graceful disconnect and exit.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|term
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Terminate signal received."
argument_list|)
expr_stmt|;
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close connection */
block|}
end_function

begin_comment
comment|/*  * intr - Catch SIGINT signal (DEL/^C).  *  * Indicates that we should initiate a graceful disconnect and exit.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|intr
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Interrupt received.  Exiting."
argument_list|)
expr_stmt|;
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close connection */
block|}
end_function

begin_comment
comment|/*  * alrm - Catch SIGALRM signal.  *  * Indicates a timeout.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|alrm
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
name|freep
decl_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Alarm"
argument|)
argument_list|)
comment|/*    * Call and free first scheduled timeout and any that were scheduled    * for the same time.    */
while|while
condition|(
name|callout
condition|)
block|{
name|freep
operator|=
name|callout
expr_stmt|;
comment|/* Remove entry before calling */
name|callout
operator|=
name|freep
operator|->
name|c_next
expr_stmt|;
call|(
modifier|*
name|freep
operator|->
name|c_func
call|)
argument_list|(
name|freep
operator|->
name|c_arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|freep
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout
operator|&&
name|callout
operator|->
name|c_time
condition|)
break|break;
block|}
comment|/*    * Set a new itimer if there are more timeouts scheduled.    */
if|if
condition|(
name|callout
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
operator|->
name|c_time
expr_stmt|;
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"Setting itimer for %d seconds."
argument|, 	      itv.it_value.tv_sec)
argument_list|)
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * io - Catch SIGIO signal.  *  * Indicates that incoming data is available.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|io
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_short
name|protocol
decl_stmt|;
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|notime
decl_stmt|;
name|int
name|ready
decl_stmt|;
ifdef|#
directive|ifdef
name|STREAMS
name|struct
name|strbuf
name|str
decl_stmt|;
endif|#
directive|endif
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"IO signal received"
argument|)
argument_list|)
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
comment|/* we do this to see if the SIGIO handler is being invoked for input */
comment|/* ready, or for the socket buffer hitting the low-water mark. */
name|notime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|notime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ready
operator|=
name|select
argument_list|(
literal|32
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|notime
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error in io() select: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ready
operator|==
literal|0
condition|)
block|{
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"IO non-input ready SIGIO occured."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Yup, this is for real */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read all available packets */
name|p
operator|=
name|inpacket_buf
expr_stmt|;
comment|/* point to beggining of packet buffer */
ifdef|#
directive|ifdef
name|STREAMS
name|str
operator|.
name|maxlen
operator|=
name|MTU
operator|+
name|DLLHEADERLEN
expr_stmt|;
name|str
operator|.
name|buf
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|getmsg
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
return|return;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getmsg(fd) %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
condition|)
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"getmsg returns with length 0x%x"
argument|,len)
argument_list|)
if|if
condition|(
name|str
operator|.
name|len
operator|<
literal|0
condition|)
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"getmsg short return length %d"
argument|, 		str.len)
argument_list|)
return|return;
block|}
name|len
operator|=
name|str
operator|.
name|len
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|MTU
operator|+
name|DLLHEADERLEN
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_DEBUG,
literal|"read(fd): EWOULDBLOCK"
argument|)
argument_list|)
return|return;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read(fd): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"End of file on fd!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
name|DLLHEADERLEN
condition|)
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"io(): Received short packet."
argument|)
argument_list|)
return|return;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Skip address and control */
name|GETSHORT
argument_list|(
name|protocol
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|len
operator|-=
name|DLLHEADERLEN
expr_stmt|;
comment|/*      * Toss all non-LCP packets unless LCP is OPEN.      */
if|if
condition|(
name|protocol
operator|!=
name|LCP
operator|&&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|state
operator|!=
name|OPEN
condition|)
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"io(): Received non-LCP packet and LCP is not in open state."
argument|)
argument_list|)
name|dumpbuffer
argument_list|(
name|inpacket_buf
argument_list|,
name|len
operator|+
name|DLLHEADERLEN
argument_list|,
name|LOG_ERR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Upcall the proper protocol input routine.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prottbl
index|[
name|i
index|]
operator|.
name|protocol
operator|==
name|protocol
condition|)
block|{
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|input
operator|)
operator|(
literal|0
operator|,
name|p
operator|,
name|len
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"input: Unknown protocol (%x) received!"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|p
operator|-=
name|DLLHEADERLEN
expr_stmt|;
name|len
operator|+=
name|DLLHEADERLEN
expr_stmt|;
name|lcp_sprotrej
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * cleanup - clean_up before we exit  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|status
parameter_list|,
name|arg
parameter_list|)
name|int
name|status
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
name|adjtimeout
argument_list|()
expr_stmt|;
name|lcp_lowerdown
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|pidfilename
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to unlink pid file: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * demuxprotrej - Demultiplex a Protocol-Reject.  */
end_comment

begin_function
name|void
name|demuxprotrej
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_short
name|protocol
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/*    * Upcall the proper Protocol-Reject routine.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prottbl
index|[
name|i
index|]
operator|.
name|protocol
operator|==
name|protocol
condition|)
block|{
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|protrej
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
return|return;
block|}
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"demuxprotrej: Unrecognized Protocol-Reject for protocol %d!"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * incdebug - Catch SIGUSR1 signal.  *  * Increment debug flag.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|incdebug
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Debug turned ON, Level %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|debug
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nodebug - Catch SIGUSR2 signal.  *  * Turn off debugging.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|nodebug
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|,
name|addr
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_WARNING
argument_list|)
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setdebug - Set debug (command line argument).  */
end_comment

begin_function
specifier|static
name|int
name|setdebug
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|debug
operator|++
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noopt - Disable all options.  */
end_comment

begin_function
specifier|static
name|int
name|noopt
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setconnector - Set a program to connect to a serial line  */
end_comment

begin_function
specifier|static
name|int
name|setconnector
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
name|connector
operator|=
name|strdup
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot allocate space for connector string"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set_up_connection - run a program to initialize the serial connector  */
end_comment

begin_function
name|int
name|set_up_connection
parameter_list|(
name|program
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|status
decl_stmt|;
name|flags
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setreuid
argument_list|(
name|getuid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setregid
argument_list|(
name|getgid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|program
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not exec /bin/sh"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"waiting for connection process"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noaccomp - Disable Address/Control field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noaccomp
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noasyncmap - Disable async map negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noasyncmap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noipaddr - Disable IP address negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noipaddr
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_addrs
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_addrs
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomagicnumber - Disable magic number negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomagicnumber
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomru - Disable mru negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomru
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setmru - Set MRU for negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|setmru
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|mru
operator|=
name|atoi
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nopcomp - Disable Protocol field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nopcomp
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setpassive - Set passive mode.  */
end_comment

begin_function
specifier|static
name|int
name|setpassive
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|passive
operator|=
literal|1
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noupap - Disable UPAP authentication.  */
end_comment

begin_function
specifier|static
name|int
name|noupap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * requpap - Require UPAP authentication.  */
end_comment

begin_function
specifier|static
name|int
name|requpap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|FILE
modifier|*
name|ufile
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
name|strcpy
argument_list|(
name|uinfopath
argument_list|,
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
comment|/* open user info file */
if|if
condition|(
operator|(
name|ufile
operator|=
name|fopen
argument_list|(
name|uinfopath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to open user login data file %s\n"
argument_list|,
name|uinfopath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ufile
argument_list|)
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"cannot stat user login data file!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
literal|077
operator|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Warning - user info file has world and/or group access!\n"
argument_list|)
expr_stmt|;
comment|/* get username */
name|fgets
argument_list|(
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|user
argument_list|)
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to get user name from user login data file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* get rid of newline */
name|user
index|[
name|strlen
argument_list|(
name|user
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\000'
expr_stmt|;
name|fgets
argument_list|(
name|passwd
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|passwd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to get password from user login data file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|passwd
index|[
name|strlen
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\000'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nochap - Disable CHAP authentication.  */
end_comment

begin_function
specifier|static
name|int
name|nochap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reqchap - Require CHAP authentication.  */
end_comment

begin_function
specifier|static
name|int
name|reqchap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	setvjmode - Set vj compression mode  */
end_comment

begin_function
specifier|static
name|int
name|setvjmode
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
specifier|extern
name|int
name|ipcp_vj_mode
decl_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
operator|*
name|argvp
argument_list|,
literal|"old"
argument_list|)
condition|)
block|{
comment|/* "old" mode */
name|ipcp_vj_setmode
argument_list|(
name|IPCP_VJMODE_OLD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
operator|*
name|argvp
argument_list|,
literal|"rfc1172"
argument_list|)
condition|)
block|{
comment|/* "rfc1172" mode*/
name|ipcp_vj_setmode
argument_list|(
name|IPCP_VJMODE_RFC1172
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
operator|*
name|argvp
argument_list|,
literal|"rfc1332"
argument_list|)
condition|)
block|{
comment|/* "rfc1332" default mode */
name|ipcp_vj_setmode
argument_list|(
name|IPCP_VJMODE_RFC1332
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unknown vj compression mode %s. Defaulting to RFC1332"
argument_list|,
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
name|ipcp_vj_setmode
argument_list|(
name|IPCP_VJMODE_RFC1332
argument_list|)
expr_stmt|;
block|}
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	setnovj - diable vj compression  */
end_comment

begin_function
specifier|static
name|int
name|setnovj
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
specifier|extern
name|int
name|ipcp_vj_mode
decl_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdomain - Set domain name to append to hostname   */
end_comment

begin_function
specifier|static
name|int
name|setdomain
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
name|strcat
argument_list|(
name|hostname
argument_list|,
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
name|hostname_len
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Valid speeds.  */
end_comment

begin_struct
struct|struct
name|speed
block|{
name|int
name|speed_int
decl_stmt|,
name|speed_val
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|B50
block|{
literal|50
block|,
name|B50
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B75
block|{
literal|75
block|,
name|B75
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B110
block|{
literal|110
block|,
name|B110
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B150
block|{
literal|150
block|,
name|B150
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B200
block|{
literal|200
block|,
name|B200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B300
block|{
literal|300
block|,
name|B300
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B600
block|{
literal|600
block|,
name|B600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1200
block|{
literal|1200
block|,
name|B1200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1800
block|{
literal|1800
block|,
name|B1800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2000
block|{
literal|2000
block|,
name|B2000
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2400
block|{
literal|2400
block|,
name|B2400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B3600
block|{
literal|3600
block|,
name|B3600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B4800
block|{
literal|4800
block|,
name|B4800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B7200
block|{
literal|7200
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B9600
block|{
literal|9600
block|,
name|B9600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTA
block|{
literal|19200
block|,
name|EXTA
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTB
block|{
literal|38400
block|,
name|EXTB
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|setasyncmap
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|unsigned
name|long
name|asyncmap
decl_stmt|;
name|asyncmap
operator|=
literal|0xffffffff
expr_stmt|;
operator|++
operator|*
name|argvp
expr_stmt|;
name|sscanf
argument_list|(
operator|*
operator|*
name|argvp
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|asyncmap
argument_list|)
expr_stmt|;
operator|++
operator|*
name|argvp
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|asyncmap
operator|=
name|asyncmap
expr_stmt|;
operator|*
name|argcp
operator|-=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setspeed - Set the speed.  */
end_comment

begin_function
specifier|static
name|int
name|setspeed
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|int
name|speed
decl_stmt|;
name|struct
name|speed
modifier|*
name|speedp
decl_stmt|;
name|speed
operator|=
name|atoi
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
for|for
control|(
name|speedp
operator|=
name|speeds
init|;
name|speedp
operator|->
name|speed_int
condition|;
name|speedp
operator|++
control|)
if|if
condition|(
name|speed
operator|==
name|speedp
operator|->
name|speed_int
condition|)
block|{
name|inspeed
operator|=
name|speedp
operator|->
name|speed_val
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdevname - Set the device name.  */
end_comment

begin_function
name|int
name|setdevname
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
name|dev
index|[
name|DEVNAME_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|*
operator|*
name|argvp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
modifier|*
name|ttyname
argument_list|()
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"/dev/"
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dev
argument_list|,
literal|"/dev/%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dev
expr_stmt|;
block|}
comment|/*    * Check if there is a device by this name.    */
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|devname
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|default_device
operator|=
name|FALSE
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
comment|/*    * If we haven't already decided to require authentication,    * or we are running ppp on the control terminal, then we can    * allow authentication to be requested.    */
if|if
condition|(
operator|(
name|tty
operator|=
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tty
operator|=
literal|""
expr_stmt|;
comment|/* running from init means no stdin.  Null kills strcmp -KWK */
if|if
condition|(
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|devname
argument_list|,
literal|"/dev/tty"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|devname
argument_list|,
name|tty
argument_list|)
condition|)
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setipaddr - Set the IP address  */
end_comment

begin_function
name|int
name|setipaddr
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|u_long
name|local
decl_stmt|,
name|remote
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
comment|/*    * IP address pair separated by ":".    */
if|if
condition|(
operator|(
name|colon
operator|=
name|index
argument_list|(
operator|*
operator|*
name|argvp
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*    * If colon first character, then no local addr.    */
if|if
condition|(
name|colon
operator|==
operator|*
operator|*
name|argvp
condition|)
block|{
name|local
operator|=
literal|0l
expr_stmt|;
operator|++
name|colon
expr_stmt|;
block|}
else|else
block|{
operator|*
name|colon
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|local
operator|=
name|inet_addr
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unknown host: %s"
argument_list|,
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|local
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * If colon last character, then no remote addr.    */
if|if
condition|(
operator|*
name|colon
operator|==
literal|'\0'
condition|)
name|remote
operator|=
literal|0l
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|remote
operator|=
name|inet_addr
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unknown host: %s"
argument_list|,
name|colon
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
block|}
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_addrs
operator|=
literal|1
expr_stmt|;
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|ouraddr
operator|=
name|local
expr_stmt|;
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|hisaddr
operator|=
name|remote
expr_stmt|;
name|ret
label|:
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setnetmask
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|u_long
name|mask
decl_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|=
name|inet_addr
argument_list|(
operator|*
operator|*
name|argvp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid netmask %s\n"
argument_list|,
operator|*
operator|*
name|argvp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|netmask
operator|=
name|mask
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setcrtscts
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|crtscts
operator|=
literal|1
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setnodetach
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|nodetach
operator|=
literal|1
expr_stmt|;
operator|--
operator|*
name|argcp
operator|,
operator|++
operator|*
name|argvp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getuserpasswd - Get the user name and passwd.  */
end_comment

begin_function
specifier|static
name|void
name|getuserpasswd
parameter_list|()
block|{
name|upap
index|[
literal|0
index|]
operator|.
name|us_user
operator|=
name|user
expr_stmt|;
name|upap
index|[
literal|0
index|]
operator|.
name|us_userlen
operator|=
name|strlen
argument_list|(
name|upap
index|[
literal|0
index|]
operator|.
name|us_user
argument_list|)
expr_stmt|;
name|upap
index|[
literal|0
index|]
operator|.
name|us_passwd
operator|=
name|passwd
expr_stmt|;
name|upap
index|[
literal|0
index|]
operator|.
name|us_passwdlen
operator|=
name|strlen
argument_list|(
name|upap
index|[
literal|0
index|]
operator|.
name|us_passwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * login - Check the user name and passwd and login the user.  *  * returns:  *	UPAP_AUTHNAK: Login failed.  *	UPAP_AUTHACK: Login succeeded.  * In either case, msg points to an appropriate message.  */
end_comment

begin_function
name|u_char
name|login
parameter_list|(
name|user
parameter_list|,
name|userlen
parameter_list|,
name|passwd
parameter_list|,
name|passwdlen
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|int
name|userlen
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|int
name|passwdlen
decl_stmt|;
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|epasswd
decl_stmt|,
modifier|*
name|crypt
argument_list|()
decl_stmt|;
specifier|static
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
name|char
modifier|*
name|tmp_passwd
decl_stmt|,
modifier|*
name|tmp_user
decl_stmt|;
comment|/* why alloca.h doesn't define what alloca() returns is a mystery */
comment|/* seems to be defined in stdlib.h for FreeBSD, rgrimes */
ifdef|#
directive|ifdef
name|sparc
name|char
modifier|*
name|__builtin_alloca
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|__386BSD__
name|char
modifier|*
name|alloca
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* !__386BSD__ */
endif|#
directive|endif
comment|/*sparc*/
name|tmp_passwd
operator|=
name|alloca
argument_list|(
name|passwdlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* we best make copies before */
comment|/* null terminating the string */
if|if
condition|(
name|tmp_passwd
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"alloca failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|passwd
argument_list|,
name|tmp_passwd
argument_list|,
name|passwdlen
argument_list|)
expr_stmt|;
name|tmp_passwd
index|[
name|passwdlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tmp_user
operator|=
name|alloca
argument_list|(
name|userlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_user
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"alloca failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|user
argument_list|,
name|tmp_user
argument_list|,
name|userlen
argument_list|)
expr_stmt|;
name|tmp_user
index|[
name|userlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|tmp_user
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Login incorrect"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap login userid '%s' incorrect"
argument_list|,
name|tmp_user
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
comment|/*    * XXX If no passwd, let them login without one.    */
if|if
condition|(
name|pw
operator|->
name|pw_passwd
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Login ok"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHACK
operator|)
return|;
block|}
name|epasswd
operator|=
name|crypt
argument_list|(
name|tmp_passwd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|epasswd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Login incorrect"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap login password '%s' incorrect"
argument_list|,
name|tmp_passwd
argument_list|)
expr_stmt|;
comment|/*      * Frustrate passwd stealer programs.      * Allow 10 tries, but start backing off after 3 (stolen from login).      * On 10'th, drop the connection.      */
if|if
condition|(
name|attempts
operator|++
operator|>=
literal|10
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%d LOGIN FAILURES ON %s, %s"
argument_list|,
name|attempts
argument_list|,
name|devname
argument_list|,
name|tmp_user
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Drop DTR? */
block|}
if|if
condition|(
name|attempts
operator|>
literal|3
condition|)
name|sleep
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|attempts
operator|-
literal|3
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* Reset count */
operator|*
name|msg
operator|=
literal|"Login ok"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"user %s logged in"
argument_list|,
name|tmp_user
argument_list|)
expr_stmt|;
name|tty
operator|=
name|rindex
argument_list|(
name|devname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
name|tty
operator|=
name|devname
expr_stmt|;
else|else
name|tty
operator|++
expr_stmt|;
name|logwtmp
argument_list|(
name|tty
argument_list|,
name|tmp_user
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Add wtmp login entry */
return|return
operator|(
name|UPAP_AUTHACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * logout - Logout the user.  */
end_comment

begin_function
name|void
name|logout
parameter_list|()
block|{
name|char
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|rindex
argument_list|(
name|devname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
name|tty
operator|=
name|devname
expr_stmt|;
else|else
name|tty
operator|++
expr_stmt|;
name|logwtmp
argument_list|(
name|tty
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Add wtmp logout entry */
block|}
end_function

begin_comment
comment|/*  * getuseropt - Get the options from /etc/hosts.ppp for this user.  */
end_comment

begin_function
name|int
name|getuseropt
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|PPPHOSTS
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
empty_stmt|;
comment|/*    * Loop till we find an entry for this user.    */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fgets"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|user
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * open "secret" file and return the secret matching the given name.  * If no secret for a given name is found, use the one for "default".  */
end_comment

begin_function
name|void
name|get_secret
parameter_list|(
name|name
parameter_list|,
name|secret
parameter_list|,
name|secret_len
parameter_list|)
name|u_char
modifier|*
name|name
decl_stmt|;
name|u_char
modifier|*
name|secret
decl_stmt|;
name|int
modifier|*
name|secret_len
decl_stmt|;
block|{
name|FILE
modifier|*
name|sfile
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|u_char
name|fname
index|[
literal|256
index|]
decl_stmt|;
name|int
name|match_found
decl_stmt|,
name|default_found
decl_stmt|;
name|match_found
operator|=
name|FALSE
expr_stmt|;
name|default_found
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|sfile
operator|=
name|fopen
argument_list|(
name|_PATH_CHAPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to open secret file %s"
argument_list|,
name|_PATH_CHAPFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|sfile
argument_list|)
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot stat secret file!: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
literal|077
operator|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Warning - secret file has world and/or group access!"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|sfile
argument_list|)
operator|&&
operator|!
name|match_found
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|sfile
argument_list|,
literal|"%s %s"
argument_list|,
name|fname
argument_list|,
name|secret
argument_list|)
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
condition|)
block|{
name|match_found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"default"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
condition|)
block|{
name|default_found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|match_found
operator|&&
operator|!
name|default_found
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No match or default entry found for %s in CHAP secret file! Aborting..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* shut us down */
block|}
ifdef|#
directive|ifdef
name|UNSECURE
comment|/* while this is useful for debugging, it is a security hole as well */
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"get_secret: found secret %s"
argument_list|,
name|secret
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*UNSECURE*/
name|fclose
argument_list|(
name|sfile
argument_list|)
expr_stmt|;
operator|*
name|secret_len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|secret_len
operator|>
name|MAX_SECRET_LEN
condition|)
block|{
comment|/* don't let it overflow the buffer */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Length of secret for host %s is greater than the maximum %d characters! "
argument_list|,
name|name
argument_list|,
name|MAX_SECRET_LEN
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* scream and die */
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Return user specified netmask. A value of zero means no netmask has  * been set.   */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|u_long
name|GetMask
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|netmask
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_comment
comment|/*   * this module will attempt to reconstruct the stream with the  * previously popped modules  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|str_restore
parameter_list|()
block|{
comment|/*EMPTY*/
while|while
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* pop any we pushed */
for|for
control|(
init|;
name|str_module_count
operator|>
literal|0
condition|;
name|str_module_count
operator|--
control|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
name|str_modules
index|[
name|str_module_count
operator|-
literal|1
index|]
operator|.
name|modname
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"str_restore: couldn't push module %s: %m"
argument_list|,
name|str_modules
index|[
name|str_module_count
operator|-
literal|1
index|]
operator|.
name|modname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MAINDEBUG
argument_list|(
argument|(LOG_INFO,
literal|"str_restore: pushed module %s"
argument|, 		       str_modules[str_module_count-
literal|1
argument|].modname)
argument_list|)
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|dumpbuffer
argument_list|(
argument|buffer
argument_list|,
argument|size
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|line
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"%d bytes:\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|line
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%08lx: "
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|3
control|)
if|if
condition|(
name|size
operator|-
name|i
operator|<=
literal|0
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"xx "
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%02x "
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|size
operator|-
name|i
operator|<=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|'x'
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
operator|(
literal|' '
operator|<=
name|buffer
index|[
name|i
index|]
operator|&&
name|buffer
index|[
name|i
index|]
operator|<=
literal|'~'
operator|)
condition|?
name|buffer
index|[
name|i
index|]
else|:
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|buffer
operator|+=
literal|8
expr_stmt|;
name|size
operator|-=
literal|8
expr_stmt|;
comment|/*	syslog(level, "%s\n", line); */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_macro
name|setdtr
argument_list|(
argument|fd
argument_list|,
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|linestate
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|linestate
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|linestate
operator||=
name|TIOCM_DTR
expr_stmt|;
else|else
name|linestate
operator|&=
operator|~
name|TIOCM_DTR
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|&
name|linestate
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_macro
name|setdtr
argument_list|(
argument|fd
argument_list|,
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|modembits
init|=
name|TIOCM_DTR
decl_stmt|;
if|if
condition|(
name|on
condition|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|modembits
argument_list|)
expr_stmt|;
else|else
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|modembits
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|proto_name
parameter_list|(
name|proto
parameter_list|)
name|u_short
name|proto
decl_stmt|;
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|LCP
case|:
return|return
literal|"lcp"
return|;
case|case
name|UPAP
case|:
return|return
literal|"pap"
return|;
case|case
name|CHAP
case|:
return|return
literal|"chap"
return|;
case|case
name|IPCP
case|:
return|return
literal|"ipcp"
return|;
define|#
directive|define
name|LQM
value|0xc025
case|case
name|LQM
case|:
return|return
literal|"lqm"
return|;
block|}
return|return
literal|"<unknown>"
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_macro
name|logf
argument_list|(
argument|level
argument_list|,
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|pvar
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_start
argument_list|(
name|pvar
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|pvar
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|pvar
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|syslog
argument_list|(
name|level
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

end_unit

