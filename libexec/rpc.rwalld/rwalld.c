begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Christopher G. Demetriou  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/rwall.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OSF
end_ifdef

begin_define
define|#
directive|define
name|WALL_CMD
value|"/usr/sbin/wall"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WALL_CMD
value|"/usr/bin/wall -n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|wallprog_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|possess
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|killkids
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodaemon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_inetd
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|salen
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|int
name|sock
init|=
literal|0
decl_stmt|;
name|int
name|proto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|nodaemon
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
operator|&&
operator|!
name|nodaemon
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pep
init|=
name|getpwnam
argument_list|(
literal|"nobody"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pep
condition|)
name|setuid
argument_list|(
name|pep
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|else
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*          * See if inetd started us          */
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
operator|&
name|salen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|from_inetd
operator|=
literal|0
expr_stmt|;
name|sock
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|from_inetd
condition|)
block|{
if|if
condition|(
operator|!
name|nodaemon
condition|)
name|possess
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_unset
argument_list|(
name|WALLPROG
argument_list|,
name|WALLVERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
name|sa
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
operator|&
name|salen
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
name|pmap_set
argument_list|(
name|WALLPROG
argument_list|,
name|WALLVERS
argument_list|,
name|IPPROTO_UDP
argument_list|,
name|ntohs
argument_list|(
name|sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"dup2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_unset
argument_list|(
name|WALLPROG
argument_list|,
name|WALLVERS
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|killkids
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"rpc.rwalld"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|transp
operator|=
name|svcudp_create
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot create udp service"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_register
argument_list|(
name|transp
argument_list|,
name|WALLPROG
argument_list|,
name|WALLVERS
argument_list|,
name|wallprog_1
argument_list|,
name|proto
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to register (WALLPROG, WALLVERS, %s)"
argument_list|,
name|proto
condition|?
literal|"udp"
else|:
literal|"(inetd)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|svc_run
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"svc_run returned"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rpc.rwalld [-n]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|possess
parameter_list|()
block|{
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|killkids
parameter_list|()
block|{
while|while
condition|(
name|wait4
argument_list|(
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|wallproc_wall_1
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
comment|/* fork, popen wall with special option, and send the message */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|pfp
operator|=
name|popen
argument_list|(
name|WALL_CMD
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|pfp
argument_list|,
literal|"\007\007%s"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|wallprog_1
parameter_list|(
name|rqstp
parameter_list|,
name|transp
parameter_list|)
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
block|{
union|union
block|{
name|char
modifier|*
name|wallproc_wall_1_arg
decl_stmt|;
block|}
name|argument
union|;
name|char
modifier|*
name|result
decl_stmt|;
name|bool_t
argument_list|(
operator|*
name|xdr_argument
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|xdr_result
argument_list|)
argument_list|()
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|NULLPROC
case|:
operator|(
name|void
operator|)
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|leave
goto|;
case|case
name|WALLPROC_WALL
case|:
name|xdr_argument
operator|=
name|xdr_wrapstring
expr_stmt|;
name|xdr_result
operator|=
name|xdr_void
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|wallproc_wall_1
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
name|result
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
operator|&
name|argument
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
name|xdr_result
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to free arguments"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|leave
label|:
if|if
condition|(
name|from_inetd
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

