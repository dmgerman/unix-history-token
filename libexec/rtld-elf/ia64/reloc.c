begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1996, 1997, 1998, 1999 John D. Polstra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Dynamic linker for ELF.  *  * John Polstra<jdp@polstra.com>.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<machine/ia64_cpu.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"rtld.h"
end_include

begin_decl_stmt
specifier|extern
name|Elf_Dyn
name|_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macros for loading/storing unaligned 64-bit values.  These are  * needed because relocations can point to unaligned data.  This  * occurs in the DWARF2 exception frame tables generated by the  * compiler, for instance.  *  * We don't use these when relocating jump slots and GOT entries,  * since they are guaranteed to be aligned.  *  * XXX dfr stub for now.  */
end_comment

begin_define
define|#
directive|define
name|load64
parameter_list|(
name|p
parameter_list|)
value|(*(u_int64_t *) (p))
end_define

begin_define
define|#
directive|define
name|store64
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|(*(u_int64_t *) (p) = (v))
end_define

begin_comment
comment|/* Allocate an @fptr. */
end_comment

begin_define
define|#
directive|define
name|FPTR_CHUNK_SIZE
value|64
end_define

begin_struct
struct|struct
name|fptr_chunk
block|{
name|struct
name|fptr
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|fptr_chunk
name|first_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr_chunk
modifier|*
name|current_chunk
init|=
operator|&
name|first_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr
modifier|*
name|next_fptr
init|=
operator|&
name|first_chunk
operator|.
name|fptrs
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr
modifier|*
name|last_fptr
init|=
operator|&
name|first_chunk
operator|.
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We use static storage initially so that we don't have to call  * malloc during init_rtld().  */
end_comment

begin_function
specifier|static
name|struct
name|fptr
modifier|*
name|alloc_fptr
parameter_list|(
name|Elf_Addr
name|target
parameter_list|,
name|Elf_Addr
name|gp
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
name|fptr
decl_stmt|;
if|if
condition|(
name|next_fptr
operator|==
name|last_fptr
condition|)
block|{
name|current_chunk
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fptr_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|next_fptr
operator|=
operator|&
name|current_chunk
operator|->
name|fptrs
index|[
literal|0
index|]
expr_stmt|;
name|last_fptr
operator|=
operator|&
name|current_chunk
operator|->
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
expr_stmt|;
block|}
name|fptr
operator|=
name|next_fptr
expr_stmt|;
name|next_fptr
operator|++
expr_stmt|;
name|fptr
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|fptr
operator|->
name|gp
operator|=
name|gp
expr_stmt|;
return|return
name|fptr
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fptr
modifier|*
modifier|*
name|alloc_fptrs
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|bool
name|mapped
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
decl_stmt|;
name|size_t
name|fbytes
decl_stmt|;
name|fbytes
operator|=
name|obj
operator|->
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Avoid malloc, if requested. Happens when relocating 	 * rtld itself on startup. 	 */
if|if
condition|(
name|mapped
condition|)
block|{
name|fptrs
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|fbytes
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fptrs
operator|==
name|MAP_FAILED
condition|)
name|fptrs
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fptrs
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|fbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This assertion is necessary to guarantee function pointer 	 * uniqueness  	 */
name|assert
argument_list|(
name|fptrs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|->
name|priv
operator|=
name|fptrs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_fptrs
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|bool
name|mapped
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
decl_stmt|;
name|size_t
name|fbytes
decl_stmt|;
name|fptrs
operator|=
name|obj
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|fptrs
operator|==
name|NULL
condition|)
return|return;
name|fbytes
operator|=
name|obj
operator|->
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped
condition|)
name|munmap
argument_list|(
name|fptrs
argument_list|,
name|fbytes
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|fptrs
argument_list|)
expr_stmt|;
name|obj
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate a non-PLT object with addend. */
end_comment

begin_function
specifier|static
name|int
name|reloc_non_plt_obj
parameter_list|(
name|Obj_Entry
modifier|*
name|obj_rtld
parameter_list|,
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
specifier|const
name|Elf_Rela
modifier|*
name|rela
parameter_list|,
name|SymCache
modifier|*
name|cache
parameter_list|,
name|int
name|flags
parameter_list|,
name|RtldLockState
modifier|*
name|lockstate
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
decl_stmt|;
name|Elf_Addr
modifier|*
name|where
init|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
decl_stmt|;
switch|switch
condition|(
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_IA_64_REL64LSB
case|:
comment|/* 		 * We handle rtld's relocations in rtld_start.S 		 */
if|if
condition|(
name|obj
operator|!=
name|obj_rtld
condition|)
name|store64
argument_list|(
name|where
argument_list|,
name|load64
argument_list|(
name|where
argument_list|)
operator|+
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA_64_DIR64LSB
case|:
block|{
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|Elf_Addr
name|target
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|target
operator|=
operator|(
name|def
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|)
condition|?
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
else|:
literal|0
expr_stmt|;
name|store64
argument_list|(
name|where
argument_list|,
name|target
operator|+
name|rela
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_FPTR64LSB
case|:
block|{
comment|/* 		 * We have to make sure that all @fptr references to 		 * the same function are identical so that code can 		 * compare function pointers. 		 */
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|struct
name|fptr
modifier|*
name|fptr
init|=
literal|0
decl_stmt|;
name|Elf_Addr
name|target
decl_stmt|,
name|gp
decl_stmt|;
name|int
name|sym_index
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|SYMLOOK_IN_PLT
operator||
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * XXX r_debug_state is problematic and find_symdef() 			 * returns NULL for it. This probably has something to 			 * do with symbol versioning (r_debug_state is in the 			 * symbol map). If we return -1 in that case we abort 			 * relocating rtld, which typically is fatal. So, for 			 * now just skip the symbol when we're relocating 			 * rtld. We don't care about r_debug_state unless we 			 * are being debugged. 			 */
if|if
condition|(
name|obj
operator|!=
name|obj_rtld
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
if|if
condition|(
name|def
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
block|{
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|defobj
operator|->
name|pltgot
expr_stmt|;
comment|/* rtld is allowed to reference itself only */
name|assert
argument_list|(
operator|!
name|obj
operator|->
name|rtld
operator|||
name|obj
operator|==
name|defobj
argument_list|)
expr_stmt|;
name|fptrs
operator|=
name|defobj
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|fptrs
operator|==
name|NULL
condition|)
name|fptrs
operator|=
name|alloc_fptrs
argument_list|(
operator|(
name|Obj_Entry
operator|*
operator|)
name|defobj
argument_list|,
name|obj
operator|->
name|rtld
argument_list|)
expr_stmt|;
name|sym_index
operator|=
name|def
operator|-
name|defobj
operator|->
name|symtab
expr_stmt|;
comment|/* 			 * Find the @fptr, using fptrs as a helper. 			 */
if|if
condition|(
name|fptrs
condition|)
name|fptr
operator|=
name|fptrs
index|[
name|sym_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|fptr
operator|=
name|alloc_fptr
argument_list|(
name|target
argument_list|,
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fptrs
condition|)
name|fptrs
index|[
name|sym_index
index|]
operator|=
name|fptr
expr_stmt|;
block|}
block|}
else|else
name|fptr
operator|=
name|NULL
expr_stmt|;
name|store64
argument_list|(
name|where
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|fptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_IPLTLSB
case|:
block|{
comment|/* 		 * Relocation typically used to populate C++ virtual function 		 * tables. It creates a 128-bit function descriptor at the 		 * specified memory address. 		 */
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|struct
name|fptr
modifier|*
name|fptr
decl_stmt|;
name|Elf_Addr
name|target
decl_stmt|,
name|gp
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|def
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
block|{
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|defobj
operator|->
name|pltgot
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
literal|0
expr_stmt|;
block|}
name|fptr
operator|=
operator|(
name|void
operator|*
operator|)
name|where
expr_stmt|;
name|store64
argument_list|(
operator|&
name|fptr
operator|->
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|store64
argument_list|(
operator|&
name|fptr
operator|->
name|gp
argument_list|,
name|gp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_DTPMOD64LSB
case|:
block|{
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|store64
argument_list|(
name|where
argument_list|,
name|defobj
operator|->
name|tlsindex
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_DTPREL64LSB
case|:
block|{
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|store64
argument_list|(
name|where
argument_list|,
name|def
operator|->
name|st_value
operator|+
name|rela
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_TPREL64LSB
case|:
block|{
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 		 * We lazily allocate offsets for static TLS as we 		 * see the first relocation that references the 		 * TLS block. This allows us to support (small 		 * amounts of) static TLS in dynamically loaded 		 * modules. If we run out of space, we generate an 		 * error. 		 */
if|if
condition|(
operator|!
name|defobj
operator|->
name|tls_done
condition|)
block|{
if|if
condition|(
operator|!
name|allocate_tls_offset
argument_list|(
operator|(
name|Obj_Entry
operator|*
operator|)
name|defobj
argument_list|)
condition|)
block|{
name|_rtld_error
argument_list|(
literal|"%s: No space available for static "
literal|"Thread Local Storage"
argument_list|,
name|obj
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|store64
argument_list|(
name|where
argument_list|,
name|defobj
operator|->
name|tlsoffset
operator|+
name|def
operator|->
name|st_value
operator|+
name|rela
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA_64_NONE
case|:
break|break;
default|default:
name|_rtld_error
argument_list|(
literal|"%s: Unsupported relocation type %u"
literal|" in non-PLT relocations\n"
argument_list|,
name|obj
operator|->
name|path
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process the non-PLT relocations. */
end_comment

begin_function
name|int
name|reloc_non_plt
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|Obj_Entry
modifier|*
name|obj_rtld
parameter_list|,
name|int
name|flags
parameter_list|,
name|RtldLockState
modifier|*
name|lockstate
parameter_list|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|SymCache
modifier|*
name|cache
decl_stmt|;
name|int
name|bytes
init|=
name|obj
operator|->
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|SymCache
argument_list|)
decl_stmt|;
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SYMLOOK_IFUNC
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX not implemented */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The dynamic loader may be called from a thread, we have 	 * limited amounts of stack available so we cannot use alloca(). 	 */
name|cache
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|bytes
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|MAP_FAILED
condition|)
name|cache
operator|=
name|NULL
expr_stmt|;
comment|/* Perform relocations without addend if there are any: */
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|obj
operator|->
name|rel
operator|+
name|obj
operator|->
name|relsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|rel
init|;
name|obj
operator|->
name|rel
operator|!=
name|NULL
operator|&&
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Rela
name|locrela
decl_stmt|;
name|locrela
operator|.
name|r_info
operator|=
name|rel
operator|->
name|r_info
expr_stmt|;
name|locrela
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|locrela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reloc_non_plt_obj
argument_list|(
name|obj_rtld
argument_list|,
name|obj
argument_list|,
operator|&
name|locrela
argument_list|,
name|cache
argument_list|,
name|flags
argument_list|,
name|lockstate
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Perform relocations with addend if there are any: */
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|obj
operator|->
name|rela
operator|+
name|obj
operator|->
name|relasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|rela
init|;
name|obj
operator|->
name|rela
operator|!=
name|NULL
operator|&&
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
if|if
condition|(
name|reloc_non_plt_obj
argument_list|(
name|obj_rtld
argument_list|,
name|obj
argument_list|,
name|rela
argument_list|,
name|cache
argument_list|,
name|flags
argument_list|,
name|lockstate
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|cache
condition|)
name|munmap
argument_list|(
name|cache
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* 	 * Release temporarily mapped fptrs if relocating 	 * rtld object itself. A new table will be created 	 * in make_function_pointer using malloc when needed. 	 */
if|if
condition|(
name|obj
operator|->
name|rtld
operator|&&
name|obj
operator|->
name|priv
condition|)
name|free_fptrs
argument_list|(
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process the PLT relocations. */
end_comment

begin_function
name|int
name|reloc_plt
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
comment|/* All PLT relocations are the same kind: Elf_Rel or Elf_Rela. */
if|if
condition|(
name|obj
operator|->
name|pltrelsize
operator|!=
literal|0
condition|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrel
operator|+
name|obj
operator|->
name|pltrelsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|pltrel
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA_64_IPLTLSB
argument_list|)
expr_stmt|;
comment|/* Relocate the @fptr pointing into the PLT. */
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
operator|*
name|where
operator|+=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrela
operator|+
name|obj
operator|->
name|pltrelasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|pltrela
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA_64_IPLTLSB
argument_list|)
expr_stmt|;
comment|/* Relocate the @fptr pointing into the PLT. */
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
operator|*
name|where
operator|+=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|reloc_iresolve
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|struct
name|Struct_RtldLockState
modifier|*
name|lockstate
parameter_list|)
block|{
comment|/* XXX not implemented */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reloc_gnu_ifunc
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|Struct_RtldLockState
modifier|*
name|lockstate
parameter_list|)
block|{
comment|/* XXX not implemented */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Relocate the jump slots in an object. */
end_comment

begin_function
name|int
name|reloc_jmpslots
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
name|RtldLockState
modifier|*
name|lockstate
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|jmpslots_done
condition|)
return|return
literal|0
return|;
comment|/* All PLT relocations are the same kind: Elf_Rel or Elf_Rela. */
if|if
condition|(
name|obj
operator|->
name|pltrelsize
operator|!=
literal|0
condition|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrel
operator|+
name|obj
operator|->
name|pltrelsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|pltrel
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA_64_IPLTLSB
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|SYMLOOK_IN_PLT
operator||
name|flags
argument_list|,
name|NULL
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|reloc_jmpslot
argument_list|(
name|where
argument_list|,
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
argument_list|,
name|defobj
argument_list|,
name|obj
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrela
operator|+
name|obj
operator|->
name|pltrelasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|pltrela
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|SYMLOOK_IN_PLT
operator||
name|flags
argument_list|,
name|NULL
argument_list|,
name|lockstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|reloc_jmpslot
argument_list|(
name|where
argument_list|,
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
argument_list|,
name|defobj
argument_list|,
name|obj
argument_list|,
operator|(
name|Elf_Rel
operator|*
operator|)
name|rela
argument_list|)
expr_stmt|;
block|}
block|}
name|obj
operator|->
name|jmpslots_done
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fixup the jump slot at "where" to transfer control to "target". */
end_comment

begin_function
name|Elf_Addr
name|reloc_jmpslot
parameter_list|(
name|Elf_Addr
modifier|*
name|where
parameter_list|,
name|Elf_Addr
name|target
parameter_list|,
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
specifier|const
name|Obj_Entry
modifier|*
name|refobj
parameter_list|,
specifier|const
name|Elf_Rel
modifier|*
name|rel
parameter_list|)
block|{
name|Elf_Addr
name|stubaddr
decl_stmt|;
name|dbg
argument_list|(
literal|" reloc_jmpslot: where=%p, target=%p, gp=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|pltgot
argument_list|)
expr_stmt|;
name|stubaddr
operator|=
operator|*
name|where
expr_stmt|;
if|if
condition|(
name|stubaddr
operator|!=
name|target
condition|)
block|{
comment|/* 		 * Point this @fptr directly at the target. Update the 		 * gp value first so that we don't break another cpu 		 * which is currently executing the PLT entry. 		 */
name|where
index|[
literal|1
index|]
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|target
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * The caller needs an @fptr for the adjusted entry. The PLT 	 * entry serves this purpose nicely. 	 */
return|return
operator|(
name|Elf_Addr
operator|)
name|where
return|;
block|}
end_function

begin_comment
comment|/*  * XXX ia64 doesn't seem to have copy relocations.  *  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|do_copy_relocations
parameter_list|(
name|Obj_Entry
modifier|*
name|dstobj
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the @fptr representing a given function symbol.  */
end_comment

begin_function
name|void
modifier|*
name|make_function_pointer
parameter_list|(
specifier|const
name|Elf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
init|=
name|obj
operator|->
name|priv
decl_stmt|;
name|int
name|index
init|=
name|sym
operator|-
name|obj
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
operator|!
name|fptrs
condition|)
block|{
comment|/* 		 * This should only happen for something like 		 * dlsym("dlopen"). Actually, I'm not sure it can ever  		 * happen. 		 */
name|fptrs
operator|=
name|alloc_fptrs
argument_list|(
operator|(
name|Obj_Entry
operator|*
operator|)
name|obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fptrs
index|[
name|index
index|]
condition|)
block|{
name|Elf_Addr
name|target
decl_stmt|,
name|gp
decl_stmt|;
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|obj
operator|->
name|relocbase
operator|+
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|fptrs
index|[
name|index
index|]
operator|=
name|alloc_fptr
argument_list|(
name|target
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
return|return
name|fptrs
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|void
name|call_initfini_pointer
parameter_list|(
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|Elf_Addr
name|target
parameter_list|)
block|{
name|struct
name|fptr
name|fptr
decl_stmt|;
name|fptr
operator|.
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|fptr
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|dbg
argument_list|(
literal|" initfini: target=%p, gp=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|gp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|InitFunc
operator|)
operator|&
name|fptr
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|call_init_pointer
parameter_list|(
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|Elf_Addr
name|target
parameter_list|)
block|{
name|struct
name|fptr
name|fptr
decl_stmt|;
name|fptr
operator|.
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|fptr
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|dbg
argument_list|(
literal|" initfini: target=%p, gp=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|gp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|InitArrFunc
operator|)
operator|&
name|fptr
operator|)
operator|(
name|main_argc
operator|,
name|main_argv
operator|,
name|environ
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the special PLT entries. */
end_comment

begin_function
name|void
name|init_pltgot
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|Elf_Dyn
modifier|*
name|dynp
decl_stmt|;
name|Elf_Addr
modifier|*
name|pltres
init|=
literal|0
decl_stmt|;
comment|/* 	 * When there are no PLT relocations, the DT_IA_64_PLT_RESERVE entry 	 * is bogus. Do not setup the BOR pointers in that case. An example 	 * of where this happens is /usr/lib/libxpg4.so.3. 	 */
if|if
condition|(
name|obj
operator|->
name|pltrelasize
operator|==
literal|0
operator|&&
name|obj
operator|->
name|pltrelsize
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the PLT RESERVE section. 	 */
for|for
control|(
name|dynp
operator|=
name|obj
operator|->
name|dynamic
init|;
name|dynp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dynp
operator|++
control|)
block|{
if|if
condition|(
name|dynp
operator|->
name|d_tag
operator|==
name|DT_IA_64_PLT_RESERVE
condition|)
name|pltres
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|dynp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pltres
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't find DT_IA_64_PLT_RESERVE entry"
argument_list|)
expr_stmt|;
comment|/* 	 * The PLT RESERVE section is used to get values to pass to 	 * _rtld_bind when lazy binding. 	 */
name|pltres
index|[
literal|0
index|]
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
expr_stmt|;
name|pltres
index|[
literal|1
index|]
operator|=
name|FPTR_TARGET
argument_list|(
name|_rtld_bind_start
argument_list|)
expr_stmt|;
name|pltres
index|[
literal|2
index|]
operator|=
name|FPTR_GP
argument_list|(
name|_rtld_bind_start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|allocate_initial_tls
parameter_list|(
name|Obj_Entry
modifier|*
name|list
parameter_list|)
block|{
name|void
modifier|*
name|tpval
decl_stmt|;
comment|/*      * Fix the size of the static TLS block by using the maximum      * offset allocated so far and adding a bit for dynamic modules to      * use.      */
name|tls_static_space
operator|=
name|tls_last_offset
operator|+
name|tls_last_size
operator|+
name|RTLD_STATIC_TLS_EXTRA
expr_stmt|;
name|tpval
operator|=
name|allocate_tls
argument_list|(
name|list
argument_list|,
name|NULL
argument_list|,
name|TLS_TCB_SIZE
argument_list|,
literal|16
argument_list|)
expr_stmt|;
asm|__asm __volatile("mov r13 = %0" :: "r"(tpval));
block|}
end_function

begin_function
name|void
modifier|*
name|__tls_get_addr
parameter_list|(
name|unsigned
name|long
name|module
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
specifier|register
name|Elf_Addr
modifier|*
modifier|*
name|tp
name|__asm__
argument_list|(
literal|"r13"
argument_list|)
decl_stmt|;
return|return
name|tls_get_addr_common
argument_list|(
name|tp
argument_list|,
name|module
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

end_unit

