begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1996, 1997, 1998, 1999 John D. Polstra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Dynamic linker for ELF.  *  * John Polstra<jdp@polstra.com>.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"rtld.h"
end_include

begin_decl_stmt
specifier|extern
name|Elf_Dyn
name|_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macros for loading/storing unaligned 64-bit values.  These are  * needed because relocations can point to unaligned data.  This  * occurs in the DWARF2 exception frame tables generated by the  * compiler, for instance.  *  * We don't use these when relocating jump slots and GOT entries,  * since they are guaranteed to be aligned.  *  * XXX dfr stub for now.  */
end_comment

begin_define
define|#
directive|define
name|load64
parameter_list|(
name|p
parameter_list|)
value|(*(u_int64_t *) (p))
end_define

begin_define
define|#
directive|define
name|store64
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|(*(u_int64_t *) (p) = (v))
end_define

begin_comment
comment|/* Allocate an @fptr. */
end_comment

begin_define
define|#
directive|define
name|FPTR_CHUNK_SIZE
value|64
end_define

begin_struct
struct|struct
name|fptr_chunk
block|{
name|struct
name|fptr
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|fptr_chunk
name|first_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr_chunk
modifier|*
name|current_chunk
init|=
operator|&
name|first_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr
modifier|*
name|next_fptr
init|=
operator|&
name|first_chunk
operator|.
name|fptrs
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fptr
modifier|*
name|last_fptr
init|=
operator|&
name|first_chunk
operator|.
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We use static storage initially so that we don't have to call  * malloc during init_rtld().  */
end_comment

begin_function
specifier|static
name|struct
name|fptr
modifier|*
name|alloc_fptr
parameter_list|(
name|Elf_Addr
name|target
parameter_list|,
name|Elf_Addr
name|gp
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
name|fptr
decl_stmt|;
if|if
condition|(
name|next_fptr
operator|==
name|last_fptr
condition|)
block|{
name|current_chunk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fptr_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|next_fptr
operator|=
operator|&
name|current_chunk
operator|->
name|fptrs
index|[
literal|0
index|]
expr_stmt|;
name|last_fptr
operator|=
operator|&
name|current_chunk
operator|->
name|fptrs
index|[
name|FPTR_CHUNK_SIZE
index|]
expr_stmt|;
block|}
name|fptr
operator|=
name|next_fptr
expr_stmt|;
name|next_fptr
operator|++
expr_stmt|;
name|fptr
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|fptr
operator|->
name|gp
operator|=
name|gp
expr_stmt|;
return|return
name|fptr
return|;
block|}
end_function

begin_comment
comment|/* Relocate a non-PLT object with addend. */
end_comment

begin_function
specifier|static
name|int
name|reloc_non_plt_obj
parameter_list|(
name|Obj_Entry
modifier|*
name|obj_rtld
parameter_list|,
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
specifier|const
name|Elf_Rela
modifier|*
name|rela
parameter_list|,
name|SymCache
modifier|*
name|cache
parameter_list|,
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
parameter_list|)
block|{
name|Elf_Addr
modifier|*
name|where
init|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
decl_stmt|;
switch|switch
condition|(
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_IA64_REL64LSB
case|:
comment|/* 		 * We handle rtld's relocations in rtld_start.S 		 */
if|if
condition|(
name|obj
operator|!=
name|obj_rtld
condition|)
name|store64
argument_list|(
name|where
argument_list|,
name|load64
argument_list|(
name|where
argument_list|)
operator|+
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
block|{
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|Elf_Addr
name|target
decl_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|false
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|store64
argument_list|(
name|where
argument_list|,
name|target
operator|+
name|rela
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_IA64_FPTR64LSB
case|:
block|{
comment|/* 		 * We have to make sure that all @fptr references to 		 * the same function are identical so that code can 		 * compare function pointers. We actually only bother 		 * to ensure this within a single object. If the 		 * caller's alloca failed, we don't even ensure that. 		 */
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|,
modifier|*
name|ref
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|struct
name|fptr
modifier|*
name|fptr
init|=
literal|0
decl_stmt|;
name|Elf_Addr
name|target
decl_stmt|,
name|gp
decl_stmt|;
comment|/* 		 * Not sure why the call to find_symdef() doesn't work  		 * properly (it fails if the symbol is local). Perhaps  		 * this is a toolchain issue - revisit after we 		 * upgrade the ia64 toolchain. 		 */
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|false
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
block|{
name|def
operator|=
operator|&
name|obj
operator|->
name|symtab
index|[
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
name|defobj
operator|=
name|obj
expr_stmt|;
block|}
comment|/* 		 * If this is an undefined weak reference, we need to 		 * have a zero target,gp fptr, not pointing to relocbase. 		 * This isn't quite right.  Maybe we should check 		 * explicitly for def ==&sym_zero. 		 */
if|if
condition|(
name|def
operator|->
name|st_value
operator|==
literal|0
operator|&&
operator|(
name|ref
operator|=
name|obj
operator|->
name|symtab
operator|+
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|)
operator|&&
name|ELF_ST_BIND
argument_list|(
name|ref
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
condition|)
block|{
name|target
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|defobj
operator|->
name|pltgot
expr_stmt|;
block|}
comment|/* 		 * Find the @fptr, using fptrs as a helper. 		 */
if|if
condition|(
name|fptrs
condition|)
name|fptr
operator|=
name|fptrs
index|[
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|fptr
operator|=
name|alloc_fptr
argument_list|(
name|target
argument_list|,
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fptrs
condition|)
name|fptrs
index|[
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
index|]
operator|=
name|fptr
expr_stmt|;
block|}
name|store64
argument_list|(
name|where
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|fptr
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|_rtld_error
argument_list|(
literal|"%s: Unsupported relocation type %d"
literal|" in non-PLT relocations\n"
argument_list|,
name|obj
operator|->
name|path
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process the non-PLT relocations. */
end_comment

begin_function
name|int
name|reloc_non_plt
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|Obj_Entry
modifier|*
name|obj_rtld
parameter_list|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|SymCache
modifier|*
name|cache
decl_stmt|;
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
decl_stmt|;
name|cache
operator|=
operator|(
name|SymCache
operator|*
operator|)
name|alloca
argument_list|(
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
name|SymCache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
name|SymCache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * When relocating rtld itself, we need to avoid using malloc. 	 */
if|if
condition|(
name|obj
operator|==
name|obj_rtld
condition|)
name|fptrs
operator|=
operator|(
expr|struct
name|fptr
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fptrs
operator|=
operator|(
expr|struct
name|fptr
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fptrs
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|fptrs
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform relocations without addend if there are any: */
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|obj
operator|->
name|rel
operator|+
name|obj
operator|->
name|relsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|rel
init|;
name|obj
operator|->
name|rel
operator|!=
name|NULL
operator|&&
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Rela
name|locrela
decl_stmt|;
name|locrela
operator|.
name|r_info
operator|=
name|rel
operator|->
name|r_info
expr_stmt|;
name|locrela
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|locrela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reloc_non_plt_obj
argument_list|(
name|obj_rtld
argument_list|,
name|obj
argument_list|,
operator|&
name|locrela
argument_list|,
name|cache
argument_list|,
name|fptrs
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Perform relocations with addend if there are any: */
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|obj
operator|->
name|rela
operator|+
name|obj
operator|->
name|relasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|rela
init|;
name|obj
operator|->
name|rela
operator|!=
name|NULL
operator|&&
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
if|if
condition|(
name|reloc_non_plt_obj
argument_list|(
name|obj_rtld
argument_list|,
name|obj
argument_list|,
name|rela
argument_list|,
name|cache
argument_list|,
name|fptrs
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Remember the fptrs in case of later calls to dlsym(). Don't  	 * bother for rtld - we will lazily create a table in 	 * make_function_pointer(). At this point we still can't risk 	 * calling malloc(). 	 */
if|if
condition|(
name|obj
operator|!=
name|obj_rtld
condition|)
name|obj
operator|->
name|priv
operator|=
name|fptrs
expr_stmt|;
else|else
name|obj
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the PLT relocations. */
end_comment

begin_function
name|int
name|reloc_plt
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
comment|/* All PLT relocations are the same kind: Elf_Rel or Elf_Rela. */
if|if
condition|(
name|obj
operator|->
name|pltrelsize
operator|!=
literal|0
condition|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrel
operator|+
name|obj
operator|->
name|pltrelsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|pltrel
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
comment|/* Relocate the @fptr pointing into the PLT. */
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
operator|*
name|where
operator|+=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrela
operator|+
name|obj
operator|->
name|pltrelasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|pltrela
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
comment|/* Relocate the @fptr pointing into the PLT. */
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
operator|*
name|where
operator|+=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|relocbase
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Relocate the jump slots in an object. */
end_comment

begin_function
name|int
name|reloc_jmpslots
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|jmpslots_done
condition|)
return|return
literal|0
return|;
comment|/* All PLT relocations are the same kind: Elf_Rel or Elf_Rela. */
if|if
condition|(
name|obj
operator|->
name|pltrelsize
operator|!=
literal|0
condition|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrel
operator|+
name|obj
operator|->
name|pltrelsize
operator|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|obj
operator|->
name|pltrel
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
name|assert
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|reloc_jmpslot
argument_list|(
name|where
argument_list|,
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
argument_list|,
name|defobj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|->
name|pltrela
operator|+
name|obj
operator|->
name|pltrelasize
operator|)
expr_stmt|;
for|for
control|(
name|rela
operator|=
name|obj
operator|->
name|pltrela
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|Elf_Addr
modifier|*
name|where
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|def
decl_stmt|;
specifier|const
name|Obj_Entry
modifier|*
name|defobj
decl_stmt|;
comment|/* assert(ELF_R_TYPE(rela->r_info) == R_ALPHA_JMP_SLOT); */
name|where
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
name|def
operator|=
name|find_symdef
argument_list|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
argument_list|,
name|obj
argument_list|,
operator|&
name|defobj
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|reloc_jmpslot
argument_list|(
name|where
argument_list|,
call|(
name|Elf_Addr
call|)
argument_list|(
name|defobj
operator|->
name|relocbase
operator|+
name|def
operator|->
name|st_value
argument_list|)
argument_list|,
name|defobj
argument_list|)
expr_stmt|;
block|}
block|}
name|obj
operator|->
name|jmpslots_done
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fixup the jump slot at "where" to transfer control to "target". */
end_comment

begin_function
name|Elf_Addr
name|reloc_jmpslot
parameter_list|(
name|Elf_Addr
modifier|*
name|where
parameter_list|,
name|Elf_Addr
name|target
parameter_list|,
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
name|Elf_Addr
name|stubaddr
decl_stmt|;
name|dbg
argument_list|(
literal|" reloc_jmpslot: where=%p, target=%p, gp=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|pltgot
argument_list|)
expr_stmt|;
name|stubaddr
operator|=
operator|*
name|where
expr_stmt|;
if|if
condition|(
name|stubaddr
operator|!=
name|target
condition|)
block|{
comment|/* 		 * Point this @fptr directly at the target. Update the 		 * gp value first so that we don't break another cpu 		 * which is currently executing the PLT entry. 		 */
name|where
index|[
literal|1
index|]
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|target
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * The caller needs an @fptr for the adjusted entry. The PLT 	 * entry serves this purpose nicely. 	 */
return|return
operator|(
name|Elf_Addr
operator|)
name|where
return|;
block|}
end_function

begin_comment
comment|/*  * XXX ia64 doesn't seem to have copy relocations.  *  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|do_copy_relocations
parameter_list|(
name|Obj_Entry
modifier|*
name|dstobj
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the @fptr representing a given function symbol.  */
end_comment

begin_function
name|void
modifier|*
name|make_function_pointer
parameter_list|(
specifier|const
name|Elf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|fptr
modifier|*
modifier|*
name|fptrs
init|=
name|obj
operator|->
name|priv
decl_stmt|;
name|int
name|index
init|=
name|sym
operator|-
name|obj
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
operator|!
name|fptrs
condition|)
block|{
comment|/* 		 * This should only happen for something like 		 * dlsym("dlopen"). Actually, I'm not sure it can ever  		 * happen. 		 */
name|fptrs
operator|=
operator|(
expr|struct
name|fptr
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fptrs
argument_list|,
literal|0
argument_list|,
name|obj
operator|->
name|nchains
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fptr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Obj_Entry
operator|*
operator|)
name|obj
operator|)
operator|->
name|priv
operator|=
name|fptrs
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fptrs
index|[
name|index
index|]
condition|)
block|{
name|Elf_Addr
name|target
decl_stmt|,
name|gp
decl_stmt|;
name|target
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|obj
operator|->
name|relocbase
operator|+
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|fptrs
index|[
name|index
index|]
operator|=
name|alloc_fptr
argument_list|(
name|target
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
return|return
name|fptrs
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|void
name|call_initfini_pointer
parameter_list|(
specifier|const
name|Obj_Entry
modifier|*
name|obj
parameter_list|,
name|Elf_Addr
name|target
parameter_list|)
block|{
name|struct
name|fptr
name|fptr
decl_stmt|;
name|fptr
operator|.
name|gp
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
operator|->
name|pltgot
expr_stmt|;
name|fptr
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|dbg
argument_list|(
literal|" initfini: target=%p, gp=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fptr
operator|.
name|gp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|InitFunc
operator|)
operator|&
name|fptr
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the special PLT entries. */
end_comment

begin_function
name|void
name|init_pltgot
parameter_list|(
name|Obj_Entry
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|Elf_Dyn
modifier|*
name|dynp
decl_stmt|;
name|Elf_Addr
modifier|*
name|pltres
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find the PLT RESERVE section. 	 */
for|for
control|(
name|dynp
operator|=
name|obj
operator|->
name|dynamic
init|;
name|dynp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dynp
operator|++
control|)
block|{
if|if
condition|(
name|dynp
operator|->
name|d_tag
operator|==
name|DT_IA64_PLT_RESERVE
condition|)
name|pltres
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
operator|(
name|obj
operator|->
name|relocbase
operator|+
name|dynp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pltres
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't find DT_IA64_PLT_RESERVE entry"
argument_list|)
expr_stmt|;
comment|/* 	 * The PLT RESERVE section is used to get values to pass to 	 * _rtld_bind when lazy binding. 	 */
name|pltres
index|[
literal|0
index|]
operator|=
operator|(
name|Elf_Addr
operator|)
name|obj
expr_stmt|;
name|pltres
index|[
literal|1
index|]
operator|=
name|FPTR_TARGET
argument_list|(
name|_rtld_bind_start
argument_list|)
expr_stmt|;
name|pltres
index|[
literal|2
index|]
operator|=
name|FPTR_GP
argument_list|(
name|_rtld_bind_start
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

