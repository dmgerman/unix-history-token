begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * dovend.c : Inserts all but the first few vendor options.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_include
include|#
directive|include
file|"dovend.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|PRIVATE
name|int
name|insert_generic
name|P
argument_list|(
operator|(
expr|struct
name|shared_bindata
operator|*
operator|,
name|byte
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Insert the 2nd part of the options into an option buffer.  * Return amount of space used.  *  * This inserts everything EXCEPT:  *   magic cookie, subnet mask, gateway, bootsize, extension file  * Those are handled separately (in bootpd.c) to allow this function  * to be shared between bootpd and bootpef.  *  * When an "extension file" is in use, the options inserted by  * this function go into the exten_file, not the bootp response.  */
end_comment

begin_function
name|int
name|dovend_rfc1497
parameter_list|(
name|hp
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|byte
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|bytesleft
init|=
name|len
decl_stmt|;
name|byte
modifier|*
name|vp
init|=
name|buf
decl_stmt|;
specifier|static
specifier|const
name|char
name|noroom
index|[]
init|=
literal|"%s: No room for \"%s\" option"
decl_stmt|;
define|#
directive|define
name|NEED
parameter_list|(
name|LEN
parameter_list|,
name|MSG
parameter_list|)
value|do                       \ 		if (bytesleft< (LEN)) {         	    \ 			report(LOG_NOTICE, noroom,          \ 				   hp->hostname->string, MSG);  \ 			return (vp - buf);                  \ 		} while (0)
comment|/* 	 * Note that the following have already been inserted: 	 *   magic_cookie, subnet_mask, gateway, bootsize 	 * 	 * The remaining options are inserted in order of importance. 	 * (Of course the importance of each is a matter of opinion.) 	 * The option insertion order should probably be configurable. 	 * 	 * This is the order used in the NetBSD version.  Can anyone 	 * explain why the time_offset and swap_server are first? 	 * Also, why is the hostname so far down the list?  -gwr 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_offset
condition|)
block|{
name|NEED
argument_list|(
literal|6
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_TIME_OFFSET
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
name|insert_u_long
argument_list|(
name|htonl
argument_list|(
name|hp
operator|->
name|time_offset
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
name|bytesleft
operator|-=
literal|6
expr_stmt|;
block|}
comment|/* 	 * swap server, root path, dump path 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|swap_server
condition|)
block|{
name|NEED
argument_list|(
literal|6
argument_list|,
literal|"sw"
argument_list|)
expr_stmt|;
comment|/* There is just one SWAP_SERVER, so it is not an iplist. */
operator|*
name|vp
operator|++
operator|=
name|TAG_SWAP_SERVER
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
name|insert_u_long
argument_list|(
name|hp
operator|->
name|swap_server
operator|.
name|s_addr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
name|bytesleft
operator|-=
literal|6
expr_stmt|;
comment|/* Fix real count */
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|root_path
condition|)
block|{
comment|/* 		 * Check for room for root_path.  Add 2 to account for 		 * TAG_ROOT_PATH and length. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|root_path
operator|->
name|string
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|2
operator|)
argument_list|,
literal|"rp"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_ROOT_PATH
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|root_path
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|dump_file
condition|)
block|{
comment|/* 		 * Check for room for dump_file.  Add 2 to account for 		 * TAG_DUMP_FILE and length. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|dump_file
operator|->
name|string
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|2
operator|)
argument_list|,
literal|"df"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_DUMP_FILE
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|dump_file
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|/* 	 * DNS server and domain 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_DOMAIN_SERVER
argument_list|,
name|hp
operator|->
name|domain_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"ds"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_name
condition|)
block|{
comment|/* 		 * Check for room for domain_name.  Add 2 to account for 		 * TAG_DOMAIN_NAME and length. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|domain_name
operator|->
name|string
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|2
operator|)
argument_list|,
literal|"dn"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_DOMAIN_NAME
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|domain_name
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|/* 	 * NIS (YP) server and domain 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|nis_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_NIS_SERVER
argument_list|,
name|hp
operator|->
name|nis_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"ds"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|nis_domain
condition|)
block|{
comment|/* 		 * Check for room for nis_domain.  Add 2 to account for 		 * TAG_NIS_DOMAIN and length. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|nis_domain
operator|->
name|string
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|2
operator|)
argument_list|,
literal|"dn"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_NIS_DOMAIN
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|nis_domain
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|/* IEN 116 name server */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_NAME_SERVER
argument_list|,
name|hp
operator|->
name|name_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"ns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_RLP_SERVER
argument_list|,
name|hp
operator|->
name|rlp_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"rl"
argument_list|)
expr_stmt|;
block|}
comment|/* Time server (RFC 868) */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_TIME_SERVER
argument_list|,
name|hp
operator|->
name|time_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"ts"
argument_list|)
expr_stmt|;
block|}
comment|/* NTP (time) Server (RFC 1129) */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|ntp_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_NTP_SERVER
argument_list|,
name|hp
operator|->
name|ntp_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"ts"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * I wonder:  If the hostname were "promoted" into the BOOTP 	 * response part, might these "extension" files possibly be 	 * shared between several clients? 	 * 	 * Also, why not just use longer BOOTP packets with all the 	 * additional length used as option data.  This bootpd version 	 * already supports that feature by replying with the same 	 * packet length as the client request packet. -gwr 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|&&
name|hp
operator|->
name|flags
operator|.
name|send_name
condition|)
block|{
comment|/* 		 * Check for room for hostname.  Add 2 to account for 		 * TAG_HOST_NAME and length. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * XXX - Too much magic.  The user can always set the hostname 		 * to the short version in the bootptab file. -gwr 		 */
block|if ((len + 2)> bytesleft) {
comment|/* 			 * Not enough room for full (domain-qualified) hostname, try 			 * stripping it down to just the first field (host). 			 */
block|char *tmpstr = hp->hostname->string; 			len = 0; 			while (*tmpstr&& (*tmpstr != '.')) { 				tmpstr++; 				len++; 			} 		}
endif|#
directive|endif
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|2
operator|)
argument_list|,
literal|"hn"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_HOST_NAME
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|/* 	 * The rest of these are less important, so they go last. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_LPR_SERVER
argument_list|,
name|hp
operator|->
name|lpr_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"lp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_COOKIE_SERVER
argument_list|,
name|hp
operator|->
name|cookie_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"cs"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
condition|)
block|{
if|if
condition|(
name|insert_ip
argument_list|(
name|TAG_LOG_SERVER
argument_list|,
name|hp
operator|->
name|log_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|8
argument_list|,
literal|"lg"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX - Add new tags here (to insert options) 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|generic
condition|)
block|{
if|if
condition|(
name|insert_generic
argument_list|(
name|hp
operator|->
name|generic
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
condition|)
name|NEED
argument_list|(
literal|64
argument_list|,
literal|"(generic)"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The end marker is inserted by the caller. 	 */
return|return
operator|(
name|vp
operator|-
name|buf
operator|)
return|;
undef|#
directive|undef
name|NEED
block|}
end_function

begin_comment
comment|/* dovend_rfc1497 */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Insert a tag value, a length value, and a list of IP addresses into the  * memory buffer indirectly pointed to by "dest".  "tag" is the RFC1048 tag  * number to use, "iplist" is a pointer to a list of IP addresses  * (struct in_addr_list), and "bytesleft" points to an integer which  * indicates the size of the "dest" buffer.  *  * Return zero if everything fits.  *  * This is used to fill the vendor-specific area of a bootp packet in  * conformance to RFC1048.  */
end_comment

begin_function
name|int
name|insert_ip
parameter_list|(
name|tag
parameter_list|,
name|iplist
parameter_list|,
name|dest
parameter_list|,
name|bytesleft
parameter_list|)
name|byte
name|tag
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|iplist
decl_stmt|;
name|byte
modifier|*
modifier|*
name|dest
decl_stmt|;
name|int
modifier|*
name|bytesleft
decl_stmt|;
block|{
name|struct
name|in_addr
modifier|*
name|addrptr
decl_stmt|;
name|unsigned
name|addrcount
init|=
literal|1
decl_stmt|;
name|byte
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|iplist
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|bytesleft
operator|>=
literal|6
condition|)
block|{
name|d
operator|=
operator|*
name|dest
expr_stmt|;
comment|/* Save pointer for later */
operator|*
operator|*
name|dest
operator|=
name|tag
expr_stmt|;
operator|(
operator|*
name|dest
operator|)
operator|+=
literal|2
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
literal|2
expr_stmt|;
comment|/* Account for tag and length */
name|addrptr
operator|=
name|iplist
operator|->
name|addr
expr_stmt|;
name|addrcount
operator|=
name|iplist
operator|->
name|addrcount
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bytesleft
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|addrcount
operator|>
literal|0
operator|)
condition|)
block|{
name|insert_u_long
argument_list|(
name|addrptr
operator|->
name|s_addr
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|addrptr
operator|++
expr_stmt|;
name|addrcount
operator|--
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
literal|4
expr_stmt|;
comment|/* Four bytes per address */
block|}
name|d
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|*
name|dest
operator|-
name|d
operator|-
literal|2
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addrcount
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Insert generic data into a bootp packet.  The data is assumed to already  * be in RFC1048 format.  It is inserted using a first-fit algorithm which  * attempts to insert as many tags as possible.  Tags and data which are  * too large to fit are skipped; any remaining tags are tried until they  * have all been exhausted.  * Return zero if everything fits.  */
end_comment

begin_function
specifier|static
name|int
name|insert_generic
parameter_list|(
name|gendata
parameter_list|,
name|buff
parameter_list|,
name|bytesleft
parameter_list|)
name|struct
name|shared_bindata
modifier|*
name|gendata
decl_stmt|;
name|byte
modifier|*
modifier|*
name|buff
decl_stmt|;
name|int
modifier|*
name|bytesleft
decl_stmt|;
block|{
name|byte
modifier|*
name|srcptr
decl_stmt|;
name|int
name|length
decl_stmt|,
name|numbytes
decl_stmt|;
name|int
name|skipped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gendata
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|srcptr
operator|=
name|gendata
operator|->
name|data
expr_stmt|;
name|length
operator|=
name|gendata
operator|->
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|bytesleft
operator|>
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|srcptr
condition|)
block|{
case|case
name|TAG_END
case|:
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Force an exit on next iteration */
break|break;
case|case
name|TAG_PAD
case|:
operator|*
operator|(
operator|*
name|buff
operator|)
operator|++
operator|=
operator|*
name|srcptr
operator|++
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|--
expr_stmt|;
name|length
operator|--
expr_stmt|;
break|break;
default|default:
name|numbytes
operator|=
name|srcptr
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|bytesleft
operator|<
name|numbytes
condition|)
name|skipped
operator|+=
name|numbytes
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|srcptr
argument_list|,
operator|*
name|buff
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buff
operator|)
operator|+=
name|numbytes
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
name|numbytes
expr_stmt|;
block|}
name|srcptr
operator|+=
name|numbytes
expr_stmt|;
name|length
operator|-=
name|numbytes
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
return|return
operator|(
name|skipped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the unsigned long "value" into memory starting at the byte  * pointed to by the byte pointer (*dest).  (*dest) is updated to  * point to the next available byte.  *  * Since it is desirable to internally store network addresses in network  * byte order (in struct in_addr's), this routine expects longs to be  * passed in network byte order.  *  * However, due to the nature of the main algorithm, the long must be in  * host byte order, thus necessitating the use of ntohl() first.  */
end_comment

begin_function
name|void
name|insert_u_long
parameter_list|(
name|value
parameter_list|,
name|dest
parameter_list|)
name|u_int32
name|value
decl_stmt|;
name|byte
modifier|*
modifier|*
name|dest
decl_stmt|;
block|{
name|byte
modifier|*
name|temp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|value
operator|=
name|ntohl
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Must use host byte order here */
name|temp
operator|=
operator|(
operator|*
name|dest
operator|+=
literal|4
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|4
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
operator|*
operator|--
name|temp
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* Final result is network byte order */
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

