begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|_BLURB_
end_ifndef

begin_define
define|#
directive|define
name|_BLURB_
end_define

begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ************************************************************************/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _BLURB_ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /b/source/CVS/othersrc/bootpd/readfile.c,v 1.2 1993/08/28 01:55:33 brezak Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * bootpd configuration file reading code.  *  * The routines in this file deal with reading, interpreting, and storing  * the information found in the bootpd configuration file (usually  * /etc/bootptab).  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSLOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|E_END_OF_ENTRY
value|(-1)
end_define

begin_define
define|#
directive|define
name|E_SYNTAX_ERROR
value|(-2)
end_define

begin_define
define|#
directive|define
name|E_UNKNOWN_SYMBOL
value|(-3)
end_define

begin_define
define|#
directive|define
name|E_BAD_IPADDR
value|(-4)
end_define

begin_define
define|#
directive|define
name|E_BAD_HADDR
value|(-5)
end_define

begin_define
define|#
directive|define
name|E_BAD_SMASK
value|(-6)
end_define

begin_define
define|#
directive|define
name|E_BAD_TIMEOFF
value|(-7)
end_define

begin_define
define|#
directive|define
name|E_BAD_VM_COOKIE
value|(-8)
end_define

begin_define
define|#
directive|define
name|E_BAD_HTYPE
value|(-9)
end_define

begin_define
define|#
directive|define
name|E_BAD_BOOTSIZE
value|(-10)
end_define

begin_define
define|#
directive|define
name|E_BAD_BOOT_SERVER
value|(-11)
end_define

begin_define
define|#
directive|define
name|E_BAD_HOMEDIR
value|(-12)
end_define

begin_define
define|#
directive|define
name|E_BAD_TFTPDIR
value|(-13)
end_define

begin_define
define|#
directive|define
name|E_BAD_SWAP_SERVER
value|(-14)
end_define

begin_define
define|#
directive|define
name|SYM_NULL
value|0
end_define

begin_define
define|#
directive|define
name|SYM_BOOTFILE
value|1
end_define

begin_define
define|#
directive|define
name|SYM_COOKIE_SERVER
value|2
end_define

begin_define
define|#
directive|define
name|SYM_DOMAIN_SERVER
value|3
end_define

begin_define
define|#
directive|define
name|SYM_GATEWAY
value|4
end_define

begin_define
define|#
directive|define
name|SYM_HADDR
value|5
end_define

begin_define
define|#
directive|define
name|SYM_HOMEDIR
value|6
end_define

begin_define
define|#
directive|define
name|SYM_HTYPE
value|7
end_define

begin_define
define|#
directive|define
name|SYM_IMPRESS_SERVER
value|8
end_define

begin_define
define|#
directive|define
name|SYM_IPADDR
value|9
end_define

begin_define
define|#
directive|define
name|SYM_LOG_SERVER
value|10
end_define

begin_define
define|#
directive|define
name|SYM_LPR_SERVER
value|11
end_define

begin_define
define|#
directive|define
name|SYM_NAME_SERVER
value|12
end_define

begin_define
define|#
directive|define
name|SYM_RLP_SERVER
value|13
end_define

begin_define
define|#
directive|define
name|SYM_SUBNET_MASK
value|14
end_define

begin_define
define|#
directive|define
name|SYM_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|SYM_TIME_SERVER
value|16
end_define

begin_define
define|#
directive|define
name|SYM_VENDOR_MAGIC
value|17
end_define

begin_define
define|#
directive|define
name|SYM_SIMILAR_ENTRY
value|18
end_define

begin_define
define|#
directive|define
name|SYM_NAME_SWITCH
value|19
end_define

begin_define
define|#
directive|define
name|SYM_BOOTSIZE
value|20
end_define

begin_define
define|#
directive|define
name|SYM_BOOT_SERVER
value|22
end_define

begin_define
define|#
directive|define
name|SYM_TFTPDIR
value|23
end_define

begin_define
define|#
directive|define
name|SYM_DUMPFILE
value|24
end_define

begin_define
define|#
directive|define
name|SYM_DOMAIN_NAME
value|25
end_define

begin_define
define|#
directive|define
name|SYM_SWAP_SERVER
value|26
end_define

begin_define
define|#
directive|define
name|SYM_ROOTPATH
value|27
end_define

begin_define
define|#
directive|define
name|OP_ADDITION
value|1
end_define

begin_comment
comment|/* Operations on tags */
end_comment

begin_define
define|#
directive|define
name|OP_DELETION
value|2
end_define

begin_define
define|#
directive|define
name|OP_BOOLEAN
value|3
end_define

begin_define
define|#
directive|define
name|MAXINADDRS
value|16
end_define

begin_comment
comment|/* Max size of an IP address list */
end_comment

begin_define
define|#
directive|define
name|MAXBUFLEN
value|64
end_define

begin_comment
comment|/* Max temp buffer space */
end_comment

begin_define
define|#
directive|define
name|MAXENTRYLEN
value|2048
end_define

begin_comment
comment|/* Max size of an entire entry */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Structure used to map a configuration-file symbol (such as "ds") to a  * unique integer.  */
end_comment

begin_struct
struct|struct
name|symbolmap
block|{
name|char
modifier|*
name|symbol
decl_stmt|;
name|int
name|symbolcode
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|htypename
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|byte
name|htype
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|PRIVATE
name|int
name|nhosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of hosts (/w hw or IP address) */
end_comment

begin_decl_stmt
name|PRIVATE
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries */
end_comment

begin_decl_stmt
name|PRIVATE
name|long
name|modtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of bootptab */
end_comment

begin_comment
comment|/*  * List of symbolic names used in the bootptab file.  The order and actual  * values of the symbol codes (SYM_. . .) are unimportant, but they must  * all be unique.  */
end_comment

begin_decl_stmt
name|PRIVATE
name|struct
name|symbolmap
name|symbol_list
index|[]
init|=
block|{
block|{
literal|"bf"
block|,
name|SYM_BOOTFILE
block|}
block|,
block|{
literal|"bs"
block|,
name|SYM_BOOTSIZE
block|}
block|,
block|{
literal|"cs"
block|,
name|SYM_COOKIE_SERVER
block|}
block|,
block|{
literal|"df"
block|,
name|SYM_DUMPFILE
block|}
block|,
block|{
literal|"dn"
block|,
name|SYM_DOMAIN_NAME
block|}
block|,
block|{
literal|"ds"
block|,
name|SYM_DOMAIN_SERVER
block|}
block|,
block|{
literal|"gw"
block|,
name|SYM_GATEWAY
block|}
block|,
block|{
literal|"ha"
block|,
name|SYM_HADDR
block|}
block|,
block|{
literal|"hd"
block|,
name|SYM_HOMEDIR
block|}
block|,
block|{
literal|"hn"
block|,
name|SYM_NAME_SWITCH
block|}
block|,
block|{
literal|"ht"
block|,
name|SYM_HTYPE
block|}
block|,
block|{
literal|"im"
block|,
name|SYM_IMPRESS_SERVER
block|}
block|,
block|{
literal|"ip"
block|,
name|SYM_IPADDR
block|}
block|,
block|{
literal|"lg"
block|,
name|SYM_LOG_SERVER
block|}
block|,
block|{
literal|"lp"
block|,
name|SYM_LPR_SERVER
block|}
block|,
block|{
literal|"ns"
block|,
name|SYM_NAME_SERVER
block|}
block|,
block|{
literal|"rl"
block|,
name|SYM_RLP_SERVER
block|}
block|,
block|{
literal|"rp"
block|,
name|SYM_ROOTPATH
block|}
block|,
block|{
literal|"sa"
block|,
name|SYM_BOOT_SERVER
block|}
block|,
block|{
literal|"sm"
block|,
name|SYM_SUBNET_MASK
block|}
block|,
block|{
literal|"sw"
block|,
name|SYM_SWAP_SERVER
block|}
block|,
block|{
literal|"tc"
block|,
name|SYM_SIMILAR_ENTRY
block|}
block|,
block|{
literal|"td"
block|,
name|SYM_TFTPDIR
block|}
block|,
block|{
literal|"to"
block|,
name|SYM_TIME_OFFSET
block|}
block|,
block|{
literal|"ts"
block|,
name|SYM_TIME_SERVER
block|}
block|,
block|{
literal|"vm"
block|,
name|SYM_VENDOR_MAGIC
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of symbolic names for hardware types.  Name translates into  * hardware type code listed with it.  Names must begin with a letter  * and must be all lowercase.  This is searched linearly, so put  * commonly-used entries near the beginning.  */
end_comment

begin_decl_stmt
name|PRIVATE
name|struct
name|htypename
name|htnamemap
index|[]
init|=
block|{
block|{
literal|"ethernet"
block|,
name|HTYPE_ETHERNET
block|}
block|,
block|{
literal|"ethernet3"
block|,
name|HTYPE_EXP_ETHERNET
block|}
block|,
block|{
literal|"ether"
block|,
name|HTYPE_ETHERNET
block|}
block|,
block|{
literal|"ether3"
block|,
name|HTYPE_EXP_ETHERNET
block|}
block|,
block|{
literal|"ieee802"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"tr"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"token-ring"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"pronet"
block|,
name|HTYPE_PRONET
block|}
block|,
block|{
literal|"chaos"
block|,
name|HTYPE_CHAOS
block|}
block|,
block|{
literal|"arcnet"
block|,
name|HTYPE_ARCNET
block|}
block|,
block|{
literal|"ax.25"
block|,
name|HTYPE_AX25
block|}
block|,
block|{
literal|"direct"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"serial"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"slip"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"ppp"
block|,
name|HTYPE_DIRECT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Externals and forward declarations.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|iplookcmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|PRIVATE
name|char
modifier|*
name|smalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|fill_defaults
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|del_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|del_bindata
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|del_iplist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|free_host
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|u_long
name|get_u_long
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|process_generic
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|char
modifier|*
name|get_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|struct
name|shared_string
modifier|*
name|get_shared_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|read_entry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|boolean
name|nullcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|boolean
name|nmcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|boolean
name|hwinscmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|adjust
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|eat_whitespace
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|void
name|makelower
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|struct
name|in_addr_list
modifier|*
name|get_addresses
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PRIVATE
name|byte
modifier|*
name|prs_haddr
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  * Read bootptab database file.  Avoid rereading the file if the  * write date hasn't changed since the last time we read it.  */
end_comment

begin_function
name|int
name|readtab
parameter_list|()
block|{
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|,
name|buflen
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|MAXENTRYLEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
name|timestr
index|[
literal|26
index|]
decl_stmt|;
endif|#
directive|endif
comment|/*      * Check the last modification time.      */
if|if
condition|(
name|stat
argument_list|(
name|bootptab
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stat on \"%s\": %s\n"
argument_list|,
name|bootptab
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|timestr
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|st
operator|.
name|st_mtime
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bootptab mtime is %s"
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|==
name|modtime
operator|&&
name|st
operator|.
name|st_nlink
condition|)
block|{
comment|/* 	 * hasn't been modified or deleted yet. 	 */
return|return
literal|0
return|;
block|}
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"reading %s\"%s\"\n"
argument_list|,
operator|(
name|modtime
operator|!=
literal|0L
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|,
name|bootptab
argument_list|)
expr_stmt|;
comment|/*      * Open bootptab file.      */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bootptab
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error opening \"%s\": %s\n"
argument_list|,
name|bootptab
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Record file modification time.      */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fstat: %s\n"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
comment|/*      * Entirely erase all hash tables.      */
name|hash_Reset
argument_list|(
name|hwhashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|hash_Reset
argument_list|(
name|iphashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|hash_Reset
argument_list|(
name|nmhashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|nhosts
operator|=
literal|0
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|read_entry
argument_list|(
name|fp
argument_list|,
name|buffer
argument_list|,
operator|&
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
comment|/* More entries? */
break|break;
block|}
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|host
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get individual info 	 */
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_entry
argument_list|(
name|hp
argument_list|,
name|buffer
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free_host
argument_list|(
name|hp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|&&
name|hp
operator|->
name|flags
operator|.
name|haddr
operator|)
operator|||
name|hp
operator|->
name|flags
operator|.
name|iaddr
condition|)
block|{
name|nhosts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|&&
name|hp
operator|->
name|flags
operator|.
name|haddr
condition|)
block|{
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|hp
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|hwhashtable
argument_list|,
name|hashcode
argument_list|,
name|hwinscmp
argument_list|,
name|hp
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"duplicate %s address: %s\n"
argument_list|,
name|netname
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|hp
operator|->
name|haddr
argument_list|,
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
name|free_host
argument_list|(
name|hp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|iaddr
condition|)
block|{
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|&
operator|(
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|iphashtable
argument_list|,
name|hashcode
argument_list|,
name|nullcmp
argument_list|,
name|hp
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hash_Insert() failed on IP address insertion\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|nmhashtable
argument_list|,
name|hashcode
argument_list|,
name|nullcmp
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hash_Insert() failed on insertion of hostname: \"%s\"\n"
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|nentries
operator|++
expr_stmt|;
block|}
name|done
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"read %d entries (%d hosts) from \"%s\"\n"
argument_list|,
name|nentries
argument_list|,
name|nhosts
argument_list|,
name|bootptab
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read an entire host entry from the file pointed to by "fp" and insert it  * into the memory pointed to by "buffer".  Leading whitespace and comments  * starting with "#" are ignored (removed).  Backslashes (\) always quote  * the next character except that newlines preceeded by a backslash cause  * line-continuation onto the next line.  The entry is terminated by a  * newline character which is not preceeded by a backslash.  Sequences  * surrounded by double quotes are taken literally (including newlines, but  * not backslashes).  *  * The "bufsiz" parameter points to an unsigned int which specifies the  * maximum permitted buffer size.  Upon return, this value will be replaced  * with the actual length of the entry (not including the null terminator).  *  * This code is a little scary. . . .  I don't like using gotos in C  * either, but I first wrote this as an FSM diagram and gotos seemed like  * the easiest way to implement it.  Maybe later I'll clean it up.  */
end_comment

begin_function
name|PRIVATE
name|void
name|read_entry
parameter_list|(
name|fp
parameter_list|,
name|buffer
parameter_list|,
name|bufsiz
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
modifier|*
name|bufsiz
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|length
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/*      * Eat whitespace, blank lines, and comment lines.      */
name|top
label|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit if end-of-file */
block|}
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Skip over whitespace */
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* Eat comments after # */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit if end-of-file */
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Try to read the next line */
block|}
block|}
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Other character, push it back to reprocess it */
comment|/*      * Now we're actually reading a data entry.  Get each character and      * assemble it into the data buffer, processing special characters like      * double quotes (") and backslashes (\).      */
name|mainloop
label|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
case|case
literal|'\n'
case|:
goto|goto
name|done
goto|;
comment|/* Exit on EOF or newline */
case|case
literal|'\\'
case|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Backslash, read a new character */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit on EOF */
block|}
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store the literal character */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|mainloop
goto|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
case|case
literal|'"'
case|:
operator|*
name|buffer
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* Store double-quote */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* Special quote processing loop */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
goto|goto
name|done
goto|;
comment|/* Exit on EOF . . . */
case|case
literal|'"'
case|:
operator|*
name|buffer
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* Store matching quote */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|mainloop
goto|;
comment|/* And continue main loop */
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Backslash */
goto|goto
name|done
goto|;
comment|/* EOF. . . .*/
block|}
comment|/* else fall through */
default|default:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Other character, store it */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
case|case
literal|':'
case|:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store colons */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
do|do
block|{
comment|/* But remove whitespace after them */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* Skip whitespace */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Backslash quotes next character */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Backslash-newline continuation */
block|}
block|}
comment|/* fall through if "other" character */
default|default:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store other characters */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
goto|goto
name|mainloop
goto|;
comment|/* Keep going */
name|done
label|:
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate string */
operator|*
name|bufsiz
operator|=
name|length
expr_stmt|;
comment|/* Tell the caller its length */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse out all the various tags and parameters in the host entry pointed  * to by "src".  Stuff all the data into the appropriate fields of the  * host structure pointed to by "host".  If there is any problem with the  * entry, an error message is reported via report(), no further processing  * is done, and -1 is returned.  Successful calls return 0.  *  * (Some errors probably shouldn't be so completely fatal. . . .)  */
end_comment

begin_function
name|PRIVATE
name|int
name|process_entry
parameter_list|(
name|host
parameter_list|,
name|src
parameter_list|)
name|struct
name|host
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|host
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|host
operator|->
name|hostname
operator|=
name|get_shared_string
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodname
argument_list|(
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad hostname: \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|host
operator|->
name|hostname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|adjust
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|retval
operator|=
name|eval_symbol
argument_list|(
operator|&
name|src
argument_list|,
name|host
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESS
case|:
break|break;
case|case
name|E_SYNTAX_ERROR
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"syntax error in entry for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_UNKNOWN_SYMBOL
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown symbol in entry for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_IPADDR
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad IP address for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_HADDR
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad hardware address for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_SMASK
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad subnet mask for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_TIMEOFF
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad time offset for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_VM_COOKIE
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad vendor magic cookie for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_HOMEDIR
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad home directory for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_TFTPDIR
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad TFTP directory for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_BOOT_SERVER
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad boot server IP address for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_BAD_SWAP_SERVER
case|:
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad swap server IP address for host \"%s\"\n"
argument_list|,
name|host
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|E_END_OF_ENTRY
case|:
default|default:
if|#
directive|if
literal|0
comment|/* 		 * For now, don't try to make-up a subnet mask if one 		 * wasn't specified. 		 * 		 * This algorithm is also not entirely correct. 		 */
block|if (!(hp->flags.subnet_mask)) {
comment|/* 		     * Try to deduce the subnet mask from the network class 		     */
block|value = (ntohl(value)>> 30)& 0x03; 		    switch (value) { 			case 0: 			case 1: 			    hp->subnet_mask.s_addr = htonl(0xFF000000L); 			    break; 			case 2: 			    hp->subnet_mask.s_addr = htonl(0xFFFF0000L); 			    break; 			case 3: 			    hp->subnet_mask.s_addr = htonl(0xFFFFFF00L); 			    break; 		    } 		    hp->flags.subnet_mask = TRUE; 		}
endif|#
directive|endif
comment|/* 		 * And now we're done with this entry 		 */
return|return
literal|0
return|;
block|}
name|adjust
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Evaluate the two-character tag symbol pointed to by "symbol" and place  * the data in the structure pointed to by "hp".  The pointer pointed to  * by "symbol" is updated to point past the source string (but may not  * point to the next tag entry).  *  * Obviously, this need a few more comments. . . .  */
end_comment

begin_function
name|PRIVATE
name|eval_symbol
parameter_list|(
name|symbol
parameter_list|,
name|hp
parameter_list|)
name|char
modifier|*
modifier|*
name|symbol
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|char
name|tmpstr
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|tmphaddr
decl_stmt|,
modifier|*
name|ustr
decl_stmt|;
name|struct
name|shared_string
modifier|*
name|ss
decl_stmt|;
name|struct
name|symbolmap
modifier|*
name|symbolptr
decl_stmt|;
name|u_long
name|value
decl_stmt|;
name|long
name|timeoff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numsymbols
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|int
name|optype
decl_stmt|;
comment|/* Indicates boolean, addition, or deletion */
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
name|E_END_OF_ENTRY
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
block|{
comment|/* generic symbol */
operator|(
operator|*
name|symbol
operator|)
operator|++
expr_stmt|;
name|value
operator|=
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|!=
literal|'='
condition|)
block|{
return|return
name|E_SYNTAX_ERROR
return|;
block|}
operator|(
operator|*
name|symbol
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|generic
operator|)
condition|)
block|{
name|hp
operator|->
name|generic
operator|=
operator|(
expr|struct
name|shared_bindata
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_bindata
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|process_generic
argument_list|(
name|symbol
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|generic
operator|)
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|generic
operator|=
name|TRUE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/*      * Determine the type of operation to be done on this symbol      */
switch|switch
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'='
case|:
name|optype
operator|=
name|OP_ADDITION
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|optype
operator|=
name|OP_DELETION
expr_stmt|;
break|break;
case|case
literal|':'
case|:
case|case
literal|'\0'
case|:
name|optype
operator|=
name|OP_BOOLEAN
expr_stmt|;
break|break;
default|default:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
name|symbolptr
operator|=
name|symbol_list
expr_stmt|;
name|numsymbols
operator|=
sizeof|sizeof
argument_list|(
name|symbol_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symbolmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsymbols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|symbolptr
operator|->
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
name|symbolptr
operator|->
name|symbol
operator|)
index|[
literal|1
index|]
operator|==
operator|(
operator|*
name|symbol
operator|)
index|[
literal|1
index|]
operator|)
condition|)
block|{
break|break;
block|}
name|symbolptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|numsymbols
condition|)
block|{
return|return
name|E_UNKNOWN_SYMBOL
return|;
block|}
comment|/*      * Skip past the = or @ character (to point to the data) if this      * isn't a boolean operation.  For boolean operations, just skip      * over the two-character tag symbol (and nothing else. . . .).      */
operator|(
operator|*
name|symbol
operator|)
operator|+=
operator|(
name|optype
operator|==
name|OP_BOOLEAN
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
switch|switch
condition|(
name|symbolptr
operator|->
name|symbolcode
condition|)
block|{
case|case
name|SYM_BOOTFILE
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|bootfile
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|bootfile
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|bootfile
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootfile
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|bootfile
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|bootfile
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|bootfile
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootfile
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_COOKIE_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
operator|&&
name|hp
operator|->
name|cookie_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|cookie_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|cookie_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|cookie_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
operator|&&
name|hp
operator|->
name|cookie_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|cookie_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|cookie_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|cookie_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_DOMAIN_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
operator|&&
name|hp
operator|->
name|domain_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|domain_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|domain_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|domain_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
operator|&&
name|hp
operator|->
name|domain_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|domain_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|domain_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|domain_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_GATEWAY
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
operator|&&
name|hp
operator|->
name|gateway
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|gateway
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|gateway
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|gateway
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
operator|&&
name|hp
operator|->
name|gateway
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|gateway
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|gateway
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|gateway
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_HADDR
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|&&
name|hp
operator|->
name|htype
operator|&&
operator|(
name|tmphaddr
operator|=
name|prs_haddr
argument_list|(
name|symbol
argument_list|,
name|hp
operator|->
name|htype
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|tmphaddr
argument_list|,
name|hp
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|haddr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
return|return
name|E_BAD_HADDR
return|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|haddr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_HOMEDIR
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ss
operator|->
name|string
operator|)
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|homedir
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|homedir
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|homedir
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|homedir
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
return|return
name|E_BAD_HOMEDIR
return|;
block|}
block|}
else|else
block|{
return|return
name|E_BAD_HOMEDIR
return|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|homedir
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|homedir
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|homedir
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|homedir
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_HTYPE
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
name|value
operator|=
literal|0L
expr_stmt|;
comment|/* Assume an illegal value */
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|symbol
argument_list|)
condition|)
block|{
name|value
operator|=
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|symbol
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|numsymbols
operator|=
sizeof|sizeof
argument_list|(
name|htnamemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|htypename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsymbols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|htnamemap
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tmpstr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|numsymbols
condition|)
block|{
name|value
operator|=
name|htnamemap
index|[
name|i
index|]
operator|.
name|htype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|value
operator|<
literal|0
operator|)
operator|||
operator|(
name|value
operator|>
name|MAXHTYPES
operator|)
condition|)
block|{
return|return
name|E_BAD_HTYPE
return|;
block|}
name|hp
operator|->
name|htype
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_IMPRESS_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|impress_server
operator|&&
name|hp
operator|->
name|impress_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|impress_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|impress_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|impress_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|impress_server
operator|&&
name|hp
operator|->
name|impress_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|impress_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|impress_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|impress_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_IPADDR
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|E_BAD_IPADDR
return|;
block|}
else|else
block|{
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|iaddr
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|iaddr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_LOG_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
operator|&&
name|hp
operator|->
name|log_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|log_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|log_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|log_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
operator|&&
name|hp
operator|->
name|log_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|log_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|log_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|log_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_LPR_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
operator|&&
name|hp
operator|->
name|lpr_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|lpr_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|lpr_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|lpr_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
operator|&&
name|hp
operator|->
name|lpr_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|lpr_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|lpr_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|lpr_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_NAME_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
operator|&&
name|hp
operator|->
name|name_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|name_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|name_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
operator|&&
name|hp
operator|->
name|name_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|name_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|name_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_RLP_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
operator|&&
name|hp
operator|->
name|rlp_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|rlp_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rlp_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|rlp_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
operator|&&
name|hp
operator|->
name|rlp_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|rlp_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rlp_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|rlp_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_SUBNET_MASK
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|E_BAD_SMASK
return|;
block|}
else|else
block|{
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_TIME_OFFSET
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|symbol
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpstr
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|timeoff_auto
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|tmpstr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|timeoff
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
name|E_BAD_TIMEOFF
return|;
block|}
else|else
block|{
name|hp
operator|->
name|time_offset
operator|=
name|timeoff
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|timeoff_auto
operator|=
name|FALSE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_TIME_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
operator|&&
name|hp
operator|->
name|time_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|time_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|time_server
operator|=
name|get_addresses
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|time_server
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
operator|&&
name|hp
operator|->
name|time_server
condition|)
block|{
name|del_iplist
argument_list|(
name|hp
operator|->
name|time_server
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|time_server
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|time_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_VENDOR_MAGIC
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|TRUE
expr_stmt|;
comment|/* Make it auto */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"rfc1048"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"rfc1084"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|FALSE
expr_stmt|;
comment|/* Make it manual */
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"cmu"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|FALSE
expr_stmt|;
comment|/* Make it manual */
name|bcopy
argument_list|(
name|vm_cmu
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|E_BAD_VM_COOKIE
return|;
block|}
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|FALSE
expr_stmt|;
comment|/* Make it manual */
name|ustr
operator|=
name|hp
operator|->
name|vm_cookie
expr_stmt|;
name|insert_u_long
argument_list|(
name|value
argument_list|,
operator|&
name|ustr
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SYM_SIMILAR_ENTRY
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
name|fill_defaults
argument_list|(
name|hp
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_NAME_SWITCH
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
return|return
name|E_SYNTAX_ERROR
return|;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|FALSE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SYM_BOOTSIZE
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|bootsize
operator|=
operator|(
name|unsigned
name|int
operator|)
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SYM_BOOT_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|E_BAD_BOOT_SERVER
return|;
block|}
else|else
block|{
name|hp
operator|->
name|bootserver
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootserver
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|bootserver
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_TFTPDIR
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ss
operator|->
name|string
operator|)
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|tftpdir
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|tftpdir
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|tftpdir
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|tftpdir
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
return|return
name|E_BAD_TFTPDIR
return|;
block|}
block|}
else|else
block|{
return|return
name|E_BAD_TFTPDIR
return|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|tftpdir
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|tftpdir
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|tftpdir
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|tftpdir
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_DUMPFILE
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|dumpfile
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|dumpfile
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|dumpfile
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|dumpfile
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|dumpfile
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|dumpfile
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|dumpfile
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|dumpfile
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_DOMAIN_NAME
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|domainname
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|domainname
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|domainname
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|domainname
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|domainname
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|domainname
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|domainname
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|domainname
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_ROOTPATH
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|ss
operator|=
name|get_shared_string
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|rootpath
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|rootpath
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rootpath
operator|=
name|ss
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|rootpath
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
if|if
condition|(
name|hp
operator|->
name|rootpath
condition|)
block|{
name|del_string
argument_list|(
name|hp
operator|->
name|rootpath
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rootpath
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|rootpath
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_SWAP_SERVER
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|E_BAD_SWAP_SERVER
return|;
block|}
else|else
block|{
name|hp
operator|->
name|swapserver
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|swap_server
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|swap_server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
default|default:
return|return
name|E_UNKNOWN_SYMBOL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read a string from the buffer indirectly pointed to through "src" and  * move it into the buffer pointed to by "dest".  A pointer to the maximum  * allowable length of the string (including null-terminator) is passed as  * "length".  The actual length of the string which was read is returned in  * the unsigned integer pointed to by "length".  This value is the same as  * that which would be returned by applying the strlen() function on the  * destination string (i.e the terminating null is not counted as a  * character).  Trailing whitespace is removed from the string.  For  * convenience, the function returns the new value of "dest".  *  * The string is read until the maximum number of characters, an unquoted  * colon (:), or a null character is read.  The return string in "dest" is  * null-terminated.  */
end_comment

begin_function
name|PRIVATE
name|char
modifier|*
name|get_string
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
modifier|*
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|len
decl_stmt|,
name|quoteflag
decl_stmt|;
name|quoteflag
operator|=
name|FALSE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|*
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|<
name|len
operator|)
operator|&&
operator|(
operator|*
operator|*
name|src
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quoteflag
operator|&&
operator|(
operator|*
operator|*
name|src
operator|==
literal|':'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
name|quoteflag
operator|=
operator|!
name|quoteflag
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|src
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|dest
operator|++
operator|=
operator|*
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/*      * Remove that troublesome trailing whitespace. . .      */
while|while
condition|(
operator|(
name|n
operator|>
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
name|dest
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|dest
operator|--
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|length
operator|=
name|n
expr_stmt|;
return|return
name|dest
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Read the string indirectly pointed to by "src", update the caller's  * pointer, and return a pointer to a malloc'ed shared_string structure  * containing the string.  *  * The string is read using the same rules as get_string() above.  */
end_comment

begin_function
name|PRIVATE
name|struct
name|shared_string
modifier|*
name|get_shared_string
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|char
name|retstring
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|struct
name|shared_string
modifier|*
name|s
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
name|retstring
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
name|retstring
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|shared_string
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_string
argument_list|)
operator|+
name|length
argument_list|)
expr_stmt|;
name|s
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|->
name|string
argument_list|,
name|retstring
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Load RFC1048 generic information directly into a memory buffer.  *  * "src" indirectly points to the ASCII representation of the generic data.  * "dest" points to a string structure which is updated to point to a new  * string with the new data appended to the old string.  The old string is  * freed.  *  * The given tag value is inserted with the new data.  *  * The data may be represented as either a stream of hexadecimal numbers  * representing bytes (any or all bytes may optionally start with '0x' and  * be separated with periods ".") or as a quoted string of ASCII  * characters (the quotes are required).  */
end_comment

begin_function
name|PRIVATE
name|void
name|process_generic
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|tagvalue
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|struct
name|shared_bindata
modifier|*
modifier|*
name|dest
decl_stmt|;
name|byte
name|tagvalue
decl_stmt|;
block|{
name|byte
name|tmpbuf
index|[
name|MAXBUFLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|str
decl_stmt|;
name|struct
name|shared_bindata
modifier|*
name|bdata
decl_stmt|;
name|int
name|newlength
decl_stmt|,
name|oldlength
decl_stmt|;
name|str
operator|=
name|tmpbuf
expr_stmt|;
operator|*
name|str
operator|++
operator|=
name|tagvalue
expr_stmt|;
comment|/* Store tag value */
name|str
operator|++
expr_stmt|;
comment|/* Skip over length field */
if|if
condition|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
comment|/* ASCII data */
name|newlength
operator|=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/* Set maximum allowed length */
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
name|str
argument_list|,
operator|&
name|newlength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Numeric data */
name|newlength
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newlength
operator|<
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|interp_byte
argument_list|(
name|src
argument_list|,
name|str
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|newlength
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
name|tmpbuf
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|newlength
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|oldlength
operator|=
operator|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|length
operator|)
expr_stmt|;
name|bdata
operator|=
operator|(
expr|struct
name|shared_bindata
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_bindata
argument_list|)
operator|+
name|oldlength
operator|+
name|newlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlength
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
argument_list|,
name|bdata
operator|->
name|data
argument_list|,
name|oldlength
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|tmpbuf
argument_list|,
name|bdata
operator|->
name|data
operator|+
name|oldlength
argument_list|,
name|newlength
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bdata
operator|->
name|length
operator|=
name|oldlength
operator|+
name|newlength
operator|+
literal|2
expr_stmt|;
name|bdata
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|dest
condition|)
block|{
name|del_bindata
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest
operator|=
name|bdata
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Verify that the given string makes sense as a hostname (according to  * Appendix 1, page 29 of RFC882).  *  * Return TRUE for good names, FALSE otherwise.  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|goodname
parameter_list|(
name|hostname
parameter_list|)
specifier|register
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|hostname
operator|++
argument_list|)
condition|)
block|{
comment|/* First character must be a letter */
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|hostname
argument_list|)
operator|||
operator|(
operator|*
name|hostname
operator|==
literal|'-'
operator|)
condition|)
block|{
name|hostname
operator|++
expr_stmt|;
comment|/* Alphanumeric or a hyphen */
block|}
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|hostname
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Last must be alphanumeric */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|hostname
operator|==
literal|'\0'
condition|)
block|{
comment|/* Done? */
return|return
name|TRUE
return|;
block|}
block|}
do|while
condition|(
operator|*
name|hostname
operator|++
operator|==
literal|'.'
condition|)
do|;
comment|/* Dot, loop for next label */
return|return
name|FALSE
return|;
comment|/* If it's not a dot, lose */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Null compare function -- always returns FALSE so an element is always  * inserted into a hash table (i.e. there is never a collision with an  * existing element).  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|nullcmp
parameter_list|(
name|host1
parameter_list|,
name|host2
parameter_list|)
name|struct
name|host
modifier|*
name|host1
decl_stmt|,
decl|*
name|host2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Function for comparing a string with the hostname field of a host  * structure.  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|nmcmp
parameter_list|(
name|name
parameter_list|,
name|hp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare function to determine whether two hardware addresses are  * equivalent.  Returns TRUE if "host1" and "host2" are equivalent, FALSE  * otherwise.  *  * If the hardware addresses of "host1" and "host2" are identical, but  * they are on different IP subnets, this function returns FALSE.  *  * This function is used when inserting elements into the hardware address  * hash table.  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|hwinscmp
parameter_list|(
name|host1
parameter_list|,
name|host2
parameter_list|)
name|struct
name|host
modifier|*
name|host1
decl_stmt|,
decl|*
name|host2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|host1
operator|->
name|htype
operator|!=
name|host2
operator|->
name|htype
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|host1
operator|->
name|haddr
argument_list|,
name|host2
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|host1
operator|->
name|htype
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|host1
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|==
operator|(
name|host2
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|host1
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
operator|&
operator|(
name|host1
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|)
operator|!=
operator|(
operator|(
name|host2
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
operator|&
operator|(
name|host2
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process the "similar entry" symbol.  *  * The host specified as the value of the "tc" symbol is used as a template  * for the current host entry.  Symbol values not explicitly set in the  * current host entry are inferred from the template entry.  */
end_comment

begin_function
name|PRIVATE
name|void
name|fill_defaults
parameter_list|(
name|hp
parameter_list|,
name|src
parameter_list|)
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|unsigned
name|tlen
decl_stmt|,
name|hashcode
decl_stmt|;
name|struct
name|host
modifier|*
name|hp2
decl_stmt|,
name|thp
decl_stmt|;
name|char
name|tstring
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
name|tstring
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
name|tstring
argument_list|,
operator|&
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|goodname
argument_list|(
name|tstring
argument_list|)
condition|)
block|{
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|tstring
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|hp2
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|nmhashtable
argument_list|,
name|hashcode
argument_list|,
name|nmcmp
argument_list|,
name|tstring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thp
operator|.
name|iaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|tstring
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|&
operator|(
name|thp
operator|.
name|iaddr
operator|.
name|s_addr
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hp2
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|iphashtable
argument_list|,
name|hashcode
argument_list|,
name|iplookcmp
argument_list|,
operator|&
name|thp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find tc=\"%s\"\n"
argument_list|,
name|tstring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Assignments inside "if" conditionals are intended here. 	 */
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|cookie_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|cookie_server
condition|)
block|{
name|hp
operator|->
name|cookie_server
operator|=
name|hp2
operator|->
name|cookie_server
expr_stmt|;
operator|(
name|hp
operator|->
name|cookie_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
name|hp
operator|->
name|domain_server
operator|=
name|hp2
operator|->
name|domain_server
expr_stmt|;
operator|(
name|hp
operator|->
name|domain_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
operator|=
name|hp2
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
name|hp
operator|->
name|gateway
operator|=
name|hp2
operator|->
name|gateway
expr_stmt|;
operator|(
name|hp
operator|->
name|gateway
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|impress_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|impress_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|impress_server
condition|)
block|{
name|hp
operator|->
name|impress_server
operator|=
name|hp2
operator|->
name|impress_server
expr_stmt|;
operator|(
name|hp
operator|->
name|impress_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|log_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|log_server
condition|)
block|{
name|hp
operator|->
name|log_server
operator|=
name|hp2
operator|->
name|log_server
expr_stmt|;
operator|(
name|hp
operator|->
name|log_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|lpr_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|lpr_server
condition|)
block|{
name|hp
operator|->
name|lpr_server
operator|=
name|hp2
operator|->
name|lpr_server
expr_stmt|;
operator|(
name|hp
operator|->
name|lpr_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
name|hp
operator|->
name|name_server
operator|=
name|hp2
operator|->
name|name_server
expr_stmt|;
operator|(
name|hp
operator|->
name|name_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|rlp_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|rlp_server
condition|)
block|{
name|hp
operator|->
name|rlp_server
operator|=
name|hp2
operator|->
name|rlp_server
expr_stmt|;
operator|(
name|hp
operator|->
name|rlp_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
name|hp
operator|->
name|time_server
operator|=
name|hp2
operator|->
name|time_server
expr_stmt|;
operator|(
name|hp
operator|->
name|time_server
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|homedir
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|homedir
operator|=
name|hp2
operator|->
name|flags
operator|.
name|homedir
condition|)
block|{
name|hp
operator|->
name|homedir
operator|=
name|hp2
operator|->
name|homedir
expr_stmt|;
operator|(
name|hp
operator|->
name|homedir
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|bootfile
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootfile
operator|=
name|hp2
operator|->
name|flags
operator|.
name|bootfile
condition|)
block|{
name|hp
operator|->
name|bootfile
operator|=
name|hp2
operator|->
name|bootfile
expr_stmt|;
operator|(
name|hp
operator|->
name|bootfile
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|generic
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|generic
operator|=
name|hp2
operator|->
name|flags
operator|.
name|generic
condition|)
block|{
name|hp
operator|->
name|generic
operator|=
name|hp2
operator|->
name|generic
expr_stmt|;
operator|(
name|hp
operator|->
name|generic
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|vm_auto
operator|=
name|hp2
operator|->
name|flags
operator|.
name|vm_auto
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
operator|=
name|hp2
operator|->
name|flags
operator|.
name|vendor_magic
condition|)
block|{
name|bcopy
argument_list|(
name|hp2
operator|->
name|vm_cookie
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|name_switch
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|hp2
operator|->
name|flags
operator|.
name|name_switch
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|hp2
operator|->
name|flags
operator|.
name|send_name
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|htype
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|hp2
operator|->
name|flags
operator|.
name|htype
condition|)
block|{
name|hp
operator|->
name|htype
operator|=
name|hp2
operator|->
name|htype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|time_offset
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|hp2
operator|->
name|flags
operator|.
name|time_offset
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|timeoff_auto
operator|=
name|hp2
operator|->
name|flags
operator|.
name|timeoff_auto
expr_stmt|;
name|hp
operator|->
name|time_offset
operator|=
name|hp2
operator|->
name|time_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
operator|=
name|hp2
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|=
name|hp2
operator|->
name|subnet_mask
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|swap_server
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|swap_server
operator|=
name|hp2
operator|->
name|flags
operator|.
name|swap_server
condition|)
block|{
name|hp
operator|->
name|swapserver
operator|.
name|s_addr
operator|=
name|hp2
operator|->
name|swapserver
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|hp2
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|hp2
operator|->
name|flags
operator|.
name|bootsize_auto
expr_stmt|;
name|hp
operator|->
name|bootsize
operator|=
name|hp2
operator|->
name|bootsize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|tftpdir
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|tftpdir
operator|=
name|hp2
operator|->
name|flags
operator|.
name|tftpdir
condition|)
block|{
name|hp
operator|->
name|tftpdir
operator|=
name|hp2
operator|->
name|tftpdir
expr_stmt|;
operator|(
name|hp
operator|->
name|tftpdir
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|rootpath
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rootpath
operator|=
name|hp2
operator|->
name|flags
operator|.
name|rootpath
condition|)
block|{
name|hp
operator|->
name|rootpath
operator|=
name|hp2
operator|->
name|rootpath
expr_stmt|;
operator|(
name|hp
operator|->
name|rootpath
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|domainname
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domainname
operator|=
name|hp2
operator|->
name|flags
operator|.
name|domainname
condition|)
block|{
name|hp
operator|->
name|domainname
operator|=
name|hp2
operator|->
name|domainname
expr_stmt|;
operator|(
name|hp
operator|->
name|domainname
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|dumpfile
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|dumpfile
operator|=
name|hp2
operator|->
name|flags
operator|.
name|dumpfile
condition|)
block|{
name|hp
operator|->
name|dumpfile
operator|=
name|hp2
operator|->
name|dumpfile
expr_stmt|;
operator|(
name|hp
operator|->
name|dumpfile
operator|->
name|linkcount
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This function adjusts the caller's pointer to point just past the  * first-encountered colon.  If it runs into a null character, it leaves  * the pointer pointing to it.  */
end_comment

begin_function
name|PRIVATE
name|void
name|adjust
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|':'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function adjusts the caller's pointer to point to the first  * non-whitespace character.  If it runs into a null character, it leaves  * the pointer pointing to it.  */
end_comment

begin_function
name|PRIVATE
name|void
name|eat_whitespace
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function converts the given string to all lowercase.  */
end_comment

begin_function
name|PRIVATE
name|void
name|makelower
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  *	N O T E :  *  *	In many of the functions which follow, a parameter such as "src" or  *	"symbol" is passed as a pointer to a pointer to something.  This is  *	done for the purpose of letting the called function update the  *	caller's copy of the parameter (i.e. to effect call-by-reference  *	parameter passing).  The value of the actual parameter is only used  *	to locate the real parameter of interest and then update this indirect  *	parameter.  *  *	I'm sure somebody out there won't like this. . . .  *  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * "src" points to a character pointer which points to an ASCII string of  * whitespace-separated IP addresses.  A pointer to an in_addr_list  * structure containing the list of addresses is returned.  NULL is  * returned if no addresses were found at all.  The pointer pointed to by  * "src" is updated to point to the first non-address (illegal) character.  */
end_comment

begin_function
name|PRIVATE
name|struct
name|in_addr_list
modifier|*
name|get_addresses
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|struct
name|in_addr
name|tmpaddrlist
index|[
name|MAXINADDRS
index|]
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|address1
decl_stmt|,
modifier|*
name|address2
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|result
decl_stmt|;
name|unsigned
name|addrcount
decl_stmt|,
name|totalsize
decl_stmt|;
name|address1
operator|=
name|tmpaddrlist
expr_stmt|;
for|for
control|(
name|addrcount
operator|=
literal|0
init|;
name|addrcount
operator|<
name|MAXINADDRS
condition|;
name|addrcount
operator|++
control|)
block|{
while|while
condition|(
operator|*
operator|*
name|src
operator|&&
name|isspace
argument_list|(
operator|*
operator|*
name|src
argument_list|)
condition|)
block|{
comment|/* Skip whitespace */
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
operator|*
name|src
condition|)
block|{
comment|/* Quit if nothing more */
break|break;
block|}
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|address1
operator|->
name|s_addr
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|address1
operator|++
expr_stmt|;
comment|/* Point to next address slot */
block|}
if|if
condition|(
name|addrcount
operator|<
literal|1
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|totalsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr_list
argument_list|)
operator|+
operator|(
name|addrcount
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|in_addr_list
operator|*
operator|)
name|smalloc
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
name|result
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
name|result
operator|->
name|addrcount
operator|=
name|addrcount
expr_stmt|;
name|address1
operator|=
name|tmpaddrlist
expr_stmt|;
name|address2
operator|=
name|result
operator|->
name|addr
expr_stmt|;
for|for
control|(
init|;
name|addrcount
operator|>
literal|0
condition|;
name|addrcount
operator|--
control|)
block|{
name|address2
operator|->
name|s_addr
operator|=
name|address1
operator|->
name|s_addr
expr_stmt|;
name|address1
operator|++
expr_stmt|;
name|address2
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * prs_inetaddr(src, result)  *  * "src" is a value-result parameter; the pointer it points to is updated  * to point to the next data position.   "result" points to an unsigned long  * in which an address is returned.  *  * This function parses the IP address string in ASCII "dot notation" pointed  * to by (*src) and places the result (in network byte order) in the unsigned  * long pointed to by "result".  For malformed addresses, -1 is returned,  * (*src) points to the first illegal character, and the unsigned long pointed  * to by "result" is unchanged.  Successful calls return 0.  */
end_comment

begin_function
name|PRIVATE
name|prs_inetaddr
parameter_list|(
name|src
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|u_long
modifier|*
name|result
decl_stmt|;
block|{
specifier|register
name|u_long
name|value
decl_stmt|;
name|u_long
name|parts
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|pp
init|=
name|parts
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|src
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|loop
label|:
name|value
operator|=
name|get_u_long
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
comment|/* 	 * Internet format: 	 *	a.b.c.d 	 *	a.b.c	(with c treated as 16-bits) 	 *	a.b	(with b treated as 24 bits) 	 */
if|if
condition|(
name|pp
operator|>=
name|parts
operator|+
literal|4
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|pp
operator|++
operator|=
name|value
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/*      * Check for trailing characters.      */
if|if
condition|(
operator|*
operator|*
name|src
operator|&&
operator|!
operator|(
name|isspace
argument_list|(
operator|*
operator|*
name|src
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|src
operator|==
literal|':'
operator|)
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|pp
operator|++
operator|=
name|value
expr_stmt|;
comment|/*      * Construct the address according to      * the number of parts specified.      */
name|n
operator|=
name|pp
operator|-
name|parts
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
comment|/* a -- 32 bits */
name|value
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* a.b -- 8.24 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFFFFFF
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* a.b.c -- 8.8.16 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* a.b.c.d -- 8.8.8.8 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|parts
index|[
literal|3
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|result
operator|=
name|htonl
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * "src" points to a pointer which in turn points to a hexadecimal ASCII  * string.  This string is interpreted as a hardware address and returned  * as a pointer to the actual hardware address, represented as an array of  * bytes.  *  * The ASCII string must have the proper number of digits for the specified  * hardware type (e.g. twelve digits for a 48-bit Ethernet address).  * Two-digit sequences (bytes) may be separated with periods (.)  and/or  * prefixed with '0x' for readability, but this is not required.  *  * For bad addresses, the pointer which "src" points to is updated to point  * to the start of the first two-digit sequence which was bad, and the  * function returns a NULL pointer.  */
end_comment

begin_function
name|PRIVATE
name|byte
modifier|*
name|prs_haddr
parameter_list|(
name|src
parameter_list|,
name|htype
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|byte
name|htype
decl_stmt|;
block|{
specifier|static
name|byte
name|haddr
index|[
name|MAXHADDRLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|hptr
decl_stmt|;
name|unsigned
name|hlen
decl_stmt|;
name|hlen
operator|=
name|haddrlength
argument_list|(
name|htype
argument_list|)
expr_stmt|;
comment|/* Get length of this address type */
name|hptr
operator|=
name|haddr
expr_stmt|;
while|while
condition|(
name|hptr
operator|<
name|haddr
operator|+
name|hlen
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|interp_byte
argument_list|(
name|src
argument_list|,
name|hptr
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
return|return
name|haddr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * "src" is a pointer to a character pointer which in turn points to a  * hexadecimal ASCII representation of a byte.  This byte is read, the  * character pointer is updated, and the result is deposited into the  * byte pointed to by "retbyte".  *  * The usual '0x' notation is allowed but not required.  The number must be  * a two digit hexadecimal number.  If the number is invalid, "src" and  * "retbyte" are left untouched and -1 is returned as the function value.  * Successful calls return 0.  */
end_comment

begin_function
name|PRIVATE
name|int
name|interp_byte
parameter_list|(
name|src
parameter_list|,
name|retbyte
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|byte
modifier|*
name|retbyte
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* allow 0x for hex, but don't require it */
block|}
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|src
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|(
operator|*
name|src
operator|)
operator|+=
literal|2
expr_stmt|;
operator|*
name|retbyte
operator|=
call|(
name|byte
call|)
argument_list|(
name|v
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The parameter "src" points to a character pointer which points to an  * ASCII string representation of an unsigned number.  The number is  * returned as an unsigned long and the character pointer is updated to  * point to the first illegal character.  */
end_comment

begin_function
name|PRIVATE
name|u_long
name|get_u_long
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
specifier|register
name|u_long
name|value
decl_stmt|,
name|base
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/*      * Collect number up to first illegal character.  Values are specified      * as for C:  0x=hex, 0=octal, other=decimal.      */
name|value
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'0'
condition|)
block|{
name|base
operator|=
literal|8
operator|,
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'x'
operator|||
operator|*
operator|*
name|src
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
operator|,
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|=
operator|*
operator|*
name|src
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|*
name|base
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|c
operator|&
operator|~
literal|32
operator|)
operator|+
literal|10
operator|-
literal|'A'
operator|)
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routines for deletion of data associated with the main data structure.  */
end_comment

begin_comment
comment|/*  * Frees the entire host data structure given.  Does nothing if the passed  * pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|free_host
parameter_list|(
name|hostptr
parameter_list|)
name|struct
name|host
modifier|*
name|hostptr
decl_stmt|;
block|{
if|if
condition|(
name|hostptr
condition|)
block|{
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|cookie_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|domain_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|gateway
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|impress_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|log_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|lpr_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|name_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|rlp_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|time_server
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|homedir
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|bootfile
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|tftpdir
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|rootpath
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|domainname
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|dumpfile
argument_list|)
expr_stmt|;
name|del_bindata
argument_list|(
name|hostptr
operator|->
name|generic
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Decrements the linkcount on the given IP address data structure.  If the  * linkcount goes to zero, the memory associated with the data is freed.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_iplist
parameter_list|(
name|iplist
parameter_list|)
name|struct
name|in_addr_list
modifier|*
name|iplist
decl_stmt|;
block|{
if|if
condition|(
name|iplist
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|iplist
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iplist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decrements the linkcount on a string data structure.  If the count  * goes to zero, the memory associated with the string is freed.  Does  * nothing if the passed pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_string
parameter_list|(
name|stringptr
parameter_list|)
name|struct
name|shared_string
modifier|*
name|stringptr
decl_stmt|;
block|{
if|if
condition|(
name|stringptr
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|stringptr
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stringptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decrements the linkcount on a shared_bindata data structure.  If the  * count goes to zero, the memory associated with the data is freed.  Does  * nothing if the passed pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_bindata
parameter_list|(
name|dataptr
parameter_list|)
name|struct
name|shared_bindata
modifier|*
name|dataptr
decl_stmt|;
block|{
if|if
condition|(
name|dataptr
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|dataptr
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dataptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* smalloc()  --  safe malloc()  *  * Always returns a valid pointer (if it returns at all).  The allocated  * memory is initialized to all zeros.  If malloc() returns an error, a  * message is printed using the report() function and the program aborts  * with a status of 1.  */
end_comment

begin_function
name|PRIVATE
name|char
modifier|*
name|smalloc
parameter_list|(
name|nbytes
parameter_list|)
name|unsigned
name|nbytes
decl_stmt|;
block|{
name|char
modifier|*
name|retvalue
decl_stmt|;
name|retvalue
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retvalue
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc() failure -- exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|retvalue
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
name|retvalue
return|;
block|}
end_function

end_unit

