begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  	$Id: readfile.c,v 1.2 1996/09/22 21:52:26 wosch Exp $  ************************************************************************/
end_comment

begin_comment
comment|/*  * bootpd configuration file reading code.  *  * The routines in this file deal with reading, interpreting, and storing  * the information found in the bootpd configuration file (usually  * /etc/bootptab).  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"hwaddr.h"
end_include

begin_include
include|#
directive|include
file|"lookup.h"
end_include

begin_include
include|#
directive|include
file|"readfile.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_include
include|#
directive|include
file|"tzone.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_define
define|#
directive|define
name|HASHTABLESIZE
value|257
end_define

begin_comment
comment|/* Hash table size (prime) */
end_comment

begin_comment
comment|/* Non-standard hardware address type (see bootp.h) */
end_comment

begin_define
define|#
directive|define
name|HTYPE_DIRECT
value|0
end_define

begin_comment
comment|/* Error codes returned by eval_symbol: */
end_comment

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|E_END_OF_ENTRY
value|(-1)
end_define

begin_define
define|#
directive|define
name|E_SYNTAX_ERROR
value|(-2)
end_define

begin_define
define|#
directive|define
name|E_UNKNOWN_SYMBOL
value|(-3)
end_define

begin_define
define|#
directive|define
name|E_BAD_IPADDR
value|(-4)
end_define

begin_define
define|#
directive|define
name|E_BAD_HWADDR
value|(-5)
end_define

begin_define
define|#
directive|define
name|E_BAD_LONGWORD
value|(-6)
end_define

begin_define
define|#
directive|define
name|E_BAD_HWATYPE
value|(-7)
end_define

begin_define
define|#
directive|define
name|E_BAD_PATHNAME
value|(-8)
end_define

begin_define
define|#
directive|define
name|E_BAD_VALUE
value|(-9)
end_define

begin_comment
comment|/* Tag idendities. */
end_comment

begin_define
define|#
directive|define
name|SYM_NULL
value|0
end_define

begin_define
define|#
directive|define
name|SYM_BOOTFILE
value|1
end_define

begin_define
define|#
directive|define
name|SYM_COOKIE_SERVER
value|2
end_define

begin_define
define|#
directive|define
name|SYM_DOMAIN_SERVER
value|3
end_define

begin_define
define|#
directive|define
name|SYM_GATEWAY
value|4
end_define

begin_define
define|#
directive|define
name|SYM_HWADDR
value|5
end_define

begin_define
define|#
directive|define
name|SYM_HOMEDIR
value|6
end_define

begin_define
define|#
directive|define
name|SYM_HTYPE
value|7
end_define

begin_define
define|#
directive|define
name|SYM_IMPRESS_SERVER
value|8
end_define

begin_define
define|#
directive|define
name|SYM_IPADDR
value|9
end_define

begin_define
define|#
directive|define
name|SYM_LOG_SERVER
value|10
end_define

begin_define
define|#
directive|define
name|SYM_LPR_SERVER
value|11
end_define

begin_define
define|#
directive|define
name|SYM_NAME_SERVER
value|12
end_define

begin_define
define|#
directive|define
name|SYM_RLP_SERVER
value|13
end_define

begin_define
define|#
directive|define
name|SYM_SUBNET_MASK
value|14
end_define

begin_define
define|#
directive|define
name|SYM_TIME_OFFSET
value|15
end_define

begin_define
define|#
directive|define
name|SYM_TIME_SERVER
value|16
end_define

begin_define
define|#
directive|define
name|SYM_VENDOR_MAGIC
value|17
end_define

begin_define
define|#
directive|define
name|SYM_SIMILAR_ENTRY
value|18
end_define

begin_define
define|#
directive|define
name|SYM_NAME_SWITCH
value|19
end_define

begin_define
define|#
directive|define
name|SYM_BOOTSIZE
value|20
end_define

begin_define
define|#
directive|define
name|SYM_BOOT_SERVER
value|22
end_define

begin_define
define|#
directive|define
name|SYM_TFTPDIR
value|23
end_define

begin_define
define|#
directive|define
name|SYM_DUMP_FILE
value|24
end_define

begin_define
define|#
directive|define
name|SYM_DOMAIN_NAME
value|25
end_define

begin_define
define|#
directive|define
name|SYM_SWAP_SERVER
value|26
end_define

begin_define
define|#
directive|define
name|SYM_ROOT_PATH
value|27
end_define

begin_define
define|#
directive|define
name|SYM_EXTEN_FILE
value|28
end_define

begin_define
define|#
directive|define
name|SYM_REPLY_ADDR
value|29
end_define

begin_define
define|#
directive|define
name|SYM_NIS_DOMAIN
value|30
end_define

begin_comment
comment|/* RFC 1533 */
end_comment

begin_define
define|#
directive|define
name|SYM_NIS_SERVER
value|31
end_define

begin_comment
comment|/* RFC 1533 */
end_comment

begin_define
define|#
directive|define
name|SYM_NTP_SERVER
value|32
end_define

begin_comment
comment|/* RFC 1533 */
end_comment

begin_define
define|#
directive|define
name|SYM_EXEC_FILE
value|33
end_define

begin_comment
comment|/* YORK_EX_OPTION */
end_comment

begin_define
define|#
directive|define
name|SYM_MSG_SIZE
value|34
end_define

begin_define
define|#
directive|define
name|SYM_MIN_WAIT
value|35
end_define

begin_comment
comment|/* XXX - Add new tags here */
end_comment

begin_define
define|#
directive|define
name|OP_ADDITION
value|1
end_define

begin_comment
comment|/* Operations on tags */
end_comment

begin_define
define|#
directive|define
name|OP_DELETION
value|2
end_define

begin_define
define|#
directive|define
name|OP_BOOLEAN
value|3
end_define

begin_define
define|#
directive|define
name|MAXINADDRS
value|16
end_define

begin_comment
comment|/* Max size of an IP address list */
end_comment

begin_define
define|#
directive|define
name|MAXBUFLEN
value|256
end_define

begin_comment
comment|/* Max temp buffer space */
end_comment

begin_define
define|#
directive|define
name|MAXENTRYLEN
value|2048
end_define

begin_comment
comment|/* Max size of an entire entry */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Structure used to map a configuration-file symbol (such as "ds") to a  * unique integer.  */
end_comment

begin_struct
struct|struct
name|symbolmap
block|{
name|char
modifier|*
name|symbol
decl_stmt|;
name|int
name|symbolcode
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|htypename
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|byte
name|htype
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|PRIVATE
name|int
name|nhosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of hosts (/w hw or IP address) */
end_comment

begin_decl_stmt
name|PRIVATE
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries */
end_comment

begin_decl_stmt
name|PRIVATE
name|int32
name|modtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of bootptab */
end_comment

begin_decl_stmt
name|PRIVATE
name|char
modifier|*
name|current_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current entry. */
end_comment

begin_decl_stmt
name|PRIVATE
name|char
name|current_tagname
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of symbolic names used in the bootptab file.  The order and actual  * values of the symbol codes (SYM_. . .) are unimportant, but they must  * all be unique.  */
end_comment

begin_decl_stmt
name|PRIVATE
name|struct
name|symbolmap
name|symbol_list
index|[]
init|=
block|{
block|{
literal|"bf"
block|,
name|SYM_BOOTFILE
block|}
block|,
block|{
literal|"bs"
block|,
name|SYM_BOOTSIZE
block|}
block|,
block|{
literal|"cs"
block|,
name|SYM_COOKIE_SERVER
block|}
block|,
block|{
literal|"df"
block|,
name|SYM_DUMP_FILE
block|}
block|,
block|{
literal|"dn"
block|,
name|SYM_DOMAIN_NAME
block|}
block|,
block|{
literal|"ds"
block|,
name|SYM_DOMAIN_SERVER
block|}
block|,
block|{
literal|"ef"
block|,
name|SYM_EXTEN_FILE
block|}
block|,
block|{
literal|"ex"
block|,
name|SYM_EXEC_FILE
block|}
block|,
comment|/* YORK_EX_OPTION */
block|{
literal|"gw"
block|,
name|SYM_GATEWAY
block|}
block|,
block|{
literal|"ha"
block|,
name|SYM_HWADDR
block|}
block|,
block|{
literal|"hd"
block|,
name|SYM_HOMEDIR
block|}
block|,
block|{
literal|"hn"
block|,
name|SYM_NAME_SWITCH
block|}
block|,
block|{
literal|"ht"
block|,
name|SYM_HTYPE
block|}
block|,
block|{
literal|"im"
block|,
name|SYM_IMPRESS_SERVER
block|}
block|,
block|{
literal|"ip"
block|,
name|SYM_IPADDR
block|}
block|,
block|{
literal|"lg"
block|,
name|SYM_LOG_SERVER
block|}
block|,
block|{
literal|"lp"
block|,
name|SYM_LPR_SERVER
block|}
block|,
block|{
literal|"ms"
block|,
name|SYM_MSG_SIZE
block|}
block|,
block|{
literal|"mw"
block|,
name|SYM_MIN_WAIT
block|}
block|,
block|{
literal|"ns"
block|,
name|SYM_NAME_SERVER
block|}
block|,
block|{
literal|"nt"
block|,
name|SYM_NTP_SERVER
block|}
block|,
block|{
literal|"ra"
block|,
name|SYM_REPLY_ADDR
block|}
block|,
block|{
literal|"rl"
block|,
name|SYM_RLP_SERVER
block|}
block|,
block|{
literal|"rp"
block|,
name|SYM_ROOT_PATH
block|}
block|,
block|{
literal|"sa"
block|,
name|SYM_BOOT_SERVER
block|}
block|,
block|{
literal|"sm"
block|,
name|SYM_SUBNET_MASK
block|}
block|,
block|{
literal|"sw"
block|,
name|SYM_SWAP_SERVER
block|}
block|,
block|{
literal|"tc"
block|,
name|SYM_SIMILAR_ENTRY
block|}
block|,
block|{
literal|"td"
block|,
name|SYM_TFTPDIR
block|}
block|,
block|{
literal|"to"
block|,
name|SYM_TIME_OFFSET
block|}
block|,
block|{
literal|"ts"
block|,
name|SYM_TIME_SERVER
block|}
block|,
block|{
literal|"vm"
block|,
name|SYM_VENDOR_MAGIC
block|}
block|,
block|{
literal|"yd"
block|,
name|SYM_NIS_DOMAIN
block|}
block|,
block|{
literal|"ys"
block|,
name|SYM_NIS_SERVER
block|}
block|,
comment|/* XXX - Add new tags here */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of symbolic names for hardware types.  Name translates into  * hardware type code listed with it.  Names must begin with a letter  * and must be all lowercase.  This is searched linearly, so put  * commonly-used entries near the beginning.  */
end_comment

begin_decl_stmt
name|PRIVATE
name|struct
name|htypename
name|htnamemap
index|[]
init|=
block|{
block|{
literal|"ethernet"
block|,
name|HTYPE_ETHERNET
block|}
block|,
block|{
literal|"ethernet3"
block|,
name|HTYPE_EXP_ETHERNET
block|}
block|,
block|{
literal|"ether"
block|,
name|HTYPE_ETHERNET
block|}
block|,
block|{
literal|"ether3"
block|,
name|HTYPE_EXP_ETHERNET
block|}
block|,
block|{
literal|"ieee802"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"tr"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"token-ring"
block|,
name|HTYPE_IEEE802
block|}
block|,
block|{
literal|"pronet"
block|,
name|HTYPE_PRONET
block|}
block|,
block|{
literal|"chaos"
block|,
name|HTYPE_CHAOS
block|}
block|,
block|{
literal|"arcnet"
block|,
name|HTYPE_ARCNET
block|}
block|,
block|{
literal|"ax.25"
block|,
name|HTYPE_AX25
block|}
block|,
block|{
literal|"direct"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"serial"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"slip"
block|,
name|HTYPE_DIRECT
block|}
block|,
block|{
literal|"ppp"
block|,
name|HTYPE_DIRECT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Externals and forward declarations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|boolean
name|iplookcmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|boolean
name|nmcmp
name|P
argument_list|(
operator|(
name|hash_datum
operator|*
operator|,
name|hash_datum
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|adjust
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|del_string
name|P
argument_list|(
operator|(
expr|struct
name|shared_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|del_bindata
name|P
argument_list|(
operator|(
expr|struct
name|shared_bindata
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|del_iplist
name|P
argument_list|(
operator|(
expr|struct
name|in_addr_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|eat_whitespace
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|eval_symbol
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|host
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|fill_defaults
name|P
argument_list|(
operator|(
expr|struct
name|host
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|free_host
name|P
argument_list|(
operator|(
name|hash_datum
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|struct
name|in_addr_list
modifier|*
name|get_addresses
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|struct
name|shared_string
modifier|*
name|get_shared_string
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|char
modifier|*
name|get_string
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|u_int32
name|get_u_long
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|boolean
name|goodname
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|boolean
name|hwinscmp
name|P
argument_list|(
operator|(
name|hash_datum
operator|*
operator|,
name|hash_datum
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|interp_byte
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|makelower
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|boolean
name|nullcmp
name|P
argument_list|(
operator|(
name|hash_datum
operator|*
operator|,
name|hash_datum
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|process_entry
name|P
argument_list|(
operator|(
expr|struct
name|host
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|process_generic
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|shared_bindata
operator|*
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|byte
modifier|*
name|prs_haddr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|prs_inetaddr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|u_int32
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|read_entry
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|char
modifier|*
name|smalloc
name|P
argument_list|(
operator|(
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * Vendor magic cookies for CMU and RFC1048  */
end_comment

begin_decl_stmt
name|u_char
name|vm_cmu
index|[
literal|4
index|]
init|=
name|VM_CMU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|vm_rfc1048
index|[
literal|4
index|]
init|=
name|VM_RFC1048
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main hash tables  */
end_comment

begin_decl_stmt
name|hash_tbl
modifier|*
name|hwhashtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash_tbl
modifier|*
name|iphashtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash_tbl
modifier|*
name|nmhashtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate hash tables for hardware address, ip address, and hostname  * (shared by bootpd and bootpef)  */
end_comment

begin_function
name|void
name|rdtab_init
parameter_list|()
block|{
name|hwhashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
name|iphashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
name|nmhashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hwhashtable
operator|&&
name|iphashtable
operator|&&
name|nmhashtable
operator|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to allocate hash tables."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read bootptab database file.  Avoid rereading the file if the  * write date hasn't changed since the last time we read it.  */
end_comment

begin_function
name|void
name|readtab
parameter_list|(
name|force
parameter_list|)
name|int
name|force
decl_stmt|;
block|{
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|,
name|buflen
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|MAXENTRYLEN
index|]
decl_stmt|;
comment|/* 	 * Check the last modification time. 	 */
if|if
condition|(
name|stat
argument_list|(
name|bootptab
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stat on \"%s\": %s"
argument_list|,
name|bootptab
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|char
name|timestr
index|[
literal|28
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|timestr
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|st
operator|.
name|st_mtime
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zap the newline */
name|timestr
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bootptab mtime: %s"
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|force
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st
operator|.
name|st_mtime
operator|==
name|modtime
operator|)
operator|&&
name|st
operator|.
name|st_nlink
condition|)
block|{
comment|/* 		 * hasn't been modified or deleted yet. 		 */
return|return;
block|}
if|if
condition|(
name|debug
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"reading %s\"%s\""
argument_list|,
operator|(
name|modtime
operator|!=
literal|0L
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|,
name|bootptab
argument_list|)
expr_stmt|;
comment|/* 	 * Open bootptab file. 	 */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bootptab
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error opening \"%s\": %s"
argument_list|,
name|bootptab
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Record file modification time. 	 */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fstat: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
comment|/* 	 * Entirely erase all hash tables. 	 */
name|hash_Reset
argument_list|(
name|hwhashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|hash_Reset
argument_list|(
name|iphashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|hash_Reset
argument_list|(
name|nmhashtable
argument_list|,
name|free_host
argument_list|)
expr_stmt|;
name|nhosts
operator|=
literal|0
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|read_entry
argument_list|(
name|fp
argument_list|,
name|buffer
argument_list|,
operator|&
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
comment|/* More entries? */
break|break;
block|}
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the link count it zero */
comment|/* 		 * Get individual info 		 */
if|if
condition|(
name|process_entry
argument_list|(
name|hp
argument_list|,
name|buffer
argument_list|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
name|free_host
argument_list|(
operator|(
name|hash_datum
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If this is not a dummy entry, and the IP or HW 		 * address is not yet set, try to get them here. 		 * Dummy entries have . as first char of name. 		 */
if|if
condition|(
name|goodname
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
condition|)
block|{
name|char
modifier|*
name|hn
init|=
name|hp
operator|->
name|hostname
operator|->
name|string
decl_stmt|;
name|u_int32
name|value
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|iaddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lookup_ipa
argument_list|(
name|hn
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not get IP addr for %s"
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"(dummy names should start with '.')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|iaddr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Set default subnet mask. */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lookup_netmask
argument_list|(
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not get netmask for %s"
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|iaddr
condition|)
block|{
name|nhosts
operator|++
expr_stmt|;
block|}
comment|/* Register by HW addr if known. */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|&&
name|hp
operator|->
name|flags
operator|.
name|haddr
condition|)
block|{
comment|/* We will either insert it or free it. */
name|hp
operator|->
name|linkcount
operator|++
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|hp
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|hwhashtable
argument_list|,
name|hashcode
argument_list|,
name|hwinscmp
argument_list|,
name|hp
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"duplicate %s address: %s"
argument_list|,
name|netname
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|hp
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free_host
argument_list|(
operator|(
name|hash_datum
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Register by IP addr if known. */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|iaddr
condition|)
block|{
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|iphashtable
argument_list|,
name|hashcode
argument_list|,
name|nullcmp
argument_list|,
name|hp
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hash_Insert() failed on IP address insertion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just inserted the host struct in a new hash list. */
name|hp
operator|->
name|linkcount
operator|++
expr_stmt|;
block|}
block|}
comment|/* Register by Name (always known) */
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_Insert
argument_list|(
name|nmhashtable
argument_list|,
name|hashcode
argument_list|,
name|nullcmp
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|hp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hash_Insert() failed on insertion of hostname: \"%s\""
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just inserted the host struct in a new hash list. */
name|hp
operator|->
name|linkcount
operator|++
expr_stmt|;
block|}
name|nentries
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"read %d entries (%d hosts) from \"%s\""
argument_list|,
name|nentries
argument_list|,
name|nhosts
argument_list|,
name|bootptab
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read an entire host entry from the file pointed to by "fp" and insert it  * into the memory pointed to by "buffer".  Leading whitespace and comments  * starting with "#" are ignored (removed).  Backslashes (\) always quote  * the next character except that newlines preceeded by a backslash cause  * line-continuation onto the next line.  The entry is terminated by a  * newline character which is not preceeded by a backslash.  Sequences  * surrounded by double quotes are taken literally (including newlines, but  * not backslashes).  *  * The "bufsiz" parameter points to an unsigned int which specifies the  * maximum permitted buffer size.  Upon return, this value will be replaced  * with the actual length of the entry (not including the null terminator).  *  * This code is a little scary. . . .  I don't like using gotos in C  * either, but I first wrote this as an FSM diagram and gotos seemed like  * the easiest way to implement it.  Maybe later I'll clean it up.  */
end_comment

begin_function
name|PRIVATE
name|void
name|read_entry
parameter_list|(
name|fp
parameter_list|,
name|buffer
parameter_list|,
name|bufsiz
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
modifier|*
name|bufsiz
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|length
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Eat whitespace, blank lines, and comment lines. 	 */
name|top
label|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit if end-of-file */
block|}
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Skip over whitespace */
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* Eat comments after # */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit if end-of-file */
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Try to read the next line */
block|}
block|}
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Other character, push it back to reprocess it */
comment|/* 	 * Now we're actually reading a data entry.  Get each character and 	 * assemble it into the data buffer, processing special characters like 	 * double quotes (") and backslashes (\). 	 */
name|mainloop
label|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
case|case
literal|'\n'
case|:
goto|goto
name|done
goto|;
comment|/* Exit on EOF or newline */
case|case
literal|'\\'
case|:
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Backslash, read a new character */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* Exit on EOF */
block|}
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store the literal character */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|mainloop
goto|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
case|case
literal|'"'
case|:
operator|*
name|buffer
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* Store double-quote */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* Special quote processing loop */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
goto|goto
name|done
goto|;
comment|/* Exit on EOF . . . */
case|case
literal|'"'
case|:
operator|*
name|buffer
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* Store matching quote */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|mainloop
goto|;
comment|/* And continue main loop */
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Backslash */
goto|goto
name|done
goto|;
comment|/* EOF. . . .*/
block|}
comment|/* else fall through */
default|default:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Other character, store it */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
case|case
literal|':'
case|:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store colons */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
do|do
block|{
comment|/* But remove whitespace after them */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* Skip whitespace */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Backslash quotes next character */
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|top
goto|;
comment|/* Backslash-newline continuation */
block|}
block|}
comment|/* fall through if "other" character */
default|default:
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store other characters */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|*
name|bufsiz
operator|-
literal|1
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
goto|goto
name|mainloop
goto|;
comment|/* Keep going */
name|done
label|:
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate string */
operator|*
name|bufsiz
operator|=
name|length
expr_stmt|;
comment|/* Tell the caller its length */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse out all the various tags and parameters in the host entry pointed  * to by "src".  Stuff all the data into the appropriate fields of the  * host structure pointed to by "host".  If there is any problem with the  * entry, an error message is reported via report(), no further processing  * is done, and -1 is returned.  Successful calls return 0.  *  * (Some errors probably shouldn't be so completely fatal. . . .)  */
end_comment

begin_function
name|PRIVATE
name|int
name|process_entry
parameter_list|(
name|host
parameter_list|,
name|src
parameter_list|)
name|struct
name|host
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|host
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|host
operator|->
name|hostname
operator|=
name|get_shared_string
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Be more liberal for the benefit of dummy tag names. */
block|if (!goodname(host->hostname->string)) { 		report(LOG_ERR, "bad hostname: \"%s\"", host->hostname->string); 		del_string(host->hostname); 		return -1; 	}
endif|#
directive|endif
name|current_hostname
operator|=
name|host
operator|->
name|hostname
operator|->
name|string
expr_stmt|;
name|adjust
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|retval
operator|=
name|eval_symbol
argument_list|(
operator|&
name|src
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|SUCCESS
condition|)
block|{
name|adjust
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|retval
operator|==
name|E_END_OF_ENTRY
condition|)
block|{
comment|/* The default subnet mask is set in readtab() */
return|return
literal|0
return|;
block|}
comment|/* Some kind of error. */
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|E_SYNTAX_ERROR
case|:
name|msg
operator|=
literal|"bad syntax"
expr_stmt|;
break|break;
case|case
name|E_UNKNOWN_SYMBOL
case|:
name|msg
operator|=
literal|"unknown symbol"
expr_stmt|;
break|break;
case|case
name|E_BAD_IPADDR
case|:
name|msg
operator|=
literal|"bad INET address"
expr_stmt|;
break|break;
case|case
name|E_BAD_HWADDR
case|:
name|msg
operator|=
literal|"bad hardware address"
expr_stmt|;
break|break;
case|case
name|E_BAD_LONGWORD
case|:
name|msg
operator|=
literal|"bad longword value"
expr_stmt|;
break|break;
case|case
name|E_BAD_HWATYPE
case|:
name|msg
operator|=
literal|"bad HW address type"
expr_stmt|;
break|break;
case|case
name|E_BAD_PATHNAME
case|:
name|msg
operator|=
literal|"bad pathname (need leading '/')"
expr_stmt|;
case|case
name|E_BAD_VALUE
case|:
name|msg
operator|=
literal|"bad value"
expr_stmt|;
default|default:
name|msg
operator|=
literal|"unkown error"
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"in entry named \"%s\", symbol \"%s\": %s"
argument_list|,
name|current_hostname
argument_list|,
name|current_tagname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Macros for use in the function below:  */
end_comment

begin_comment
comment|/* Parse one INET address stored directly in MEMBER. */
end_comment

begin_define
define|#
directive|define
name|PARSE_IA1
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (optype == OP_BOOLEAN) \ 		return E_SYNTAX_ERROR; \ 	hp->flags.MEMBER = FALSE; \ 	if (optype == OP_ADDITION) { \ 		if (prs_inetaddr(symbol,&value)< 0) \ 			return E_BAD_IPADDR; \ 		hp->MEMBER.s_addr = value; \ 		hp->flags.MEMBER = TRUE; \ 	} \ } while (0)
end_define

begin_comment
comment|/* Parse a list of INET addresses pointed to by MEMBER */
end_comment

begin_define
define|#
directive|define
name|PARSE_IAL
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (optype == OP_BOOLEAN) \ 		return E_SYNTAX_ERROR; \ 	if (hp->flags.MEMBER) { \ 		hp->flags.MEMBER = FALSE; \ 		assert(hp->MEMBER); \ 		del_iplist(hp->MEMBER); \ 		hp->MEMBER = NULL; \ 	} \ 	if (optype == OP_ADDITION) { \ 		hp->MEMBER = get_addresses(symbol); \ 		if (hp->MEMBER == NULL) \ 			return E_SYNTAX_ERROR; \ 		hp->flags.MEMBER = TRUE; \ 	} \ } while (0)
end_define

begin_comment
comment|/* Parse a shared string pointed to by MEMBER */
end_comment

begin_define
define|#
directive|define
name|PARSE_STR
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (optype == OP_BOOLEAN) \ 		return E_SYNTAX_ERROR; \ 	if (hp->flags.MEMBER) { \ 		hp->flags.MEMBER = FALSE; \ 		assert(hp->MEMBER); \ 		del_string(hp->MEMBER); \ 		hp->MEMBER = NULL; \ 	} \ 	if (optype == OP_ADDITION) { \ 		hp->MEMBER = get_shared_string(symbol); \ 		if (hp->MEMBER == NULL) \ 			return E_SYNTAX_ERROR; \ 		hp->flags.MEMBER = TRUE; \ 	} \ } while (0)
end_define

begin_comment
comment|/* Parse an unsigned integer value for MEMBER */
end_comment

begin_define
define|#
directive|define
name|PARSE_UINT
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (optype == OP_BOOLEAN) \ 		return E_SYNTAX_ERROR; \ 	hp->flags.MEMBER = FALSE; \ 	if (optype == OP_ADDITION) { \ 		value = get_u_long(symbol); \ 		hp->MEMBER = value; \ 		hp->flags.MEMBER = TRUE; \ 	} \ } while (0)
end_define

begin_comment
comment|/*  * Evaluate the two-character tag symbol pointed to by "symbol" and place  * the data in the structure pointed to by "hp".  The pointer pointed to  * by "symbol" is updated to point past the source string (but may not  * point to the next tag entry).  *  * Obviously, this need a few more comments. . . .  */
end_comment

begin_function
name|PRIVATE
name|int
name|eval_symbol
parameter_list|(
name|symbol
parameter_list|,
name|hp
parameter_list|)
name|char
modifier|*
modifier|*
name|symbol
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|char
name|tmpstr
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|tmphaddr
decl_stmt|;
name|struct
name|symbolmap
modifier|*
name|symbolptr
decl_stmt|;
name|u_int32
name|value
decl_stmt|;
name|int32
name|timeoff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numsymbols
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|int
name|optype
decl_stmt|;
comment|/* Indicates boolean, addition, or deletion */
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* Make sure this is set before returning. */
name|current_tagname
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|current_tagname
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|symbol
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|current_tagname
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
name|E_END_OF_ENTRY
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
block|{
comment|/* generic symbol */
operator|(
operator|*
name|symbol
operator|)
operator|++
expr_stmt|;
name|value
operator|=
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|current_tagname
argument_list|,
sizeof|sizeof
argument_list|(
name|current_tagname
argument_list|)
argument_list|,
literal|"T%d"
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|!=
literal|'='
condition|)
block|{
return|return
name|E_SYNTAX_ERROR
return|;
block|}
operator|(
operator|*
name|symbol
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|generic
operator|)
condition|)
block|{
name|hp
operator|->
name|generic
operator|=
operator|(
expr|struct
name|shared_bindata
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_bindata
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|process_generic
argument_list|(
name|symbol
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|generic
operator|)
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
argument_list|)
condition|)
return|return
name|E_SYNTAX_ERROR
return|;
name|hp
operator|->
name|flags
operator|.
name|generic
operator|=
name|TRUE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* 	 * Determine the type of operation to be done on this symbol 	 */
switch|switch
condition|(
operator|(
operator|*
name|symbol
operator|)
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'='
case|:
name|optype
operator|=
name|OP_ADDITION
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|optype
operator|=
name|OP_DELETION
expr_stmt|;
break|break;
case|case
literal|':'
case|:
case|case
literal|'\0'
case|:
name|optype
operator|=
name|OP_BOOLEAN
expr_stmt|;
break|break;
default|default:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
name|symbolptr
operator|=
name|symbol_list
expr_stmt|;
name|numsymbols
operator|=
sizeof|sizeof
argument_list|(
name|symbol_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symbolmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsymbols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|symbolptr
operator|->
name|symbol
operator|)
index|[
literal|0
index|]
operator|==
operator|(
operator|*
name|symbol
operator|)
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
name|symbolptr
operator|->
name|symbol
operator|)
index|[
literal|1
index|]
operator|==
operator|(
operator|*
name|symbol
operator|)
index|[
literal|1
index|]
operator|)
condition|)
block|{
break|break;
block|}
name|symbolptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|numsymbols
condition|)
block|{
return|return
name|E_UNKNOWN_SYMBOL
return|;
block|}
comment|/* 	 * Skip past the = or @ character (to point to the data) if this 	 * isn't a boolean operation.  For boolean operations, just skip 	 * over the two-character tag symbol (and nothing else. . . .). 	 */
operator|(
operator|*
name|symbol
operator|)
operator|+=
operator|(
name|optype
operator|==
name|OP_BOOLEAN
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* The cases below are in order by symbolcode value. */
switch|switch
condition|(
name|symbolptr
operator|->
name|symbolcode
condition|)
block|{
case|case
name|SYM_BOOTFILE
case|:
name|PARSE_STR
argument_list|(
name|bootfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_COOKIE_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|cookie_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_DOMAIN_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|domain_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_GATEWAY
case|:
name|PARSE_IAL
argument_list|(
name|gateway
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_HWADDR
case|:
if|if
condition|(
name|optype
operator|==
name|OP_BOOLEAN
condition|)
return|return
name|E_SYNTAX_ERROR
return|;
name|hp
operator|->
name|flags
operator|.
name|haddr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_ADDITION
condition|)
block|{
comment|/* Default the HW type to Ethernet */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|htype
operator|=
name|HTYPE_ETHERNET
expr_stmt|;
block|}
name|tmphaddr
operator|=
name|prs_haddr
argument_list|(
name|symbol
argument_list|,
name|hp
operator|->
name|htype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmphaddr
condition|)
return|return
name|E_BAD_HWADDR
return|;
name|bcopy
argument_list|(
name|tmphaddr
argument_list|,
name|hp
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|haddr
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|SYM_HOMEDIR
case|:
name|PARSE_STR
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_HTYPE
case|:
if|if
condition|(
name|optype
operator|==
name|OP_BOOLEAN
condition|)
return|return
name|E_SYNTAX_ERROR
return|;
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_ADDITION
condition|)
block|{
name|value
operator|=
literal|0L
expr_stmt|;
comment|/* Assume an illegal value */
name|eat_whitespace
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|symbol
argument_list|)
condition|)
block|{
name|value
operator|=
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|symbol
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|numsymbols
operator|=
sizeof|sizeof
argument_list|(
name|htnamemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|htypename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsymbols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|htnamemap
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tmpstr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|numsymbols
condition|)
block|{
name|value
operator|=
name|htnamemap
index|[
name|i
index|]
operator|.
name|htype
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|>=
name|hwinfocnt
condition|)
block|{
return|return
name|E_BAD_HWATYPE
return|;
block|}
name|hp
operator|->
name|htype
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|htype
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|SYM_IMPRESS_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|impress_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_IPADDR
case|:
name|PARSE_IA1
argument_list|(
name|iaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_LOG_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|log_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_LPR_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|lpr_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_NAME_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|name_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_RLP_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|rlp_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_SUBNET_MASK
case|:
name|PARSE_IA1
argument_list|(
name|subnet_mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_TIME_OFFSET
case|:
if|if
condition|(
name|optype
operator|==
name|OP_BOOLEAN
condition|)
return|return
name|E_SYNTAX_ERROR
return|;
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_ADDITION
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|symbol
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|tmpstr
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|hp
operator|->
name|time_offset
operator|=
name|secondswest
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|tmpstr
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|timeoff
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|E_BAD_LONGWORD
return|;
name|hp
operator|->
name|time_offset
operator|=
name|timeoff
expr_stmt|;
block|}
name|hp
operator|->
name|flags
operator|.
name|time_offset
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|SYM_TIME_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|time_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_VENDOR_MAGIC
case|:
if|if
condition|(
name|optype
operator|==
name|OP_BOOLEAN
condition|)
return|return
name|E_SYNTAX_ERROR
return|;
name|hp
operator|->
name|flags
operator|.
name|vm_cookie
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_ADDITION
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* The string is not "auto" */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"rfc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"cmu"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|vm_cmu
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|symbol
argument_list|)
condition|)
return|return
name|E_BAD_IPADDR
return|;
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|symbol
argument_list|,
operator|&
name|value
argument_list|)
operator|<
literal|0
condition|)
return|return
name|E_BAD_IPADDR
return|;
name|bcopy
argument_list|(
operator|&
name|value
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|flags
operator|.
name|vm_cookie
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYM_SIMILAR_ENTRY
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
name|fill_defaults
argument_list|(
name|hp
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|E_SYNTAX_ERROR
return|;
block|}
break|break;
case|case
name|SYM_NAME_SWITCH
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
return|return
name|E_SYNTAX_ERROR
return|;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|FALSE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SYM_BOOTSIZE
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_ADDITION
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|symbol
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|bootsize
operator|=
operator|(
name|unsigned
name|int
operator|)
name|get_u_long
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|OP_DELETION
case|:
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_BOOLEAN
case|:
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SYM_BOOT_SERVER
case|:
name|PARSE_IA1
argument_list|(
name|bootserver
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_TFTPDIR
case|:
name|PARSE_STR
argument_list|(
name|tftpdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|tftpdir
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|hp
operator|->
name|tftpdir
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
condition|)
return|return
name|E_BAD_PATHNAME
return|;
break|break;
case|case
name|SYM_DUMP_FILE
case|:
name|PARSE_STR
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_DOMAIN_NAME
case|:
name|PARSE_STR
argument_list|(
name|domain_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_SWAP_SERVER
case|:
name|PARSE_IA1
argument_list|(
name|swap_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_ROOT_PATH
case|:
name|PARSE_STR
argument_list|(
name|root_path
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_EXTEN_FILE
case|:
name|PARSE_STR
argument_list|(
name|exten_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_REPLY_ADDR
case|:
name|PARSE_IA1
argument_list|(
name|reply_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_NIS_DOMAIN
case|:
name|PARSE_STR
argument_list|(
name|nis_domain
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_NIS_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|nis_server
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_NTP_SERVER
case|:
name|PARSE_IAL
argument_list|(
name|ntp_server
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|YORK_EX_OPTION
case|case
name|SYM_EXEC_FILE
case|:
name|PARSE_STR
argument_list|(
name|exec_file
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SYM_MSG_SIZE
case|:
name|PARSE_UINT
argument_list|(
name|msg_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|msg_size
operator|<
name|BP_MINPKTSZ
operator|||
name|hp
operator|->
name|msg_size
operator|>
name|MAX_MSG_SIZE
condition|)
return|return
name|E_BAD_VALUE
return|;
break|break;
case|case
name|SYM_MIN_WAIT
case|:
name|PARSE_UINT
argument_list|(
name|min_wait
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX - Add new tags here */
default|default:
return|return
name|E_UNKNOWN_SYMBOL
return|;
block|}
comment|/* switch symbolcode */
return|return
name|SUCCESS
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PARSE_IA1
end_undef

begin_undef
undef|#
directive|undef
name|PARSE_IAL
end_undef

begin_undef
undef|#
directive|undef
name|PARSE_STR
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * Read a string from the buffer indirectly pointed to through "src" and  * move it into the buffer pointed to by "dest".  A pointer to the maximum  * allowable length of the string (including null-terminator) is passed as  * "length".  The actual length of the string which was read is returned in  * the unsigned integer pointed to by "length".  This value is the same as  * that which would be returned by applying the strlen() function on the  * destination string (i.e the terminating null is not counted as a  * character).  Trailing whitespace is removed from the string.  For  * convenience, the function returns the new value of "dest".  *  * The string is read until the maximum number of characters, an unquoted  * colon (:), or a null character is read.  The return string in "dest" is  * null-terminated.  */
end_comment

begin_function
name|PRIVATE
name|char
modifier|*
name|get_string
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
modifier|*
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|len
decl_stmt|,
name|quoteflag
decl_stmt|;
name|quoteflag
operator|=
name|FALSE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|*
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|<
name|len
operator|)
operator|&&
operator|(
operator|*
operator|*
name|src
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quoteflag
operator|&&
operator|(
operator|*
operator|*
name|src
operator|==
literal|':'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
name|quoteflag
operator|=
operator|!
name|quoteflag
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|src
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|dest
operator|++
operator|=
operator|*
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* 	 * Remove that troublesome trailing whitespace. . . 	 */
while|while
condition|(
operator|(
name|n
operator|>
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
name|dest
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|dest
operator|--
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|length
operator|=
name|n
expr_stmt|;
return|return
name|dest
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Read the string indirectly pointed to by "src", update the caller's  * pointer, and return a pointer to a malloc'ed shared_string structure  * containing the string.  *  * The string is read using the same rules as get_string() above.  */
end_comment

begin_function
name|PRIVATE
name|struct
name|shared_string
modifier|*
name|get_shared_string
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|char
name|retstring
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|struct
name|shared_string
modifier|*
name|s
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
name|retstring
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
name|retstring
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|shared_string
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_string
argument_list|)
operator|+
name|length
argument_list|)
expr_stmt|;
name|s
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|->
name|string
argument_list|,
name|retstring
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Load RFC1048 generic information directly into a memory buffer.  *  * "src" indirectly points to the ASCII representation of the generic data.  * "dest" points to a string structure which is updated to point to a new  * string with the new data appended to the old string.  The old string is  * freed.  *  * The given tag value is inserted with the new data.  *  * The data may be represented as either a stream of hexadecimal numbers  * representing bytes (any or all bytes may optionally start with '0x' and  * be separated with periods ".") or as a quoted string of ASCII  * characters (the quotes are required).  */
end_comment

begin_function
name|PRIVATE
name|int
name|process_generic
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|tagvalue
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|struct
name|shared_bindata
modifier|*
modifier|*
name|dest
decl_stmt|;
name|u_int
name|tagvalue
decl_stmt|;
block|{
name|byte
name|tmpbuf
index|[
name|MAXBUFLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|str
decl_stmt|;
name|struct
name|shared_bindata
modifier|*
name|bdata
decl_stmt|;
name|u_int
name|newlength
decl_stmt|,
name|oldlength
decl_stmt|;
name|str
operator|=
name|tmpbuf
expr_stmt|;
operator|*
name|str
operator|++
operator|=
operator|(
name|tagvalue
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|/* Store tag value */
name|str
operator|++
expr_stmt|;
comment|/* Skip over length field */
if|if
condition|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
comment|/* ASCII data */
name|newlength
operator|=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/* Set maximum allowed length */
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
operator|&
name|newlength
argument_list|)
expr_stmt|;
name|newlength
operator|++
expr_stmt|;
comment|/* null terminator */
block|}
else|else
block|{
comment|/* Numeric data */
name|newlength
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newlength
operator|<
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|interp_byte
argument_list|(
name|src
argument_list|,
name|str
operator|++
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|newlength
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
return|return
operator|-
literal|1
return|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
operator|(
name|newlength
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|oldlength
operator|=
operator|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|length
operator|)
expr_stmt|;
name|bdata
operator|=
operator|(
expr|struct
name|shared_bindata
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shared_bindata
argument_list|)
operator|+
name|oldlength
operator|+
name|newlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlength
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
operator|*
name|dest
operator|)
operator|->
name|data
argument_list|,
name|bdata
operator|->
name|data
argument_list|,
name|oldlength
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|tmpbuf
argument_list|,
name|bdata
operator|->
name|data
operator|+
name|oldlength
argument_list|,
name|newlength
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bdata
operator|->
name|length
operator|=
name|oldlength
operator|+
name|newlength
operator|+
literal|2
expr_stmt|;
name|bdata
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|dest
condition|)
block|{
name|del_bindata
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest
operator|=
name|bdata
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Verify that the given string makes sense as a hostname (according to  * Appendix 1, page 29 of RFC882).  *  * Return TRUE for good names, FALSE otherwise.  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|goodname
parameter_list|(
name|hostname
parameter_list|)
specifier|register
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|hostname
operator|++
argument_list|)
condition|)
block|{
comment|/* First character must be a letter */
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|hostname
argument_list|)
operator|||
operator|(
operator|*
name|hostname
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|hostname
operator|==
literal|'_'
operator|)
condition|)
block|{
name|hostname
operator|++
expr_stmt|;
comment|/* Alphanumeric or a hyphen */
block|}
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|hostname
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Last must be alphanumeric */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|hostname
operator|==
literal|'\0'
condition|)
block|{
comment|/* Done? */
return|return
name|TRUE
return|;
block|}
block|}
do|while
condition|(
operator|*
name|hostname
operator|++
operator|==
literal|'.'
condition|)
do|;
comment|/* Dot, loop for next label */
return|return
name|FALSE
return|;
comment|/* If it's not a dot, lose */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Null compare function -- always returns FALSE so an element is always  * inserted into a hash table (i.e. there is never a collision with an  * existing element).  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|nullcmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|hash_datum
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Function for comparing a string with the hostname field of a host  * structure.  */
end_comment

begin_function
name|boolean
name|nmcmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|hash_datum
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|d1
decl_stmt|;
comment|/* XXX - OK? */
name|struct
name|host
modifier|*
name|hp
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d2
decl_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compare function to determine whether two hardware addresses are  * equivalent.  Returns TRUE if "host1" and "host2" are equivalent, FALSE  * otherwise.  *  * If the hardware addresses of "host1" and "host2" are identical, but  * they are on different IP subnets, this function returns FALSE.  *  * This function is used when inserting elements into the hardware address  * hash table.  */
end_comment

begin_function
name|PRIVATE
name|boolean
name|hwinscmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|hash_datum
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|host
modifier|*
name|host1
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d1
decl_stmt|;
name|struct
name|host
modifier|*
name|host2
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d2
decl_stmt|;
if|if
condition|(
name|host1
operator|->
name|htype
operator|!=
name|host2
operator|->
name|htype
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|host1
operator|->
name|haddr
argument_list|,
name|host2
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|host1
operator|->
name|htype
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|/* XXX - Is the subnet_mask field set yet? */
if|if
condition|(
operator|(
name|host1
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|==
operator|(
name|host2
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|host1
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
operator|&
operator|(
name|host1
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|)
operator|!=
operator|(
operator|(
name|host2
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
operator|&
operator|(
name|host2
operator|->
name|subnet_mask
operator|.
name|s_addr
operator|)
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Macros for use in the function below:  */
end_comment

begin_define
define|#
directive|define
name|DUP_COPY
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (!hp->flags.MEMBER) { \ 		if ((hp->flags.MEMBER = hp2->flags.MEMBER) != 0) { \ 			hp->MEMBER = hp2->MEMBER; \ 		} \ 	} \ } while (0)
end_define

begin_define
define|#
directive|define
name|DUP_LINK
parameter_list|(
name|MEMBER
parameter_list|)
value|do \ { \ 	if (!hp->flags.MEMBER) { \ 		if ((hp->flags.MEMBER = hp2->flags.MEMBER) != 0) { \ 			assert(hp2->MEMBER); \ 			hp->MEMBER = hp2->MEMBER; \ 			(hp->MEMBER->linkcount)++; \ 		} \ 	} \ } while (0)
end_define

begin_comment
comment|/*  * Process the "similar entry" symbol.  *  * The host specified as the value of the "tc" symbol is used as a template  * for the current host entry.  Symbol values not explicitly set in the  * current host entry are inferred from the template entry.  */
end_comment

begin_function
name|PRIVATE
name|void
name|fill_defaults
parameter_list|(
name|hp
parameter_list|,
name|src
parameter_list|)
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|unsigned
name|int
name|tlen
decl_stmt|,
name|hashcode
decl_stmt|;
name|struct
name|host
modifier|*
name|hp2
decl_stmt|;
name|char
name|tstring
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
name|tstring
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_string
argument_list|(
name|src
argument_list|,
name|tstring
argument_list|,
operator|&
name|tlen
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|tstring
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|hp2
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|nmhashtable
argument_list|,
name|hashcode
argument_list|,
name|nmcmp
argument_list|,
name|tstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find tc=\"%s\""
argument_list|,
name|tstring
argument_list|)
expr_stmt|;
return|return;
block|}
name|DUP_LINK
argument_list|(
name|bootfile
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|cookie_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|domain_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|gateway
argument_list|)
expr_stmt|;
comment|/* haddr not copied */
name|DUP_LINK
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|htype
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|impress_server
argument_list|)
expr_stmt|;
comment|/* iaddr not copied */
name|DUP_LINK
argument_list|(
name|log_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|lpr_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|name_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|rlp_server
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|subnet_mask
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|time_offset
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|time_server
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|vm_cookie
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|flags
operator|.
name|vm_cookie
operator|=
name|hp2
operator|->
name|flags
operator|.
name|vm_cookie
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|hp2
operator|->
name|vm_cookie
argument_list|,
name|hp
operator|->
name|vm_cookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|name_switch
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|=
name|hp2
operator|->
name|flags
operator|.
name|name_switch
operator|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|send_name
operator|=
name|hp2
operator|->
name|flags
operator|.
name|send_name
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|flags
operator|.
name|bootsize
operator|=
name|hp2
operator|->
name|flags
operator|.
name|bootsize
operator|)
condition|)
block|{
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|=
name|hp2
operator|->
name|flags
operator|.
name|bootsize_auto
expr_stmt|;
name|hp
operator|->
name|bootsize
operator|=
name|hp2
operator|->
name|bootsize
expr_stmt|;
block|}
block|}
name|DUP_COPY
argument_list|(
name|bootserver
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|tftpdir
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|domain_name
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|swap_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|root_path
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|exten_file
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|reply_addr
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|nis_domain
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|nis_server
argument_list|)
expr_stmt|;
name|DUP_LINK
argument_list|(
name|ntp_server
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YORK_EX_OPTION
name|DUP_LINK
argument_list|(
name|exec_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DUP_COPY
argument_list|(
name|msg_size
argument_list|)
expr_stmt|;
name|DUP_COPY
argument_list|(
name|min_wait
argument_list|)
expr_stmt|;
comment|/* XXX - Add new tags here */
name|DUP_LINK
argument_list|(
name|generic
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DUP_COPY
end_undef

begin_undef
undef|#
directive|undef
name|DUP_LINK
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * This function adjusts the caller's pointer to point just past the  * first-encountered colon.  If it runs into a null character, it leaves  * the pointer pointing to it.  */
end_comment

begin_function
name|PRIVATE
name|void
name|adjust
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|':'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function adjusts the caller's pointer to point to the first  * non-whitespace character.  If it runs into a null character, it leaves  * the pointer pointing to it.  */
end_comment

begin_function
name|PRIVATE
name|void
name|eat_whitespace
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function converts the given string to all lowercase.  */
end_comment

begin_function
name|PRIVATE
name|void
name|makelower
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  *	N O T E :  *  *	In many of the functions which follow, a parameter such as "src" or  *	"symbol" is passed as a pointer to a pointer to something.  This is  *	done for the purpose of letting the called function update the  *	caller's copy of the parameter (i.e. to effect call-by-reference  *	parameter passing).  The value of the actual parameter is only used  *	to locate the real parameter of interest and then update this indirect  *	parameter.  *  *	I'm sure somebody out there won't like this. . . .  *  (Yea, because it usually makes code slower... -gwr)  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * "src" points to a character pointer which points to an ASCII string of  * whitespace-separated IP addresses.  A pointer to an in_addr_list  * structure containing the list of addresses is returned.  NULL is  * returned if no addresses were found at all.  The pointer pointed to by  * "src" is updated to point to the first non-address (illegal) character.  */
end_comment

begin_function
name|PRIVATE
name|struct
name|in_addr_list
modifier|*
name|get_addresses
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
name|struct
name|in_addr
name|tmpaddrlist
index|[
name|MAXINADDRS
index|]
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|address1
decl_stmt|,
modifier|*
name|address2
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|result
decl_stmt|;
name|unsigned
name|addrcount
decl_stmt|,
name|totalsize
decl_stmt|;
name|address1
operator|=
name|tmpaddrlist
expr_stmt|;
for|for
control|(
name|addrcount
operator|=
literal|0
init|;
name|addrcount
operator|<
name|MAXINADDRS
condition|;
name|addrcount
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|src
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|src
operator|==
literal|','
operator|)
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
operator|*
name|src
condition|)
block|{
comment|/* Quit if nothing more */
break|break;
block|}
if|if
condition|(
name|prs_inetaddr
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|address1
operator|->
name|s_addr
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|address1
operator|++
expr_stmt|;
comment|/* Point to next address slot */
block|}
if|if
condition|(
name|addrcount
operator|<
literal|1
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|totalsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr_list
argument_list|)
operator|+
operator|(
name|addrcount
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|in_addr_list
operator|*
operator|)
name|smalloc
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
name|result
operator|->
name|linkcount
operator|=
literal|1
expr_stmt|;
name|result
operator|->
name|addrcount
operator|=
name|addrcount
expr_stmt|;
name|address1
operator|=
name|tmpaddrlist
expr_stmt|;
name|address2
operator|=
name|result
operator|->
name|addr
expr_stmt|;
for|for
control|(
init|;
name|addrcount
operator|>
literal|0
condition|;
name|addrcount
operator|--
control|)
block|{
name|address2
operator|->
name|s_addr
operator|=
name|address1
operator|->
name|s_addr
expr_stmt|;
name|address1
operator|++
expr_stmt|;
name|address2
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * prs_inetaddr(src, result)  *  * "src" is a value-result parameter; the pointer it points to is updated  * to point to the next data position.   "result" points to an unsigned long  * in which an address is returned.  *  * This function parses the IP address string in ASCII "dot notation" pointed  * to by (*src) and places the result (in network byte order) in the unsigned  * long pointed to by "result".  For malformed addresses, -1 is returned,  * (*src) points to the first illegal character, and the unsigned long pointed  * to by "result" is unchanged.  Successful calls return 0.  */
end_comment

begin_function
name|PRIVATE
name|int
name|prs_inetaddr
parameter_list|(
name|src
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|u_int32
modifier|*
name|result
decl_stmt|;
block|{
name|char
name|tmpstr
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
specifier|register
name|u_int32
name|value
decl_stmt|;
name|u_int32
name|parts
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Leading alpha char causes IP addr lookup. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|*
name|src
argument_list|)
condition|)
block|{
comment|/* Lookup IP address. */
name|s
operator|=
operator|*
name|src
expr_stmt|;
name|t
operator|=
name|tmpstr
expr_stmt|;
while|while
condition|(
operator|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'_'
operator|)
operator|)
operator|&&
operator|(
name|t
operator|<
operator|&
name|tmpstr
index|[
name|MAXSTRINGLEN
operator|-
literal|1
index|]
operator|)
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|src
operator|=
name|s
expr_stmt|;
name|n
operator|=
name|lookup_ipa
argument_list|(
name|tmpstr
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not get IP addr for %s"
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/* 	 * Parse an address in Internet format: 	 *	a.b.c.d 	 *	a.b.c	(with c treated as 16-bits) 	 *	a.b	(with b treated as 24 bits) 	 */
name|pp
operator|=
name|parts
expr_stmt|;
name|loop
label|:
comment|/* If it's not a digit, return error. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|src
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|pp
operator|++
operator|=
name|get_u_long
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|pp
operator|<
operator|(
name|parts
operator|+
literal|4
operator|)
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* This is handled by the caller. */
block|if (**src&& !(isspace(**src) || (**src == ':'))) { 		return (-1); 	}
endif|#
directive|endif
comment|/* 	 * Construct the address according to 	 * the number of parts specified. 	 */
name|n
operator|=
name|pp
operator|-
name|parts
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
comment|/* a -- 32 bits */
name|value
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* a.b -- 8.24 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFFFFFF
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* a.b.c -- 8.8.16 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* a.b.c.d -- 8.8.8.8 bits */
name|value
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|parts
index|[
literal|3
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|result
operator|=
name|htonl
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * "src" points to a pointer which in turn points to a hexadecimal ASCII  * string.  This string is interpreted as a hardware address and returned  * as a pointer to the actual hardware address, represented as an array of  * bytes.  *  * The ASCII string must have the proper number of digits for the specified  * hardware type (e.g. twelve digits for a 48-bit Ethernet address).  * Two-digit sequences (bytes) may be separated with periods (.)  and/or  * prefixed with '0x' for readability, but this is not required.  *  * For bad addresses, the pointer which "src" points to is updated to point  * to the start of the first two-digit sequence which was bad, and the  * function returns a NULL pointer.  */
end_comment

begin_function
name|PRIVATE
name|byte
modifier|*
name|prs_haddr
parameter_list|(
name|src
parameter_list|,
name|htype
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|u_int
name|htype
decl_stmt|;
block|{
specifier|static
name|byte
name|haddr
index|[
name|MAXHADDRLEN
index|]
decl_stmt|;
name|byte
modifier|*
name|hap
decl_stmt|;
name|char
name|tmpstr
index|[
name|MAXSTRINGLEN
index|]
decl_stmt|;
name|u_int
name|tmplen
decl_stmt|;
name|unsigned
name|hal
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|hal
operator|=
name|haddrlength
argument_list|(
name|htype
argument_list|)
expr_stmt|;
comment|/* Get length of this address type */
if|if
condition|(
name|hal
operator|<=
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid addr type for HW addr parse"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tmplen
operator|=
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|get_string
argument_list|(
name|src
argument_list|,
name|tmpstr
argument_list|,
operator|&
name|tmplen
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmpstr
expr_stmt|;
comment|/* If it's a valid host name, try to lookup the HW address. */
if|if
condition|(
name|goodname
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Lookup Hardware Address for hostname. */
if|if
condition|(
operator|(
name|hap
operator|=
name|lookup_hwa
argument_list|(
name|p
argument_list|,
name|htype
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|hap
return|;
comment|/* success */
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Add 0x prefix if hex value starts with A-F"
argument_list|)
expr_stmt|;
comment|/* OK, assume it must be numeric. */
block|}
name|hap
operator|=
name|haddr
expr_stmt|;
while|while
condition|(
name|hap
operator|<
name|haddr
operator|+
name|hal
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|interp_byte
argument_list|(
operator|&
name|p
argument_list|,
name|hap
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
return|return
name|haddr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * "src" is a pointer to a character pointer which in turn points to a  * hexadecimal ASCII representation of a byte.  This byte is read, the  * character pointer is updated, and the result is deposited into the  * byte pointed to by "retbyte".  *  * The usual '0x' notation is allowed but not required.  The number must be  * a two digit hexadecimal number.  If the number is invalid, "src" and  * "retbyte" are left untouched and -1 is returned as the function value.  * Successful calls return 0.  */
end_comment

begin_function
name|PRIVATE
name|int
name|interp_byte
parameter_list|(
name|src
parameter_list|,
name|retbyte
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
name|byte
modifier|*
name|retbyte
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
operator|(
operator|*
name|src
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* allow 0x for hex, but don't require it */
block|}
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|(
operator|*
name|src
operator|)
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
operator|(
operator|*
name|src
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|src
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|(
operator|*
name|src
operator|)
operator|+=
literal|2
expr_stmt|;
operator|*
name|retbyte
operator|=
call|(
name|byte
call|)
argument_list|(
name|v
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The parameter "src" points to a character pointer which points to an  * ASCII string representation of an unsigned number.  The number is  * returned as an unsigned long and the character pointer is updated to  * point to the first illegal character.  */
end_comment

begin_function
name|PRIVATE
name|u_int32
name|get_u_long
parameter_list|(
name|src
parameter_list|)
name|char
modifier|*
modifier|*
name|src
decl_stmt|;
block|{
specifier|register
name|u_int32
name|value
decl_stmt|,
name|base
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Collect number up to first illegal character.  Values are specified 	 * as for C:  0x=hex, 0=octal, other=decimal. 	 */
name|value
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'0'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|src
operator|==
literal|'x'
operator|||
operator|*
operator|*
name|src
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|*
name|src
operator|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|*
name|base
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|c
operator|&
operator|~
literal|32
operator|)
operator|+
literal|10
operator|-
literal|'A'
operator|)
expr_stmt|;
operator|(
operator|*
name|src
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routines for deletion of data associated with the main data structure.  */
end_comment

begin_comment
comment|/*  * Frees the entire host data structure given.  Does nothing if the passed  * pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|free_host
parameter_list|(
name|hmp
parameter_list|)
name|hash_datum
modifier|*
name|hmp
decl_stmt|;
block|{
name|struct
name|host
modifier|*
name|hostptr
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hmp
decl_stmt|;
if|if
condition|(
name|hostptr
operator|==
name|NULL
condition|)
return|return;
name|assert
argument_list|(
name|hostptr
operator|->
name|linkcount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|hostptr
operator|->
name|linkcount
operator|)
condition|)
return|return;
comment|/* Still has references */
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|cookie_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|domain_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|gateway
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|impress_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|log_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|lpr_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|name_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|rlp_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|time_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|nis_server
argument_list|)
expr_stmt|;
name|del_iplist
argument_list|(
name|hostptr
operator|->
name|ntp_server
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - Add new tags here 	 * (if the value is an IP list) 	 */
name|del_string
argument_list|(
name|hostptr
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|homedir
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|bootfile
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|tftpdir
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|root_path
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|domain_name
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|dump_file
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|exten_file
argument_list|)
expr_stmt|;
name|del_string
argument_list|(
name|hostptr
operator|->
name|nis_domain
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YORK_EX_OPTION
name|del_string
argument_list|(
name|hostptr
operator|->
name|exec_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX - Add new tags here 	 * (if it is a shared string) 	 */
name|del_bindata
argument_list|(
name|hostptr
operator|->
name|generic
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Decrements the linkcount on the given IP address data structure.  If the  * linkcount goes to zero, the memory associated with the data is freed.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_iplist
parameter_list|(
name|iplist
parameter_list|)
name|struct
name|in_addr_list
modifier|*
name|iplist
decl_stmt|;
block|{
if|if
condition|(
name|iplist
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|iplist
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iplist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decrements the linkcount on a string data structure.  If the count  * goes to zero, the memory associated with the string is freed.  Does  * nothing if the passed pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_string
parameter_list|(
name|stringptr
parameter_list|)
name|struct
name|shared_string
modifier|*
name|stringptr
decl_stmt|;
block|{
if|if
condition|(
name|stringptr
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|stringptr
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stringptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decrements the linkcount on a shared_bindata data structure.  If the  * count goes to zero, the memory associated with the data is freed.  Does  * nothing if the passed pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|del_bindata
parameter_list|(
name|dataptr
parameter_list|)
name|struct
name|shared_bindata
modifier|*
name|dataptr
decl_stmt|;
block|{
if|if
condition|(
name|dataptr
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
operator|(
name|dataptr
operator|->
name|linkcount
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dataptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* smalloc()  --  safe malloc()  *  * Always returns a valid pointer (if it returns at all).  The allocated  * memory is initialized to all zeros.  If malloc() returns an error, a  * message is printed using the report() function and the program aborts  * with a status of 1.  */
end_comment

begin_function
name|PRIVATE
name|char
modifier|*
name|smalloc
parameter_list|(
name|nbytes
parameter_list|)
name|unsigned
name|nbytes
decl_stmt|;
block|{
name|char
modifier|*
name|retvalue
decl_stmt|;
name|retvalue
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retvalue
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc() failure -- exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|retvalue
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
name|retvalue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Compare function to determine whether two hardware addresses are  * equivalent.  Returns TRUE if "host1" and "host2" are equivalent, FALSE  * otherwise.  *  * This function is used when retrieving elements from the hardware address  * hash table.  */
end_comment

begin_function
name|boolean
name|hwlookcmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|hash_datum
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|host
modifier|*
name|host1
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d1
decl_stmt|;
name|struct
name|host
modifier|*
name|host2
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d2
decl_stmt|;
if|if
condition|(
name|host1
operator|->
name|htype
operator|!=
name|host2
operator|->
name|htype
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|host1
operator|->
name|haddr
argument_list|,
name|host2
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|host1
operator|->
name|htype
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * Compare function for doing IP address hash table lookup.  */
end_comment

begin_function
name|boolean
name|iplookcmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|hash_datum
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|host
modifier|*
name|host1
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d1
decl_stmt|;
name|struct
name|host
modifier|*
name|host2
init|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|d2
decl_stmt|;
return|return
operator|(
name|host1
operator|->
name|iaddr
operator|.
name|s_addr
operator|==
name|host2
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

