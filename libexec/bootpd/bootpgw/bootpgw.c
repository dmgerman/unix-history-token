begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * bootpgw.c - BOOTP GateWay  * This program forwards BOOTP Request packets to a BOOTP server.  */
end_comment

begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ************************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * BOOTPGW is typically used to forward BOOTP client requests from  * one subnet to a BOOTP server on a different subnet.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNISTD
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SETSID
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* for O_RDONLY, etc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"getif.h"
end_include

begin_include
include|#
directive|include
file|"hwaddr.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_comment
comment|/* Local definitions: */
end_comment

begin_define
define|#
directive|define
name|MAX_MSG_SIZE
value|(3*512)
end_define

begin_comment
comment|/* Maximum packet size */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|get_network_errmsg
value|get_errmsg
end_define

begin_escape
end_escape

begin_comment
comment|/*  * Externals, forward declarations, and global variables  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_reply
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_request
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_comment
comment|/*  * IP port numbers for client and server obtained from /etc/services  */
end_comment

begin_decl_stmt
name|u_short
name|bootps_port
decl_stmt|,
name|bootpc_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internet socket and interface config structures  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|bind_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Listening */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|recv_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet source */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|send_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  destination */
end_comment

begin_comment
comment|/*  * option defaults  */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging flag (level) */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|actualtimeout
init|=
block|{
comment|/* fifteen minutes */
literal|15
operator|*
literal|60L
block|,
comment|/* tv_sec */
literal|0
comment|/* tv_usec */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|maxhops
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of hops allowed for requests. */
end_comment

begin_decl_stmt
name|u_int
name|minwait
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of seconds client must wait before 						   its bootrequest packets are forwarded. */
end_comment

begin_comment
comment|/*  * General  */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pktbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receive packet buffer */
end_comment

begin_decl_stmt
name|int
name|pktlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|servername
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int32
name|server_ipa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real server IP address, network order. */
end_comment

begin_decl_stmt
name|struct
name|in_addr
name|my_ip_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utsname
name|my_uname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Initialization such as command-line processing is done and then the  * main server loop is started.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|servent
modifier|*
name|servp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hep
decl_stmt|;
name|char
modifier|*
name|stmp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ba_len
decl_stmt|,
name|ra_len
decl_stmt|;
name|int
name|nfound
decl_stmt|,
name|readfds
decl_stmt|;
name|int
name|standalone
decl_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Initialize logging. 	 */
name|report_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* uses progname */
comment|/* 	 * Log startup 	 */
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"version %s.%d"
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
comment|/* Debugging for compilers with struct padding. */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
operator|==
name|BP_MINPKTSZ
argument_list|)
expr_stmt|;
comment|/* Get space for receiving packets and composing replies. */
name|pktbuf
operator|=
name|malloc
argument_list|(
name|MAX_MSG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pktbuf
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
expr_stmt|;
comment|/* 	 * Check to see if a socket was passed to us from inetd. 	 * 	 * Use getsockname() to determine if descriptor 0 is indeed a socket 	 * (and thus we are probably a child of inetd) or if it is instead 	 * something else and we are running standalone. 	 */
name|s
operator|=
literal|0
expr_stmt|;
name|ba_len
operator|=
sizeof|sizeof
argument_list|(
name|bind_addr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
name|ba_len
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|standalone
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
operator|&
name|ba_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Descriptor 0 is a socket.  Assume we are a child of inetd. 		 */
if|if
condition|(
name|bind_addr
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|standalone
operator|=
name|FALSE
expr_stmt|;
name|bootps_port
operator|=
name|ntohs
argument_list|(
name|bind_addr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Some other type of socket? */
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getsockname: not an INET socket"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set defaults that might be changed by option switches. 	 */
name|stmp
operator|=
name|NULL
expr_stmt|;
name|timeout
operator|=
operator|&
name|actualtimeout
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|my_uname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpgw: can't get hostname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hostname
operator|=
name|my_uname
operator|.
name|nodename
expr_stmt|;
name|hep
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hep
condition|)
block|{
name|printf
argument_list|(
literal|"Can not get my IP address\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|hep
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|my_ip_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|my_ip_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Read switches. 	 */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* debug level */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* 				 * Backwards-compatible behavior: 				 * no parameter, so just increment the debug flag. 				 */
name|debug
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid debug level\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
name|debug
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count limit */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>
literal|16
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpgw: invalid hop count limit\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|maxhops
operator|=
operator|(
name|u_char
operator|)
name|n
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* inetd mode */
name|standalone
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* standalone mode */
name|standalone
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* timeout */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid timeout specification\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
name|actualtimeout
operator|.
name|tv_sec
operator|=
call|(
name|int32
call|)
argument_list|(
literal|60
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* 			 * If the actual timeout is zero, pass a NULL pointer 			 * to select so it blocks indefinitely, otherwise, 			 * point to the actual timeout value. 			 */
name|timeout
operator|=
operator|(
name|n
operator|>
literal|0
operator|)
condition|?
operator|&
name|actualtimeout
else|:
name|NULL
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* wait time */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>
literal|60
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpgw: invalid wait time\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|minwait
operator|=
operator|(
name|u_int
operator|)
name|n
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown switch: -%c\n"
argument_list|,
name|progname
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* for args */
comment|/* Make sure server name argument is suplied. */
name|servername
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|servername
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpgw: missing server name\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Get address of real bootp server. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|servername
index|[
literal|0
index|]
argument_list|)
condition|)
name|server_ipa
operator|=
name|inet_addr
argument_list|(
name|servername
argument_list|)
expr_stmt|;
else|else
block|{
name|hep
operator|=
name|gethostbyname
argument_list|(
name|servername
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpgw: can't get addr for %s\n"
argument_list|,
name|servername
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|hep
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|server_ipa
argument_list|,
sizeof|sizeof
argument_list|(
name|server_ipa
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|standalone
condition|)
block|{
comment|/* 		 * Go into background and disassociate from controlling terminal. 		 * XXX - This is not the POSIX way (Should use setsid). -gwr 		 */
if|if
condition|(
name|debug
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SETSID
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|n
operator|=
name|open
argument_list|(
name|_PATH_TTY
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|n
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCNOTTY */
else|#
directive|else
comment|/* SETSID */
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"setsid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SETSID */
block|}
comment|/* if debug< 3 */
comment|/* 		 * Nuke any timeout value 		 */
name|timeout
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Here, bootpd would do: 		 *	chdir 		 *	tzone_init 		 *	rdtab_init 		 *	readtab 		 */
comment|/* 		 * Create a socket. 		 */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get server's listening port number 		 */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootps"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootps_port
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bootps_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPS
expr_stmt|;
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootps: unknown service -- assuming port %d"
argument_list|,
name|bootps_port
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Bind socket to BOOTPS port. 		 */
name|bind_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bind_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootps_port
argument_list|)
expr_stmt|;
name|bind_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|bind_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if standalone */
comment|/* 	 * Get destination port number so we can reply to client 	 */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootpc"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootpc_port
operator|=
name|ntohs
argument_list|(
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootpc: unknown service -- assuming port %d"
argument_list|,
name|IPPORT_BOOTPC
argument_list|)
expr_stmt|;
name|bootpc_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPC
expr_stmt|;
block|}
comment|/* no signal catchers */
comment|/* 	 * Process incoming requests. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|readfds
operator|=
literal|1
operator|<<
name|s
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
name|tv
operator|=
operator|*
name|timeout
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|timeout
operator|)
condition|?
operator|&
name|tv
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|readfds
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
operator|)
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"exiting after %ld minutes of inactivity"
argument_list|,
name|actualtimeout
operator|.
name|tv_sec
operator|/
literal|60
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ra_len
operator|=
sizeof|sizeof
argument_list|(
name|recv_addr
argument_list|)
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
name|pktbuf
argument_list|,
name|MAX_MSG_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recv_addr
argument_list|,
operator|&
name|ra_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recvd pkt from IP addr %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|recv_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received short packet"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|pktlen
operator|=
name|n
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_op
condition|)
block|{
case|case
name|BOOTREQUEST
case|:
name|handle_request
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOTREPLY
case|:
name|handle_reply
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print "usage" message and exit  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  bootpgw [-d level] [-i] [-s] [-t timeout] server\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -d n\tset debug level\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -h n\tset max hop count\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -i\tforce inetd mode (run as child of inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -s\tforce standalone mode (run without inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -t n\tset inetd exit timeout to n minutes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -w n\tset min wait time (secs)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Process BOOTREQUEST packet.  *  * Note, this just forwards the request to a real server.  */
end_comment

begin_function
specifier|static
name|void
name|handle_request
parameter_list|()
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
decl_stmt|;
name|u_short
name|secs
decl_stmt|;
name|u_char
name|hops
decl_stmt|;
comment|/* XXX - SLIP init: Set bp_ciaddr = recv_addr here? */
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|recv_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Has the client been waiting long enough? */
name|secs
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|bp_secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|secs
operator|<
name|minwait
condition|)
return|return;
comment|/* Has this packet hopped too many times? */
name|hops
operator|=
name|bp
operator|->
name|bp_hops
expr_stmt|;
if|if
condition|(
operator|++
name|hops
operator|>
name|maxhops
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"reqest from %s reached hop limit"
argument_list|,
name|inet_ntoa
argument_list|(
name|recv_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|bp_hops
operator|=
name|hops
expr_stmt|;
comment|/* 	 * Here one might discard a request from the same subnet as the 	 * real server, but we can assume that the real server will send 	 * a reply to the client before it waits for minwait seconds. 	 */
comment|/* If gateway address is not set, put in local interface addr. */
if|if
condition|(
name|bp
operator|->
name|bp_giaddr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* BUG */
block|struct sockaddr_in *sip; 		struct ifreq *ifr;
comment|/* 		 * XXX - This picks the wrong interface when the receive addr 		 * is the broadcast address.  There is no  portable way to 		 * find out which interface a broadcast was received on. -gwr 		 * (Thanks to<walker@zk3.dec.com> for finding this bug!) 		 */
block|ifr = getif(s,&recv_addr.sin_addr); 		if (!ifr) { 			report(LOG_NOTICE, "no interface for request from %s", 				   inet_ntoa(recv_addr.sin_addr)); 			return; 		} 		sip = (struct sockaddr_in *)&(ifr->ifr_addr); 		bp->bp_giaddr = sip->sin_addr;
else|#
directive|else
comment|/* BUG */
comment|/* 		 * XXX - Just set "giaddr" to our "official" IP address. 		 * RFC 1532 says giaddr MUST be set to the address of the 		 * interface on which the request was received.  Setting 		 * it to our "default" IP address is not strictly correct, 		 * but is good enough to allow the real BOOTP server to 		 * get the reply back here.  Then, before we forward the 		 * reply to the client, the giaddr field is corrected. 		 * (In case the client uses giaddr, which it should not.) 		 * See handle_reply() 		 */
name|bp
operator|->
name|bp_giaddr
operator|=
name|my_ip_addr
expr_stmt|;
endif|#
directive|endif
comment|/* BUG */
comment|/* 		 * XXX - DHCP says to insert a subnet mask option into the 		 * options area of the request (if vendor magic == std). 		 */
block|}
comment|/* Set up socket address for send. */
name|send_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|send_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootps_port
argument_list|)
expr_stmt|;
name|send_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|server_ipa
expr_stmt|;
comment|/* Send reply with same size packet as request used. */
if|if
condition|(
name|sendto
argument_list|(
name|s
argument_list|,
name|pktbuf
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|send_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|send_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Process BOOTREPLY packet.  */
end_comment

begin_function
specifier|static
name|void
name|handle_reply
parameter_list|()
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sip
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ha
decl_stmt|;
name|int
name|len
decl_stmt|,
name|haf
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"   reply for %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_yiaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure client is directly accessible. */
name|ifr
operator|=
name|getif
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|bp
operator|->
name|bp_yiaddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifr
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no interface for reply to %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_yiaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|1
comment|/* Experimental (see BUG above) */
comment|/* #ifdef CATER_TO_OLD_CLIENTS ? */
comment|/* 	 * The giaddr field has been set to our "default" IP address 	 * which might not be on the same interface as the client. 	 * In case the client looks at giaddr, (which it should not) 	 * giaddr is now set to the address of the correct interface. 	 */
name|sip
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|->
name|ifr_addr
operator|)
expr_stmt|;
name|bp
operator|->
name|bp_giaddr
operator|=
name|sip
operator|->
name|sin_addr
expr_stmt|;
endif|#
directive|endif
comment|/* Set up socket address for send to client. */
name|send_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|send_addr
operator|.
name|sin_addr
operator|=
name|bp
operator|->
name|bp_yiaddr
expr_stmt|;
name|send_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootpc_port
argument_list|)
expr_stmt|;
comment|/* Create an ARP cache entry for the client. */
name|ha
operator|=
name|bp
operator|->
name|bp_chaddr
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|bp_hlen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXHADDRLEN
condition|)
name|len
operator|=
name|MAXHADDRLEN
expr_stmt|;
name|haf
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|bp_htype
expr_stmt|;
if|if
condition|(
name|haf
operator|==
literal|0
condition|)
name|haf
operator|=
name|HTYPE_ETHERNET
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"setarp %s - %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_yiaddr
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|ha
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|setarp
argument_list|(
name|s
argument_list|,
operator|&
name|bp
operator|->
name|bp_yiaddr
argument_list|,
name|haf
argument_list|,
name|ha
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Send reply with same size packet as request used. */
if|if
condition|(
name|sendto
argument_list|(
name|s
argument_list|,
name|pktbuf
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|send_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|send_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

