begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  	$Id: bootpef.c,v 1.5 1999/04/25 22:23:33 imp Exp $  ************************************************************************/
end_comment

begin_comment
comment|/*  * bootpef - BOOTP Extension File generator  *	Makes an "Extension File" for each host entry that  *	defines an and Extension File. (See RFC1497, tag 18.)  *  * HISTORY  *	See ./Changes  *  * BUGS  *	See ./ToDo  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNISTD
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"hwaddr.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_include
include|#
directive|include
file|"dovend.h"
end_include

begin_include
include|#
directive|include
file|"readfile.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_include
include|#
directive|include
file|"tzone.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_define
define|#
directive|define
name|BUFFERSIZE
value|0x4000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/bootptab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Externals, forward declarations, and global variables  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|mktagfile
name|P
argument_list|(
operator|(
expr|struct
name|host
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_comment
comment|/*  * General  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chdir_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging flag (level) */
end_comment

begin_decl_stmt
name|byte
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Globals below are associated with the bootp database file (bootptab).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootptab
init|=
name|CONFIG_FILE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Print "usage" message and exit  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  $s [ -c chdir ] [-d level] [-f configfile] [host...]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -c n\tset current directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -d n\tset debug level\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -f n\tconfig file name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization such as command-line processing is done and then the  * main server loop is started.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|stmp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Get work space for making tag 18 files. */
name|buffer
operator|=
operator|(
name|byte
operator|*
operator|)
name|malloc
argument_list|(
name|BUFFERSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set defaults that might be changed by option switches. 	 */
name|stmp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Read switches. 	 */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* chdir_path */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|stmp
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: invalid chdir specification\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|chdir_path
operator|=
name|stmp
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debug */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* 				 * Backwards-compatible behavior: 				 * no parameter, so just increment the debug flag. 				 */
name|debug
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: invalid debug level\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|debug
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* config file */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
name|bootptab
operator|=
name|stmp
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: unknown switch: -%c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get the timezone. */
name|tzone_init
argument_list|()
expr_stmt|;
comment|/* Allocate hash tables. */
name|rdtab_init
argument_list|()
expr_stmt|;
comment|/* 	 * Read the bootptab file. 	 */
name|readtab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force read */
comment|/* Set the cwd (i.e. to /tftpboot) */
if|if
condition|(
name|chdir_path
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|chdir_path
argument_list|)
operator|<
literal|0
condition|)
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: chdir failed"
argument_list|,
name|chdir_path
argument_list|)
expr_stmt|;
block|}
comment|/* If there are host names on the command line, do only those. */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|tlen
decl_stmt|,
name|hashcode
decl_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
name|tlen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|argv
index|[
literal|0
index|]
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|nmhashtable
argument_list|,
name|hashcode
argument_list|,
name|nmcmp
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no matching entry\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|exten_file
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no extension file\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mktagfile
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* No host names specified.  Do them all. */
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_FirstEntry
argument_list|(
name|nmhashtable
argument_list|)
expr_stmt|;
while|while
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|mktagfile
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_NextEntry
argument_list|(
name|nmhashtable
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Make a "TAG 18" file for this host.  * (Insert the RFC1497 options.)  */
end_comment

begin_function
specifier|static
name|void
name|mktagfile
parameter_list|(
name|hp
parameter_list|)
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|bytesleft
decl_stmt|,
name|len
decl_stmt|;
name|byte
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|exten_file
condition|)
return|return;
name|vp
operator|=
name|buffer
expr_stmt|;
name|bytesleft
operator|=
name|BUFFERSIZE
expr_stmt|;
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|vp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Copy in the magic cookie */
name|vp
operator|+=
literal|4
expr_stmt|;
name|bytesleft
operator|-=
literal|4
expr_stmt|;
comment|/* 	 * The "extension file" options are appended by the following 	 * function (which is shared with bootpd.c). 	 */
name|len
operator|=
name|dovend_rfc1497
argument_list|(
name|hp
argument_list|,
name|vp
argument_list|,
name|bytesleft
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|bytesleft
operator|<
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: too much option data"
argument_list|,
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|vp
operator|++
operator|=
name|TAG_END
expr_stmt|;
name|bytesleft
operator|--
expr_stmt|;
comment|/* Write the buffer to the extension file. */
name|printf
argument_list|(
literal|"Updating \"%s\"\n"
argument_list|,
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error opening \"%s\": %s"
argument_list|,
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|vp
operator|-
name|buffer
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write failed on \"%s\" : %s"
argument_list|,
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mktagfile */
end_comment

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

