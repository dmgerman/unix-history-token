begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  	$FreeBSD$  ************************************************************************/
end_comment

begin_comment
comment|/*  * BOOTP (bootstrap protocol) server daemon.  *  * Answers BOOTP request packets from booting client machines.  * See [SRI-NIC]<RFC>RFC951.TXT for a description of the protocol.  * See [SRI-NIC]<RFC>RFC1048.TXT for vendor-information extensions.  * See RFC 1395 for option tags 14-17.  * See accompanying man page -- bootpd.8  *  * HISTORY  *	See ./Changes  *  * BUGS  *	See ./ToDo  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNISTD
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SETSID
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* for O_RDONLY, etc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"hwaddr.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_include
include|#
directive|include
file|"dovend.h"
end_include

begin_include
include|#
directive|include
file|"getif.h"
end_include

begin_include
include|#
directive|include
file|"readfile.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_include
include|#
directive|include
file|"tzone.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/bootptab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DUMPTAB_FILE
end_ifndef

begin_define
define|#
directive|define
name|DUMPTAB_FILE
value|"/tmp/bootpd.dump"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Externals, forward declarations, and global variables  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|dumptab
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|catcher
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|chk_access
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int32
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VEND_CMU
end_ifdef

begin_decl_stmt
name|PRIVATE
name|void
name|dovend_cmu
name|P
argument_list|(
operator|(
expr|struct
name|bootp
operator|*
operator|,
expr|struct
name|host
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|PRIVATE
name|void
name|dovend_rfc1048
name|P
argument_list|(
operator|(
expr|struct
name|bootp
operator|*
operator|,
expr|struct
name|host
operator|*
operator|,
name|int32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|handle_reply
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|handle_request
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|sendreply
name|P
argument_list|(
operator|(
name|int
name|forward
operator|,
name|int32
name|dest_override
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_comment
comment|/*  * IP port numbers for client and server obtained from /etc/services  */
end_comment

begin_decl_stmt
name|u_short
name|bootps_port
decl_stmt|,
name|bootpc_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internet socket and interface config structures  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|bind_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Listening */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|recv_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet source */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|send_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  destination */
end_comment

begin_comment
comment|/*  * option defaults  */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging flag (level) */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|actualtimeout
init|=
block|{
comment|/* fifteen minutes */
literal|15
operator|*
literal|60L
block|,
comment|/* tv_sec */
literal|0
comment|/* tv_usec */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * General  */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pktbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receive packet buffer */
end_comment

begin_decl_stmt
name|int
name|pktlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chdir_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|my_ip_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utsname
name|my_uname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags set by signal catcher. */
end_comment

begin_decl_stmt
name|PRIVATE
name|int
name|do_readtab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PRIVATE
name|int
name|do_dumptab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Globals below are associated with the bootp database file (bootptab).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootptab
init|=
name|CONFIG_FILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bootpd_dump
init|=
name|DUMPTAB_FILE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Initialization such as command-line processing is done and then the  * main server loop is started.  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|servent
modifier|*
name|servp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hep
decl_stmt|;
name|char
modifier|*
name|stmp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ba_len
decl_stmt|,
name|ra_len
decl_stmt|;
name|int
name|nfound
decl_stmt|,
name|readfds
decl_stmt|;
name|int
name|standalone
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
comment|/* Have POSIX sigaction(2). */
name|struct
name|sigaction
name|sa
decl_stmt|;
endif|#
directive|endif
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Initialize logging. 	 */
name|report_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* uses progname */
comment|/* 	 * Log startup 	 */
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"version %s.%d"
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
comment|/* Debugging for compilers with struct padding. */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
operator|==
name|BP_MINPKTSZ
argument_list|)
expr_stmt|;
comment|/* Get space for receiving packets and composing replies. */
name|pktbuf
operator|=
name|malloc
argument_list|(
name|MAX_MSG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pktbuf
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
expr_stmt|;
comment|/* 	 * Check to see if a socket was passed to us from inetd. 	 * 	 * Use getsockname() to determine if descriptor 0 is indeed a socket 	 * (and thus we are probably a child of inetd) or if it is instead 	 * something else and we are running standalone. 	 */
name|s
operator|=
literal|0
expr_stmt|;
name|ba_len
operator|=
sizeof|sizeof
argument_list|(
name|bind_addr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
name|ba_len
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|standalone
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
operator|&
name|ba_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Descriptor 0 is a socket.  Assume we are a child of inetd. 		 */
if|if
condition|(
name|bind_addr
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|standalone
operator|=
name|FALSE
expr_stmt|;
name|bootps_port
operator|=
name|ntohs
argument_list|(
name|bind_addr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Some other type of socket? */
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsockname: not an INET socket"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set defaults that might be changed by option switches. 	 */
name|stmp
operator|=
name|NULL
expr_stmt|;
name|timeout
operator|=
operator|&
name|actualtimeout
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|my_uname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: can't get hostname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hostname
operator|=
name|my_uname
operator|.
name|nodename
expr_stmt|;
comment|/* 	 * Read switches. 	 */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* chdir_path */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|stmp
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: invalid chdir specification\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|chdir_path
operator|=
name|stmp
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debug level */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* 				 * Backwards-compatible behavior: 				 * no parameter, so just increment the debug flag. 				 */
name|debug
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid debug level\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
name|debug
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* override hostname */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: missing hostname\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|hostname
operator|=
name|stmp
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* inetd mode */
name|standalone
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* standalone mode */
name|standalone
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* timeout */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid timeout specification\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
name|actualtimeout
operator|.
name|tv_sec
operator|=
call|(
name|int32
call|)
argument_list|(
literal|60
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* 			 * If the actual timeout is zero, pass a NULL pointer 			 * to select so it blocks indefinitely, otherwise, 			 * point to the actual timeout value. 			 */
name|timeout
operator|=
operator|(
name|n
operator|>
literal|0
operator|)
condition|?
operator|&
name|actualtimeout
else|:
name|NULL
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown switch: -%c\n"
argument_list|,
name|progname
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* for args */
comment|/* 	 * Override default file names if specified on the command line. 	 */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|bootptab
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|bootpd_dump
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Get my hostname and IP address. 	 */
name|hep
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can not get my IP address\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|hep
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|my_ip_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|my_ip_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|standalone
condition|)
block|{
comment|/* 		 * Go into background and disassociate from controlling terminal. 		 */
if|if
condition|(
name|debug
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SETSID
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|n
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|n
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCNOTTY */
else|#
directive|else
comment|/* SETSID */
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"setsid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SETSID */
block|}
comment|/* if debug< 3 */
comment|/* 		 * Nuke any timeout value 		 */
name|timeout
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* if standalone (1st) */
comment|/* Set the cwd (i.e. to /tftpboot) */
if|if
condition|(
name|chdir_path
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|chdir_path
argument_list|)
operator|<
literal|0
condition|)
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: chdir failed"
argument_list|,
name|chdir_path
argument_list|)
expr_stmt|;
block|}
comment|/* Get the timezone. */
name|tzone_init
argument_list|()
expr_stmt|;
comment|/* Allocate hash tables. */
name|rdtab_init
argument_list|()
expr_stmt|;
comment|/* 	 * Read the bootptab file. 	 */
name|readtab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force read */
if|if
condition|(
name|standalone
condition|)
block|{
comment|/* 		 * Create a socket. 		 */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get server's listening port number 		 */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootps"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootps_port
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bootps_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPS
expr_stmt|;
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootps: unknown service -- assuming port %d"
argument_list|,
name|bootps_port
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Bind socket to BOOTPS port. 		 */
name|bind_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bind_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|bind_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootps_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bind_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|bind_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if standalone (2nd)*/
comment|/* 	 * Get destination port number so we can reply to client 	 */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootpc"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootpc_port
operator|=
name|ntohs
argument_list|(
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootpc: unknown service -- assuming port %d"
argument_list|,
name|IPPORT_BOOTPC
argument_list|)
expr_stmt|;
name|bootpc_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPC
expr_stmt|;
block|}
comment|/* 	 * Set up signals to read or dump the table. 	 */
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
comment|/* Have POSIX sigaction(2). */
name|sa
operator|.
name|sa_handler
operator|=
name|catcher
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SA_NOCLDSTOP */
comment|/* Old-fashioned UNIX signals */
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catcher
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"signal: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|catcher
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"signal: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SA_NOCLDSTOP */
comment|/* 	 * Process incoming requests. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|readfds
operator|=
literal|1
operator|<<
name|s
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
name|tv
operator|=
operator|*
name|timeout
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|timeout
operator|)
condition|?
operator|&
name|tv
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Call readtab() or dumptab() here to avoid the 			 * dangers of doing I/O from a signal handler. 			 */
if|if
condition|(
name|do_readtab
condition|)
block|{
name|do_readtab
operator|=
literal|0
expr_stmt|;
name|readtab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force read */
block|}
if|if
condition|(
name|do_dumptab
condition|)
block|{
name|do_dumptab
operator|=
literal|0
expr_stmt|;
name|dumptab
argument_list|(
name|bootpd_dump
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|readfds
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"exiting after %ld minutes of inactivity"
argument_list|,
name|actualtimeout
operator|.
name|tv_sec
operator|/
literal|60
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ra_len
operator|=
sizeof|sizeof
argument_list|(
name|recv_addr
argument_list|)
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
name|pktbuf
argument_list|,
name|MAX_MSG_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recv_addr
argument_list|,
operator|&
name|ra_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recvd pkt from IP addr %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|recv_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"received short packet"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|pktlen
operator|=
name|n
expr_stmt|;
name|readtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* maybe re-read bootptab */
switch|switch
condition|(
name|bp
operator|->
name|bp_op
condition|)
block|{
case|case
name|BOOTREQUEST
case|:
name|handle_request
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOTREPLY
case|:
name|handle_reply
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print "usage" message and exit  */
end_comment

begin_function
name|PRIVATE
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  bootpd [-d level] [-i] [-s] [-t timeout] [configfile [dumpfile]]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -c n\tset current directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -d n\tset debug level\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -i\tforce inetd mode (run as child of inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -s\tforce standalone mode (run without inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -t n\tset inetd exit timeout to n minutes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Signal catchers */
end_comment

begin_function
name|PRIVATE
name|void
name|catcher
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|sig
operator|==
name|SIGHUP
condition|)
name|do_readtab
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGUSR1
condition|)
name|do_dumptab
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SA_NOCLDSTOP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
comment|/* For older "System V" derivatives with no sigaction(). */
name|signal
argument_list|(
name|sig
argument_list|,
name|catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Process BOOTREQUEST packet.  *  * Note:  This version of the bootpd.c server never forwards  * a request to another server.  That is the job of a gateway  * program such as the "bootpgw" program included here.  *  * (Also this version does not interpret the hostname field of  * the request packet;  it COULD do a name->address lookup and  * forward the request there.)  */
end_comment

begin_function
name|PRIVATE
name|void
name|handle_request
parameter_list|()
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|struct
name|host
name|dummyhost
decl_stmt|;
name|int32
name|bootsize
init|=
literal|0
decl_stmt|;
name|unsigned
name|hlen
decl_stmt|,
name|hashcode
decl_stmt|;
name|int32
name|dest
decl_stmt|;
name|char
name|realpath
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|clntpath
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|bootfile
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* XXX - SLIP init: Set bp_ciaddr = recv_addr here? */
comment|/* 	 * If the servername field is set, compare it against us. 	 * If we're not being addressed, ignore this request. 	 * If the server name field is null, throw in our name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|bp
operator|->
name|bp_sname
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bp_sname
argument_list|,
name|hostname
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"\ ignoring request for server %s from client at %s address %s"
argument_list|,
name|bp
operator|->
name|bp_sname
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_hlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - Is it correct to ignore such a request? -gwr */
return|return;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|bp
operator|->
name|bp_sname
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the request into a reply. */
name|bp
operator|->
name|bp_op
operator|=
name|BOOTREPLY
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 		 * client doesnt know his IP address, 		 * search by hardware address. 		 */
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request from %s address %s"
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_hlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hlen
operator|=
name|haddrlength
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|!=
name|bp
operator|->
name|bp_hlen
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"bad addr len from from %s address %s"
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|hlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dummyhost
operator|.
name|htype
operator|=
name|bp
operator|->
name|bp_htype
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|dummyhost
operator|.
name|haddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|hwhashtable
argument_list|,
name|hashcode
argument_list|,
name|hwlookcmp
argument_list|,
operator|&
name|dummyhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|&&
name|bp
operator|->
name|bp_htype
operator|==
name|HTYPE_IEEE802
condition|)
block|{
comment|/* Try again with address in "canonical" form. */
name|haddr_conv802
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|dummyhost
operator|.
name|haddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"\ HW addr type is IEEE 802.  convert to %s and check again\n"
argument_list|,
name|haddrtoa
argument_list|(
name|dummyhost
operator|.
name|haddr
argument_list|,
name|bp
operator|->
name|bp_hlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|dummyhost
operator|.
name|haddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|hwhashtable
argument_list|,
name|hashcode
argument_list|,
name|hwlookcmp
argument_list|,
operator|&
name|dummyhost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * XXX - Add dynamic IP address assignment? 			 */
if|if
condition|(
name|debug
condition|)
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unknown client %s address %s"
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_hlen
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* not found */
block|}
operator|(
name|bp
operator|->
name|bp_yiaddr
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * search by IP address. 		 */
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request from IP addr %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_ciaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dummyhost
operator|.
name|iaddr
operator|.
name|s_addr
operator|=
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|iphashtable
argument_list|,
name|hashcode
argument_list|,
name|iplookcmp
argument_list|,
operator|&
name|dummyhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"IP address not found: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_ciaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"found %s (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|iaddr
argument_list|)
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there is a response delay threshold, ignore requests 	 * with a timestamp lower than the threshold. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|min_wait
condition|)
block|{
name|u_int32
name|t
init|=
operator|(
name|u_int32
operator|)
name|ntohs
argument_list|(
name|bp
operator|->
name|bp_secs
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|<
name|hp
operator|->
name|min_wait
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ignoring request due to timestamp (%d< %d)"
argument_list|,
name|t
argument_list|,
name|hp
operator|->
name|min_wait
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|YORK_EX_OPTION
comment|/* 	 * The need for the "ex" tag arose out of the need to empty 	 * shared networked drives on diskless PCs.  This solution is 	 * not very clean but it does work fairly well. 	 * Written by Edmund J. Sutcliffe<edmund@york.ac.uk> 	 * 	 * XXX - This could compromise security if a non-trusted user 	 * managed to write an entry in the bootptab with :ex=trojan: 	 * so I would leave this turned off unless you need it. -gwr 	 */
comment|/* Run a program, passing the client name as a parameter. */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|exec_file
condition|)
block|{
name|char
name|tst
index|[
literal|100
index|]
decl_stmt|;
comment|/* XXX - Check string lengths? -gwr */
name|strcpy
argument_list|(
name|tst
argument_list|,
name|hp
operator|->
name|exec_file
operator|->
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tst
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tst
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tst
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"executing %s"
argument_list|,
name|tst
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tst
argument_list|)
expr_stmt|;
comment|/* Hope this finishes soon... */
block|}
endif|#
directive|endif
comment|/* YORK_EX_OPTION */
comment|/* 	 * If a specific TFTP server address was specified in the bootptab file, 	 * fill it in, otherwise zero it. 	 * XXX - Rather than zero it, should it be the bootpd address? -gwr 	 */
operator|(
name|bp
operator|->
name|bp_siaddr
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|hp
operator|->
name|flags
operator|.
name|bootserver
operator|)
condition|?
name|hp
operator|->
name|bootserver
operator|.
name|s_addr
else|:
literal|0L
expr_stmt|;
ifdef|#
directive|ifdef
name|STANFORD_PROM_COMPAT
comment|/* 	 * Stanford bootp PROMs (for a Sun?) have no way to leave 	 * the boot file name field blank (because the boot file 	 * name is automatically generated from some index). 	 * As a work-around, this little hack allows those PROMs to 	 * specify "sunboot14" with the same effect as a NULL name. 	 * (The user specifies boot device 14 or some such magic.) 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
literal|"sunboot14"
argument_list|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* treat it as unspecified */
endif|#
directive|endif
comment|/* 	 * Fill in the client's proper bootfile. 	 * 	 * If the client specifies an absolute path, try that file with a 	 * ".host" suffix and then without.  If the file cannot be found, no 	 * reply is made at all. 	 * 	 * If the client specifies a null or relative file, use the following 	 * table to determine the appropriate action: 	 * 	 *  Homedir      Bootfile    Client's file 	 * specified?   specified?   specification   Action 	 * ------------------------------------------------------------------- 	 *      No          No          Null         Send null filename 	 *      No          No          Relative     Discard request 	 *      No          Yes         Null         Send if absolute else null 	 *      No          Yes         Relative     Discard request     *XXX 	 *      Yes         No          Null         Send null filename 	 *      Yes         No          Relative     Lookup with ".host" 	 *      Yes         Yes         Null         Send home/boot or bootfile 	 *      Yes         Yes         Relative     Lookup with ".host" *XXX 	 * 	 */
comment|/* 	 * XXX - I don't like the policy of ignoring a client when the 	 * boot file is not accessible.  The TFTP server might not be 	 * running on the same machine as the BOOTP server, in which 	 * case checking accessibility of the boot file is pointless. 	 * 	 * Therefore, file accessibility is now demanded ONLY if you 	 * define CHECK_FILE_ACCESS in the Makefile options. -gwr 	 */
comment|/* 	 * The "real" path is as seen by the BOOTP daemon on this 	 * machine, while the client path is relative to the TFTP 	 * daemon chroot directory (i.e. /tftpboot). 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|tftpdir
condition|)
block|{
name|strcpy
argument_list|(
name|realpath
argument_list|,
name|hp
operator|->
name|tftpdir
operator|->
name|string
argument_list|)
expr_stmt|;
name|clntpath
operator|=
operator|&
name|realpath
index|[
name|strlen
argument_list|(
name|realpath
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|realpath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|clntpath
operator|=
name|realpath
expr_stmt|;
block|}
comment|/* 	 * Determine client's requested homedir and bootfile. 	 */
name|homedir
operator|=
name|NULL
expr_stmt|;
name|bootfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
condition|)
block|{
name|homedir
operator|=
name|bp
operator|->
name|bp_file
expr_stmt|;
name|bootfile
operator|=
name|strrchr
argument_list|(
name|homedir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootfile
condition|)
block|{
if|if
condition|(
name|homedir
operator|==
name|bootfile
condition|)
name|homedir
operator|=
name|NULL
expr_stmt|;
operator|*
name|bootfile
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* no "/" in the string */
name|bootfile
operator|=
name|homedir
expr_stmt|;
name|homedir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"requested path=\"%s\"  file=\"%s\""
argument_list|,
operator|(
name|homedir
operator|)
condition|?
name|homedir
else|:
literal|""
argument_list|,
operator|(
name|bootfile
operator|)
condition|?
name|bootfile
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Specifications in bootptab override client requested values. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|homedir
condition|)
name|homedir
operator|=
name|hp
operator|->
name|homedir
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootfile
condition|)
name|bootfile
operator|=
name|hp
operator|->
name|bootfile
operator|->
name|string
expr_stmt|;
comment|/* 	 * Construct bootfile path. 	 */
if|if
condition|(
name|homedir
condition|)
block|{
if|if
condition|(
name|homedir
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|clntpath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|clntpath
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|homedir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bootfile
condition|)
block|{
if|if
condition|(
name|bootfile
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|clntpath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|clntpath
argument_list|,
name|bootfile
argument_list|)
expr_stmt|;
name|bootfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * First try to find the file with a ".host" suffix 	 */
name|n
operator|=
name|strlen
argument_list|(
name|clntpath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|clntpath
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|clntpath
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_access
argument_list|(
name|realpath
argument_list|,
operator|&
name|bootsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|clntpath
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Try it without the suffix */
if|if
condition|(
name|chk_access
argument_list|(
name|realpath
argument_list|,
operator|&
name|bootsize
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* neither "file.host" nor "file" was found */
ifdef|#
directive|ifdef
name|CHECK_FILE_ACCESS
if|if
condition|(
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
condition|)
block|{
comment|/* 				 * Client wanted specific file 				 * and we didn't have it. 				 */
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"requested file not found: \"%s\""
argument_list|,
name|clntpath
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Client didn't ask for a specific file and we couldn't 			 * access the default file, so just zero-out the bootfile 			 * field in the packet and continue processing the reply. 			 */
name|bzero
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|null_file_name
goto|;
else|#
directive|else
comment|/* CHECK_FILE_ACCESS */
comment|/* Complain only if boot file size was needed. */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not determine size of file \"%s\""
argument_list|,
name|clntpath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CHECK_FILE_ACCESS */
block|}
block|}
name|strncpy
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
name|clntpath
argument_list|,
name|BP_FILE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bootfile=\"%s\""
argument_list|,
name|clntpath
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_FILE_ACCESS
name|null_file_name
label|:
endif|#
directive|endif
comment|/* CHECK_FILE_ACCESS */
comment|/* 	 * Handle vendor options based on magic number. 	 */
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vendor magic field is %d.%d.%d.%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|2
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this host isn't set for automatic vendor info then copy the 	 * specific cookie into the bootp packet, thus forcing a certain 	 * reply format.  Only force reply format if user specified it. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|vm_cookie
condition|)
block|{
comment|/* Slam in the user specified magic number. */
name|bcopy
argument_list|(
name|hp
operator|->
name|vm_cookie
argument_list|,
name|bp
operator|->
name|bp_vend
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out the format for the vendor-specific info. 	 * Note that bp->bp_vend may have been set above. 	 */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
name|vm_rfc1048
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* RFC1048 conformant bootp client */
name|dovend_rfc1048
argument_list|(
name|bp
argument_list|,
name|hp
argument_list|,
name|bootsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending reply (with RFC1048 options)"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|VEND_CMU
elseif|else
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
name|vm_cmu
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|dovend_cmu
argument_list|(
name|bp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending reply (with CMU options)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending reply (with no options)"
argument_list|)
expr_stmt|;
block|}
block|}
name|dest
operator|=
operator|(
name|hp
operator|->
name|flags
operator|.
name|reply_addr
operator|)
condition|?
name|hp
operator|->
name|reply_addr
operator|.
name|s_addr
else|:
literal|0L
expr_stmt|;
comment|/* not forwarded */
name|sendreply
argument_list|(
literal|0
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process BOOTREPLY packet.  */
end_comment

begin_function
name|PRIVATE
name|void
name|handle_reply
parameter_list|()
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"processing boot reply"
argument_list|)
expr_stmt|;
block|}
comment|/* forwarded, no destination override */
name|sendreply
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a reply packet to the client.  'forward' flag is set if we are  * not the originator of this reply packet.  */
end_comment

begin_function
name|PRIVATE
name|void
name|sendreply
parameter_list|(
name|forward
parameter_list|,
name|dst_override
parameter_list|)
name|int
name|forward
decl_stmt|;
name|int32
name|dst_override
decl_stmt|;
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|pktbuf
decl_stmt|;
name|struct
name|in_addr
name|dst
decl_stmt|;
name|u_short
name|port
init|=
name|bootpc_port
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ha
decl_stmt|;
name|int
name|len
decl_stmt|,
name|haf
decl_stmt|;
comment|/* 	 * XXX - Should honor bp_flags "broadcast" bit here. 	 * Temporary workaround: use the :ra=ADDR: option to 	 * set the reply address to the broadcast address. 	 */
comment|/* 	 * If the destination address was specified explicitly 	 * (i.e. the broadcast address for HP compatiblity) 	 * then send the response to that address.  Otherwise, 	 * act in accordance with RFC951: 	 *   If the client IP address is specified, use that 	 * else if gateway IP address is specified, use that 	 * else make a temporary arp cache entry for the client's 	 * NEW IP/hardware address and use that. 	 */
if|if
condition|(
name|dst_override
condition|)
block|{
name|dst
operator|.
name|s_addr
operator|=
name|dst_override
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"reply address override: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
condition|)
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_ciaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bp_giaddr
operator|.
name|s_addr
operator|&&
name|forward
operator|==
literal|0
condition|)
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_giaddr
expr_stmt|;
name|port
operator|=
name|bootps_port
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending reply to gateway %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_yiaddr
expr_stmt|;
name|ha
operator|=
name|bp
operator|->
name|bp_chaddr
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|bp_hlen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXHADDRLEN
condition|)
name|len
operator|=
name|MAXHADDRLEN
expr_stmt|;
name|haf
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|bp_htype
expr_stmt|;
if|if
condition|(
name|haf
operator|==
literal|0
condition|)
name|haf
operator|=
name|HTYPE_ETHERNET
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"setarp %s - %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|ha
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|setarp
argument_list|(
name|s
argument_list|,
operator|&
name|dst
argument_list|,
name|haf
argument_list|,
name|ha
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|forward
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bp
operator|->
name|bp_siaddr
operator|.
name|s_addr
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|in_addr
name|siaddr
decl_stmt|;
comment|/* 		 * If we are originating this reply, we 		 * need to find our own interface address to 		 * put in the bp_siaddr field of the reply. 		 * If this server is multi-homed, pick the 		 * 'best' interface (the one on the same net 		 * as the client).  Of course, the client may 		 * be on the other side of a BOOTP gateway... 		 */
name|ifr
operator|=
name|getif
argument_list|(
name|s
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sip
decl_stmt|;
name|sip
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|->
name|ifr_addr
operator|)
expr_stmt|;
name|siaddr
operator|=
name|sip
operator|->
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use my "official" IP address. */
name|siaddr
operator|=
name|my_ip_addr
expr_stmt|;
block|}
comment|/* XXX - No need to set bp_giaddr here. */
comment|/* Finally, set the server address field. */
name|bp
operator|->
name|bp_siaddr
operator|=
name|siaddr
expr_stmt|;
block|}
comment|/* Set up socket address for send. */
name|send_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|send_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|send_addr
operator|.
name|sin_addr
operator|=
name|dst
expr_stmt|;
comment|/* Send reply with same size packet as request used. */
if|if
condition|(
name|sendto
argument_list|(
name|s
argument_list|,
name|pktbuf
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|send_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|send_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %s"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sendreply */
end_comment

begin_escape
end_escape

begin_comment
comment|/* nmatch() - now in getif.c */
end_comment

begin_comment
comment|/* setarp() - now in hwaddr.c */
end_comment

begin_comment
comment|/*  * This call checks read access to a file.  It returns 0 if the file given  * by "path" exists and is publically readable.  A value of -1 is returned if  * access is not permitted or an error occurs.  Successful calls also  * return the file size in bytes using the long pointer "filesize".  *  * The read permission bit for "other" users is checked.  This bit must be  * set for tftpd(8) to allow clients to read the file.  */
end_comment

begin_function
name|PRIVATE
name|int
name|chk_access
parameter_list|(
name|path
parameter_list|,
name|filesize
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int32
modifier|*
name|filesize
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st
operator|.
name|st_mode
operator|&
operator|(
name|S_IREAD
operator|>>
literal|6
operator|)
operator|)
condition|)
block|{
operator|*
name|filesize
operator|=
operator|(
name|int32
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Now in dumptab.c :  *	dumptab()  *	dump_host()  *	list_ipaddresses()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VEND_CMU
end_ifdef

begin_comment
comment|/*  * Insert the CMU "vendor" data for the host pointed to by "hp" into the  * bootp packet pointed to by "bp".  */
end_comment

begin_function
name|PRIVATE
name|void
name|dovend_cmu
parameter_list|(
name|bp
parameter_list|,
name|hp
parameter_list|)
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|struct
name|cmu_vend
modifier|*
name|vendp
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|taddr
decl_stmt|;
comment|/* 	 * Initialize the entire vendor field to zeroes. 	 */
name|bzero
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in vendor information. Subnet mask, default gateway, 	 * domain name server, ien name server, time server 	 */
name|vendp
operator|=
operator|(
expr|struct
name|cmu_vend
operator|*
operator|)
name|bp
operator|->
name|bp_vend
expr_stmt|;
name|strcpy
argument_list|(
name|vendp
operator|->
name|v_magic
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vm_cmu
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_smask
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
expr_stmt|;
operator|(
name|vendp
operator|->
name|v_flags
operator|)
operator||=
name|VF_SMASK
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dgate
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|gateway
operator|->
name|addr
operator|->
name|s_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|domain_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dns1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dns2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|name_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ins1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ins2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|time_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ts1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ts2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
comment|/* Log message now done by caller. */
block|}
end_function

begin_comment
comment|/* dovend_cmu */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VEND_CMU */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Insert the RFC1048 vendor data for the host pointed to by "hp" into the  * bootp packet pointed to by "bp".  */
end_comment

begin_define
define|#
directive|define
name|NEED
parameter_list|(
name|LEN
parameter_list|,
name|MSG
parameter_list|)
value|do \ 	if (bytesleft< (LEN)) { \ 		report(LOG_NOTICE, noroom, \ 			   hp->hostname->string, MSG); \ 		return; \ 	} while (0)
end_define

begin_function
name|PRIVATE
name|void
name|dovend_rfc1048
parameter_list|(
name|bp
parameter_list|,
name|hp
parameter_list|,
name|bootsize
parameter_list|)
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|int32
name|bootsize
decl_stmt|;
block|{
name|int
name|bytesleft
decl_stmt|,
name|len
decl_stmt|;
name|byte
modifier|*
name|vp
decl_stmt|;
specifier|static
name|char
name|noroom
index|[]
init|=
literal|"%s: No room for \"%s\" option"
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|bp_vend
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|msg_size
condition|)
block|{
name|pktlen
operator|=
name|hp
operator|->
name|msg_size
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the request was longer than the official length, build 		 * a response of that same length where the additional length 		 * is assumed to be part of the bp_vend (options) area. 		 */
if|if
condition|(
name|pktlen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request message length=%d"
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check whether the request contains the option: 		 * Maximum DHCP Message Size (RFC1533 sec. 9.8) 		 * and if so, override the response length with its value. 		 * This request must lie within the first BP_VEND_LEN 		 * bytes of the option space. 		 */
block|{
name|byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|byte
name|tag
decl_stmt|,
name|len
decl_stmt|;
name|short
name|msgsz
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|vp
operator|+
literal|4
expr_stmt|;
name|ep
operator|=
name|p
operator|+
name|BP_VEND_LEN
operator|-
literal|4
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|ep
condition|)
block|{
name|tag
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Check for tags with no data first. */
if|if
condition|(
name|tag
operator|==
name|TAG_PAD
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|==
name|TAG_END
condition|)
break|break;
comment|/* Now scan the length byte. */
name|len
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TAG_MAX_MSGSZ
case|:
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msgsz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msgsz
operator|=
name|ntohs
argument_list|(
name|msgsz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_SUBNET_MASK
case|:
comment|/* XXX - Should preserve this if given... */
break|break;
block|}
comment|/* swtich */
name|p
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|msgsz
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request has DHCP msglen=%d"
argument_list|,
name|msgsz
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|msgsz
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid response length=%d"
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
block|}
name|bytesleft
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|bp
operator|+
name|pktlen
operator|)
operator|-
name|vp
expr_stmt|;
if|if
condition|(
name|pktlen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"extended reply, length=%d, options=%d"
argument_list|,
name|pktlen
argument_list|,
name|bytesleft
argument_list|)
expr_stmt|;
block|}
comment|/* Copy in the magic cookie */
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|vp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|vp
operator|+=
literal|4
expr_stmt|;
name|bytesleft
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
comment|/* always enough room here. */
operator|*
name|vp
operator|++
operator|=
name|TAG_SUBNET_MASK
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
name|insert_u_long
argument_list|(
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
name|bytesleft
operator|-=
literal|6
expr_stmt|;
comment|/* Fix real count */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
operator|(
name|void
operator|)
name|insert_ip
argument_list|(
name|TAG_GATEWAY
argument_list|,
name|hp
operator|->
name|gateway
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
comment|/* always enough room here */
name|bootsize
operator|=
operator|(
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|)
condition|?
operator|(
operator|(
name|bootsize
operator|+
literal|511
operator|)
operator|/
literal|512
operator|)
else|:
operator|(
name|hp
operator|->
name|bootsize
operator|)
expr_stmt|;
comment|/* Round up */
operator|*
name|vp
operator|++
operator|=
name|TAG_BOOT_SIZE
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|bootsize
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|bootsize
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bytesleft
operator|-=
literal|4
expr_stmt|;
comment|/* Tag, length, and 16 bit blocksize */
block|}
comment|/* 	 * This one is special: Remaining options go in the ext file. 	 * Only the subnet_mask, bootsize, and gateway should precede. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|exten_file
condition|)
block|{
comment|/* 		 * Check for room for exten_file.  Add 3 to account for 		 * TAG_EXTEN_FILE, length, and TAG_END. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
operator|(
name|len
operator|+
literal|3
operator|)
argument_list|,
literal|"ef"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_EXTEN_FILE
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|exten_file
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_END
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|3
expr_stmt|;
return|return;
comment|/* no more options here. */
block|}
comment|/* 	 * The remaining options are inserted by the following 	 * function (which is shared with bootpef.c). 	 * Keep back one byte for the TAG_END. 	 */
name|len
operator|=
name|dovend_rfc1497
argument_list|(
name|hp
argument_list|,
name|vp
argument_list|,
name|bytesleft
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
expr_stmt|;
comment|/* There should be at least one byte left. */
name|NEED
argument_list|(
literal|1
argument_list|,
literal|"(end)"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|TAG_END
expr_stmt|;
name|bytesleft
operator|--
expr_stmt|;
comment|/* Log message done by caller. */
if|if
condition|(
name|bytesleft
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Zero out any remaining part of the vendor area. 		 */
name|bzero
argument_list|(
name|vp
argument_list|,
name|bytesleft
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* dovend_rfc1048 */
end_comment

begin_undef
undef|#
directive|undef
name|NEED
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * Now in readfile.c:  * 	hwlookcmp()  *	iplookcmp()  */
end_comment

begin_comment
comment|/* haddrtoa() - now in hwaddr.c */
end_comment

begin_comment
comment|/*  * Now in dovend.c:  * insert_ip()  * insert_generic()  * insert_u_long()  */
end_comment

begin_comment
comment|/* get_errmsg() - now in report.c */
end_comment

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

