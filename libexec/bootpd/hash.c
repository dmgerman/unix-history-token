begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.   $FreeBSD$  ************************************************************************/
end_comment

begin_comment
comment|/*  * Generalized hash table ADT  *  * Provides multiple, dynamically-allocated, variable-sized hash tables on  * various data and keys.  *  * This package attempts to follow some of the coding conventions suggested  * by Bob Sidebotham and the AFS Clean Code Committee of the  * Information Technology Center at Carnegie Mellon.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BFUNCS
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* Yes, memcpy is OK here (no overlapped copies). */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|memset(p,0,l)
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcmp(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This can be changed to make internal routines visible to debuggers, etc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRIVATE
end_ifndef

begin_define
define|#
directive|define
name|PRIVATE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|PRIVATE
name|void
name|hashi_FreeMembers
name|P
argument_list|(
operator|(
name|hash_member
operator|*
operator|,
name|hash_freefp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * Hash table initialization routine.  *  * This routine creates and intializes a hash table of size "tablesize"  * entries.  Successful calls return a pointer to the hash table (which must  * be passed to other hash routines to identify the hash table).  Failed  * calls return NULL.  */
end_comment

begin_function
name|hash_tbl
modifier|*
name|hash_Init
parameter_list|(
name|tablesize
parameter_list|)
name|unsigned
name|tablesize
decl_stmt|;
block|{
specifier|register
name|hash_tbl
modifier|*
name|hashtblptr
decl_stmt|;
specifier|register
name|unsigned
name|totalsize
decl_stmt|;
if|if
condition|(
name|tablesize
operator|>
literal|0
condition|)
block|{
name|totalsize
operator|=
sizeof|sizeof
argument_list|(
name|hash_tbl
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hash_member
operator|*
argument_list|)
operator|*
operator|(
name|tablesize
operator|-
literal|1
operator|)
expr_stmt|;
name|hashtblptr
operator|=
operator|(
name|hash_tbl
operator|*
operator|)
name|malloc
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashtblptr
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hashtblptr
argument_list|,
name|totalsize
argument_list|)
expr_stmt|;
name|hashtblptr
operator|->
name|size
operator|=
name|tablesize
expr_stmt|;
comment|/* Success! */
name|hashtblptr
operator|->
name|bucketnum
operator|=
literal|0
expr_stmt|;
name|hashtblptr
operator|->
name|member
operator|=
operator|(
name|hashtblptr
operator|->
name|table
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|hashtblptr
operator|=
name|NULL
expr_stmt|;
comment|/* Disallow zero-length tables */
block|}
return|return
name|hashtblptr
return|;
comment|/* NULL if failure */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Frees an entire linked list of bucket members (used in the open  * hashing scheme).  Does nothing if the passed pointer is NULL.  */
end_comment

begin_function
name|PRIVATE
name|void
name|hashi_FreeMembers
parameter_list|(
name|bucketptr
parameter_list|,
name|free_data
parameter_list|)
name|hash_member
modifier|*
name|bucketptr
decl_stmt|;
name|hash_freefp
name|free_data
decl_stmt|;
block|{
name|hash_member
modifier|*
name|nextbucket
decl_stmt|;
while|while
condition|(
name|bucketptr
condition|)
block|{
name|nextbucket
operator|=
name|bucketptr
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|free_data
call|)
argument_list|(
name|bucketptr
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bucketptr
argument_list|)
expr_stmt|;
name|bucketptr
operator|=
name|nextbucket
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine re-initializes the hash table.  It frees all the allocated  * memory and resets all bucket pointers to NULL.  */
end_comment

begin_function
name|void
name|hash_Reset
parameter_list|(
name|hashtable
parameter_list|,
name|free_data
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
name|hash_freefp
name|free_data
decl_stmt|;
block|{
name|hash_member
modifier|*
modifier|*
name|bucketptr
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bucketptr
operator|=
name|hashtable
operator|->
name|table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashtable
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|hashi_FreeMembers
argument_list|(
operator|*
name|bucketptr
argument_list|,
name|free_data
argument_list|)
expr_stmt|;
operator|*
name|bucketptr
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
name|hashtable
operator|->
name|bucketnum
operator|=
literal|0
expr_stmt|;
name|hashtable
operator|->
name|member
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Generic hash function to calculate a hash code from the given string.  *  * For each byte of the string, this function left-shifts the value in an  * accumulator and then adds the byte into the accumulator.  The contents of  * the accumulator is returned after the entire string has been processed.  * It is assumed that this result will be used as the "hashcode" parameter in  * calls to other functions in this package.  These functions automatically  * adjust the hashcode for the size of each hashtable.  *  * This algorithm probably works best when the hash table size is a prime  * number.  *  * Hopefully, this function is better than the previous one which returned  * the sum of the squares of all the bytes.  I'm still open to other  * suggestions for a default hash function.  The programmer is more than  * welcome to supply his/her own hash function as that is one of the design  * features of this package.  */
end_comment

begin_function
name|unsigned
name|hash_HashFunction
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|unsigned
name|accum
decl_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
name|accum
operator|<<=
literal|1
expr_stmt|;
name|accum
operator|+=
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|string
operator|++
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
name|accum
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Returns TRUE if at least one entry for the given key exists; FALSE  * otherwise.  */
end_comment

begin_function
name|int
name|hash_Exists
parameter_list|(
name|hashtable
parameter_list|,
name|hashcode
parameter_list|,
name|compare
parameter_list|,
name|key
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|;
name|hash_cmpfp
name|compare
decl_stmt|;
name|hash_datum
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|hash_member
modifier|*
name|memberptr
decl_stmt|;
name|memberptr
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
operator|%
operator|(
name|hashtable
operator|->
name|size
operator|)
index|]
expr_stmt|;
while|while
condition|(
name|memberptr
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|key
argument_list|,
name|memberptr
operator|->
name|data
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
comment|/* Entry does exist */
block|}
name|memberptr
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
comment|/* Entry does not exist */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Insert the data item "element" into the hash table using "hashcode"  * to determine the bucket number, and "compare" and "key" to determine  * its uniqueness.  *  * If the insertion is successful 0 is returned.  If a matching entry  * already exists in the given bucket of the hash table, or some other error  * occurs, -1 is returned and the insertion is not done.  */
end_comment

begin_function
name|int
name|hash_Insert
parameter_list|(
name|hashtable
parameter_list|,
name|hashcode
parameter_list|,
name|compare
parameter_list|,
name|key
parameter_list|,
name|element
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|;
name|hash_cmpfp
name|compare
decl_stmt|;
name|hash_datum
modifier|*
name|key
decl_stmt|,
decl|*
name|element
decl_stmt|;
end_function

begin_block
block|{
name|hash_member
modifier|*
name|temp
decl_stmt|;
name|hashcode
operator|%=
name|hashtable
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|hash_Exists
argument_list|(
name|hashtable
argument_list|,
name|hashcode
argument_list|,
name|compare
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* At least one entry already exists */
block|}
name|temp
operator|=
operator|(
name|hash_member
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_member
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
operator|-
literal|1
return|;
comment|/* malloc failed! */
name|temp
operator|->
name|data
operator|=
name|element
expr_stmt|;
name|temp
operator|->
name|next
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
index|]
expr_stmt|;
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
index|]
operator|=
name|temp
expr_stmt|;
return|return
literal|0
return|;
comment|/* Success */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Delete all data elements which match the given key.  If at least one  * element is found and the deletion is successful, 0 is returned.  * If no matching elements can be found in the hash table, -1 is returned.  */
end_comment

begin_function
name|int
name|hash_Delete
parameter_list|(
name|hashtable
parameter_list|,
name|hashcode
parameter_list|,
name|compare
parameter_list|,
name|key
parameter_list|,
name|free_data
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|;
name|hash_cmpfp
name|compare
decl_stmt|;
name|hash_datum
modifier|*
name|key
decl_stmt|;
name|hash_freefp
name|free_data
decl_stmt|;
block|{
name|hash_member
modifier|*
name|memberptr
decl_stmt|,
modifier|*
name|tempptr
decl_stmt|;
name|hash_member
modifier|*
name|previous
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
name|hashcode
operator|%=
name|hashtable
operator|->
name|size
expr_stmt|;
comment|/* 	 * Delete the first member of the list if it matches.  Since this moves 	 * the second member into the first position we have to keep doing this 	 * over and over until it no longer matches. 	 */
name|memberptr
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
index|]
expr_stmt|;
while|while
condition|(
name|memberptr
operator|&&
call|(
modifier|*
name|compare
call|)
argument_list|(
name|key
argument_list|,
name|memberptr
operator|->
name|data
argument_list|)
condition|)
block|{
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
index|]
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
comment|/* 		 * Stop hashi_FreeMembers() from deleting the whole list! 		 */
name|memberptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|hashi_FreeMembers
argument_list|(
name|memberptr
argument_list|,
name|free_data
argument_list|)
expr_stmt|;
name|memberptr
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
index|]
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now traverse the rest of the list 	 */
if|if
condition|(
name|memberptr
condition|)
block|{
name|previous
operator|=
name|memberptr
expr_stmt|;
name|memberptr
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|memberptr
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|key
argument_list|,
name|memberptr
operator|->
name|data
argument_list|)
condition|)
block|{
name|tempptr
operator|=
name|memberptr
expr_stmt|;
name|previous
operator|->
name|next
operator|=
name|memberptr
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
comment|/* 			 * Put the brakes on hashi_FreeMembers(). . . . 			 */
name|tempptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|hashi_FreeMembers
argument_list|(
name|tempptr
argument_list|,
name|free_data
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|previous
operator|=
name|memberptr
expr_stmt|;
name|memberptr
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Locate and return the data entry associated with the given key.  *  * If the data entry is found, a pointer to it is returned.  Otherwise,  * NULL is returned.  */
end_comment

begin_function
name|hash_datum
modifier|*
name|hash_Lookup
parameter_list|(
name|hashtable
parameter_list|,
name|hashcode
parameter_list|,
name|compare
parameter_list|,
name|key
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
name|unsigned
name|hashcode
decl_stmt|;
name|hash_cmpfp
name|compare
decl_stmt|;
name|hash_datum
modifier|*
name|key
decl_stmt|;
block|{
name|hash_member
modifier|*
name|memberptr
decl_stmt|;
name|memberptr
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|hashcode
operator|%
operator|(
name|hashtable
operator|->
name|size
operator|)
index|]
expr_stmt|;
while|while
condition|(
name|memberptr
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|key
argument_list|,
name|memberptr
operator|->
name|data
argument_list|)
condition|)
block|{
return|return
operator|(
name|memberptr
operator|->
name|data
operator|)
return|;
block|}
name|memberptr
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Return the next available entry in the hashtable for a linear search  */
end_comment

begin_function
name|hash_datum
modifier|*
name|hash_NextEntry
parameter_list|(
name|hashtable
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
block|{
specifier|register
name|unsigned
name|bucket
decl_stmt|;
specifier|register
name|hash_member
modifier|*
name|memberptr
decl_stmt|;
comment|/* 	 * First try to pick up where we left off. 	 */
name|memberptr
operator|=
name|hashtable
operator|->
name|member
expr_stmt|;
if|if
condition|(
name|memberptr
condition|)
block|{
name|hashtable
operator|->
name|member
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
comment|/* Set up for next call */
return|return
name|memberptr
operator|->
name|data
return|;
comment|/* Return the data */
block|}
comment|/* 	 * We hit the end of a chain, so look through the array of buckets 	 * until we find a new chain (non-empty bucket) or run out of buckets. 	 */
name|bucket
operator|=
name|hashtable
operator|->
name|bucketnum
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|bucket
operator|<
name|hashtable
operator|->
name|size
operator|)
operator|&&
operator|!
operator|(
name|memberptr
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
name|bucket
index|]
operator|)
condition|)
block|{
name|bucket
operator|++
expr_stmt|;
block|}
comment|/* 	 * Check to see if we ran out of buckets. 	 */
if|if
condition|(
name|bucket
operator|>=
name|hashtable
operator|->
name|size
condition|)
block|{
comment|/* 		 * Reset to top of table for next call. 		 */
name|hashtable
operator|->
name|bucketnum
operator|=
literal|0
expr_stmt|;
name|hashtable
operator|->
name|member
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * But return end-of-table indication to the caller this time. 		 */
return|return
name|NULL
return|;
block|}
comment|/* 	 * Must have found a non-empty bucket. 	 */
name|hashtable
operator|->
name|bucketnum
operator|=
name|bucket
expr_stmt|;
name|hashtable
operator|->
name|member
operator|=
name|memberptr
operator|->
name|next
expr_stmt|;
comment|/* Set up for next call */
return|return
name|memberptr
operator|->
name|data
return|;
comment|/* Return the data */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Return the first entry in a hash table for a linear search  */
end_comment

begin_function
name|hash_datum
modifier|*
name|hash_FirstEntry
parameter_list|(
name|hashtable
parameter_list|)
name|hash_tbl
modifier|*
name|hashtable
decl_stmt|;
block|{
name|hashtable
operator|->
name|bucketnum
operator|=
literal|0
expr_stmt|;
name|hashtable
operator|->
name|member
operator|=
operator|(
name|hashtable
operator|->
name|table
operator|)
index|[
literal|0
index|]
expr_stmt|;
return|return
name|hash_NextEntry
argument_list|(
name|hashtable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

