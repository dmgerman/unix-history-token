begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)from: subr.c	8.1 (Berkeley) 6/4/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Melbourne getty.  */
end_comment

begin_define
define|#
directive|define
name|COMPAT_43
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"gettytab.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|compatflags
name|__P
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get a table entry.  */
end_comment

begin_function
name|void
name|gettable
parameter_list|(
name|name
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
name|long
name|n
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dba
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|int
name|firsttime
init|=
literal|1
decl_stmt|;
name|dba
index|[
literal|0
index|]
operator|=
name|_PATH_GETTYTAB
expr_stmt|;
name|dba
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
comment|/* 		 * we need to strdup() anything in the strings array 		 * initially in order to simplify things later 		 */
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* handle these ones more carefully */
if|if
condition|(
name|sp
operator|>=
operator|&
name|gettystrs
index|[
literal|4
index|]
operator|&&
name|sp
operator|<=
operator|&
name|gettystrs
index|[
literal|6
index|]
condition|)
name|l
operator|=
literal|2
expr_stmt|;
else|else
name|l
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|sp
operator|->
name|value
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 				 * replace, even if NULL, else we'll 				 * have problems with free()ing static mem 				 */
name|sp
operator|->
name|value
operator|=
name|p
expr_stmt|;
block|}
name|firsttime
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|cgetent
argument_list|(
operator|&
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|dba
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|msg
operator|=
literal|"%s: couldn't resolve 'tc=' in gettytab '%s'"
expr_stmt|;
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
name|msg
operator|=
literal|"%s: unknown gettytab entry '%s'"
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|msg
operator|=
literal|"%s: retrieving gettytab entry '%s': %m"
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
name|msg
operator|=
literal|"%s: recursive 'tc=' reference gettytab entry '%s'"
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
literal|"%s: unexpected cgetent() error for entry '%s'"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|msg
argument_list|,
literal|"getty"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|cgetstr
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|field
argument_list|,
operator|&
name|p
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|value
condition|)
block|{
comment|/* prefer existing value */
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|sp
operator|->
name|value
argument_list|)
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|sp
operator|->
name|value
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|value
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|cgetnum
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|field
argument_list|,
operator|&
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|np
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|np
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|n
expr_stmt|;
block|}
block|}
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|cgetcap
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|field
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
name|fp
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|value
operator|=
literal|1
operator|^
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"name=\"%s\", buf=\"%s\"\r\n"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
name|printf
argument_list|(
literal|"cgetstr: %s=%s\r\n"
argument_list|,
name|sp
operator|->
name|field
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
name|printf
argument_list|(
literal|"cgetnum: %s=%d\r\n"
argument_list|,
name|np
operator|->
name|field
argument_list|,
name|np
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
name|printf
argument_list|(
literal|"cgetflags: %s='%c' set='%c'\r\n"
argument_list|,
name|fp
operator|->
name|field
argument_list|,
name|fp
operator|->
name|value
operator|+
literal|'0'
argument_list|,
name|fp
operator|->
name|set
operator|+
literal|'0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_function
name|void
name|gendefaults
parameter_list|()
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|defalt
operator|=
name|strdup
argument_list|(
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|defalt
operator|=
name|np
operator|->
name|value
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|value
expr_stmt|;
else|else
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setdefaults
parameter_list|()
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|!
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|value
operator|=
operator|!
name|sp
operator|->
name|defalt
condition|?
name|sp
operator|->
name|defalt
else|:
name|strdup
argument_list|(
name|sp
operator|->
name|defalt
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
operator|!
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|value
operator|=
name|np
operator|->
name|defalt
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
operator|!
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|value
operator|=
name|fp
operator|->
name|defalt
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|charnames
index|[]
init|=
block|{
operator|&
name|ER
block|,
operator|&
name|KL
block|,
operator|&
name|IN
block|,
operator|&
name|QU
block|,
operator|&
name|XN
block|,
operator|&
name|XF
block|,
operator|&
name|ET
block|,
operator|&
name|BK
block|,
operator|&
name|SU
block|,
operator|&
name|DS
block|,
operator|&
name|RP
block|,
operator|&
name|FL
block|,
operator|&
name|WE
block|,
operator|&
name|LN
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|charvars
index|[]
init|=
block|{
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VERASE
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VKILL
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VINTR
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VSTART
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VSTOP
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VEOF
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VEOL
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VSUSP
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VWERASE
index|]
block|,
operator|&
name|tmode
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setchars
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|charnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|charnames
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
operator|*
name|charvars
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
else|else
operator|*
name|charvars
index|[
name|i
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Macros to clear/set/test flags. */
end_comment

begin_define
define|#
directive|define
name|SET
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
value|(t) |= (f)
end_define

begin_define
define|#
directive|define
name|CLR
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
value|(t)&= ~(f)
end_define

begin_define
define|#
directive|define
name|ISSET
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
value|((t)& (f))
end_define

begin_function
name|void
name|setflags
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|tcflag_t
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|cflag
decl_stmt|,
name|lflag
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_43
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|F0set
condition|)
block|{
name|compatflags
argument_list|(
name|F0
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|F1set
condition|)
block|{
name|compatflags
argument_list|(
name|F1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
if|if
condition|(
name|F2set
condition|)
block|{
name|compatflags
argument_list|(
name|F2
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|C0set
operator|&&
name|I0set
operator|&&
name|L0set
operator|&&
name|O0set
condition|)
block|{
name|tmode
operator|.
name|c_cflag
operator|=
name|C0
expr_stmt|;
name|tmode
operator|.
name|c_iflag
operator|=
name|I0
expr_stmt|;
name|tmode
operator|.
name|c_lflag
operator|=
name|L0
expr_stmt|;
name|tmode
operator|.
name|c_oflag
operator|=
name|O0
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|C1set
operator|&&
name|I1set
operator|&&
name|L1set
operator|&&
name|O1set
condition|)
block|{
name|tmode
operator|.
name|c_cflag
operator|=
name|C1
expr_stmt|;
name|tmode
operator|.
name|c_iflag
operator|=
name|I1
expr_stmt|;
name|tmode
operator|.
name|c_lflag
operator|=
name|L1
expr_stmt|;
name|tmode
operator|.
name|c_oflag
operator|=
name|O1
expr_stmt|;
return|return;
block|}
break|break;
default|default:
if|if
condition|(
name|C2set
operator|&&
name|I2set
operator|&&
name|L2set
operator|&&
name|O2set
condition|)
block|{
name|tmode
operator|.
name|c_cflag
operator|=
name|C2
expr_stmt|;
name|tmode
operator|.
name|c_iflag
operator|=
name|I2
expr_stmt|;
name|tmode
operator|.
name|c_lflag
operator|=
name|L2
expr_stmt|;
name|tmode
operator|.
name|c_oflag
operator|=
name|O2
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|iflag
operator|=
name|omode
operator|.
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|omode
operator|.
name|c_oflag
expr_stmt|;
name|cflag
operator|=
name|omode
operator|.
name|c_cflag
expr_stmt|;
name|lflag
operator|=
name|omode
operator|.
name|c_lflag
expr_stmt|;
if|if
condition|(
name|NP
condition|)
block|{
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CSIZE
operator||
name|PARENB
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|CS8
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|iflag
argument_list|,
name|ISTRIP
operator||
name|INPCK
operator||
name|IGNPAR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AP
operator|||
name|EP
operator|||
name|OP
condition|)
block|{
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CSIZE
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|CS7
operator||
name|PARENB
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|iflag
argument_list|,
name|ISTRIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
operator|&&
operator|!
name|EP
condition|)
block|{
name|SET
argument_list|(
name|iflag
argument_list|,
name|INPCK
operator||
name|IGNPAR
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|PARODD
argument_list|)
expr_stmt|;
if|if
condition|(
name|AP
condition|)
name|CLR
argument_list|(
name|iflag
argument_list|,
name|INPCK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EP
operator|&&
operator|!
name|OP
condition|)
block|{
name|SET
argument_list|(
name|iflag
argument_list|,
name|INPCK
operator||
name|IGNPAR
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|cflag
argument_list|,
name|PARODD
argument_list|)
expr_stmt|;
if|if
condition|(
name|AP
condition|)
name|CLR
argument_list|(
name|iflag
argument_list|,
name|INPCK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AP
operator|||
operator|(
name|EP
operator|&&
name|OP
operator|)
condition|)
block|{
name|CLR
argument_list|(
name|iflag
argument_list|,
name|INPCK
operator||
name|IGNPAR
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|cflag
argument_list|,
name|PARODD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else, leave as is */
if|#
directive|if
literal|0
block|if (UC) 		f |= LCASE;
endif|#
directive|endif
if|if
condition|(
name|HC
condition|)
name|SET
argument_list|(
name|cflag
argument_list|,
name|HUPCL
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|cflag
argument_list|,
name|HUPCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB
condition|)
name|SET
argument_list|(
name|cflag
argument_list|,
name|MDMBUF
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|cflag
argument_list|,
name|MDMBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|HW
condition|)
name|SET
argument_list|(
name|cflag
argument_list|,
name|CRTSCTS
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CRTSCTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|NL
condition|)
block|{
name|SET
argument_list|(
name|iflag
argument_list|,
name|ICRNL
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|oflag
argument_list|,
name|ONLCR
operator||
name|OPOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLR
argument_list|(
name|iflag
argument_list|,
name|ICRNL
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|oflag
argument_list|,
name|ONLCR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HT
condition|)
name|SET
argument_list|(
name|oflag
argument_list|,
name|OXTABS
operator||
name|OPOST
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|oflag
argument_list|,
name|OXTABS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XXX_DELAY
name|SET
argument_list|(
name|f
argument_list|,
name|delaybits
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* read mode flags */
if|if
condition|(
name|RW
condition|)
block|{
name|iflag
operator|=
literal|0
expr_stmt|;
name|CLR
argument_list|(
name|oflag
argument_list|,
name|OPOST
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CSIZE
operator||
name|PARENB
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|CS8
argument_list|)
expr_stmt|;
name|lflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ICANON
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|#
directive|if
literal|0
block|if (CB) 		SET(f, CRTBS);
endif|#
directive|endif
if|if
condition|(
name|CE
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOE
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CK
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOKE
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PE
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOPRT
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOPRT
argument_list|)
expr_stmt|;
if|if
condition|(
name|EC
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHO
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|XC
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOCTL
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DX
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|IXANY
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|IXANY
argument_list|)
expr_stmt|;
name|out
label|:
name|tmode
operator|.
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|tmode
operator|.
name|c_oflag
operator|=
name|oflag
expr_stmt|;
name|tmode
operator|.
name|c_cflag
operator|=
name|cflag
expr_stmt|;
name|tmode
operator|.
name|c_lflag
operator|=
name|lflag
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_comment
comment|/*  * Old TTY => termios, snatched from<sys/kern/tty_compat.c>  */
end_comment

begin_function
name|void
name|compatflags
parameter_list|(
name|flags
parameter_list|)
specifier|register
name|long
name|flags
decl_stmt|;
block|{
specifier|register
name|tcflag_t
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|cflag
decl_stmt|,
name|lflag
decl_stmt|;
name|iflag
operator|=
name|BRKINT
operator||
name|ICRNL
operator||
name|IMAXBEL
operator||
name|IXON
operator||
name|IXANY
expr_stmt|;
name|oflag
operator|=
name|OPOST
operator||
name|ONLCR
operator||
name|OXTABS
expr_stmt|;
name|cflag
operator|=
name|CREAD
expr_stmt|;
name|lflag
operator|=
name|ICANON
operator||
name|ISIG
operator||
name|IEXTEN
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|TANDEM
argument_list|)
condition|)
name|SET
argument_list|(
name|iflag
argument_list|,
name|IXOFF
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|iflag
argument_list|,
name|IXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|ECHO
argument_list|)
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHO
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|CRMOD
argument_list|)
condition|)
block|{
name|SET
argument_list|(
name|iflag
argument_list|,
name|ICRNL
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|oflag
argument_list|,
name|ONLCR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLR
argument_list|(
name|iflag
argument_list|,
name|ICRNL
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|oflag
argument_list|,
name|ONLCR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|XTABS
argument_list|)
condition|)
name|SET
argument_list|(
name|oflag
argument_list|,
name|OXTABS
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|oflag
argument_list|,
name|OXTABS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|RAW
argument_list|)
condition|)
block|{
name|iflag
operator|&=
name|IXOFF
expr_stmt|;
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ISIG
operator||
name|ICANON
operator||
name|IEXTEN
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|cflag
argument_list|,
name|PARENB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET
argument_list|(
name|iflag
argument_list|,
name|BRKINT
operator||
name|IXON
operator||
name|IMAXBEL
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|lflag
argument_list|,
name|ISIG
operator||
name|IEXTEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|CBREAK
argument_list|)
condition|)
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ICANON
argument_list|)
expr_stmt|;
else|else
name|SET
argument_list|(
name|lflag
argument_list|,
name|ICANON
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|ANYP
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|CLR
argument_list|(
name|cflag
argument_list|,
name|PARENB
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYP
case|:
name|SET
argument_list|(
name|cflag
argument_list|,
name|PARENB
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|iflag
argument_list|,
name|INPCK
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVENP
case|:
name|SET
argument_list|(
name|cflag
argument_list|,
name|PARENB
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|iflag
argument_list|,
name|INPCK
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|cflag
argument_list|,
name|PARODD
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODDP
case|:
name|SET
argument_list|(
name|cflag
argument_list|,
name|PARENB
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|iflag
argument_list|,
name|INPCK
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|PARODD
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Nothing we can do with CRTBS. */
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|PRTERA
argument_list|)
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOPRT
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOPRT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|CRTERA
argument_list|)
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOE
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOE
argument_list|)
expr_stmt|;
comment|/* Nothing we can do with TILDE. */
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|MDMBUF
argument_list|)
condition|)
name|SET
argument_list|(
name|cflag
argument_list|,
name|MDMBUF
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|cflag
argument_list|,
name|MDMBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|NOHANG
argument_list|)
condition|)
name|CLR
argument_list|(
name|cflag
argument_list|,
name|HUPCL
argument_list|)
expr_stmt|;
else|else
name|SET
argument_list|(
name|cflag
argument_list|,
name|HUPCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|CRTKIL
argument_list|)
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOKE
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|CTLECH
argument_list|)
condition|)
name|SET
argument_list|(
name|lflag
argument_list|,
name|ECHOCTL
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|lflag
argument_list|,
name|ECHOCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|flags
argument_list|,
name|DECCTQ
argument_list|)
condition|)
name|SET
argument_list|(
name|iflag
argument_list|,
name|IXANY
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|iflag
argument_list|,
name|IXANY
argument_list|)
expr_stmt|;
name|CLR
argument_list|(
name|lflag
argument_list|,
name|TOSTOP
operator||
name|FLUSHO
operator||
name|PENDIN
operator||
name|NOFLSH
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|lflag
argument_list|,
name|ISSET
argument_list|(
name|flags
argument_list|,
name|TOSTOP
operator||
name|FLUSHO
operator||
name|PENDIN
operator||
name|NOFLSH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|flags
argument_list|,
name|RAW
operator||
name|LITOUT
operator||
name|PASS8
argument_list|)
condition|)
block|{
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CSIZE
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|CS8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|flags
argument_list|,
name|RAW
operator||
name|PASS8
argument_list|)
condition|)
name|SET
argument_list|(
name|iflag
argument_list|,
name|ISTRIP
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|iflag
argument_list|,
name|ISTRIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|flags
argument_list|,
name|RAW
operator||
name|LITOUT
argument_list|)
condition|)
name|SET
argument_list|(
name|oflag
argument_list|,
name|OPOST
argument_list|)
expr_stmt|;
else|else
name|CLR
argument_list|(
name|oflag
argument_list|,
name|OPOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLR
argument_list|(
name|cflag
argument_list|,
name|CSIZE
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cflag
argument_list|,
name|CS7
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|iflag
argument_list|,
name|ISTRIP
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|oflag
argument_list|,
name|OPOST
argument_list|)
expr_stmt|;
block|}
name|tmode
operator|.
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|tmode
operator|.
name|c_oflag
operator|=
name|oflag
expr_stmt|;
name|tmode
operator|.
name|c_cflag
operator|=
name|cflag
expr_stmt|;
name|tmode
operator|.
name|c_lflag
operator|=
name|lflag
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XXX_DELAY
end_ifdef

begin_struct
struct|struct
name|delayval
block|{
name|unsigned
name|delay
decl_stmt|;
comment|/* delay in ms */
name|int
name|bits
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * below are random guesses, I can't be bothered checking  */
end_comment

begin_decl_stmt
name|struct
name|delayval
name|crdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|CR1
block|}
block|,
block|{
literal|2
block|,
name|CR2
block|}
block|,
block|{
literal|3
block|,
name|CR3
block|}
block|,
block|{
literal|83
block|,
name|CR1
block|}
block|,
block|{
literal|166
block|,
name|CR2
block|}
block|,
block|{
literal|0
block|,
name|CR3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|nldelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|NL1
block|}
block|,
comment|/* special, calculated */
block|{
literal|2
block|,
name|NL2
block|}
block|,
block|{
literal|3
block|,
name|NL3
block|}
block|,
block|{
literal|100
block|,
name|NL2
block|}
block|,
block|{
literal|0
block|,
name|NL3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|bsdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|BS1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|ffdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|FF1
block|}
block|,
block|{
literal|1750
block|,
name|FF1
block|}
block|,
block|{
literal|0
block|,
name|FF1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|tbdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|TAB1
block|}
block|,
block|{
literal|2
block|,
name|TAB2
block|}
block|,
block|{
literal|3
block|,
name|XTABS
block|}
block|,
comment|/* this is expand tabs */
block|{
literal|100
block|,
name|TAB1
block|}
block|,
block|{
literal|0
block|,
name|TAB2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|delaybits
parameter_list|()
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|f
operator|=
name|adelay
argument_list|(
name|CD
argument_list|,
name|crdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|ND
argument_list|,
name|nldelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|FD
argument_list|,
name|ffdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|TD
argument_list|,
name|tbdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|BD
argument_list|,
name|bsdelay
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|adelay
argument_list|(
name|ms
argument_list|,
name|dp
argument_list|)
decl|register
name|ms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|delayval
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ms
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|dp
operator|->
name|delay
operator|&&
name|ms
operator|>
name|dp
operator|->
name|delay
condition|)
name|dp
operator|++
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|bits
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|editedhost
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|edithost
parameter_list|(
name|pat
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|host
init|=
name|HN
decl_stmt|;
specifier|register
name|char
modifier|*
name|res
init|=
name|editedhost
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
name|pat
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
switch|switch
condition|(
operator|*
name|pat
condition|)
block|{
case|case
literal|'#'
case|:
if|if
condition|(
operator|*
name|host
condition|)
name|host
operator|++
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
operator|*
name|host
condition|)
operator|*
name|res
operator|++
operator|=
operator|*
name|host
operator|++
expr_stmt|;
break|break;
default|default:
operator|*
name|res
operator|++
operator|=
operator|*
name|pat
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|==
operator|&
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|pat
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|host
condition|)
name|strncpy
argument_list|(
name|res
argument_list|,
name|host
argument_list|,
sizeof|sizeof
name|editedhost
operator|-
operator|(
name|res
operator|-
name|editedhost
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|speedtab
block|{
name|int
name|speed
decl_stmt|;
name|int
name|uxname
decl_stmt|;
block|}
name|speedtab
index|[]
init|=
block|{
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
block|{
literal|9600
block|,
name|B9600
block|}
block|,
block|{
literal|19200
block|,
name|EXTA
block|}
block|,
block|{
literal|19
block|,
name|EXTA
block|}
block|,
comment|/* for people who say 19.2K */
block|{
literal|38400
block|,
name|EXTB
block|}
block|,
block|{
literal|38
block|,
name|EXTB
block|}
block|,
block|{
literal|7200
block|,
name|EXTB
block|}
block|,
comment|/* alternative */
block|{
literal|57600
block|,
name|B57600
block|}
block|,
block|{
literal|115200
block|,
name|B115200
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|speed
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|speedtab
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|val
operator|<=
name|B115200
condition|)
return|return
operator|(
name|val
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|speedtab
init|;
name|sp
operator|->
name|speed
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|speed
operator|==
name|val
condition|)
return|return
operator|(
name|sp
operator|->
name|uxname
operator|)
return|;
return|return
operator|(
name|B300
operator|)
return|;
comment|/* default in impossible cases */
block|}
end_function

begin_function
name|void
name|makeenv
parameter_list|(
name|env
parameter_list|)
name|char
modifier|*
name|env
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|termbuf
index|[
literal|128
index|]
init|=
literal|"TERM="
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|env
expr_stmt|;
if|if
condition|(
name|TT
operator|&&
operator|*
name|TT
condition|)
block|{
name|strcat
argument_list|(
name|termbuf
argument_list|,
name|TT
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|termbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|EV
operator|)
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This speed select mechanism is written for the Develcon DATASWITCH.  * The Develcon sends a string of the form "B{speed}\n" at a predefined  * baud rate. This string indicates the user's actual speed.  * The routine below returns the terminal type mapped from derived speed.  */
end_comment

begin_struct
struct|struct
name|portselect
block|{
specifier|const
name|char
modifier|*
name|ps_baud
decl_stmt|;
specifier|const
name|char
modifier|*
name|ps_type
decl_stmt|;
block|}
name|portspeeds
index|[]
init|=
block|{
block|{
literal|"B110"
block|,
literal|"std.110"
block|}
block|,
block|{
literal|"B134"
block|,
literal|"std.134"
block|}
block|,
block|{
literal|"B150"
block|,
literal|"std.150"
block|}
block|,
block|{
literal|"B300"
block|,
literal|"std.300"
block|}
block|,
block|{
literal|"B600"
block|,
literal|"std.600"
block|}
block|,
block|{
literal|"B1200"
block|,
literal|"std.1200"
block|}
block|,
block|{
literal|"B2400"
block|,
literal|"std.2400"
block|}
block|,
block|{
literal|"B4800"
block|,
literal|"std.4800"
block|}
block|,
block|{
literal|"B9600"
block|,
literal|"std.9600"
block|}
block|,
block|{
literal|"B19200"
block|,
literal|"std.19200"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|portselector
parameter_list|()
block|{
name|char
name|c
decl_stmt|,
name|baud
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
literal|"default"
decl_stmt|;
specifier|register
name|struct
name|portselect
modifier|*
name|ps
decl_stmt|;
name|int
name|len
decl_stmt|;
name|alarm
argument_list|(
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
sizeof|sizeof
argument_list|(
name|baud
argument_list|)
operator|-
literal|1
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* in case of leading garbage */
name|baud
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
block|}
name|baud
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|portspeeds
init|;
name|ps
operator|->
name|ps_baud
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ps
operator|->
name|ps_baud
argument_list|,
name|baud
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ps
operator|->
name|ps_type
expr_stmt|;
break|break;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for connection to complete */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This auto-baud speed select mechanism is written for the Micom 600  * portselector. Selection is done by looking at how the character '\r'  * is garbled at the different speeds.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|autobaud
parameter_list|()
block|{
name|int
name|rfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
literal|"9600-baud"
decl_stmt|;
operator|(
name|void
operator|)
name|tcflush
argument_list|(
literal|0
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
name|rfds
operator|=
literal|1
operator|<<
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|32
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|rfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|type
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|(
name|type
operator|)
return|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|20
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|32
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcflush
argument_list|(
literal|0
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
literal|0377
condition|)
block|{
case|case
literal|0200
case|:
comment|/* 300-baud */
name|type
operator|=
literal|"300-baud"
expr_stmt|;
break|break;
case|case
literal|0346
case|:
comment|/* 1200-baud */
name|type
operator|=
literal|"1200-baud"
expr_stmt|;
break|break;
case|case
literal|015
case|:
comment|/* 2400-baud */
case|case
literal|0215
case|:
name|type
operator|=
literal|"2400-baud"
expr_stmt|;
break|break;
default|default:
comment|/* 4800-baud */
name|type
operator|=
literal|"4800-baud"
expr_stmt|;
break|break;
case|case
literal|0377
case|:
comment|/* 9600-baud */
name|type
operator|=
literal|"9600-baud"
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

end_unit

