begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)subr.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Melbourne getty.  */
end_comment

begin_define
define|#
directive|define
name|USE_OLD_TTY
end_define

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gettytab.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sgttyb
name|tmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tchars
name|tc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ltchars
name|ltc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a table entry.  */
end_comment

begin_function
name|void
name|gettable
parameter_list|(
name|name
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|dba
index|[
literal|2
index|]
decl_stmt|;
name|dba
index|[
literal|0
index|]
operator|=
name|_PATH_GETTYTAB
expr_stmt|;
name|dba
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cgetent
argument_list|(
operator|&
name|buf
argument_list|,
name|dba
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
name|cgetstr
argument_list|(
name|buf
argument_list|,
name|sp
operator|->
name|field
argument_list|,
operator|&
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|cgetnum
argument_list|(
name|buf
argument_list|,
name|np
operator|->
name|field
argument_list|,
operator|&
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|np
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|np
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|n
expr_stmt|;
block|}
block|}
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|cgetcap
argument_list|(
name|buf
argument_list|,
name|fp
operator|->
name|field
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
name|fp
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|value
operator|=
literal|1
operator|^
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"name=\"%s\", buf=\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
name|printf
argument_list|(
literal|"cgetstr: %s=%s\n"
argument_list|,
name|sp
operator|->
name|field
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
name|printf
argument_list|(
literal|"cgetnum: %s=%d\n"
argument_list|,
name|np
operator|->
name|field
argument_list|,
name|np
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
name|printf
argument_list|(
literal|"cgetflags: %s='%c' set='%c'\n"
argument_list|,
name|fp
operator|->
name|field
argument_list|,
name|fp
operator|->
name|value
operator|+
literal|'0'
argument_list|,
name|fp
operator|->
name|set
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_block

begin_function
name|void
name|gendefaults
parameter_list|()
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|defalt
operator|=
name|sp
operator|->
name|value
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|defalt
operator|=
name|np
operator|->
name|value
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|value
expr_stmt|;
else|else
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setdefaults
parameter_list|()
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|!
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|value
operator|=
name|sp
operator|->
name|defalt
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
operator|!
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|value
operator|=
name|np
operator|->
name|defalt
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
operator|!
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|value
operator|=
name|fp
operator|->
name|defalt
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|charnames
index|[]
init|=
block|{
operator|&
name|ER
block|,
operator|&
name|KL
block|,
operator|&
name|IN
block|,
operator|&
name|QU
block|,
operator|&
name|XN
block|,
operator|&
name|XF
block|,
operator|&
name|ET
block|,
operator|&
name|BK
block|,
operator|&
name|SU
block|,
operator|&
name|DS
block|,
operator|&
name|RP
block|,
operator|&
name|FL
block|,
operator|&
name|WE
block|,
operator|&
name|LN
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|charvars
index|[]
init|=
block|{
operator|&
name|tmode
operator|.
name|sg_erase
block|,
operator|&
name|tmode
operator|.
name|sg_kill
block|,
operator|&
name|tc
operator|.
name|t_intrc
block|,
operator|&
name|tc
operator|.
name|t_quitc
block|,
operator|&
name|tc
operator|.
name|t_startc
block|,
operator|&
name|tc
operator|.
name|t_stopc
block|,
operator|&
name|tc
operator|.
name|t_eofc
block|,
operator|&
name|tc
operator|.
name|t_brkc
block|,
operator|&
name|ltc
operator|.
name|t_suspc
block|,
operator|&
name|ltc
operator|.
name|t_dsuspc
block|,
operator|&
name|ltc
operator|.
name|t_rprntc
block|,
operator|&
name|ltc
operator|.
name|t_flushc
block|,
operator|&
name|ltc
operator|.
name|t_werasc
block|,
operator|&
name|ltc
operator|.
name|t_lnextc
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setchars
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|charnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|charnames
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
operator|*
name|charvars
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
else|else
operator|*
name|charvars
index|[
name|i
index|]
operator|=
literal|'\377'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
name|setflags
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|long
name|f
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|F0set
condition|)
return|return
operator|(
name|F0
operator|)
return|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|F1set
condition|)
return|return
operator|(
name|F1
operator|)
return|;
break|break;
default|default:
if|if
condition|(
name|F2set
condition|)
return|return
operator|(
name|F2
operator|)
return|;
break|break;
block|}
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AP
condition|)
name|f
operator||=
name|ANYP
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
condition|)
name|f
operator||=
name|ODDP
expr_stmt|;
elseif|else
if|if
condition|(
name|EP
condition|)
name|f
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|UC
condition|)
name|f
operator||=
name|LCASE
expr_stmt|;
if|if
condition|(
name|NL
condition|)
name|f
operator||=
name|CRMOD
expr_stmt|;
name|f
operator||=
name|delaybits
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* read mode flags */
if|if
condition|(
name|RW
condition|)
name|f
operator||=
name|RAW
expr_stmt|;
else|else
name|f
operator||=
name|CBREAK
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|HT
condition|)
name|f
operator||=
name|XTABS
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|f
operator|)
return|;
if|if
condition|(
name|CB
condition|)
name|f
operator||=
name|CRTBS
expr_stmt|;
if|if
condition|(
name|CE
condition|)
name|f
operator||=
name|CRTERA
expr_stmt|;
if|if
condition|(
name|CK
condition|)
name|f
operator||=
name|CRTKIL
expr_stmt|;
if|if
condition|(
name|PE
condition|)
name|f
operator||=
name|PRTERA
expr_stmt|;
if|if
condition|(
name|EC
condition|)
name|f
operator||=
name|ECHO
expr_stmt|;
if|if
condition|(
name|XC
condition|)
name|f
operator||=
name|CTLECH
expr_stmt|;
if|if
condition|(
name|DX
condition|)
name|f
operator||=
name|DECCTQ
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|delayval
block|{
name|unsigned
name|delay
decl_stmt|;
comment|/* delay in ms */
name|int
name|bits
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * below are random guesses, I can't be bothered checking  */
end_comment

begin_decl_stmt
name|struct
name|delayval
name|crdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|CR1
block|}
block|,
block|{
literal|2
block|,
name|CR2
block|}
block|,
block|{
literal|3
block|,
name|CR3
block|}
block|,
block|{
literal|83
block|,
name|CR1
block|}
block|,
block|{
literal|166
block|,
name|CR2
block|}
block|,
block|{
literal|0
block|,
name|CR3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|nldelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|NL1
block|}
block|,
comment|/* special, calculated */
block|{
literal|2
block|,
name|NL2
block|}
block|,
block|{
literal|3
block|,
name|NL3
block|}
block|,
block|{
literal|100
block|,
name|NL2
block|}
block|,
block|{
literal|0
block|,
name|NL3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|bsdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|BS1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|ffdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|FF1
block|}
block|,
block|{
literal|1750
block|,
name|FF1
block|}
block|,
block|{
literal|0
block|,
name|FF1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|tbdelay
index|[]
init|=
block|{
block|{
literal|1
block|,
name|TAB1
block|}
block|,
block|{
literal|2
block|,
name|TAB2
block|}
block|,
block|{
literal|3
block|,
name|XTABS
block|}
block|,
comment|/* this is expand tabs */
block|{
literal|100
block|,
name|TAB1
block|}
block|,
block|{
literal|0
block|,
name|TAB2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|delaybits
parameter_list|()
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|f
operator|=
name|adelay
argument_list|(
name|CD
argument_list|,
name|crdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|ND
argument_list|,
name|nldelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|FD
argument_list|,
name|ffdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|TD
argument_list|,
name|tbdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|BD
argument_list|,
name|bsdelay
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|adelay
argument_list|(
name|ms
argument_list|,
name|dp
argument_list|)
decl|register
name|ms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|delayval
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ms
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|dp
operator|->
name|delay
operator|&&
name|ms
operator|>
name|dp
operator|->
name|delay
condition|)
name|dp
operator|++
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|bits
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|editedhost
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|edithost
parameter_list|(
name|pat
parameter_list|)
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|host
init|=
name|HN
decl_stmt|;
specifier|register
name|char
modifier|*
name|res
init|=
name|editedhost
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
name|pat
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
switch|switch
condition|(
operator|*
name|pat
condition|)
block|{
case|case
literal|'#'
case|:
if|if
condition|(
operator|*
name|host
condition|)
name|host
operator|++
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
operator|*
name|host
condition|)
operator|*
name|res
operator|++
operator|=
operator|*
name|host
operator|++
expr_stmt|;
break|break;
default|default:
operator|*
name|res
operator|++
operator|=
operator|*
name|pat
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|==
operator|&
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|pat
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|host
condition|)
name|strncpy
argument_list|(
name|res
argument_list|,
name|host
argument_list|,
sizeof|sizeof
name|editedhost
operator|-
operator|(
name|res
operator|-
name|editedhost
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|speedtab
block|{
name|int
name|speed
decl_stmt|;
name|int
name|uxname
decl_stmt|;
block|}
name|speedtab
index|[]
init|=
block|{
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
block|{
literal|9600
block|,
name|B9600
block|}
block|,
block|{
literal|19200
block|,
name|EXTA
block|}
block|,
block|{
literal|19
block|,
name|EXTA
block|}
block|,
comment|/* for people who say 19.2K */
block|{
literal|38400
block|,
name|EXTB
block|}
block|,
block|{
literal|38
block|,
name|EXTB
block|}
block|,
block|{
literal|7200
block|,
name|EXTB
block|}
block|,
comment|/* alternative */
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|speed
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|speedtab
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|val
operator|<=
literal|15
condition|)
return|return
operator|(
name|val
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|speedtab
init|;
name|sp
operator|->
name|speed
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|speed
operator|==
name|val
condition|)
return|return
operator|(
name|sp
operator|->
name|uxname
operator|)
return|;
return|return
operator|(
name|B300
operator|)
return|;
comment|/* default in impossible cases */
block|}
end_function

begin_function
name|void
name|makeenv
parameter_list|(
name|env
parameter_list|)
name|char
modifier|*
name|env
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|termbuf
index|[
literal|128
index|]
init|=
literal|"TERM="
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|env
expr_stmt|;
if|if
condition|(
name|TT
operator|&&
operator|*
name|TT
condition|)
block|{
name|strcat
argument_list|(
name|termbuf
argument_list|,
name|TT
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|termbuf
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|=
name|EV
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|','
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This speed select mechanism is written for the Develcon DATASWITCH.  * The Develcon sends a string of the form "B{speed}\n" at a predefined  * baud rate. This string indicates the user's actual speed.  * The routine below returns the terminal type mapped from derived speed.  */
end_comment

begin_struct
struct|struct
name|portselect
block|{
name|char
modifier|*
name|ps_baud
decl_stmt|;
name|char
modifier|*
name|ps_type
decl_stmt|;
block|}
name|portspeeds
index|[]
init|=
block|{
block|{
literal|"B110"
block|,
literal|"std.110"
block|}
block|,
block|{
literal|"B134"
block|,
literal|"std.134"
block|}
block|,
block|{
literal|"B150"
block|,
literal|"std.150"
block|}
block|,
block|{
literal|"B300"
block|,
literal|"std.300"
block|}
block|,
block|{
literal|"B600"
block|,
literal|"std.600"
block|}
block|,
block|{
literal|"B1200"
block|,
literal|"std.1200"
block|}
block|,
block|{
literal|"B2400"
block|,
literal|"std.2400"
block|}
block|,
block|{
literal|"B4800"
block|,
literal|"std.4800"
block|}
block|,
block|{
literal|"B9600"
block|,
literal|"std.9600"
block|}
block|,
block|{
literal|"B19200"
block|,
literal|"std.19200"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|portselector
parameter_list|()
block|{
name|char
name|c
decl_stmt|,
name|baud
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|type
init|=
literal|"default"
decl_stmt|;
specifier|register
name|struct
name|portselect
modifier|*
name|ps
decl_stmt|;
name|int
name|len
decl_stmt|;
name|alarm
argument_list|(
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
sizeof|sizeof
argument_list|(
name|baud
argument_list|)
operator|-
literal|1
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* in case of leading garbage */
name|baud
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
block|}
name|baud
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|portspeeds
init|;
name|ps
operator|->
name|ps_baud
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ps
operator|->
name|ps_baud
argument_list|,
name|baud
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ps
operator|->
name|ps_type
expr_stmt|;
break|break;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for connection to complete */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This auto-baud speed select mechanism is written for the Micom 600  * portselector. Selection is done by looking at how the character '\r'  * is garbled at the different speeds.  */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_function
name|char
modifier|*
name|autobaud
parameter_list|()
block|{
name|int
name|rfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|type
init|=
literal|"9600-baud"
decl_stmt|;
name|int
name|null
init|=
literal|0
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|null
argument_list|)
expr_stmt|;
name|rfds
operator|=
literal|1
operator|<<
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|32
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|rfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|type
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|(
name|type
operator|)
return|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|20
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|32
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|null
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
literal|0377
condition|)
block|{
case|case
literal|0200
case|:
comment|/* 300-baud */
name|type
operator|=
literal|"300-baud"
expr_stmt|;
break|break;
case|case
literal|0346
case|:
comment|/* 1200-baud */
name|type
operator|=
literal|"1200-baud"
expr_stmt|;
break|break;
case|case
literal|015
case|:
comment|/* 2400-baud */
case|case
literal|0215
case|:
name|type
operator|=
literal|"2400-baud"
expr_stmt|;
break|break;
default|default:
comment|/* 4800-baud */
name|type
operator|=
literal|"4800-baud"
expr_stmt|;
break|break;
case|case
literal|0377
case|:
comment|/* 9600-baud */
name|type
operator|=
literal|"9600-baud"
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

end_unit

