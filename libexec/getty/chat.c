begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997  *	David L Nugent<davidn@blaze.net.au>.  *	All rights reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, is permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. This work was done expressly for inclusion into FreeBSD.  Other use  *    is permitted provided this notation is included.  * 4. Absolutely no warranty of function or purpose is made by the authors.  * 5. Modifications may be freely made to this file providing the above  *    conditions are met.  *  * Modem chat module - send/expect style functions for getty  * For semi-intelligent modem handling.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttydefaults.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_define
define|#
directive|define
name|PAUSE_CH
value|(unsigned char)'\xff'
end_define

begin_comment
comment|/* pause kludge */
end_comment

begin_define
define|#
directive|define
name|CHATDEBUG_RECEIVE
value|0x01
end_define

begin_define
define|#
directive|define
name|CHATDEBUG_SEND
value|0x02
end_define

begin_define
define|#
directive|define
name|CHATDEBUG_EXPECT
value|0x04
end_define

begin_define
define|#
directive|define
name|CHATDEBUG_MISC
value|0x08
end_define

begin_define
define|#
directive|define
name|CHATDEBUG_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|CHAT_DEFAULT_TIMEOUT
value|10
end_define

begin_decl_stmt
specifier|static
name|int
name|chat_debug
init|=
name|CHATDEBUG_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chat_alarm
init|=
name|CHAT_DEFAULT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|alarmed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chat_alrm
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chat_unalarm
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getdigit
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|read_chat
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cleanchr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|unsigned
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cleanstr
name|__P
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|result
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chat_expect
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chat_send
name|__P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * alarm signal handler  * handle timeouts in read/write  * change stdin to non-blocking mode to prevent  * possible hang in read().  */
end_comment

begin_function
specifier|static
name|void
name|chat_alrm
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|chat_alrm
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn back on blocking mode reset by chat_alrm()  */
end_comment

begin_function
specifier|static
name|int
name|chat_unalarm
parameter_list|()
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
return|return
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|off
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert a string of a given base (octal/hex) to binary  */
end_comment

begin_function
specifier|static
name|int
name|getdigit
parameter_list|(
name|ptr
parameter_list|,
name|base
parameter_list|,
name|max
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
name|base
decl_stmt|,
name|max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|static
specifier|const
name|char
name|xdigits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|q
operator|=
operator|*
name|ptr
init|;
name|i
operator|++
operator|<
name|max
condition|;
operator|++
name|q
control|)
block|{
name|int
name|sval
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|strchr
argument_list|(
name|xdigits
argument_list|,
name|tolower
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|sval
operator|=
name|s
operator|-
name|xdigits
operator|)
operator|>=
name|base
condition|)
break|break;
name|val
operator|=
operator|(
name|val
operator|*
name|base
operator|)
operator|+
name|sval
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|q
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * read_chat()  * Convert a whitespace delimtied string into an array  * of strings, being expect/send pairs  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|read_chat
parameter_list|(
name|chatstr
parameter_list|)
name|char
modifier|*
modifier|*
name|chatstr
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|chatstr
decl_stmt|;
name|char
modifier|*
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|tmp
operator|=
name|malloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|res
operator|=
name|malloc
argument_list|(
operator|(
name|l
operator|/
literal|2
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|ws
index|[]
init|=
literal|" \t"
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
operator|,
name|p
operator|=
name|strtok
argument_list|(
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|str
argument_list|)
argument_list|,
name|ws
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|ws
argument_list|)
control|)
block|{
name|unsigned
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* Read escapes */
for|for
control|(
name|q
operator|=
name|r
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
init|;
operator|*
name|r
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\\'
condition|)
block|{
comment|/* handle special escapes */
switch|switch
condition|(
operator|*
operator|++
name|q
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* bell */
operator|*
name|r
operator|++
operator|=
literal|'\a'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* cr */
operator|*
name|r
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* nl */
operator|*
name|r
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* ff */
operator|*
name|r
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* bs */
operator|*
name|r
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* esc */
operator|*
name|r
operator|++
operator|=
literal|27
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* tab */
operator|*
name|r
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause */
operator|*
name|r
operator|++
operator|=
name|PAUSE_CH
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
comment|/* space */
operator|*
name|r
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* hexdigit */
operator|++
name|q
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|getdigit
argument_list|(
operator|&
name|q
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|--
name|q
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* octal */
operator|++
name|q
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|getdigit
argument_list|(
operator|&
name|q
argument_list|,
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|--
name|q
expr_stmt|;
break|break;
default|default:
comment|/* literal */
operator|*
name|r
operator|++
operator|=
operator|*
name|q
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* not past eos */
operator|--
name|q
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* copy standard character */
operator|*
name|r
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
block|}
comment|/* Remove surrounding quotes, if any 				 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|q
operator|=
name|strrchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
operator|&&
operator|*
name|q
operator|==
operator|*
name|p
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|res
index|[
name|l
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|res
index|[
name|l
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|chatstr
operator|=
name|tmp
expr_stmt|;
return|return
name|res
return|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * clean a character for display (ctrl/meta character)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cleanchr
parameter_list|(
name|buf
parameter_list|,
name|ch
parameter_list|)
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
specifier|static
name|char
name|tmpbuf
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|buf
condition|?
operator|*
name|buf
else|:
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|ch
operator|&
literal|0x80
condition|)
block|{
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
name|ch
operator|&=
literal|0x7f
expr_stmt|;
block|}
else|else
name|l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|32
condition|)
block|{
name|tmp
index|[
name|l
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|tmp
index|[
name|l
operator|++
index|]
operator|=
name|ch
operator|+
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|127
condition|)
block|{
name|tmp
index|[
name|l
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|tmp
index|[
name|l
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|tmp
index|[
name|l
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|tmp
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
condition|)
operator|*
name|buf
operator|=
name|tmp
operator|+
name|l
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/*  * clean a string for display (ctrl/meta characters)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cleanstr
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|tmplen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tmplen
operator|<
name|l
operator|*
literal|4
operator|+
literal|1
condition|)
name|tmp
operator|=
name|realloc
argument_list|(
name|tmp
argument_list|,
name|tmplen
operator|=
name|l
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|tmplen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|"(mem alloc error)"
return|;
block|}
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tmp
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
name|cleanchr
argument_list|(
operator|&
name|p
argument_list|,
name|s
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/*  * return result as an pseudo-english word  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|result
parameter_list|(
name|r
parameter_list|)
name|int
name|r
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|results
index|[]
init|=
block|{
literal|"OK"
block|,
literal|"MEMERROR"
block|,
literal|"IOERROR"
block|,
literal|"TIMEOUT"
block|}
decl_stmt|;
return|return
name|results
index|[
name|r
operator|&
literal|3
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * chat_expect()  * scan input for an expected string  */
end_comment

begin_function
specifier|static
name|int
name|chat_expect
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_EXPECT
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"chat_expect '%s'"
argument_list|,
name|cleanstr
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|got
decl_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|r
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
name|got
argument_list|,
literal|0
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|chat_alarm
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|==
literal|0
operator|&&
name|i
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|alarmed
condition|)
name|r
operator|=
literal|3
expr_stmt|;
else|else
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_RECEIVE
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"chat_recv '%s' m=%d"
argument_list|,
name|cleanchr
argument_list|(
name|NULL
argument_list|,
name|ch
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|str
index|[
name|i
index|]
condition|)
name|got
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|j
init|=
literal|1
decl_stmt|;
comment|/* See if we can resync on a 							 * partial match in our buffer 							 */
while|while
condition|(
name|j
operator|<
name|i
operator|&&
name|memcmp
argument_list|(
name|got
operator|+
name|j
argument_list|,
name|str
argument_list|,
name|i
operator|-
name|j
argument_list|)
operator|!=
name|NULL
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|memcpy
argument_list|(
name|got
argument_list|,
name|got
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
block|}
block|}
else|else
name|r
operator|=
name|alarmed
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chat_unalarm
argument_list|()
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|got
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_EXPECT
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"chat_expect %s"
argument_list|,
name|result
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * chat_send()  * send a chat string  */
end_comment

begin_function
specifier|static
name|int
name|chat_send
parameter_list|(
name|str
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chat_debug
operator|&&
name|CHATDEBUG_SEND
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"chat_send '%s'"
argument_list|,
name|cleanstr
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
block|{
name|alarm
argument_list|(
name|chat_alarm
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|==
literal|0
operator|&&
operator|*
name|str
condition|)
block|{
name|unsigned
name|char
name|ch
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
operator|++
decl_stmt|;
if|if
condition|(
name|alarmed
condition|)
name|r
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|PAUSE_CH
condition|)
name|usleep
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/* 1/2 second */
else|else
block|{
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* be kind to modem */
if|if
condition|(
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|r
operator|=
name|alarmed
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chat_unalarm
argument_list|()
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_SEND
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"chat_send %s"
argument_list|,
name|result
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * getty_chat()  *  * Termination codes:  * -1 - no script supplied  *  0 - script terminated correctly  *  1 - invalid argument, expect string too large, etc.  *  2 - error on an I/O operation or fatal error condition  *  3 - timeout waiting for a simple string  *  * Parameters:  *  char *scrstr     - unparsed chat script  *  timeout          - seconds timeout  *  debug            - debug value (bitmask)  */
end_comment

begin_function
name|int
name|getty_chat
parameter_list|(
name|scrstr
parameter_list|,
name|timeout
parameter_list|,
name|debug
parameter_list|)
name|char
modifier|*
name|scrstr
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|debug
decl_stmt|;
block|{
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
name|chat_alarm
operator|=
name|timeout
condition|?
name|timeout
else|:
name|CHAT_DEFAULT_TIMEOUT
expr_stmt|;
name|chat_debug
operator|=
name|debug
expr_stmt|;
if|if
condition|(
name|scrstr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|script
decl_stmt|;
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_MISC
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getty_chat script='%s'"
argument_list|,
name|scrstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|script
operator|=
name|read_chat
argument_list|(
operator|&
name|scrstr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
name|r
operator|=
literal|0
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|sig_t
name|old_alarm
decl_stmt|;
comment|/* 			 * We need to be in raw mode for all this 			 * Rely on caller...                          */
name|old_alarm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|chat_alrm
argument_list|)
expr_stmt|;
name|chat_unalarm
argument_list|()
expr_stmt|;
comment|/* Force blocking mode at start */
comment|/* 			 * This is the send/expect loop 			 */
while|while
condition|(
name|r
operator|==
literal|0
operator|&&
name|script
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|r
operator|=
name|chat_expect
argument_list|(
name|script
index|[
name|i
operator|++
index|]
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|script
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|r
operator|=
name|chat_send
argument_list|(
name|script
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|old_alarm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scrstr
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure stdin is in blocking mode 			 */
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chat_debug
operator|&
name|CHATDEBUG_MISC
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getty_chat %s"
argument_list|,
name|result
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

end_unit

