begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: library.c,v 1.7 1997/02/22 14:21:45 peter Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)library.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"clean.h"
end_include

begin_decl_stmt
name|void
name|add_blocks
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|BLOCK_INFO
operator|*
operator|,
name|int
operator|*
operator|,
name|SEGSUM
operator|*
operator|,
name|caddr_t
operator|,
name|daddr_t
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_inodes
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|BLOCK_INFO
operator|*
operator|,
name|int
operator|*
operator|,
name|SEGSUM
operator|*
operator|,
name|caddr_t
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bi_compare
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bi_toss
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|get_ifile
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_superblock
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
expr|struct
name|lfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pseg_valid
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|SEGSUM
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function will get information on a a filesystem which matches  * the name and type given.  If a "name" is in a filesystem of the given  * type, then buf is filled with that filesystem's info, and the  * a non-zero value is returned.  */
end_comment

begin_function
name|int
name|fs_getmntinfo
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|struct
name|statfs
modifier|*
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
comment|/* allocate space for the filesystem info */
operator|*
name|buf
operator|=
operator|(
expr|struct
name|statfs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* grab the filesystem info */
if|if
condition|(
name|statfs
argument_list|(
name|name
argument_list|,
operator|*
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check to see if it's the one we want */
if|if
condition|(
operator|(
operator|(
operator|*
name|buf
operator|)
operator|->
name|f_type
operator|!=
name|type
operator|)
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|buf
operator|)
operator|->
name|f_mntonname
argument_list|,
name|MNAMELEN
argument_list|)
condition|)
block|{
comment|/* "this is not the filesystem you're looking for" */
name|free
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Get all the information available on an LFS file system.  * Returns an pointer to an FS_INFO structure, NULL on error.  */
end_comment

begin_function
name|FS_INFO
modifier|*
name|get_fs_info
parameter_list|(
name|lstatfsp
parameter_list|,
name|use_mmap
parameter_list|)
name|struct
name|statfs
modifier|*
name|lstatfsp
decl_stmt|;
comment|/* IN: pointer to statfs struct */
name|int
name|use_mmap
decl_stmt|;
comment|/* IN: mmap or read */
block|{
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fsp
operator|=
operator|(
name|FS_INFO
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FS_INFO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
name|fsp
argument_list|,
sizeof|sizeof
argument_list|(
name|FS_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fi_statfsp
operator|=
name|lstatfsp
expr_stmt|;
if|if
condition|(
name|get_superblock
argument_list|(
name|fsp
argument_list|,
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_fs_info: get_superblock failed"
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fi_daddr_shift
operator|=
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_bshift
operator|-
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_fsbtodb
expr_stmt|;
name|get_ifile
argument_list|(
name|fsp
argument_list|,
name|use_mmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|fsp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we are reading the ifile then we need to refresh it.  Even if  * we are mmapping it, it might have grown.  Finally, we need to  * refresh the file system information (statfs) info.  */
end_comment

begin_function
name|void
name|reread_fs_info
parameter_list|(
name|fsp
parameter_list|,
name|use_mmap
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* IN: prointer fs_infos to reread */
name|int
name|use_mmap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|statfs
argument_list|(
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntonname
argument_list|,
name|fsp
operator|->
name|fi_statfsp
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"reread_fs_info: statfs failed"
argument_list|)
expr_stmt|;
name|get_ifile
argument_list|(
name|fsp
argument_list|,
name|use_mmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Gets the superblock from disk (possibly in face of errors)  */
end_comment

begin_function
name|int
name|get_superblock
parameter_list|(
name|fsp
parameter_list|,
name|sbp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* local file system info structure */
name|struct
name|lfs
modifier|*
name|sbp
decl_stmt|;
block|{
name|char
name|mntfromname
index|[
name|MNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|fid
decl_stmt|;
name|strcpy
argument_list|(
name|mntfromname
argument_list|,
literal|"/dev/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mntfromname
argument_list|,
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntfromname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|mntfromname
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"get_superblock: bad open"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|get
argument_list|(
name|fid
argument_list|,
name|LFS_LABELPAD
argument_list|,
name|sbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function will map the ifile into memory.  It causes a  * fatal error on failure.  */
end_comment

begin_function
name|void
name|get_ifile
parameter_list|(
name|fsp
parameter_list|,
name|use_mmap
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
name|int
name|use_mmap
decl_stmt|;
block|{
name|struct
name|stat
name|file_stat
decl_stmt|;
name|caddr_t
name|ifp
decl_stmt|;
name|char
modifier|*
name|ifile_name
decl_stmt|;
name|int
name|count
decl_stmt|,
name|fid
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|ifile_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntonname
argument_list|)
operator|+
name|strlen
argument_list|(
name|IFILE_NAME
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|ifile_name
argument_list|,
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntonname
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|IFILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|ifile_name
argument_list|,
name|O_RDWR
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: bad open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fid
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: fstat failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_mmap
operator|&&
name|file_stat
operator|.
name|st_size
operator|==
name|fsp
operator|->
name|fi_ifile_length
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the ifile */
if|if
condition|(
name|use_mmap
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fi_cip
condition|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|fsp
operator|->
name|fi_cip
argument_list|,
name|fsp
operator|->
name|fi_ifile_length
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|file_stat
operator|.
name|st_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fid
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: mmap failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsp
operator|->
name|fi_cip
condition|)
name|free
argument_list|(
name|fsp
operator|->
name|fi_cip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|=
name|malloc
argument_list|(
name|file_stat
operator|.
name|st_size
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: malloc failed"
argument_list|)
expr_stmt|;
name|redo_read
label|:
name|count
operator|=
name|read
argument_list|(
name|fid
argument_list|,
name|ifp
argument_list|,
operator|(
name|size_t
operator|)
name|file_stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: bad ifile read"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|<
name|file_stat
operator|.
name|st_size
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"get_ifile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fid
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get_ifile: bad ifile lseek"
argument_list|)
expr_stmt|;
goto|goto
name|redo_read
goto|;
block|}
block|}
name|fsp
operator|->
name|fi_ifile_length
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fi_cip
operator|=
operator|(
name|CLEANERINFO
operator|*
operator|)
name|ifp
expr_stmt|;
name|fsp
operator|->
name|fi_segusep
operator|=
operator|(
name|SEGUSE
operator|*
operator|)
operator|(
name|ifp
operator|+
name|CLEANSIZE
argument_list|(
name|fsp
argument_list|)
operator|)
expr_stmt|;
name|fsp
operator|->
name|fi_ifilep
operator|=
operator|(
name|IFILE
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fsp
operator|->
name|fi_segusep
operator|+
name|SEGTABSIZE
argument_list|(
name|fsp
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * The number of ifile entries is equal to the number of blocks 	 * blocks in the ifile minus the ones allocated to cleaner info 	 * and segment usage table multiplied by the number of ifile 	 * entries per page. 	 */
name|fsp
operator|->
name|fi_ifile_count
operator|=
operator|(
name|fsp
operator|->
name|fi_ifile_length
operator|>>
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_bshift
operator|-
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_cleansz
operator|-
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_segtabsz
operator|)
operator|*
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_ifpb
expr_stmt|;
name|free
argument_list|(
name|ifile_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function will scan a segment and return a list of  *<inode, blocknum> pairs which indicate which blocks were  * contained as live data within the segment when the segment  * summary was read (it may have "died" since then).  Any given  * pair will be listed at most once.  */
end_comment

begin_function
name|int
name|lfs_segmapv
parameter_list|(
name|fsp
parameter_list|,
name|seg
parameter_list|,
name|seg_buf
parameter_list|,
name|blocks
parameter_list|,
name|bcount
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to local file system information */
name|int
name|seg
decl_stmt|;
comment|/* the segment number */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* the buffer containing the segment's data */
name|BLOCK_INFO
modifier|*
modifier|*
name|blocks
decl_stmt|;
comment|/* OUT: array of block_info for live blocks */
name|int
modifier|*
name|bcount
decl_stmt|;
comment|/* OUT: number of active blocks in segment */
block|{
name|BLOCK_INFO
modifier|*
name|bip
decl_stmt|;
name|SEGSUM
modifier|*
name|sp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|caddr_t
name|s
decl_stmt|,
name|segend
decl_stmt|;
name|daddr_t
name|pseg_addr
decl_stmt|,
name|seg_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nelem
decl_stmt|,
name|nblocks
decl_stmt|,
name|sumsize
decl_stmt|;
name|time_t
name|timestamp
decl_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
name|nelem
operator|=
literal|2
operator|*
name|lfsp
operator|->
name|lfs_ssize
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bip
operator|=
name|malloc
argument_list|(
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err0
goto|;
name|sup
operator|=
name|SEGUSE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|fsp
operator|->
name|fi_segusep
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|s
operator|=
name|seg_buf
operator|+
operator|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
condition|?
name|LFS_SBPAD
else|:
literal|0
operator|)
expr_stmt|;
name|seg_addr
operator|=
name|sntoda
argument_list|(
name|lfsp
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|pseg_addr
operator|=
name|seg_addr
operator|+
operator|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
condition|?
name|btodb
argument_list|(
name|LFS_SBPAD
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\tsegment buffer at: 0x%x\tseg_addr 0x%x\n"
argument_list|,
name|s
argument_list|,
name|seg_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE */
operator|*
name|bcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|segend
operator|=
name|seg_buf
operator|+
name|seg_size
argument_list|(
name|lfsp
argument_list|)
operator|,
name|timestamp
operator|=
literal|0
init|;
name|s
operator|<
name|segend
condition|;
control|)
block|{
name|sp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\tpartial at: 0x%x\n"
argument_list|,
name|pseg_addr
argument_list|)
expr_stmt|;
name|print_SEGSUM
argument_list|(
name|lfsp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE */
name|nblocks
operator|=
name|pseg_valid
argument_list|(
name|fsp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblocks
operator|<=
literal|0
condition|)
break|break;
comment|/* Check if we have hit old data */
if|if
condition|(
name|timestamp
operator|>
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|s
operator|)
operator|->
name|ss_create
condition|)
break|break;
name|timestamp
operator|=
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|s
operator|)
operator|->
name|ss_create
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Verify size of summary block */
name|sumsize
operator|=
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|+
operator|(
name|sp
operator|->
name|ss_ninos
operator|+
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
for|for
control|(
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
name|sp
operator|+
literal|1
operator|)
init|;
name|i
operator|<
name|sp
operator|->
name|ss_nfinfo
condition|;
operator|++
name|i
control|)
block|{
name|sumsize
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
operator|(
name|fip
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sumsize
operator|>
name|LFS_SUMMARY_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Segment %d summary block too big: %d\n"
argument_list|,
name|seg
argument_list|,
name|sumsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|bcount
operator|+
name|nblocks
operator|+
name|sp
operator|->
name|ss_ninos
operator|>
name|nelem
condition|)
block|{
name|nelem
operator|=
operator|*
name|bcount
operator|+
name|nblocks
operator|+
name|sp
operator|->
name|ss_ninos
expr_stmt|;
name|bip
operator|=
name|realloc
argument_list|(
name|bip
argument_list|,
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bip
condition|)
goto|goto
name|err0
goto|;
block|}
name|add_blocks
argument_list|(
name|fsp
argument_list|,
name|bip
argument_list|,
name|bcount
argument_list|,
name|sp
argument_list|,
name|seg_buf
argument_list|,
name|seg_addr
argument_list|,
name|pseg_addr
argument_list|)
expr_stmt|;
name|add_inodes
argument_list|(
name|fsp
argument_list|,
name|bip
argument_list|,
name|bcount
argument_list|,
name|sp
argument_list|,
name|seg_buf
argument_list|,
name|seg_addr
argument_list|)
expr_stmt|;
name|pseg_addr
operator|+=
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
name|nblocks
argument_list|)
operator|+
name|bytetoda
argument_list|(
name|fsp
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|s
operator|+=
operator|(
name|nblocks
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
block|}
name|qsort
argument_list|(
name|bip
argument_list|,
operator|*
name|bcount
argument_list|,
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|bi_compare
argument_list|)
expr_stmt|;
name|toss
argument_list|(
name|bip
argument_list|,
name|bcount
argument_list|,
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|bi_toss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
block|{
name|BLOCK_INFO
modifier|*
name|_bip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"BLOCK INFOS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|_bip
operator|=
name|bip
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|bcount
condition|;
operator|++
name|_bip
operator|,
operator|++
name|i
control|)
name|PRINT_BINFO
argument_list|(
name|_bip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|blocks
operator|=
name|bip
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err0
label|:
operator|*
name|bcount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This will parse a partial segment and fill in BLOCK_INFO structures  * for each block described in the segment summary.  It will not include  * blocks or inodes from files with new version numbers.  */
end_comment

begin_function
name|void
name|add_blocks
parameter_list|(
name|fsp
parameter_list|,
name|bip
parameter_list|,
name|countp
parameter_list|,
name|sp
parameter_list|,
name|seg_buf
parameter_list|,
name|segaddr
parameter_list|,
name|psegaddr
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|BLOCK_INFO
modifier|*
name|bip
decl_stmt|;
comment|/* Block info array */
name|int
modifier|*
name|countp
decl_stmt|;
comment|/* IN/OUT: number of blocks in array */
name|SEGSUM
modifier|*
name|sp
decl_stmt|;
comment|/* segment summmary pointer */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* buffer containing segment */
name|daddr_t
name|segaddr
decl_stmt|;
comment|/* address of this segment */
name|daddr_t
name|psegaddr
decl_stmt|;
comment|/* address of this partial segment */
block|{
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
name|caddr_t
name|bp
decl_stmt|;
name|daddr_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|iaddrp
decl_stmt|;
name|int
name|db_per_block
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_long
name|page_size
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"FILE INFOS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_per_block
operator|=
name|fsbtodb
argument_list|(
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|page_size
operator|=
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_bsize
expr_stmt|;
name|bp
operator|=
name|seg_buf
operator|+
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|psegaddr
operator|-
name|segaddr
argument_list|)
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|bip
operator|+=
operator|*
name|countp
expr_stmt|;
name|psegaddr
operator|+=
name|bytetoda
argument_list|(
name|fsp
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|iaddrp
operator|=
operator|(
name|daddr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sp
operator|+
name|LFS_SUMMARY_SIZE
operator|)
expr_stmt|;
operator|--
name|iaddrp
expr_stmt|;
for|for
control|(
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
name|sp
operator|+
literal|1
operator|)
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|ss_nfinfo
condition|;
operator|++
name|i
operator|,
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
operator|(
operator|&
name|fip
operator|->
name|fi_blocks
index|[
name|fip
operator|->
name|fi_nblocks
index|]
operator|)
control|)
block|{
name|ifp
operator|=
name|IFILE_ENTRY
argument_list|(
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|,
name|fsp
operator|->
name|fi_ifilep
argument_list|,
name|fip
operator|->
name|fi_ino
argument_list|)
expr_stmt|;
name|PRINT_FINFO
argument_list|(
name|fip
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_version
operator|>
name|fip
operator|->
name|fi_version
condition|)
continue|continue;
name|dp
operator|=
operator|&
operator|(
name|fip
operator|->
name|fi_blocks
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fip
operator|->
name|fi_nblocks
condition|;
name|j
operator|++
operator|,
name|dp
operator|++
control|)
block|{
while|while
condition|(
name|psegaddr
operator|==
operator|*
name|iaddrp
condition|)
block|{
name|psegaddr
operator|+=
name|db_per_block
expr_stmt|;
name|bp
operator|+=
name|page_size
expr_stmt|;
operator|--
name|iaddrp
expr_stmt|;
block|}
name|bip
operator|->
name|bi_inode
operator|=
name|fip
operator|->
name|fi_ino
expr_stmt|;
name|bip
operator|->
name|bi_lbn
operator|=
operator|*
name|dp
expr_stmt|;
name|bip
operator|->
name|bi_daddr
operator|=
name|psegaddr
expr_stmt|;
name|bip
operator|->
name|bi_segcreate
operator|=
call|(
name|time_t
call|)
argument_list|(
name|sp
operator|->
name|ss_create
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bi_bp
operator|=
name|bp
expr_stmt|;
name|bip
operator|->
name|bi_version
operator|=
name|ifp
operator|->
name|if_version
expr_stmt|;
name|psegaddr
operator|+=
name|db_per_block
expr_stmt|;
name|bp
operator|+=
name|page_size
expr_stmt|;
operator|++
name|bip
expr_stmt|;
operator|++
operator|(
operator|*
name|countp
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * For a particular segment summary, reads the inode blocks and adds  * INODE_INFO structures to the array.  Returns the number of inodes  * actually added.  */
end_comment

begin_function
name|void
name|add_inodes
parameter_list|(
name|fsp
parameter_list|,
name|bip
parameter_list|,
name|countp
parameter_list|,
name|sp
parameter_list|,
name|seg_buf
parameter_list|,
name|seg_addr
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|BLOCK_INFO
modifier|*
name|bip
decl_stmt|;
comment|/* block info array */
name|int
modifier|*
name|countp
decl_stmt|;
comment|/* pointer to current number of inodes */
name|SEGSUM
modifier|*
name|sp
decl_stmt|;
comment|/* segsum pointer */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* the buffer containing the segment's data */
name|daddr_t
name|seg_addr
decl_stmt|;
comment|/* disk address of seg_buf */
block|{
name|struct
name|dinode
modifier|*
name|di
decl_stmt|;
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|IFILE
modifier|*
name|ifp
decl_stmt|;
name|BLOCK_INFO
modifier|*
name|bp
decl_stmt|;
name|daddr_t
modifier|*
name|daddrp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|ss_ninos
operator|<=
literal|0
condition|)
return|return;
name|bp
operator|=
name|bip
operator|+
operator|*
name|countp
expr_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"INODES:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|daddrp
operator|=
operator|(
name|daddr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sp
operator|+
name|LFS_SUMMARY_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|ss_ninos
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|daddrp
expr_stmt|;
name|di
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
operator|(
name|seg_buf
operator|+
operator|(
operator|(
operator|*
name|daddrp
operator|-
name|seg_addr
operator|)
operator|<<
name|fsp
operator|->
name|fi_daddr_shift
operator|)
operator|)
expr_stmt|;
block|}
else|else
operator|++
name|di
expr_stmt|;
name|inum
operator|=
name|di
operator|->
name|di_inumber
expr_stmt|;
name|bp
operator|->
name|bi_lbn
operator|=
name|LFS_UNUSED_LBN
expr_stmt|;
name|bp
operator|->
name|bi_inode
operator|=
name|inum
expr_stmt|;
name|bp
operator|->
name|bi_daddr
operator|=
operator|*
name|daddrp
expr_stmt|;
name|bp
operator|->
name|bi_bp
operator|=
name|di
expr_stmt|;
name|bp
operator|->
name|bi_segcreate
operator|=
name|sp
operator|->
name|ss_create
expr_stmt|;
if|if
condition|(
name|inum
operator|==
name|LFS_IFILE_INUM
condition|)
block|{
name|bp
operator|->
name|bi_version
operator|=
literal|1
expr_stmt|;
comment|/* Ifile version should be 1 */
name|bp
operator|++
expr_stmt|;
operator|++
operator|(
operator|*
name|countp
operator|)
expr_stmt|;
name|PRINT_INODE
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|fsp
operator|->
name|fi_ifilep
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|PRINT_INODE
argument_list|(
name|ifp
operator|->
name|if_daddr
operator|==
operator|*
name|daddrp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bi_version
operator|=
name|ifp
operator|->
name|if_version
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_daddr
operator|==
operator|*
name|daddrp
condition|)
block|{
name|bp
operator|++
expr_stmt|;
operator|++
operator|(
operator|*
name|countp
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Checks the summary checksum and the data checksum to determine if the  * segment is valid or not.  Returns the size of the partial segment if it  * is valid, * and 0 otherwise.  Use dump_summary to figure out size of the  * the partial as well as whether or not the checksum is valid.  */
end_comment

begin_function
name|int
name|pseg_valid
parameter_list|(
name|fsp
parameter_list|,
name|ssp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
comment|/* pointer to segment summary block */
block|{
name|caddr_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nblocks
decl_stmt|;
name|u_long
modifier|*
name|datap
decl_stmt|;
if|if
condition|(
operator|(
name|nblocks
operator|=
name|dump_summary
argument_list|(
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|,
name|ssp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|nblocks
operator|>
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_ssize
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* check data/inode block(s) checksum too */
name|datap
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|ssp
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
operator|++
name|i
control|)
block|{
name|datap
index|[
name|i
index|]
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_bsize
expr_stmt|;
block|}
if|if
condition|(
name|cksum
argument_list|(
operator|(
name|void
operator|*
operator|)
name|datap
argument_list|,
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
operator|!=
name|ssp
operator|->
name|ss_datasum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|nblocks
operator|)
return|;
block|}
end_function

begin_comment
comment|/* #define MMAP_SEGMENT */
end_comment

begin_comment
comment|/*  * read a segment into a memory buffer  */
end_comment

begin_function
name|int
name|mmap_segment
parameter_list|(
name|fsp
parameter_list|,
name|segment
parameter_list|,
name|segbuf
parameter_list|,
name|use_mmap
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|int
name|segment
decl_stmt|;
comment|/* segment number */
name|caddr_t
modifier|*
name|segbuf
decl_stmt|;
comment|/* pointer to buffer area */
name|int
name|use_mmap
decl_stmt|;
comment|/* mmap instead of read */
block|{
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|int
name|fid
decl_stmt|;
comment|/* fildes for file system device */
name|daddr_t
name|seg_daddr
decl_stmt|;
comment|/* base disk address of segment */
name|off_t
name|seg_byte
decl_stmt|;
name|size_t
name|ssize
decl_stmt|;
name|char
name|mntfromname
index|[
name|MNAMELEN
operator|+
literal|2
index|]
decl_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
comment|/* get the disk address of the beginning of the segment */
name|seg_daddr
operator|=
name|sntoda
argument_list|(
name|lfsp
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|seg_byte
operator|=
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|seg_daddr
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|seg_size
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mntfromname
argument_list|,
literal|"/dev/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mntfromname
argument_list|,
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntfromname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|mntfromname
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment: bad open"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|use_mmap
condition|)
block|{
operator|*
name|segbuf
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fid
argument_list|,
name|seg_byte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|segbuf
operator|==
name|MAP_FAILED
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment: mmap failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"mmap_segment\tseg_daddr: %lu\tseg_size: %lu\tseg_offset: %qu\n"
argument_list|,
name|seg_daddr
argument_list|,
name|ssize
argument_list|,
name|seg_byte
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* malloc the space for the buffer */
operator|*
name|segbuf
operator|=
name|malloc
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|segbuf
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment: malloc failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* read the segment data into the buffer */
if|if
condition|(
name|lseek
argument_list|(
name|fid
argument_list|,
name|seg_byte
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|seg_byte
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment: bad lseek"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|segbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fid
argument_list|,
operator|*
name|segbuf
argument_list|,
name|ssize
argument_list|)
operator|!=
name|ssize
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment: bad read"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|segbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|munmap_segment
parameter_list|(
name|fsp
parameter_list|,
name|seg_buf
parameter_list|,
name|use_mmap
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* pointer to buffer area */
name|int
name|use_mmap
decl_stmt|;
comment|/* mmap instead of read/write */
block|{
if|if
condition|(
name|use_mmap
condition|)
name|munmap
argument_list|(
name|seg_buf
argument_list|,
name|seg_size
argument_list|(
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|seg_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * USEFUL DEBUGGING TOOLS:  */
end_comment

begin_function
name|void
name|print_SEGSUM
parameter_list|(
name|lfsp
parameter_list|,
name|p
parameter_list|)
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|SEGSUM
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
operator|(
name|void
operator|)
name|dump_summary
argument_list|(
name|lfsp
argument_list|,
name|p
argument_list|,
name|DUMP_ALL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bi_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
specifier|const
name|BLOCK_INFO
modifier|*
name|ba
decl_stmt|,
modifier|*
name|bb
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|ba
operator|=
name|a
expr_stmt|;
name|bb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|diff
operator|=
call|(
name|int
call|)
argument_list|(
name|ba
operator|->
name|bi_inode
operator|-
name|bb
operator|->
name|bi_inode
argument_list|)
condition|)
return|return
operator|(
name|diff
operator|)
return|;
if|if
condition|(
name|diff
operator|=
call|(
name|int
call|)
argument_list|(
name|ba
operator|->
name|bi_lbn
operator|-
name|bb
operator|->
name|bi_lbn
argument_list|)
condition|)
block|{
if|if
condition|(
name|ba
operator|->
name|bi_lbn
operator|==
name|LFS_UNUSED_LBN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|bb
operator|->
name|bi_lbn
operator|==
name|LFS_UNUSED_LBN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ba
operator|->
name|bi_lbn
operator|<
literal|0
operator|&&
name|bb
operator|->
name|bi_lbn
operator|>=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|bb
operator|->
name|bi_lbn
operator|<
literal|0
operator|&&
name|ba
operator|->
name|bi_lbn
operator|>=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|diff
operator|)
return|;
block|}
if|if
condition|(
name|diff
operator|=
call|(
name|int
call|)
argument_list|(
name|ba
operator|->
name|bi_segcreate
operator|-
name|bb
operator|->
name|bi_segcreate
argument_list|)
condition|)
return|return
operator|(
name|diff
operator|)
return|;
name|diff
operator|=
call|(
name|int
call|)
argument_list|(
name|ba
operator|->
name|bi_daddr
operator|-
name|bb
operator|->
name|bi_daddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bi_toss
parameter_list|(
name|dummy
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|dummy
decl_stmt|;
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
specifier|const
name|BLOCK_INFO
modifier|*
name|ba
decl_stmt|,
modifier|*
name|bb
decl_stmt|;
name|ba
operator|=
name|a
expr_stmt|;
name|bb
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|ba
operator|->
name|bi_inode
operator|==
name|bb
operator|->
name|bi_inode
operator|&&
name|ba
operator|->
name|bi_lbn
operator|==
name|bb
operator|->
name|bi_lbn
operator|)
return|;
block|}
end_function

begin_function_decl
name|void
name|toss
parameter_list|(
name|p
parameter_list|,
name|nump
parameter_list|,
name|size
parameter_list|,
name|dotoss
parameter_list|,
name|client
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|nump
decl_stmt|;
name|size_t
name|size
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*dotoss
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|client
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
operator|*
name|nump
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
operator|*
name|nump
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
block|{
name|p1
operator|=
name|p
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|dotoss
argument_list|(
name|client
argument_list|,
name|p
argument_list|,
name|p1
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
name|p
argument_list|,
name|p1
argument_list|,
name|i
operator|*
name|size
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|nump
operator|)
expr_stmt|;
block|}
else|else
name|p
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_block

end_unit

