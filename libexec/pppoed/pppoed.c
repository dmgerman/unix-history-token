begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2001 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netgraph.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ether.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pppoe.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NOKLDLOAD
end_ifndef

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|DEFAULT_EXEC_PREFIX
value|"exec /usr/sbin/ppp -direct "
end_define

begin_define
define|#
directive|define
name|HISMACADDR
value|"HISMACADDR"
end_define

begin_define
define|#
directive|define
name|SESSION_ID
value|"SESSION_ID"
end_define

begin_function_decl
specifier|static
name|void
name|nglogx
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|ReceivedSignal
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-Fd] [-P pidfile] [-a name] [-e exec | -l label]"
literal|" [-n ngdebug] [-p provider] interface\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Farewell
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ReceivedSignal
operator|=
name|sig
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ConfigureNode
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
specifier|const
name|char
modifier|*
name|provider
parameter_list|,
name|int
name|cs
parameter_list|,
name|int
name|ds
parameter_list|,
name|int
name|debug
parameter_list|,
name|struct
name|ngm_connect
modifier|*
name|ngc
parameter_list|)
block|{
comment|/*    * We're going to do this with the passed `ds'& `cs' descriptors:    *    * .---------.    * |  ether  |    * |<iface> |    * `---------'    *  (orphan)                                     ds    cs    *     |                                         |     |    *     |                                         |     |    * (ethernet)                                    |     |    * .---------.                                .-----------.    * |  pppoe  |                                |  socket   |    * |<iface> |(pppoe-<pid>)<---->(pppoe-<pid>)|<unnamed> |    * `---------                                 `-----------'    * (exec-<pid>)    *     ^                .-----------.      .-------------.    *     |                |   socket  |      | ppp -direct |    *     `--->(exec-<pid>)|<unnamed> |--fd--|  provider   |    *                      `-----------'      `-------------'    *    * where there are potentially many ppp processes running off of the    * same PPPoE node.    * The exec-<pid> hook isn't made 'till we Spawn().    */
name|char
modifier|*
name|epath
decl_stmt|,
modifier|*
name|spath
decl_stmt|;
name|struct
name|ngpppoe_init_data
modifier|*
name|data
decl_stmt|;
specifier|const
name|struct
name|hooklist
modifier|*
name|hlist
decl_stmt|;
specifier|const
name|struct
name|nodeinfo
modifier|*
name|ninfo
decl_stmt|;
specifier|const
name|struct
name|linkinfo
modifier|*
name|nlink
decl_stmt|;
name|struct
name|ngm_mkpeer
name|mkp
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
decl_stmt|;
name|u_char
name|rbuf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|f
decl_stmt|,
name|plen
decl_stmt|;
comment|/*    * Ask for a list of hooks attached to the "ether" node.  This node should    * magically exist as a way of hooking stuff onto an ethernet device    */
name|epath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|iface
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|epath
argument_list|,
literal|"%s:"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending NGM_LISTHOOKS to %s\n"
argument_list|,
name|epath
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
name|epath
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_LISTHOOKS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Cannot send a netgraph message: Invalid interface\n"
argument_list|,
name|epath
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Cannot send a netgraph message: %s\n"
argument_list|,
name|epath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
comment|/* Get our list back */
name|resp
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rbuf
expr_stmt|;
if|if
condition|(
name|NgRecvMsg
argument_list|(
name|cs
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
name|rbuf
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot get netgraph response"
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
name|hlist
operator|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ninfo
operator|=
operator|&
name|hlist
operator|->
name|nodeinfo
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got reply from id [%x]: Type %s with %d hooks\n"
argument_list|,
name|ninfo
operator|->
name|id
argument_list|,
name|ninfo
operator|->
name|type
argument_list|,
name|ninfo
operator|->
name|hooks
argument_list|)
expr_stmt|;
comment|/* Make sure we've got the right type of node */
if|if
condition|(
name|strncmp
argument_list|(
name|ninfo
operator|->
name|type
argument_list|,
name|NG_ETHER_NODE_TYPE
argument_list|,
sizeof|sizeof
name|NG_ETHER_NODE_TYPE
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Unexpected node type ``%s'' (wanted ``"
name|NG_ETHER_NODE_TYPE
literal|"'')\n"
argument_list|,
name|epath
argument_list|,
name|ninfo
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
comment|/* look for a hook already attached.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ninfo
operator|->
name|hooks
condition|;
name|f
operator|++
control|)
block|{
name|nlink
operator|=
operator|&
name|hlist
operator|->
name|link
index|[
name|f
index|]
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Got [%x]:%s -> [%x]:%s\n"
argument_list|,
name|ninfo
operator|->
name|id
argument_list|,
name|nlink
operator|->
name|ourhook
argument_list|,
name|nlink
operator|->
name|nodeinfo
operator|.
name|id
argument_list|,
name|nlink
operator|->
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|ourhook
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|ourhook
argument_list|,
name|NG_ETHER_HOOK_DIVERT
argument_list|)
condition|)
block|{
comment|/*        * Something is using the data coming out of this `ether' node.        * If it's a PPPoE node, we use that node, otherwise we complain that        * someone else is using the node.        */
if|if
condition|(
name|strcmp
argument_list|(
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|,
name|NG_PPPOE_NODE_TYPE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Node type %s is currently active\n"
argument_list|,
name|epath
argument_list|,
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
name|ninfo
operator|->
name|hooks
condition|)
block|{
comment|/*      * Create a new PPPoE node connected to the `ether' node using      * the magic `orphan' and `ethernet' hooks      */
name|snprintf
argument_list|(
name|mkp
operator|.
name|type
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|type
argument_list|,
literal|"%s"
argument_list|,
name|NG_PPPOE_NODE_TYPE
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|ourhook
argument_list|,
literal|"%s"
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|peerhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|peerhook
argument_list|,
literal|"%s"
argument_list|,
name|NG_PPPOE_HOOK_ETHERNET
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Send MKPEER: %s%s -> [type %s]:%s\n"
argument_list|,
name|epath
argument_list|,
name|mkp
operator|.
name|ourhook
argument_list|,
name|mkp
operator|.
name|type
argument_list|,
name|mkp
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
name|epath
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_MKPEER
argument_list|,
operator|&
name|mkp
argument_list|,
sizeof|sizeof
name|mkp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Cannot create a peer PPPoE node: %s\n"
argument_list|,
name|epath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
block|}
comment|/* Connect the PPPoE node to our socket node.  */
name|snprintf
argument_list|(
name|ngc
operator|->
name|path
argument_list|,
sizeof|sizeof
name|ngc
operator|->
name|path
argument_list|,
literal|"%s%s"
argument_list|,
name|epath
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ngc
operator|->
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|->
name|ourhook
argument_list|,
literal|"pppoe-%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ngc
operator|->
name|peerhook
argument_list|,
name|ngc
operator|->
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|->
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
literal|".:"
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_CONNECT
argument_list|,
name|ngc
argument_list|,
sizeof|sizeof
expr|*
name|ngc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot CONNECT PPPoE and socket nodes"
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|provider
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|*
name|data
operator|+
name|plen
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|data
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|data
operator|->
name|hook
argument_list|,
literal|"%s"
argument_list|,
name|ngc
operator|->
name|peerhook
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|provider
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|data
operator|->
name|data_len
operator|=
name|plen
expr_stmt|;
name|spath
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ngc
operator|->
name|peerhook
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|spath
argument_list|,
literal|".:"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|spath
operator|+
literal|2
argument_list|,
name|ngc
operator|->
name|ourhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|provider
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending PPPOE_LISTEN to %s, provider %s\n"
argument_list|,
name|spath
argument_list|,
name|provider
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending PPPOE_LISTEN to %s\n"
argument_list|,
name|spath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
name|spath
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_LISTEN
argument_list|,
name|data
argument_list|,
sizeof|sizeof
expr|*
name|data
operator|+
name|plen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot LISTEN on netgraph node: %s\n"
argument_list|,
name|spath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Spawn
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
specifier|const
name|char
modifier|*
name|acname
parameter_list|,
specifier|const
name|char
modifier|*
name|provider
parameter_list|,
specifier|const
name|char
modifier|*
name|exec
parameter_list|,
name|struct
name|ngm_connect
name|ngc
parameter_list|,
name|int
name|cs
parameter_list|,
name|int
name|ds
parameter_list|,
name|void
modifier|*
name|request
parameter_list|,
name|int
name|sz
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|char
name|msgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
index|]
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rep
init|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msgbuf
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
init|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
operator|(
name|msgbuf
operator|+
sizeof|sizeof
expr|*
name|rep
operator|)
decl_stmt|;
name|struct
name|ngpppoe_init_data
modifier|*
name|data
decl_stmt|;
name|char
name|env
index|[
literal|18
index|]
decl_stmt|,
name|unknown
index|[
literal|14
index|]
decl_stmt|,
name|sessionid
index|[
literal|5
index|]
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|unsigned
name|char
modifier|*
name|macaddr
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|slen
decl_stmt|;
switch|switch
condition|(
operator|(
name|ret
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork: %m"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
name|_exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/* Create a new socket node */
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Creating a new socket node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgMkSockNode
argument_list|(
name|NULL
argument_list|,
operator|&
name|cs
argument_list|,
operator|&
name|ds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot create netgraph socket node: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
comment|/* Connect the PPPoE node to our new socket node.  */
name|snprintf
argument_list|(
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|ourhook
argument_list|,
literal|"exec-%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ngc
operator|.
name|peerhook
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Sending CONNECT from .:%s -> %s.%s"
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
name|ngc
operator|.
name|path
argument_list|,
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
literal|".:"
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_CONNECT
argument_list|,
operator|&
name|ngc
argument_list|,
sizeof|sizeof
name|ngc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot CONNECT PPPoE and socket nodes: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/*        * If we tell the socket node not to LINGER, it will go away when        * the last hook is removed.        */
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Sending NGM_SOCK_CMD_NOLINGER to socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
literal|".:"
argument_list|,
name|NGM_SOCKET_COOKIE
argument_list|,
name|NGM_SOCK_CMD_NOLINGER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot send NGM_SOCK_CMD_NOLINGER: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* Put the PPPoE node into OFFER mode */
name|slen
operator|=
name|strlen
argument_list|(
name|acname
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|*
name|data
operator|+
name|slen
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|data
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|data
operator|->
name|hook
argument_list|,
literal|"%s"
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|acname
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|data
operator|->
name|data_len
operator|=
name|slen
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ngc
operator|.
name|ourhook
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
literal|".:"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
operator|+
literal|2
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Offering to %s as access concentrator %s"
argument_list|,
name|path
argument_list|,
name|acname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_OFFER
argument_list|,
name|data
argument_list|,
sizeof|sizeof
expr|*
name|data
operator|+
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: Cannot OFFER on netgraph node: %m"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a provider code, set it */
if|if
condition|(
name|provider
condition|)
block|{
name|slen
operator|=
name|strlen
argument_list|(
name|provider
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|*
name|data
operator|+
name|slen
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|data
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|data
operator|->
name|hook
argument_list|,
literal|"%s"
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|provider
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|data
operator|->
name|data_len
operator|=
name|slen
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"adding to %s as offered service %s"
argument_list|,
name|path
argument_list|,
name|acname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_SERVICE
argument_list|,
name|data
argument_list|,
sizeof|sizeof
expr|*
name|data
operator|+
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: Cannot add service on netgraph node: %m"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put the peer's MAC address in the environment */
if|if
condition|(
name|sz
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|macaddr
operator|=
operator|(
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|request
operator|)
operator|->
name|ether_shost
expr_stmt|;
name|snprintf
argument_list|(
name|env
argument_list|,
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|,
literal|"%x:%x:%x:%x:%x:%x"
argument_list|,
name|macaddr
index|[
literal|0
index|]
argument_list|,
name|macaddr
index|[
literal|1
index|]
argument_list|,
name|macaddr
index|[
literal|2
index|]
argument_list|,
name|macaddr
index|[
literal|3
index|]
argument_list|,
name|macaddr
index|[
literal|4
index|]
argument_list|,
name|macaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|setenv
argument_list|(
name|HISMACADDR
argument_list|,
name|env
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"setenv: cannot set %s: %m"
argument_list|,
name|HISMACADDR
argument_list|)
expr_stmt|;
block|}
comment|/* And send our request data to the waiting node */
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Sending original request to %s (%d bytes)"
argument_list|,
name|path
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendData
argument_list|(
name|ds
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
name|request
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot send original request to %s: %m"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* Then wait for a success indication */
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Waiting for a SUCCESS reply %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|NgRecvMsg
argument_list|(
name|cs
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
name|msgbuf
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Cannot receive a message: %m"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* The socket has been closed */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: Client timed out"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|header
operator|.
name|version
operator|!=
name|NG_VERSION
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%ld: Unexpected netgraph version, expected %ld"
argument_list|,
operator|(
name|long
operator|)
name|rep
operator|->
name|header
operator|.
name|version
argument_list|,
operator|(
name|long
operator|)
name|NG_VERSION
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_PROTOCOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|header
operator|.
name|typecookie
operator|!=
name|NGM_PPPOE_COOKIE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%ld: Unexpected netgraph cookie, expected %ld"
argument_list|,
operator|(
name|long
operator|)
name|rep
operator|->
name|header
operator|.
name|typecookie
argument_list|,
operator|(
name|long
operator|)
name|NGM_PPPOE_COOKIE
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|rep
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_SET_FLAG
case|:
name|msg
operator|=
literal|"SET_FLAG"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_CONNECT
case|:
name|msg
operator|=
literal|"CONNECT"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_LISTEN
case|:
name|msg
operator|=
literal|"LISTEN"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_OFFER
case|:
name|msg
operator|=
literal|"OFFER"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SUCCESS
case|:
name|msg
operator|=
literal|"SUCCESS"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_FAIL
case|:
name|msg
operator|=
literal|"FAIL"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_CLOSE
case|:
name|msg
operator|=
literal|"CLOSE"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_GET_STATUS
case|:
name|msg
operator|=
literal|"GET_STATUS"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_ACNAME
case|:
name|msg
operator|=
literal|"ACNAME"
expr_stmt|;
if|if
condition|(
name|setenv
argument_list|(
literal|"ACNAME"
argument_list|,
name|sts
operator|->
name|hook
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"setenv: cannot set ACNAME=%s: %m"
argument_list|,
name|sts
operator|->
name|hook
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SESSIONID
case|:
name|msg
operator|=
literal|"SESSIONID"
expr_stmt|;
name|snprintf
argument_list|(
name|sessionid
argument_list|,
sizeof|sizeof
name|sessionid
argument_list|,
literal|"%04x"
argument_list|,
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|sts
argument_list|)
expr_stmt|;
if|if
condition|(
name|setenv
argument_list|(
literal|"SESSIONID"
argument_list|,
name|sessionid
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"setenv: cannot set SESSIONID=%s: %m"
argument_list|,
name|sessionid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|unknown
argument_list|,
sizeof|sizeof
name|unknown
argument_list|,
literal|"<%d>"
argument_list|,
operator|(
name|int
operator|)
name|rep
operator|->
name|header
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|msg
operator|=
name|unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|rep
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_FAIL
case|:
case|case
name|NGM_PPPOE_CLOSE
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Received NGM_PPPOE_%s (hook \"%s\")"
argument_list|,
name|msg
argument_list|,
name|sts
operator|->
name|hook
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Received NGM_PPPOE_%s (hook \"%s\")"
argument_list|,
name|msg
argument_list|,
name|sts
operator|->
name|hook
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rep
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPPOE_SUCCESS
condition|)
do|;
name|dup2
argument_list|(
name|ds
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|ds
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Executing: %s"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|_PATH_BSHELL
argument_list|,
name|_PATH_BSHELL
argument_list|,
literal|"-c"
argument_list|,
name|exec
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"execlp failed: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
default|default:
name|wait
argument_list|(
operator|&
name|ret
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Second fork failed: %m"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOKLDLOAD
end_ifndef

begin_function
specifier|static
name|int
name|LoadModules
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|module
index|[]
init|=
block|{
literal|"netgraph"
block|,
literal|"ng_socket"
block|,
literal|"ng_ether"
block|,
literal|"ng_pppoe"
block|}
decl_stmt|;
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
sizeof|sizeof
name|module
operator|/
sizeof|sizeof
expr|*
name|module
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|modfind
argument_list|(
name|module
index|[
name|f
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|kldload
argument_list|(
name|module
index|[
name|f
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kldload: %s: %s\n"
argument_list|,
name|module
index|[
name|f
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|nglog
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|nfmt
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|snprintf
argument_list|(
name|nfmt
argument_list|,
sizeof|sizeof
name|nfmt
argument_list|,
literal|"%s: %s"
argument_list|,
name|fmt
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_INFO
argument_list|,
name|nfmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nglogx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_INFO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|,
modifier|*
name|exec
decl_stmt|,
name|rhook
index|[
name|NG_HOOKSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|response
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|,
modifier|*
name|prog
decl_stmt|,
modifier|*
name|provider
decl_stmt|,
modifier|*
name|acname
decl_stmt|;
name|struct
name|ngm_connect
name|ngc
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|cs
decl_stmt|,
name|ds
decl_stmt|,
name|ret
decl_stmt|,
name|optF
decl_stmt|,
name|optd
decl_stmt|,
name|optn
decl_stmt|,
name|sz
decl_stmt|,
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|pidfile
decl_stmt|;
name|prog
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|prog
operator|=
name|prog
condition|?
name|prog
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|pidfile
operator|=
name|NULL
expr_stmt|;
name|exec
operator|=
name|NULL
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
name|acname
operator|=
name|NULL
expr_stmt|;
name|provider
operator|=
literal|""
expr_stmt|;
name|optF
operator|=
name|optd
operator|=
name|optn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"FP:a:de:l:n:p:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'F'
case|:
name|optF
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pidfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|acname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|optd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|exec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|label
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|optn
operator|=
literal|1
expr_stmt|;
name|NgSetDebug
argument_list|(
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|provider
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
return|return
name|usage
argument_list|(
name|prog
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|optind
operator|>=
name|argc
operator|||
name|optind
operator|+
literal|2
operator|<
name|argc
condition|)
return|return
name|usage
argument_list|(
name|prog
argument_list|)
return|;
if|if
condition|(
name|exec
operator|!=
name|NULL
operator|&&
name|label
operator|!=
name|NULL
condition|)
return|return
name|usage
argument_list|(
name|prog
argument_list|)
return|;
if|if
condition|(
name|exec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|label
operator|=
name|provider
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Either a provider, a label or an exec command"
literal|" must be given\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
name|usage
argument_list|(
name|prog
argument_list|)
return|;
block|}
name|exec
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|DEFAULT_EXEC_PREFIX
operator|+
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot allocate %d bytes\n"
argument_list|,
name|prog
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|DEFAULT_EXEC_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|strcpy
argument_list|(
name|exec
argument_list|,
name|DEFAULT_EXEC_PREFIX
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|exec
operator|+
sizeof|sizeof
name|DEFAULT_EXEC_PREFIX
operator|-
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acname
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
argument_list|)
condition|)
name|strcpy
argument_list|(
name|hostname
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dot
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
name|acname
operator|=
name|hostname
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NOKLDLOAD
if|if
condition|(
operator|!
name|LoadModules
argument_list|()
condition|)
return|return
name|EX_UNAVAILABLE
return|;
endif|#
directive|endif
comment|/* Create a socket node */
if|if
condition|(
name|NgMkSockNode
argument_list|(
name|NULL
argument_list|,
operator|&
name|cs
argument_list|,
operator|&
name|ds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot create netgraph socket node"
argument_list|)
expr_stmt|;
return|return
name|EX_CANTCREAT
return|;
block|}
comment|/* Connect it up (and fill in `ngc') */
if|if
condition|(
operator|(
name|ret
operator|=
name|ConfigureNode
argument_list|(
name|prog
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|provider
argument_list|,
name|cs
argument_list|,
name|ds
argument_list|,
name|optd
argument_list|,
operator|&
name|ngc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|optF
operator|&&
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"daemon()"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
if|if
condition|(
name|pidfile
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|EX_CANTCREAT
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|openlog
argument_list|(
name|prog
argument_list|,
name|LOG_PID
operator||
operator|(
name|optF
condition|?
name|LOG_PERROR
else|:
literal|0
operator|)
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optF
operator|&&
name|optn
condition|)
name|NgSetErrLog
argument_list|(
name|nglog
argument_list|,
name|nglogx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|act
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|Farewell
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ReceivedSignal
condition|)
block|{
if|if
condition|(
operator|*
name|provider
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening as provider %s"
argument_list|,
name|provider
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sz
operator|=
name|NgRecvData
argument_list|(
name|ds
argument_list|,
name|response
argument_list|,
sizeof|sizeof
name|response
argument_list|,
name|rhook
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NgRecvData: %m"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NgRecvData: socket closed"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|optd
condition|)
block|{
name|char
modifier|*
name|dbuf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|dbuf
operator|=
name|alloca
argument_list|(
name|sz
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|sz
condition|;
name|f
operator|++
operator|,
name|ptr
operator|+=
literal|2
control|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|u_char
operator|)
name|response
index|[
name|f
index|]
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got %d bytes of data: %s"
argument_list|,
name|sz
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
break|break;
block|}
name|Spawn
argument_list|(
name|prog
argument_list|,
name|acname
argument_list|,
name|provider
argument_list|,
name|exec
argument_list|,
name|ngc
argument_list|,
name|cs
argument_list|,
name|ds
argument_list|,
name|response
argument_list|,
name|sz
argument_list|,
name|optd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pidfile
condition|)
name|remove
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReceivedSignal
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Received signal %d, exiting"
argument_list|,
name|ReceivedSignal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|ReceivedSignal
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|ReceivedSignal
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|ret
operator|=
operator|-
name|ReceivedSignal
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

