begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: var.c,v 1.213 2017/02/01 18:39:27 sjg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: var.c,v 1.213 2017/02/01 18:39:27 sjg Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)var.c	8.3 (Berkeley) 3/19/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: var.c,v 1.213 2017/02/01 18:39:27 sjg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * var.c --  *	Variable-handling functions  *  * Interface:  *	Var_Set		    Set the value of a variable in the given  *			    context. The variable is created if it doesn't  *			    yet exist. The value and variable name need not  *			    be preserved.  *  *	Var_Append	    Append more characters to an existing variable  *			    in the given context. The variable needn't  *			    exist already -- it will be created if it doesn't.  *			    A space is placed between the old value and the  *			    new one.  *  *	Var_Exists	    See if a variable exists.  *  *	Var_Value 	    Return the value of a variable in a context or  *			    NULL if the variable is undefined.  *  *	Var_Subst 	    Substitute named variable, or all variables if  *			    NULL in a string using  *			    the given context as the top-most one. If the  *			    third argument is non-zero, Parse_Error is  *			    called if any variables are undefined.  *  *	Var_Parse 	    Parse a variable expansion from a string and  *			    return the result and the number of characters  *			    consumed.  *  *	Var_Delete	    Delete a variable in a context.  *  *	Var_Init  	    Initialize this module.  *  * Debugging:  *	Var_Dump  	    Print out all variables defined in the given  *			    context.  *  * XXX: There's a lot of duplication in these functions.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"metachar.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|makelevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This lets us tell if we have replaced the original environ  * (which we cannot free).  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|savedEnv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is a harmless return value for Var_Parse that can be used by Var_Subst  * to determine if there was an error in parsing -- easier than returning  * a flag, as things outside this module don't give a hoot.  */
end_comment

begin_decl_stmt
name|char
name|var_Error
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Similar to var_Error, but returned when the 'VARF_UNDEFERR' flag for  * Var_Parse is not set. Why not just use a constant? Well, gcc likes  * to condense identical string instances...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|varNoError
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Traditionally we consume $$ during := like any other expansion.  * Other make's do not.  * This knob allows controlling the behavior.  * FALSE for old behavior.  * TRUE for new compatible.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_DOLLARS
value|".MAKE.SAVE_DOLLARS"
end_define

begin_decl_stmt
specifier|static
name|Boolean
name|save_dollars
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internally, variables are contained in four different contexts.  *	1) the environment. They may not be changed. If an environment  *	    variable is appended-to, the result is placed in the global  *	    context.  *	2) the global context. Variables set in the Makefile are located in  *	    the global context. It is the penultimate context searched when  *	    substituting.  *	3) the command-line context. All variables set on the command line  *	   are placed in this context. They are UNALTERABLE once placed here.  *	4) the local context. Each target has associated with it a context  *	   list. On this list are located the structures describing such  *	   local variables as $(@) and $(*)  * The four contexts are searched in the reverse order from which they are  * listed.  */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_INTERNAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables from make itself */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_GLOBAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables from the makefile */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_CMD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables defined on the command-line */
end_comment

begin_define
define|#
directive|define
name|FIND_CMD
value|0x1
end_define

begin_comment
comment|/* look in VAR_CMD when searching */
end_comment

begin_define
define|#
directive|define
name|FIND_GLOBAL
value|0x2
end_define

begin_comment
comment|/* look in VAR_GLOBAL as well */
end_comment

begin_define
define|#
directive|define
name|FIND_ENV
value|0x4
end_define

begin_comment
comment|/* look in the environment also */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Var
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the variable's name */
name|Buffer
name|val
decl_stmt|;
comment|/* its value */
name|int
name|flags
decl_stmt|;
comment|/* miscellaneous status flags */
define|#
directive|define
name|VAR_IN_USE
value|1
comment|/* Variable's value currently being used. 				     * Used to avoid recursion */
define|#
directive|define
name|VAR_FROM_ENV
value|2
comment|/* Variable comes from the environment */
define|#
directive|define
name|VAR_JUNK
value|4
comment|/* Variable is a junk variable that 				     * should be destroyed when done with 				     * it. Used by Var_Parse for undefined, 				     * modified variables */
define|#
directive|define
name|VAR_KEEP
value|8
comment|/* Variable is VAR_JUNK, but we found 				     * a use for it in some modifier and 				     * the value is therefore valid */
define|#
directive|define
name|VAR_EXPORTED
value|16
comment|/* Variable is exported */
define|#
directive|define
name|VAR_REEXPORT
value|32
comment|/* Indicate if var needs re-export. 				     * This would be true if it contains $'s 				     */
define|#
directive|define
name|VAR_FROM_CMD
value|64
comment|/* Variable came from command line */
block|}
name|Var
typedef|;
end_typedef

begin_comment
comment|/*  * Exporting vars is expensive so skip it if we can  */
end_comment

begin_define
define|#
directive|define
name|VAR_EXPORTED_NONE
value|0
end_define

begin_define
define|#
directive|define
name|VAR_EXPORTED_YES
value|1
end_define

begin_define
define|#
directive|define
name|VAR_EXPORTED_ALL
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|var_exportedVars
init|=
name|VAR_EXPORTED_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We pass this to Var_Export when doing the initial export  * or after updating an exported var.  */
end_comment

begin_define
define|#
directive|define
name|VAR_EXPORT_PARENT
value|1
end_define

begin_comment
comment|/*  * We pass this to Var_Export1 to tell it to leave the value alone.  */
end_comment

begin_define
define|#
directive|define
name|VAR_EXPORT_LITERAL
value|2
end_define

begin_comment
comment|/* Var*Pattern flags */
end_comment

begin_define
define|#
directive|define
name|VAR_SUB_GLOBAL
value|0x01
end_define

begin_comment
comment|/* Apply substitution globally */
end_comment

begin_define
define|#
directive|define
name|VAR_SUB_ONE
value|0x02
end_define

begin_comment
comment|/* Apply substitution to one word */
end_comment

begin_define
define|#
directive|define
name|VAR_SUB_MATCHED
value|0x04
end_define

begin_comment
comment|/* There was a match */
end_comment

begin_define
define|#
directive|define
name|VAR_MATCH_START
value|0x08
end_define

begin_comment
comment|/* Match at start of word */
end_comment

begin_define
define|#
directive|define
name|VAR_MATCH_END
value|0x10
end_define

begin_comment
comment|/* Match at end of word */
end_comment

begin_define
define|#
directive|define
name|VAR_NOSUBST
value|0x20
end_define

begin_comment
comment|/* don't expand vars in VarGetPattern */
end_comment

begin_comment
comment|/* Var_Set flags */
end_comment

begin_define
define|#
directive|define
name|VAR_NO_EXPORT
value|0x01
end_define

begin_comment
comment|/* do not export */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/*      * The following fields are set by Var_Parse() when it      * encounters modifiers that need to keep state for use by      * subsequent modifiers within the same variable expansion.      */
name|Byte
name|varSpace
decl_stmt|;
comment|/* Word separator in expansions */
name|Boolean
name|oneBigWord
decl_stmt|;
comment|/* TRUE if we will treat the variable as a 				 * single big word, even if it contains 				 * embedded spaces (as opposed to the 				 * usual behaviour of treating it as 				 * several space-separated words). */
block|}
name|Var_Parse_State
typedef|;
end_typedef

begin_comment
comment|/* struct passed as 'void *' to VarSubstitute() for ":S/lhs/rhs/",  * to VarSYSVMatch() for ":lhs=rhs". */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|lhs
decl_stmt|;
comment|/* String to match */
name|int
name|leftLen
decl_stmt|;
comment|/* Length of string */
specifier|const
name|char
modifier|*
name|rhs
decl_stmt|;
comment|/* Replacement string (w/&'s removed) */
name|int
name|rightLen
decl_stmt|;
comment|/* Length of replacement */
name|int
name|flags
decl_stmt|;
block|}
name|VarPattern
typedef|;
end_typedef

begin_comment
comment|/* struct passed as 'void *' to VarLoopExpand() for ":@tvar@str@" */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* variable context */
name|char
modifier|*
name|tvar
decl_stmt|;
comment|/* name of temp var */
name|int
name|tvarLen
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to expand */
name|int
name|strLen
decl_stmt|;
name|int
name|errnum
decl_stmt|;
comment|/* errnum for not defined */
block|}
name|VarLoop_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_comment
comment|/* struct passed as 'void *' to VarRESubstitute() for ":C///" */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|regex_t
name|re
decl_stmt|;
name|int
name|nsub
decl_stmt|;
name|regmatch_t
modifier|*
name|matches
decl_stmt|;
name|char
modifier|*
name|replace
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|VarREPattern
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* struct passed to VarSelectWords() for ":[start..end]" */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|start
decl_stmt|;
comment|/* first word to select */
name|int
name|end
decl_stmt|;
comment|/* last word to select */
block|}
name|VarSelectWords_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|Var
modifier|*
name|VarFind
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|GNode
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|VarAdd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|GNode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarHead
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarTail
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarSuffix
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarRoot
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarMatch
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_function_decl
specifier|static
name|Boolean
name|VarSYSVMatch
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|Boolean
name|VarNoMatch
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_function_decl
specifier|static
name|void
name|VarREError
parameter_list|(
name|int
parameter_list|,
name|regex_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarRESubstitute
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|Boolean
name|VarSubstitute
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|VarLoopExpand
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarGetPattern
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|VarPattern
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarQuote
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarHash
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarModify
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Boolean
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarOrder
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|VarUniq
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VarWordCompare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|VarPrintVar
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BROPEN
value|'{'
end_define

begin_define
define|#
directive|define
name|BRCLOSE
value|'}'
end_define

begin_define
define|#
directive|define
name|PROPEN
value|'('
end_define

begin_define
define|#
directive|define
name|PRCLOSE
value|')'
end_define

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarFind --  *	Find the given variable in the given context and any other contexts  *	indicated.  *  * Input:  *	name		name to find  *	ctxt		context in which to find it  *	flags		FIND_GLOBAL set means to look in the  *			VAR_GLOBAL context as well. FIND_CMD set means  *			to look in the VAR_CMD context also. FIND_ENV  *			set means to look in the environment  *  * Results:  *	A pointer to the structure describing the desired variable or  *	NULL if the variable does not exist.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarFind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|var
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
comment|/* 	 * If the variable name begins with a '.', it could very well be one of 	 * the local ones.  We check the name against all the local variables 	 * and substitute the short version in for 'name' if it matches one of 	 * them. 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ALLSRC"
argument_list|)
condition|)
name|name
operator|=
name|ALLSRC
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ARCHIVE"
argument_list|)
condition|)
name|name
operator|=
name|ARCHIVE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".IMPSRC"
argument_list|)
condition|)
name|name
operator|=
name|IMPSRC
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MEMBER"
argument_list|)
condition|)
name|name
operator|=
name|MEMBER
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".OODATE"
argument_list|)
condition|)
name|name
operator|=
name|OODATE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PREFIX"
argument_list|)
condition|)
name|name
operator|=
name|PREFIX
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".TARGET"
argument_list|)
condition|)
name|name
operator|=
name|TARGET
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* for compatibility with gmake */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'^'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|ALLSRC
expr_stmt|;
endif|#
directive|endif
comment|/*      * First look for the variable in the given context. If it's not there,      * look for it in VAR_CMD, VAR_GLOBAL and the environment, in that order,      * depending on the FIND_* flags in 'flags'      */
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_CMD
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_CMD
operator|)
condition|)
block|{
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|VAR_CMD
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkEnvFirst
operator|&&
operator|(
name|var
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_GLOBAL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_INTERNAL
operator|)
condition|)
block|{
comment|/* VAR_INTERNAL is subordinate to VAR_GLOBAL */
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|VAR_INTERNAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|var
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_ENV
operator|)
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|v
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|len
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|VAR_FROM_ENV
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|checkEnvFirst
operator|&&
operator|(
name|flags
operator|&
name|FIND_GLOBAL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_INTERNAL
operator|)
condition|)
block|{
name|var
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|VAR_INTERNAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarFreeEnv  --  *	If the variable is an environment variable, free it  *  * Input:  *	v		the variable  *	destroy		true if the value buffer should be destroyed.  *  * Results:  *	1 if it is an environment variable 0 ow.  *  * Side Effects:  *	The variable is free'ed if it is an environent variable.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarFreeEnv
parameter_list|(
name|Var
modifier|*
name|v
parameter_list|,
name|Boolean
name|destroy
parameter_list|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
operator|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarAdd  --  *	Add a new variable of name name and value val to the given context  *  * Input:  *	name		name of variable to add  *	val		value to set it to  *	ctxt		context in which to set it  *  * Results:  *	None  *  * Side Effects:  *	The new variable is placed at the front of the given context  *	The name and val arguments are duplicated so they may  *	safely be freed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarAdd
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Hash_Entry
modifier|*
name|h
decl_stmt|;
name|v
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|val
condition|?
name|strlen
argument_list|(
name|val
argument_list|)
else|:
literal|0
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|len
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|h
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|h
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
operator|&&
operator|(
name|ctxt
operator|->
name|flags
operator|&
name|INTERNAL
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Delete --  *	Remove a variable from a context.  *  * Results:  *	None.  *  * Side Effects:  *	The Var structure is removed and freed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Delete
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|ln
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
block|}
name|ln
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s:delete %s%s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|ln
condition|?
literal|""
else|:
literal|" (not found)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|name
condition|)
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_EXPORTED
operator|)
condition|)
block|{
name|unsetenv
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|MAKE_EXPORTED
argument_list|,
name|v
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|var_exportedVars
operator|=
name|VAR_EXPORTED_NONE
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|name
operator|!=
name|ln
operator|->
name|name
condition|)
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|Hash_DeleteEntry
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Export a var.  * We ignore make internal variables (those which start with '.')  * Also we jump through some hoops to avoid calling setenv  * more than necessary since it can leak.  * We only manipulate flags of vars if 'parent' is set.  */
end_comment

begin_function
specifier|static
name|int
name|Var_Export1
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
name|tmp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|parent
init|=
operator|(
name|flags
operator|&
name|VAR_EXPORT_PARENT
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
return|return
literal|0
return|;
comment|/* skip internals */
if|if
condition|(
operator|!
name|name
index|[
literal|1
index|]
condition|)
block|{
comment|/* 	 * A single char. 	 * If it is one of the vars that should only appear in 	 * local context, skip it, else we can get Var_Subst 	 * into a loop. 	 */
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
return|return
literal|0
return|;
block|}
block|}
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parent
operator|&&
operator|(
name|v
operator|->
name|flags
operator|&
operator|(
name|VAR_EXPORTED
operator||
name|VAR_REEXPORT
operator|)
operator|)
operator|==
name|VAR_EXPORTED
condition|)
block|{
return|return
literal|0
return|;
comment|/* nothing to do */
block|}
name|val
operator|=
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|VAR_EXPORT_LITERAL
operator|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|val
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
if|if
condition|(
name|parent
condition|)
block|{
comment|/* 	     * Flag this as something we need to re-export. 	     * No point actually exporting it now though, 	     * the child can do it at the last minute. 	     */
name|v
operator|->
name|flags
operator||=
operator|(
name|VAR_EXPORTED
operator||
name|VAR_REEXPORT
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_IN_USE
condition|)
block|{
comment|/* 	     * We recursed while exporting in a child. 	     * This isn't going to end well, just skip it. 	     */
return|return
literal|0
return|;
block|}
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"${%s}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|val
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parent
condition|)
block|{
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_REEXPORT
expr_stmt|;
comment|/* once will do */
block|}
if|if
condition|(
name|parent
operator|||
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_EXPORTED
operator|)
condition|)
block|{
name|setenv
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * This is so Var_Set knows to call Var_Export again...      */
if|if
condition|(
name|parent
condition|)
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_EXPORTED
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called from our children.  */
end_comment

begin_function
name|void
name|Var_ExportVars
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tmp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|Hash_Entry
modifier|*
name|var
decl_stmt|;
name|Hash_Search
name|state
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*      * Several make's support this sort of mechanism for tracking      * recursion - but each uses a different name.      * We allow the makefiles to update MAKELEVEL and ensure      * children see a correctly incremented value.      */
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|makelevel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|MAKE_LEVEL_ENV
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR_EXPORTED_NONE
operator|==
name|var_exportedVars
condition|)
return|return;
if|if
condition|(
name|VAR_EXPORTED_ALL
operator|==
name|var_exportedVars
condition|)
block|{
comment|/* 	 * Ouch! This is crazy... 	 */
for|for
control|(
name|var
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
operator|&
name|state
argument_list|)
init|;
name|var
operator|!=
name|NULL
condition|;
name|var
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|state
argument_list|)
control|)
block|{
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|Var_Export1
argument_list|(
name|v
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*      * We have a number of exported vars,      */
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"${"
name|MAKE_EXPORTED
literal|":O:u}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|as
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|val
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
condition|)
block|{
name|av
operator|=
name|brk_string
argument_list|(
name|val
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|Var_Export1
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when .export is seen or  * .MAKE.EXPORTED is modified.  * It is also called when any exported var is modified.  */
end_comment

begin_function
name|void
name|Var_Export
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|isExport
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|as
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|isExport
operator|&&
operator|(
operator|!
name|str
operator|||
operator|!
name|str
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|var_exportedVars
operator|=
name|VAR_EXPORTED_ALL
expr_stmt|;
comment|/* use with caution! */
return|return;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"-env"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"-literal"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|+=
literal|8
expr_stmt|;
name|flags
operator||=
name|VAR_EXPORT_LITERAL
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|VAR_EXPORT_PARENT
expr_stmt|;
block|}
name|val
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|str
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
condition|)
block|{
name|av
operator|=
name|brk_string
argument_list|(
name|val
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|av
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|name
index|[
literal|1
index|]
condition|)
block|{
comment|/* 		 * A single char. 		 * If it is one of the vars that should only appear in 		 * local context, skip it, else we can get Var_Subst 		 * into a loop. 		 */
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
continue|continue;
block|}
block|}
if|if
condition|(
name|Var_Export1
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|VAR_EXPORTED_ALL
operator|!=
name|var_exportedVars
condition|)
name|var_exportedVars
operator|=
name|VAR_EXPORTED_YES
expr_stmt|;
if|if
condition|(
name|isExport
operator|&&
operator|(
name|flags
operator|&
name|VAR_EXPORT_PARENT
operator|)
condition|)
block|{
name|Var_Append
argument_list|(
name|MAKE_EXPORTED
argument_list|,
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when .unexport[-env] is seen.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Var_UnExport
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|tmp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|vlist
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Boolean
name|unexport_env
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
operator|!
name|str
index|[
literal|0
index|]
condition|)
block|{
return|return;
comment|/* assert? */
block|}
name|vlist
operator|=
name|NULL
expr_stmt|;
name|str
operator|+=
literal|8
expr_stmt|;
name|unexport_env
operator|=
operator|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"-env"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|unexport_env
condition|)
block|{
name|char
modifier|*
modifier|*
name|newenv
decl_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
name|MAKE_LEVEL_ENV
argument_list|)
expr_stmt|;
comment|/* we should preserve this */
if|if
condition|(
name|environ
operator|==
name|savedEnv
condition|)
block|{
comment|/* we have been here before! */
name|newenv
operator|=
name|bmake_realloc
argument_list|(
name|environ
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|savedEnv
condition|)
block|{
name|free
argument_list|(
name|savedEnv
argument_list|)
expr_stmt|;
name|savedEnv
operator|=
name|NULL
expr_stmt|;
block|}
name|newenv
operator|=
name|bmake_malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newenv
condition|)
return|return;
comment|/* Note: we cannot safely free() the original environ. */
name|environ
operator|=
name|savedEnv
operator|=
name|newenv
expr_stmt|;
name|newenv
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|newenv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|setenv
argument_list|(
name|MAKE_LEVEL_ENV
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|str
operator|!=
literal|'\n'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|;
name|str
operator|++
control|)
continue|continue;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|vlist
operator|=
name|str
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|vlist
condition|)
block|{
comment|/* Using .MAKE.EXPORTED */
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"${"
name|MAKE_EXPORTED
literal|":O:u}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|vlist
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vlist
condition|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|as
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|vlist
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|VarFind
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
if|if
condition|(
operator|!
name|unexport_env
operator|&&
operator|(
name|v
operator|->
name|flags
operator|&
operator|(
name|VAR_EXPORTED
operator||
name|VAR_REEXPORT
operator|)
operator|)
operator|==
name|VAR_EXPORTED
condition|)
block|{
name|unsetenv
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|flags
operator|&=
operator|~
operator|(
name|VAR_EXPORTED
operator||
name|VAR_REEXPORT
operator|)
expr_stmt|;
comment|/* 	     * If we are unexporting a list, 	     * remove each one from .MAKE.EXPORTED. 	     * If we are removing them all, 	     * just delete .MAKE.EXPORTED below. 	     */
if|if
condition|(
name|vlist
operator|==
name|str
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"${"
name|MAKE_EXPORTED
literal|":N%s}"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|MAKE_EXPORTED
argument_list|,
name|cp
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlist
operator|!=
name|str
condition|)
block|{
name|Var_Delete
argument_list|(
name|MAKE_EXPORTED
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Set --  *	Set the variable name to the value val in the given context.  *  * Input:  *	name		name of variable to set  *	val		value to give to the variable  *	ctxt		context in which to set it  *  * Results:  *	None.  *  * Side Effects:  *	If the variable doesn't yet exist, a new record is created for it.  *	Else the old value is freed and the new one stuck in its place  *  * Notes:  *	The variable is searched for only in its context before being  *	created in that context. I.e. if the context is VAR_GLOBAL,  *	only VAR_GLOBAL->context is searched. Likewise if it is VAR_CMD, only  *	VAR_CMD->context is searched. This is done to avoid the literally  *	thousands of unnecessary strcmp's that used to be done to  *	set, say, $(@) or $(<).  *	If the context is VAR_GLOBAL though, we check if the variable  *	was set in VAR_CMD from the command line and skip it if so.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Set
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|expanded_name
init|=
name|NULL
decl_stmt|;
comment|/*      * We only look for a variable in the given context since anything set      * here will override anything in a lower context, so there's not much      * point in searching them all just to save a bit of memory...      */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|expanded_name
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|ctxt
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Var_Set(\"%s\", \"%s\", ...) "
literal|"name expands to empty string - ignored\n"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|expanded_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|expanded_name
expr_stmt|;
block|}
if|if
condition|(
name|ctxt
operator|==
name|VAR_GLOBAL
condition|)
block|{
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|VAR_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_CMD
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s:%s = %s ignored!\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|VarFreeEnv
argument_list|(
name|v
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ctxt
operator|==
name|VAR_CMD
operator|&&
operator|(
name|flags
operator|&
name|VAR_NO_EXPORT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * This var would normally prevent the same name being added 	     * to VAR_GLOBAL, so delete it from there if needed. 	     * Otherwise -V name may show the wrong value. 	     */
name|Var_Delete
argument_list|(
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
name|VarAdd
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_Empty
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_EXPORTED
operator|)
condition|)
block|{
name|Var_Export1
argument_list|(
name|name
argument_list|,
name|VAR_EXPORT_PARENT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Any variables given on the command line are automatically exported      * to the environment (as per POSIX standard)      */
if|if
condition|(
name|ctxt
operator|==
name|VAR_CMD
operator|&&
operator|(
name|flags
operator|&
name|VAR_NO_EXPORT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
comment|/* we just added it */
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|v
operator|->
name|flags
operator||=
name|VAR_FROM_CMD
expr_stmt|;
comment|/* 	 * If requested, don't export these in the environment 	 * individually.  We still put them in MAKEOVERRIDES so 	 * that the command-line settings continue to override 	 * Makefile settings. 	 */
if|if
condition|(
name|varNoExportEnv
operator|!=
name|TRUE
condition|)
name|setenv
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEOVERRIDES
argument_list|,
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_DOLLARS
argument_list|)
operator|==
literal|0
condition|)
name|save_dollars
operator|=
name|s2Boolean
argument_list|(
name|val
argument_list|,
name|save_dollars
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|expanded_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|VarFreeEnv
argument_list|(
name|v
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Append --  *	The variable of the given name has the given value appended to it in  *	the given context.  *  * Input:  *	name		name of variable to modify  *	val		String to append to it  *	ctxt		Context in which this should occur  *  * Results:  *	None  *  * Side Effects:  *	If the variable doesn't exist, it is created. Else the strings  *	are concatenated (with a space in between).  *  * Notes:  *	Only if the variable is being sought in the global context is the  *	environment searched.  *	XXX: Knows its calling circumstances in that if called with ctxt  *	an actual target, it will only search that context since only  *	a local variable could be being appended to. This is actually  *	a big win and must be tolerated.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Append
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|Hash_Entry
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|expanded_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|expanded_name
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|ctxt
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Var_Append(\"%s\", \"%s\", ...) "
literal|"name expands to empty string - ignored\n"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|expanded_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|expanded_name
expr_stmt|;
block|}
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|?
name|FIND_ENV
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|VarAdd
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
comment|/* 	     * If the original variable came from the environment, we 	     * have to install it in the global context (we could place 	     * it in the environment, but then we should provide a way to 	     * export other variables...) 	     */
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_FROM_ENV
expr_stmt|;
name|h
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|h
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|expanded_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Exists --  *	See if the given variable exists.  *  * Input:  *	name		Variable to find  *	ctxt		Context in which to start search  *  * Results:  *	TRUE if it does, FALSE if it doesn't  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Var_Exists
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|ctxt
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|VarFind
argument_list|(
name|cp
condition|?
name|cp
else|:
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_CMD
operator||
name|FIND_GLOBAL
operator||
name|FIND_ENV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|VarFreeEnv
argument_list|(
name|v
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Value --  *	Return the value of the named variable in the given context  *  * Input:  *	name		name to find  *	ctxt		context in which to search for it  *  * Results:  *	The value if the variable exists, NULL if it doesn't  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_Value
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|char
modifier|*
modifier|*
name|frp
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
operator|*
name|frp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|VarFreeEnv
argument_list|(
name|v
argument_list|,
name|FALSE
argument_list|)
condition|)
operator|*
name|frp
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarHead --  *	Remove the tail of the given word and place the result in the given  *	buffer.  *  * Input:  *	word		Word to trim  *	addSpace	True if need to add a space to the buffer  *			before sticking in the head  *	buf		Buffer in which to store it  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarHead
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If no directory part, give . (q.v. the POSIX standard) 	 */
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarTail --  *	Remove the head of the given word and place the result in the given  *	buffer.  *  * Input:  *	word		Word to trim  *	addSpace	True if need to add a space to the buffer  *			before adding the tail  *	buf		Buffer in which to store it  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarTail
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|slash
argument_list|)
argument_list|,
name|slash
argument_list|)
expr_stmt|;
name|slash
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSuffix --  *	Place the suffix of the given word in the given buffer.  *  * Input:  *	word		Word to trim  *	addSpace	TRUE if need to add a space before placing the  *			suffix in the buffer  *	buf		Buffer in which to store it  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The suffix from the word is placed in the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSuffix
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
operator|*
name|dot
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|dot
argument_list|)
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|dot
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|addSpace
else|:
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRoot --  *	Remove the suffix of the given word and place the result in the  *	buffer.  *  * Input:  *	word		Word to trim  *	addSpace	TRUE if need to add a space to the buffer  *			before placing the root in it  *	buf		Buffer in which to store it  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRoot
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
operator|*
name|dot
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the :M modifier.  *  * Input:  *	word		Word to examine  *	addSpace	TRUE if need to add a space to the buffer  *			before adding the word, if it matches  *	buf		Buffer in which to store it  *	pattern		Pattern the word must match  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarMatch
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"VarMatch [%s] [%s]\n"
argument_list|,
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|Str_Match
argument_list|(
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSYSVMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the System V %  *	modifiers.  *  * Input:  *	word		Word to examine  *	addSpace	TRUE if need to add a space to the buffer  *			before adding the word, if it matches  *	buf		Buffer in which to store it  *	patp		Pattern the word must match  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSYSVMatch
parameter_list|(
name|GNode
modifier|*
name|ctx
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|VarPattern
modifier|*
name|pat
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patp
decl_stmt|;
name|char
modifier|*
name|varexp
decl_stmt|;
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|Str_SYSVMatch
argument_list|(
name|word
argument_list|,
name|pat
operator|->
name|lhs
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|varexp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|pat
operator|->
name|rhs
argument_list|,
name|ctx
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|Str_SYSVSubst
argument_list|(
name|buf
argument_list|,
name|varexp
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|varexp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarNoMatch --  *	Place the word in the buffer if it doesn't match the given pattern.  *	Callback function for VarModify to implement the :N modifier.  *  * Input:  *	word		Word to examine  *	addSpace	TRUE if need to add a space to the buffer  *			before adding the word, if it matches  *	buf		Buffer in which to store it  *	pattern		Pattern the word must match  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarNoMatch
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Str_Match
argument_list|(
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSubstitute --  *	Perform a string-substitution on the given word, placing the  *	result in the passed buffer.  *  * Input:  *	word		Word to modify  *	addSpace	True if space should be added before  *			other characters  *	buf		Buffer for result  *	patternp	Pattern for substitution  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSubstitute
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|int
name|wordLen
decl_stmt|;
comment|/* Length of word */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* General pointer */
name|VarPattern
modifier|*
name|pattern
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patternp
decl_stmt|;
name|wordLen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
operator|)
operator|!=
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
condition|)
block|{
comment|/* 	 * Still substituting -- break it down into simple anchored cases 	 * and if none of them fits, perform the general substitution case. 	 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Anchored at start and beginning of word matches pattern 		 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
operator|)
operator|&&
operator|(
name|wordLen
operator|==
name|pattern
operator|->
name|leftLen
operator|)
condition|)
block|{
comment|/* 			 * Also anchored at end and matches to the end (word 			 * is same length as pattern) add space and rhs only 			 * if rhs is non-null. 			 */
if|if
condition|(
name|pattern
operator|->
name|rightLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
name|pattern
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 		     * Doesn't match to end -- copy word wholesale 		     */
goto|goto
name|nosub
goto|;
block|}
else|else
block|{
comment|/* 		     * Matches at start but need to copy in trailing characters 		     */
if|if
condition|(
operator|(
name|pattern
operator|->
name|rightLen
operator|+
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
argument_list|,
operator|(
name|word
operator|+
name|pattern
operator|->
name|leftLen
operator|)
argument_list|)
expr_stmt|;
name|pattern
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
condition|)
block|{
comment|/* 	     * Had to match at start of word and didn't -- copy whole word. 	     */
goto|goto
name|nosub
goto|;
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 	     * Anchored at end, Find only place match could occur (leftLen 	     * characters from the end of the word) and see if it does. Note 	     * that because the $ will be left at the end of the lhs, we have 	     * to use strncmp. 	     */
name|cp
operator|=
name|word
operator|+
operator|(
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|>=
name|word
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Match found. If we will place characters in the buffer, 		 * add a space before hand as indicated by addSpace, then 		 * stuff in the initial, unmatched part of the word followed 		 * by the right-hand-side. 		 */
if|if
condition|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|pattern
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Had to match at end and didn't. Copy entire word. 		 */
goto|goto
name|nosub
goto|;
block|}
block|}
else|else
block|{
comment|/* 	     * Pattern is unanchored: search for the pattern in the word using 	     * String_FindSubstring, copying unmatched portions and the 	     * right-hand-side for each match found, handling non-global 	     * substitutions correctly, etc. When the loop is done, any 	     * remaining part of the word (word and wordLen are adjusted 	     * accordingly through the loop) is copied straight into the 	     * buffer. 	     * addSpace is set FALSE as soon as a space is added to the 	     * buffer. 	     */
name|Boolean
name|done
decl_stmt|;
name|int
name|origSize
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|origSize
operator|=
name|Buf_Size
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|cp
operator|=
name|Str_FindSubstring
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
operator|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|wordLen
operator|-=
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
name|word
operator|=
name|cp
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
if|if
condition|(
name|wordLen
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
operator|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
name|pattern
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If added characters to the buffer, need to add a space 	     * before we add any more. If we didn't add any, just return 	     * the previous value of addSpace. 	     */
return|return
operator|(
operator|(
name|Buf_Size
argument_list|(
name|buf
argument_list|)
operator|!=
name|origSize
operator|)
operator|||
name|addSpace
operator|)
return|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
name|nosub
label|:
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarREError --  *	Print the error caused by a regcomp or regexec call.  *  * Results:  *	None.  *  * Side Effects:  *	An error gets printed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarREError
parameter_list|(
name|int
name|reerr
parameter_list|,
name|regex_t
modifier|*
name|pat
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|errbuf
decl_stmt|;
name|int
name|errlen
decl_stmt|;
name|errlen
operator|=
name|regerror
argument_list|(
name|reerr
argument_list|,
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errbuf
operator|=
name|bmake_malloc
argument_list|(
name|errlen
argument_list|)
expr_stmt|;
name|regerror
argument_list|(
name|reerr
argument_list|,
name|pat
argument_list|,
name|errbuf
argument_list|,
name|errlen
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRESubstitute --  *	Perform a regex substitution on the given word, placing the  *	result in the passed buffer.  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRESubstitute
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
name|MAKE_ATTR_UNUSED
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|VarREPattern
modifier|*
name|pat
decl_stmt|;
name|int
name|xrv
decl_stmt|;
name|char
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|int
name|added
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAYBE_ADD_SPACE
parameter_list|()
define|\
value|if (addSpace&& !added)		\ 	    Buf_AddByte(buf, ' ');	\ 	added = 1
name|added
operator|=
literal|0
expr_stmt|;
name|wp
operator|=
name|word
expr_stmt|;
name|pat
operator|=
name|patternp
expr_stmt|;
if|if
condition|(
operator|(
name|pat
operator|->
name|flags
operator|&
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
operator|)
operator|==
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
condition|)
name|xrv
operator|=
name|REG_NOMATCH
expr_stmt|;
else|else
block|{
name|tryagain
label|:
name|xrv
operator|=
name|regexec
argument_list|(
operator|&
name|pat
operator|->
name|re
argument_list|,
name|wp
argument_list|,
name|pat
operator|->
name|nsub
argument_list|,
name|pat
operator|->
name|matches
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|xrv
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|pat
operator|->
name|replace
init|;
operator|*
name|rp
condition|;
name|rp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|rp
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|subbuf
decl_stmt|;
name|int
name|sublen
decl_stmt|;
name|char
name|errstr
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
literal|'&'
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'&'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rp
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
name|errstr
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|pat
operator|->
name|nsub
condition|)
block|{
name|Error
argument_list|(
literal|"No subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|Error
argument_list|(
literal|"No match for subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subbuf
operator|=
name|wp
operator|+
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
name|sublen
operator|=
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|-
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
block|}
if|if
condition|(
name|sublen
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|sublen
argument_list|,
name|subbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
name|wp
operator|+=
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
condition|)
block|{
name|flags
operator||=
name|REG_NOTBOL
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|*
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|wp
argument_list|)
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|VarREError
argument_list|(
name|xrv
argument_list|,
operator|&
name|pat
operator|->
name|re
argument_list|,
literal|"Unexpected regex error"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|REG_NOMATCH
case|:
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|wp
argument_list|)
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|addSpace
operator|||
name|added
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarLoopExpand --  *	Implements the :@<temp>@<string>@ modifier of ODE make.  *	We set the temp variable named in pattern.lhs to word and expand  *	pattern.rhs storing the result in the passed buffer.  *  * Input:  *	word		Word to modify  *	addSpace	True if space should be added before  *			other characters  *	buf		Buffer for result  *	pattern		Datafor substitution  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarLoopExpand
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
name|MAKE_ATTR_UNUSED
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|loopp
parameter_list|)
block|{
name|VarLoop_t
modifier|*
name|loop
init|=
operator|(
name|VarLoop_t
operator|*
operator|)
name|loopp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|slen
decl_stmt|;
if|if
condition|(
name|word
operator|&&
operator|*
name|word
condition|)
block|{
name|Var_Set
argument_list|(
name|loop
operator|->
name|tvar
argument_list|,
name|word
argument_list|,
name|loop
operator|->
name|ctxt
argument_list|,
name|VAR_NO_EXPORT
argument_list|)
expr_stmt|;
name|s
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|loop
operator|->
name|str
argument_list|,
name|loop
operator|->
name|ctxt
argument_list|,
name|loop
operator|->
name|errnum
operator||
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
operator|(
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|addSpace
operator|=
operator|(
name|slen
operator|>
literal|0
operator|&&
name|s
index|[
name|slen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addSpace
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSelectWords --  *	Implements the :[start..end] modifier.  *	This is a special case of VarModify since we want to be able  *	to scan the list backwards if start> end.  *  * Input:  *	str		String whose words should be trimmed  *	seldata		words to select  *  * Results:  *	A string of all the words selected.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarSelectWords
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|VarSelectWords_t
modifier|*
name|seldata
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for the new string */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				     * buffer before adding the trimmed 				     * word */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* word list */
name|char
modifier|*
name|as
decl_stmt|;
comment|/* word list memory */
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|step
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vpstate
operator|->
name|oneBigWord
condition|)
block|{
comment|/* fake what brk_string() would do if there were only one word */
name|ac
operator|=
literal|1
expr_stmt|;
name|av
operator|=
name|bmake_malloc
argument_list|(
operator|(
name|ac
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|=
name|bmake_strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|as
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now sanitize seldata.      * If seldata->start or seldata->end are negative, convert them to      * the positive equivalents (-1 gets converted to argc, -2 gets      * converted to (argc-1), etc.).      */
if|if
condition|(
name|seldata
operator|->
name|start
operator|<
literal|0
condition|)
name|seldata
operator|->
name|start
operator|=
name|ac
operator|+
name|seldata
operator|->
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|seldata
operator|->
name|end
operator|<
literal|0
condition|)
name|seldata
operator|->
name|end
operator|=
name|ac
operator|+
name|seldata
operator|->
name|end
operator|+
literal|1
expr_stmt|;
comment|/*      * We avoid scanning more of the list than we need to.      */
if|if
condition|(
name|seldata
operator|->
name|start
operator|>
name|seldata
operator|->
name|end
condition|)
block|{
name|start
operator|=
name|MIN
argument_list|(
name|ac
argument_list|,
name|seldata
operator|->
name|start
argument_list|)
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|seldata
operator|->
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
name|step
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|seldata
operator|->
name|start
operator|-
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|MIN
argument_list|(
name|ac
argument_list|,
name|seldata
operator|->
name|end
argument_list|)
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
operator|(
name|step
operator|<
literal|0
operator|&&
name|i
operator|>=
name|end
operator|)
operator|||
operator|(
name|step
operator|>
literal|0
operator|&&
name|i
operator|<
name|end
operator|)
condition|;
name|i
operator|+=
name|step
control|)
block|{
if|if
condition|(
name|av
index|[
name|i
index|]
operator|&&
operator|*
name|av
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  * VarRealpath --  *	Replace each word with the result of realpath()  *	if successful.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRealpath
parameter_list|(
name|GNode
modifier|*
name|ctx
name|MAKE_ATTR_UNUSED
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|rbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|addSpace
operator|&&
name|vpstate
operator|->
name|varSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
name|vpstate
operator|->
name|varSpace
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|rp
operator|=
name|cached_realpath
argument_list|(
name|word
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
operator|*
name|rp
operator|==
literal|'/'
operator|&&
name|stat
argument_list|(
name|rp
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|word
operator|=
name|rp
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarModify --  *	Modify each of the words of the passed string using the given  *	function. Used to implement all modifiers.  *  * Input:  *	str		String whose words should be trimmed  *	modProc		Function to use to modify them  *	datum		Datum to pass it  *  * Results:  *	A string of all the words modified appropriately.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarModify
parameter_list|(
name|GNode
modifier|*
name|ctx
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|Boolean
function_decl|(
modifier|*
name|modProc
function_decl|)
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Var_Parse_State
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|datum
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for the new string */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				     * buffer before adding the trimmed 				     * word */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* word list */
name|char
modifier|*
name|as
decl_stmt|;
comment|/* word list memory */
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vpstate
operator|->
name|oneBigWord
condition|)
block|{
comment|/* fake what brk_string() would do if there were only one word */
name|ac
operator|=
literal|1
expr_stmt|;
name|av
operator|=
name|bmake_malloc
argument_list|(
operator|(
name|ac
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|=
name|bmake_strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|as
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|addSpace
operator|=
call|(
modifier|*
name|modProc
call|)
argument_list|(
name|ctx
argument_list|,
name|vpstate
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|addSpace
argument_list|,
operator|&
name|buf
argument_list|,
name|datum
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|VarWordCompare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|int
name|r
init|=
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|a
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarOrder --  *	Order the words in the string.  *  * Input:  *	str		String whose words should be sorted.  *	otype		How to order: s - sort, x - random.  *  * Results:  *	A string containing the words ordered.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarOrder
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
name|otype
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for the new string */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* word list [first word does not count] */
name|char
modifier|*
name|as
decl_stmt|;
comment|/* word list memory */
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
switch|switch
condition|(
name|otype
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* sort alphabetically */
name|qsort
argument_list|(
name|av
argument_list|,
name|ac
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|VarWordCompare
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* randomize */
block|{
name|int
name|rndidx
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
comment|/* 	     * We will use [ac..2] range for mod factors. This will produce 	     * random numbers in [(ac-1)..0] interval, and minimal 	     * reasonable value for mod factor is 2 (the mod 1 will produce 	     * 0 with probability 1). 	     */
for|for
control|(
name|i
operator|=
name|ac
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rndidx
operator|=
name|random
argument_list|()
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|rndidx
condition|)
block|{
name|t
operator|=
name|av
index|[
name|i
index|]
expr_stmt|;
name|av
index|[
name|i
index|]
operator|=
name|av
index|[
name|rndidx
index|]
expr_stmt|;
name|av
index|[
name|rndidx
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end of switch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ac
operator|-
literal|1
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarUniq --  *	Remove adjacent duplicate words.  *  * Input:  *	str		String whose words should be sorted  *  * Results:  *	A string containing the resulting words.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarUniq
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for new string */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* List of words to affect */
name|char
modifier|*
name|as
decl_stmt|;
comment|/* Word list memory */
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
name|av
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|++
name|j
operator|!=
name|i
operator|)
condition|)
name|av
index|[
name|j
index|]
operator|=
name|av
index|[
name|i
index|]
expr_stmt|;
name|ac
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ac
operator|-
literal|1
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRange --  *	Return an integer sequence  *  * Input:  *	str		String whose words provide default range  *	ac		range length, if 0 use str words  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for new string */
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
comment|/* each element */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* List of words to affect */
name|char
modifier|*
name|as
decl_stmt|;
comment|/* Word list memory */
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
block|{
name|as
operator|=
name|NULL
expr_stmt|;
name|av
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
break|break;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|n
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ac
operator|-
literal|1
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarGetPattern --  *	Pass through the tstr looking for 1) escaped delimiters,  *	'$'s and backslashes (place the escaped character in  *	uninterpreted) and 2) unescaped $'s that aren't before  *	the delimiter (expand the variable substitution unless flags  *	has VAR_NOSUBST set).  *	Return the expanded string or NULL if the delimiter was missing  *	If pattern is specified, handle escaped ampersands, and replace  *	unescaped ampersands with the lhs of the pattern.  *  * Results:  *	A string of all the words modified appropriately.  *	If length is specified, return the string length of the buffer  *	If flags is specified and the last character of the pattern is a  *	$ set the VAR_MATCH_END bit of flags.  *  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarGetPattern
parameter_list|(
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|Var_Parse_State
modifier|*
name|vpstate
name|MAKE_ATTR_UNUSED
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tstr
parameter_list|,
name|int
name|delim
parameter_list|,
name|int
modifier|*
name|vflags
parameter_list|,
name|int
modifier|*
name|length
parameter_list|,
name|VarPattern
modifier|*
name|pattern
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|rstr
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
name|errnum
init|=
name|flags
operator|&
name|VARF_UNDEFERR
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|NULL
condition|)
name|length
operator|=
operator|&
name|junk
expr_stmt|;
define|#
directive|define
name|IS_A_MATCH
parameter_list|(
name|cp
parameter_list|,
name|delim
parameter_list|)
define|\
value|((cp[0] == '\\')&& ((cp[1] == delim) ||  \      (cp[1] == '\\') || (cp[1] == '$') || (pattern&& (cp[1] == '&'))))
comment|/*      * Skim through until the matching delimiter is found;      * pick up variable substitutions on the way. Also allow      * backslashes to quote the delimiter, $, and \, but don't      * touch other backslashes.      */
for|for
control|(
name|cp
operator|=
operator|*
name|tstr
init|;
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|!=
name|delim
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|IS_A_MATCH
argument_list|(
name|cp
argument_list|,
name|delim
argument_list|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|vflags
operator|==
name|NULL
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
else|else
comment|/* 		     * Unescaped $ at end of pattern => anchor 		     * pattern at end. 		     */
operator|*
name|vflags
operator||=
name|VAR_MATCH_END
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vflags
operator|==
name|NULL
operator|||
operator|(
operator|*
name|vflags
operator|&
name|VAR_NOSUBST
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
comment|/* 		     * If unescaped dollar sign not before the 		     * delimiter, assume it's a variable 		     * substitution and recurse. 		     */
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|errnum
operator||
name|VARF_WANTRES
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|cp2
init|=
operator|&
name|cp
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
name|PROPEN
operator|||
operator|*
name|cp2
operator|==
name|BROPEN
condition|)
block|{
comment|/* 			 * Find the end of this variable reference 			 * and suck it in without further ado. 			 * It will be interperated later. 			 */
name|int
name|have
init|=
operator|*
name|cp2
decl_stmt|;
name|int
name|want
init|=
operator|(
operator|*
name|cp2
operator|==
name|PROPEN
operator|)
condition|?
name|PRCLOSE
else|:
name|BRCLOSE
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
for|for
control|(
operator|++
name|cp2
init|;
operator|*
name|cp2
operator|!=
literal|'\0'
operator|&&
name|depth
operator|>
literal|0
condition|;
operator|++
name|cp2
control|)
block|{
if|if
condition|(
name|cp2
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|cp2
operator|==
name|have
condition|)
operator|++
name|depth
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
name|want
condition|)
operator|--
name|depth
expr_stmt|;
block|}
block|}
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|cp2
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|--
name|cp2
expr_stmt|;
block|}
else|else
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|&&
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
else|else
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
name|delim
condition|)
block|{
operator|*
name|tstr
operator|=
name|cp
expr_stmt|;
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|tstr
operator|=
operator|++
name|cp
expr_stmt|;
operator|*
name|length
operator|=
name|Buf_Size
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|rstr
operator|=
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Modifier pattern: \"%s\"\n"
argument_list|,
name|rstr
argument_list|)
expr_stmt|;
return|return
name|rstr
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarQuote --  *	Quote shell meta-characters and space characters in the string  *  * Results:  *	The quoted string  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarQuote
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|newline
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
if|if
condition|(
operator|(
name|newline
operator|=
name|Shell_GetNewline
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|newline
operator|=
literal|"\\\n"
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|newline
argument_list|)
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|nlen
argument_list|,
name|newline
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
operator|||
name|ismeta
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"QuoteMeta: [%s]\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarHash --  *      Hash the string using the MurmurHash3 algorithm.  *      Output is computed using 32bit Little Endian arithmetic.  *  * Input:  *	str		String to modify  *  * Results:  *      Hash value of str, encoded as 8 hex digits.  *  * Side Effects:  *      None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarHash
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hexdigits
index|[
literal|16
index|]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|len2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ustr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
decl_stmt|;
name|unsigned
name|int
name|h
decl_stmt|,
name|k
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|h
operator|=
literal|0x971e137bU
expr_stmt|;
name|c1
operator|=
literal|0x95543787U
expr_stmt|;
name|c2
operator|=
literal|0x2ad7eb25U
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|len2
init|;
name|len
condition|;
control|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
default|default:
name|k
operator|=
operator|(
name|ustr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ustr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ustr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ustr
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|ustr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|k
operator||=
operator|(
name|ustr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
case|case
literal|2
case|:
name|k
operator||=
operator|(
name|ustr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|1
case|:
name|k
operator||=
name|ustr
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|c1
operator|=
name|c1
operator|*
literal|5
operator|+
literal|0x7b7d159cU
expr_stmt|;
name|c2
operator|=
name|c2
operator|*
literal|5
operator|+
literal|0x6bce6396U
expr_stmt|;
name|k
operator|*=
name|c1
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator|<<
literal|11
operator|)
operator|^
operator|(
name|k
operator|>>
literal|21
operator|)
expr_stmt|;
name|k
operator|*=
name|c2
expr_stmt|;
name|h
operator|=
operator|(
name|h
operator|<<
literal|13
operator|)
operator|^
operator|(
name|h
operator|>>
literal|19
operator|)
expr_stmt|;
name|h
operator|=
name|h
operator|*
literal|5
operator|+
literal|0x52dce729U
expr_stmt|;
name|h
operator|^=
name|k
expr_stmt|;
block|}
name|h
operator|^=
name|len2
expr_stmt|;
name|h
operator|*=
literal|0x85ebca6b
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|13
expr_stmt|;
name|h
operator|*=
literal|0xc2b2ae35
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|8
condition|;
operator|++
name|len
control|)
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
name|hexdigits
index|[
name|h
operator|&
literal|15
index|]
argument_list|)
expr_stmt|;
name|h
operator|>>=
literal|4
expr_stmt|;
block|}
return|return
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|VarStrftime
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|zulu
parameter_list|,
name|time_t
name|utc
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|utc
condition|)
name|time
argument_list|(
operator|&
name|utc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
name|fmt
operator|=
literal|"%c"
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|zulu
condition|?
name|gmtime
argument_list|(
operator|&
name|utc
argument_list|)
else|:
name|localtime
argument_list|(
operator|&
name|utc
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|bmake_strdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Now we need to apply any modifiers the user wants applied.  * These are:  *  	  :M<pattern>	words which match the given<pattern>.  *<pattern> is of the standard file  *  			wildcarding form.  *  	  :N<pattern>	words which do not match the given<pattern>.  *  	  :S<d><pat1><d><pat2><d>[1gW]  *  			Substitute<pat2> for<pat1> in the value  *  	  :C<d><pat1><d><pat2><d>[1gW]  *  			Substitute<pat2> for regex<pat1> in the value  *  	  :H		Substitute the head of each word  *  	  :T		Substitute the tail of each word  *  	  :E		Substitute the extension (minus '.') of  *  			each word  *  	  :R		Substitute the root of each word  *  			(pathname minus the suffix).  *	  :O		("Order") Alphabeticaly sort words in variable.  *	  :Ox		("intermiX") Randomize words in variable.  *	  :u		("uniq") Remove adjacent duplicate words.  *	  :tu		Converts the variable contents to uppercase.  *	  :tl		Converts the variable contents to lowercase.  *	  :ts[c]	Sets varSpace - the char used to  *			separate words to 'c'. If 'c' is  *			omitted then no separation is used.  *	  :tW		Treat the variable contents as a single  *			word, even if it contains spaces.  *			(Mnemonic: one big 'W'ord.)  *	  :tw		Treat the variable contents as multiple  *			space-separated words.  *			(Mnemonic: many small 'w'ords.)  *	  :[index]	Select a single word from the value.  *	  :[start..end]	Select multiple words from the value.  *	  :[*] or :[0]	Select the entire value, as a single  *			word.  Equivalent to :tW.  *	  :[@]		Select the entire value, as multiple  *			words.	Undoes the effect of :[*].  *			Equivalent to :tw.  *	  :[#]		Returns the number of words in the value.  *  *	  :?<true-value>:<false-value>  *			If the variable evaluates to true, return  *			true value, else return the second value.  *    	  :lhs=rhs  	Like :S, but the rhs goes to the end of  *    			the invocation.  *	  :sh		Treat the current value as a command  *			to be run, new value is its output.  * The following added so we can handle ODE makefiles.  *	  :@<tmpvar>@<newval>@  *			Assign a temporary local variable<tmpvar>  *			to the current value of each word in turn  *			and replace each word with the result of  *			evaluating<newval>  *	  :D<newval>	Use<newval> as value if variable defined  *	  :U<newval>	Use<newval> as value if variable undefined  *	  :L		Use the name of the variable as the value.  *	  :P		Use the path of the node that has the same  *			name as the variable as the value.  This  *			basically includes an implied :L so that  *			the common method of refering to the path  *			of your dependent 'x' in a rule is to use  *			the form '${x:P}'.  *	  :!<cmd>!	Run cmd much the same as :sh run's the  *			current value of the variable.  * The ::= modifiers, actually assign a value to the variable.  * Their main purpose is in supporting modifiers of .for loop  * iterators and other obscure uses.  They always expand to  * nothing.  In a target rule that would otherwise expand to an  * empty line they can be preceded with @: to keep make happy.  * Eg.  *  * foo:	.USE  * .for i in ${.TARGET} ${.TARGET:R}.gz  * 	@: ${t::=$i}  *	@echo blah ${t:T}  * .endfor  *  *	  ::=<str>	Assigns<str> as the new value of variable.  *	  ::?=<str>	Assigns<str> as value of variable if  *			it was not already set.  *	  ::+=<str>	Appends<str> to variable.  *	  ::!=<cmd>	Assigns output of<cmd> as the new value of  *			variable.  */
end_comment

begin_comment
comment|/* we now have some modifiers with long names */
end_comment

begin_define
define|#
directive|define
name|STRMOD_MATCH
parameter_list|(
name|s
parameter_list|,
name|want
parameter_list|,
name|n
parameter_list|)
define|\
value|(strncmp(s, want, n) == 0&& (s[n] == endc || s[n] == ':'))
end_define

begin_define
define|#
directive|define
name|STRMOD_MATCHX
parameter_list|(
name|s
parameter_list|,
name|want
parameter_list|,
name|n
parameter_list|)
define|\
value|(strncmp(s, want, n) == 0&& (s[n] == endc || s[n] == ':' || s[n] == '='))
end_define

begin_define
define|#
directive|define
name|CHARMOD_MATCH
parameter_list|(
name|c
parameter_list|)
value|(c == endc || c == ':')
end_define

begin_function
specifier|static
name|char
modifier|*
name|ApplyModifiers
parameter_list|(
name|char
modifier|*
name|nstr
parameter_list|,
specifier|const
name|char
modifier|*
name|tstr
parameter_list|,
name|int
name|startc
parameter_list|,
name|int
name|endc
parameter_list|,
name|Var
modifier|*
name|v
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|lengthPtr
parameter_list|,
name|void
modifier|*
modifier|*
name|freePtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Secondary pointer into str (place marker 				 * for tstr) */
name|char
modifier|*
name|newStr
decl_stmt|;
comment|/* New value to return */
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|termc
decl_stmt|;
comment|/* Character which terminated scan */
name|int
name|cnt
decl_stmt|;
comment|/* Used to count brace pairs when variable in 				 * in parens or braces */
name|char
name|delim
decl_stmt|;
name|int
name|modifier
decl_stmt|;
comment|/* that we are processing */
name|Var_Parse_State
name|parsestate
decl_stmt|;
comment|/* Flags passed to helper functions */
name|time_t
name|utc
decl_stmt|;
comment|/* for VarStrftime */
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|parsestate
operator|.
name|oneBigWord
operator|=
name|FALSE
expr_stmt|;
name|parsestate
operator|.
name|varSpace
operator|=
literal|' '
expr_stmt|;
comment|/* word separator */
name|start
operator|=
name|cp
operator|=
name|tstr
expr_stmt|;
while|while
condition|(
operator|*
name|tstr
operator|&&
operator|*
name|tstr
operator|!=
name|endc
condition|)
block|{
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'$'
condition|)
block|{
comment|/* 	     * We may have some complex modifiers in a variable. 	     */
name|void
modifier|*
name|freeIt
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
name|int
name|rlen
decl_stmt|;
name|int
name|c
decl_stmt|;
name|rval
operator|=
name|Var_Parse
argument_list|(
name|tstr
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|rlen
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
comment|/* 	     * If we have not parsed up to endc or ':', 	     * we are not interested. 	     */
if|if
condition|(
name|rval
operator|!=
name|NULL
operator|&&
operator|*
name|rval
operator|&&
operator|(
name|c
operator|=
name|tstr
index|[
name|rlen
index|]
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
name|endc
condition|)
block|{
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
goto|goto
name|apply_mods
goto|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Got '%s' from '%.*s'%.*s\n"
argument_list|,
name|rval
argument_list|,
name|rlen
argument_list|,
name|tstr
argument_list|,
name|rlen
argument_list|,
name|tstr
operator|+
name|rlen
argument_list|)
expr_stmt|;
block|}
name|tstr
operator|+=
name|rlen
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|NULL
operator|&&
operator|*
name|rval
condition|)
block|{
name|int
name|used
decl_stmt|;
name|nstr
operator|=
name|ApplyModifiers
argument_list|(
name|nstr
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|v
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|used
argument_list|,
name|freePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstr
operator|==
name|var_Error
operator|||
operator|(
name|nstr
operator|==
name|varNoError
operator|&&
operator|(
name|flags
operator|&
name|VARF_UNDEFERR
operator|)
operator|==
literal|0
operator|)
operator|||
name|strlen
argument_list|(
name|rval
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|used
condition|)
block|{
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* error already reported */
block|}
block|}
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tstr
operator|==
literal|':'
condition|)
name|tstr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|tstr
operator|&&
name|endc
condition|)
block|{
name|Error
argument_list|(
literal|"Unclosed variable specification after complex modifier (expecting '%c') for %s"
argument_list|,
name|endc
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
block|}
name|apply_mods
label|:
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Applying[%s] :%c to \"%s\"\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
operator|*
name|tstr
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
block|}
name|newStr
operator|=
name|var_Error
expr_stmt|;
switch|switch
condition|(
operator|(
name|modifier
operator|=
operator|*
name|tstr
operator|)
condition|)
block|{
case|case
literal|':'
case|:
block|{
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
operator|(
name|tstr
index|[
literal|2
index|]
operator|==
literal|'='
operator|&&
operator|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'!'
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
operator|)
condition|)
block|{
comment|/* 		     * "::=", "::!=", "::+=", or "::?=" 		     */
name|GNode
modifier|*
name|v_ctxt
decl_stmt|;
comment|/* context where v belongs */
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
name|char
modifier|*
name|sv_name
decl_stmt|;
name|VarPattern
name|pattern
decl_stmt|;
name|int
name|how
decl_stmt|;
name|int
name|vflags
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|bad_modifier
goto|;
name|v_ctxt
operator|=
name|ctxt
expr_stmt|;
name|sv_name
operator|=
name|NULL
expr_stmt|;
operator|++
name|tstr
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
comment|/* 			 * We need to bmake_strdup() it incase 			 * VarGetPattern() recurses. 			 */
name|sv_name
operator|=
name|v
operator|->
name|name
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctxt
operator|!=
name|VAR_GLOBAL
condition|)
block|{
name|Var
modifier|*
name|gv
init|=
name|VarFind
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|==
name|NULL
condition|)
name|v_ctxt
operator|=
name|VAR_GLOBAL
expr_stmt|;
else|else
name|VarFreeEnv
argument_list|(
name|gv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|how
operator|=
operator|*
name|tstr
operator|)
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
name|cp
operator|=
operator|&
name|tstr
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
break|break;
block|}
name|delim
operator|=
name|startc
operator|==
name|PROPEN
condition|?
name|PRCLOSE
else|:
name|BRCLOSE
expr_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|vflags
operator|=
operator|(
name|flags
operator|&
name|VARF_WANTRES
operator|)
condition|?
literal|0
else|:
name|VAR_NOSUBST
expr_stmt|;
name|pattern
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|vflags
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
comment|/* restore original name */
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|sv_name
expr_stmt|;
block|}
if|if
condition|(
name|pattern
operator|.
name|rhs
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|termc
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VARF_WANTRES
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
literal|'+'
case|:
name|Var_Append
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|pattern
operator|.
name|rhs
argument_list|,
name|v_ctxt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|newStr
operator|=
name|Cmd_Exec
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|,
operator|&
name|emsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|emsg
condition|)
name|Error
argument_list|(
name|emsg
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
else|else
name|Var_Set
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|newStr
argument_list|,
name|v_ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newStr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
name|Var_Set
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|pattern
operator|.
name|rhs
argument_list|,
name|v_ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|newStr
operator|=
name|varNoError
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
comment|/* "::<unrecognised>" */
block|}
case|case
literal|'@'
case|:
block|{
name|VarLoop_t
name|loop
decl_stmt|;
name|int
name|vflags
init|=
name|VAR_NOSUBST
decl_stmt|;
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
name|delim
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
operator|(
name|loop
operator|.
name|tvar
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|vflags
argument_list|,
operator|&
name|loop
operator|.
name|tvarLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|loop
operator|.
name|str
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|vflags
argument_list|,
operator|&
name|loop
operator|.
name|strLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|loop
operator|.
name|errnum
operator|=
name|flags
operator|&
name|VARF_UNDEFERR
expr_stmt|;
name|loop
operator|.
name|ctxt
operator|=
name|ctxt
expr_stmt|;
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarLoopExpand
argument_list|,
operator|&
name|loop
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
name|loop
operator|.
name|tvar
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop
operator|.
name|tvar
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop
operator|.
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'_'
case|:
comment|/* remember current value */
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|STRMOD_MATCHX
argument_list|(
name|tstr
argument_list|,
literal|"_"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|n
decl_stmt|;
name|cp
operator|++
expr_stmt|;
name|n
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|":)}"
argument_list|)
expr_stmt|;
name|np
operator|=
name|bmake_strndup
argument_list|(
name|cp
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|np
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
operator|+
name|n
expr_stmt|;
name|Var_Set
argument_list|(
name|np
argument_list|,
name|nstr
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Var_Set
argument_list|(
literal|"_"
argument_list|,
name|nstr
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|newStr
operator|=
name|nstr
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for patterns */
name|int
name|nflags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|VARF_WANTRES
condition|)
block|{
name|int
name|wantres
decl_stmt|;
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'U'
condition|)
name|wantres
operator|=
operator|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|else
name|wantres
operator|=
operator|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|nflags
operator|=
name|flags
operator|&
operator|~
name|VARF_WANTRES
expr_stmt|;
if|if
condition|(
name|wantres
condition|)
name|nflags
operator||=
name|VARF_WANTRES
expr_stmt|;
block|}
else|else
name|nflags
operator|=
name|flags
expr_stmt|;
comment|/* 		 * Pass through tstr looking for 1) escaped delimiters, 		 * '$'s and backslashes (place the escaped character in 		 * uninterpreted) and 2) unescaped $'s that aren't before 		 * the delimiter (expand the variable substitution). 		 * The result is left in the Buffer buf. 		 */
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
name|endc
operator|&&
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
name|endc
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 			     * If unescaped dollar sign, assume it's a 			     * variable substitution and recurse. 			     */
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|nflags
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|!=
literal|0
condition|)
name|v
operator|->
name|flags
operator||=
name|VAR_KEEP
expr_stmt|;
if|if
condition|(
name|nflags
operator|&
name|VARF_WANTRES
condition|)
block|{
name|newStr
operator|=
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|nstr
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'L'
case|:
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|!=
literal|0
condition|)
name|v
operator|->
name|flags
operator||=
name|VAR_KEEP
expr_stmt|;
name|newStr
operator|=
name|bmake_strdup
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
name|termc
operator|=
operator|*
name|tstr
expr_stmt|;
break|break;
block|}
case|case
literal|'P'
case|:
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
operator|)
operator|!=
literal|0
condition|)
name|v
operator|->
name|flags
operator||=
name|VAR_KEEP
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
operator|||
name|gn
operator|->
name|type
operator|&
name|OP_NOPATH
condition|)
block|{
name|newStr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|path
condition|)
block|{
name|newStr
operator|=
name|bmake_strdup
argument_list|(
name|gn
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|Dir_FindFile
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|Suff_FindPath
argument_list|(
name|gn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newStr
condition|)
block|{
name|newStr
operator|=
name|bmake_strdup
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
name|termc
operator|=
operator|*
name|tstr
expr_stmt|;
break|break;
block|}
case|case
literal|'!'
case|:
block|{
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
name|VarPattern
name|pattern
decl_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|delim
operator|=
literal|'!'
expr_stmt|;
name|emsg
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|flags
operator|&
name|VARF_WANTRES
condition|)
name|newStr
operator|=
name|Cmd_Exec
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|,
operator|&
name|emsg
argument_list|)
expr_stmt|;
else|else
name|newStr
operator|=
name|varNoError
expr_stmt|;
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|emsg
condition|)
name|Error
argument_list|(
name|emsg
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_KEEP
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'['
case|:
block|{
comment|/* 		 * Look for the closing ']', recursively 		 * expanding any embedded variables. 		 * 		 * estr is a pointer to the expanded result, 		 * which we must free(). 		 */
name|char
modifier|*
name|estr
decl_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* point to char after '[' */
name|delim
operator|=
literal|']'
expr_stmt|;
comment|/* look for closing ']' */
name|estr
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|estr
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* report missing ']' */
comment|/* now cp points just after the closing ']' */
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
name|cp
index|[
literal|0
index|]
operator|!=
name|endc
condition|)
block|{
comment|/* Found junk after ']' */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
if|if
condition|(
name|estr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Found empty square brackets in ":[]". */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
elseif|else
if|if
condition|(
name|estr
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|estr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Found ":[#]" */
comment|/* 		     * We will need enough space for the decimal 		     * representation of an int.  We calculate the 		     * space needed for the octal representation, 		     * and add enough slop to cope with a '-' sign 		     * (which should never be needed) and a '\0' 		     * string terminator. 		     */
name|int
name|newStrSize
init|=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
literal|2
decl_stmt|;
name|newStr
operator|=
name|bmake_malloc
argument_list|(
name|newStrSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsestate
operator|.
name|oneBigWord
condition|)
block|{
name|strncpy
argument_list|(
name|newStr
argument_list|,
literal|"1"
argument_list|,
name|newStrSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: brk_string() is a rather expensive 			 * way of counting words. */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|as
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|nstr
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|newStr
argument_list|,
name|newStrSize
argument_list|,
literal|"%d"
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|estr
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|estr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Found ":[*]" */
name|parsestate
operator|.
name|oneBigWord
operator|=
name|TRUE
expr_stmt|;
name|newStr
operator|=
name|nstr
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|estr
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|estr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Found ":[@]" */
name|parsestate
operator|.
name|oneBigWord
operator|=
name|FALSE
expr_stmt|;
name|newStr
operator|=
name|nstr
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* 		     * We expect estr to contain a single 		     * integer for :[N], or two integers 		     * separated by ".." for :[start..end]. 		     */
name|VarSelectWords_t
name|seldata
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|seldata
operator|.
name|start
operator|=
name|strtol
argument_list|(
name|estr
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|estr
condition|)
block|{
comment|/* Found junk instead of a number */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
elseif|else
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Found only one integer in :[N] */
name|seldata
operator|.
name|end
operator|=
name|seldata
operator|.
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ep
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|ep
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Expecting another integer after ".." */
name|ep
operator|+=
literal|2
expr_stmt|;
name|seldata
operator|.
name|end
operator|=
name|strtol
argument_list|(
name|ep
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Found junk after ".." */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
block|}
else|else
block|{
comment|/* Found junk instead of ".." */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
comment|/* 		     * Now seldata is properly filled in, 		     * but we still have to check for 0 as 		     * a special case. 		     */
if|if
condition|(
name|seldata
operator|.
name|start
operator|==
literal|0
operator|&&
name|seldata
operator|.
name|end
operator|==
literal|0
condition|)
block|{
comment|/* ":[0]" or perhaps ":[0..0]" */
name|parsestate
operator|.
name|oneBigWord
operator|=
name|TRUE
expr_stmt|;
name|newStr
operator|=
name|nstr
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|seldata
operator|.
name|start
operator|==
literal|0
operator|||
name|seldata
operator|.
name|end
operator|==
literal|0
condition|)
block|{
comment|/* ":[0..N]" or ":[N..0]" */
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
goto|goto
name|bad_modifier
goto|;
block|}
comment|/* 		     * Normal case: select the words 		     * described by seldata. 		     */
name|newStr
operator|=
name|VarSelectWords
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
operator|&
name|seldata
argument_list|)
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
case|case
literal|'g'
case|:
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|STRMOD_MATCHX
argument_list|(
name|tstr
argument_list|,
literal|"gmtime"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|tstr
index|[
literal|6
index|]
operator|==
literal|'='
condition|)
block|{
name|utc
operator|=
name|strtoul
argument_list|(
operator|&
name|tstr
index|[
literal|7
index|]
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
else|else
block|{
name|utc
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|6
expr_stmt|;
block|}
name|newStr
operator|=
name|VarStrftime
argument_list|(
name|nstr
argument_list|,
literal|1
argument_list|,
name|utc
argument_list|)
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|default_case
goto|;
block|}
break|break;
case|case
literal|'h'
case|:
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|STRMOD_MATCH
argument_list|(
name|tstr
argument_list|,
literal|"hash"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|newStr
operator|=
name|VarHash
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|4
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|default_case
goto|;
block|}
break|break;
case|case
literal|'l'
case|:
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|STRMOD_MATCHX
argument_list|(
name|tstr
argument_list|,
literal|"localtime"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
name|tstr
index|[
literal|9
index|]
operator|==
literal|'='
condition|)
block|{
name|utc
operator|=
name|strtoul
argument_list|(
operator|&
name|tstr
index|[
literal|10
index|]
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
else|else
block|{
name|utc
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|9
expr_stmt|;
block|}
name|newStr
operator|=
name|VarStrftime
argument_list|(
name|nstr
argument_list|,
literal|0
argument_list|,
name|utc
argument_list|)
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|default_case
goto|;
block|}
break|break;
case|case
literal|'t'
case|:
block|{
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|!=
name|endc
operator|&&
name|tstr
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
comment|/* 			 * Use the char (if any) at tstr[2] 			 * as the word separator. 			 */
name|VarPattern
name|pattern
decl_stmt|;
if|if
condition|(
name|tstr
index|[
literal|2
index|]
operator|!=
name|endc
operator|&&
operator|(
name|tstr
index|[
literal|3
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|3
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* ":ts<unrecognised><endc>" or 			     * ":ts<unrecognised>:" */
name|parsestate
operator|.
name|varSpace
operator|=
name|tstr
index|[
literal|2
index|]
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* ":ts<endc>" or ":ts:" */
name|parsestate
operator|.
name|varSpace
operator|=
literal|0
expr_stmt|;
comment|/* no separator */
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
specifier|const
name|char
modifier|*
name|xp
init|=
operator|&
name|tstr
index|[
literal|3
index|]
decl_stmt|;
name|int
name|base
init|=
literal|8
decl_stmt|;
comment|/* assume octal */
switch|switch
condition|(
name|tstr
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'n'
case|:
name|parsestate
operator|.
name|varSpace
operator|=
literal|'\n'
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|4
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|parsestate
operator|.
name|varSpace
operator|=
literal|'\t'
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
name|xp
operator|++
expr_stmt|;
goto|goto
name|get_numeric
goto|;
case|case
literal|'0'
case|:
name|base
operator|=
literal|0
expr_stmt|;
goto|goto
name|get_numeric
goto|;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tstr
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|get_numeric
label|:
name|parsestate
operator|.
name|varSpace
operator|=
name|strtoul
argument_list|(
name|xp
argument_list|,
operator|&
name|ep
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|':'
operator|&&
operator|*
name|ep
operator|!=
name|endc
condition|)
goto|goto
name|bad_modifier
goto|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
else|else
block|{
comment|/* 				     * ":ts<backslash><unrecognised>". 				     */
goto|goto
name|bad_modifier
goto|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* 			     * Found ":ts<unrecognised><unrecognised>". 			     */
goto|goto
name|bad_modifier
goto|;
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
comment|/* 			 * We cannot be certain that VarModify 			 * will be used - even if there is a 			 * subsequent modifier, so do a no-op 			 * VarSubstitute now to for str to be 			 * re-expanded without the spaces. 			 */
name|pattern
operator|.
name|flags
operator|=
name|VAR_SUB_ONE
expr_stmt|;
name|pattern
operator|.
name|lhs
operator|=
name|pattern
operator|.
name|rhs
operator|=
literal|"\032"
expr_stmt|;
name|pattern
operator|.
name|leftLen
operator|=
name|pattern
operator|.
name|rightLen
operator|=
literal|1
expr_stmt|;
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarSubstitute
argument_list|,
operator|&
name|pattern
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* 			 * Check for two-character options: 			 * ":tu", ":tl" 			 */
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
comment|/* absolute path */
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarRealpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'u'
condition|)
block|{
name|char
modifier|*
name|dp
init|=
name|bmake_strdup
argument_list|(
name|nstr
argument_list|)
decl_stmt|;
for|for
control|(
name|newStr
operator|=
name|dp
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
operator|*
name|dp
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|dp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|char
modifier|*
name|dp
init|=
name|bmake_strdup
argument_list|(
name|nstr
argument_list|)
decl_stmt|;
for|for
control|(
name|newStr
operator|=
name|dp
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
operator|*
name|dp
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|dp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'W'
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
name|parsestate
operator|.
name|oneBigWord
operator|=
operator|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'W'
operator|)
expr_stmt|;
name|newStr
operator|=
name|nstr
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
else|else
block|{
comment|/* Found ":t<unrecognised>:" or 			     * ":t<unrecognised><endc>". */
goto|goto
name|bad_modifier
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * Found ":t<unrecognised><unrecognised>". 			 */
goto|goto
name|bad_modifier
goto|;
block|}
block|}
else|else
block|{
comment|/* 		     * Found ":t<endc>" or ":t:". 		     */
goto|goto
name|bad_modifier
goto|;
block|}
break|break;
block|}
case|case
literal|'N'
case|:
case|case
literal|'M'
case|:
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|endpat
decl_stmt|;
comment|/* points just after end of pattern */
name|char
modifier|*
name|cp2
decl_stmt|;
name|Boolean
name|copy
decl_stmt|;
comment|/* pattern should be, or has been, copied */
name|Boolean
name|needSubst
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|copy
operator|=
name|FALSE
expr_stmt|;
name|needSubst
operator|=
name|FALSE
expr_stmt|;
name|nest
operator|=
literal|1
expr_stmt|;
comment|/* 		 * In the loop below, ignore ':' unless we are at 		 * (or back to) the original brace level. 		 * XXX This will likely not work right if $() and ${} 		 * are intermixed. 		 */
for|for
control|(
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
operator|*
name|cp
operator|==
literal|':'
operator|&&
name|nest
operator|==
literal|1
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|cp
index|[
literal|1
index|]
operator|==
name|startc
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|needSubst
condition|)
block|{
name|copy
operator|=
name|TRUE
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
name|needSubst
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|||
operator|*
name|cp
operator|==
literal|'{'
condition|)
operator|++
name|nest
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
operator|||
operator|*
name|cp
operator|==
literal|'}'
condition|)
block|{
operator|--
name|nest
expr_stmt|;
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|endpat
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
comment|/* 		     * Need to compress the \:'s out of the pattern, so 		     * allocate enough room to hold the uncompressed 		     * pattern (note that cp started at tstr+1, so 		     * cp - tstr takes the null byte into account) and 		     * compress the pattern into the space. 		     */
name|pattern
operator|=
name|bmake_malloc
argument_list|(
name|cp
operator|-
name|tstr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp2
operator|=
name|pattern
operator|,
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
name|cp
operator|<
name|endpat
condition|;
name|cp
operator|++
operator|,
name|cp2
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|cp
operator|+
literal|1
operator|<
name|endpat
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
name|endc
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
operator|*
name|cp
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|endpat
operator|=
name|cp2
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Either Var_Subst or VarModify will need a 		     * nul-terminated string soon, so construct one now. 		     */
name|pattern
operator|=
name|bmake_strndup
argument_list|(
name|tstr
operator|+
literal|1
argument_list|,
name|endpat
operator|-
operator|(
name|tstr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needSubst
condition|)
block|{
comment|/* 		     * pattern contains embedded '$', so use Var_Subst to 		     * expand it. 		     */
name|cp2
operator|=
name|pattern
expr_stmt|;
name|pattern
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cp2
argument_list|,
name|ctxt
argument_list|,
name|flags
operator||
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Pattern[%s] for [%s] is [%s]\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|nstr
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'M'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarMatch
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarNoMatch
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'S'
case|:
block|{
name|VarPattern
name|pattern
decl_stmt|;
name|Var_Parse_State
name|tmpparsestate
decl_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|tmpparsestate
operator|=
name|parsestate
expr_stmt|;
name|delim
operator|=
name|tstr
index|[
literal|1
index|]
expr_stmt|;
name|tstr
operator|+=
literal|2
expr_stmt|;
comment|/* 		 * If pattern begins with '^', it is anchored to the 		 * start of the word -- skip over it and flag pattern. 		 */
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'^'
condition|)
block|{
name|pattern
operator|.
name|flags
operator||=
name|VAR_MATCH_START
expr_stmt|;
name|tstr
operator|+=
literal|1
expr_stmt|;
block|}
name|cp
operator|=
name|tstr
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|pattern
operator|.
name|flags
argument_list|,
operator|&
name|pattern
operator|.
name|leftLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|,
operator|&
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Check for global substitution. If 'g' after the final 		 * delimiter, substitution is global and is marked that 		 * way. 		 */
for|for
control|(
init|;
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'g'
case|:
name|pattern
operator|.
name|flags
operator||=
name|VAR_SUB_GLOBAL
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
name|pattern
operator|.
name|flags
operator||=
name|VAR_SUB_ONE
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|tmpparsestate
operator|.
name|oneBigWord
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|tmpparsestate
argument_list|,
name|nstr
argument_list|,
name|VarSubstitute
argument_list|,
operator|&
name|pattern
argument_list|)
expr_stmt|;
comment|/* 		 * Free the two strings. 		 */
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
case|case
literal|'?'
case|:
block|{
name|VarPattern
name|pattern
decl_stmt|;
name|Boolean
name|value
decl_stmt|;
name|int
name|cond_rc
decl_stmt|;
name|int
name|lhs_flags
decl_stmt|,
name|rhs_flags
decl_stmt|;
comment|/* find ':', and then substitute accordingly */
if|if
condition|(
name|flags
operator|&
name|VARF_WANTRES
condition|)
block|{
name|cond_rc
operator|=
name|Cond_EvalExpression
argument_list|(
name|NULL
argument_list|,
name|v
operator|->
name|name
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_rc
operator|==
name|COND_INVALID
condition|)
block|{
name|lhs_flags
operator|=
name|rhs_flags
operator|=
name|VAR_NOSUBST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
condition|)
block|{
name|lhs_flags
operator|=
literal|0
expr_stmt|;
name|rhs_flags
operator|=
name|VAR_NOSUBST
expr_stmt|;
block|}
else|else
block|{
name|lhs_flags
operator|=
name|VAR_NOSUBST
expr_stmt|;
name|rhs_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* we are just consuming and discarding */
name|cond_rc
operator|=
name|value
operator|=
literal|0
expr_stmt|;
name|lhs_flags
operator|=
name|rhs_flags
operator|=
name|VAR_NOSUBST
expr_stmt|;
block|}
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|++
name|tstr
expr_stmt|;
name|delim
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|lhs_flags
argument_list|,
operator|&
name|pattern
operator|.
name|leftLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* BROPEN or PROPEN */
name|delim
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|rhs_flags
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|termc
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cond_rc
operator|==
name|COND_INVALID
condition|)
block|{
name|Error
argument_list|(
literal|"Bad conditional expression `%s' in %s?%s:%s"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|pattern
operator|.
name|lhs
argument_list|,
name|pattern
operator|.
name|rhs
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|value
condition|)
block|{
name|newStr
operator|=
name|UNCONST
argument_list|(
name|pattern
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_KEEP
expr_stmt|;
block|}
break|break;
block|}
ifndef|#
directive|ifndef
name|NO_REGEX
case|case
literal|'C'
case|:
block|{
name|VarREPattern
name|pattern
decl_stmt|;
name|char
modifier|*
name|re
decl_stmt|;
name|int
name|error
decl_stmt|;
name|Var_Parse_State
name|tmpparsestate
decl_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|tmpparsestate
operator|=
name|parsestate
expr_stmt|;
name|delim
operator|=
name|tstr
index|[
literal|1
index|]
expr_stmt|;
name|tstr
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
name|tstr
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|replace
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
init|;
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'g'
case|:
name|pattern
operator|.
name|flags
operator||=
name|VAR_SUB_GLOBAL
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
name|pattern
operator|.
name|flags
operator||=
name|VAR_SUB_ONE
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|tmpparsestate
operator|.
name|oneBigWord
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|error
operator|=
name|regcomp
argument_list|(
operator|&
name|pattern
operator|.
name|re
argument_list|,
name|re
argument_list|,
name|REG_EXTENDED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|cp
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|VarREError
argument_list|(
name|error
argument_list|,
operator|&
name|pattern
operator|.
name|re
argument_list|,
literal|"RE substitution error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
operator|.
name|replace
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|pattern
operator|.
name|nsub
operator|=
name|pattern
operator|.
name|re
operator|.
name|re_nsub
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pattern
operator|.
name|nsub
operator|<
literal|1
condition|)
name|pattern
operator|.
name|nsub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pattern
operator|.
name|nsub
operator|>
literal|10
condition|)
name|pattern
operator|.
name|nsub
operator|=
literal|10
expr_stmt|;
name|pattern
operator|.
name|matches
operator|=
name|bmake_malloc
argument_list|(
name|pattern
operator|.
name|nsub
operator|*
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
argument_list|)
expr_stmt|;
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|tmpparsestate
argument_list|,
name|nstr
argument_list|,
name|VarRESubstitute
argument_list|,
operator|&
name|pattern
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|pattern
operator|.
name|re
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
operator|.
name|replace
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
operator|.
name|matches
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
literal|'Q'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarQuote
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'T'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarTail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'H'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarHead
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'E'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarSuffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'R'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarRoot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'r'
case|:
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* make sure it is set */
if|if
condition|(
name|STRMOD_MATCHX
argument_list|(
name|tstr
argument_list|,
literal|"range"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tstr
index|[
literal|5
index|]
operator|==
literal|'='
condition|)
block|{
name|n
operator|=
name|strtoul
argument_list|(
operator|&
name|tstr
index|[
literal|6
index|]
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|5
expr_stmt|;
block|}
name|newStr
operator|=
name|VarRange
argument_list|(
name|nstr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
case|case
literal|'O'
case|:
block|{
name|char
name|otype
decl_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
comment|/* skip to the rest in any case */
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|otype
operator|=
literal|'s'
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|tstr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|otype
operator|=
name|tstr
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad_modifier
goto|;
block|}
name|newStr
operator|=
name|VarOrder
argument_list|(
name|nstr
argument_list|,
name|otype
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarUniq
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
ifdef|#
directive|ifdef
name|SUNSHCMD
case|case
literal|'s'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'h'
operator|&&
operator|(
name|tstr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|VARF_WANTRES
condition|)
block|{
name|newStr
operator|=
name|Cmd_Exec
argument_list|(
name|nstr
argument_list|,
operator|&
name|emsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|emsg
condition|)
name|Error
argument_list|(
name|emsg
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
block|}
else|else
name|newStr
operator|=
name|varNoError
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
goto|goto
name|default_case
goto|;
endif|#
directive|endif
default|default:
name|default_case
label|:
block|{
ifdef|#
directive|ifdef
name|SYSVVARSUB
comment|/* 	     * This can either be a bogus modifier or a System-V 	     * substitution command. 	     */
name|VarPattern
name|pattern
decl_stmt|;
name|Boolean
name|eqFound
decl_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|eqFound
operator|=
name|FALSE
expr_stmt|;
comment|/* 	     * First we make a pass through the string trying 	     * to verify it is a SYSV-make-style translation: 	     * it must be:<string1>=<string2>) 	     */
name|cp
operator|=
name|tstr
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|cnt
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
name|eqFound
operator|=
name|TRUE
expr_stmt|;
comment|/* continue looking for endc */
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
condition|)
name|cnt
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|startc
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
operator|&&
name|eqFound
condition|)
block|{
comment|/* 		 * Now we break this sucker into the lhs and 		 * rhs. We must null terminate them of course. 		 */
name|delim
operator|=
literal|'='
expr_stmt|;
name|cp
operator|=
name|tstr
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
operator|&
name|pattern
operator|.
name|flags
argument_list|,
operator|&
name|pattern
operator|.
name|leftLen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|delim
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|,
operator|&
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * SYSV modifications happen through the whole 		 * string. Note the pattern is anchored at the end. 		 */
name|termc
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pattern
operator|.
name|leftLen
operator|==
literal|0
operator|&&
operator|*
name|nstr
operator|==
literal|'\0'
condition|)
block|{
name|newStr
operator|=
name|nstr
expr_stmt|;
comment|/* special case */
block|}
else|else
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|ctxt
argument_list|,
operator|&
name|parsestate
argument_list|,
name|nstr
argument_list|,
name|VarSYSVMatch
argument_list|,
operator|&
name|pattern
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|UNCONST
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|Error
argument_list|(
literal|"Unknown modifier '%c'"
argument_list|,
operator|*
name|tstr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
operator|!=
name|endc
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
continue|continue;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|newStr
operator|=
name|var_Error
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Result[%s] of :%c is \"%s\"\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|modifier
argument_list|,
name|newStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newStr
operator|!=
name|nstr
condition|)
block|{
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|NULL
expr_stmt|;
block|}
name|nstr
operator|=
name|newStr
expr_stmt|;
if|if
condition|(
name|nstr
operator|!=
name|var_Error
operator|&&
name|nstr
operator|!=
name|varNoError
condition|)
block|{
operator|*
name|freePtr
operator|=
name|nstr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termc
operator|==
literal|'\0'
operator|&&
name|endc
operator|!=
literal|'\0'
condition|)
block|{
name|Error
argument_list|(
literal|"Unclosed variable specification (expecting '%c') for \"%s\" (value \"%s\") modifier %c"
argument_list|,
name|endc
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|nstr
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termc
operator|==
literal|':'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|tstr
operator|=
name|cp
expr_stmt|;
block|}
name|out
label|:
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
expr_stmt|;
return|return
operator|(
name|nstr
operator|)
return|;
name|bad_modifier
label|:
comment|/* "{(" */
name|Error
argument_list|(
literal|"Bad modifier `:%.*s' for %s"
argument_list|,
operator|(
name|int
operator|)
name|strcspn
argument_list|(
name|tstr
argument_list|,
literal|":)}"
argument_list|)
argument_list|,
name|tstr
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|cleanup
label|:
operator|*
name|lengthPtr
operator|=
name|cp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|delim
operator|!=
literal|'\0'
condition|)
name|Error
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|freePtr
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Parse --  *	Given the start of a variable invocation, extract the variable  *	name and find its value, then modify it according to the  *	specification.  *  * Input:  *	str		The string to parse  *	ctxt		The context for the variable  *	flags		VARF_UNDEFERR	if undefineds are an error  *			VARF_WANTRES	if we actually want the result  *			VARF_ASSIGN	if we are in a := assignment  *	lengthPtr	OUT: The length of the specification  *	freePtr		OUT: Non-NULL if caller should free *freePtr  *  * Results:  *	The (possibly-modified) value of the variable or var_Error if the  *	specification is invalid. The length of the specification is  *	placed in *lengthPtr (for invalid specifications, this is just  *	2...?).  *	If *freePtr is non-NULL then it's a pointer that the caller  *	should pass to free() to free memory used by the result.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* coverity[+alloc : arg-*4] */
end_comment

begin_function
name|char
modifier|*
name|Var_Parse
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|lengthPtr
parameter_list|,
name|void
modifier|*
modifier|*
name|freePtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tstr
decl_stmt|;
comment|/* Pointer into str */
name|Var
modifier|*
name|v
decl_stmt|;
comment|/* Variable in invocation */
name|Boolean
name|haveModifier
decl_stmt|;
comment|/* TRUE if have modifiers for the variable */
name|char
name|endc
decl_stmt|;
comment|/* Ending character when variable in parens 				 * or braces */
name|char
name|startc
decl_stmt|;
comment|/* Starting character when variable in parens 				 * or braces */
name|int
name|vlen
decl_stmt|;
comment|/* Length of variable name */
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Points to original start of str */
name|char
modifier|*
name|nstr
decl_stmt|;
comment|/* New string, used during expansion */
name|Boolean
name|dynamic
decl_stmt|;
comment|/* TRUE if the variable is local and we're 				 * expanding it in a non-local context. This 				 * is done to support dynamic sources. The 				 * result is just the invocation, unaltered */
specifier|const
name|char
modifier|*
name|extramodifiers
decl_stmt|;
comment|/* extra modifiers to apply first */
name|char
name|name
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|freePtr
operator|=
name|NULL
expr_stmt|;
name|extramodifiers
operator|=
name|NULL
expr_stmt|;
name|dynamic
operator|=
name|FALSE
expr_stmt|;
name|start
operator|=
name|str
expr_stmt|;
name|startc
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|startc
operator|!=
name|PROPEN
operator|&&
name|startc
operator|!=
name|BROPEN
condition|)
block|{
comment|/* 	 * If it's not bounded by braces of some sort, life is much simpler. 	 * We just need to check for the first character and return the 	 * value if it exists. 	 */
comment|/* Error out some really stupid names */
if|if
condition|(
name|startc
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
literal|")}:$"
argument_list|,
name|startc
argument_list|)
condition|)
block|{
operator|*
name|lengthPtr
operator|=
literal|1
expr_stmt|;
return|return
name|var_Error
return|;
block|}
name|name
index|[
literal|0
index|]
operator|=
name|startc
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
operator|*
name|lengthPtr
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|)
block|{
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set 		 * when dynamic sources are expanded. 		 */
switch|switch
condition|(
name|str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'@'
case|:
return|return
name|UNCONST
argument_list|(
literal|"$(.TARGET)"
argument_list|)
return|;
case|case
literal|'%'
case|:
return|return
name|UNCONST
argument_list|(
literal|"$(.MEMBER)"
argument_list|)
return|;
case|case
literal|'*'
case|:
return|return
name|UNCONST
argument_list|(
literal|"$(.PREFIX)"
argument_list|)
return|;
case|case
literal|'!'
case|:
return|return
name|UNCONST
argument_list|(
literal|"$(.ARCHIVE)"
argument_list|)
return|;
block|}
block|}
comment|/* 	     * Error 	     */
return|return
operator|(
name|flags
operator|&
name|VARF_UNDEFERR
operator|)
condition|?
name|var_Error
else|:
name|varNoError
return|;
block|}
else|else
block|{
name|haveModifier
operator|=
name|FALSE
expr_stmt|;
name|tstr
operator|=
operator|&
name|str
index|[
literal|1
index|]
expr_stmt|;
name|endc
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Holds the variable name */
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|endc
operator|=
name|startc
operator|==
name|PROPEN
condition|?
name|PRCLOSE
else|:
name|BRCLOSE
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Skip to the end character or a colon, whichever comes first. 	 */
for|for
control|(
name|tstr
operator|=
name|str
operator|+
literal|2
init|;
operator|*
name|tstr
operator|!=
literal|'\0'
condition|;
name|tstr
operator|++
control|)
block|{
comment|/* 	     * Track depth so we can spot parse errors. 	     */
if|if
condition|(
operator|*
name|tstr
operator|==
name|startc
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tstr
operator|==
name|endc
condition|)
block|{
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|depth
operator|==
literal|1
operator|&&
operator|*
name|tstr
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
comment|/* 	     * A variable inside a variable, expand 	     */
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'$'
condition|)
block|{
name|int
name|rlen
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
name|char
modifier|*
name|rval
init|=
name|Var_Parse
argument_list|(
name|tstr
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|rlen
argument_list|,
operator|&
name|freeIt
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|!=
name|NULL
condition|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|tstr
operator|+=
name|rlen
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|tstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tstr
operator|==
literal|':'
condition|)
block|{
name|haveModifier
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tstr
operator|==
name|endc
condition|)
block|{
name|haveModifier
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * If we never did find the end character, return NULL 	     * right now, setting the length to be the distance to 	     * the end of the string, since that's what make does. 	     */
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|str
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
name|str
operator|=
name|Buf_GetAll
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, str points into newly allocated memory from 	 * buf, containing only the name of the variable. 	 * 	 * start and tstr point into the const string that was pointed 	 * to by the original value of the str parameter.  start points 	 * to the '$' at the beginning of the string, while tstr points 	 * to the char just after the end of the variable name -- this 	 * will be '\0', ':', PRCLOSE, or BRCLOSE. 	 */
name|v
operator|=
name|VarFind
argument_list|(
name|str
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
comment|/* 	 * Check also for bogus D and F forms of local variables since we're 	 * in a local context and the name is the right length. 	 */
if|if
condition|(
operator|(
name|v
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_CMD
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
operator|&&
operator|(
name|vlen
operator|==
literal|2
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|&&
name|strchr
argument_list|(
literal|"@%?*!<>"
argument_list|,
name|str
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Well, it's local -- go look for it. 	     */
name|name
index|[
literal|0
index|]
operator|=
operator|*
name|str
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
name|extramodifiers
operator|=
literal|"H:"
expr_stmt|;
block|}
else|else
block|{
comment|/* F */
name|extramodifiers
operator|=
literal|"T:"
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|vlen
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
operator|(
name|vlen
operator|==
literal|2
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set 		 * when dynamic sources are expanded. 		 */
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
name|dynamic
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|vlen
operator|>
literal|2
operator|)
operator|&&
operator|(
operator|*
name|str
operator|==
literal|'.'
operator|)
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|vlen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|".TARGET"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|".ARCHIVE"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|".PREFIX"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|".MEMBER"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dynamic
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|haveModifier
condition|)
block|{
comment|/* 		 * No modifiers -- have specification length so we can return 		 * now. 		 */
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|char
modifier|*
name|pstr
init|=
name|bmake_strndup
argument_list|(
name|start
argument_list|,
operator|*
name|lengthPtr
argument_list|)
decl_stmt|;
operator|*
name|freePtr
operator|=
name|pstr
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|pstr
operator|)
return|;
block|}
else|else
block|{
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|VARF_UNDEFERR
operator|)
condition|?
name|var_Error
else|:
name|varNoError
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Still need to get to the end of the variable specification, 		 * so kludge up a Var structure for the modifications 		 */
name|v
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|UNCONST
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|VAR_JUNK
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_IN_USE
condition|)
block|{
name|Fatal
argument_list|(
literal|"Variable %s is recursive."
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_IN_USE
expr_stmt|;
block|}
comment|/*      * Before doing any modification, we have to make sure the value      * has been fully expanded. If it looks like recursion might be      * necessary (there's a dollar sign somewhere in the variable's value)      * we just call Var_Subst to do any other substitutions that are      * necessary. Note that the value returned by Var_Subst will have      * been dynamically-allocated, so it will need freeing when we      * return.      */
name|nstr
operator|=
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|nstr
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nstr
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|nstr
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|nstr
expr_stmt|;
block|}
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_IN_USE
expr_stmt|;
if|if
condition|(
operator|(
name|nstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|haveModifier
operator|||
name|extramodifiers
operator|!=
name|NULL
operator|)
condition|)
block|{
name|void
modifier|*
name|extraFree
decl_stmt|;
name|int
name|used
decl_stmt|;
name|extraFree
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|extramodifiers
operator|!=
name|NULL
condition|)
block|{
name|nstr
operator|=
name|ApplyModifiers
argument_list|(
name|nstr
argument_list|,
name|extramodifiers
argument_list|,
literal|'('
argument_list|,
literal|')'
argument_list|,
name|v
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|extraFree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|haveModifier
condition|)
block|{
comment|/* Skip initial colon. */
name|tstr
operator|++
expr_stmt|;
name|nstr
operator|=
name|ApplyModifiers
argument_list|(
name|nstr
argument_list|,
name|tstr
argument_list|,
name|startc
argument_list|,
name|endc
argument_list|,
name|v
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|used
argument_list|,
name|freePtr
argument_list|)
expr_stmt|;
name|tstr
operator|+=
name|used
expr_stmt|;
name|free
argument_list|(
name|extraFree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|freePtr
operator|=
name|extraFree
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|tstr
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
name|Boolean
name|destroy
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|nstr
operator|!=
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|destroy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Returning the value unmodified, so tell the caller to free 	     * the thing. 	     */
operator|*
name|freePtr
operator|=
name|nstr
expr_stmt|;
block|}
name|VarFreeEnv
argument_list|(
name|v
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
comment|/* 	 * Perform any free'ing needed and set *freePtr to NULL so the caller 	 * doesn't try to free a static pointer. 	 * If VAR_KEEP is also set then we want to keep str as is. 	 */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_KEEP
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
condition|)
block|{
name|nstr
operator|=
name|bmake_strndup
argument_list|(
name|start
argument_list|,
operator|*
name|lengthPtr
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|nstr
expr_stmt|;
block|}
else|else
block|{
name|nstr
operator|=
operator|(
name|flags
operator|&
name|VARF_UNDEFERR
operator|)
condition|?
name|var_Error
else|:
name|varNoError
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nstr
operator|!=
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
condition|)
name|Buf_Destroy
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Subst  --  *	Substitute for all variables in the given string in the given context  *	If flags& VARF_UNDEFERR, Parse_Error will be called when an undefined  *	variable is encountered.  *  * Input:  *	var		Named variable || NULL for all  *	str		the string which to substitute  *	ctxt		the context wherein to find variables  *	flags		VARF_UNDEFERR	if undefineds are an error  *			VARF_WANTRES	if we actually want the result  *			VARF_ASSIGN	if we are in a := assignment  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None. The old string must be freed by the caller  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_Subst
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for forming things */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Value to substitute for a variable */
name|int
name|length
decl_stmt|;
comment|/* Length of the variable invocation */
name|Boolean
name|trailingBslash
decl_stmt|;
comment|/* variable ends in \ */
name|void
modifier|*
name|freeIt
init|=
name|NULL
decl_stmt|;
comment|/* Set if it should be freed */
specifier|static
name|Boolean
name|errorReported
decl_stmt|;
comment|/* Set true if an error has already 				     * been reported to prevent a plethora 				     * of messages when recursing */
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errorReported
operator|=
name|FALSE
expr_stmt|;
name|trailingBslash
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
operator|&&
name|trailingBslash
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|str
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
comment|/* 	     * A dollar sign may be escaped either with another dollar sign. 	     * In such a case, we skip over the escape character and store the 	     * dollar sign into the buffer directly. 	     */
if|if
condition|(
name|save_dollars
operator|&&
operator|(
name|flags
operator|&
name|VARF_ASSIGN
operator|)
condition|)
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|!=
literal|'$'
condition|)
block|{
comment|/* 	     * Skip as many characters as possible -- either to the end of 	     * the string or to the next dollar sign (variable invocation). 	     */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|str
operator|++
init|;
operator|*
name|str
operator|!=
literal|'$'
operator|&&
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
continue|continue;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|str
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var
operator|!=
name|NULL
condition|)
block|{
name|int
name|expand
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* A trailing $ is kind of a special case */
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|expand
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
name|PROPEN
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
name|BROPEN
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
operator|*
name|var
operator|||
name|strlen
argument_list|(
name|var
argument_list|)
operator|>
literal|1
condition|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
literal|2
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
name|expand
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|expand
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 			 * Scan up to the end of the variable name. 			 */
for|for
control|(
name|p
operator|=
operator|&
name|str
index|[
literal|2
index|]
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
name|PRCLOSE
operator|&&
operator|*
name|p
operator|!=
name|BRCLOSE
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
break|break;
comment|/* 			 * A variable inside the variable. We cannot expand 			 * the external variable yet, so we try again with 			 * the nested one 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|p
operator|-
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|var
argument_list|,
name|str
operator|+
literal|2
argument_list|,
name|p
operator|-
name|str
operator|-
literal|2
argument_list|)
operator|!=
literal|0
operator|||
name|var
index|[
name|p
operator|-
name|str
operator|-
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			     * Not the variable we want to expand, scan 			     * until the next variable 			     */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'$'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
continue|continue;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|p
operator|-
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|p
expr_stmt|;
name|expand
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|expand
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|expand
condition|)
continue|continue;
block|}
name|val
operator|=
name|Var_Parse
argument_list|(
name|str
argument_list|,
name|ctxt
argument_list|,
name|flags
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
comment|/* 	     * When we come down here, val should either point to the 	     * value of this variable, suitably modified, or be NULL. 	     * Length should be the total length of the potential 	     * variable invocation (from $ to end character...) 	     */
if|if
condition|(
name|val
operator|==
name|var_Error
operator|||
name|val
operator|==
name|varNoError
condition|)
block|{
comment|/* 		 * If performing old-time variable substitution, skip over 		 * the variable and continue with the substitution. Otherwise, 		 * store the dollar sign and advance str so we continue with 		 * the string... 		 */
if|if
condition|(
name|oldVars
condition|)
block|{
name|str
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|VARF_UNDEFERR
operator|)
operator|||
name|val
operator|==
name|var_Error
condition|)
block|{
comment|/* 		     * If variable is undefined, complain and skip the 		     * variable. The complaint will stop us from doing anything 		     * when the file is parsed. 		     */
if|if
condition|(
operator|!
name|errorReported
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Undefined variable \"%.*s\""
argument_list|,
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|str
operator|+=
name|length
expr_stmt|;
name|errorReported
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We've now got a variable structure to store in. But first, 		 * advance the string pointer. 		 */
name|str
operator|+=
name|length
expr_stmt|;
comment|/* 		 * Copy all the characters from the variable value straight 		 * into the new string. 		 */
name|length
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|length
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|trailingBslash
operator|=
name|length
operator|>
literal|0
operator|&&
name|val
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\\'
expr_stmt|;
block|}
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|freeIt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|Buf_DestroyCompact
argument_list|(
operator|&
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_GetTail --  *	Return the tail from each of a list of words. Used to set the  *	System V local variables.  *  * Input:  *	file		Filename to modify  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|char * Var_GetTail(char *file) {     return(VarModify(file, VarTail, NULL)); }
comment|/*-  *-----------------------------------------------------------------------  * Var_GetHead --  *	Find the leading components of a (list of) filename(s).  *	XXX: VarHead does not replace foo by ., as (sun) System V make  *	does.  *  * Input:  *	file		Filename to manipulate  *  * Results:  *	The leading components.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_endif
unit|char * Var_GetHead(char *file) {     return(VarModify(file, VarHead, NULL)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Init --  *	Initialize the module  *  * Results:  *	None  *  * Side Effects:  *	The VAR_CMD and VAR_GLOBAL contexts are created  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|VAR_INTERNAL
operator|=
name|Targ_NewGN
argument_list|(
literal|"Internal"
argument_list|)
expr_stmt|;
name|VAR_GLOBAL
operator|=
name|Targ_NewGN
argument_list|(
literal|"Global"
argument_list|)
expr_stmt|;
name|VAR_CMD
operator|=
name|Targ_NewGN
argument_list|(
literal|"Command"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Var_End
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/****************** PRINT DEBUGGING INFO *****************/
end_comment

begin_function
specifier|static
name|void
name|VarPrintVar
parameter_list|(
name|void
modifier|*
name|vp
parameter_list|)
block|{
name|Var
modifier|*
name|v
init|=
operator|(
name|Var
operator|*
operator|)
name|vp
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%-16s = %s\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|Buf_GetAll
argument_list|(
operator|&
name|v
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Dump --  *	print all variables in a context  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Dump
parameter_list|(
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Hash_Search
name|search
decl_stmt|;
name|Hash_Entry
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|VarPrintVar
argument_list|(
name|Hash_GetValue
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

