begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Mips interrupts.  *  *<hr>$Revision: 52004 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
end_if

begin_comment
comment|/* Backtrace is only available with the new toolchain.  */
end_comment

begin_include
include|#
directive|include
file|<execinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __U_BOOT__ */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-uart.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pow.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ebt3000.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-init.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"../../bootloader/u-boot/include/octeon_mem_map.h"
end_include

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_stage1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_debug_handler_stage1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_cache_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|cvmx_interrupt_in_isr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Internal status the interrupt registration  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_interrupt_func_t
name|handlers
index|[
literal|256
index|]
decl_stmt|;
comment|/**< One function to call per interrupt */
name|void
modifier|*
name|data
index|[
literal|256
index|]
decl_stmt|;
comment|/**< User data per interrupt */
name|cvmx_interrupt_exception_t
name|exception_handler
decl_stmt|;
block|}
name|cvmx_interrupt_state_t
typedef|;
end_typedef

begin_comment
comment|/**  * Internal state the interrupt registration  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_interrupt_state_t
name|cvmx_interrupt_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_interrupt_default_lock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __U_BOOT__ */
end_comment

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_define
define|#
directive|define
name|HI32
parameter_list|(
name|data64
parameter_list|)
value|((uint32_t)(data64>> 32))
end_define

begin_define
define|#
directive|define
name|LO32
parameter_list|(
name|data64
parameter_list|)
value|((uint32_t)(data64& 0xFFFFFFFF))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|reg_names
index|[]
index|[
literal|32
index|]
init|=
block|{
literal|"r0"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * version of printf that works better in exception context.  *  * @param format  */
end_comment

begin_function
name|void
name|cvmx_safe_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|count
operator|=
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|count
operator|=
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
comment|/* Spin until there is room */
do|do
block|{
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_SIM_SPEED
argument_list|)
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Just to reduce the load on the system */
endif|#
directive|endif
block|}
do|while
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Textual descriptions of cause codes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|cause_names
index|[]
index|[
literal|128
index|]
init|=
block|{
comment|/*  0 */
literal|"Interrupt"
block|,
comment|/*  1 */
literal|"TLB modification"
block|,
comment|/*  2 */
literal|"tlb load/fetch"
block|,
comment|/*  3 */
literal|"tlb store"
block|,
comment|/*  4 */
literal|"address exc, load/fetch"
block|,
comment|/*  5 */
literal|"address exc, store"
block|,
comment|/*  6 */
literal|"bus error, instruction fetch"
block|,
comment|/*  7 */
literal|"bus error, load/store"
block|,
comment|/*  8 */
literal|"syscall"
block|,
comment|/*  9 */
literal|"breakpoint"
block|,
comment|/* 10 */
literal|"reserved instruction"
block|,
comment|/* 11 */
literal|"cop unusable"
block|,
comment|/* 12 */
literal|"arithmetic overflow"
block|,
comment|/* 13 */
literal|"trap"
block|,
comment|/* 14 */
literal|""
block|,
comment|/* 15 */
literal|"floating point exc"
block|,
comment|/* 16 */
literal|""
block|,
comment|/* 17 */
literal|""
block|,
comment|/* 18 */
literal|"cop2 exception"
block|,
comment|/* 19 */
literal|""
block|,
comment|/* 20 */
literal|""
block|,
comment|/* 21 */
literal|""
block|,
comment|/* 22 */
literal|"mdmx unusable"
block|,
comment|/* 23 */
literal|"watch"
block|,
comment|/* 24 */
literal|"machine check"
block|,
comment|/* 25 */
literal|""
block|,
comment|/* 26 */
literal|""
block|,
comment|/* 27 */
literal|""
block|,
comment|/* 28 */
literal|""
block|,
comment|/* 29 */
literal|""
block|,
comment|/* 30 */
literal|"cache error"
block|,
comment|/* 31 */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @INTERNAL  * print_reg64  * @param name   Name of the value to print  * @param reg    Value to print  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_reg64
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|reg
parameter_list|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%08x%08x\n"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Dump all useful registers to the console  *  * @param registers CPU register to dump  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_dump_registers
parameter_list|(
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|)
block|{
name|uint64_t
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
block|{
name|r1
operator|=
name|registers
index|[
name|reg
index|]
expr_stmt|;
name|r2
operator|=
name|registers
index|[
name|reg
operator|+
literal|16
index|]
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%3s ($%02d): 0x%08x%08x \t %3s ($%02d): 0x%08x%08x\n"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|reg
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|r1
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|r1
argument_list|)
argument_list|,
name|reg_names
index|[
name|reg
operator|+
literal|16
index|]
argument_list|,
name|reg
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|r2
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CVMX_MF_COP0
argument_list|(
name|r1
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_CAUSE"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r2
argument_list|,
name|COP0_STATUS
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_STATUS"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r1
argument_list|,
name|COP0_BADVADDR
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_BADVADDR"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r2
argument_list|,
name|COP0_EPC
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_EPC"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Default exception handler. Prints out the exception  * cause decode and all relevant registers.  *  * @param registers Registers at time of the exception  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
comment|/* __U_BOOT__ */
name|void
name|__cvmx_interrupt_default_exception_handler
parameter_list|(
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|)
block|{
name|uint64_t
name|trap_print_cause
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|ebt3000_str_write
argument_list|(
literal|"Trap"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CVMX_MF_COP0
argument_list|(
name|trap_print_cause
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|str
operator|=
name|cause_names
index|[
operator|(
name|trap_print_cause
operator|>>
literal|2
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"Core %d: Unhandled Exception. Cause register decodes to:\n%s\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_get_core_num
argument_list|()
argument_list|,
name|str
operator|&&
operator|*
name|str
condition|?
name|str
else|:
literal|"Reserved exception cause"
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
operator|&&
operator|!
name|defined
argument_list|(
name|OCTEON_DISABLE_BACKTRACE
argument_list|)
name|cvmx_safe_printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
name|__octeon_print_backtrace_func
argument_list|(
operator|(
name|__octeon_backtrace_printf_t
operator|)
name|cvmx_safe_printf
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
name|CVMX_BREAK
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Interrupts are suppressed when we are in the exception 	   handler (because of SR[EXL]).  Spin and poll the uart 	   status and see if the debugger is trying to stop us. */
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|dr
condition|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
comment|/* Pulse the MCD0 signal. */
asm|asm
specifier|volatile
asm|( 	    ".set push\n" 	    ".set noreorder\n" 	    ".set mips64\n" 	    "dmfc0 %0, $22\n" 	    "ori   %0, %0, 0x10\n" 	    "dmtc0 %0, $22\n" 	    ".set pop\n" 	    : "=r" (tmp));
block|}
block|}
endif|#
directive|endif
comment|/* __U_BOOT__ */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Default interrupt handler if the user doesn't register one.  *  * @param irq_number IRQ that caused this interrupt  * @param registers  Register at the time of the interrupt  * @param user_arg   Unused optional user data  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_default
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"cvmx_interrupt_default: Received interrupt %d\n"
argument_list|,
name|irq_number
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Handler for interrupt lines 2 and 3. These are directly tied  * to the CIU. The handler queres the status of the CIU and  * calls the secondary handler for the CIU interrupt that  * occurred.  *  * @param irq_number Interrupt number that fired (2 or 3)  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|int
name|ciu_offset
init|=
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
name|irq_number
operator|-
literal|2
decl_stmt|;
name|uint64_t
name|irq_mask
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_SUM0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|irq
init|=
literal|8
decl_stmt|;
comment|/* Handle EN0 sources */
while|while
condition|(
name|irq_mask
condition|)
block|{
if|if
condition|(
name|irq_mask
operator|&
literal|1
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq
index|]
operator|(
name|irq
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq
index|]
operator|)
expr_stmt|;
return|return;
block|}
name|irq_mask
operator|=
name|irq_mask
operator|>>
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
block|}
comment|/* Handle EN1 sources */
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INT_SUM1
argument_list|)
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
expr_stmt|;
name|irq
operator|=
literal|8
operator|+
literal|64
expr_stmt|;
while|while
condition|(
name|irq_mask
condition|)
block|{
if|if
condition|(
name|irq_mask
operator|&
literal|1
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq
index|]
operator|(
name|irq
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq
index|]
operator|)
expr_stmt|;
return|return;
block|}
name|irq_mask
operator|=
name|irq_mask
operator|>>
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Called for all RML interrupts. This is usually an ECC error  *  * @param irq_number Interrupt number that we're being called for  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ecc
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_error_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Process an interrupt request  *  * @param registers Registers at time of interrupt / exception  * Registers 0-31 are standard MIPS, others specific to this routine  * @return  */
end_comment

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
name|registers
index|[
literal|35
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
name|registers
index|[
literal|35
index|]
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|uint64_t
name|cause
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
name|uint64_t
name|cache_err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|exc_vec
decl_stmt|;
comment|/* Determine the cause of the interrupt */
asm|asm
specifier|volatile
asm|("dmfc0 %0,$13,0" : "=r" (cause));
asm|asm
specifier|volatile
asm|("dmfc0 %0,$12,0" : "=r" (status));
comment|/* In case of exception, clear all interrupts to avoid recursive interrupts.        Also clear EXL bit to display the correct PC value. */
if|if
condition|(
operator|(
name|cause
operator|&
literal|0x7c
operator|)
operator|==
literal|0
condition|)
block|{
asm|asm
specifier|volatile
asm|("dmtc0 %0, $12, 0" : : "r" (status& ~(0xff02)));
block|}
comment|/* The assembly stub at each exception vector saves its address in k1 when     ** it calls the stage 2 handler.  We use this to compute the exception vector     ** that brought us here */
name|exc_vec
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|registers
index|[
literal|27
index|]
operator|&
literal|0x780
argument_list|)
expr_stmt|;
comment|/* Mask off bits we need to ignore */
comment|/* Check for cache errors.  The cache errors go to a separate exception vector,     ** so we will only check these if we got here from a cache error exception, and     ** the ERL (error level) bit is set. */
if|if
condition|(
name|exc_vec
operator|==
literal|0x100
operator|&&
operator|(
name|status
operator|&
literal|0x4
operator|)
condition|)
block|{
name|i
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|CVMX_MF_CACHE_ERR
argument_list|(
name|cache_err
argument_list|)
expr_stmt|;
comment|/* Use copy of DCACHE_ERR register that early exception stub read */
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x1
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Dcache error detected: core: %d, set: %d, va 6:3: 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0x3
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|uint64_t
name|dcache_err
init|=
literal|0
decl_stmt|;
name|CVMX_MT_DCACHE_ERR
argument_list|(
name|dcache_err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache_err
operator|&
literal|0x1
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Icache error detected: core: %d, set: %d, way : %d\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|5
argument_list|)
operator|&
literal|0x3f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|7
argument_list|)
operator|&
literal|0x3
argument_list|)
expr_stmt|;
name|cache_err
operator|=
literal|0
expr_stmt|;
name|CVMX_MT_CACHE_ERR
argument_list|(
name|cache_err
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_safe_printf
argument_list|(
literal|"Cache error exception: core %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cause
operator|&
literal|0x7c
operator|)
operator|!=
literal|0
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
goto|goto
name|return_from_interrupt
goto|;
block|}
comment|/* Convert the cause into an active mask */
name|mask
operator|=
operator|(
operator|(
name|cause
operator|&
name|status
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
goto|goto
name|return_from_interrupt
goto|;
comment|/* Spurious interrupt */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|(
name|i
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|i
index|]
operator|)
expr_stmt|;
goto|goto
name|return_from_interrupt
goto|;
block|}
block|}
comment|/* We should never get here */
name|__cvmx_interrupt_default_exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
name|return_from_interrupt
label|:
comment|/* Restore Status register before returning from exception. */
asm|asm
specifier|volatile
asm|("dmtc0 %0, $12, 0" : : "r" (status));
block|}
end_function

begin_comment
comment|/**  * Initialize the interrupt routine and copy the low level  * stub into the correct interrupt vector. This is called  * automatically during application startup.  */
end_comment

begin_function
name|void
name|cvmx_interrupt_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|low_level_loc
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable all CIU interrupts by default */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|__cvmx_interrupt_default_exception_handler
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|=
name|__cvmx_interrupt_default
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|low_level_loc
operator|=
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|sys_info_ptr
operator|->
name|exception_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x80
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x100
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_cache_error
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x180
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x200
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Make sure the locations used to count Icache and Dcache exceptions             starts out as zero */
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|24
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Add an interrupt handlers for chained CIU interrupts */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_CIU0
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_CIU1
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add an interrupt handler for ECC failures */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_RML
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_error_initialize
argument_list|(
literal|0
comment|/* || CVMX_ERROR_FLAGS_ECC_SINGLE_BIT */
argument_list|)
condition|)
name|cvmx_warn
argument_list|(
literal|"cvmx_error_initialize() failed\n"
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_RML
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_CIU0
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_CIU1
argument_list|)
expr_stmt|;
name|CVMX_ICACHE_INVALIDATE
expr_stmt|;
comment|/* Enable interrupts for each core (bit0 of COP0 Status) */
name|uint32_t
name|mask
decl_stmt|;
asm|asm
specifier|volatile
asm|(         "mfc0   %0,$12,0\n"         "ori    %0, %0, 1\n"         "mtc0   %0,$12,0\n"         : "=r" (mask));
block|}
end_function

begin_comment
comment|/**  * Register an interrupt handler for the specified interrupt number.  *  * @param irq_number Interrupt number to register for (0-135)  See  *                   cvmx-interrupt.h for enumeration and description of sources.  * @param func       Function to call on interrupt.  * @param user_arg   User data to pass to the interrupt handler  */
end_comment

begin_function
name|void
name|cvmx_interrupt_register
parameter_list|(
name|cvmx_irq_t
name|irq_number
parameter_list|,
name|cvmx_interrupt_func_t
name|func
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|=
name|func
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq_number
index|]
operator|=
name|user_arg
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the exception handler for all non interrupt sources.  *  * @param handler New exception handler  * @return Old exception handler  */
end_comment

begin_function
name|cvmx_interrupt_exception_t
name|cvmx_interrupt_set_exception
parameter_list|(
name|cvmx_interrupt_exception_t
name|handler
parameter_list|)
block|{
name|cvmx_interrupt_exception_t
name|result
init|=
name|cvmx_interrupt_state
operator|.
name|exception_handler
decl_stmt|;
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|handler
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__U_BOOT__ */
end_comment

end_unit

