begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Mips interrupts.  *  *<hr>$Revision: 42264 $<hr>  */
end_comment

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
end_if

begin_comment
comment|/* Backtrace is only available with the new toolchain.  */
end_comment

begin_include
include|#
directive|include
file|<execinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-uart.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pow.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ebt3000.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-init.h"
end_include

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_stage1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_cache_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Internal status the interrupt registration  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_interrupt_func_t
name|handlers
index|[
literal|256
index|]
decl_stmt|;
comment|/**< One function to call per interrupt */
name|void
modifier|*
name|data
index|[
literal|256
index|]
decl_stmt|;
comment|/**< User data per interrupt */
name|cvmx_interrupt_exception_t
name|exception_handler
decl_stmt|;
block|}
name|cvmx_interrupt_state_t
typedef|;
end_typedef

begin_comment
comment|/**  * Internal state the interrupt registration  */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_interrupt_state_t
name|cvmx_interrupt_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_interrupt_default_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COP0_CAUSE
value|"$13,0"
end_define

begin_define
define|#
directive|define
name|COP0_STATUS
value|"$12,0"
end_define

begin_define
define|#
directive|define
name|COP0_BADVADDR
value|"$8,0"
end_define

begin_define
define|#
directive|define
name|COP0_EPC
value|"$14,0"
end_define

begin_define
define|#
directive|define
name|READ_COP0
parameter_list|(
name|dest
parameter_list|,
name|R
parameter_list|)
value|asm volatile ("dmfc0 %[rt]," R : [rt] "=r" (dest))
end_define

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_comment
comment|/**  * @INTERNAL  * Dump all useful registers to the console  *  * @param registers CPU register to dump  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_dump_registers
parameter_list|(
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|name
index|[
literal|32
index|]
init|=
block|{
literal|"r0"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
name|uint64_t
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"%3s ($%02d): 0x%016llx \t %3s ($%02d): 0x%016llx\n"
argument_list|,
name|name
index|[
name|reg
index|]
argument_list|,
operator|(
name|int
operator|)
name|reg
argument_list|,
operator|(
name|ULL
operator|)
name|registers
index|[
name|reg
index|]
argument_list|,
name|name
index|[
name|reg
operator|+
literal|16
index|]
argument_list|,
operator|(
name|int
operator|)
name|reg
operator|+
literal|16
argument_list|,
operator|(
name|ULL
operator|)
name|registers
index|[
name|reg
operator|+
literal|16
index|]
argument_list|)
expr_stmt|;
block|}
name|READ_COP0
argument_list|(
name|reg
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%016llx\n"
argument_list|,
literal|"COP0_CAUSE"
argument_list|,
operator|(
name|ULL
operator|)
name|reg
argument_list|)
expr_stmt|;
name|READ_COP0
argument_list|(
name|reg
argument_list|,
name|COP0_STATUS
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%016llx\n"
argument_list|,
literal|"COP0_STATUS"
argument_list|,
operator|(
name|ULL
operator|)
name|reg
argument_list|)
expr_stmt|;
name|READ_COP0
argument_list|(
name|reg
argument_list|,
name|COP0_BADVADDR
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%016llx\n"
argument_list|,
literal|"COP0_BADVADDR"
argument_list|,
operator|(
name|ULL
operator|)
name|reg
argument_list|)
expr_stmt|;
name|READ_COP0
argument_list|(
name|reg
argument_list|,
name|COP0_EPC
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%016llx\n"
argument_list|,
literal|"COP0_EPC"
argument_list|,
operator|(
name|ULL
operator|)
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Default exception handler. Prints out the exception  * cause decode and all relevant registers.  *  * @param registers Registers at time of the exception  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_default_exception_handler
parameter_list|(
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|)
block|{
name|uint64_t
name|trap_print_cause
decl_stmt|;
name|ebt3000_str_write
argument_list|(
literal|"Trap"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"Core %d: Unhandled Exception. Cause register decodes to:\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
name|READ_COP0
argument_list|(
name|trap_print_cause
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|trap_print_cause
operator|>>
literal|2
operator|)
operator|&
literal|0x1f
condition|)
block|{
case|case
literal|0x0
case|:
name|cvmx_safe_printf
argument_list|(
literal|"Interrupt\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|cvmx_safe_printf
argument_list|(
literal|"TLB Mod\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|cvmx_safe_printf
argument_list|(
literal|"tlb load/fetch\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|cvmx_safe_printf
argument_list|(
literal|"tlb store\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|cvmx_safe_printf
argument_list|(
literal|"address exc, load/fetch\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|cvmx_safe_printf
argument_list|(
literal|"address exc, store\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
name|cvmx_safe_printf
argument_list|(
literal|"bus error, inst. fetch\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|cvmx_safe_printf
argument_list|(
literal|"bus error, load/store\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|cvmx_safe_printf
argument_list|(
literal|"syscall\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|cvmx_safe_printf
argument_list|(
literal|"breakpoint \n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa
case|:
name|cvmx_safe_printf
argument_list|(
literal|"reserved instruction\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|cvmx_safe_printf
argument_list|(
literal|"cop unusable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
name|cvmx_safe_printf
argument_list|(
literal|"arithmetic overflow\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
name|cvmx_safe_printf
argument_list|(
literal|"trap\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|cvmx_safe_printf
argument_list|(
literal|"floating point exc\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|cvmx_safe_printf
argument_list|(
literal|"cop2 exception\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
name|cvmx_safe_printf
argument_list|(
literal|"mdmx unusable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
name|cvmx_safe_printf
argument_list|(
literal|"watch\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|cvmx_safe_printf
argument_list|(
literal|"machine check\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1e
case|:
name|cvmx_safe_printf
argument_list|(
literal|"cache error\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cvmx_safe_printf
argument_list|(
literal|"Reserved exception cause.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
operator|&&
operator|!
name|defined
argument_list|(
name|OCTEON_DISABLE_BACKTRACE
argument_list|)
name|cvmx_safe_printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
name|__octeon_print_backtrace_func
argument_list|(
operator|(
name|__octeon_backtrace_printf_t
operator|)
name|cvmx_safe_printf
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
name|CVMX_BREAK
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Interrupts are suppressed when we are in the exception 	   handler (because of SR[EXL]).  Spin and poll the uart 	   status and see if the debugger is trying to stop us. */
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|dr
condition|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
comment|/* Pulse the MCD0 signal. */
asm|asm
specifier|volatile
asm|( 		".set push\n" 		".set noreorder\n" 		".set mips64\n" 		"dmfc0 %0, $22\n" 		"ori   %0, %0, 0x10\n" 		"dmtc0 %0, $22\n" 		".set pop\n" 		: "=r" (tmp));
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Default interrupt handler if the user doesn't register one.  *  * @param irq_number IRQ that caused this interrupt  * @param registers  Register at the time of the interrupt  * @param user_arg   Unused optional user data  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_default
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"cvmx_interrupt_default: Received interrupt %d\n"
argument_list|,
name|irq_number
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Handler for interrupt lines 2 and 3. These are directly tied  * to the CIU. The handler queres the status of the CIU and  * calls the secondary handler for the CIU interrupt that  * occurred.  *  * @param irq_number Interrupt number that fired (2 or 3)  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|int
name|ciu_offset
init|=
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
name|irq_number
operator|-
literal|2
decl_stmt|;
name|uint64_t
name|irq_mask
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_SUM0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|irq
init|=
literal|8
decl_stmt|;
comment|/* Handle EN0 sources */
while|while
condition|(
name|irq_mask
condition|)
block|{
if|if
condition|(
name|irq_mask
operator|&
literal|1
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq
index|]
operator|(
name|irq
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq
index|]
operator|)
expr_stmt|;
return|return;
block|}
name|irq_mask
operator|=
name|irq_mask
operator|>>
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
block|}
comment|/* Handle EN1 sources */
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INT_SUM1
argument_list|)
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
expr_stmt|;
name|irq
operator|=
literal|8
operator|+
literal|64
expr_stmt|;
while|while
condition|(
name|irq_mask
condition|)
block|{
if|if
condition|(
name|irq_mask
operator|&
literal|1
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq
index|]
operator|(
name|irq
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq
index|]
operator|)
expr_stmt|;
return|return;
block|}
name|irq_mask
operator|=
name|irq_mask
operator|>>
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Called for all RML interrupts. This is usually an ECC error  *  * @param irq_number Interrupt number that we're being called for  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ecc
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_interrupt_rsl_decode
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Process an interrupt request  *  * @param registers Registers at time of interrupt / exception  * Registers 0-31 are standard MIPS, others specific to this routine  * @return  */
end_comment

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
name|registers
index|[
literal|35
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
name|registers
index|[
literal|35
index|]
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|uint64_t
name|cause
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
name|uint64_t
name|cache_err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|exc_vec
decl_stmt|;
comment|/* Determine the cause of the interrupt */
asm|asm
specifier|volatile
asm|("dmfc0 %0,$13,0" : "=r" (cause));
asm|asm
specifier|volatile
asm|("dmfc0 %0,$12,0" : "=r" (status));
comment|/* The assembly stub at each exception vector saves its address in k1 when     ** it calls the stage 2 handler.  We use this to compute the exception vector     ** that brought us here */
name|exc_vec
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|registers
index|[
literal|27
index|]
operator|&
literal|0x780
argument_list|)
expr_stmt|;
comment|/* Mask off bits we need to ignore */
comment|/* Check for cache errors.  The cache errors go to a separate exception vector,     ** so we will only check these if we got here from a cache error exception, and     ** the ERL (error level) bit is set. */
if|if
condition|(
name|exc_vec
operator|==
literal|0x100
operator|&&
operator|(
name|status
operator|&
literal|0x4
operator|)
condition|)
block|{
name|i
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|CVMX_MF_CACHE_ERR
argument_list|(
name|cache_err
argument_list|)
expr_stmt|;
comment|/* Use copy of DCACHE_ERR register that early exception stub read */
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x1
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Dcache error detected: core: %d, set: %d, va 6:3: 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0x3
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|uint64_t
name|dcache_err
init|=
literal|0
decl_stmt|;
name|CVMX_MT_DCACHE_ERR
argument_list|(
name|dcache_err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache_err
operator|&
literal|0x1
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Icache error detected: core: %d, set: %d, way : %d\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|5
argument_list|)
operator|&
literal|0x3f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|7
argument_list|)
operator|&
literal|0x3
argument_list|)
expr_stmt|;
name|cache_err
operator|=
literal|0
expr_stmt|;
name|CVMX_MT_CACHE_ERR
argument_list|(
name|cache_err
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_safe_printf
argument_list|(
literal|"Cache error exception: core %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cause
operator|&
literal|0x7c
operator|)
operator|!=
literal|0
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert the cause into an active mask */
name|mask
operator|=
operator|(
operator|(
name|cause
operator|&
name|status
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
comment|/* Spurious interrupt */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|(
name|i
operator|,
name|registers
operator|,
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* We should never get here */
name|__cvmx_interrupt_default_exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize the interrupt routine and copy the low level  * stub into the correct interrupt vector. This is called  * automatically during application startup.  */
end_comment

begin_function
name|void
name|cvmx_interrupt_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|low_level_loc
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable all CIU interrupts by default */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|__cvmx_interrupt_default_exception_handler
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|=
name|__cvmx_interrupt_default
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|low_level_loc
operator|=
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|sys_info_ptr
operator|->
name|exception_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x80
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x100
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_cache_error
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x180
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x200
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Make sure the locations used to count Icache and Dcache exceptions             starts out as zero */
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|24
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Add an interrupt handlers for chained CIU interrupts */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_CIU0
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_CIU1
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add an interrupt handler for ECC failures */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_RML
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_rsl_enable
argument_list|()
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_RML
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_CIU0
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_CIU1
argument_list|)
expr_stmt|;
name|CVMX_ICACHE_INVALIDATE
expr_stmt|;
comment|/* Enable interrupts for each core (bit0 of COP0 Status) */
name|uint32_t
name|mask
decl_stmt|;
asm|asm
specifier|volatile
asm|(         "mfc0   %0,$12,0\n"         "ori    %0, %0, 1\n"         "mtc0   %0,$12,0\n"         : "=r" (mask));
block|}
end_function

begin_comment
comment|/**  * Register an interrupt handler for the specified interrupt number.  *  * @param irq_number Interrupt number to register for (0-135)  See  *                   cvmx-interrupt.h for enumeration and description of sources.  * @param func       Function to call on interrupt.  * @param user_arg   User data to pass to the interrupt handler  */
end_comment

begin_function
name|void
name|cvmx_interrupt_register
parameter_list|(
name|cvmx_irq_t
name|irq_number
parameter_list|,
name|cvmx_interrupt_func_t
name|func
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|=
name|func
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|data
index|[
name|irq_number
index|]
operator|=
name|user_arg
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the exception handler for all non interrupt sources.  *  * @param handler New exception handler  * @return Old exception handler  */
end_comment

begin_function
name|cvmx_interrupt_exception_t
name|cvmx_interrupt_set_exception
parameter_list|(
name|cvmx_interrupt_exception_t
name|handler
parameter_list|)
block|{
name|cvmx_interrupt_exception_t
name|result
init|=
name|cvmx_interrupt_state
operator|.
name|exception_handler
decl_stmt|;
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|handler
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * version of printf that works better in exception context.  *  * @param format  */
end_comment

begin_function
name|void
name|cvmx_safe_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
comment|/* Spin until there is room */
do|do
block|{
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Just to reduce the load on the system */
block|}
do|while
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

