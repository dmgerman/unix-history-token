begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tcp_input.c	8.12 (Berkeley) 5/24/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ipfw.h"
end_include

begin_comment
comment|/* for ipfw_fwd		*/
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcpdebug.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcp_input.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for proc0 declaration */
end_comment

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* before tcp_seq.h, for tcp_random18() */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_comment
comment|/* for ICMP_BANDLIM		*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_comment
comment|/* for ICMP_BANDLIM		*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/tcp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_decl_stmt
name|u_char
name|tcp_saveipgen
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the size must be of max ip header, now IPv6 */
end_comment

begin_decl_stmt
name|struct
name|tcphdr
name|tcp_savetcp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPDEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*IPSEC*/
end_comment

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TSEGQ
argument_list|,
literal|"tseg_qent"
argument_list|,
literal|"TCP segment queue entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|tcprexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tcp_cc
name|tcp_ccgen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcpstat
name|tcpstat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|TCPCTL_STATS
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tcpstat
argument_list|,
name|tcpstat
argument_list|,
literal|"TCP statistics (struct tcpstat, netinet/tcp_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_in_vain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|log_in_vain
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|log_in_vain
argument_list|,
literal|0
argument_list|,
literal|"Log all incoming TCP connections"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|blackhole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|blackhole
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|blackhole
argument_list|,
literal|0
argument_list|,
literal|"Do not send RST when dropping refused connections"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tcp_delack_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|delayed_ack
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tcp_delack_enabled
argument_list|,
literal|0
argument_list|,
literal|"Delay ACK to try and piggyback it onto a data packet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_DROP_SYNFIN
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|drop_synfin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|drop_synfin
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|drop_synfin
argument_list|,
literal|0
argument_list|,
literal|"Drop TCP packets with SYN+FIN set"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|inpcbhead
name|tcb
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tcb6
value|tcb
end_define

begin_comment
comment|/* for KAME src sync over BSD*'s */
end_comment

begin_decl_stmt
name|struct
name|inpcbinfo
name|tcbinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tcp_dooptions
name|__P
argument_list|(
operator|(
expr|struct
name|tcpopt
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tcp_pulloutofband
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|tcphdr
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_reass
name|__P
argument_list|(
operator|(
expr|struct
name|tcpcb
operator|*
operator|,
expr|struct
name|tcphdr
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tcp_xmit_timer
name|__P
argument_list|(
operator|(
expr|struct
name|tcpcb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_newreno
name|__P
argument_list|(
operator|(
expr|struct
name|tcpcb
operator|*
operator|,
expr|struct
name|tcphdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Neighbor Discovery, Neighbor Unreachability Detection Upper layer hint. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|ND6_HINT
parameter_list|(
name|tp
parameter_list|)
define|\
value|do { \ 	if ((tp)&& (tp)->t_inpcb&& \ 	    ((tp)->t_inpcb->inp_vflag& INP_IPV6) != 0&& \ 	    (tp)->t_inpcb->in6p_route.ro_rt) \ 		nd6_nud_hint((tp)->t_inpcb->in6p_route.ro_rt, NULL, 0); \ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ND6_HINT
parameter_list|(
name|tp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Indicate whether this ack should be delayed.  We can delay the ack if  *	- delayed acks are enabled and  *	- there is no delayed ack timer in progress and  *	- our last ack wasn't a 0-sized window.  We never want to delay  *	  the ack that opens up a 0-sized window.  */
end_comment

begin_define
define|#
directive|define
name|DELAY_ACK
parameter_list|(
name|tp
parameter_list|)
define|\
value|(tcp_delack_enabled&& !callout_pending(tp->tt_delack)&& \ 	(tp->t_flags& TF_RXWIN0SENT) == 0)
end_define

begin_function
specifier|static
name|int
name|tcp_reass
parameter_list|(
name|tp
parameter_list|,
name|th
parameter_list|,
name|tlenp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|int
modifier|*
name|tlenp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|tseg_qent
modifier|*
name|q
decl_stmt|;
name|struct
name|tseg_qent
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|tseg_qent
modifier|*
name|nq
decl_stmt|;
name|struct
name|tseg_qent
modifier|*
name|te
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* 	 * Call with th==0 after become established to 	 * force pre-ESTABLISHED data up to user socket. 	 */
if|if
condition|(
name|th
operator|==
literal|0
condition|)
goto|goto
name|present
goto|;
comment|/* Allocate a new queue entry. If we can't, just drop the pkt. XXX */
name|MALLOC
argument_list|(
name|te
argument_list|,
expr|struct
name|tseg_qent
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tseg_qent
argument_list|)
argument_list|,
name|M_TSEGQ
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|==
name|NULL
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvmemdrop
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Find a segment which begins after this one does. 	 */
name|LIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&tp->t_segq
argument_list|,
argument|tqe_q
argument_list|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|q
operator|->
name|tqe_th
operator|->
name|th_seq
argument_list|,
name|th
operator|->
name|th_seq
argument_list|)
condition|)
break|break;
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us. 	 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* conversion to int (in i) handles seq wraparound */
name|i
operator|=
name|p
operator|->
name|tqe_th
operator|->
name|th_seq
operator|+
name|p
operator|->
name|tqe_len
operator|-
name|th
operator|->
name|th_seq
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
operator|*
name|tlenp
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvdupbyte
operator|+=
operator|*
name|tlenp
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|te
argument_list|,
name|M_TSEGQ
argument_list|)
expr_stmt|;
comment|/* 				 * Try to present any queued data 				 * at the left window edge to the user. 				 * This is needed after the 3-WHS 				 * completes. 				 */
goto|goto
name|present
goto|;
comment|/* ??? */
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|tlenp
operator|-=
name|i
expr_stmt|;
name|th
operator|->
name|th_seq
operator|+=
name|i
expr_stmt|;
block|}
block|}
name|tcpstat
operator|.
name|tcps_rcvoopack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvoobyte
operator|+=
operator|*
name|tlenp
expr_stmt|;
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
while|while
condition|(
name|q
condition|)
block|{
specifier|register
name|int
name|i
init|=
operator|(
name|th
operator|->
name|th_seq
operator|+
operator|*
name|tlenp
operator|)
operator|-
name|q
operator|->
name|tqe_th
operator|->
name|th_seq
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|q
operator|->
name|tqe_len
condition|)
block|{
name|q
operator|->
name|tqe_th
operator|->
name|th_seq
operator|+=
name|i
expr_stmt|;
name|q
operator|->
name|tqe_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|q
operator|->
name|tqe_m
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|nq
operator|=
name|LIST_NEXT
argument_list|(
name|q
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|q
operator|->
name|tqe_m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|q
argument_list|,
name|M_TSEGQ
argument_list|)
expr_stmt|;
name|q
operator|=
name|nq
expr_stmt|;
block|}
comment|/* Insert the new segment queue entry into place. */
name|te
operator|->
name|tqe_m
operator|=
name|m
expr_stmt|;
name|te
operator|->
name|tqe_th
operator|=
name|th
expr_stmt|;
name|te
operator|->
name|tqe_len
operator|=
operator|*
name|tlenp
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|,
name|te
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|p
argument_list|,
name|te
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
block|}
name|present
label|:
comment|/* 	 * Present data to user, advancing rcv_nxt through 	 * completed sequence space. 	 */
if|if
condition|(
operator|!
name|TCPS_HAVEESTABLISHED
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|q
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
name|q
operator|->
name|tqe_th
operator|->
name|th_seq
operator|!=
name|tp
operator|->
name|rcv_nxt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
name|tp
operator|->
name|rcv_nxt
operator|+=
name|q
operator|->
name|tqe_len
expr_stmt|;
name|flags
operator|=
name|q
operator|->
name|tqe_th
operator|->
name|th_flags
operator|&
name|TH_FIN
expr_stmt|;
name|nq
operator|=
name|LIST_NEXT
argument_list|(
name|q
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|tqe_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
name|m_freem
argument_list|(
name|q
operator|->
name|tqe_m
argument_list|)
expr_stmt|;
else|else
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|q
operator|->
name|tqe_m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|q
argument_list|,
name|M_TSEGQ
argument_list|)
expr_stmt|;
name|q
operator|=
name|nq
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|&&
name|q
operator|->
name|tqe_th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
condition|)
do|;
name|ND6_HINT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TCP input routine, follows pages 65-76 of the  * protocol specification dated September, 1981 very closely.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|tcp6_input
parameter_list|(
name|mp
parameter_list|,
name|offp
parameter_list|,
name|proto
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|,
name|proto
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
operator|*
name|offp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
name|IPPROTO_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * draft-itojun-ipv6-tcp-to-anycast 	 * better place to put this in? 	 */
name|ia6
operator|=
name|ip6_getdstifaddr
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_ANYCAST
operator|)
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
operator|->
name|ip6_dst
operator|-
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
name|tcp_input
argument_list|(
name|m
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|tcp_input
parameter_list|(
name|m
parameter_list|,
name|off0
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off0
decl_stmt|;
block|{
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|ipovly
modifier|*
name|ipov
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|u_char
modifier|*
name|optp
init|=
name|NULL
decl_stmt|;
name|int
name|optlen
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|off
decl_stmt|;
name|int
name|drop_hdrlen
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|thflags
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
literal|0
decl_stmt|;
name|int
name|todrop
decl_stmt|,
name|acked
decl_stmt|,
name|ourfinisacked
decl_stmt|,
name|needoutput
init|=
literal|0
decl_stmt|;
name|int
name|iss
init|=
literal|0
decl_stmt|;
name|u_long
name|tiwin
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
comment|/* options in this segment */
name|struct
name|rmxp_tao
modifier|*
name|taop
decl_stmt|;
comment|/* pointer to our TAO cache entry */
name|struct
name|rmxp_tao
name|tao_noncached
decl_stmt|;
comment|/* in case there's no cached entry */
ifdef|#
directive|ifdef
name|TCPDEBUG
name|short
name|ostate
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|NULL
decl_stmt|;
name|int
name|isipv6
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|int
name|rstreason
decl_stmt|;
comment|/* For badport_bandlim accounting purposes */
ifdef|#
directive|ifdef
name|INET6
name|isipv6
operator|=
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_v
operator|==
literal|6
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvtotal
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
comment|/* IP6_EXTHDR_CHECK() is already done at tcp6_input() */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|-
name|off0
expr_stmt|;
if|if
condition|(
name|in6_cksum
argument_list|(
name|m
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|off0
argument_list|,
name|tlen
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbadsum
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off0
operator|)
expr_stmt|;
comment|/* 		 * Be proactive about unspecified IPv6 address in source. 		 * As we use all-zero to indicate unbounded/unconnected pcb, 		 * unspecified IPv6 address can be used to confuse us. 		 * 		 * Note that packets with unspecified IPv6 destination is 		 * already dropped in ip6_input. 		 */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
comment|/* XXX stat */
goto|goto
name|drop
goto|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* INET6 */
block|{
comment|/* 	 * Get IP and TCP header together in first mbuf. 	 * Note: IP leaves IP header in first mbuf. 	 */
if|if
condition|(
name|off0
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|ip_stripoptions
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|off0
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ipov
operator|=
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|off0
operator|)
expr_stmt|;
name|tlen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
name|th
operator|->
name|th_sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
else|else
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
name|ip
operator|->
name|ip_len
operator|+
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|^=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Checksum extended TCP header and data. 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|tlen
expr_stmt|;
name|bzero
argument_list|(
name|ipov
operator|->
name|ih_x1
argument_list|,
sizeof|sizeof
argument_list|(
name|ipov
operator|->
name|ih_x1
argument_list|)
argument_list|)
expr_stmt|;
name|ipov
operator|->
name|ih_len
operator|=
operator|(
name|u_short
operator|)
name|tlen
expr_stmt|;
name|ipov
operator|->
name|ih_len
operator|=
name|htons
argument_list|(
name|ipov
operator|->
name|ih_len
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_sum
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbadsum
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* Re-initialization for later version check */
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Check that TCP offset makes sense, 	 * pull out TCP options and adjust length.		XXX 	 */
name|off
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|off
operator|>
name|tlen
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbadoff
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|tlen
operator|-=
name|off
expr_stmt|;
comment|/* tlen is used instead of ti->ti_len */
if|if
condition|(
name|off
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off0
argument_list|,
name|off
argument_list|, )
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off0
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* INET6 */
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ipov
operator|=
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|off0
operator|)
expr_stmt|;
block|}
block|}
name|optlen
operator|=
name|off
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|optp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|thflags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_DROP_SYNFIN
comment|/* 	 * If the drop_synfin option is enabled, drop all packets with 	 * both the SYN and FIN bits set. This prevents e.g. nmap from 	 * identifying the TCP/IP stack. 	 * 	 * This is a violation of the TCP specification. 	 */
if|if
condition|(
name|drop_synfin
operator|&&
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
operator|)
operator|==
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
condition|)
goto|goto
name|drop
goto|;
endif|#
directive|endif
comment|/* 	 * Convert TCP protocol specific fields to host format. 	 */
name|th
operator|->
name|th_seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_win
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
comment|/* 	 * Delay droping TCP, IP headers, IPv6 ext headers, and TCP options, 	 * until after ip6_savecontrol() is called and before other functions 	 * which don't want those proto headers. 	 * Because ip6_savecontrol() is going to parse the mbuf to 	 * search for data to be passed up to user-land, it wants mbuf 	 * parameters to be unchanged. 	 */
name|drop_hdrlen
operator|=
name|off0
operator|+
name|off
expr_stmt|;
comment|/* 	 * Locate pcb for segment. 	 */
name|findpcb
label|:
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
if|if
condition|(
name|ip_fw_fwd_addr
operator|!=
name|NULL
ifdef|#
directive|ifdef
name|INET6
operator|&&
name|isipv6
operator|==
name|NULL
comment|/* IPv6 support is not yet */
endif|#
directive|endif
comment|/* INET6 */
condition|)
block|{
comment|/* 		 * Diverted. Pretend to be the destination. 		 * already got one like this?  		 */
name|inp
operator|=
name|in_pcblookup_hash
argument_list|(
operator|&
name|tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
comment|/*  			 * No, then it's new. Try find the ambushing socket 			 */
if|if
condition|(
operator|!
name|ip_fw_fwd_addr
operator|->
name|sin_port
condition|)
block|{
name|inp
operator|=
name|in_pcblookup_hash
argument_list|(
operator|&
name|tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip_fw_fwd_addr
operator|->
name|sin_addr
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|=
name|in_pcblookup_hash
argument_list|(
operator|&
name|tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip_fw_fwd_addr
operator|->
name|sin_addr
argument_list|,
name|ntohs
argument_list|(
name|ip_fw_fwd_addr
operator|->
name|sin_port
argument_list|)
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
block|}
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* IPFIREWALL_FORWARD */
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
name|inp
operator|=
name|in6_pcblookup_hash
argument_list|(
operator|&
name|tcbinfo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INET6 */
name|inp
operator|=
name|in_pcblookup_hash
argument_list|(
operator|&
name|tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|inp
operator|!=
name|NULL
operator|&&
name|ipsec6_in_reject_so
argument_list|(
name|m
argument_list|,
name|inp
operator|->
name|inp_socket
argument_list|)
condition|)
block|{
name|ipsec6stat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|inp
operator|!=
name|NULL
operator|&&
name|ipsec4_in_reject_so
argument_list|(
name|m
argument_list|,
name|inp
operator|->
name|inp_socket
argument_list|)
condition|)
block|{
name|ipsecstat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
comment|/*IPSEC*/
comment|/* 	 * If the state is CLOSED (i.e., TCB does not exist) then 	 * all data in the incoming segment is discarded. 	 * If the TCB exists but is in CLOSED state, it is embryonic, 	 * but should either do a listen or a connect soon. 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|log_in_vain
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|char
name|dbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|sbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
else|#
directive|else
comment|/* INET6 */
name|char
name|dbuf
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
operator|,
name|sbuf
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|log_in_vain
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection attempt to TCP %s:%d from %s:%d\n"
argument_list|,
name|dbuf
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_dport
argument_list|)
argument_list|,
name|sbuf
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection attempt to TCP %s:%d from %s:%d flags:0x%x\n"
argument_list|,
name|dbuf
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_dport
argument_list|)
argument_list|,
name|sbuf
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sport
argument_list|)
argument_list|,
name|thflags
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|blackhole
condition|)
block|{
switch|switch
condition|(
name|blackhole
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
goto|goto
name|drop
goto|;
break|break;
case|case
literal|2
case|:
goto|goto
name|drop
goto|;
default|default:
goto|goto
name|drop
goto|;
block|}
block|}
name|rstreason
operator|=
name|BANDLIM_RST_CLOSEDPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_CLOSEDPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
condition|)
goto|goto
name|drop
goto|;
comment|/* Unscale the window into a 32-bit value. */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
name|tiwin
operator|=
name|th
operator|->
name|th_win
operator|<<
name|tp
operator|->
name|snd_scale
expr_stmt|;
else|else
name|tiwin
operator|=
name|th
operator|->
name|th_win
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
operator|(
name|SO_DEBUG
operator||
name|SO_ACCEPTCONN
operator|)
condition|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
block|{
name|ostate
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip6
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INET6 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_savetcp
operator|=
operator|*
name|th
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* skip if this isn't a listen socket */
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|after_listen
goto|;
ifdef|#
directive|ifdef
name|INET6
name|inc
operator|.
name|inc_isipv6
operator|=
name|isipv6
expr_stmt|;
if|if
condition|(
name|isipv6
condition|)
block|{
name|inc
operator|.
name|inc6_faddr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|inc
operator|.
name|inc6_laddr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|inc
operator|.
name|inc6_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
block|}
else|else
endif|#
directive|endif
comment|/* INET6 */
block|{
name|inc
operator|.
name|inc_faddr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|inc
operator|.
name|inc_laddr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|inc
operator|.
name|inc_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
block|}
name|inc
operator|.
name|inc_fport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|inc
operator|.
name|inc_lport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
comment|/* 	         * If the state is LISTEN then ignore segment if it contains 		 * a RST.  If the segment contains an ACK then it is bad and 		 * send a RST.  If it does not contain a SYN then it is not 		 * interesting; drop it. 		 * 		 * If the state is SYN_RECEIVED (syncache) and seg contains 		 * an ACK, but not for our SYN/ACK, send a RST.  If the seg 		 * contains a RST, check the sequence number to see if it 		 * is a valid reset segment. 		 */
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator||
name|TH_SYN
operator|)
operator|)
operator|!=
name|TH_SYN
condition|)
block|{
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator||
name|TH_SYN
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
if|if
condition|(
operator|!
name|syncache_expand
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
operator|&
name|so
argument_list|,
name|m
argument_list|)
condition|)
block|{
comment|/* 					 * No syncache entry, or ACK was not 					 * for our SYN/ACK.  Send a RST. 					 */
name|tcpstat
operator|.
name|tcps_badsyn
operator|++
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
comment|/* 					 * Could not complete 3-way handshake, 					 * connection is being closed down, and 					 * syncache will free mbuf. 					 */
return|return;
comment|/* 				 * Socket is created in state SYN_RECEIVED. 				 * Continue processing segment. 				 */
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 				 * This is what would have happened in 				 * tcp_output() when the SYN,ACK was sent. 				 */
name|tp
operator|->
name|snd_up
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
name|tp
operator|->
name|snd_max
operator|=
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|iss
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|last_ack_sent
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
comment|/*  * XXX possible bug - it doesn't appear that tp->snd_wnd is unscaled  * until the _second_ ACK is received:  *    rcv SYN (set wscale opts)	 --> send SYN/ACK, set snd_wnd = window.  *    rcv ACK, calculate tiwin --> process SYN_RECEIVED, determine wscale,  *        move to ESTAB, set snd_wnd to tiwin.  */
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
comment|/* unscaled */
goto|goto
name|after_listen
goto|;
block|}
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
block|{
name|syncache_chkrst
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
block|{
name|syncache_badack
argument_list|(
operator|&
name|inc
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_badsyn
operator|++
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * Segment's flags are (SYN) or (SYN|FIN). 		 */
ifdef|#
directive|ifdef
name|INET6
comment|/* 		 * If deprecated address is forbidden, 		 * we do not accept SYN to deprecated interface 		 * address to prevent any new inbound connection from 		 * getting established. 		 * When we do not accept SYN, we send a TCP RST, 		 * with deprecated source address (instead of dropping 		 * it).  We compromise it as it is much better for peer 		 * to send a RST, and RST will be the final packet 		 * for the exchange. 		 * 		 * If we do not forbid deprecated addresses, we accept 		 * the SYN packet.  RFC2462 does not suggest dropping 		 * SYN in this case. 		 * If we decipher RFC2462 5.5.4, it says like this: 		 * 1. use of deprecated addr with existing 		 *    communication is okay - "SHOULD continue to be 		 *    used" 		 * 2. use of it with new communication: 		 *   (2a) "SHOULD NOT be used if alternate address 		 *        with sufficient scope is available" 		 *   (2b) nothing mentioned otherwise. 		 * Here we fall into (2b) case as we have no choice in 		 * our source address selection - we must obey the peer. 		 * 		 * The wording in RFC2462 is confusing, and there are 		 * multiple description text for deprecated address 		 * handling - worse, they are not exactly the same. 		 * I believe 5.5.4 is the best one, so we follow 5.5.4. 		 */
if|if
condition|(
name|isipv6
operator|&&
operator|!
name|ip6_use_deprecated
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
if|if
condition|(
operator|(
name|ia6
operator|=
name|ip6_getdstifaddr
argument_list|(
name|m
argument_list|)
operator|)
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_DEPRECATED
operator|)
condition|)
block|{
name|tp
operator|=
name|NULL
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * If it is from this socket, drop it, it must be forged. 		 * Don't bother responding if the destination was a broadcast. 		 */
if|if
condition|(
name|th
operator|->
name|th_dport
operator|==
name|th
operator|->
name|th_sport
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * RFC1122 4.2.3.10, p. 104: discard bcast/mcast SYN 		 * 		 * Note that it is quite possible to receive unicast 		 * link-layer packets with a broadcast IP address. Use 		 * in_broadcast() to find them. 		 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
goto|goto
name|drop
goto|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
operator|||
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* 		 * SYN appears to be valid; create compressed TCP state 		 * for syncache, or perform t/tcp connection. 		 */
if|if
condition|(
name|so
operator|->
name|so_qlen
operator|<=
name|so
operator|->
name|so_qlimit
condition|)
block|{
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
name|th
argument_list|,
operator|&
name|so
argument_list|,
name|m
argument_list|)
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
comment|/* 				 * Entry added to syncache, mbuf used to 				 * send SYN,ACK packet. 				 */
return|return;
comment|/* 			 * Segment passed TAO tests. 			 */
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
comment|/* 			 * If there is a FIN, or if there is data and the 			 * connection is local, then delay SYN,ACK(SYN) in 			 * the hope of piggy-backing it on a response 			 * segment.  Otherwise must send ACK now in case 			 * the other side is slow starting. 			 */
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|||
operator|(
name|tlen
operator|!=
literal|0
operator|&&
ifdef|#
directive|ifdef
name|INET6
operator|(
operator|(
name|isipv6
operator|&&
name|in6_localaddr
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isipv6
operator|&&
endif|#
directive|endif
name|in_localaddr
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_delack
argument_list|,
name|tcp_delacktime
argument_list|,
name|tcp_timer_delack
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_NEEDSYN
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_flags
operator||=
operator|(
name|TF_ACKNOW
operator||
name|TF_NEEDSYN
operator|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|trimthenstep6
goto|;
block|}
goto|goto
name|drop
goto|;
block|}
name|after_listen
label|:
comment|/* XXX temp debugging */
comment|/* should not happen - syncache should pick up these connections */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
name|panic
argument_list|(
literal|"tcp_input: TCPS_LISTEN"
argument_list|)
expr_stmt|;
comment|/* 	 * Segment received on connection. 	 * Reset idle time and keep-alive timer. 	 */
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|TCPS_HAVEESTABLISHED
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_keep
argument_list|,
name|tcp_keepidle
argument_list|,
name|tcp_timer_keep
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Process options. 	 * XXX this is tradtitional behavior, may need to be cleaned up. 	 */
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
name|thflags
operator|&
name|TH_SYN
argument_list|)
expr_stmt|;
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
block|{
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SCALE
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_SCALE
expr_stmt|;
name|tp
operator|->
name|requested_s_scale
operator|=
name|to
operator|.
name|to_requested_s_scale
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_TSTMP
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
operator|(
name|TOF_CC
operator||
name|TOF_CCNEW
operator|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_CC
expr_stmt|;
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_MSS
condition|)
name|tcp_mss
argument_list|(
name|tp
argument_list|,
name|to
operator|.
name|to_mss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Header prediction: check for the two common cases 	 * of a uni-directional data xfer.  If the packet has 	 * no control flags, is in-sequence, the window didn't 	 * change and we're not retransmitting, it's a 	 * candidate.  If the length is zero and the ack moved 	 * forward, we're the sender side of the xfer.  Just 	 * free the data acked& wake any higher level process 	 * that was blocked waiting for space.  If the length 	 * is non-zero and the ack didn't move, we're the 	 * receiver side.  If we're getting packets in-order 	 * (the reassembly queue is empty), add the data to 	 * the socket buffer and note that we need a delayed ack. 	 * Make sure that the hidden state-flags are also off. 	 * Since we check for TCPS_ESTABLISHED above, it can only 	 * be TH_NEEDSYN. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_ESTABLISHED
operator|&&
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_URG
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_NEEDSYN
operator||
name|TF_NEEDFIN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|==
literal|0
operator|||
name|TSTMP_GEQ
argument_list|(
name|to
operator|.
name|to_tsval
argument_list|,
name|tp
operator|->
name|ts_recent
argument_list|)
operator|)
operator|&&
comment|/* 	     * Using the CC option is compulsory if once started: 	     *   the segment is OK if no T/TCP was negotiated or 	     *   if the segment has a CC option equal to CCrecv 	     */
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_REQ_CC
operator||
name|TF_RCVD_CC
operator|)
operator|)
operator|!=
operator|(
name|TF_REQ_CC
operator||
name|TF_RCVD_CC
operator|)
operator|||
operator|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_CC
operator|)
operator|!=
literal|0
operator|&&
name|to
operator|.
name|to_cc
operator|==
name|tp
operator|->
name|cc_recv
operator|)
operator|)
operator|&&
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
operator|&&
name|tiwin
operator|&&
name|tiwin
operator|==
name|tp
operator|->
name|snd_wnd
operator|&&
name|tp
operator|->
name|snd_nxt
operator|==
name|tp
operator|->
name|snd_max
condition|)
block|{
comment|/* 		 * If last ACK falls within this segment's sequence numbers, 		 * record the timestamp. 		 * NOTE that the test is modified according to the latest 		 * proposal of the tcplw@cray.com list (Braden 1993/04/26). 		 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
condition|)
block|{
name|tp
operator|->
name|ts_recent_age
operator|=
name|ticks
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
block|}
if|if
condition|(
name|tlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|&&
name|tp
operator|->
name|snd_cwnd
operator|>=
name|tp
operator|->
name|snd_wnd
operator|&&
name|tp
operator|->
name|t_dupacks
operator|<
name|tcprexmtthresh
condition|)
block|{
comment|/* 				 * this is a pure ack for outstanding data. 				 */
operator|++
name|tcpstat
operator|.
name|tcps_predack
expr_stmt|;
comment|/* 				 * "bad retransmit" recovery 				 */
if|if
condition|(
name|tp
operator|->
name|t_rxtshift
operator|==
literal|1
operator|&&
name|ticks
operator|<
name|tp
operator|->
name|t_badrxtwin
condition|)
block|{
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_cwnd_prev
expr_stmt|;
name|tp
operator|->
name|snd_ssthresh
operator|=
name|tp
operator|->
name|snd_ssthresh_prev
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
name|tp
operator|->
name|t_badrxtwin
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
condition|)
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|to
operator|.
name|to_tsecr
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_rtttime
operator|&&
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|t_rtseq
argument_list|)
condition|)
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
argument_list|)
expr_stmt|;
name|acked
operator|=
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackpack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackbyte
operator|+=
name|acked
expr_stmt|;
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ND6_HINT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* some progress has been done */
comment|/* 				 * If all outstanding data are acked, stop 				 * retransmit timer, otherwise restart timer 				 * using current (possibly backed-off) value. 				 * If process is waiting for space, 				 * wakeup/selwakeup/signal.  If data 				 * are ready to send, let tcp_output 				 * decide between more output or persist. 				 */
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|==
name|tp
operator|->
name|snd_max
condition|)
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|tp
operator|->
name|tt_persist
argument_list|)
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|,
name|tp
operator|->
name|t_rxtcur
argument_list|,
name|tcp_timer_rexmt
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
condition|)
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_ack
operator|==
name|tp
operator|->
name|snd_una
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|)
operator|&&
name|tlen
operator|<=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
comment|/* 			 * this is a pure, in-sequence data packet 			 * with nothing on the reassembly queue and 			 * we have enough buffer space to take it. 			 */
operator|++
name|tcpstat
operator|.
name|tcps_preddat
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|tlen
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbyte
operator|+=
name|tlen
expr_stmt|;
name|ND6_HINT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* some progress has been done */
comment|/* 			 * Add data to socket buffer. 			 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
comment|/* delayed header drop */
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_delack
argument_list|,
name|tcp_delacktime
argument_list|,
name|tcp_timer_delack
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* 	 * Calculate amount of space in receive window, 	 * and then do TCP input processing. 	 * Receive window is amount of space in rcv queue, 	 * but not less than advertised window. 	 */
block|{
name|int
name|win
decl_stmt|;
name|win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|0
condition|)
name|win
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|imax
argument_list|(
name|win
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tp
operator|->
name|rcv_adv
operator|-
name|tp
operator|->
name|rcv_nxt
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * If the state is SYN_RECEIVED: 	 *	if seg contains an ACK, but not for our SYN/ACK, send a RST. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
break|break;
comment|/* 	 * If the state is SYN_SENT: 	 *	if seg contains an ACK, but not for our SYN, drop the input. 	 *	if seg contains a RST, then drop the connection. 	 *	if seg does not contain SYN, then drop it. 	 * Otherwise this is an acceptable SYN segment 	 *	initialize tp->rcv_nxt and tp->irs 	 *	if seg contains ack then advance tp->snd_una 	 *	if SYN has been acked change to ESTABLISHED else SYN_RCVD state 	 *	arrange for segment to be acked (eventually) 	 *	continue processing rest of data/controls, beginning with URG 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
operator|(
name|taop
operator|=
name|tcp_gettaocache
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|taop
operator|=
operator|&
name|tao_noncached
expr_stmt|;
name|bzero
argument_list|(
name|taop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|taop
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * If we have a cached CCsent for the remote host, 			 * hence we haven't just crashed and restarted, 			 * do not send a RST.  This may be a retransmission 			 * from the other side after our earlier ACK was lost. 			 * Our new SYN, when it arrives, will serve as the 			 * needed ACK. 			 */
if|if
condition|(
name|taop
operator|->
name|tao_ccsent
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
else|else
block|{
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
block|}
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
block|{
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
name|tp
operator|->
name|snd_wnd
operator|=
name|th
operator|->
name|th_win
expr_stmt|;
comment|/* initial send window */
name|tp
operator|->
name|cc_recv
operator|=
name|to
operator|.
name|to_cc
expr_stmt|;
comment|/* foreign CC */
name|tp
operator|->
name|irs
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
block|{
comment|/* 			 * Our SYN was acked.  If segment contains CC.ECHO 			 * option, check it to make sure this segment really 			 * matches our SYN.  If not, just drop it as old 			 * duplicate, but send an RST if we're still playing 			 * by the old rules.  If no CC.ECHO option, make sure 			 * we don't get fooled into using T/TCP. 			 */
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_CCECHO
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|cc_send
operator|!=
name|to
operator|.
name|to_ccecho
condition|)
block|{
if|if
condition|(
name|taop
operator|->
name|tao_ccsent
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
else|else
block|{
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
block|}
block|}
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_RCVD_CC
expr_stmt|;
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Do window scaling on this connection? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|snd_scale
operator|=
name|tp
operator|->
name|requested_s_scale
expr_stmt|;
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
block|}
comment|/* Segment is acceptable, update cache if undefined. */
if|if
condition|(
name|taop
operator|->
name|tao_ccsent
operator|==
literal|0
condition|)
name|taop
operator|->
name|tao_ccsent
operator|=
name|to
operator|.
name|to_ccecho
expr_stmt|;
name|tp
operator|->
name|rcv_adv
operator|+=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|++
expr_stmt|;
comment|/* SYN is acked */
comment|/* 			 * If there's data, delay ACK; if there's also a FIN 			 * ACKNOW will be turned on later. 			 */
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|)
operator|&&
name|tlen
operator|!=
literal|0
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_delack
argument_list|,
name|tcp_delacktime
argument_list|,
name|tcp_timer_delack
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
comment|/* 			 * Received<SYN,ACK> in SYN_SENT[*] state. 			 * Transitions: 			 *	SYN_SENT  --> ESTABLISHED 			 *	SYN_SENT* --> FIN_WAIT_1 			 */
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDFIN
condition|)
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_1
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDFIN
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_SYN
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_keep
argument_list|,
name|tcp_keepidle
argument_list|,
name|tcp_timer_keep
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 *  Received initial SYN in SYN-SENT[*] state => simul- 		 *  taneous open.  If segment contains CC option and there is 		 *  a cached CC, apply TAO test; if it succeeds, connection is 		 *  half-synchronized.  Otherwise, do 3-way handshake: 		 *        SYN-SENT -> SYN-RECEIVED 		 *        SYN-SENT* -> SYN-RECEIVED* 		 *  If there was no CC option, clear cached CC value. 		 */
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_CC
condition|)
block|{
if|if
condition|(
name|taop
operator|->
name|tao_cc
operator|!=
literal|0
operator|&&
name|CC_GT
argument_list|(
name|to
operator|.
name|to_cc
argument_list|,
name|taop
operator|->
name|tao_cc
argument_list|)
condition|)
block|{
comment|/* 					 * update cache and make transition: 					 *        SYN-SENT -> ESTABLISHED* 					 *        SYN-SENT* -> FIN-WAIT-1* 					 */
name|taop
operator|->
name|tao_cc
operator|=
name|to
operator|.
name|to_cc
expr_stmt|;
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDFIN
condition|)
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_1
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDFIN
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_keep
argument_list|,
name|tcp_keepidle
argument_list|,
name|tcp_timer_keep
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_flags
operator||=
name|TF_NEEDSYN
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
block|}
else|else
block|{
comment|/* CC.NEW or no option => invalidate cache */
name|taop
operator|->
name|tao_cc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
block|}
block|}
name|trimthenstep6
label|:
comment|/* 		 * Advance th->th_seq to correspond to first data byte. 		 * If data, trim to stay within window, 		 * dropping FIN if necessary. 		 */
name|th
operator|->
name|th_seq
operator|++
expr_stmt|;
if|if
condition|(
name|tlen
operator|>
name|tp
operator|->
name|rcv_wnd
condition|)
block|{
name|todrop
operator|=
name|tlen
operator|-
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpackafterwin
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|todrop
expr_stmt|;
block|}
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|rcv_up
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
comment|/* 		 *  Client side of transaction: already sent SYN and data. 		 *  If the remote host used T/TCP to validate the SYN, 		 *  our data will be ACK'd; if so, enter normal data segment 		 *  processing in the middle of step 5, ack processing. 		 *  Otherwise, goto step 6. 		 */
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
goto|goto
name|process_ACK
goto|;
goto|goto
name|step6
goto|;
comment|/* 	 * If the state is LAST_ACK or CLOSING or TIME_WAIT: 	 *	if segment contains a SYN and CC [not CC.NEW] option: 	 *              if state == TIME_WAIT and connection duration> MSL, 	 *                  drop packet and send RST; 	 * 	 *		if SEG.CC> CCrecv then is new SYN, and can implicitly 	 *		    ack the FIN (and data) in retransmission queue. 	 *                  Complete close and delete TCPCB.  Then reprocess 	 *                  segment, hoping to find new TCPCB in LISTEN state; 	 * 	 *		else must be old SYN; drop it. 	 *      else do normal processing. 	 */
case|case
name|TCPS_LAST_ACK
case|:
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_TIME_WAIT
case|:
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_CC
operator|)
operator|&&
name|tp
operator|->
name|cc_recv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_TIME_WAIT
operator|&&
operator|(
name|ticks
operator|-
name|tp
operator|->
name|t_starttime
operator|)
operator|>
name|tcp_msl
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
if|if
condition|(
name|CC_GT
argument_list|(
name|to
operator|.
name|to_cc
argument_list|,
name|tp
operator|->
name|cc_recv
argument_list|)
condition|)
block|{
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
else|else
goto|goto
name|drop
goto|;
block|}
break|break;
comment|/* continue normal processing */
block|}
comment|/* 	 * States other than LISTEN or SYN_SENT. 	 * First check the RST flag and sequence number since reset segments 	 * are exempt from the timestamp and connection count tests.  This 	 * fixes a bug introduced by the Stevens, vol. 2, p. 960 bugfix 	 * below which allowed reset segments in half the sequence space 	 * to fall though and be processed (which gives forged reset 	 * segments with a random sequence number a 50 percent chance of 	 * killing a connection). 	 * Then check timestamp, if present. 	 * Then check the connection count, if present. 	 * Then check that at least some bytes of segment are within 	 * receive window.  If segment begins before rcv_nxt, 	 * drop leading data (and SYN); if nothing left, just ack. 	 * 	 * 	 * If the RST bit is set, check the sequence number to see 	 * if this is a valid reset segment. 	 * RFC 793 page 37: 	 *   In all states except SYN-SENT, all reset (RST) segments 	 *   are validated by checking their SEQ-fields.  A reset is 	 *   valid if its sequence number is in the window. 	 * Note: this does not take into account delayed ACKs, so 	 *   we should test against last_ack_sent instead of rcv_nxt. 	 *   The sequence number in the reset segment is normally an 	 *   echo of our outgoing acknowlegement numbers, but some hosts 	 *   send a reset with the sequence number at the rightmost edge 	 *   of our receive window, and we have to handle this case. 	 * If we have multiple segments in flight, the intial reset 	 * segment sequence numbers will be to the left of last_ack_sent, 	 * but they will eventually catch up. 	 * In any case, it never made sense to trim reset segments to 	 * fit the receive window since RFC 1122 says: 	 *   4.2.2.12  RST Segment: RFC-793 Section 3.4 	 * 	 *    A TCP SHOULD allow a received RST segment to include data. 	 * 	 *    DISCUSSION 	 *         It has been suggested that a RST segment could contain 	 *         ASCII text that encoded and explained the cause of the 	 *         RST.  No standard has yet been established for such 	 *         data. 	 * 	 * If the reset segment passes the sequence number test examine 	 * the state: 	 *    SYN_RECEIVED STATE: 	 *	If passive open, return to LISTEN state. 	 *	If active open, inform user that connection was refused. 	 *    ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSE_WAIT STATES: 	 *	Inform user that connection was reset, and close tcb. 	 *    CLOSING, LAST_ACK STATES: 	 *	Close the tcb. 	 *    TIME_WAIT STATE: 	 *	Drop the segment - see Stevens, vol. 2, p. 964 and 	 *      RFC 1337. 	 */
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
block|{
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
operator|+
name|tp
operator|->
name|rcv_wnd
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|close
goto|;
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNRESET
expr_stmt|;
name|close
label|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|tcpstat
operator|.
name|tcps_drops
operator|++
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPS_TIME_WAIT
case|:
break|break;
block|}
block|}
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * RFC 1323 PAWS: If we have a timestamp reply on this segment 	 * and it's less than ts_recent, drop it. 	 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|ts_recent
operator|&&
name|TSTMP_LT
argument_list|(
name|to
operator|.
name|to_tsval
argument_list|,
name|tp
operator|->
name|ts_recent
argument_list|)
condition|)
block|{
comment|/* Check to see if ts_recent is over 24 days old.  */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|ticks
operator|-
name|tp
operator|->
name|ts_recent_age
argument_list|)
operator|>
name|TCP_PAWS_IDLE
condition|)
block|{
comment|/* 			 * Invalidate ts_recent.  If this segment updates 			 * ts_recent, the age will be reset later and ts_recent 			 * will get a valid value.  If it does not, setting 			 * ts_recent to zero will at least satisfy the 			 * requirement that zero be placed in the timestamp 			 * echo reply when ts_recent isn't valid.  The 			 * age isn't reset until we get a valid ts_recent 			 * because we don't want out-of-order segments to be 			 * dropped when ts_recent is old. 			 */
name|tp
operator|->
name|ts_recent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tcpstat
operator|.
name|tcps_rcvduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvdupbyte
operator|+=
name|tlen
expr_stmt|;
name|tcpstat
operator|.
name|tcps_pawsdrop
operator|++
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
block|}
comment|/* 	 * T/TCP mechanism 	 *   If T/TCP was negotiated and the segment doesn't have CC, 	 *   or if its CC is wrong then drop the segment. 	 *   RST segments do not have to comply with this. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_REQ_CC
operator||
name|TF_RCVD_CC
operator|)
operator|)
operator|==
operator|(
name|TF_REQ_CC
operator||
name|TF_RCVD_CC
operator|)
operator|&&
operator|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_CC
operator|)
operator|==
literal|0
operator|||
name|tp
operator|->
name|cc_recv
operator|!=
name|to
operator|.
name|to_cc
operator|)
condition|)
goto|goto
name|dropafterack
goto|;
comment|/* 	 * In the SYN-RECEIVED state, validate that the packet belongs to 	 * this connection before trimming the data to fit the receive 	 * window.  Check the sequence number versus IRS since we know 	 * the sequence numbers haven't wrapped.  This is a partial fix 	 * for the "LAND" DoS attack. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|irs
argument_list|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|todrop
operator|=
name|tp
operator|->
name|rcv_nxt
operator|-
name|th
operator|->
name|th_seq
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
block|{
name|thflags
operator|&=
operator|~
name|TH_SYN
expr_stmt|;
name|th
operator|->
name|th_seq
operator|++
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_urp
operator|>
literal|1
condition|)
name|th
operator|->
name|th_urp
operator|--
expr_stmt|;
else|else
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|todrop
operator|--
expr_stmt|;
block|}
comment|/* 		 * Following if statement from Stevens, vol. 2, p. 960. 		 */
if|if
condition|(
name|todrop
operator|>
name|tlen
operator|||
operator|(
name|todrop
operator|==
name|tlen
operator|&&
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Any valid FIN must be to the left of the window. 			 * At this point the FIN must be a duplicate or out 			 * of sequence; drop it. 			 */
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
comment|/* 			 * Send an ACK to resynchronize and drop any data. 			 * But keep on processing for RST or ACK. 			 */
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|todrop
operator|=
name|tlen
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvdupbyte
operator|+=
name|todrop
expr_stmt|;
block|}
else|else
block|{
name|tcpstat
operator|.
name|tcps_rcvpartduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpartdupbyte
operator|+=
name|todrop
expr_stmt|;
block|}
name|drop_hdrlen
operator|+=
name|todrop
expr_stmt|;
comment|/* drop from the top afterwards */
name|th
operator|->
name|th_seq
operator|+=
name|todrop
expr_stmt|;
name|tlen
operator|-=
name|todrop
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_urp
operator|>
name|todrop
condition|)
name|th
operator|->
name|th_urp
operator|-=
name|todrop
expr_stmt|;
else|else
block|{
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If new data are received on a connection after the 	 * user processes are gone, then RST the other end. 	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|&&
name|tp
operator|->
name|t_state
operator|>
name|TCPS_CLOSE_WAIT
operator|&&
name|tlen
condition|)
block|{
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvafterclose
operator|++
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * If segment ends after window, drop trailing data 	 * (and PUSH and FIN); if nothing left, just ACK. 	 */
name|todrop
operator|=
operator|(
name|th
operator|->
name|th_seq
operator|+
name|tlen
operator|)
operator|-
operator|(
name|tp
operator|->
name|rcv_nxt
operator|+
name|tp
operator|->
name|rcv_wnd
operator|)
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvpackafterwin
operator|++
expr_stmt|;
if|if
condition|(
name|todrop
operator|>=
name|tlen
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|tlen
expr_stmt|;
comment|/* 			 * If a new connection request is received 			 * while in TIME_WAIT, drop the old connection 			 * and start over if the sequence numbers 			 * are above the previous ones. 			 */
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
operator|&&
name|tp
operator|->
name|t_state
operator|==
name|TCPS_TIME_WAIT
operator|&&
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
name|iss
operator|=
name|tcp_new_isn
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
comment|/* 			 * If window is closed can only take segments at 			 * window edge, and have to drop data and PUSH from 			 * incoming segments.  Continue processing, but 			 * remember to ack.  Otherwise, drop segment 			 * and ack. 			 */
if|if
condition|(
name|tp
operator|->
name|rcv_wnd
operator|==
literal|0
operator|&&
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvwinprobe
operator|++
expr_stmt|;
block|}
else|else
goto|goto
name|dropafterack
goto|;
block|}
else|else
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|todrop
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|todrop
expr_stmt|;
name|thflags
operator|&=
operator|~
operator|(
name|TH_PUSH
operator||
name|TH_FIN
operator|)
expr_stmt|;
block|}
comment|/* 	 * If last ACK falls within this segment's sequence numbers, 	 * record its timestamp. 	 * NOTE that the test is modified according to the latest 	 * proposal of the tcplw@cray.com list (Braden 1993/04/26). 	 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
condition|)
block|{
name|tp
operator|->
name|ts_recent_age
operator|=
name|ticks
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
block|}
comment|/* 	 * If a SYN is in the window, then this is an 	 * error and we send an RST and drop the connection. 	 */
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
block|{
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * If the ACK bit is off:  if in SYN-RECEIVED state or SENDSYN 	 * flag is on (half-synchronized state), then queue data for 	 * later processing; else drop segment and return. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
operator|)
condition|)
goto|goto
name|step6
goto|;
else|else
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Ack processing. 	 */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * In SYN_RECEIVED state, the ack ACKs our SYN, so enter 	 * ESTABLISHED state and continue processing. 	 * The ACK was checked above. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Do window scaling? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|snd_scale
operator|=
name|tp
operator|->
name|requested_s_scale
expr_stmt|;
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
block|}
comment|/* 		 * Upon successful completion of 3-way handshake, 		 * update cache.CC if it was undefined, pass any queued 		 * data to the user, and advance state appropriately. 		 */
if|if
condition|(
operator|(
name|taop
operator|=
name|tcp_gettaocache
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|taop
operator|->
name|tao_cc
operator|==
literal|0
condition|)
name|taop
operator|->
name|tao_cc
operator|=
name|tp
operator|->
name|cc_recv
expr_stmt|;
comment|/* 		 * Make transitions: 		 *      SYN-RECEIVED  -> ESTABLISHED 		 *      SYN-RECEIVED* -> FIN-WAIT-1 		 */
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDFIN
condition|)
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_1
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDFIN
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_keep
argument_list|,
name|tcp_keepidle
argument_list|,
name|tcp_timer_keep
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If segment contains data or ACK, will call tcp_reass() 		 * later; if not, do so now to pass queued data to user. 		 */
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|tcp_reass
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
operator|-
literal|1
expr_stmt|;
comment|/* fall into ... */
comment|/* 	 * In ESTABLISHED state: drop duplicate ACKs; ACK out of range 	 * ACKs.  If the ack is in the range 	 *	tp->snd_una< th->th_ack<= tp->snd_max 	 * then advance tp->snd_una to th->th_ack and drop 	 * data from the retransmission queue.  If this ACK reflects 	 * more up to date window information we update our window information. 	 */
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
case|case
name|TCPS_TIME_WAIT
case|:
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
block|{
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
name|tiwin
operator|==
name|tp
operator|->
name|snd_wnd
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvdupack
operator|++
expr_stmt|;
comment|/* 				 * If we have outstanding data (other than 				 * a window probe), this is a completely 				 * duplicate ack (ie, window info didn't 				 * change), the ack is the biggest we've 				 * seen and we've seen exactly our rexmt 				 * threshhold of them, assume a packet 				 * has been dropped and retransmit it. 				 * Kludge snd_nxt& the congestion 				 * window so we send only this one 				 * packet. 				 * 				 * We know we're losing at the current 				 * window size so do congestion avoidance 				 * (set ssthresh to half the current window 				 * and pull our congestion window back to 				 * the new ssthresh). 				 * 				 * Dup acks mean that packets have left the 				 * network (they're now cached at the receiver) 				 * so bump cwnd by the amount in the receiver 				 * to keep a constant cwnd packets in the 				 * network. 				 */
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
operator|||
name|th
operator|->
name|th_ack
operator|!=
name|tp
operator|->
name|snd_una
condition|)
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|tp
operator|->
name|t_dupacks
operator|==
name|tcprexmtthresh
condition|)
block|{
name|tcp_seq
name|onxt
init|=
name|tp
operator|->
name|snd_nxt
decl_stmt|;
name|u_int
name|win
init|=
name|min
argument_list|(
name|tp
operator|->
name|snd_wnd
argument_list|,
name|tp
operator|->
name|snd_cwnd
argument_list|)
operator|/
literal|2
operator|/
name|tp
operator|->
name|t_maxseg
decl_stmt|;
if|if
condition|(
name|tcp_do_newreno
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
block|{
comment|/* False retransmit, should not 						 * cut window 						 */
name|tp
operator|->
name|snd_cwnd
operator|+=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|tp
operator|->
name|snd_ssthresh
operator|=
name|win
operator|*
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|tp
operator|->
name|snd_recover
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
operator|+
name|tp
operator|->
name|t_maxseg
operator|*
name|tp
operator|->
name|t_dupacks
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|onxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|onxt
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|>
name|tcprexmtthresh
condition|)
block|{
name|tp
operator|->
name|snd_cwnd
operator|+=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
else|else
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * If the congestion window was inflated to account 		 * for the other side's cached packets, retract it. 		 */
if|if
condition|(
name|tcp_do_newreno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|>=
name|tcprexmtthresh
operator|&&
name|tp
operator|->
name|snd_cwnd
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
expr_stmt|;
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|>=
name|tcprexmtthresh
operator|&&
operator|!
name|tcp_newreno
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
condition|)
block|{
comment|/*                          * Window inflation should have left us with approx.                          * snd_ssthresh outstanding data.  But in case we                          * would be inclined to send a burst, better to do                          * it via the slow start mechanism.                          */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
operator|+
name|tp
operator|->
name|snd_ssthresh
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_max
operator|-
name|th
operator|->
name|th_ack
operator|+
name|tp
operator|->
name|t_maxseg
expr_stmt|;
else|else
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
expr_stmt|;
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|<
name|tcprexmtthresh
condition|)
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvacktoomuch
operator|++
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
comment|/* 		 *  If we reach this point, ACK is not a duplicate, 		 *     i.e., it ACKs something we sent. 		 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
condition|)
block|{
comment|/* 			 * T/TCP: Connection was half-synchronized, and our 			 * SYN has been ACK'd (so connection is now fully 			 * synchronized).  Go to non-starred state, 			 * increment snd_una for ACK of SYN, and check if 			 * we can do window scaling. 			 */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDSYN
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|++
expr_stmt|;
comment|/* Do window scaling? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|snd_scale
operator|=
name|tp
operator|->
name|requested_s_scale
expr_stmt|;
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
block|}
block|}
name|process_ACK
label|:
name|acked
operator|=
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackpack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackbyte
operator|+=
name|acked
expr_stmt|;
comment|/* 		 * If we just performed our first retransmit, and the ACK 		 * arrives within our recovery window, then it was a mistake 		 * to do the retransmit in the first place.  Recover our 		 * original cwnd and ssthresh, and proceed to transmit where 		 * we left off. 		 */
if|if
condition|(
name|tp
operator|->
name|t_rxtshift
operator|==
literal|1
operator|&&
name|ticks
operator|<
name|tp
operator|->
name|t_badrxtwin
condition|)
block|{
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_cwnd_prev
expr_stmt|;
name|tp
operator|->
name|snd_ssthresh
operator|=
name|tp
operator|->
name|snd_ssthresh_prev
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
name|tp
operator|->
name|t_badrxtwin
operator|=
literal|0
expr_stmt|;
comment|/* XXX probably not required */
block|}
comment|/* 		 * If we have a timestamp reply, update smoothed 		 * round trip time.  If no timestamp is present but 		 * transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 * Since we now have an rtt measurement, cancel the 		 * timer backoff (cf., Phil Karn's retransmit alg.). 		 * Recompute the initial retransmit timer. 		 */
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
condition|)
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|to
operator|.
name|to_tsecr
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_rtttime
operator|&&
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|t_rtseq
argument_list|)
condition|)
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
argument_list|)
expr_stmt|;
comment|/* 		 * If all outstanding data is acked, stop retransmit 		 * timer and remember to restart (more output or persist). 		 * If there is more data to be acked, restart retransmit 		 * timer, using current (possibly backed-off) value. 		 */
if|if
condition|(
name|th
operator|->
name|th_ack
operator|==
name|tp
operator|->
name|snd_max
condition|)
block|{
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|tp
operator|->
name|tt_persist
argument_list|)
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|,
name|tp
operator|->
name|t_rxtcur
argument_list|,
name|tcp_timer_rexmt
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * If no data (only SYN) was ACK'd, 		 *    skip rest of ACK processing. 		 */
if|if
condition|(
name|acked
operator|==
literal|0
condition|)
goto|goto
name|step6
goto|;
comment|/* 		 * When new data is acked, open the congestion window. 		 * If the window gives us less than ssthresh packets 		 * in flight, open exponentially (maxseg per packet). 		 * Otherwise open linearly: maxseg per window 		 * (maxseg^2 / cwnd per packet). 		 */
block|{
specifier|register
name|u_int
name|cw
init|=
name|tp
operator|->
name|snd_cwnd
decl_stmt|;
specifier|register
name|u_int
name|incr
init|=
name|tp
operator|->
name|t_maxseg
decl_stmt|;
if|if
condition|(
name|cw
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
name|incr
operator|=
name|incr
operator|*
name|incr
operator|/
name|cw
expr_stmt|;
comment|/* 		 * If t_dupacks != 0 here, it indicates that we are still 		 * in NewReno fast recovery mode, so we leave the congestion 		 * window alone. 		 */
if|if
condition|(
name|tcp_do_newreno
operator|==
literal|0
operator|||
name|tp
operator|->
name|t_dupacks
operator|==
literal|0
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|min
argument_list|(
name|cw
operator|+
name|incr
argument_list|,
name|TCP_MAXWIN
operator|<<
name|tp
operator|->
name|snd_scale
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acked
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
condition|)
block|{
name|tp
operator|->
name|snd_wnd
operator|-=
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
expr_stmt|;
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
operator|(
name|int
operator|)
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
name|ourfinisacked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|-=
name|acked
expr_stmt|;
name|ourfinisacked
operator|=
literal|0
expr_stmt|;
block|}
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In FIN_WAIT_1 STATE in addition to the processing 		 * for the ESTABLISHED state if our FIN is now acknowledged 		 * then enter FIN_WAIT_2. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
comment|/* 				 * If we can't receive any more 				 * data, then closing user can proceed. 				 * Starting the timer is contrary to the 				 * specification, but if we don't get a FIN 				 * we'll hang forever. 				 */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
block|{
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
name|tcp_maxidle
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
block|}
break|break;
comment|/* 		 * In CLOSING STATE in addition to the processing for 		 * the ESTABLISHED state if the ACK acknowledges our FIN 		 * then enter the TIME-WAIT state, otherwise ignore 		 * the segment. 		 */
case|case
name|TCPS_CLOSING
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
name|tcp_canceltimers
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Shorten TIME_WAIT [RFC-1644, p.28] */
if|if
condition|(
name|tp
operator|->
name|cc_recv
operator|!=
literal|0
operator|&&
operator|(
name|ticks
operator|-
name|tp
operator|->
name|t_starttime
operator|)
operator|<
name|tcp_msl
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
name|tp
operator|->
name|t_rxtcur
operator|*
name|TCPTV_TWTRUNC
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
literal|2
operator|*
name|tcp_msl
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * In LAST_ACK, we may still be waiting for data to drain 		 * and/or to be acked, as well as for the ack of our FIN. 		 * If our FIN is now acknowledged, delete the TCB, 		 * enter the closed state and return. 		 */
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
break|break;
comment|/* 		 * In TIME_WAIT state the only thing that should arrive 		 * is a retransmission of the remote FIN.  Acknowledge 		 * it and restart the finack timer. 		 */
case|case
name|TCPS_TIME_WAIT
case|:
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
literal|2
operator|*
name|tcp_msl
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
block|}
name|step6
label|:
comment|/* 	 * Update window information. 	 * Don't look at window if no ACK: TAC's send garbage on first SYN. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl1
argument_list|,
name|th
operator|->
name|th_seq
argument_list|)
operator|||
operator|(
name|tp
operator|->
name|snd_wl1
operator|==
name|th
operator|->
name|th_seq
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl2
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
operator|||
operator|(
name|tp
operator|->
name|snd_wl2
operator|==
name|th
operator|->
name|th_ack
operator|&&
name|tiwin
operator|>
name|tp
operator|->
name|snd_wnd
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
name|tp
operator|->
name|snd_wl2
operator|==
name|th
operator|->
name|th_ack
operator|&&
name|tiwin
operator|>
name|tp
operator|->
name|snd_wnd
condition|)
name|tcpstat
operator|.
name|tcps_rcvwinupd
operator|++
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
name|tp
operator|->
name|snd_wl2
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>
name|tp
operator|->
name|max_sndwnd
condition|)
name|tp
operator|->
name|max_sndwnd
operator|=
name|tp
operator|->
name|snd_wnd
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Process segments with URG. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_URG
operator|)
operator|&&
name|th
operator|->
name|th_urp
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is a kludge, but if we receive and accept 		 * random urgent pointers, we'll crash in 		 * soreceive.  It's hard to imagine someone 		 * actually wanting to send this much urgent data. 		 */
if|if
condition|(
name|th
operator|->
name|th_urp
operator|+
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
name|sb_max
condition|)
block|{
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
comment|/* XXX */
goto|goto
name|dodata
goto|;
comment|/* XXX */
block|}
comment|/* 		 * If this segment advances the known urgent pointer, 		 * then mark the data stream.  This should not happen 		 * in CLOSE_WAIT, CLOSING, LAST_ACK or TIME_WAIT STATES since 		 * a FIN has been received from the remote side. 		 * In these states we ignore the URG. 		 * 		 * According to RFC961 (Assigned Protocols), 		 * the urgent pointer points to the last octet 		 * of urgent data.  We continue, however, 		 * to consider it to indicate the first octet 		 * of data past the urgent section as the original 		 * spec states (in one of two places). 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_seq
operator|+
name|th
operator|->
name|th_urp
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
block|{
name|tp
operator|->
name|rcv_up
operator|=
name|th
operator|->
name|th_seq
operator|+
name|th
operator|->
name|th_urp
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|+
operator|(
name|tp
operator|->
name|rcv_up
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator|&=
operator|~
operator|(
name|TCPOOB_HAVEDATA
operator||
name|TCPOOB_HADDATA
operator|)
expr_stmt|;
block|}
comment|/* 		 * Remove out of band data so doesn't get presented to user. 		 * This can happen independent of advancing the URG pointer, 		 * but if two URG's are pending at once, some out-of-band 		 * data may creep in... ick. 		 */
if|if
condition|(
name|th
operator|->
name|th_urp
operator|<=
operator|(
name|u_long
operator|)
name|tlen
ifdef|#
directive|ifdef
name|SO_OOBINLINE
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
operator|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|tcp_pulloutofband
argument_list|(
name|so
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
comment|/* hdr drop is delayed */
block|}
elseif|else
comment|/* 		 * If no out of band data is expected, 		 * pull receive urgent pointer along 		 * with the receive window. 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
name|tp
operator|->
name|rcv_up
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|dodata
label|:
comment|/* XXX */
comment|/* 	 * Process the segment text, merging it into the TCP sequencing queue, 	 * and arranging for acknowledgment of receipt if necessary. 	 * This process logically involves adjusting tp->rcv_wnd as data 	 * is presented to the user (this happens in tcp_usrreq.c, 	 * case PRU_RCVD).  If a FIN has already been received on this 	 * connection then we just ignore the text. 	 */
if|if
condition|(
operator|(
name|tlen
operator|||
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|)
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
comment|/* delayed header drop */
comment|/* 		 * Insert segment which inludes th into reassembly queue of tcp with 		 * control block tp.  Return TH_FIN if reassembly now includes 		 * a segment with FIN.  This handle the common case inline (segment 		 * is the next to be received on an established connection, and the 		 * queue is empty), avoiding linkage into and removal from the queue 		 * and repetition of various conversions. 		 * Set DELACK for segments received in order, but ack immediately 		 * when segments are out of order (so fast retransmit can work). 		 */
if|if
condition|(
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|)
operator|&&
name|TCPS_HAVEESTABLISHED
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|)
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_delack
argument_list|,
name|tcp_delacktime
argument_list|,
name|tcp_timer_delack
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|tlen
expr_stmt|;
name|thflags
operator|=
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbyte
operator|+=
name|tlen
expr_stmt|;
name|ND6_HINT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thflags
operator|=
name|tcp_reass
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
operator|&
name|tlen
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
block|}
comment|/* 		 * Note the amount of data that peer has sent into 		 * our window, in order to estimate the sender's 		 * buffer size. 		 */
name|len
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|-
operator|(
name|tp
operator|->
name|rcv_adv
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
block|}
comment|/* 	 * If FIN is received ACK the FIN and let the user know 	 * that the connection is closing. 	 */
if|if
condition|(
name|thflags
operator|&
name|TH_FIN
condition|)
block|{
if|if
condition|(
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 			 *  If connection is half-synchronized 			 *  (ie NEEDSYN flag on) then delay ACK, 			 *  so it may be piggybacked when SYN is sent. 			 *  Otherwise, since we received a FIN then no 			 *  more input can be expected, send ACK now. 			 */
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
operator|)
condition|)
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_delack
argument_list|,
name|tcp_delacktime
argument_list|,
name|tcp_timer_delack
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In SYN_RECEIVED and ESTABLISHED STATES 		 * enter the CLOSE_WAIT state. 		 */
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|TCPS_ESTABLISHED
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSE_WAIT
expr_stmt|;
break|break;
comment|/* 		 * If still in FIN_WAIT_1 STATE FIN has not been acked so 		 * enter the CLOSING state. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSING
expr_stmt|;
break|break;
comment|/* 		 * In FIN_WAIT_2 state enter the TIME_WAIT state, 		 * starting the time-wait timer, turning off the other 		 * standard timers. 		 */
case|case
name|TCPS_FIN_WAIT_2
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
name|tcp_canceltimers
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Shorten TIME_WAIT [RFC-1644, p.28] */
if|if
condition|(
name|tp
operator|->
name|cc_recv
operator|!=
literal|0
operator|&&
operator|(
name|ticks
operator|-
name|tp
operator|->
name|t_starttime
operator|)
operator|<
name|tcp_msl
condition|)
block|{
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
name|tp
operator|->
name|t_rxtcur
operator|*
name|TCPTV_TWTRUNC
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* For transaction client, force ACK now. */
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
block|}
else|else
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
literal|2
operator|*
name|tcp_msl
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In TIME_WAIT state restart the 2 MSL time_wait timer. 		 */
case|case
name|TCPS_TIME_WAIT
case|:
name|callout_reset
argument_list|(
name|tp
operator|->
name|tt_2msl
argument_list|,
literal|2
operator|*
name|tcp_msl
argument_list|,
name|tcp_timer_2msl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Return any desired output. 	 */
if|if
condition|(
name|needoutput
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ACKNOW
operator|)
condition|)
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
name|dropafterack
label|:
comment|/* 	 * Generate an ACK dropping incoming segment if it occupies 	 * sequence space, where the ACK reflects our state. 	 * 	 * We can now skip the test for the RST flag since all 	 * paths to this code happen after packets containing 	 * RST have been dropped. 	 * 	 * In the SYN-RECEIVED state, don't send an ACK unless the 	 * segment we received passes the SYN-RECEIVED ACK test. 	 * If it fails send a RST.  This breaks the loop in the 	 * "LAND" DoS attack, and also prevents an ACK storm 	 * between two listening ports that have been sent forged 	 * SYN segments, each with the source address of the other. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
comment|/* 	 * Generate a RST, dropping incoming segment. 	 * Make ACK acceptable to originator of segment. 	 * Don't bother to respond if destination was broadcast/multicast. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_RST
operator|)
operator|||
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
goto|goto
name|drop
goto|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
operator|||
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* IPv6 anycast check is done at tcp6_input() */
comment|/* 	 * Perform bandwidth limiting. 	 */
if|if
condition|(
name|badport_bandlim
argument_list|(
name|rstreason
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|drop
goto|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|tp
operator|==
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|)
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
comment|/* mtod() below is safe as long as hdr dropping is delayed */
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|th
operator|->
name|th_ack
argument_list|,
name|TH_RST
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
name|tlen
operator|++
expr_stmt|;
comment|/* mtod() below is safe as long as hdr dropping is delayed */
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|th
operator|->
name|th_seq
operator|+
name|tlen
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|TH_RST
operator||
name|TH_ACK
argument_list|)
expr_stmt|;
block|}
return|return;
name|drop
label|:
comment|/* 	 * Drop space held by incoming segment and return. 	 */
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|tp
operator|==
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|)
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Parse TCP options and place in tcpopt.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_dooptions
parameter_list|(
name|to
parameter_list|,
name|cp
parameter_list|,
name|cnt
parameter_list|,
name|is_syn
parameter_list|)
name|struct
name|tcpopt
modifier|*
name|to
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|;
name|to
operator|->
name|to_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
break|break;
name|optlen
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
operator|||
name|optlen
operator|>
name|cnt
condition|)
break|break;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_MAXSEG
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_MAXSEG
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_syn
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_MSS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_mss
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_mss
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_mss
operator|=
name|ntohs
argument_list|(
name|to
operator|->
name|to_mss
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_WINDOW
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_WINDOW
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_syn
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_SCALE
expr_stmt|;
name|to
operator|->
name|to_requested_s_scale
operator|=
name|min
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|TCP_MAX_WINSHIFT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_TIMESTAMP
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_tsval
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_tsval
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_tsecr
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_tsecr
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_tsecr
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsecr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_CC
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_CC
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_CC
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_cc
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_cc
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_cc
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_cc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_CCNEW
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_CC
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_syn
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_CCNEW
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_cc
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_cc
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_cc
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_cc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_CCECHO
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_CC
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_syn
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_CCECHO
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_ccecho
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_ccecho
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_ccecho
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_ccecho
argument_list|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Pull out of band byte out of a segment so  * it doesn't appear in the user's data queue.  * It is still reflected in the segment length for  * sequencing purposes.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_pulloutofband
parameter_list|(
name|so
parameter_list|,
name|th
parameter_list|,
name|m
parameter_list|,
name|off
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* delayed to be droped hdrlen */
block|{
name|int
name|cnt
init|=
name|off
operator|+
name|th
operator|->
name|th_urp
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|cnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|cnt
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|cnt
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|tp
operator|->
name|t_iobc
operator|=
operator|*
name|cp
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator||=
name|TCPOOB_HAVEDATA
expr_stmt|;
name|bcopy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|--
expr_stmt|;
return|return;
block|}
name|cnt
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
block|}
name|panic
argument_list|(
literal|"tcp_pulloutofband"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Collect new round-trip time estimate  * and update averages and current timeout.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_xmit_timer
parameter_list|(
name|tp
parameter_list|,
name|rtt
parameter_list|)
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|int
name|rtt
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|;
name|tcpstat
operator|.
name|tcps_rttupdated
operator|++
expr_stmt|;
name|tp
operator|->
name|t_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_srtt
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * srtt is stored as fixed point with 5 bits after the 		 * binary point (i.e., scaled by 8).  The following magic 		 * is equivalent to the smoothing algorithm in rfc793 with 		 * an alpha of .875 (srtt = rtt/8 + srtt*7/8 in fixed 		 * point).  Adjust rtt to origin 0. 		 */
name|delta
operator|=
operator|(
operator|(
name|rtt
operator|-
literal|1
operator|)
operator|<<
name|TCP_DELTA_SHIFT
operator|)
operator|-
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
operator|(
name|TCP_RTT_SHIFT
operator|-
name|TCP_DELTA_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_srtt
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We accumulate a smoothed rtt variance (actually, a 		 * smoothed mean difference), then set the retransmit 		 * timer to smoothed rtt + 4 times the smoothed variance. 		 * rttvar is stored as fixed point with 4 bits after the 		 * binary point (scaled by 16).  The following is 		 * equivalent to rfc793 smoothing with an alpha of .75 		 * (rttvar = rttvar*3/4 + |delta| / 4).  This replaces 		 * rfc793's wired-in beta. 		 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
name|tp
operator|->
name|t_rttvar
operator|>>
operator|(
name|TCP_RTTVAR_SHIFT
operator|-
name|TCP_DELTA_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_rttvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No rtt measurement yet - use the unsmoothed rtt. 		 * Set the variance to half the rtt (so our first 		 * retransmit happens at 3*rtt). 		 */
name|tp
operator|->
name|t_srtt
operator|=
name|rtt
operator|<<
name|TCP_RTT_SHIFT
expr_stmt|;
name|tp
operator|->
name|t_rttvar
operator|=
name|rtt
operator|<<
operator|(
name|TCP_RTTVAR_SHIFT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_rxtshift
operator|=
literal|0
expr_stmt|;
comment|/* 	 * the retransmit should happen at rtt + 4 * rttvar. 	 * Because of the way we do the smoothing, srtt and rttvar 	 * will each average +1/2 tick of bias.  When we compute 	 * the retransmit timer, we want 1/2 tick of rounding and 	 * 1 extra tick because of +-1/2 tick uncertainty in the 	 * firing of the timer.  The bias will give us exactly the 	 * 1.5 tick we need.  But, because the bias is 	 * statistical, we have to test that we don't drop below 	 * the minimum feasible timer (which is 2 ticks). 	 */
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
name|TCP_REXMTVAL
argument_list|(
name|tp
argument_list|)
argument_list|,
name|max
argument_list|(
name|tp
operator|->
name|t_rttmin
argument_list|,
name|rtt
operator|+
literal|2
argument_list|)
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
comment|/* 	 * We received an ack for a packet that wasn't retransmitted; 	 * it is probably safe to discard any error indications we've 	 * received recently.  This isn't quite right, but close enough 	 * for now (a route might have failed after we sent a segment, 	 * and the return path might not be symmetrical). 	 */
name|tp
operator|->
name|t_softerror
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine a reasonable value for maxseg size.  * If the route is known, check route for mtu.  * If none, use an mss that can be handled on the outgoing  * interface without forcing IP to fragment; if bigger than  * an mbuf cluster (MCLBYTES), round down to nearest multiple of MCLBYTES  * to utilize large mbufs.  If no route is found, route has no mtu,  * or the destination isn't local, use a default, hopefully conservative  * size (usually 512 or the default IP max size, but no more than the mtu  * of the interface), as we can't discover anything about intervening  * gateways or networks.  We also initialize the congestion/slow start  * window to be a single segment if the destination isn't local.  * While looking at the routing entry, we also initialize other path-dependent  * parameters from pre-set or cached values in the routing entry.  *  * Also take into account the space needed for options that we  * send regularly.  Make maxseg shorter by that amount to assure  * that we can send maxseg amount of data even when the options  * are present.  Store the upper limit of the length of options plus  * data in maxopd.  *  * NOTE that this routine is only called when we process an incoming  * segment, for outgoing segments only tcp_mssopt is called.  *  * In case of T/TCP, we call this routine during implicit connection  * setup as well (offer = -1), to initialize maxseg from the cached  * MSS of our peer.  */
end_comment

begin_function
name|void
name|tcp_mss
parameter_list|(
name|tp
parameter_list|,
name|offer
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|int
name|offer
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|rtt
decl_stmt|,
name|mss
decl_stmt|;
name|u_long
name|bufsize
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|rmxp_tao
modifier|*
name|taop
decl_stmt|;
name|int
name|origoffer
init|=
name|offer
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|int
name|isipv6
decl_stmt|;
name|int
name|min_protoh
decl_stmt|;
endif|#
directive|endif
name|inp
operator|=
name|tp
operator|->
name|t_inpcb
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|isipv6
operator|=
operator|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|min_protoh
operator|=
name|isipv6
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|min_protoh
value|(sizeof (struct tcpiphdr))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
name|rt
operator|=
name|tcp_rtlookup6
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|rt
operator|=
name|tcp_rtlookup
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_maxopd
operator|=
name|tp
operator|->
name|t_maxseg
operator|=
ifdef|#
directive|ifdef
name|INET6
name|isipv6
condition|?
name|tcp_v6mssdflt
else|:
endif|#
directive|endif
comment|/* INET6 */
name|tcp_mssdflt
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|taop
operator|=
name|rmx_taop
argument_list|(
name|rt
operator|->
name|rt_rmx
argument_list|)
expr_stmt|;
comment|/* 	 * Offer == -1 means that we didn't receive SYN yet, 	 * use cached value in that case; 	 */
if|if
condition|(
name|offer
operator|==
operator|-
literal|1
condition|)
name|offer
operator|=
name|taop
operator|->
name|tao_mssopt
expr_stmt|;
comment|/* 	 * Offer == 0 means that there was no MSS on the SYN segment, 	 * in this case we use tcp_mssdflt. 	 */
if|if
condition|(
name|offer
operator|==
literal|0
condition|)
name|offer
operator|=
ifdef|#
directive|ifdef
name|INET6
name|isipv6
condition|?
name|tcp_v6mssdflt
else|:
endif|#
directive|endif
comment|/* INET6 */
name|tcp_mssdflt
expr_stmt|;
else|else
comment|/* 		 * Sanity check: make sure that maxopd will be large 		 * enough to allow some data on segments even is the 		 * all the option space is used (40bytes).  Otherwise 		 * funny things may happen in tcp_output. 		 */
name|offer
operator|=
name|max
argument_list|(
name|offer
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|taop
operator|->
name|tao_mssopt
operator|=
name|offer
expr_stmt|;
comment|/* 	 * While we're here, check if there's an initial rtt 	 * or rttvar.  Convert from the route-table units 	 * to scaled multiples of the slow timeout timer. 	 */
if|if
condition|(
name|tp
operator|->
name|t_srtt
operator|==
literal|0
operator|&&
operator|(
name|rtt
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rtt
operator|)
condition|)
block|{
comment|/* 		 * XXX the lock bit for RTT indicates that the value 		 * is also a minimum value; this is subject to time. 		 */
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator|&
name|RTV_RTT
condition|)
name|tp
operator|->
name|t_rttmin
operator|=
name|rtt
operator|/
operator|(
name|RTM_RTTUNIT
operator|/
name|hz
operator|)
expr_stmt|;
name|tp
operator|->
name|t_srtt
operator|=
name|rtt
operator|/
operator|(
name|RTM_RTTUNIT
operator|/
operator|(
name|hz
operator|*
name|TCP_RTT_SCALE
operator|)
operator|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_usedrtt
operator|++
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rttvar
condition|)
block|{
name|tp
operator|->
name|t_rttvar
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rttvar
operator|/
operator|(
name|RTM_RTTUNIT
operator|/
operator|(
name|hz
operator|*
name|TCP_RTTVAR_SCALE
operator|)
operator|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_usedrttvar
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* default variation is +- 1 rtt */
name|tp
operator|->
name|t_rttvar
operator|=
name|tp
operator|->
name|t_srtt
operator|*
name|TCP_RTTVAR_SCALE
operator|/
name|TCP_RTT_SCALE
expr_stmt|;
block|}
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
operator|(
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
literal|2
operator|)
operator|+
name|tp
operator|->
name|t_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|tp
operator|->
name|t_rttmin
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if there's an mtu associated with the route, use it 	 * else, use the link mtu. 	 */
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
condition|)
name|mss
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|-
name|min_protoh
expr_stmt|;
else|else
block|{
name|mss
operator|=
ifdef|#
directive|ifdef
name|INET6
operator|(
name|isipv6
condition|?
name|nd_ifinfo
index|[
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
index|]
operator|.
name|linkmtu
else|:
endif|#
directive|endif
name|ifp
operator|->
name|if_mtu
ifdef|#
directive|ifdef
name|INET6
operator|)
endif|#
directive|endif
operator|-
name|min_protoh
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
operator|!
name|in6_localaddr
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
condition|)
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|tcp_v6mssdflt
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|in_localaddr
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
condition|)
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|tcp_mssdflt
argument_list|)
expr_stmt|;
block|}
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|offer
argument_list|)
expr_stmt|;
comment|/* 	 * maxopd stores the maximum length of data AND options 	 * in a segment; maxseg is the amount of data in a normal 	 * segment.  We need to store this value (maxopd) apart 	 * from maxseg, because now every segment carries options 	 * and thus we normally have somewhat less data in segments. 	 */
name|tp
operator|->
name|t_maxopd
operator|=
name|mss
expr_stmt|;
comment|/* 	 * In case of T/TCP, origoffer==-1 indicates, that no segments 	 * were received yet.  In this case we just guess, otherwise 	 * we do the same as before T/TCP. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_REQ_TSTMP
operator||
name|TF_NOOPT
operator|)
operator|)
operator|==
name|TF_REQ_TSTMP
operator|&&
operator|(
name|origoffer
operator|==
operator|-
literal|1
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_RCVD_TSTMP
operator|)
operator|==
name|TF_RCVD_TSTMP
operator|)
condition|)
name|mss
operator|-=
name|TCPOLEN_TSTAMP_APPA
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_REQ_CC
operator||
name|TF_NOOPT
operator|)
operator|)
operator|==
name|TF_REQ_CC
operator|&&
operator|(
name|origoffer
operator|==
operator|-
literal|1
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_RCVD_CC
operator|)
operator|==
name|TF_RCVD_CC
operator|)
condition|)
name|mss
operator|-=
name|TCPOLEN_CC_APPA
expr_stmt|;
if|#
directive|if
operator|(
name|MCLBYTES
operator|&
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
if|if
condition|(
name|mss
operator|>
name|MCLBYTES
condition|)
name|mss
operator|&=
operator|~
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mss
operator|>
name|MCLBYTES
condition|)
name|mss
operator|=
name|mss
operator|/
name|MCLBYTES
operator|*
name|MCLBYTES
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there's a pipesize, change the socket buffer 	 * to that size.  Make the socket buffers an integral 	 * number of mss units; if the mss is larger than 	 * the socket buffer, decrease the mss. 	 */
ifdef|#
directive|ifdef
name|RTV_SPIPE
if|if
condition|(
operator|(
name|bufsize
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_sendpipe
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|bufsize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|bufsize
operator|<
name|mss
condition|)
name|mss
operator|=
name|bufsize
expr_stmt|;
else|else
block|{
name|bufsize
operator|=
name|roundup
argument_list|(
name|bufsize
argument_list|,
name|mss
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|sb_max
condition|)
name|bufsize
operator|=
name|sb_max
expr_stmt|;
operator|(
name|void
operator|)
name|sbreserve
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|bufsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_maxseg
operator|=
name|mss
expr_stmt|;
ifdef|#
directive|ifdef
name|RTV_RPIPE
if|if
condition|(
operator|(
name|bufsize
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_recvpipe
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|bufsize
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|mss
condition|)
block|{
name|bufsize
operator|=
name|roundup
argument_list|(
name|bufsize
argument_list|,
name|mss
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|sb_max
condition|)
name|bufsize
operator|=
name|sb_max
expr_stmt|;
operator|(
name|void
operator|)
name|sbreserve
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|bufsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the slow-start flight size depending on whether this 	 * is a local network or not. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|INET6
operator|(
name|isipv6
operator|&&
name|in6_localaddr
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isipv6
operator|&&
endif|#
directive|endif
name|in_localaddr
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|)
endif|#
directive|endif
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|mss
operator|*
name|ss_fltsz_local
expr_stmt|;
else|else
name|tp
operator|->
name|snd_cwnd
operator|=
name|mss
operator|*
name|ss_fltsz
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_ssthresh
condition|)
block|{
comment|/* 		 * There's some sort of gateway or interface 		 * buffer limit on the path.  Use this to set 		 * the slow start threshhold, but set the 		 * threshold to no less than 2*mss. 		 */
name|tp
operator|->
name|snd_ssthresh
operator|=
name|max
argument_list|(
literal|2
operator|*
name|mss
argument_list|,
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_ssthresh
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_usedssthresh
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine the MSS option to send on an outgoing SYN.  */
end_comment

begin_function
name|int
name|tcp_mssopt
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|int
name|isipv6
decl_stmt|;
name|int
name|min_protoh
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|isipv6
operator|=
operator|(
operator|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|min_protoh
operator|=
name|isipv6
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|min_protoh
value|(sizeof (struct tcpiphdr))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
name|rt
operator|=
name|tcp_rtlookup6
argument_list|(
operator|&
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_inc
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INET6 */
name|rt
operator|=
name|tcp_rtlookup
argument_list|(
operator|&
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
ifdef|#
directive|ifdef
name|INET6
name|isipv6
condition|?
name|tcp_v6mssdflt
else|:
endif|#
directive|endif
comment|/* INET6 */
name|tcp_mssdflt
return|;
return|return
name|rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|min_protoh
return|;
block|}
end_function

begin_comment
comment|/*  * Checks for partial ack.  If partial ack arrives, force the retransmission  * of the next unacknowledged segment, do not clear tp->t_dupacks, and return  * 1.  By setting snd_nxt to ti_ack, this forces retransmission timer to  * be started again.  If the ack advances at least to tp->snd_recover, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|tcp_newreno
parameter_list|(
name|tp
parameter_list|,
name|th
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
block|{
name|tcp_seq
name|onxt
init|=
name|tp
operator|->
name|snd_nxt
decl_stmt|;
name|u_long
name|ocwnd
init|=
name|tp
operator|->
name|snd_cwnd
decl_stmt|;
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
comment|/* 		 * Set snd_cwnd to one segment beyond acknowledged offset 		 * (tp->snd_una has not yet been updated when this function  		 *  is called) 		 */
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|t_maxseg
operator|+
operator|(
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|ocwnd
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|onxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|onxt
expr_stmt|;
comment|/* 		 * Partial window deflation.  Relies on fact that tp->snd_una 		 * not updated yet. 		 */
name|tp
operator|->
name|snd_cwnd
operator|-=
operator|(
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
operator|-
name|tp
operator|->
name|t_maxseg
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

