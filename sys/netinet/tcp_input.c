begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 2007-2008,2010  *	Swinburne University of Technology, Melbourne, Australia.  * Copyright (c) 2009-2010 Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2010 The FreeBSD Foundation  * Copyright (c) 2010-2011 Juniper Networks, Inc.  * All rights reserved.  *  * Portions of this software were developed at the Centre for Advanced Internet  * Architectures, Swinburne University of Technology, by Lawrence Stewart,  * James Healy and David Hayes, made possible in part by a grant from the Cisco  * University Research Program Fund at Community Foundation Silicon Valley.  *  * Portions of this software were developed at the Centre for Advanced  * Internet Architectures, Swinburne University of Technology, Melbourne,  * Australia by David Hayes under sponsorship from the FreeBSD Foundation.  *  * Portions of this software were developed by Robert N. M. Watson under  * contract to Juniper Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tcp_input.c	8.12 (Berkeley) 5/24/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcpdebug.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_HHOOK
end_ifdef

begin_include
include|#
directive|include
file|<sys/hhook.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for proc0 declaration */
end_comment

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* before tcp_seq.h, for tcp_random18() */
end_comment

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_comment
comment|/* for logging */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_kdtrace.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_comment
comment|/* required for icmp_var.h */
end_comment

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_comment
comment|/* for ICMP_BANDLIM */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_options.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_RFC7413
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_fastopen.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/tcp6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc/cc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPPCAP
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_pcap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp_syncache.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPDEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ipsec_support.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_decl_stmt
specifier|const
name|int
name|tcprexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcp_log_in_vain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|log_in_vain
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tcp_log_in_vain
argument_list|,
literal|0
argument_list|,
literal|"Log all incoming TCP segments to closed ports"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|blackhole
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_blackhole
value|VNET(blackhole)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|blackhole
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|blackhole
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Do not send RST on segments to closed ports"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_delack_enabled
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|delayed_ack
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_delack_enabled
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Delay ACK to try and piggyback it onto a data packet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|drop_synfin
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_drop_synfin
value|VNET(drop_synfin)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|drop_synfin
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|drop_synfin
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Drop TCP packets with SYN+FIN set"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_rfc6675_pipe
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|rfc6675_pipe
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_rfc6675_pipe
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Use calculated pipe/in-flight bytes per RFC 6675"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_rfc3042
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_rfc3042
value|VNET(tcp_do_rfc3042)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|rfc3042
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_rfc3042
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable RFC 3042 (Limited Transmit)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_rfc3390
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|rfc3390
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_rfc3390
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable RFC 3390 (Increasing TCP's Initial Congestion Window)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_initcwnd_segments
argument_list|)
operator|=
literal|10
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|initcwnd_segments
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_initcwnd_segments
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Slow-start flight size (initial congestion window) in number of segments"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_rfc3465
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|rfc3465
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_rfc3465
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable RFC 3465 (Appropriate Byte Counting)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_abc_l_var
argument_list|)
operator|=
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|abc_l_var
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_abc_l_var
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Cap the max cwnd increment during slow-start to this number of segments"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|ecn
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TCP ECN"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_ecn
argument_list|)
operator|=
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp_ecn
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_ecn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"TCP ECN support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_ecn_maxretries
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp_ecn
argument_list|,
name|OID_AUTO
argument_list|,
name|maxretries
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_ecn_maxretries
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Max retries before giving up on ECN"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_insecure_syn
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_insecure_syn
value|VNET(tcp_insecure_syn)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|insecure_syn
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_insecure_syn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Follow RFC793 instead of RFC5961 criteria for accepting SYN packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_insecure_rst
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_insecure_rst
value|VNET(tcp_insecure_rst)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|insecure_rst
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_insecure_rst
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Follow RFC793 instead of RFC5961 criteria for accepting RST packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_recvspace
argument_list|)
operator|=
literal|1024
operator|*
literal|64
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_recvspace
value|VNET(tcp_recvspace)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|TCPCTL_RECVSPACE
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_recvspace
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Initial receive socket buffer size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_do_autorcvbuf
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_do_autorcvbuf
value|VNET(tcp_do_autorcvbuf)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|recvbuf_auto
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_do_autorcvbuf
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable automatic receive buffer sizing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_inc
argument_list|)
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_inc
value|VNET(tcp_autorcvbuf_inc)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|recvbuf_inc
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_autorcvbuf_inc
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Incrementor step size of automatic receive buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_autorcvbuf_max
argument_list|)
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_autorcvbuf_max
value|VNET(tcp_autorcvbuf_max)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|recvbuf_max
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_autorcvbuf_max
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Max size of automatic receive buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbhead
argument_list|,
name|tcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|tcb6
value|tcb
end_define

begin_comment
comment|/* for KAME src sync over BSD*'s */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbinfo
argument_list|,
name|tcbinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * TCP statistics are stored in an array of counter(9)s, which size matches  * size of struct tcpstat.  TCP running connection count is a regular array.  */
end_comment

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|tcpstat
argument_list|,
name|tcpstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|TCPCTL_STATS
argument_list|,
name|stats
argument_list|,
expr|struct
name|tcpstat
argument_list|,
name|tcpstat
argument_list|,
literal|"TCP statistics (struct tcpstat, netinet/tcp_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|counter_u64_t
argument_list|,
name|tcps_states
index|[
name|TCP_NSTATES
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_COUNTER_U64_ARRAY
argument_list|(
name|_net_inet_tcp
argument_list|,
name|TCPCTL_STATES
argument_list|,
name|states
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcps_states
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|TCP_NSTATES
argument_list|,
literal|"TCP connection counts by TCP state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|tcp_vnet_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|COUNTER_ARRAY_ALLOC
argument_list|(
name|V_tcps_states
argument_list|,
name|TCP_NSTATES
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|VNET_PCPUSTAT_ALLOC
argument_list|(
name|tcpstat
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|tcp_vnet_init
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|tcp_vnet_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
specifier|static
name|void
name|tcp_vnet_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|COUNTER_ARRAY_FREE
argument_list|(
name|V_tcps_states
argument_list|,
name|TCP_NSTATES
argument_list|)
expr_stmt|;
name|VNET_PCPUSTAT_FREE
argument_list|(
name|tcpstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|tcp_vnet_uninit
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|tcp_vnet_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_comment
comment|/*  * Kernel module interface for updating tcpstat.  The argument is an index  * into tcpstat treated as an array.  */
end_comment

begin_function
name|void
name|kmod_tcpstat_inc
parameter_list|(
name|int
name|statnum
parameter_list|)
block|{
name|counter_u64_add
argument_list|(
name|VNET
argument_list|(
name|tcpstat
argument_list|)
index|[
name|statnum
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_HHOOK
end_ifdef

begin_comment
comment|/*  * Wrapper for the TCP established input helper hook.  */
end_comment

begin_function
name|void
name|hhook_run_tcp_est_in
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|tcp_hhook_data
name|hhook_data
decl_stmt|;
if|if
condition|(
name|V_tcp_hhh
index|[
name|HHOOK_TCP_EST_IN
index|]
operator|->
name|hhh_nhooks
operator|>
literal|0
condition|)
block|{
name|hhook_data
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|hhook_data
operator|.
name|th
operator|=
name|th
expr_stmt|;
name|hhook_data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|hhook_run_hooks
argument_list|(
name|V_tcp_hhh
index|[
name|HHOOK_TCP_EST_IN
index|]
argument_list|,
operator|&
name|hhook_data
argument_list|,
name|tp
operator|->
name|osd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CC wrapper hook functions  */
end_comment

begin_function
name|void
name|cc_ack_received
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|uint16_t
name|nsegs
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ccv
operator|->
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|tp
operator|->
name|ccv
operator|->
name|bytes_this_ack
operator|=
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|<=
name|tp
operator|->
name|snd_wnd
condition|)
name|tp
operator|->
name|ccv
operator|->
name|flags
operator||=
name|CCF_CWND_LIMITED
expr_stmt|;
else|else
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_CWND_LIMITED
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CC_ACK
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
block|{
name|tp
operator|->
name|t_bytes_acked
operator|+=
name|min
argument_list|(
name|tp
operator|->
name|ccv
operator|->
name|bytes_this_ack
argument_list|,
name|nsegs
operator|*
name|V_tcp_abc_l_var
operator|*
name|tcp_maxseg
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_bytes_acked
operator|>=
name|tp
operator|->
name|snd_cwnd
condition|)
block|{
name|tp
operator|->
name|t_bytes_acked
operator|-=
name|tp
operator|->
name|snd_cwnd
expr_stmt|;
name|tp
operator|->
name|ccv
operator|->
name|flags
operator||=
name|CCF_ABC_SENTAWND
expr_stmt|;
block|}
block|}
else|else
block|{
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_ABC_SENTAWND
expr_stmt|;
name|tp
operator|->
name|t_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|ack_received
operator|!=
name|NULL
condition|)
block|{
comment|/* XXXLAS: Find a way to live without this */
name|tp
operator|->
name|ccv
operator|->
name|curack
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|ack_received
argument_list|(
name|tp
operator|->
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cc_conn_init
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|hc_metrics_lite
name|metrics
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|u_int
name|maxseg
decl_stmt|;
name|int
name|rtt
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_hc_get
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
name|maxseg
operator|=
name|tcp_maxseg
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_srtt
operator|==
literal|0
operator|&&
operator|(
name|rtt
operator|=
name|metrics
operator|.
name|rmx_rtt
operator|)
condition|)
block|{
name|tp
operator|->
name|t_srtt
operator|=
name|rtt
expr_stmt|;
name|tp
operator|->
name|t_rttbest
operator|=
name|tp
operator|->
name|t_srtt
operator|+
name|TCP_RTT_SCALE
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_usedrtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|.
name|rmx_rttvar
condition|)
block|{
name|tp
operator|->
name|t_rttvar
operator|=
name|metrics
operator|.
name|rmx_rttvar
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_usedrttvar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default variation is +- 1 rtt */
name|tp
operator|->
name|t_rttvar
operator|=
name|tp
operator|->
name|t_srtt
operator|*
name|TCP_RTTVAR_SCALE
operator|/
name|TCP_RTT_SCALE
expr_stmt|;
block|}
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
operator|(
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
literal|2
operator|)
operator|+
name|tp
operator|->
name|t_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|tp
operator|->
name|t_rttmin
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|.
name|rmx_ssthresh
condition|)
block|{
comment|/* 		 * There's some sort of gateway or interface 		 * buffer limit on the path.  Use this to set 		 * the slow start threshold, but set the 		 * threshold to no less than 2*mss. 		 */
name|tp
operator|->
name|snd_ssthresh
operator|=
name|max
argument_list|(
literal|2
operator|*
name|maxseg
argument_list|,
name|metrics
operator|.
name|rmx_ssthresh
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_usedssthresh
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the initial slow-start flight size. 	 * 	 * RFC5681 Section 3.1 specifies the default conservative values. 	 * RFC3390 specifies slightly more aggressive values. 	 * RFC6928 increases it to ten segments. 	 * Support for user specified value for initial flight size. 	 * 	 * If a SYN or SYN/ACK was lost and retransmitted, we have to 	 * reduce the initial CWND to one segment as congestion is likely 	 * requiring us to be cautious. 	 */
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|==
literal|1
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|maxseg
expr_stmt|;
comment|/* SYN(-ACK) lost */
elseif|else
if|if
condition|(
name|V_tcp_initcwnd_segments
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|min
argument_list|(
name|V_tcp_initcwnd_segments
operator|*
name|maxseg
argument_list|,
name|max
argument_list|(
literal|2
operator|*
name|maxseg
argument_list|,
name|V_tcp_initcwnd_segments
operator|*
literal|1460
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|V_tcp_do_rfc3390
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|min
argument_list|(
literal|4
operator|*
name|maxseg
argument_list|,
name|max
argument_list|(
literal|2
operator|*
name|maxseg
argument_list|,
literal|4380
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Per RFC5681 Section 3.1 */
if|if
condition|(
name|maxseg
operator|>
literal|2190
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
literal|2
operator|*
name|maxseg
expr_stmt|;
elseif|else
if|if
condition|(
name|maxseg
operator|>
literal|1095
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
literal|3
operator|*
name|maxseg
expr_stmt|;
else|else
name|tp
operator|->
name|snd_cwnd
operator|=
literal|4
operator|*
name|maxseg
expr_stmt|;
block|}
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|conn_init
operator|!=
name|NULL
condition|)
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|conn_init
argument_list|(
name|tp
operator|->
name|ccv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
specifier|inline
name|cc_cong_signal
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
name|u_int
name|maxseg
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CC_NDUPACK
case|:
if|if
condition|(
operator|!
name|IN_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|tp
operator|->
name|snd_recover
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ECN_PERMIT
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_ECN_SND_CWR
expr_stmt|;
block|}
break|break;
case|case
name|CC_ECN
case|:
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_ecn_rcwnd
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_recover
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ECN_PERMIT
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_ECN_SND_CWR
expr_stmt|;
block|}
break|break;
case|case
name|CC_RTO
case|:
name|maxseg
operator|=
name|tcp_maxseg
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_bytes_acked
operator|=
literal|0
expr_stmt|;
name|EXIT_RECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * RFC5681 Section 3.1  			 * ssthresh = max (FlightSize / 2, 2*SMSS) eq (4) 			 */
name|tp
operator|->
name|snd_ssthresh
operator|=
name|max
argument_list|(
operator|(
name|tp
operator|->
name|snd_max
operator|-
name|tp
operator|->
name|snd_una
operator|)
operator|/
literal|2
operator|/
name|maxseg
argument_list|,
literal|2
argument_list|)
operator|*
name|maxseg
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|maxseg
expr_stmt|;
block|}
break|break;
case|case
name|CC_RTO_ERR
case|:
name|TCPSTAT_INC
argument_list|(
name|tcps_sndrexmitbad
argument_list|)
expr_stmt|;
comment|/* RTO was unnecessary, so reset everything. */
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_cwnd_prev
expr_stmt|;
name|tp
operator|->
name|snd_ssthresh
operator|=
name|tp
operator|->
name|snd_ssthresh_prev
expr_stmt|;
name|tp
operator|->
name|snd_recover
operator|=
name|tp
operator|->
name|snd_recover_prev
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_WASFRECOVERY
condition|)
name|ENTER_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_WASCRECOVERY
condition|)
name|ENTER_CONGRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_PREVVALID
expr_stmt|;
name|tp
operator|->
name|t_badrxtwin
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|th
operator|!=
name|NULL
condition|)
name|tp
operator|->
name|ccv
operator|->
name|curack
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
argument_list|(
name|tp
operator|->
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
specifier|inline
name|cc_post_recovery
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* XXXLAS: KASSERT that we're in recovery? */
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|post_recovery
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|ccv
operator|->
name|curack
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|post_recovery
argument_list|(
name|tp
operator|->
name|ccv
argument_list|)
expr_stmt|;
block|}
comment|/* XXXLAS: EXIT_RECOVERY ? */
name|tp
operator|->
name|t_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Indicate whether this ack should be delayed.  We can delay the ack if  * following conditions are met:  *	- There is no delayed ack timer in progress.  *	- Our last ack wasn't a 0-sized window. We never want to delay  *	  the ack that opens up a 0-sized window.  *	- LRO wasn't used for this segment. We make sure by checking that the  *	  segment size is not larger than the MSS.  */
end_comment

begin_define
define|#
directive|define
name|DELAY_ACK
parameter_list|(
name|tp
parameter_list|,
name|tlen
parameter_list|)
define|\
value|((!tcp_timer_active(tp, TT_DELACK)&&				\ 	    (tp->t_flags& TF_RXWIN0SENT) == 0)&&			\ 	    (tlen<= tp->t_maxseg)&&					\ 	    (V_tcp_delack_enabled || (tp->t_flags& TF_NEEDSYN)))
end_define

begin_function
specifier|static
name|void
specifier|inline
name|cc_ecnpkt_handler
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|uint8_t
name|iptos
parameter_list|)
block|{
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|ecnpkt_handler
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|iptos
operator|&
name|IPTOS_ECN_MASK
condition|)
block|{
case|case
name|IPTOS_ECN_CE
case|:
name|tp
operator|->
name|ccv
operator|->
name|flags
operator||=
name|CCF_IPHDR_CE
expr_stmt|;
break|break;
case|case
name|IPTOS_ECN_ECT0
case|:
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_IPHDR_CE
expr_stmt|;
break|break;
case|case
name|IPTOS_ECN_ECT1
case|:
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_IPHDR_CE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_CWR
condition|)
name|tp
operator|->
name|ccv
operator|->
name|flags
operator||=
name|CCF_TCPHDR_CWR
expr_stmt|;
else|else
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_TCPHDR_CWR
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_DELACK
condition|)
name|tp
operator|->
name|ccv
operator|->
name|flags
operator||=
name|CCF_DELACK
expr_stmt|;
else|else
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_DELACK
expr_stmt|;
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|ecnpkt_handler
argument_list|(
name|tp
operator|->
name|ccv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ccv
operator|->
name|flags
operator|&
name|CCF_ACKNOW
condition|)
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_DELACK
argument_list|,
name|tcp_delacktime
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TCP input handling is split into multiple parts:  *   tcp6_input is a thin wrapper around tcp_input for the extended  *	ip6_protox[] call format in ip6_input  *   tcp_input handles primary segment validation, inpcb lookup and  *	SYN processing on listen sockets  *   tcp_do_segment processes the ACK and text of the segment for  *	establishing, established and closing connections  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|tcp6_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
operator|*
name|offp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
name|IPPROTO_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * draft-itojun-ipv6-tcp-to-anycast 	 * better place to put this in? 	 */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ia6
operator|=
name|in6ifa_ifwithaddr
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
literal|0
comment|/* XXX */
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_ANYCAST
operator|)
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|ifa_free
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
operator|->
name|ip6_dst
operator|-
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
name|ia6
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
name|tcp_input
argument_list|(
name|mp
argument_list|,
name|offp
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
name|int
name|tcp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|optp
init|=
name|NULL
decl_stmt|;
name|int
name|off0
decl_stmt|;
name|int
name|optlen
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|int
name|len
decl_stmt|;
endif|#
directive|endif
name|int
name|tlen
init|=
literal|0
decl_stmt|,
name|off
decl_stmt|;
name|int
name|drop_hdrlen
decl_stmt|;
name|int
name|thflags
decl_stmt|;
name|int
name|rstreason
init|=
literal|0
decl_stmt|;
comment|/* For badport_bandlim accounting purposes */
name|uint8_t
name|iptos
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|fwd_tag
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|NULL
decl_stmt|;
name|int
name|isipv6
decl_stmt|;
else|#
directive|else
specifier|const
name|void
modifier|*
name|ip6
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|struct
name|tcpopt
name|to
decl_stmt|;
comment|/* options in this segment */
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
comment|/* address and port logging */
name|int
name|ti_locked
decl_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
comment|/* 	 * The size of tcp_saveipgen must be the size of the max ip header, 	 * now IPv6. 	 */
name|u_char
name|tcp_saveipgen
index|[
name|IP6_HDR_LEN
index|]
decl_stmt|;
name|struct
name|tcphdr
name|tcp_savetcp
decl_stmt|;
name|short
name|ostate
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|isipv6
operator|=
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_v
operator|==
literal|6
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|off0
operator|=
operator|*
name|offp
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
name|to
operator|.
name|to_flags
operator|=
literal|0
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvtotal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
comment|/* IP6_EXTHDR_CHECK() is already done at tcp6_input(). */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off0
operator|)
expr_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|-
name|off0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID_IPV6
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
name|th
operator|->
name|th_sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
else|else
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
name|tlen
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|^=
literal|0xffff
expr_stmt|;
block|}
else|else
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum
argument_list|(
name|m
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|off0
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_sum
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvbadsum
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * Be proactive about unspecified IPv6 address in source. 		 * As we use all-zero to indicate unbounded/unconnected pcb, 		 * unspecified IPv6 address can be used to confuse us. 		 * 		 * Note that packets with unspecified IPv6 destination is 		 * already dropped in ip6_input. 		 */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
comment|/* XXX stat */
goto|goto
name|drop
goto|;
block|}
name|iptos
operator|=
operator|(
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
comment|/* 		 * Get IP and TCP header together in first mbuf. 		 * Note: IP leaves IP header in first mbuf. 		 */
if|if
condition|(
name|off0
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|ip_stripoptions
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|off0
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|off0
operator|)
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|off0
expr_stmt|;
name|iptos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
name|th
operator|->
name|th_sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
else|else
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
name|tlen
operator|+
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|^=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ipovly
modifier|*
name|ipov
init|=
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
decl_stmt|;
comment|/* 			 * Checksum extended TCP header and data. 			 */
name|len
operator|=
name|off0
operator|+
name|tlen
expr_stmt|;
name|bzero
argument_list|(
name|ipov
operator|->
name|ih_x1
argument_list|,
sizeof|sizeof
argument_list|(
name|ipov
operator|->
name|ih_x1
argument_list|)
argument_list|)
expr_stmt|;
name|ipov
operator|->
name|ih_len
operator|=
name|htons
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Reset length for SDT probes. */
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Reset TOS bits */
name|ip
operator|->
name|ip_tos
operator|=
name|iptos
expr_stmt|;
comment|/* Re-initialization for later version check */
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_sum
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvbadsum
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INET */
comment|/* 	 * Check that TCP offset makes sense, 	 * pull out TCP options and adjust length.		XXX 	 */
name|off
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|off
operator|>
name|tlen
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvbadoff
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|tlen
operator|-=
name|off
expr_stmt|;
comment|/* tlen is used instead of ti->ti_len */
if|if
condition|(
name|off
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off0
argument_list|,
name|off
argument_list|,
name|IPPROTO_DONE
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|off0
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|optlen
operator|=
name|off
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|optp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|thflags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
comment|/* 	 * Convert TCP protocol specific fields to host format. 	 */
name|tcp_fields_to_host
argument_list|(
name|th
argument_list|)
expr_stmt|;
comment|/* 	 * Delay dropping TCP, IP headers, IPv6 ext headers, and TCP options. 	 */
name|drop_hdrlen
operator|=
name|off0
operator|+
name|off
expr_stmt|;
comment|/* 	 * Locate pcb for segment; if we're likely to add or remove a 	 * connection then first acquire pcbinfo lock.  There are three cases 	 * where we might discover later we need a write lock despite the 	 * flags: ACKs moving a connection out of the syncache, ACKs for a 	 * connection in TIMEWAIT and SYNs not targeting a listening socket. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_RST
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_RLOCKED
expr_stmt|;
block|}
else|else
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
comment|/* 	 * Grab info from PACKET_TAG_IPFORWARD tag prepended to the chain. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|INET6
operator|(
name|isipv6
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP6_NEXTHOP
operator|)
operator|)
ifdef|#
directive|ifdef
name|INET
operator|||
operator|(
operator|!
name|isipv6
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP_NEXTHOP
operator|)
operator|)
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|INET6
argument_list|)
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP_NEXTHOP
operator|)
endif|#
directive|endif
condition|)
name|fwd_tag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPFORWARD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|findpcb
label|:
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
block|{
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
operator|&&
name|fwd_tag
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|next_hop6
decl_stmt|;
name|next_hop6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|fwd_tag
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Transparently forwarded. Pretend to be the destination. 		 * Already got one like this? 		 */
name|inp
operator|=
name|in6_pcblookup_mbuf
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
comment|/* 			 * It's new.  Try to find the ambushing socket. 			 * Because we've rewritten the destination address, 			 * any hardware-generated hash is ignored. 			 */
name|inp
operator|=
name|in6_pcblookup
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
operator|&
name|next_hop6
operator|->
name|sin6_addr
argument_list|,
name|next_hop6
operator|->
name|sin6_port
condition|?
name|ntohs
argument_list|(
name|next_hop6
operator|->
name|sin6_port
argument_list|)
else|:
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isipv6
condition|)
block|{
name|inp
operator|=
name|in6_pcblookup_mbuf
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET
argument_list|)
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|fwd_tag
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|next_hop
decl_stmt|;
name|next_hop
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|fwd_tag
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Transparently forwarded. Pretend to be the destination. 		 * already got one like this? 		 */
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
comment|/* 			 * It's new.  Try to find the ambushing socket. 			 * Because we've rewritten the destination address, 			 * any hardware-generated hash is ignored. 			 */
name|inp
operator|=
name|in_pcblookup
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|next_hop
operator|->
name|sin_addr
argument_list|,
name|next_hop
operator|->
name|sin_port
condition|?
name|ntohs
argument_list|(
name|next_hop
operator|->
name|sin_port
argument_list|)
else|:
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
operator|&
name|V_tcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_WLOCKPCB
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET */
comment|/* 	 * If the INPCB does not exist then all data in the incoming 	 * segment is discarded and an appropriate RST is sent back. 	 * XXX MRT Send RST using which routing table? 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Log communication attempts to ports that are not 		 * in use. 		 */
if|if
condition|(
operator|(
name|tcp_log_in_vain
operator|==
literal|1
operator|&&
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|)
operator|||
name|tcp_log_in_vain
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_vain
argument_list|(
name|NULL
argument_list|,
name|th
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
name|ip6
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s; %s: Connection attempt "
literal|"to closed port\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When blackholing do not respond with a RST but 		 * completely ignore the segment and drop it. 		 */
if|if
condition|(
operator|(
name|V_blackhole
operator|==
literal|1
operator|&&
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|)
operator|||
name|V_blackhole
operator|==
literal|2
condition|)
goto|goto
name|dropunlock
goto|;
name|rstreason
operator|=
name|BANDLIM_RST_CLOSEDPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * While waiting for inp lock during the lookup, another thread 	 * can have dropped the inpcb, in which case we need to loop back 	 * and try to find a new inpcb to deliver to. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_flowtype
operator|==
name|M_HASHTYPE_NONE
operator|)
operator|&&
operator|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|inp_socket
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|inp
operator|->
name|inp_flowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|inp
operator|->
name|inp_flowtype
operator|=
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
operator|&&
name|IPSEC_ENABLED
argument_list|(
name|ipv6
argument_list|)
operator|&&
name|IPSEC_CHECK_POLICY
argument_list|(
name|ipv6
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|dropunlock
goto|;
block|}
ifdef|#
directive|ifdef
name|INET
elseif|else
endif|#
directive|endif
endif|#
directive|endif
comment|/* INET6 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv4
argument_list|)
operator|&&
name|IPSEC_CHECK_POLICY
argument_list|(
name|ipv4
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|dropunlock
goto|;
block|}
endif|#
directive|endif
comment|/* INET */
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * Check the minimum TTL for socket. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_ip_minttl
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_ip_minttl
operator|>
name|ip6
operator|->
name|ip6_hlim
condition|)
goto|goto
name|dropunlock
goto|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_ip_minttl
operator|>
name|ip
operator|->
name|ip_ttl
condition|)
goto|goto
name|dropunlock
goto|;
block|}
comment|/* 	 * A previous connection in TIMEWAIT state is supposed to catch stray 	 * or duplicate segments arriving late.  If this segment was a 	 * legitimate new connection attempt, the old INPCB gets removed and 	 * we can try again to find a listening socket. 	 * 	 * At this point, due to earlier optimism, we may hold only an inpcb 	 * lock, and not the inpcbinfo write lock.  If so, we need to try to 	 * acquire it, or if that fails, acquire a reference on the inpcb, 	 * drop all locks, acquire a global write lock, and then re-acquire 	 * the inpcb lock.  We may at that point discover that another thread 	 * has tried to free the inpcb, in which case we need to loop back 	 * and try to find a new inpcb to deliver to. 	 * 	 * XXXRW: It may be time to rethink timewait locking. 	 */
name|relocked
label|:
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_TIMEWAIT
condition|)
block|{
if|if
condition|(
name|ti_locked
operator|==
name|TI_UNLOCKED
condition|)
block|{
if|if
condition|(
name|INP_INFO_TRY_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_RLOCKED
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
block|{
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
elseif|else
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
block|}
else|else
name|ti_locked
operator|=
name|TI_RLOCKED
expr_stmt|;
block|}
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
name|TO_SYN
argument_list|)
expr_stmt|;
comment|/* 		 * NB: tcp_twcheck unlocks the INP and frees the mbuf. 		 */
if|if
condition|(
name|tcp_twcheck
argument_list|(
name|inp
argument_list|,
operator|&
name|to
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|tlen
argument_list|)
condition|)
goto|goto
name|findpcb
goto|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * The TCPCB may no longer exist if the connection is winding 	 * down or it is in the CLOSED state.  Either way we drop the 	 * segment and send an appropriate response. 	 */
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_CLOSEDPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
condition|)
block|{
name|tcp_offload_input
argument_list|(
name|tp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* consumed by the TOE driver */
goto|goto
name|dropunlock
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * We've identified a valid inpcb, but it could be that we need an 	 * inpcbinfo write lock but don't hold it.  In this case, attempt to 	 * acquire using the same strategy as the TIMEWAIT case above.  If we 	 * relock, we have to jump back to 'relocked' as the connection might 	 * now be in TIMEWAIT. 	 */
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_RST
operator|)
operator|)
operator|!=
literal|0
condition|)
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_ESTABLISHED
operator|&&
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
operator|&&
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|!
name|IS_FASTOPEN
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ti_locked
operator|==
name|TI_UNLOCKED
condition|)
block|{
if|if
condition|(
name|INP_INFO_TRY_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_RLOCKED
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
condition|)
block|{
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
elseif|else
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
goto|goto
name|relocked
goto|;
block|}
else|else
name|ti_locked
operator|=
name|TI_RLOCKED
expr_stmt|;
block|}
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_inpcb_check_deliver
argument_list|(
name|inp
argument_list|,
name|m
argument_list|)
condition|)
goto|goto
name|dropunlock
goto|;
endif|#
directive|endif
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: so == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
block|{
name|ostate
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip6
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_savetcp
operator|=
operator|*
name|th
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCPDEBUG */
comment|/* 	 * When the socket is accepting connections (the INPCB is in LISTEN 	 * state) we look into the SYN cache if this is a new connection 	 * attempt or the completion of a previous one. 	 */
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
operator|||
operator|!
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
argument_list|,
operator|(
literal|"%s: so accepting but tp %p not listening"
operator|,
name|__func__
operator|,
name|tp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
condition|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
name|inc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|inc
operator|.
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
name|inc
operator|.
name|inc6_faddr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|inc
operator|.
name|inc6_laddr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|inc
operator|.
name|inc_faddr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|inc
operator|.
name|inc_laddr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
block|}
name|inc
operator|.
name|inc_fport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|inc
operator|.
name|inc_lport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
name|inc
operator|.
name|inc_fibnum
operator|=
name|so
operator|->
name|so_fibnum
expr_stmt|;
comment|/* 		 * Check for an existing connection attempt in syncache if 		 * the flag is only ACK.  A successful lookup creates a new 		 * socket appended to the listen queue in SYN_RECEIVED state. 		 */
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator||
name|TH_SYN
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* 			 * Parse the TCP options here because 			 * syncookies need access to the reflected 			 * timestamp. 			 */
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * NB: syncache_expand() doesn't unlock 			 * inp and tcpinfo locks. 			 */
name|rstreason
operator|=
name|syncache_expand
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
name|th
argument_list|,
operator|&
name|so
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstreason
operator|<
literal|0
condition|)
block|{
comment|/* 				 * A failing TCP MD5 signature comparison 				 * must result in the segment being dropped 				 * and must not produce any response back 				 * to the sender. 				 */
goto|goto
name|dropunlock
goto|;
block|}
elseif|else
if|if
condition|(
name|rstreason
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No syncache entry or ACK was not 				 * for our SYN/ACK.  Send a RST. 				 * NB: syncache did its own logging 				 * of the failure cause. 				 */
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_RFC7413
name|tfo_socket_result
label|:
endif|#
directive|endif
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We completed the 3-way handshake 				 * but could not allocate a socket 				 * either due to memory shortage, 				 * listen queue length limits or 				 * global socket limits.  Send RST 				 * or wait and have the remote end 				 * retransmit the ACK for another 				 * try. 				 */
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Socket allocation failed due to "
literal|"limits or memory shortage, %s\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|,
name|V_tcp_sc_rst_sock_fail
condition|?
literal|"sending RST"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_tcp_sc_rst_sock_fail
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
else|else
goto|goto
name|dropunlock
goto|;
block|}
comment|/* 			 * Socket is created in state SYN_RECEIVED. 			 * Unlock the listen socket, lock the newly 			 * created socket and update the tp variable. 			 */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* listen socket */
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 			 * New connection inpcb is already locked by 			 * syncache_expand(). 			 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
argument_list|,
operator|(
literal|"%s: "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Process the segment and the data it 			 * contains.  tcp_do_segment() consumes 			 * the mbuf chain and unlocks the inpcb. 			 */
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_do_segment
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|so
argument_list|,
name|tp
argument_list|,
name|drop_hdrlen
argument_list|,
name|tlen
argument_list|,
name|iptos
argument_list|,
name|ti_locked
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 		 * Segment flag validation for new connection attempts: 		 * 		 * Our (SYN|ACK) response was rejected. 		 * Check with syncache and remove entry to prevent 		 * retransmits. 		 * 		 * NB: syncache_chkrst does its own logging of failure 		 * causes. 		 */
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
block|{
name|syncache_chkrst
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
comment|/* 		 * We can't do anything without SYN. 		 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"SYN is missing, segment ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_badsyn
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
comment|/* 		 * (SYN|ACK) is bogus on a listen socket. 		 */
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"SYN|ACK invalid, segment rejected\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|syncache_badack
argument_list|(
operator|&
name|inc
argument_list|)
expr_stmt|;
comment|/* XXX: Not needed! */
name|TCPSTAT_INC
argument_list|(
name|tcps_badsyn
argument_list|)
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 		 * If the drop_synfin option is enabled, drop all 		 * segments with both the SYN and FIN bits set. 		 * This prevents e.g. nmap from identifying the 		 * TCP/IP stack. 		 * XXX: Poor reasoning.  nmap has other methods 		 * and is constantly refining its stack detection 		 * strategies. 		 * XXX: This is a violation of the TCP specification 		 * and was used by RFC1644. 		 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|&&
name|V_drop_synfin
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"SYN|FIN segment ignored (based on "
literal|"sysctl setting)\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_badsyn
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
comment|/* 		 * Segment's flags are (SYN) or (SYN|FIN). 		 * 		 * TH_PUSH, TH_URG, TH_ECE, TH_CWR are ignored 		 * as they do not affect the state of the TCP FSM. 		 * The data pointed to by TH_URG and th_urp is ignored. 		 */
name|KASSERT
argument_list|(
operator|(
name|thflags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Listen socket: TH_RST or TH_ACK set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator|)
argument_list|,
operator|(
literal|"%s: Listen socket: TH_SYN not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
comment|/* 		 * If deprecated address is forbidden, 		 * we do not accept SYN to deprecated interface 		 * address to prevent any new inbound connection from 		 * getting established. 		 * When we do not accept SYN, we send a TCP RST, 		 * with deprecated source address (instead of dropping 		 * it).  We compromise it as it is much better for peer 		 * to send a RST, and RST will be the final packet 		 * for the exchange. 		 * 		 * If we do not forbid deprecated addresses, we accept 		 * the SYN packet.  RFC2462 does not suggest dropping 		 * SYN in this case. 		 * If we decipher RFC2462 5.5.4, it says like this: 		 * 1. use of deprecated addr with existing 		 *    communication is okay - "SHOULD continue to be 		 *    used" 		 * 2. use of it with new communication: 		 *   (2a) "SHOULD NOT be used if alternate address 		 *        with sufficient scope is available" 		 *   (2b) nothing mentioned otherwise. 		 * Here we fall into (2b) case as we have no choice in 		 * our source address selection - we must obey the peer. 		 * 		 * The wording in RFC2462 is confusing, and there are 		 * multiple description text for deprecated address 		 * handling - worse, they are not exactly the same. 		 * I believe 5.5.4 is the best one, so we follow 5.5.4. 		 */
if|if
condition|(
name|isipv6
operator|&&
operator|!
name|V_ip6_use_deprecated
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|ia6
operator|=
name|in6ifa_ifwithaddr
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
literal|0
comment|/* XXX */
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
operator|!=
name|NULL
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_DEPRECATED
operator|)
condition|)
block|{
name|ifa_free
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt to deprecated "
literal|"IPv6 address rejected\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
if|if
condition|(
name|ia6
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
comment|/* 		 * Basic sanity checks on incoming SYN requests: 		 *   Don't respond if the destination is a link layer 		 *	broadcast according to RFC1122 4.2.3.10, p. 104. 		 *   If it is from this socket it must be forged. 		 *   Don't respond if the source or destination is a 		 *	global or subnet broad- or multicast address. 		 *   Note that it is quite possible to receive unicast 		 *	link-layer packets with a broadcast IP address. Use 		 *	in_broadcast() to find them. 		 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt from broad- or multicast "
literal|"link layer address ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
if|if
condition|(
name|th
operator|->
name|th_dport
operator|==
name|th
operator|->
name|th_sport
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt to/from self "
literal|"ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt from/to multicast "
literal|"address ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
if|if
condition|(
name|th
operator|->
name|th_dport
operator|==
name|th
operator|->
name|th_sport
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt from/to self "
literal|"ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
operator|||
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
operator|&
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Listen socket: "
literal|"Connection attempt from/to broad- "
literal|"or multicast address ignored\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * SYN appears to be valid.  Create compressed TCP state 		 * for syncache. 		 */
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
name|TO_SYN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_RFC7413
if|if
condition|(
name|syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
name|th
argument_list|,
name|inp
argument_list|,
operator|&
name|so
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|tfo_socket_result
goto|;
else|#
directive|else
name|syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
name|th
argument_list|,
name|inp
argument_list|,
operator|&
name|so
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Entry added to syncache and mbuf consumed. 		 * Only the listen socket is unlocked by syncache_add(). 		 */
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
block|{
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
block|}
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_LISTEN
condition|)
block|{
comment|/* 		 * When a listen socket is torn down the SO_ACCEPTCONN 		 * flag is removed first while connections are drained 		 * from the accept queue in a unlock/lock cycle of the 		 * ACCEPT_LOCK, opening a race condition allowing a SYN 		 * attempt go through unhandled. 		 */
goto|goto
name|dropunlock
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|TCP_SIGNATURE
argument_list|)
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SIGNATURE
condition|)
block|{
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
name|optp
argument_list|,
name|optlen
argument_list|,
name|thflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SIGNATURE
operator|)
operator|==
literal|0
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_sig_err_nosigopt
argument_list|)
expr_stmt|;
goto|goto
name|dropunlock
goto|;
block|}
if|if
condition|(
operator|!
name|TCPMD5_ENABLED
argument_list|()
operator|||
name|TCPMD5_INPUT
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|to
operator|.
name|to_signature
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|dropunlock
goto|;
block|}
endif|#
directive|endif
name|TCP_PROBE5
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
comment|/* 	 * Segment belongs to a connection in SYN_SENT, ESTABLISHED or later 	 * state.  tcp_do_segment() always consumes the mbuf chain, unlocks 	 * the inpcb, and unlocks pcbinfo. 	 */
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_do_segment
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|so
argument_list|,
name|tp
argument_list|,
name|drop_hdrlen
argument_list|,
name|tlen
argument_list|,
name|iptos
argument_list|,
name|ti_locked
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
name|dropwithreset
label|:
name|TCP_PROBE5
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
block|{
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
else|else
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_UNLOCKED
argument_list|,
operator|(
literal|"%s: dropwithreset "
literal|"ti_locked: %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|tcp_dropwithreset
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|tp
argument_list|,
name|tlen
argument_list|,
name|rstreason
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
name|tcp_dropwithreset
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|tlen
argument_list|,
name|rstreason
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* mbuf chain got consumed. */
goto|goto
name|drop
goto|;
name|dropunlock
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|TCP_PROBE5
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
block|{
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
else|else
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_UNLOCKED
argument_list|,
operator|(
literal|"%s: dropunlock "
literal|"ti_locked: %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|drop
label|:
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|s
argument_list|,
name|M_TCPLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Automatic sizing of receive socket buffer.  Often the send  * buffer size is not optimally adjusted to the actual network  * conditions at hand (delay bandwidth product).  Setting the  * buffer size too small limits throughput on links with high  * bandwidth and high delay (eg. trans-continental/oceanic links).  *  * On the receive side the socket buffer memory is only rarely  * used to any significant extent.  This allows us to be much  * more aggressive in scaling the receive socket buffer.  For  * the case that the buffer space is actually used to a large  * extent and we run out of kernel memory we can simply drop  * the new segments; TCP on the sender will just retransmit it  * later.  Setting the buffer size too big may only consume too  * much kernel memory if the application doesn't read() from  * the socket or packet loss or reordering makes use of the  * reassembly queue.  *  * The criteria to step up the receive buffer one notch are:  *  1. Application has not set receive buffer size with  *     SO_RCVBUF. Setting SO_RCVBUF clears SB_AUTOSIZE.  *  2. the number of bytes received during the time it takes  *     one timestamp to be reflected back to us (the RTT);  *  3. received bytes per RTT is within seven eighth of the  *     current socket buffer size;  *  4. receive buffer size has not hit maximal automatic size;  *  * This algorithm does one step per RTT at most and only if  * we receive a bulk stream w/o packet losses or reorderings.  * Shrinking the buffer during idle times is not necessary as  * it doesn't consume any memory when idle.  *  * TODO: Only step up if the application is actually serving  * the buffer to better manage the socket buffer resources.  */
end_comment

begin_function
name|int
name|tcp_autorcvbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|tlen
parameter_list|)
block|{
name|int
name|newsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|V_tcp_do_autorcvbuf
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
operator|)
operator|&&
name|tp
operator|->
name|t_srtt
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|rfbuf_ts
operator|!=
literal|0
operator|&&
name|TCP_TS_TO_TICKS
argument_list|(
name|tcp_ts_getticks
argument_list|()
operator|-
name|tp
operator|->
name|rfbuf_ts
argument_list|)
operator|>
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
name|TCP_RTT_SHIFT
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|rfbuf_cnt
operator|>
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|/
literal|8
operator|*
literal|7
operator|)
operator|&&
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|<
name|V_tcp_autorcvbuf_max
condition|)
block|{
name|newsize
operator|=
name|min
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|+
name|V_tcp_autorcvbuf_inc
argument_list|,
name|V_tcp_autorcvbuf_max
argument_list|)
expr_stmt|;
block|}
name|TCP_PROBE6
argument_list|(
name|receive__autoresize
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
comment|/* Start over with next RTT. */
name|tp
operator|->
name|rfbuf_ts
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|rfbuf_cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|rfbuf_cnt
operator|+=
name|tlen
expr_stmt|;
comment|/* add up */
block|}
return|return
operator|(
name|newsize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcp_do_segment
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|drop_hdrlen
parameter_list|,
name|int
name|tlen
parameter_list|,
name|uint8_t
name|iptos
parameter_list|,
name|int
name|ti_locked
parameter_list|)
block|{
name|int
name|thflags
decl_stmt|,
name|acked
decl_stmt|,
name|ourfinisacked
decl_stmt|,
name|needoutput
init|=
literal|0
decl_stmt|,
name|sack_changed
decl_stmt|;
name|int
name|rstreason
decl_stmt|,
name|todrop
decl_stmt|,
name|win
decl_stmt|;
name|uint32_t
name|tiwin
decl_stmt|;
name|uint16_t
name|nsegs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|in_conninfo
modifier|*
name|inc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mfree
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_RFC7413
name|int
name|tfo_syn
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCPDEBUG
comment|/* 	 * The size of tcp_saveipgen must be the size of the max ip header, 	 * now IPv6. 	 */
name|u_char
name|tcp_saveipgen
index|[
name|IP6_HDR_LEN
index|]
decl_stmt|;
name|struct
name|tcphdr
name|tcp_savetcp
decl_stmt|;
name|short
name|ostate
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|thflags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
name|inc
operator|=
operator|&
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_inc
expr_stmt|;
name|tp
operator|->
name|sackhint
operator|.
name|last_sack_ack
operator|=
literal|0
expr_stmt|;
name|sack_changed
operator|=
literal|0
expr_stmt|;
name|nsegs
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|lro_nsegs
argument_list|)
expr_stmt|;
comment|/* 	 * If this is either a state-changing packet or current state isn't 	 * established, we require a write lock on tcbinfo.  Otherwise, we 	 * allow the tcbinfo to be in either alocked or unlocked, as the 	 * caller may have unnecessarily acquired a write lock due to a race. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator|)
operator|)
operator|!=
literal|0
operator|||
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_ESTABLISHED
condition|)
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"%s ti_locked %d for "
literal|"SYN/FIN/RST/!EST"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_UNLOCKED
argument_list|,
operator|(
literal|"%s: EST "
literal|"ti_locked: %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|>
name|TCPS_LISTEN
argument_list|,
operator|(
literal|"%s: TCPS_LISTEN"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_TIME_WAIT
argument_list|,
operator|(
literal|"%s: TCPS_TIME_WAIT"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCPPCAP
comment|/* Save segment, if requested. */
name|tcp_pcap_add
argument_list|(
name|th
argument_list|,
name|m
argument_list|,
operator|&
operator|(
name|tp
operator|->
name|t_inpkts
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|&&
name|V_drop_synfin
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: "
literal|"SYN|FIN segment ignored (based on "
literal|"sysctl setting)\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_TCPLOG
argument_list|)
expr_stmt|;
block|}
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * If a segment with the ACK-bit set arrives in the SYN-SENT state 	 * check SEQ.ACK first. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|)
operator|&&
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * Segment received on connection. 	 * Reset idle time and keep-alive timer. 	 * XXX: This should be done after segment 	 * validation to ignore broken/spoofed segs. 	 */
name|tp
operator|->
name|t_rcvtime
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * Scale up the window into a 32-bit value. 	 * For the SYN_SENT state the scale is zero. 	 */
name|tiwin
operator|=
name|th
operator|->
name|th_win
operator|<<
name|tp
operator|->
name|snd_scale
expr_stmt|;
comment|/* 	 * TCP ECN processing. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ECN_PERMIT
condition|)
block|{
if|if
condition|(
name|thflags
operator|&
name|TH_CWR
condition|)
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_ECN_SND_ECE
expr_stmt|;
switch|switch
condition|(
name|iptos
operator|&
name|IPTOS_ECN_MASK
condition|)
block|{
case|case
name|IPTOS_ECN_CE
case|:
name|tp
operator|->
name|t_flags
operator||=
name|TF_ECN_SND_ECE
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_ecn_ce
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPTOS_ECN_ECT0
case|:
name|TCPSTAT_INC
argument_list|(
name|tcps_ecn_ect0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPTOS_ECN_ECT1
case|:
name|TCPSTAT_INC
argument_list|(
name|tcps_ecn_ect1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Process a packet differently from RFC3168. */
name|cc_ecnpkt_handler
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|iptos
argument_list|)
expr_stmt|;
comment|/* Congestion experienced. */
if|if
condition|(
name|thflags
operator|&
name|TH_ECE
condition|)
block|{
name|cc_cong_signal
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|CC_ECN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Parse options on any incoming segment. 	 */
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
condition|?
name|TO_SYN
else|:
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|TCP_SIGNATURE
argument_list|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SIGNATURE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SIGNATURE
operator|)
operator|==
literal|0
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_sig_err_sigopt
argument_list|)
expr_stmt|;
comment|/* XXX: should drop? */
block|}
endif|#
directive|endif
comment|/* 	 * If echoed timestamp is later than the current time, 	 * fall back to non RFC1323 RTT calculation.  Normalize 	 * timestamp if syncookies were used when this connection 	 * was established. 	 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|&&
operator|(
name|to
operator|.
name|to_tsecr
operator|!=
literal|0
operator|)
condition|)
block|{
name|to
operator|.
name|to_tsecr
operator|-=
name|tp
operator|->
name|ts_offset
expr_stmt|;
if|if
condition|(
name|TSTMP_GT
argument_list|(
name|to
operator|.
name|to_tsecr
argument_list|,
name|tcp_ts_getticks
argument_list|()
argument_list|)
condition|)
name|to
operator|.
name|to_tsecr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If timestamps were negotiated during SYN/ACK they should 	 * appear on every segment during this session and vice versa. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_RCVD_TSTMP
operator|)
operator|&&
operator|!
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Timestamp missing, "
literal|"no action\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_TCPLOG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_RCVD_TSTMP
operator|)
operator|&&
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: Timestamp not expected, "
literal|"no action\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_TCPLOG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Process options only when we get SYN/ACK back. The SYN case 	 * for incoming connections is handled in tcp_syncache. 	 * According to RFC1323 the window field in a SYN (i.e., a<SYN> 	 * or<SYN,ACK>) segment itself is never scaled. 	 * XXX this is traditional behavior, may need to be cleaned up. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_SENT
operator|&&
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SCALE
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_SCALE
expr_stmt|;
name|tp
operator|->
name|snd_scale
operator|=
name|to
operator|.
name|to_wscale
expr_stmt|;
block|}
comment|/* 		 * Initial send window.  It will be updated with 		 * the next incoming segment to the scaled value. 		 */
name|tp
operator|->
name|snd_wnd
operator|=
name|th
operator|->
name|th_win
expr_stmt|;
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_RCVD_TSTMP
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_MSS
condition|)
name|tcp_mss
argument_list|(
name|tp
argument_list|,
name|to
operator|.
name|to_mss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SACKPERM
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_SACK_PERMIT
expr_stmt|;
block|}
comment|/* 	 * Header prediction: check for the two common cases 	 * of a uni-directional data xfer.  If the packet has 	 * no control flags, is in-sequence, the window didn't 	 * change and we're not retransmitting, it's a 	 * candidate.  If the length is zero and the ack moved 	 * forward, we're the sender side of the xfer.  Just 	 * free the data acked& wake any higher level process 	 * that was blocked waiting for space.  If the length 	 * is non-zero and the ack didn't move, we're the 	 * receiver side.  If we're getting packets in-order 	 * (the reassembly queue is empty), add the data to 	 * the socket buffer and note that we need a delayed ack. 	 * Make sure that the hidden state-flags are also off. 	 * Since we check for TCPS_ESTABLISHED first, it can only 	 * be TH_NEEDSYN. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_ESTABLISHED
operator|&&
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
operator|&&
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_URG
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
operator|&&
name|tp
operator|->
name|snd_nxt
operator|==
name|tp
operator|->
name|snd_max
operator|&&
name|tiwin
operator|&&
name|tiwin
operator|==
name|tp
operator|->
name|snd_wnd
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_NEEDSYN
operator||
name|TF_NEEDFIN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|)
operator|&&
operator|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|==
literal|0
operator|||
name|TSTMP_GEQ
argument_list|(
name|to
operator|.
name|to_tsval
argument_list|,
name|tp
operator|->
name|ts_recent
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * If last ACK falls within this segment's sequence numbers, 		 * record the timestamp. 		 * NOTE that the test is modified according to the latest 		 * proposal of the tcplw@cray.com list (Braden 1993/04/26). 		 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
condition|)
block|{
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
block|}
if|if
condition|(
name|tlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|&&
operator|!
name|IN_RECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
operator|&&
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SACK
operator|)
operator|==
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
condition|)
block|{
comment|/* 				 * This is a pure ack for outstanding data. 				 */
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_predack
argument_list|)
expr_stmt|;
comment|/* 				 * "bad retransmit" recovery. 				 */
if|if
condition|(
name|tp
operator|->
name|t_rxtshift
operator|==
literal|1
operator|&&
name|tp
operator|->
name|t_flags
operator|&
name|TF_PREVVALID
operator|&&
call|(
name|int
call|)
argument_list|(
name|ticks
operator|-
name|tp
operator|->
name|t_badrxtwin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cc_cong_signal
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|CC_RTO_ERR
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Recalculate the transmit timer / rtt. 				 * 				 * Some boxes send broken timestamp replies 				 * during the SYN+ACK phase, ignore 				 * timestamps of 0 or we could calculate a 				 * huge RTT and blow up the retransmit timer. 				 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|to
operator|.
name|to_tsecr
condition|)
block|{
name|uint32_t
name|t
decl_stmt|;
name|t
operator|=
name|tcp_ts_getticks
argument_list|()
operator|-
name|to
operator|.
name|to_tsecr
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|t_rttlow
operator|||
name|tp
operator|->
name|t_rttlow
operator|>
name|t
condition|)
name|tp
operator|->
name|t_rttlow
operator|=
name|t
expr_stmt|;
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|TCP_TS_TO_TICKS
argument_list|(
name|t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_rtttime
operator|&&
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|t_rtseq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tp
operator|->
name|t_rttlow
operator|||
name|tp
operator|->
name|t_rttlow
operator|>
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
condition|)
name|tp
operator|->
name|t_rttlow
operator|=
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
expr_stmt|;
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
argument_list|)
expr_stmt|;
block|}
name|acked
operator|=
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_HHOOK
comment|/* Run HHOOK_TCP_ESTABLISHED_IN helper hooks. */
name|hhook_run_tcp_est_in
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvackpack
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvackbyte
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|acked
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
name|tp
operator|->
name|snd_recover
operator|=
name|th
operator|->
name|th_ack
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Let the congestion control algorithm update 				 * congestion control related information. This 				 * typically means increasing the congestion 				 * window. 				 */
name|cc_ack_received
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|nsegs
argument_list|,
name|CC_ACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
comment|/* 				 * Pull snd_wl2 up to prevent seq wrap relative 				 * to th_ack. 				 */
name|tp
operator|->
name|snd_wl2
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * If all outstanding data are acked, stop 				 * retransmit timer, otherwise restart timer 				 * using current (possibly backed-off) value. 				 * If process is waiting for space, 				 * wakeup/selwakeup/signal.  If data 				 * are ready to send, let tcp_output 				 * decide between more output or persist. 				 */
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_una
operator|==
name|tp
operator|->
name|snd_max
condition|)
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tcp_timer_active
argument_list|(
name|tp
argument_list|,
name|TT_PERSIST
argument_list|)
condition|)
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
name|tp
operator|->
name|t_rxtcur
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
condition|)
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|check_delack
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_ack
operator|==
name|tp
operator|->
name|snd_una
operator|&&
name|tlen
operator|<=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
name|int
name|newsize
init|=
literal|0
decl_stmt|;
comment|/* automatic sockbuf scaling */
comment|/* 			 * This is a pure, in-sequence data packet with 			 * nothing on the reassembly queue and we have enough 			 * buffer space to take it. 			 */
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
comment|/* Clean receiver SACK report if present */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
name|tp
operator|->
name|rcv_numsacks
condition|)
name|tcp_clean_sackreport
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_preddat
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|tlen
expr_stmt|;
comment|/* 			 * Pull snd_wl1 up to prevent seq wrap relative to 			 * th_seq. 			 */
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
comment|/* 			 * Pull rcv_up up to prevent seq wrap relative to 			 * rcv_nxt. 			 */
name|tp
operator|->
name|rcv_up
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvpack
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvbyte
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|tcp_autorcvbuf
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|so
argument_list|,
name|tp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* Add data to socket buffer. */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Set new socket buffer size. 				 * Give up when limit is reached. 				 */
if|if
condition|(
name|newsize
condition|)
if|if
condition|(
operator|!
name|sbreserve_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|newsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
comment|/* delayed header drop */
name|sbappendstream_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* NB: sorwakeup_locked() does an implicit unlock. */
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|,
name|tlen
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_DELACK
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|check_delack
goto|;
block|}
block|}
comment|/* 	 * Calculate amount of space in receive window, 	 * and then do TCP input processing. 	 * Receive window is amount of space in rcv queue, 	 * but not less than advertised window. 	 */
name|win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|0
condition|)
name|win
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|imax
argument_list|(
name|win
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tp
operator|->
name|rcv_adv
operator|-
name|tp
operator|->
name|rcv_nxt
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * If the state is SYN_RECEIVED: 	 *	if seg contains an ACK, but not for our SYN/ACK, send a RST. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
ifdef|#
directive|ifdef
name|TCP_RFC7413
if|if
condition|(
name|IS_FASTOPEN
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
comment|/* 			 * When a TFO connection is in SYN_RECEIVED, the 			 * only valid packets are the initial SYN, a 			 * retransmit/copy of the initial SYN (possibly with 			 * a subset of the original data), a valid ACK, a 			 * FIN, or a RST. 			 */
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
elseif|else
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
block|{
comment|/* non-initial SYN is ignored */
if|if
condition|(
operator|(
name|tcp_timer_active
argument_list|(
name|tp
argument_list|,
name|TT_DELACK
argument_list|)
operator|||
name|tcp_timer_active
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|)
operator|)
condition|)
goto|goto
name|drop
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|thflags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_FIN
operator||
name|TH_RST
operator|)
operator|)
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
block|}
endif|#
directive|endif
break|break;
comment|/* 	 * If the state is SYN_SENT: 	 *	if seg contains a RST, then drop the connection. 	 *	if seg does not contain SYN, then drop it. 	 * Otherwise this is an acceptable SYN segment 	 *	initialize tp->rcv_nxt and tp->irs 	 *	if seg contains ack then advance tp->snd_una 	 *	if seg contains an ECE and ECN support is enabled, the stream 	 *	    is ECN capable. 	 *	if SYN has been acked change to ESTABLISHED else SYN_RCVD state 	 *	arrange for segment to be acked (eventually) 	 *	continue processing rest of data/controls, beginning with URG 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
operator|(
name|thflags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|==
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
condition|)
block|{
name|TCP_PROBE5
argument_list|(
name|connect__refused
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|!
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
condition|)
goto|goto
name|drop
goto|;
name|tp
operator|->
name|irs
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_connects
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socketpeer_set_from_mbuf
argument_list|(
name|m
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do window scaling on this connection? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
block|}
name|tp
operator|->
name|rcv_adv
operator|+=
name|min
argument_list|(
name|tp
operator|->
name|rcv_wnd
argument_list|,
name|TCP_MAXWIN
operator|<<
name|tp
operator|->
name|rcv_scale
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|++
expr_stmt|;
comment|/* SYN is acked */
comment|/* 			 * If there's data, delay ACK; if there's also a FIN 			 * ACKNOW will be turned on later. 			 */
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|,
name|tlen
argument_list|)
operator|&&
name|tlen
operator|!=
literal|0
condition|)
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_DELACK
argument_list|,
name|tcp_delacktime
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ECE
operator|)
operator|&&
name|V_tcp_do_ecn
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ECN_PERMIT
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_ecn_shs
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Received<SYN,ACK> in SYN_SENT[*] state. 			 * Transitions: 			 *	SYN_SENT  --> ESTABLISHED 			 *	SYN_SENT* --> FIN_WAIT_1 			 */
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDFIN
condition|)
block|{
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_FIN_WAIT_1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDFIN
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_SYN
expr_stmt|;
block|}
else|else
block|{
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_ESTABLISHED
argument_list|)
expr_stmt|;
name|TCP_PROBE5
argument_list|(
name|connect__established
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|cc_conn_init
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_KEEP
argument_list|,
name|TP_KEEPIDLE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Received initial SYN in SYN-SENT[*] state => 			 * simultaneous open. 			 * If it succeeds, connection is * half-synchronized. 			 * Otherwise, do 3-way handshake: 			 *        SYN-SENT -> SYN-RECEIVED 			 *        SYN-SENT* -> SYN-RECEIVED* 			 */
name|tp
operator|->
name|t_flags
operator||=
operator|(
name|TF_ACKNOW
operator||
name|TF_NEEDSYN
operator|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_SYN_RECEIVED
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"%s: trimthenstep6: "
literal|"ti_locked %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* 		 * Advance th->th_seq to correspond to first data byte. 		 * If data, trim to stay within window, 		 * dropping FIN if necessary. 		 */
name|th
operator|->
name|th_seq
operator|++
expr_stmt|;
if|if
condition|(
name|tlen
operator|>
name|tp
operator|->
name|rcv_wnd
condition|)
block|{
name|todrop
operator|=
name|tlen
operator|-
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvpackafterwin
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvbyteafterwin
argument_list|,
name|todrop
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|rcv_up
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
comment|/* 		 * Client side of transaction: already sent SYN and data. 		 * If the remote host used T/TCP to validate the SYN, 		 * our data will be ACK'd; if so, enter normal data segment 		 * processing in the middle of step 5, ack processing. 		 * Otherwise, goto step 6. 		 */
if|if
condition|(
name|thflags
operator|&
name|TH_ACK
condition|)
goto|goto
name|process_ACK
goto|;
goto|goto
name|step6
goto|;
comment|/* 	 * If the state is LAST_ACK or CLOSING or TIME_WAIT: 	 *      do normal processing. 	 * 	 * NB: Leftover from RFC1644 T/TCP.  Cases to be reused later. 	 */
case|case
name|TCPS_LAST_ACK
case|:
case|case
name|TCPS_CLOSING
case|:
break|break;
comment|/* continue normal processing */
block|}
comment|/* 	 * States other than LISTEN or SYN_SENT. 	 * First check the RST flag and sequence number since reset segments 	 * are exempt from the timestamp and connection count tests.  This 	 * fixes a bug introduced by the Stevens, vol. 2, p. 960 bugfix 	 * below which allowed reset segments in half the sequence space 	 * to fall though and be processed (which gives forged reset 	 * segments with a random sequence number a 50 percent chance of 	 * killing a connection). 	 * Then check timestamp, if present. 	 * Then check the connection count, if present. 	 * Then check that at least some bytes of segment are within 	 * receive window.  If segment begins before rcv_nxt, 	 * drop leading data (and SYN); if nothing left, just ack. 	 */
if|if
condition|(
name|thflags
operator|&
name|TH_RST
condition|)
block|{
comment|/* 		 * RFC5961 Section 3.2 		 * 		 * - RST drops connection only if SEG.SEQ == RCV.NXT. 		 * - If RST is in window, we send challenge ACK. 		 * 		 * Note: to take into account delayed ACKs, we should 		 *   test against last_ack_sent instead of rcv_nxt. 		 * Note 2: we handle special case of closed window, not 		 *   covered by the RFC. 		 */
if|if
condition|(
operator|(
name|SEQ_GEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
operator|+
name|tp
operator|->
name|rcv_wnd
argument_list|)
operator|)
operator|||
operator|(
name|tp
operator|->
name|rcv_wnd
operator|==
literal|0
operator|&&
name|tp
operator|->
name|last_ack_sent
operator|==
name|th
operator|->
name|th_seq
operator|)
condition|)
block|{
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"%s: TH_RST ti_locked %d, th %p tp %p"
operator|,
name|__func__
operator|,
name|ti_locked
operator|,
name|th
operator|,
name|tp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_SYN_SENT
argument_list|,
operator|(
literal|"%s: TH_RST for TCPS_SYN_SENT th %p tp %p"
operator|,
name|__func__
operator|,
name|th
operator|,
name|tp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_tcp_insecure_rst
operator|||
name|tp
operator|->
name|last_ack_sent
operator|==
name|th
operator|->
name|th_seq
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_drops
argument_list|)
expr_stmt|;
comment|/* Drop the connection. */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|close
goto|;
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNRESET
expr_stmt|;
name|close
label|:
comment|/* FALLTHROUGH */
default|default:
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_badrst
argument_list|)
expr_stmt|;
comment|/* Send challenge ACK. */
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|,
name|TH_ACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|last_ack_sent
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * RFC5961 Section 4.2 	 * Send challenge ACK for any SYN in synchronized state. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_SYN
operator|)
operator|&&
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_SYN_SENT
operator|&&
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_SYN_RECEIVED
condition|)
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"tcp_do_segment: TH_SYN ti_locked %d"
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_badsyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_tcp_insecure_syn
operator|&&
name|SEQ_GEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
operator|+
name|tp
operator|->
name|rcv_wnd
argument_list|)
condition|)
block|{
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
block|}
else|else
block|{
comment|/* Send challenge ACK. */
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|,
name|TH_ACK
argument_list|)
expr_stmt|;
name|tp
operator|->
name|last_ack_sent
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * RFC 1323 PAWS: If we have a timestamp reply on this segment 	 * and it's less than ts_recent, drop it. 	 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|ts_recent
operator|&&
name|TSTMP_LT
argument_list|(
name|to
operator|.
name|to_tsval
argument_list|,
name|tp
operator|->
name|ts_recent
argument_list|)
condition|)
block|{
comment|/* Check to see if ts_recent is over 24 days old.  */
if|if
condition|(
name|tcp_ts_getticks
argument_list|()
operator|-
name|tp
operator|->
name|ts_recent_age
operator|>
name|TCP_PAWS_IDLE
condition|)
block|{
comment|/* 			 * Invalidate ts_recent.  If this segment updates 			 * ts_recent, the age will be reset later and ts_recent 			 * will get a valid value.  If it does not, setting 			 * ts_recent to zero will at least satisfy the 			 * requirement that zero be placed in the timestamp 			 * echo reply when ts_recent isn't valid.  The 			 * age isn't reset until we get a valid ts_recent 			 * because we don't want out-of-order segments to be 			 * dropped when ts_recent is old. 			 */
name|tp
operator|->
name|ts_recent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvduppack
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvdupbyte
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_pawsdrop
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
condition|)
goto|goto
name|dropafterack
goto|;
goto|goto
name|drop
goto|;
block|}
block|}
comment|/* 	 * In the SYN-RECEIVED state, validate that the packet belongs to 	 * this connection before trimming the data to fit the receive 	 * window.  Check the sequence number versus IRS since we know 	 * the sequence numbers haven't wrapped.  This is a partial fix 	 * for the "LAND" DoS attack. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|irs
argument_list|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|todrop
operator|=
name|tp
operator|->
name|rcv_nxt
operator|-
name|th
operator|->
name|th_seq
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|thflags
operator|&
name|TH_SYN
condition|)
block|{
name|thflags
operator|&=
operator|~
name|TH_SYN
expr_stmt|;
name|th
operator|->
name|th_seq
operator|++
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_urp
operator|>
literal|1
condition|)
name|th
operator|->
name|th_urp
operator|--
expr_stmt|;
else|else
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|todrop
operator|--
expr_stmt|;
block|}
comment|/* 		 * Following if statement from Stevens, vol. 2, p. 960. 		 */
if|if
condition|(
name|todrop
operator|>
name|tlen
operator|||
operator|(
name|todrop
operator|==
name|tlen
operator|&&
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Any valid FIN must be to the left of the window. 			 * At this point the FIN must be a duplicate or out 			 * of sequence; drop it. 			 */
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
comment|/* 			 * Send an ACK to resynchronize and drop any data. 			 * But keep on processing for RST or ACK. 			 */
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|todrop
operator|=
name|tlen
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvduppack
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvdupbyte
argument_list|,
name|todrop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvpartduppack
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvpartdupbyte
argument_list|,
name|todrop
argument_list|)
expr_stmt|;
block|}
name|drop_hdrlen
operator|+=
name|todrop
expr_stmt|;
comment|/* drop from the top afterwards */
name|th
operator|->
name|th_seq
operator|+=
name|todrop
expr_stmt|;
name|tlen
operator|-=
name|todrop
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_urp
operator|>
name|todrop
condition|)
name|th
operator|->
name|th_urp
operator|-=
name|todrop
expr_stmt|;
else|else
block|{
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If new data are received on a connection after the 	 * user processes are gone, then RST the other end. 	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|&&
name|tp
operator|->
name|t_state
operator|>
name|TCPS_CLOSE_WAIT
operator|&&
name|tlen
condition|)
block|{
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"%s: SS_NOFDEREF&& "
literal|"CLOSE_WAIT&& tlen ti_locked %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|tcp_log_addrs
argument_list|(
name|inc
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s; %s: %s: Received %d bytes of data "
literal|"after socket was closed, "
literal|"sending RST and removing tcpcb\n"
argument_list|,
name|s
argument_list|,
name|__func__
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_TCPLOG
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvafterclose
argument_list|)
expr_stmt|;
name|rstreason
operator|=
name|BANDLIM_UNLIMITED
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * If segment ends after window, drop trailing data 	 * (and PUSH and FIN); if nothing left, just ACK. 	 */
name|todrop
operator|=
operator|(
name|th
operator|->
name|th_seq
operator|+
name|tlen
operator|)
operator|-
operator|(
name|tp
operator|->
name|rcv_nxt
operator|+
name|tp
operator|->
name|rcv_wnd
operator|)
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvpackafterwin
argument_list|)
expr_stmt|;
if|if
condition|(
name|todrop
operator|>=
name|tlen
condition|)
block|{
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvbyteafterwin
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* 			 * If window is closed can only take segments at 			 * window edge, and have to drop data and PUSH from 			 * incoming segments.  Continue processing, but 			 * remember to ack.  Otherwise, drop segment 			 * and ack. 			 */
if|if
condition|(
name|tp
operator|->
name|rcv_wnd
operator|==
literal|0
operator|&&
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvwinprobe
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|dropafterack
goto|;
block|}
else|else
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvbyteafterwin
argument_list|,
name|todrop
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|todrop
expr_stmt|;
name|thflags
operator|&=
operator|~
operator|(
name|TH_PUSH
operator||
name|TH_FIN
operator|)
expr_stmt|;
block|}
comment|/* 	 * If last ACK falls within this segment's sequence numbers, 	 * record its timestamp. 	 * NOTE:  	 * 1) That the test incorporates suggestions from the latest 	 *    proposal of the tcplw@cray.com list (Braden 1993/04/26). 	 * 2) That updating only on newer timestamps interferes with 	 *    our earlier PAWS tests, so this check should be solely 	 *    predicated on the sequence space of this segment. 	 * 3) That we modify the segment boundary check to be  	 *        Last.ACK.Sent<= SEG.SEQ + SEG.Len   	 *    instead of RFC1323's 	 *        Last.ACK.Sent< SEG.SEQ + SEG.Len, 	 *    This modified check allows us to overcome RFC1323's 	 *    limitations as described in Stevens TCP/IP Illustrated 	 *    Vol. 2 p.869. In such cases, we can still calculate the 	 *    RTT correctly when RCV.NXT == Last.ACK.Sent. 	 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_seq
argument_list|,
name|tp
operator|->
name|last_ack_sent
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|tp
operator|->
name|last_ack_sent
argument_list|,
name|th
operator|->
name|th_seq
operator|+
name|tlen
operator|+
operator|(
operator|(
name|thflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
operator|)
operator|!=
literal|0
operator|)
argument_list|)
condition|)
block|{
name|tp
operator|->
name|ts_recent_age
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ts_recent
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
block|}
comment|/* 	 * If the ACK bit is off:  if in SYN-RECEIVED state or SENDSYN 	 * flag is on (half-synchronized state), then queue data for 	 * later processing; else drop segment and return. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TCP_RFC7413
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
name|IS_FASTOPEN
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
name|cc_conn_init
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|step6
goto|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ACKNOW
condition|)
goto|goto
name|dropafterack
goto|;
else|else
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Ack processing. 	 */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * In SYN_RECEIVED state, the ack ACKs our SYN, so enter 	 * ESTABLISHED state and continue processing. 	 * The ACK was checked above. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
name|TCPSTAT_INC
argument_list|(
name|tcps_connects
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Do window scaling? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
block|}
comment|/* 		 * Make transitions: 		 *      SYN-RECEIVED  -> ESTABLISHED 		 *      SYN-RECEIVED* -> FIN-WAIT-1 		 */
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDFIN
condition|)
block|{
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_FIN_WAIT_1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDFIN
expr_stmt|;
block|}
else|else
block|{
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_ESTABLISHED
argument_list|)
expr_stmt|;
name|TCP_PROBE5
argument_list|(
name|accept__established
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_RFC7413
if|if
condition|(
name|tp
operator|->
name|t_tfo_pending
condition|)
block|{
name|tcp_fastopen_decrement_counter
argument_list|(
name|tp
operator|->
name|t_tfo_pending
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_tfo_pending
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Account for the ACK of our SYN prior to 				 * regular ACK processing below. 				 */
name|tp
operator|->
name|snd_una
operator|++
expr_stmt|;
block|}
comment|/* 			 * TFO connections call cc_conn_init() during SYN 			 * processing.  Calling it again here for such 			 * connections is not harmless as it would undo the 			 * snd_cwnd reduction that occurs when a TFO SYN|ACK 			 * is retransmitted. 			 */
if|if
condition|(
operator|!
name|IS_FASTOPEN
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
endif|#
directive|endif
name|cc_conn_init
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_KEEP
argument_list|,
name|TP_KEEPIDLE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If segment contains data or ACK, will call tcp_reass() 		 * later; if not, do so now to pass queued data to user. 		 */
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|tcp_reass
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
operator|-
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
comment|/* 	 * In ESTABLISHED state: drop duplicate ACKs; ACK out of range 	 * ACKs.  If the ack is in the range 	 *	tp->snd_una< th->th_ack<= tp->snd_max 	 * then advance tp->snd_una to th->th_ack and drop 	 * data from the retransmission queue.  If this ACK reflects 	 * more up to date window information we update our window information. 	 */
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvacktoomuch
argument_list|)
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
operator|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_SACK
operator|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
operator|)
condition|)
name|sack_changed
operator|=
name|tcp_sack_doack
argument_list|(
name|tp
argument_list|,
operator|&
name|to
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
expr_stmt|;
else|else
comment|/* 			 * Reset the value so that previous (valid) value 			 * from the last ack with SACK doesn't get used. 			 */
name|tp
operator|->
name|sackhint
operator|.
name|sacked_bytes
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_HHOOK
comment|/* Run HHOOK_TCP_ESTABLISHED_IN helper hooks. */
name|hhook_run_tcp_est_in
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
block|{
name|u_int
name|maxseg
decl_stmt|;
name|maxseg
operator|=
name|tcp_maxseg
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
operator|(
name|tiwin
operator|==
name|tp
operator|->
name|snd_wnd
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|)
condition|)
block|{
comment|/* 				 * If this is the first time we've seen a 				 * FIN from the remote, this is not a 				 * duplicate and it needs to be processed 				 * normally.  This happens during a 				 * simultaneous close. 				 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|&&
operator|(
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvdupack
argument_list|)
expr_stmt|;
comment|/* 				 * If we have outstanding data (other than 				 * a window probe), this is a completely 				 * duplicate ack (ie, window info didn't 				 * change and FIN isn't set), 				 * the ack is the biggest we've 				 * seen and we've seen exactly our rexmt 				 * threshold of them, assume a packet 				 * has been dropped and retransmit it. 				 * Kludge snd_nxt& the congestion 				 * window so we send only this one 				 * packet. 				 * 				 * We know we're losing at the current 				 * window size so do congestion avoidance 				 * (set ssthresh to half the current window 				 * and pull our congestion window back to 				 * the new ssthresh). 				 * 				 * Dup acks mean that packets have left the 				 * network (they're now cached at the receiver) 				 * so bump cwnd by the amount in the receiver 				 * to keep a constant cwnd packets in the 				 * network. 				 * 				 * When using TCP ECN, notify the peer that 				 * we reduced the cwnd. 				 */
comment|/* 				 * Following 2 kinds of acks should not affect 				 * dupack counting: 				 * 1) Old acks 				 * 2) Acks with SACK but without any new SACK 				 * information in them. These could result from 				 * any anomaly in the network like a switch 				 * duplicating packets or a possible DoS attack. 				 */
if|if
condition|(
name|th
operator|->
name|th_ack
operator|!=
name|tp
operator|->
name|snd_una
operator|||
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
operator|!
name|sack_changed
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|tcp_timer_active
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|)
condition|)
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|tp
operator|->
name|t_dupacks
operator|>
name|tcprexmtthresh
operator|||
name|IN_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|cc_ack_received
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|nsegs
argument_list|,
name|CC_DUPACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
name|IN_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|int
name|awnd
decl_stmt|;
comment|/* 						 * Compute the amount of data in flight first. 						 * We can inject new data into the pipe iff  						 * we have less than 1/2 the original window's 						 * worth of data in flight. 						 */
if|if
condition|(
name|V_tcp_do_rfc6675_pipe
condition|)
name|awnd
operator|=
name|tcp_compute_pipe
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|else
name|awnd
operator|=
operator|(
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|snd_fack
operator|)
operator|+
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
expr_stmt|;
if|if
condition|(
name|awnd
operator|<
name|tp
operator|->
name|snd_ssthresh
condition|)
block|{
name|tp
operator|->
name|snd_cwnd
operator|+=
name|maxseg
expr_stmt|;
comment|/* 							 * RFC5681 Section 3.2 talks about cwnd 							 * inflation on additional dupacks and 							 * deflation on recovering from loss. 							 * 							 * We keep cwnd into check so that 							 * we don't have to 'deflate' it when we 							 * get out of recovery. 							 */
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
expr_stmt|;
block|}
block|}
else|else
name|tp
operator|->
name|snd_cwnd
operator|+=
name|maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|==
name|tcprexmtthresh
condition|)
block|{
name|tcp_seq
name|onxt
init|=
name|tp
operator|->
name|snd_nxt
decl_stmt|;
comment|/* 					 * If we're doing sack, check to 					 * see if we're already in sack 					 * recovery. If we're not doing sack, 					 * check to see if we're in newreno 					 * recovery. 					 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
block|{
if|if
condition|(
name|IN_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Congestion signal before ack. */
name|cc_cong_signal
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|CC_NDUPACK
argument_list|)
expr_stmt|;
name|cc_ack_received
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|nsegs
argument_list|,
name|CC_DUPACK
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
block|{
name|TCPSTAT_INC
argument_list|(
name|tcps_sack_recovery_episode
argument_list|)
expr_stmt|;
name|tp
operator|->
name|sack_newdata
operator|=
name|tp
operator|->
name|snd_nxt
expr_stmt|;
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
operator|==
name|NULL
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|tp
operator|->
name|snd_nxt
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
operator|==
name|NULL
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|snd_limited
operator|<=
literal|2
argument_list|,
operator|(
literal|"%s: tp->snd_limited too big"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CC_ALGO
argument_list|(
name|tp
argument_list|)
operator|->
name|cong_signal
operator|==
name|NULL
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
operator|+
name|maxseg
operator|*
operator|(
name|tp
operator|->
name|t_dupacks
operator|-
name|tp
operator|->
name|snd_limited
operator|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|onxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|onxt
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
elseif|else
if|if
condition|(
name|V_tcp_do_rfc3042
condition|)
block|{
comment|/* 					 * Process first and second duplicate 					 * ACKs. Each indicates a segment 					 * leaving the network, creating room 					 * for more. Make sure we can send a 					 * packet on reception of each duplicate 					 * ACK by increasing snd_cwnd by one 					 * segment. Restore the original 					 * snd_cwnd after packet transmission. 					 */
name|cc_ack_received
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|nsegs
argument_list|,
name|CC_DUPACK
argument_list|)
expr_stmt|;
name|uint32_t
name|oldcwnd
init|=
name|tp
operator|->
name|snd_cwnd
decl_stmt|;
name|tcp_seq
name|oldsndmax
init|=
name|tp
operator|->
name|snd_max
decl_stmt|;
name|u_int
name|sent
decl_stmt|;
name|int
name|avail
decl_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|t_dupacks
operator|==
literal|1
operator|||
name|tp
operator|->
name|t_dupacks
operator|==
literal|2
argument_list|,
operator|(
literal|"%s: dupacks not 1 or 2"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_dupacks
operator|==
literal|1
condition|)
name|tp
operator|->
name|snd_limited
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
operator|(
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|snd_una
operator|)
operator|+
operator|(
name|tp
operator|->
name|t_dupacks
operator|-
name|tp
operator|->
name|snd_limited
operator|)
operator|*
name|maxseg
expr_stmt|;
comment|/* 					 * Only call tcp_output when there 					 * is new data available to be sent. 					 * Otherwise we would send pure ACKs. 					 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|avail
operator|=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|-
operator|(
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|snd_una
operator|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sent
operator|=
name|tp
operator|->
name|snd_max
operator|-
name|oldsndmax
expr_stmt|;
if|if
condition|(
name|sent
operator|>
name|maxseg
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|tp
operator|->
name|t_dupacks
operator|==
literal|2
operator|&&
name|tp
operator|->
name|snd_limited
operator|==
literal|0
operator|)
operator|||
operator|(
name|sent
operator|==
name|maxseg
operator|+
literal|1
operator|&&
name|tp
operator|->
name|t_flags
operator|&
name|TF_SENTFIN
operator|)
argument_list|,
operator|(
literal|"%s: sent too much"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_limited
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
operator|++
name|tp
operator|->
name|snd_limited
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|oldcwnd
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
break|break;
block|}
else|else
block|{
comment|/* 			 * This ack is advancing the left edge, reset the 			 * counter. 			 */
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this ack also has new SACK info, increment the 			 * counter as per rfc6675. 			 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
operator|&&
name|sack_changed
condition|)
name|tp
operator|->
name|t_dupacks
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
argument_list|,
operator|(
literal|"%s: th_ack<= snd_una"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the congestion window was inflated to account 		 * for the other side's cached packets, retract it. 		 */
if|if
condition|(
name|IN_FASTRECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
name|tcp_sack_partialack
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
else|else
name|tcp_newreno_partial_ack
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
else|else
name|cc_post_recovery
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we reach this point, ACK is not a duplicate, 		 *     i.e., it ACKs something we sent. 		 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
condition|)
block|{
comment|/* 			 * T/TCP: Connection was half-synchronized, and our 			 * SYN has been ACK'd (so connection is now fully 			 * synchronized).  Go to non-starred state, 			 * increment snd_una for ACK of SYN, and check if 			 * we can do window scaling. 			 */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_NEEDSYN
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|++
expr_stmt|;
comment|/* Do window scaling? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
operator|)
operator|==
operator|(
name|TF_RCVD_SCALE
operator||
name|TF_REQ_SCALE
operator|)
condition|)
block|{
name|tp
operator|->
name|rcv_scale
operator|=
name|tp
operator|->
name|request_r_scale
expr_stmt|;
comment|/* Send window already scaled. */
block|}
block|}
name|process_ACK
label|:
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|acked
operator|=
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|acked
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: acked unexepectedly negative "
literal|"(tp->snd_una=%u, th->th_ack=%u, tp=%p, m=%p)"
operator|,
name|__func__
operator|,
name|tp
operator|->
name|snd_una
operator|,
name|th
operator|->
name|th_ack
operator|,
name|tp
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvackpack
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvackbyte
argument_list|,
name|acked
argument_list|)
expr_stmt|;
comment|/* 		 * If we just performed our first retransmit, and the ACK 		 * arrives within our recovery window, then it was a mistake 		 * to do the retransmit in the first place.  Recover our 		 * original cwnd and ssthresh, and proceed to transmit where 		 * we left off. 		 */
if|if
condition|(
name|tp
operator|->
name|t_rxtshift
operator|==
literal|1
operator|&&
name|tp
operator|->
name|t_flags
operator|&
name|TF_PREVVALID
operator|&&
call|(
name|int
call|)
argument_list|(
name|ticks
operator|-
name|tp
operator|->
name|t_badrxtwin
argument_list|)
operator|<
literal|0
condition|)
name|cc_cong_signal
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|CC_RTO_ERR
argument_list|)
expr_stmt|;
comment|/* 		 * If we have a timestamp reply, update smoothed 		 * round trip time.  If no timestamp is present but 		 * transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 * Since we now have an rtt measurement, cancel the 		 * timer backoff (cf., Phil Karn's retransmit alg.). 		 * Recompute the initial retransmit timer. 		 * 		 * Some boxes send broken timestamp replies 		 * during the SYN+ACK phase, ignore 		 * timestamps of 0 or we could calculate a 		 * huge RTT and blow up the retransmit timer. 		 */
if|if
condition|(
operator|(
name|to
operator|.
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|to
operator|.
name|to_tsecr
condition|)
block|{
name|uint32_t
name|t
decl_stmt|;
name|t
operator|=
name|tcp_ts_getticks
argument_list|()
operator|-
name|to
operator|.
name|to_tsecr
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|t_rttlow
operator|||
name|tp
operator|->
name|t_rttlow
operator|>
name|t
condition|)
name|tp
operator|->
name|t_rttlow
operator|=
name|t
expr_stmt|;
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|TCP_TS_TO_TICKS
argument_list|(
name|t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_rtttime
operator|&&
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|t_rtseq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tp
operator|->
name|t_rttlow
operator|||
name|tp
operator|->
name|t_rttlow
operator|>
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
condition|)
name|tp
operator|->
name|t_rttlow
operator|=
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
expr_stmt|;
name|tcp_xmit_timer
argument_list|(
name|tp
argument_list|,
name|ticks
operator|-
name|tp
operator|->
name|t_rtttime
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If all outstanding data is acked, stop retransmit 		 * timer and remember to restart (more output or persist). 		 * If there is more data to be acked, restart retransmit 		 * timer, using current (possibly backed-off) value. 		 */
if|if
condition|(
name|th
operator|->
name|th_ack
operator|==
name|tp
operator|->
name|snd_max
condition|)
block|{
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tcp_timer_active
argument_list|(
name|tp
argument_list|,
name|TT_PERSIST
argument_list|)
condition|)
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
name|tp
operator|->
name|t_rxtcur
argument_list|)
expr_stmt|;
comment|/* 		 * If no data (only SYN) was ACK'd, 		 *    skip rest of ACK processing. 		 */
if|if
condition|(
name|acked
operator|==
literal|0
condition|)
goto|goto
name|step6
goto|;
comment|/* 		 * Let the congestion control algorithm update congestion 		 * control related information. This typically means increasing 		 * the congestion window. 		 */
name|cc_ack_received
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
name|nsegs
argument_list|,
name|CC_ACK
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|acked
operator|>
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
condition|)
name|tp
operator|->
name|snd_wnd
operator|-=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|snd_wnd
operator|=
literal|0
expr_stmt|;
name|mfree
operator|=
name|sbcut_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
operator|(
name|int
operator|)
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
argument_list|)
expr_stmt|;
name|ourfinisacked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mfree
operator|=
name|sbcut_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|acked
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>=
operator|(
name|uint32_t
operator|)
name|acked
condition|)
name|tp
operator|->
name|snd_wnd
operator|-=
name|acked
expr_stmt|;
else|else
name|tp
operator|->
name|snd_wnd
operator|=
literal|0
expr_stmt|;
name|ourfinisacked
operator|=
literal|0
expr_stmt|;
block|}
comment|/* NB: sowwakeup_locked() does an implicit unlock. */
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mfree
argument_list|)
expr_stmt|;
comment|/* Detect una wraparound. */
if|if
condition|(
operator|!
name|IN_RECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
name|tp
operator|->
name|snd_recover
operator|=
name|th
operator|->
name|th_ack
operator|-
literal|1
expr_stmt|;
comment|/* XXXLAS: Can this be moved up into cc_post_recovery? */
if|if
condition|(
name|IN_RECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
operator|&&
name|SEQ_GEQ
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
block|{
name|EXIT_RECOVERY
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|snd_una
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|tp
operator|->
name|snd_recover
argument_list|)
condition|)
name|tp
operator|->
name|snd_recover
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
block|}
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In FIN_WAIT_1 STATE in addition to the processing 		 * for the ESTABLISHED state if our FIN is now acknowledged 		 * then enter FIN_WAIT_2. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
comment|/* 				 * If we can't receive any more 				 * data, then closing user can proceed. 				 * Starting the timer is contrary to the 				 * specification, but if we don't get a FIN 				 * we'll hang forever. 				 * 				 * XXXjl: 				 * we should release the tp also, and use a 				 * compressed state. 				 */
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_2MSL
argument_list|,
operator|(
name|tcp_fast_finwait2_recycle
condition|?
name|tcp_finwait2_timeout
else|:
name|TP_MAXIDLE
argument_list|(
name|tp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_FIN_WAIT_2
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * In CLOSING STATE in addition to the processing for 		 * the ESTABLISHED state if the ACK acknowledges our FIN 		 * then enter the TIME-WAIT state, otherwise ignore 		 * the segment. 		 */
case|case
name|TCPS_CLOSING
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
comment|/* 		 * In LAST_ACK, we may still be waiting for data to drain 		 * and/or to be acked, as well as for the ack of our FIN. 		 * If our FIN is now acknowledged, delete the TCB, 		 * enter the closed state and return. 		 */
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
break|break;
block|}
block|}
name|step6
label|:
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* 	 * Update window information. 	 * Don't look at window if no ACK: TAC's send garbage on first SYN. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl1
argument_list|,
name|th
operator|->
name|th_seq
argument_list|)
operator|||
operator|(
name|tp
operator|->
name|snd_wl1
operator|==
name|th
operator|->
name|th_seq
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl2
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
operator|||
operator|(
name|tp
operator|->
name|snd_wl2
operator|==
name|th
operator|->
name|th_ack
operator|&&
name|tiwin
operator|>
name|tp
operator|->
name|snd_wnd
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
name|tlen
operator|==
literal|0
operator|&&
name|tp
operator|->
name|snd_wl2
operator|==
name|th
operator|->
name|th_ack
operator|&&
name|tiwin
operator|>
name|tp
operator|->
name|snd_wnd
condition|)
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvwinupd
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|tiwin
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
name|tp
operator|->
name|snd_wl2
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>
name|tp
operator|->
name|max_sndwnd
condition|)
name|tp
operator|->
name|max_sndwnd
operator|=
name|tp
operator|->
name|snd_wnd
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Process segments with URG. 	 */
if|if
condition|(
operator|(
name|thflags
operator|&
name|TH_URG
operator|)
operator|&&
name|th
operator|->
name|th_urp
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is a kludge, but if we receive and accept 		 * random urgent pointers, we'll crash in 		 * soreceive.  It's hard to imagine someone 		 * actually wanting to send this much urgent data. 		 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_urp
operator|+
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|>
name|sb_max
condition|)
block|{
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|thflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
comment|/* XXX */
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|dodata
goto|;
comment|/* XXX */
block|}
comment|/* 		 * If this segment advances the known urgent pointer, 		 * then mark the data stream.  This should not happen 		 * in CLOSE_WAIT, CLOSING, LAST_ACK or TIME_WAIT STATES since 		 * a FIN has been received from the remote side. 		 * In these states we ignore the URG. 		 * 		 * According to RFC961 (Assigned Protocols), 		 * the urgent pointer points to the last octet 		 * of urgent data.  We continue, however, 		 * to consider it to indicate the first octet 		 * of data past the urgent section as the original 		 * spec states (in one of two places). 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_seq
operator|+
name|th
operator|->
name|th_urp
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
block|{
name|tp
operator|->
name|rcv_up
operator|=
name|th
operator|->
name|th_seq
operator|+
name|th
operator|->
name|th_urp
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|+
operator|(
name|tp
operator|->
name|rcv_up
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_RCVATMARK
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator|&=
operator|~
operator|(
name|TCPOOB_HAVEDATA
operator||
name|TCPOOB_HADDATA
operator|)
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 		 * Remove out of band data so doesn't get presented to user. 		 * This can happen independent of advancing the URG pointer, 		 * but if two URG's are pending at once, some out-of-band 		 * data may creep in... ick. 		 */
if|if
condition|(
name|th
operator|->
name|th_urp
operator|<=
operator|(
name|uint32_t
operator|)
name|tlen
operator|&&
operator|!
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
operator|)
condition|)
block|{
comment|/* hdr drop is delayed */
name|tcp_pulloutofband
argument_list|(
name|so
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If no out of band data is expected, 		 * pull receive urgent pointer along 		 * with the receive window. 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
name|tp
operator|->
name|rcv_up
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
block|}
name|dodata
label|:
comment|/* XXX */
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* 	 * Process the segment text, merging it into the TCP sequencing queue, 	 * and arranging for acknowledgment of receipt if necessary. 	 * This process logically involves adjusting tp->rcv_wnd as data 	 * is presented to the user (this happens in tcp_usrreq.c, 	 * case PRU_RCVD).  If a FIN has already been received on this 	 * connection then we just ignore the text. 	 */
ifdef|#
directive|ifdef
name|TCP_RFC7413
name|tfo_syn
operator|=
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|)
operator|&&
name|IS_FASTOPEN
argument_list|(
name|tp
operator|->
name|t_flags
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|tfo_syn
value|(false)
endif|#
directive|endif
if|if
condition|(
operator|(
name|tlen
operator|||
operator|(
name|thflags
operator|&
name|TH_FIN
operator|)
operator|||
name|tfo_syn
operator|)
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcp_seq
name|save_start
init|=
name|th
operator|->
name|th_seq
decl_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|drop_hdrlen
argument_list|)
expr_stmt|;
comment|/* delayed header drop */
comment|/* 		 * Insert segment which includes th into TCP reassembly queue 		 * with control block tp.  Set thflags to whether reassembly now 		 * includes a segment with FIN.  This handles the common case 		 * inline (segment is the next to be received on an established 		 * connection, and the queue is empty), avoiding linkage into 		 * and removal from the queue and repetition of various 		 * conversions. 		 * Set DELACK for segments received in order, but ack 		 * immediately when segments are out of order (so 		 * fast retransmit can work). 		 */
if|if
condition|(
name|th
operator|->
name|th_seq
operator|==
name|tp
operator|->
name|rcv_nxt
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|t_segq
argument_list|)
operator|&&
operator|(
name|TCPS_HAVEESTABLISHED
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|||
name|tfo_syn
operator|)
condition|)
block|{
if|if
condition|(
name|DELAY_ACK
argument_list|(
name|tp
argument_list|,
name|tlen
argument_list|)
operator|||
name|tfo_syn
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_DELACK
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|+=
name|tlen
expr_stmt|;
name|thflags
operator|=
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rcvpack
argument_list|)
expr_stmt|;
name|TCPSTAT_ADD
argument_list|(
name|tcps_rcvbyte
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|sbappendstream_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NB: sorwakeup_locked() does an implicit unlock. */
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX: Due to the header drop above "th" is 			 * theoretically invalid by now.  Fortunately 			 * m_adj() doesn't actually frees any mbufs 			 * when trimming from the head. 			 */
name|thflags
operator|=
name|tcp_reass
argument_list|(
name|tp
argument_list|,
name|th
argument_list|,
operator|&
name|tlen
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
block|}
if|if
condition|(
name|tlen
operator|>
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_SACK_PERMIT
operator|)
condition|)
name|tcp_update_sack_list
argument_list|(
name|tp
argument_list|,
name|save_start
argument_list|,
name|save_start
operator|+
name|tlen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * Note the amount of data that peer has sent into 		 * our window, in order to estimate the sender's 		 * buffer size. 		 * XXX: Unused. 		 */
block|if (SEQ_GT(tp->rcv_adv, tp->rcv_nxt)) 			len = so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt); 		else 			len = so->so_rcv.sb_hiwat;
endif|#
directive|endif
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|thflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
block|}
comment|/* 	 * If FIN is received ACK the FIN and let the user know 	 * that the connection is closing. 	 */
if|if
condition|(
name|thflags
operator|&
name|TH_FIN
condition|)
block|{
if|if
condition|(
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 			 * If connection is half-synchronized 			 * (ie NEEDSYN flag on) then delay ACK, 			 * so it may be piggybacked when SYN is sent. 			 * Otherwise, since we received a FIN then no 			 * more input can be expected, send ACK now. 			 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NEEDSYN
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_DELACK
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In SYN_RECEIVED and ESTABLISHED STATES 		 * enter the CLOSE_WAIT state. 		 */
case|case
name|TCPS_SYN_RECEIVED
case|:
name|tp
operator|->
name|t_starttime
operator|=
name|ticks
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TCPS_ESTABLISHED
case|:
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_CLOSE_WAIT
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * If still in FIN_WAIT_1 STATE FIN has not been acked so 		 * enter the CLOSING state. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tcp_state_change
argument_list|(
name|tp
argument_list|,
name|TCPS_CLOSING
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In FIN_WAIT_2 state enter the TIME_WAIT state, 		 * starting the time-wait timer, turning off the other 		 * standard timers. 		 */
case|case
name|TCPS_FIN_WAIT_2
case|:
name|INP_INFO_RLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_RLOCKED
argument_list|,
operator|(
literal|"%s: dodata "
literal|"TCP_FIN_WAIT_2 ti_locked: %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|tcp_twstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Return any desired output. 	 */
if|if
condition|(
name|needoutput
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ACKNOW
operator|)
condition|)
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_delack
label|:
name|KASSERT
argument_list|(
name|ti_locked
operator|==
name|TI_UNLOCKED
argument_list|,
operator|(
literal|"%s: check_delack ti_locked %d"
operator|,
name|__func__
operator|,
name|ti_locked
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_DELACK
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_DELACK
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_DELACK
argument_list|,
name|tcp_delacktime
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
return|return;
name|dropafterack
label|:
comment|/* 	 * Generate an ACK dropping incoming segment if it occupies 	 * sequence space, where the ACK reflects our state. 	 * 	 * We can now skip the test for the RST flag since all 	 * paths to this code happen after packets containing 	 * RST have been dropped. 	 * 	 * In the SYN-RECEIVED state, don't send an ACK unless the 	 * segment we received passes the SYN-RECEIVED ACK test. 	 * If it fails send a RST.  This breaks the loop in the 	 * "LAND" DoS attack, and also prevents an ACK storm 	 * between two listening ports that have been sent forged 	 * SYN segments, each with the source address of the other. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
operator|(
name|thflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
block|{
name|rstreason
operator|=
name|BANDLIM_RST_OPENPORT
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|tcp_dropwithreset
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|tp
argument_list|,
name|tlen
argument_list|,
name|rstreason
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
else|else
name|tcp_dropwithreset
argument_list|(
name|m
argument_list|,
name|th
argument_list|,
name|NULL
argument_list|,
name|tlen
argument_list|,
name|rstreason
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
if|if
condition|(
name|ti_locked
operator|==
name|TI_RLOCKED
condition|)
block|{
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|ti_locked
operator|=
name|TI_UNLOCKED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
else|else
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Drop space held by incoming segment and return. 	 */
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
operator|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|)
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tcp_saveipgen
argument_list|,
operator|&
name|tcp_savetcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TCP_PROBE3
argument_list|(
name|debug__input
argument_list|,
name|tp
argument_list|,
name|th
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TCP_RFC7413
undef|#
directive|undef
name|tfo_syn
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Issue RST and make ACK acceptable to originator of segment.  * The mbuf must still include the original packet header.  * tp may be NULL.  */
end_comment

begin_function
name|void
name|tcp_dropwithreset
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|tlen
parameter_list|,
name|int
name|rstreason
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
block|}
comment|/* Don't bother if destination was broadcast/multicast. */
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
operator|)
operator|||
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
goto|goto
name|drop
goto|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_v
operator|==
literal|6
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* IPv6 anycast check is done at tcp6_input() */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
operator|||
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
comment|/* Perform bandwidth limiting. */
if|if
condition|(
name|badport_bandlim
argument_list|(
name|rstreason
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* tcp_respond consumes the mbuf chain. */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_ACK
condition|)
block|{
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|th
operator|->
name|th_ack
argument_list|,
name|TH_RST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
name|tlen
operator|++
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
name|tlen
operator|++
expr_stmt|;
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|th
argument_list|,
name|m
argument_list|,
name|th
operator|->
name|th_seq
operator|+
name|tlen
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|TH_RST
operator||
name|TH_ACK
argument_list|)
expr_stmt|;
block|}
return|return;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse TCP options and place in tcpopt.  */
end_comment

begin_function
name|void
name|tcp_dooptions
parameter_list|(
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|;
name|to
operator|->
name|to_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
break|break;
name|optlen
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
operator|||
name|optlen
operator|>
name|cnt
condition|)
break|break;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_MAXSEG
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_MAXSEG
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TO_SYN
operator|)
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_MSS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_mss
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_mss
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_mss
operator|=
name|ntohs
argument_list|(
name|to
operator|->
name|to_mss
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_WINDOW
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_WINDOW
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TO_SYN
operator|)
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_SCALE
expr_stmt|;
name|to
operator|->
name|to_wscale
operator|=
name|min
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|,
name|TCP_MAX_WINSHIFT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_TIMESTAMP
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_tsval
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_tsval
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|+
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|->
name|to_tsecr
argument_list|,
sizeof|sizeof
argument_list|(
name|to
operator|->
name|to_tsecr
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|to_tsecr
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsecr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_SIGNATURE
case|:
comment|/* 			 * In order to reply to a host which has set the 			 * TCP_SIGNATURE option in its initial SYN, we have 			 * to record the fact that the option was observed 			 * here for the syncache code to perform the correct 			 * response. 			 */
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_SIGNATURE
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_SIGNATURE
expr_stmt|;
name|to
operator|->
name|to_signature
operator|=
name|cp
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK_PERMITTED
case|:
if|if
condition|(
name|optlen
operator|!=
name|TCPOLEN_SACK_PERMITTED
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TO_SYN
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|V_tcp_do_sack
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_SACKPERM
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK
case|:
if|if
condition|(
name|optlen
operator|<=
literal|2
operator|||
operator|(
name|optlen
operator|-
literal|2
operator|)
operator|%
name|TCPOLEN_SACK
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|flags
operator|&
name|TO_SYN
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_SACK
expr_stmt|;
name|to
operator|->
name|to_nsacks
operator|=
operator|(
name|optlen
operator|-
literal|2
operator|)
operator|/
name|TCPOLEN_SACK
expr_stmt|;
name|to
operator|->
name|to_sacks
operator|=
name|cp
operator|+
literal|2
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_sack_rcv_blocks
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TCP_RFC7413
case|case
name|TCPOPT_FAST_OPEN
case|:
if|if
condition|(
operator|(
name|optlen
operator|!=
name|TCPOLEN_FAST_OPEN_EMPTY
operator|)
operator|&&
operator|(
name|optlen
operator|<
name|TCPOLEN_FAST_OPEN_MIN
operator|)
operator|&&
operator|(
name|optlen
operator|>
name|TCPOLEN_FAST_OPEN_MAX
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TO_SYN
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|V_tcp_fastopen_enabled
condition|)
continue|continue;
name|to
operator|->
name|to_flags
operator||=
name|TOF_FASTOPEN
expr_stmt|;
name|to
operator|->
name|to_tfo_len
operator|=
name|optlen
operator|-
literal|2
expr_stmt|;
name|to
operator|->
name|to_tfo_cookie
operator|=
name|to
operator|->
name|to_tfo_len
condition|?
name|cp
operator|+
literal|2
else|:
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Pull out of band byte out of a segment so  * it doesn't appear in the user's data queue.  * It is still reflected in the segment length for  * sequencing purposes.  */
end_comment

begin_function
name|void
name|tcp_pulloutofband
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|int
name|cnt
init|=
name|off
operator|+
name|th
operator|->
name|th_urp
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|cnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|cnt
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|cnt
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iobc
operator|=
operator|*
name|cp
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator||=
name|TCPOOB_HAVEDATA
expr_stmt|;
name|bcopy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|--
expr_stmt|;
return|return;
block|}
name|cnt
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
block|}
name|panic
argument_list|(
literal|"tcp_pulloutofband"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Collect new round-trip time estimate  * and update averages and current timeout.  */
end_comment

begin_function
name|void
name|tcp_xmit_timer
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|rtt
parameter_list|)
block|{
name|int
name|delta
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|TCPSTAT_INC
argument_list|(
name|tcps_rttupdated
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_srtt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_rxtshift
operator|<=
name|TCP_RTT_INVALIDATE
operator|)
condition|)
block|{
comment|/* 		 * srtt is stored as fixed point with 5 bits after the 		 * binary point (i.e., scaled by 8).  The following magic 		 * is equivalent to the smoothing algorithm in rfc793 with 		 * an alpha of .875 (srtt = rtt/8 + srtt*7/8 in fixed 		 * point).  Adjust rtt to origin 0. 		 */
name|delta
operator|=
operator|(
operator|(
name|rtt
operator|-
literal|1
operator|)
operator|<<
name|TCP_DELTA_SHIFT
operator|)
operator|-
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
operator|(
name|TCP_RTT_SHIFT
operator|-
name|TCP_DELTA_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_srtt
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We accumulate a smoothed rtt variance (actually, a 		 * smoothed mean difference), then set the retransmit 		 * timer to smoothed rtt + 4 times the smoothed variance. 		 * rttvar is stored as fixed point with 4 bits after the 		 * binary point (scaled by 16).  The following is 		 * equivalent to rfc793 smoothing with an alpha of .75 		 * (rttvar = rttvar*3/4 + |delta| / 4).  This replaces 		 * rfc793's wired-in beta. 		 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
name|tp
operator|->
name|t_rttvar
operator|>>
operator|(
name|TCP_RTTVAR_SHIFT
operator|-
name|TCP_DELTA_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_rttvar
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_rttbest
operator|>
name|tp
operator|->
name|t_srtt
operator|+
name|tp
operator|->
name|t_rttvar
condition|)
name|tp
operator|->
name|t_rttbest
operator|=
name|tp
operator|->
name|t_srtt
operator|+
name|tp
operator|->
name|t_rttvar
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No rtt measurement yet - use the unsmoothed rtt. 		 * Set the variance to half the rtt (so our first 		 * retransmit happens at 3*rtt). 		 */
name|tp
operator|->
name|t_srtt
operator|=
name|rtt
operator|<<
name|TCP_RTT_SHIFT
expr_stmt|;
name|tp
operator|->
name|t_rttvar
operator|=
name|rtt
operator|<<
operator|(
name|TCP_RTTVAR_SHIFT
operator|-
literal|1
operator|)
expr_stmt|;
name|tp
operator|->
name|t_rttbest
operator|=
name|tp
operator|->
name|t_srtt
operator|+
name|tp
operator|->
name|t_rttvar
expr_stmt|;
block|}
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_rxtshift
operator|=
literal|0
expr_stmt|;
comment|/* 	 * the retransmit should happen at rtt + 4 * rttvar. 	 * Because of the way we do the smoothing, srtt and rttvar 	 * will each average +1/2 tick of bias.  When we compute 	 * the retransmit timer, we want 1/2 tick of rounding and 	 * 1 extra tick because of +-1/2 tick uncertainty in the 	 * firing of the timer.  The bias will give us exactly the 	 * 1.5 tick we need.  But, because the bias is 	 * statistical, we have to test that we don't drop below 	 * the minimum feasible timer (which is 2 ticks). 	 */
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
name|TCP_REXMTVAL
argument_list|(
name|tp
argument_list|)
argument_list|,
name|max
argument_list|(
name|tp
operator|->
name|t_rttmin
argument_list|,
name|rtt
operator|+
literal|2
argument_list|)
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
comment|/* 	 * We received an ack for a packet that wasn't retransmitted; 	 * it is probably safe to discard any error indications we've 	 * received recently.  This isn't quite right, but close enough 	 * for now (a route might have failed after we sent a segment, 	 * and the return path might not be symmetrical). 	 */
name|tp
operator|->
name|t_softerror
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine a reasonable value for maxseg size.  * If the route is known, check route for mtu.  * If none, use an mss that can be handled on the outgoing interface  * without forcing IP to fragment.  If no route is found, route has no mtu,  * or the destination isn't local, use a default, hopefully conservative  * size (usually 512 or the default IP max size, but no more than the mtu  * of the interface), as we can't discover anything about intervening  * gateways or networks.  We also initialize the congestion/slow start  * window to be a single segment if the destination isn't local.  * While looking at the routing entry, we also initialize other path-dependent  * parameters from pre-set or cached values in the routing entry.  *  * NOTE that resulting t_maxseg doesn't include space for TCP options or  * IP options, e.g. IPSEC data, since length of this data may vary, and  * thus it is calculated for every segment separately in tcp_output().  *  * NOTE that this routine is only called when we process an incoming  * segment, or an ICMP need fragmentation datagram. Outgoing SYN/ACK MSS  * settings are handled in tcp_mssopt().  */
end_comment

begin_function
name|void
name|tcp_mss_update
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|offer
parameter_list|,
name|int
name|mtuoffer
parameter_list|,
name|struct
name|hc_metrics_lite
modifier|*
name|metricptr
parameter_list|,
name|struct
name|tcp_ifcap
modifier|*
name|cap
parameter_list|)
block|{
name|int
name|mss
init|=
literal|0
decl_stmt|;
name|uint32_t
name|maxmtu
init|=
literal|0
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|hc_metrics_lite
name|metrics
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|int
name|isipv6
init|=
operator|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|size_t
name|min_protoh
init|=
name|isipv6
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|size_t
name|min_protoh
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtuoffer
operator|!=
operator|-
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|offer
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"%s: conflict"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|offer
operator|=
name|mtuoffer
operator|-
name|min_protoh
expr_stmt|;
block|}
comment|/* Initialize. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|maxmtu
operator|=
name|tcp_maxmtu6
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|V_tcp_v6mssdflt
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
name|maxmtu
operator|=
name|tcp_maxmtu
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|V_tcp_mssdflt
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * No route to sender, stay with default mss and return. 	 */
if|if
condition|(
name|maxmtu
operator|==
literal|0
condition|)
block|{
comment|/* 		 * In case we return early we need to initialize metrics 		 * to a defined state as tcp_hc_get() would do for us 		 * if there was no cache hit. 		 */
if|if
condition|(
name|metricptr
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|metricptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_metrics_lite
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* What have we got? */
switch|switch
condition|(
name|offer
condition|)
block|{
case|case
literal|0
case|:
comment|/* 			 * Offer == 0 means that there was no MSS on the SYN 			 * segment, in this case we use tcp_mssdflt as 			 * already assigned to t_maxseg above. 			 */
name|offer
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|/* 			 * Offer == -1 means that we didn't receive SYN yet. 			 */
comment|/* FALLTHROUGH */
default|default:
comment|/* 			 * Prevent DoS attack with too small MSS. Round up 			 * to at least minmss. 			 */
name|offer
operator|=
name|max
argument_list|(
name|offer
argument_list|,
name|V_tcp_minmss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * rmx information is now retrieved from tcp_hostcache. 	 */
name|tcp_hc_get
argument_list|(
operator|&
name|inp
operator|->
name|inp_inc
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|metricptr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|metrics
argument_list|,
name|metricptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_metrics_lite
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a discovered mtu in tcp hostcache, use it. 	 * Else, use the link mtu. 	 */
if|if
condition|(
name|metrics
operator|.
name|rmx_mtu
condition|)
name|mss
operator|=
name|min
argument_list|(
name|metrics
operator|.
name|rmx_mtu
argument_list|,
name|maxmtu
argument_list|)
operator|-
name|min_protoh
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|isipv6
condition|)
block|{
name|mss
operator|=
name|maxmtu
operator|-
name|min_protoh
expr_stmt|;
if|if
condition|(
operator|!
name|V_path_mtu_discovery
operator|&&
operator|!
name|in6_localaddr
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
condition|)
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|V_tcp_v6mssdflt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
name|mss
operator|=
name|maxmtu
operator|-
name|min_protoh
expr_stmt|;
if|if
condition|(
operator|!
name|V_path_mtu_discovery
operator|&&
operator|!
name|in_localaddr
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
condition|)
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|V_tcp_mssdflt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * XXX - The above conditional (mss = maxmtu - min_protoh) 		 * probably violates the TCP spec. 		 * The problem is that, since we don't know the 		 * other end's MSS, we are supposed to use a conservative 		 * default.  But, if we do that, then MTU discovery will 		 * never actually take place, because the conservative 		 * default is much less than the MTUs typically seen 		 * on the Internet today.  For the moment, we'll sweep 		 * this under the carpet. 		 * 		 * The conservative default might not actually be a problem 		 * if the only case this occurs is when sending an initial 		 * SYN with options and data to a host we've never talked 		 * to before.  Then, they will reply with an MSS value which 		 * will get recorded and the new parameters should get 		 * recomputed.  For Further Study. 		 */
block|}
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|offer
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check: make sure that maxseg will be large 	 * enough to allow some data on segments even if the 	 * all the option space is used (40bytes).  Otherwise 	 * funny things may happen in tcp_output. 	 * 	 * XXXGL: shouldn't we reserve space for IP/IPv6 options? 	 */
name|mss
operator|=
name|max
argument_list|(
name|mss
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|mss
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_mss
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
name|offer
parameter_list|)
block|{
name|int
name|mss
decl_stmt|;
name|uint32_t
name|bufsize
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|hc_metrics_lite
name|metrics
decl_stmt|;
name|struct
name|tcp_ifcap
name|cap
decl_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: tp == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_mss_update
argument_list|(
name|tp
argument_list|,
name|offer
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|metrics
argument_list|,
operator|&
name|cap
argument_list|)
expr_stmt|;
name|mss
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_inpcb
expr_stmt|;
comment|/* 	 * If there's a pipesize, change the socket buffer to that size, 	 * don't change if sb_hiwat is different than default (then it 	 * has been changed on purpose with setsockopt). 	 * Make the socket buffers an integral number of mss units; 	 * if the mss is larger than the socket buffer, decrease the mss. 	 */
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
name|V_tcp_sendspace
operator|)
operator|&&
name|metrics
operator|.
name|rmx_sendpipe
condition|)
name|bufsize
operator|=
name|metrics
operator|.
name|rmx_sendpipe
expr_stmt|;
else|else
name|bufsize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|bufsize
operator|<
name|mss
condition|)
name|mss
operator|=
name|bufsize
expr_stmt|;
else|else
block|{
name|bufsize
operator|=
name|roundup
argument_list|(
name|bufsize
argument_list|,
name|mss
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|sb_max
condition|)
name|bufsize
operator|=
name|sb_max
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|sbreserve_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|bufsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check: make sure that maxseg will be large 	 * enough to allow some data on segments even if the 	 * all the option space is used (40bytes).  Otherwise 	 * funny things may happen in tcp_output. 	 * 	 * XXXGL: shouldn't we reserve space for IP/IPv6 options? 	 */
name|tp
operator|->
name|t_maxseg
operator|=
name|max
argument_list|(
name|mss
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
name|V_tcp_recvspace
operator|)
operator|&&
name|metrics
operator|.
name|rmx_recvpipe
condition|)
name|bufsize
operator|=
name|metrics
operator|.
name|rmx_recvpipe
expr_stmt|;
else|else
name|bufsize
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|mss
condition|)
block|{
name|bufsize
operator|=
name|roundup
argument_list|(
name|bufsize
argument_list|,
name|mss
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|sb_max
condition|)
name|bufsize
operator|=
name|sb_max
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|sbreserve_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|bufsize
argument_list|,
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Check the interface for TSO capabilities. */
if|if
condition|(
name|cap
operator|.
name|ifcap
operator|&
name|CSUM_TSO
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_TSO
expr_stmt|;
name|tp
operator|->
name|t_tsomax
operator|=
name|cap
operator|.
name|tsomax
expr_stmt|;
name|tp
operator|->
name|t_tsomaxsegcount
operator|=
name|cap
operator|.
name|tsomaxsegcount
expr_stmt|;
name|tp
operator|->
name|t_tsomaxsegsize
operator|=
name|cap
operator|.
name|tsomaxsegsize
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine the MSS option to send on an outgoing SYN.  */
end_comment

begin_function
name|int
name|tcp_mssopt
parameter_list|(
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|)
block|{
name|int
name|mss
init|=
literal|0
decl_stmt|;
name|uint32_t
name|thcmtu
init|=
literal|0
decl_stmt|;
name|uint32_t
name|maxmtu
init|=
literal|0
decl_stmt|;
name|size_t
name|min_protoh
decl_stmt|;
name|KASSERT
argument_list|(
name|inc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"tcp_mssopt with NULL in_conninfo pointer"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inc
operator|->
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
block|{
name|mss
operator|=
name|V_tcp_v6mssdflt
expr_stmt|;
name|maxmtu
operator|=
name|tcp_maxmtu6
argument_list|(
name|inc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|min_protoh
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
name|mss
operator|=
name|V_tcp_mssdflt
expr_stmt|;
name|maxmtu
operator|=
name|tcp_maxmtu
argument_list|(
name|inc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|min_protoh
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|thcmtu
operator|=
name|tcp_hc_getmtu
argument_list|(
name|inc
argument_list|)
expr_stmt|;
comment|/* IPv4 and IPv6 */
endif|#
directive|endif
if|if
condition|(
name|maxmtu
operator|&&
name|thcmtu
condition|)
name|mss
operator|=
name|min
argument_list|(
name|maxmtu
argument_list|,
name|thcmtu
argument_list|)
operator|-
name|min_protoh
expr_stmt|;
elseif|else
if|if
condition|(
name|maxmtu
operator|||
name|thcmtu
condition|)
name|mss
operator|=
name|max
argument_list|(
name|maxmtu
argument_list|,
name|thcmtu
argument_list|)
operator|-
name|min_protoh
expr_stmt|;
return|return
operator|(
name|mss
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On a partial ack arrives, force the retransmission of the  * next unacknowledged segment.  Do not clear tp->t_dupacks.  * By setting snd_nxt to ti_ack, this forces retransmission timer to  * be started again.  */
end_comment

begin_function
name|void
name|tcp_newreno_partial_ack
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|tcp_seq
name|onxt
init|=
name|tp
operator|->
name|snd_nxt
decl_stmt|;
name|uint32_t
name|ocwnd
init|=
name|tp
operator|->
name|snd_cwnd
decl_stmt|;
name|u_int
name|maxseg
init|=
name|tcp_maxseg
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
comment|/* 	 * Set snd_cwnd to one segment beyond acknowledged offset. 	 * (tp->snd_una has not yet been updated when this function is called.) 	 */
name|tp
operator|->
name|snd_cwnd
operator|=
name|maxseg
operator|+
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tp
operator|->
name|t_fb
operator|->
name|tfb_tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|ocwnd
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|onxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|onxt
expr_stmt|;
comment|/* 	 * Partial window deflation.  Relies on fact that tp->snd_una 	 * not updated yet. 	 */
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|>
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
condition|)
name|tp
operator|->
name|snd_cwnd
operator|-=
name|BYTES_THIS_ACK
argument_list|(
name|tp
argument_list|,
name|th
argument_list|)
expr_stmt|;
else|else
name|tp
operator|->
name|snd_cwnd
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|+=
name|maxseg
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tcp_compute_pipe
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
return|return
operator|(
name|tp
operator|->
name|snd_max
operator|-
name|tp
operator|->
name|snd_una
operator|+
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|-
name|tp
operator|->
name|sackhint
operator|.
name|sacked_bytes
operator|)
return|;
block|}
end_function

end_unit

