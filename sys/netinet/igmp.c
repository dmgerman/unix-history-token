begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Bruce Simpson.  * Copyright (c) 1988 Stephen Deering.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)igmp.c	8.1 (Berkeley) 7/19/93  */
end_comment

begin_comment
comment|/*  * Internet Group Management Protocol (IGMP) routines.  * [RFC1112, RFC2236, RFC3376]  *  * Written by Steve Deering, Stanford, May 1988.  * Modified by Rosen Sharma, Stanford, Aug 1994.  * Modified by Bill Fenner, Xerox PARC, Feb 1995.  * Modified to fully comply to IGMPv2 by Bill Fenner, Oct 1995.  * Significantly rewritten for IGMPv3, VIMAGE, and SMP by Bruce Simpson.  *  * MULTICAST Revision: 3.5.1.4  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_options.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_IGMPV3
end_ifndef

begin_define
define|#
directive|define
name|KTR_IGMPV3
value|KTR_INET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|igmp_ifinfo
modifier|*
name|igi_alloc_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igi_delete_locked
parameter_list|(
specifier|const
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_dispatch_queue
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_fasttimo_vnet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_final_leave
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_handle_state_change
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_initial_join
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v1_query
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
parameter_list|,
specifier|const
name|struct
name|igmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v2_query
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
parameter_list|,
specifier|const
name|struct
name|igmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v3_query
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|igmpv3
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v3_group_query
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|,
name|int
parameter_list|,
comment|/*const*/
name|struct
name|igmpv3
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v1_report
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|ip
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|igmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_input_v2_report
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|ip
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|igmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_intr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_isgroupreported
parameter_list|(
specifier|const
name|struct
name|in_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|igmp_ra_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|igmp_rec_type_to_str
parameter_list|(
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|igmp_set_version
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_slowtimo_vnet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_v1v2_queue_report
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v1v2_process_group_timer
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v1v2_process_querier_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v2_update_group
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v3_cancel_link_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v3_dispatch_general_query
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|igmp_v3_encap_report
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_v3_enqueue_group_record
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_v3_enqueue_filter_change
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v3_process_group_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igmp_v3_merge_state_changes
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igmp_v3_suppress_group_record
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_igmp_default_version
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_igmp_gsr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_igmp_ifinfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|netisr_handler
name|igmp_nh
init|=
block|{
operator|.
name|nh_name
operator|=
literal|"igmp"
block|,
operator|.
name|nh_handler
operator|=
name|igmp_intr
block|,
operator|.
name|nh_proto
operator|=
name|NETISR_IGMP
block|,
operator|.
name|nh_policy
operator|=
name|NETISR_POLICY_SOURCE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System-wide globals.  *  * Unlocked access to these is OK, except for the global IGMP output  * queue. The IGMP subsystem lock ends up being system-wide for the moment,  * because all VIMAGEs have to share a global output queue, as netisrs  * themselves are not virtualized.  *  * Locking:  *  * The permitted lock order is: IN_MULTI_LOCK, IGMP_LOCK, IF_ADDR_LOCK.  *    Any may be taken independently; if any are held at the same  *    time, the above lock order must be followed.  *  * All output is delegated to the netisr.  *    Now that Giant has been eliminated, the netisr may be inlined.  *  * IN_MULTI_LOCK covers in_multi.  *  * IGMP_LOCK covers igmp_ifinfo and any global variables in this file,  *    including the output queue.  *  * IF_ADDR_LOCK covers if_multiaddrs, which is used for a variety of  *    per-link state iterators.  *  * igmp_ifinfo is valid as long as PF_INET is attached to the interface,  *    therefore it is not refcounted.  *    We allow unlocked reads of igmp_ifinfo when accessed via in_multi.  *  * Reference counting  *  * IGMP acquires its own reference every time an in_multi is passed to  *    it and the group is being joined for the first time.  *  * IGMP releases its reference(s) on in_multi in a deferred way,  *    because the operations which process the release run as part of  *    a loop whose control variables are directly affected by the release  *    (that, and not recursing on the IF_ADDR_LOCK).  *  * VIMAGE: Each in_multi corresponds to an ifp, and each ifp corresponds  * to a vnet in ifp->if_vnet.  *  * SMPng: XXX We may potentially race operations on ifma_protospec.  * The problem is that we currently lack a clean way of taking the  * IF_ADDR_LOCK() between the ifnet and in layers w/o recursing,  * as anything which modifies ifma needs to be covered by that lock.  * So check for ifma_protospec being NULL before proceeding.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|igmp_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m_raopt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Router Alert option */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IGMP
argument_list|,
literal|"igmp"
argument_list|,
literal|"igmp state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * VIMAGE-wide globals.  *  * The IGMPv3 timers themselves need to run per-image, however,  * protosw timers run globally (see tcp).  * An ifnet can only be in one vimage at a time, and the loopback  * ifnet, loif, is itself virtualized.  * It would otherwise be possible to seriously hose IGMP state,  * and create inconsistencies in upstream multicast routing, if you have  * multiple VIMAGEs running on the same link joining different multicast  * groups, UNLESS the "primary IP address" is different. This is because  * IGMP for IPv4 does not force link-local addresses to be used for each  * node, unlike MLD for IPv6.  * Obviously the IGMPv3 per-interface state has per-vimage granularity  * also as a result.  *  * FUTURE: Stop using IFP_TO_IA/INADDR_ANY, and use source address selection  * policy to control the address used by IGMP on the link.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|interface_timers_running
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IGMPv3 general 							 * query response */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|state_change_timers_running
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IGMPv3 state-change 							 * retransmit */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|current_state_timers_running
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IGMPv1/v2 host 							 * report; IGMPv3 g/sg 							 * query response */
end_comment

begin_define
define|#
directive|define
name|V_interface_timers_running
value|VNET(interface_timers_running)
end_define

begin_define
define|#
directive|define
name|V_state_change_timers_running
value|VNET(state_change_timers_running)
end_define

begin_define
define|#
directive|define
name|V_current_state_timers_running
value|VNET(current_state_timers_running)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(,
name|igmp_ifinfo
argument_list|)
argument_list|,
name|igi_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|igmpstat
argument_list|,
name|igmpstat
argument_list|)
operator|=
block|{
operator|.
name|igps_version
operator|=
name|IGPS_VERSION_3
block|,
operator|.
name|igps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|igmpstat
argument_list|)
block|, }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|timeval
argument_list|,
name|igmp_gsrdelay
argument_list|)
operator|=
block|{
literal|10
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_igi_head
value|VNET(igi_head)
end_define

begin_define
define|#
directive|define
name|V_igmpstat
value|VNET(igmpstat)
end_define

begin_define
define|#
directive|define
name|V_igmp_gsrdelay
value|VNET(igmp_gsrdelay)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_recvifkludge
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_sendra
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_sendlocal
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_v1enable
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_v2enable
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_legacysupp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|igmp_default_version
argument_list|)
operator|=
name|IGMP_VERSION_3
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_igmp_recvifkludge
value|VNET(igmp_recvifkludge)
end_define

begin_define
define|#
directive|define
name|V_igmp_sendra
value|VNET(igmp_sendra)
end_define

begin_define
define|#
directive|define
name|V_igmp_sendlocal
value|VNET(igmp_sendlocal)
end_define

begin_define
define|#
directive|define
name|V_igmp_v1enable
value|VNET(igmp_v1enable)
end_define

begin_define
define|#
directive|define
name|V_igmp_v2enable
value|VNET(igmp_v2enable)
end_define

begin_define
define|#
directive|define
name|V_igmp_legacysupp
value|VNET(igmp_legacysupp)
end_define

begin_define
define|#
directive|define
name|V_igmp_default_version
value|VNET(igmp_default_version)
end_define

begin_comment
comment|/*  * Virtualized sysctls.  */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_STRUCT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|IGMPCTL_STATS
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmpstat
argument_list|)
argument_list|,
name|igmpstat
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|recvifkludge
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_recvifkludge
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Rewrite IGMPv1/v2 reports from 0.0.0.0 to contain subnet address"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|sendra
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_sendra
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Send IP Router Alert option in IGMPv2/v3 messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|sendlocal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_sendlocal
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Send IGMP membership reports for 224.0.0.0/24 groups"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|v1enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_v1enable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable backwards compatibility with IGMPv1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|v2enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_v2enable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable backwards compatibility with IGMPv2"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|legacysupp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_legacysupp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Allow v1/v2 reports to suppress v3 group responses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PROC
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|default_version
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_default_version
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sysctl_igmp_default_version
argument_list|,
literal|"I"
argument_list|,
literal|"Default version of IGMP to run on each interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PROC
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|gsrdelay
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|igmp_gsrdelay
operator|.
name|tv_sec
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sysctl_igmp_gsr
argument_list|,
literal|"I"
argument_list|,
literal|"Rate limit for IGMPv3 Group-and-Source queries in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Non-virtualized sysctls.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_igmp
argument_list|,
name|OID_AUTO
argument_list|,
name|ifinfo
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sysctl_igmp_ifinfo
argument_list|,
literal|"Per-interface IGMPv3 state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|igmp_save_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VIMAGE
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
endif|#
directive|endif
comment|/* VIMAGE */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|igmp_scrub_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|inet_ntoa_haddr
parameter_list|(
name|in_addr_t
name|haddr
parameter_list|)
block|{
name|struct
name|in_addr
name|ia
decl_stmt|;
name|ia
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|haddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Restore context from a queued IGMP output chain.  * Return saved ifindex.  *  * VIMAGE: The assertion is there to make sure that we  * actually called CURVNET_SET() with what's in the mbuf chain.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|igmp_restore_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
if|#
directive|if
name|defined
argument_list|(
name|VIMAGE
argument_list|)
operator|&&
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|KASSERT
argument_list|(
name|curvnet
operator|==
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|)
argument_list|,
operator|(
literal|"%s: called when curvnet was not restored"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve or set default IGMP version.  *  * VIMAGE: Assume curvnet set by caller.  * SMPng: NOTE: Serialized by IGMP lock.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_igmp_default_version
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|new
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|new
operator|=
name|V_igmp_default_version
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
goto|goto
name|out_locked
goto|;
if|if
condition|(
name|new
operator|<
name|IGMP_VERSION_1
operator|||
name|new
operator|>
name|IGMP_VERSION_3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"change igmp_default_version from %d to %d"
argument_list|,
name|V_igmp_default_version
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|V_igmp_default_version
operator|=
name|new
expr_stmt|;
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve or set threshold between group-source queries in seconds.  *  * VIMAGE: Assume curvnet set by caller.  * SMPng: NOTE: Serialized by IGMP lock.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_igmp_gsr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|i
operator|=
name|V_igmp_gsrdelay
operator|.
name|tv_sec
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
goto|goto
name|out_locked
goto|;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
operator|||
name|i
operator|>=
literal|60
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"change igmp_gsrdelay from %d to %d"
argument_list|,
name|V_igmp_gsrdelay
operator|.
name|tv_sec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|V_igmp_gsrdelay
operator|.
name|tv_sec
operator|=
name|i
expr_stmt|;
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expose struct igmp_ifinfo to userland, keyed by ifindex.  * For use by ifmcstat(8).  *  * SMPng: NOTE: Does an unlocked ifindex space read.  * VIMAGE: Assume curvnet set by caller. The node handler itself  * is not directly virtualized.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_igmp_ifinfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|name
operator|=
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|namelen
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|namelen
operator|!=
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_ifinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|<=
literal|0
operator|||
name|name
index|[
literal|0
index|]
operator|>
name|V_if_index
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|out_locked
goto|;
name|LIST_FOREACH
argument_list|(
argument|igi
argument_list|,
argument|&V_igi_head
argument_list|,
argument|igi_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|igi
operator|->
name|igi_ifp
condition|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|igi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_ifinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch an entire queue of pending packet chains  * using the netisr.  * VIMAGE: Assumes the vnet pointer has been set.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_dispatch_queue
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|int
name|limit
parameter_list|,
specifier|const
name|int
name|loop
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dispatch %p from %p"
argument_list|,
name|__func__
argument_list|,
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_IGMP_LOOP
expr_stmt|;
name|netisr_dispatch
argument_list|(
name|NETISR_IGMP
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|limit
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Filter outgoing IGMP report state by group.  *  * Reports are ALWAYS suppressed for ALL-HOSTS (224.0.0.1).  * If the net.inet.igmp.sendlocal sysctl is 0, then IGMP reports are  * disabled for all groups in the 224.0.0.0/24 link-local scope. However,  * this may break certain IGMP snooping switches which rely on the old  * report behaviour.  *  * Return zero if the given group is one for which IGMP reports  * should be suppressed, or non-zero if reports should be issued.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|igmp_isgroupreported
parameter_list|(
specifier|const
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
if|if
condition|(
name|in_allhosts
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
operator|(
operator|!
name|V_igmp_sendlocal
operator|&&
name|IN_LOCAL_GROUP
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a Router Alert option to use in outgoing packets.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|igmp_ra_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ipoption
modifier|*
name|p
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ipoption
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|ipopt_dst
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|p
operator|->
name|ipopt_list
index|[
literal|0
index|]
operator|=
name|IPOPT_RA
expr_stmt|;
comment|/* Router Alert Option */
name|p
operator|->
name|ipopt_list
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* 4 bytes long */
name|p
operator|->
name|ipopt_list
index|[
literal|2
index|]
operator|=
name|IPOPT_EOL
expr_stmt|;
comment|/* End of IP option list */
name|p
operator|->
name|ipopt_list
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* pad byte */
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ipopt_dst
argument_list|)
operator|+
name|p
operator|->
name|ipopt_list
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach IGMP when PF_INET is attached to an interface.  */
end_comment

begin_function
name|struct
name|igmp_ifinfo
modifier|*
name|igmp_domifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
name|igi_alloc_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
name|igi
operator|->
name|igi_flags
operator||=
name|IGIF_SILENT
expr_stmt|;
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|igi
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VIMAGE: assume curvnet set by caller.  */
end_comment

begin_function
specifier|static
name|struct
name|igmp_ifinfo
modifier|*
name|igi_alloc_locked
parameter_list|(
comment|/*const*/
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|igi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_ifinfo
argument_list|)
argument_list|,
name|M_IGMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|igi
operator|->
name|igi_ifp
operator|=
name|ifp
expr_stmt|;
name|igi
operator|->
name|igi_version
operator|=
name|V_igmp_default_version
expr_stmt|;
name|igi
operator|->
name|igi_flags
operator|=
literal|0
expr_stmt|;
name|igi
operator|->
name|igi_rv
operator|=
name|IGMP_RV_INIT
expr_stmt|;
name|igi
operator|->
name|igi_qi
operator|=
name|IGMP_QI_INIT
expr_stmt|;
name|igi
operator|->
name|igi_qri
operator|=
name|IGMP_QRI_INIT
expr_stmt|;
name|igi
operator|->
name|igi_uri
operator|=
name|IGMP_URI_INIT
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|)
expr_stmt|;
comment|/* 	 * Responses to general queries are subject to bounds. 	 */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|igi
operator|->
name|igi_gq
argument_list|,
name|IGMP_MAX_RESPONSE_PACKETS
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_igi_head
argument_list|,
name|igi
argument_list|,
name|igi_link
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"allocate igmp_ifinfo for ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|igi
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook for ifdetach.  *  * NOTE: Some finalization tasks need to run before the protocol domain  * is detached, but also before the link layer does its cleanup.  *  * SMPNG: igmp_ifdetach() needs to take IF_ADDR_LOCK().  * XXX This is also bitten by unlocked ifma_protospec access.  */
end_comment

begin_function
name|void
name|igmp_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|,
modifier|*
name|tinm
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
if|#
directive|if
literal|0
block|KASSERT(ifma->ifma_protospec != NULL, 			    ("%s: ifma_protospec is NULL", __func__));
endif|#
directive|endif
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_LEAVING_MEMBER
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
block|}
name|inm_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 		 * Free the in_multi reference(s) for this IGMP lifecycle. 		 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&igi->igi_relinmhead
argument_list|,
argument|inm_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
block|}
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hook for domifdetach.  */
end_comment

begin_function
name|void
name|igmp_domifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
name|igi_delete_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igi_delete_locked
parameter_list|(
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|,
modifier|*
name|tigi
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: freeing igmp_ifinfo for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|igi
argument_list|,
argument|&V_igi_head
argument_list|,
argument|igi_link
argument_list|,
argument|tigi
argument_list|)
block|{
if|if
condition|(
name|igi
operator|->
name|igi_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* 			 * Free deferred General Query responses. 			 */
name|_IF_DRAIN
argument_list|(
operator|&
name|igi
operator|->
name|igi_gq
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|igi
argument_list|,
name|igi_link
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|)
argument_list|,
operator|(
literal|"%s: there are dangling in_multi references"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|igi
argument_list|,
name|M_IGMP
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: igmp_ifinfo not found for ifp %p\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Process a received IGMPv1 query.  * Return non-zero if the message should be dropped.  *  * VIMAGE: The curvnet pointer is derived from the input ifp.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v1_query
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
specifier|const
name|struct
name|igmp
modifier|*
name|igmp
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
comment|/* 	 * IGMPv1 Host Mmembership Queries SHOULD always be addressed to 	 * 224.0.0.1. They are always treated as General Queries. 	 * igmp_group is always ignored. Do not drop it as a userland 	 * daemon may wish to see it. 	 * XXX SMPng: unlocked increments in igmpstat assumed atomic. 	 */
if|if
condition|(
operator|!
name|in_allhosts
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|||
operator|!
name|in_nullhost
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badqueries
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_gen_queries
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igmp_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"ignore v1 query on IGIF_LOOPBACK ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * Switch to IGMPv1 host compatibility mode. 	 */
name|igmp_set_version
argument_list|(
name|igi
argument_list|,
name|IGMP_VERSION_1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v1 query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 	 * Start the timers in all of our group records 	 * for the interface on which the query arrived, 	 * except those which are already running. 	 */
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_timer
operator|!=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|IGMP_V1V2_MAX_RI
operator|*
name|PR_FASTHZ
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received IGMPv2 general or group-specific query.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v2_query
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
specifier|const
name|struct
name|igmp
modifier|*
name|igmp
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|is_general_query
decl_stmt|;
name|uint16_t
name|timer
decl_stmt|;
name|is_general_query
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Validate address fields upfront. 	 * XXX SMPng: unlocked increments in igmpstat assumed atomic. 	 */
if|if
condition|(
name|in_nullhost
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
condition|)
block|{
comment|/* 		 * IGMPv2 General Query. 		 * If this was not sent to the all-hosts group, ignore it. 		 */
if|if
condition|(
operator|!
name|in_allhosts
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_gen_queries
argument_list|)
expr_stmt|;
name|is_general_query
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* IGMPv2 Group-Specific Query. */
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_group_queries
argument_list|)
expr_stmt|;
block|}
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igmp_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"ignore v2 query on IGIF_LOOPBACK ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * Ignore v2 query if in v1 Compatibility Mode. 	 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_1
condition|)
goto|goto
name|out_locked
goto|;
name|igmp_set_version
argument_list|(
name|igi
argument_list|,
name|IGMP_VERSION_2
argument_list|)
expr_stmt|;
name|timer
operator|=
name|igmp
operator|->
name|igmp_code
operator|*
name|PR_FASTHZ
operator|/
name|IGMP_TIMER_SCALE
expr_stmt|;
if|if
condition|(
name|timer
operator|==
literal|0
condition|)
name|timer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_general_query
condition|)
block|{
comment|/* 		 * For each reporting group joined on this 		 * interface, kick the report timer. 		 */
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v2 general query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
name|igmp_v2_update_group
argument_list|(
name|inm
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Group-specific IGMPv2 query, we need only 		 * look up the single group to process it. 		 */
name|inm
operator|=
name|inm_lookup
argument_list|(
name|ifp
argument_list|,
name|igmp
operator|->
name|igmp_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v2 query %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igmp_v2_update_group
argument_list|(
name|inm
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the report timer on a group in response to an IGMPv2 query.  *  * If we are becoming the reporting member for this group, start the timer.  * If we already are the reporting member for this group, and timer is  * below the threshold, reset it.  *  * We may be updating the group for the first time since we switched  * to IGMPv3. If we are, then we must clear any recorded source lists,  * and transition to REPORTING state; the group timer is overloaded  * for group and group-source query responses.   *  * Unlike IGMPv3, the delay per group should be jittered  * to avoid bursts of IGMPv2 reports.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v2_update_group
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|timer
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: %s/%s timer=%d"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
if|if
condition|(
name|inm
operator|->
name|inm_timer
operator|!=
literal|0
operator|&&
name|inm
operator|->
name|inm_timer
operator|<=
name|timer
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: REPORTING and timer running, "
literal|"skipping."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ->REPORTING"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IGMP_SLEEPING_MEMBER
case|:
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ->AWAKENING"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_AWAKENING_MEMBER
expr_stmt|;
break|break;
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a received IGMPv3 general, group-specific or  * group-and-source-specific query.  * Assumes m has already been pulled up to the full IGMP message length.  * Return 0 if successful, otherwise an appropriate error code is returned.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v3_query
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
comment|/*const*/
name|struct
name|igmpv3
modifier|*
name|igmpv3
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|is_general_query
decl_stmt|;
name|uint32_t
name|maxresp
decl_stmt|,
name|nsrc
decl_stmt|,
name|qqi
decl_stmt|;
name|uint16_t
name|timer
decl_stmt|;
name|uint8_t
name|qrv
decl_stmt|;
name|is_general_query
operator|=
literal|0
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v3 query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|maxresp
operator|=
name|igmpv3
operator|->
name|igmp_code
expr_stmt|;
comment|/* in 1/10ths of a second */
if|if
condition|(
name|maxresp
operator|>=
literal|128
condition|)
block|{
name|maxresp
operator|=
name|IGMP_MANT
argument_list|(
name|igmpv3
operator|->
name|igmp_code
argument_list|)
operator|<<
operator|(
name|IGMP_EXP
argument_list|(
name|igmpv3
operator|->
name|igmp_code
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
comment|/* 	 * Robustness must never be less than 2 for on-wire IGMPv3. 	 * FUTURE: Check if ifp has IGIF_LOOPBACK set, as we will make 	 * an exception for interfaces whose IGMPv3 state changes 	 * are redirected to loopback (e.g. MANET). 	 */
name|qrv
operator|=
name|IGMP_QRV
argument_list|(
name|igmpv3
operator|->
name|igmp_misc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qrv
operator|<
literal|2
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: clamping qrv %d to %d"
argument_list|,
name|__func__
argument_list|,
name|qrv
argument_list|,
name|IGMP_RV_INIT
argument_list|)
expr_stmt|;
name|qrv
operator|=
name|IGMP_RV_INIT
expr_stmt|;
block|}
name|qqi
operator|=
name|igmpv3
operator|->
name|igmp_qqi
expr_stmt|;
if|if
condition|(
name|qqi
operator|>=
literal|128
condition|)
block|{
name|qqi
operator|=
name|IGMP_MANT
argument_list|(
name|igmpv3
operator|->
name|igmp_qqi
argument_list|)
operator|<<
operator|(
name|IGMP_EXP
argument_list|(
name|igmpv3
operator|->
name|igmp_qqi
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|timer
operator|=
name|maxresp
operator|*
name|PR_FASTHZ
operator|/
name|IGMP_TIMER_SCALE
expr_stmt|;
if|if
condition|(
name|timer
operator|==
literal|0
condition|)
name|timer
operator|=
literal|1
expr_stmt|;
name|nsrc
operator|=
name|ntohs
argument_list|(
name|igmpv3
operator|->
name|igmp_numsrc
argument_list|)
expr_stmt|;
comment|/* 	 * Validate address fields and versions upfront before 	 * accepting v3 query. 	 * XXX SMPng: Unlocked access to igmpstat counters here. 	 */
if|if
condition|(
name|in_nullhost
argument_list|(
name|igmpv3
operator|->
name|igmp_group
argument_list|)
condition|)
block|{
comment|/* 		 * IGMPv3 General Query. 		 * 		 * General Queries SHOULD be directed to 224.0.0.1. 		 * A general query with a source list has undefined 		 * behaviour; discard it. 		 */
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_gen_queries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_allhosts
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|||
name|nsrc
operator|>
literal|0
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badqueries
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|is_general_query
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Group or group-source specific query. */
if|if
condition|(
name|nsrc
operator|==
literal|0
condition|)
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_group_queries
argument_list|)
expr_stmt|;
else|else
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_gsr_queries
argument_list|)
expr_stmt|;
block|}
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igmp_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"ignore v3 query on IGIF_LOOPBACK ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * Discard the v3 query if we're in Compatibility Mode. 	 * The RFC is not obviously worded that hosts need to stay in 	 * compatibility mode until the Old Version Querier Present 	 * timer expires. 	 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_3
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"ignore v3 query in v%d mode on ifp %p(%s)"
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|igmp_set_version
argument_list|(
name|igi
argument_list|,
name|IGMP_VERSION_3
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_rv
operator|=
name|qrv
expr_stmt|;
name|igi
operator|->
name|igi_qi
operator|=
name|qqi
expr_stmt|;
name|igi
operator|->
name|igi_qri
operator|=
name|maxresp
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: qrv %d qi %d qri %d"
argument_list|,
name|__func__
argument_list|,
name|qrv
argument_list|,
name|qqi
argument_list|,
name|maxresp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_general_query
condition|)
block|{
comment|/* 		 * Schedule a current-state report on this ifp for 		 * all groups, possibly containing source lists. 		 * If there is a pending General Query response 		 * scheduled earlier than the selected delay, do 		 * not schedule any other reports. 		 * Otherwise, reset the interface timer. 		 */
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v3 general query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_v3_timer
operator|==
literal|0
operator|||
name|igi
operator|->
name|igi_v3_timer
operator|>=
name|timer
condition|)
block|{
name|igi
operator|->
name|igi_v3_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_interface_timers_running
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Group-source-specific queries are throttled on 		 * a per-group basis to defeat denial-of-service attempts. 		 * Queries for groups we are not a member of on this 		 * link are simply ignored. 		 */
name|inm
operator|=
name|inm_lookup
argument_list|(
name|ifp
argument_list|,
name|igmpv3
operator|->
name|igmp_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
goto|goto
name|out_locked
goto|;
if|if
condition|(
name|nsrc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ratecheck
argument_list|(
operator|&
name|inm
operator|->
name|inm_lastgsrtv
argument_list|,
operator|&
name|V_igmp_gsrdelay
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: GS query throttled."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_drop_gsr_queries
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v3 %s query on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmpv3
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * If there is a pending General Query response 		 * scheduled sooner than the selected delay, no 		 * further report need be scheduled. 		 * Otherwise, prepare to respond to the 		 * group-specific or group-and-source query. 		 */
if|if
condition|(
name|igi
operator|->
name|igi_v3_timer
operator|==
literal|0
operator|||
name|igi
operator|->
name|igi_v3_timer
operator|>=
name|timer
condition|)
name|igmp_input_v3_group_query
argument_list|(
name|inm
argument_list|,
name|igi
argument_list|,
name|timer
argument_list|,
name|igmpv3
argument_list|)
expr_stmt|;
block|}
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a recieved IGMPv3 group-specific or group-and-source-specific  * query.  * Return<0 if any error occured. Currently this is ignored.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v3_group_query
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|,
name|int
name|timer
parameter_list|,
comment|/*const*/
name|struct
name|igmpv3
modifier|*
name|igmpv3
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|uint16_t
name|nsrc
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
return|return
operator|(
name|retval
operator|)
return|;
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
break|break;
block|}
name|nsrc
operator|=
name|ntohs
argument_list|(
name|igmpv3
operator|->
name|igmp_numsrc
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with group-specific queries upfront. 	 * If any group query is already pending, purge any recorded 	 * source-list state if it exists, and schedule a query response 	 * for this group-specific query. 	 */
if|if
condition|(
name|nsrc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_G_QUERY_PENDING_MEMBER
operator|||
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_SG_QUERY_PENDING_MEMBER
condition|)
block|{
name|inm_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|timer
operator|=
name|min
argument_list|(
name|inm
operator|->
name|inm_timer
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_G_QUERY_PENDING_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Deal with the case where a group-and-source-specific query has 	 * been received but a group-specific query is already pending. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_G_QUERY_PENDING_MEMBER
condition|)
block|{
name|timer
operator|=
name|min
argument_list|(
name|inm
operator|->
name|inm_timer
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Finally, deal with the case where a group-and-source-specific 	 * query has been received, where a response to a previous g-s-r 	 * query exists, or none exists. 	 * In this case, we need to parse the source-list which the Querier 	 * has provided us with and check if we have any source list filter 	 * entries at T1 for these sources. If we do not, there is no need 	 * schedule a report and the query may be dropped. 	 * If we do, we must record them and schedule a current-state 	 * report for those sources. 	 * FIXME: Handling source lists larger than 1 mbuf requires that 	 * we pass the mbuf chain pointer down to this function, and use 	 * m_getptr() to walk the chain. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_nsrc
operator|>
literal|0
condition|)
block|{
specifier|const
name|struct
name|in_addr
modifier|*
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nrecorded
decl_stmt|;
name|ap
operator|=
operator|(
specifier|const
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|igmpv3
operator|+
literal|1
operator|)
expr_stmt|;
name|nrecorded
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsrc
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
name|retval
operator|=
name|inm_record_source
argument_list|(
name|inm
argument_list|,
name|ap
operator|->
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
break|break;
name|nrecorded
operator|+=
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|nrecorded
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: schedule response to SG query"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_SG_QUERY_PENDING_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received IGMPv1 host membership report.  *  * NOTE: 0.0.0.0 workaround breaks const correctness.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v1_report
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
comment|/*const*/
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
comment|/*const*/
name|struct
name|igmp
modifier|*
name|igmp
parameter_list|)
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_reports
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
operator|!
name|in_hosteq
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|)
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badreports
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * RFC 3376, Section 4.2.13, 9.2, 9.3: 	 * Booting clients may use the source address 0.0.0.0. Some 	 * IGMP daemons may not know how to use IP_RECVIF to determine 	 * the interface upon which this message was received. 	 * Replace 0.0.0.0 with the subnet address if told to do so. 	 */
if|if
condition|(
name|V_igmp_recvifkludge
operator|&&
name|in_nullhost
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
condition|)
block|{
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ia
operator|->
name|ia_subnet
argument_list|)
expr_stmt|;
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v1 report %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 	 * IGMPv1 report suppression. 	 * If we are a member of this group, and our membership should be 	 * reported, stop our group timer and transition to the 'lazy' state. 	 */
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|inm
operator|=
name|inm_lookup
argument_list|(
name|ifp
argument_list|,
name|igmp
operator|->
name|igmp_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|igi
operator|=
name|inm
operator|->
name|inm_igi
expr_stmt|;
if|if
condition|(
name|igi
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igi for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_ourreports
argument_list|)
expr_stmt|;
comment|/* 		 * If we are in IGMPv3 host mode, do not allow the 		 * other host's IGMPv1 report to suppress our reports 		 * unless explicitly configured to do so. 		 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
if|if
condition|(
name|V_igmp_legacysupp
condition|)
name|igmp_v3_suppress_group_record
argument_list|(
name|inm
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
break|break;
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"report suppressed for %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
case|case
name|IGMP_SLEEPING_MEMBER
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_SLEEPING_MEMBER
expr_stmt|;
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"report suppressed for %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_1
condition|)
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_LAZY_MEMBER
expr_stmt|;
elseif|else
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_2
condition|)
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_SLEEPING_MEMBER
expr_stmt|;
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|out_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received IGMPv2 host membership report.  *  * NOTE: 0.0.0.0 workaround breaks const correctness.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_input_v2_report
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
comment|/*const*/
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
comment|/*const*/
name|struct
name|igmp
modifier|*
name|igmp
parameter_list|)
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
comment|/* 	 * Make sure we don't hear our own membership report.  Fast 	 * leave requires knowing that we are the only member of a 	 * group. 	 */
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
operator|&&
name|in_hosteq
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_reports
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
operator|!
name|in_hosteq
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badreports
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * RFC 3376, Section 4.2.13, 9.2, 9.3: 	 * Booting clients may use the source address 0.0.0.0. Some 	 * IGMP daemons may not know how to use IP_RECVIF to determine 	 * the interface upon which this message was received. 	 * Replace 0.0.0.0 with the subnet address if told to do so. 	 */
if|if
condition|(
name|V_igmp_recvifkludge
operator|&&
name|in_nullhost
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ia
operator|->
name|ia_subnet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"process v2 report %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 	 * IGMPv2 report suppression. 	 * If we are a member of this group, and our membership should be 	 * reported, and our group timer is pending or about to be reset, 	 * stop our group timer by transitioning to the 'lazy' state. 	 */
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|inm
operator|=
name|inm_lookup
argument_list|(
name|ifp
argument_list|,
name|igmp
operator|->
name|igmp_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|igi
operator|=
name|inm
operator|->
name|inm_igi
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igi for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_ourreports
argument_list|)
expr_stmt|;
comment|/* 		 * If we are in IGMPv3 host mode, do not allow the 		 * other host's IGMPv1 report to suppress our reports 		 * unless explicitly configured to do so. 		 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
if|if
condition|(
name|V_igmp_legacysupp
condition|)
name|igmp_v3_suppress_group_record
argument_list|(
name|inm
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"report suppressed for %s on ifp %p(%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|igmp
operator|->
name|igmp_group
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
case|case
name|IGMP_LAZY_MEMBER
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_LAZY_MEMBER
expr_stmt|;
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|out_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|igmp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|int
name|iphlen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|igmplen
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|int
name|queryver
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: called w/mbuf (%p,%d)"
argument_list|,
name|__func__
argument_list|,
operator|*
name|mp
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_total
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|iphlen
operator|=
operator|*
name|offp
expr_stmt|;
name|igmplen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|iphlen
expr_stmt|;
comment|/* 	 * Validate lengths. 	 */
if|if
condition|(
name|igmplen
operator|<
name|IGMP_MINLEN
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_tooshort
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * Always pullup to the minimum size for v1/v2 or v3 	 * to amortize calls to m_pullup(). 	 */
name|minlen
operator|=
name|iphlen
expr_stmt|;
if|if
condition|(
name|igmplen
operator|>=
name|IGMP_V3_QUERY_MINLEN
condition|)
name|minlen
operator|+=
name|IGMP_V3_QUERY_MINLEN
expr_stmt|;
else|else
name|minlen
operator|+=
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|||
name|m
operator|->
name|m_len
operator|<
name|minlen
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|minlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_tooshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Validate checksum. 	 */
name|m
operator|->
name|m_data
operator|+=
name|iphlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|iphlen
expr_stmt|;
name|igmp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|igmp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_cksum
argument_list|(
name|m
argument_list|,
name|igmplen
argument_list|)
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badsum
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|m
operator|->
name|m_data
operator|-=
name|iphlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|iphlen
expr_stmt|;
comment|/* 	 * IGMP control traffic is link-scope, and must have a TTL of 1. 	 * DVMRP traffic (e.g. mrinfo, mtrace) is an exception; 	 * probe packets may come from beyond the LAN. 	 */
if|if
condition|(
name|igmp
operator|->
name|igmp_type
operator|!=
name|IGMP_DVMRP
operator|&&
name|ip
operator|->
name|ip_ttl
operator|!=
literal|1
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_badttl
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_HOST_MEMBERSHIP_QUERY
case|:
if|if
condition|(
name|igmplen
operator|==
name|IGMP_MINLEN
condition|)
block|{
if|if
condition|(
name|igmp
operator|->
name|igmp_code
operator|==
literal|0
condition|)
name|queryver
operator|=
name|IGMP_VERSION_1
expr_stmt|;
else|else
name|queryver
operator|=
name|IGMP_VERSION_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|igmplen
operator|>=
name|IGMP_V3_QUERY_MINLEN
condition|)
block|{
name|queryver
operator|=
name|IGMP_VERSION_3
expr_stmt|;
block|}
else|else
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_tooshort
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
switch|switch
condition|(
name|queryver
condition|)
block|{
case|case
name|IGMP_VERSION_1
case|:
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_v1v2_queries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|V_igmp_v1enable
condition|)
break|break;
if|if
condition|(
name|igmp_input_v1_query
argument_list|(
name|ifp
argument_list|,
name|ip
argument_list|,
name|igmp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
break|break;
case|case
name|IGMP_VERSION_2
case|:
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_v1v2_queries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|V_igmp_v2enable
condition|)
break|break;
if|if
condition|(
name|igmp_input_v2_query
argument_list|(
name|ifp
argument_list|,
name|ip
argument_list|,
name|igmp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
break|break;
case|case
name|IGMP_VERSION_3
case|:
block|{
name|struct
name|igmpv3
modifier|*
name|igmpv3
decl_stmt|;
name|uint16_t
name|igmpv3len
decl_stmt|;
name|uint16_t
name|srclen
decl_stmt|;
name|int
name|nsrc
decl_stmt|;
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_v3_queries
argument_list|)
expr_stmt|;
name|igmpv3
operator|=
operator|(
expr|struct
name|igmpv3
operator|*
operator|)
name|igmp
expr_stmt|;
comment|/* 				 * Validate length based on source count. 				 */
name|nsrc
operator|=
name|ntohs
argument_list|(
name|igmpv3
operator|->
name|igmp_numsrc
argument_list|)
expr_stmt|;
name|srclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|*
name|nsrc
expr_stmt|;
if|if
condition|(
name|nsrc
operator|*
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
operator|>
name|srclen
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_tooshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 				 * m_pullup() may modify m, so pullup in 				 * this scope. 				 */
name|igmpv3len
operator|=
name|iphlen
operator|+
name|IGMP_V3_QUERY_MINLEN
operator|+
name|srclen
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|||
name|m
operator|->
name|m_len
operator|<
name|igmpv3len
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|igmpv3len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_tooshort
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|igmpv3
operator|=
operator|(
expr|struct
name|igmpv3
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|iphlen
operator|)
expr_stmt|;
if|if
condition|(
name|igmp_input_v3_query
argument_list|(
name|ifp
argument_list|,
name|ip
argument_list|,
name|igmpv3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
break|break;
block|}
break|break;
case|case
name|IGMP_v1_HOST_MEMBERSHIP_REPORT
case|:
if|if
condition|(
operator|!
name|V_igmp_v1enable
condition|)
break|break;
if|if
condition|(
name|igmp_input_v1_report
argument_list|(
name|ifp
argument_list|,
name|ip
argument_list|,
name|igmp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
break|break;
case|case
name|IGMP_v2_HOST_MEMBERSHIP_REPORT
case|:
if|if
condition|(
operator|!
name|V_igmp_v2enable
condition|)
break|break;
if|if
condition|(
operator|!
name|ip_checkrouteralert
argument_list|(
name|m
argument_list|)
condition|)
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_nora
argument_list|)
expr_stmt|;
if|if
condition|(
name|igmp_input_v2_report
argument_list|(
name|ifp
argument_list|,
name|ip
argument_list|,
name|igmp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
break|break;
case|case
name|IGMP_v3_HOST_MEMBERSHIP_REPORT
case|:
comment|/* 		 * Hosts do not need to process IGMPv3 membership reports, 		 * as report suppression is no longer required. 		 */
if|if
condition|(
operator|!
name|ip_checkrouteralert
argument_list|(
name|m
argument_list|)
condition|)
name|IGMPSTAT_INC
argument_list|(
name|igps_rcv_nora
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Pass all valid IGMP packets up to any process(es) listening on a 	 * raw IGMP socket. 	 */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|rip_input
argument_list|(
name|mp
argument_list|,
name|offp
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout handler (global).  * VIMAGE: Timeout handlers are expected to service all vimages.  */
end_comment

begin_function
name|void
name|igmp_fasttimo
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|igmp_fasttimo_vnet
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout handler (per-vnet).  * Sends are shuffled off to a netisr to deal with Giant.  *  * VIMAGE: Assume caller has set up our curvnet.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_fasttimo_vnet
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifqueue
name|scq
decl_stmt|;
comment|/* State-change packets */
name|struct
name|ifqueue
name|qrq
decl_stmt|;
comment|/* Query response packets */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|loop
decl_stmt|,
name|uri_fasthz
decl_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
name|uri_fasthz
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Quick check to see if any work needs to be done, in order to 	 * minimize the overhead of fasttimo processing. 	 * SMPng: XXX Unlocked reads. 	 */
if|if
condition|(
operator|!
name|V_current_state_timers_running
operator|&&
operator|!
name|V_interface_timers_running
operator|&&
operator|!
name|V_state_change_timers_running
condition|)
return|return;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * IGMPv3 General Query response timer processing. 	 */
if|if
condition|(
name|V_interface_timers_running
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: interface timers running"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|V_interface_timers_running
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|igi
argument_list|,
argument|&V_igi_head
argument_list|,
argument|igi_link
argument_list|)
block|{
if|if
condition|(
name|igi
operator|->
name|igi_v3_timer
operator|==
literal|0
condition|)
block|{
comment|/* Do nothing. */
block|}
elseif|else
if|if
condition|(
operator|--
name|igi
operator|->
name|igi_v3_timer
operator|==
literal|0
condition|)
block|{
name|igmp_v3_dispatch_general_query
argument_list|(
name|igi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|V_interface_timers_running
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|V_current_state_timers_running
operator|&&
operator|!
name|V_state_change_timers_running
condition|)
goto|goto
name|out_locked
goto|;
name|V_current_state_timers_running
operator|=
literal|0
expr_stmt|;
name|V_state_change_timers_running
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: state change timers running"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * IGMPv1/v2/v3 host report and state-change timer processing. 	 * Note: Processing a v3 group timer may remove a node. 	 */
name|LIST_FOREACH
argument_list|(
argument|igi
argument_list|,
argument|&V_igi_head
argument_list|,
argument|igi_link
argument_list|)
block|{
name|ifp
operator|=
name|igi
operator|->
name|igi_ifp
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
name|loop
operator|=
operator|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|uri_fasthz
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|igi
operator|->
name|igi_uri
operator|*
name|PR_FASTHZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|qrq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifqueue
argument_list|)
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|qrq
argument_list|,
name|IGMP_MAX_G_GS_PACKETS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|scq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifqueue
argument_list|)
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|scq
argument_list|,
name|IGMP_MAX_STATE_CHANGE_PACKETS
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
switch|switch
condition|(
name|igi
operator|->
name|igi_version
condition|)
block|{
case|case
name|IGMP_VERSION_1
case|:
case|case
name|IGMP_VERSION_2
case|:
name|igmp_v1v2_process_group_timer
argument_list|(
name|inm
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGMP_VERSION_3
case|:
name|igmp_v3_process_group_timers
argument_list|(
name|igi
argument_list|,
operator|&
name|qrq
argument_list|,
operator|&
name|scq
argument_list|,
name|inm
argument_list|,
name|uri_fasthz
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
name|struct
name|in_multi
modifier|*
name|tinm
decl_stmt|;
name|igmp_dispatch_queue
argument_list|(
operator|&
name|qrq
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|igmp_dispatch_queue
argument_list|(
operator|&
name|scq
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/* 			 * Free the in_multi reference(s) for this 			 * IGMP lifecycle. 			 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&igi->igi_relinmhead
argument_list|,
argument|inm_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update host report group timer for IGMPv1/v2.  * Will update the global pending timer flags.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v1v2_process_group_timer
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|version
parameter_list|)
block|{
name|int
name|report_timer_expired
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_timer
operator|==
literal|0
condition|)
block|{
name|report_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_timer
operator|==
literal|0
condition|)
block|{
name|report_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
if|if
condition|(
name|report_timer_expired
condition|)
block|{
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_IDLE_MEMBER
expr_stmt|;
operator|(
name|void
operator|)
name|igmp_v1v2_queue_report
argument_list|(
name|inm
argument_list|,
operator|(
name|version
operator|==
name|IGMP_VERSION_2
operator|)
condition|?
name|IGMP_v2_HOST_MEMBERSHIP_REPORT
else|:
name|IGMP_v1_HOST_MEMBERSHIP_REPORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update a group's timers for IGMPv3.  * Will update the global pending timer flags.  * Note: Unlocked read from igi.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v3_process_group_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|qrq
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|scq
parameter_list|,
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|uri_fasthz
parameter_list|)
block|{
name|int
name|query_response_timer_expired
decl_stmt|;
name|int
name|state_change_retransmit_timer_expired
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|query_response_timer_expired
operator|=
literal|0
expr_stmt|;
name|state_change_retransmit_timer_expired
operator|=
literal|0
expr_stmt|;
comment|/* 	 * During a transition from v1/v2 compatibility mode back to v3, 	 * a group record in REPORTING state may still have its group 	 * timer active. This is a no-op in this function; it is easier 	 * to deal with it here than to complicate the slow-timeout path. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_timer
operator|==
literal|0
condition|)
block|{
name|query_response_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_timer
operator|==
literal|0
condition|)
block|{
name|query_response_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inm
operator|->
name|inm_sctimer
operator|==
literal|0
condition|)
block|{
name|state_change_retransmit_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_sctimer
operator|==
literal|0
condition|)
block|{
name|state_change_retransmit_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_state_change_timers_running
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are in fasttimo, so be quick about it. */
if|if
condition|(
operator|!
name|state_change_retransmit_timer_expired
operator|&&
operator|!
name|query_response_timer_expired
condition|)
return|return;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
comment|/* 		 * Respond to a previously pending Group-Specific 		 * or Group-and-Source-Specific query by enqueueing 		 * the appropriate Current-State report for 		 * immediate transmission. 		 */
if|if
condition|(
name|query_response_timer_expired
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|igmp_v3_enqueue_group_record
argument_list|(
name|qrq
argument_list|,
name|inm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_SG_QUERY_PENDING_MEMBER
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
comment|/* XXX Clear recorded sources for next time. */
name|inm_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
if|if
condition|(
name|state_change_retransmit_timer_expired
condition|)
block|{
comment|/* 			 * State-change retransmission timer fired. 			 * If there are any further pending retransmissions, 			 * set the global pending state-change flag, and 			 * reset the timer. 			 */
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_scrv
operator|>
literal|0
condition|)
block|{
name|inm
operator|->
name|inm_sctimer
operator|=
name|uri_fasthz
expr_stmt|;
name|V_state_change_timers_running
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Retransmit the previously computed state-change 			 * report. If there are no further pending 			 * retransmissions, the mbuf queue will be consumed. 			 * Update T0 state to T1 as we have now sent 			 * a state-change. 			 */
operator|(
name|void
operator|)
name|igmp_v3_merge_state_changes
argument_list|(
name|inm
argument_list|,
name|scq
argument_list|)
expr_stmt|;
name|inm_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 			 * If we are leaving the group for good, make sure 			 * we release IGMP's reference to it. 			 * This release must be deferred using a SLIST, 			 * as we are called from a loop which traverses 			 * the in_ifmultiaddr TAILQ. 			 */
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_LEAVING_MEMBER
operator|&&
name|inm
operator|->
name|inm_scrv
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_NOT_MEMBER
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Suppress a group's pending response to a group or source/group query.  *  * Do NOT suppress state changes. This leads to IGMPv3 inconsistency.  * Do NOT update ST1/ST0 as this operation merely suppresses  * the currently pending group record.  * Do NOT suppress the response to a general query. It is possible but  * it would require adding another state or flag.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v3_suppress_group_record
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
argument_list|,
operator|(
literal|"%s: not IGMPv3 mode on link"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|!=
name|IGMP_G_QUERY_PENDING_MEMBER
operator|||
name|inm
operator|->
name|inm_state
operator|!=
name|IGMP_SG_QUERY_PENDING_MEMBER
condition|)
return|return;
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_SG_QUERY_PENDING_MEMBER
condition|)
name|inm_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch to a different IGMP version on the given interface,  * as per Section 7.2.1.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_set_version
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|,
specifier|const
name|int
name|version
parameter_list|)
block|{
name|int
name|old_version_timer
decl_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: switching to v%d on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|version
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|IGMP_VERSION_1
operator|||
name|version
operator|==
name|IGMP_VERSION_2
condition|)
block|{
comment|/* 		 * Compute the "Older Version Querier Present" timer as per 		 * Section 8.12. 		 */
name|old_version_timer
operator|=
name|igi
operator|->
name|igi_rv
operator|*
name|igi
operator|->
name|igi_qi
operator|+
name|igi
operator|->
name|igi_qri
expr_stmt|;
name|old_version_timer
operator|*=
name|PR_SLOWHZ
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|IGMP_VERSION_1
condition|)
block|{
name|igi
operator|->
name|igi_v1_timer
operator|=
name|old_version_timer
expr_stmt|;
name|igi
operator|->
name|igi_v2_timer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|==
name|IGMP_VERSION_2
condition|)
block|{
name|igi
operator|->
name|igi_v1_timer
operator|=
literal|0
expr_stmt|;
name|igi
operator|->
name|igi_v2_timer
operator|=
name|old_version_timer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|igi
operator|->
name|igi_v1_timer
operator|==
literal|0
operator|&&
name|igi
operator|->
name|igi_v2_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_2
condition|)
block|{
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_2
expr_stmt|;
name|igmp_v3_cancel_link_timers
argument_list|(
name|igi
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|igi
operator|->
name|igi_v1_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_1
condition|)
block|{
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_1
expr_stmt|;
name|igmp_v3_cancel_link_timers
argument_list|(
name|igi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Cancel pending IGMPv3 timers for the given link and all groups  * joined on it; state-change, general-query, and group-query timers.  *  * Only ever called on a transition from v3 to Compatibility mode. Kill  * the timers stone dead (this may be expensive for large N groups), they  * will be restarted if Compatibility Mode deems that they must be due to  * query processing.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v3_cancel_link_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|,
modifier|*
name|tinm
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: cancel v3 timers on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * Stop the v3 General Query Response on this link stone dead. 	 * If fasttimo is woken up due to V_interface_timers_running, 	 * the flag will be cleared if there are no pending link timers. 	 */
name|igi
operator|->
name|igi_v3_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now clear the current-state and state-change report timers 	 * for all memberships scoped to this link. 	 */
name|ifp
operator|=
name|igi
operator|->
name|igi_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
comment|/* 			 * These states are either not relevant in v3 mode, 			 * or are unreported. Do nothing. 			 */
break|break;
case|case
name|IGMP_LEAVING_MEMBER
case|:
comment|/* 			 * If we are leaving the group and switching to 			 * compatibility mode, we need to release the final 			 * reference held for issuing the INCLUDE {}, and 			 * transition to REPORTING to ensure the host leave 			 * message is sent upstream to the old querier -- 			 * transition to NOT would lose the leave and race. 			 */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
name|inm_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IGMP_REPORTING_MEMBER
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
break|break;
block|}
comment|/* 		 * Always clear state-change and group report timers. 		 * Free any pending IGMPv3 state-change records. 		 */
name|inm
operator|->
name|inm_sctimer
operator|=
literal|0
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&igi->igi_relinmhead
argument_list|,
argument|inm_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|igi
operator|->
name|igi_relinmhead
argument_list|,
name|inm_nrele
argument_list|)
expr_stmt|;
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the Older Version Querier Present timers for a link.  * See Section 7.2.1 of RFC 3376.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v1v2_process_querier_timers
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_v1_timer
operator|==
literal|0
operator|&&
name|igi
operator|->
name|igi_v2_timer
operator|==
literal|0
condition|)
block|{
comment|/* 		 * IGMPv1 and IGMPv2 Querier Present timers expired. 		 * 		 * Revert to IGMPv3. 		 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_3
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition from v%d -> v%d on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|,
name|IGMP_VERSION_3
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|igi
operator|->
name|igi_v1_timer
operator|==
literal|0
operator|&&
name|igi
operator|->
name|igi_v2_timer
operator|>
literal|0
condition|)
block|{
comment|/* 		 * IGMPv1 Querier Present timer expired, 		 * IGMPv2 Querier Present timer running. 		 * If IGMPv2 was disabled since last timeout, 		 * revert to IGMPv3. 		 * If IGMPv2 is enabled, revert to IGMPv2. 		 */
if|if
condition|(
operator|!
name|V_igmp_v2enable
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition from v%d -> v%d on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|,
name|IGMP_VERSION_3
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_v2_timer
operator|=
literal|0
expr_stmt|;
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_3
expr_stmt|;
block|}
else|else
block|{
operator|--
name|igi
operator|->
name|igi_v2_timer
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_2
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition from v%d -> v%d on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|,
name|IGMP_VERSION_2
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_2
expr_stmt|;
name|igmp_v3_cancel_link_timers
argument_list|(
name|igi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|igi
operator|->
name|igi_v1_timer
operator|>
literal|0
condition|)
block|{
comment|/* 		 * IGMPv1 Querier Present timer running. 		 * Stop IGMPv2 timer if running. 		 * 		 * If IGMPv1 was disabled since last timeout, 		 * revert to IGMPv3. 		 * If IGMPv1 is enabled, reset IGMPv2 timer if running. 		 */
if|if
condition|(
operator|!
name|V_igmp_v1enable
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition from v%d -> v%d on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_version
argument_list|,
name|IGMP_VERSION_3
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_v1_timer
operator|=
literal|0
expr_stmt|;
name|igi
operator|->
name|igi_version
operator|=
name|IGMP_VERSION_3
expr_stmt|;
block|}
else|else
block|{
operator|--
name|igi
operator|->
name|igi_v1_timer
expr_stmt|;
block|}
if|if
condition|(
name|igi
operator|->
name|igi_v2_timer
operator|>
literal|0
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: cancel v2 timer on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|igi
operator|->
name|igi_ifp
argument_list|,
name|igi
operator|->
name|igi_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|igi
operator|->
name|igi_v2_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Global slowtimo handler.  * VIMAGE: Timeout handlers are expected to service all vimages.  */
end_comment

begin_function
name|void
name|igmp_slowtimo
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|igmp_slowtimo_vnet
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Per-vnet slowtimo handler.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_slowtimo_vnet
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|igi
argument_list|,
argument|&V_igi_head
argument_list|,
argument|igi_link
argument_list|)
block|{
name|igmp_v1v2_process_querier_timers
argument_list|(
name|igi
argument_list|)
expr_stmt|;
block|}
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch an IGMPv1/v2 host report or leave message.  * These are always small enough to fit inside a single mbuf.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_v1v2_queue_report
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|type
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifp
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|igmp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|igmp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp
argument_list|)
expr_stmt|;
name|igmp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|igmp
operator|*
argument_list|)
expr_stmt|;
name|igmp
operator|->
name|igmp_type
operator|=
name|type
expr_stmt|;
name|igmp
operator|->
name|igmp_code
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|igmp_group
operator|=
name|inm
operator|->
name|inm_addr
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|igmp
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_IGMP
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IGMP_HOST_LEAVE_MESSAGE
condition|)
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLRTRS_GROUP
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ip_dst
operator|=
name|inm
operator|->
name|inm_addr
expr_stmt|;
name|igmp_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_IGMPV2
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_IGMP_LOOP
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: netisr_dispatch(NETISR_IGMP, %p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|netisr_dispatch
argument_list|(
name|NETISR_IGMP
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a state change from the upper layer for the given IPv4 group.  *  * Each socket holds a reference on the in_multi in its own ip_moptions.  * The socket layer will have made the necessary updates to.the group  * state, it is now up to IGMP to issue a state change report if there  * has been any change between T0 (when the last state-change was issued)  * and T1 (now).  *  * We use the IGMPv3 state machine at group level. The IGMP module  * however makes the decision as to which IGMP protocol version to speak.  * A state change *from* INCLUDE {} always means an initial join.  * A state change *to* INCLUDE {} always means a final leave.  *  * FUTURE: If IGIF_V3LITE is enabled for this interface, then we can  * save ourselves a bunch of work; any exclusive mode groups need not  * compute source filter lists.  *  * VIMAGE: curvnet should have been set by caller, as this routine  * is called from the socket option handlers.  */
end_comment

begin_function
name|int
name|igmp_change_state
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|igmp_ifinfo
modifier|*
name|igi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Try to detect if the upper layer just asked us to change state 	 * for an interface which has now gone away. 	 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifma
operator|->
name|ifma_ifp
expr_stmt|;
comment|/* 	 * Sanity check that netinet's notion of ifp is the 	 * same as net's. 	 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: bad ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IGMP_LOCK
argument_list|()
expr_stmt|;
name|igi
operator|=
operator|(
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
operator|)
operator|->
name|ii_igmp
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no igmp_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we detect a state transition to or from MCAST_UNDEFINED 	 * for this group, then we are starting or finishing an IGMP 	 * life cycle for this group. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|!=
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: inm transition %d -> %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
argument_list|,
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: initial join"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_initial_join
argument_list|(
name|inm
argument_list|,
name|igi
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
elseif|else
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: final leave"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|igmp_final_leave
argument_list|(
name|inm
argument_list|,
name|igi
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: filter set change"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|igmp_handle_state_change
argument_list|(
name|inm
argument_list|,
name|igi
argument_list|)
expr_stmt|;
name|out_locked
label|:
name|IGMP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the initial join for an IGMP group.  *  * When joining a group:  *  If the group should have its IGMP traffic suppressed, do nothing.  *  IGMPv1 starts sending IGMPv1 host membership reports.  *  IGMPv2 starts sending IGMPv2 host membership reports.  *  IGMPv3 will schedule an IGMPv3 state-change report containing the  *  initial state of the membership.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_initial_join
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|syncstates
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: initial join %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|syncstates
operator|=
literal|1
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifp
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|&&
name|igi
operator|->
name|igi_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Groups joined on loopback or marked as 'not reported', 	 * e.g. 224.0.0.1, enter the IGMP_SILENT_MEMBER state and 	 * are never reported in any IGMP protocol exchanges. 	 * All other groups enter the appropriate IGMP state machine 	 * for the version in use on this link. 	 * A link marked as IGIF_SILENT causes IGMP to be completely 	 * disabled for the link. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
operator|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_SILENT
operator|)
operator|||
operator|!
name|igmp_isgroupreported
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_SILENT_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Deal with overlapping in_multi lifecycle. 		 * If this group was LEAVING, then make sure 		 * we drop the reference we picked up to keep the 		 * group around for the final INCLUDE {} enqueue. 		 */
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
operator|&&
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_LEAVING_MEMBER
condition|)
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
switch|switch
condition|(
name|igi
operator|->
name|igi_version
condition|)
block|{
case|case
name|IGMP_VERSION_1
case|:
case|case
name|IGMP_VERSION_2
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_IDLE_MEMBER
expr_stmt|;
name|error
operator|=
name|igmp_v1v2_queue_report
argument_list|(
name|inm
argument_list|,
operator|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_2
operator|)
condition|?
name|IGMP_v2_HOST_MEMBERSHIP_REPORT
else|:
name|IGMP_v1_HOST_MEMBERSHIP_REPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|inm_timer
operator|=
name|IGMP_RANDOM_DELAY
argument_list|(
name|IGMP_V1V2_MAX_RI
operator|*
name|PR_FASTHZ
argument_list|)
expr_stmt|;
name|V_current_state_timers_running
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IGMP_VERSION_3
case|:
comment|/* 			 * Defer update of T0 to T1, until the first copy 			 * of the state change has been transmitted. 			 */
name|syncstates
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Immediately enqueue a State-Change Report for 			 * this interface, freeing any previous reports. 			 * Don't kick the timers if there is nothing to do, 			 * or if an error occurred. 			 */
name|ifq
operator|=
operator|&
name|inm
operator|->
name|inm_scq
expr_stmt|;
name|_IF_DRAIN
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|retval
operator|=
name|igmp_v3_enqueue_group_record
argument_list|(
name|ifq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|retval
operator|*
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * Schedule transmission of pending state-change 			 * report up to RV times for this link. The timer 			 * will fire at the next igmp_fasttimo (~200ms), 			 * giving us an opportunity to merge the reports. 			 */
if|if
condition|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
block|{
name|inm
operator|->
name|inm_scrv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|igi
operator|->
name|igi_rv
operator|>
literal|1
argument_list|,
operator|(
literal|"%s: invalid robustness %d"
operator|,
name|__func__
operator|,
name|igi
operator|->
name|igi_rv
operator|)
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_scrv
operator|=
name|igi
operator|->
name|igi_rv
expr_stmt|;
block|}
name|inm
operator|->
name|inm_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running
operator|=
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Only update the T0 state if state change is atomic, 	 * i.e. we don't need to wait for a timer to fire before we 	 * can consider the state change to have been communicated. 	 */
if|if
condition|(
name|syncstates
condition|)
block|{
name|inm_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue an intermediate state change during the IGMP life-cycle.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_handle_state_change
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: state change for %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifp
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|&&
name|igi
operator|->
name|igi_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
operator|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_SILENT
operator|)
operator|||
operator|!
name|igmp_isgroupreported
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
operator|||
operator|(
name|igi
operator|->
name|igi_version
operator|!=
name|IGMP_VERSION_3
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|igmp_isgroupreported
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: nothing to do"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|)
expr_stmt|;
name|retval
operator|=
name|igmp_v3_enqueue_group_record
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
name|retval
operator|)
return|;
comment|/* 	 * If record(s) were enqueued, start the state-change 	 * report timer for this group. 	 */
name|inm
operator|->
name|inm_scrv
operator|=
operator|(
operator|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
operator|)
condition|?
literal|1
else|:
name|igi
operator|->
name|igi_rv
operator|)
expr_stmt|;
name|inm
operator|->
name|inm_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the final leave for an IGMP group.  *  * When leaving a group:  *  IGMPv1 does nothing.  *  IGMPv2 sends a host leave message, if and only if we are the reporter.  *  IGMPv3 enqueues a state-change report containing a transition  *  to INCLUDE {} for immediate transmission.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_final_leave
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|int
name|syncstates
decl_stmt|;
name|syncstates
operator|=
literal|1
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: final leave %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
comment|/* Already leaving or left; do nothing. */
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_2
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_G_QUERY_PENDING_MEMBER
operator|||
name|inm
operator|->
name|inm_state
operator|==
name|IGMP_SG_QUERY_PENDING_MEMBER
condition|)
name|panic
argument_list|(
literal|"%s: IGMPv3 state reached, not IGMPv3 mode"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|igmp_v1v2_queue_report
argument_list|(
name|inm
argument_list|,
name|IGMP_HOST_LEAVE_MESSAGE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_NOT_MEMBER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
condition|)
block|{
comment|/* 			 * Stop group timer and all pending reports. 			 * Immediately enqueue a state-change report 			 * TO_IN {} to be sent on the next fast timeout, 			 * giving us an opportunity to merge reports. 			 */
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
condition|)
block|{
name|inm
operator|->
name|inm_scrv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inm
operator|->
name|inm_scrv
operator|=
name|igi
operator|->
name|igi_rv
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: Leaving %s/%s with %d "
literal|"pending retransmissions."
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|,
name|inm
operator|->
name|inm_scrv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_scrv
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_NOT_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_sctimer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|retval
decl_stmt|;
name|inm_acquire_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|retval
operator|=
name|igmp_v3_enqueue_group_record
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|retval
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: enqueue record = %d"
operator|,
name|__func__
operator|,
name|retval
operator|)
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_LEAVING_MEMBER
expr_stmt|;
name|inm
operator|->
name|inm_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running
operator|=
literal|1
expr_stmt|;
name|syncstates
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
comment|/* Our reports are suppressed; do nothing. */
break|break;
block|}
if|if
condition|(
name|syncstates
condition|)
block|{
name|inm_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: T1 now MCAST_UNDEFINED for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enqueue an IGMPv3 group record to the given output queue.  *  * XXX This function could do with having the allocation code  * split out, and the multiple-tree-walks coalesced into a single  * routine as has been done in igmp_v3_enqueue_filter_change().  *  * If is_state_change is zero, a current-state record is appended.  * If is_state_change is non-zero, a state-change report is appended.  *  * If is_group_query is non-zero, an mbuf packet chain is allocated.  * If is_group_query is zero, and if there is a packet with free space  * at the tail of the queue, it will be appended to providing there  * is enough free space.  * Otherwise a new mbuf packet chain is allocated.  *  * If is_source_query is non-zero, each source is checked to see if  * it was recorded for a Group-Source query, and will be omitted if  * it is not both in-mode and recorded.  *  * The function will attempt to allocate leading space in the packet  * for the IP/IGMP header to be prepended without fragmenting the chain.  *  * If successful the size of all data appended to the queue is returned,  * otherwise an error code less than zero is returned, or zero if  * no record(s) were appended.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_v3_enqueue_group_record
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|is_state_change
parameter_list|,
specifier|const
name|int
name|is_group_query
parameter_list|,
specifier|const
name|int
name|is_source_query
parameter_list|)
block|{
name|struct
name|igmp_grouprec
name|ig
decl_stmt|;
name|struct
name|igmp_grouprec
modifier|*
name|pig
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_filter_list_change
decl_stmt|;
name|int
name|minrec0len
decl_stmt|,
name|m0srcs
decl_stmt|,
name|msrcs
decl_stmt|,
name|nbytes
decl_stmt|,
name|off
decl_stmt|;
name|int
name|record_has_sources
decl_stmt|;
name|int
name|now
decl_stmt|;
name|int
name|type
decl_stmt|;
name|in_addr_t
name|naddr
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifp
expr_stmt|;
name|is_filter_list_change
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|m0srcs
operator|=
literal|0
expr_stmt|;
name|msrcs
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|nims
operator|=
name|NULL
expr_stmt|;
name|record_has_sources
operator|=
literal|1
expr_stmt|;
name|pig
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|IGMP_DO_NOTHING
expr_stmt|;
name|mode
operator|=
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
comment|/* 	 * If we did not transition out of ASM mode during t0->t1, 	 * and there are no source nodes to process, we can skip 	 * the generation of source records. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|inm_nsrc
operator|==
literal|0
condition|)
name|record_has_sources
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_state_change
condition|)
block|{
comment|/* 		 * Queue a state change record. 		 * If the mode did not change, and there are non-ASM 		 * listeners or source filters present, 		 * we potentially need to issue two records for the group. 		 * If we are transitioning to MCAST_UNDEFINED, we need 		 * not send any sources. 		 * If there are ASM listeners, and there was no filter 		 * mode transition of any kind, do nothing. 		 */
if|if
condition|(
name|mode
operator|!=
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: change to EXCLUDE"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|type
operator|=
name|IGMP_CHANGE_TO_EXCLUDE_MODE
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: change to INCLUDE"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|type
operator|=
name|IGMP_CHANGE_TO_INCLUDE_MODE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MCAST_UNDEFINED
condition|)
name|record_has_sources
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|record_has_sources
condition|)
block|{
name|is_filter_list_change
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|IGMP_DO_NOTHING
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Queue a current state record. 		 */
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|type
operator|=
name|IGMP_MODE_IS_EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|type
operator|=
name|IGMP_MODE_IS_INCLUDE
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inm %p is INCLUDE but ASM count is %d"
operator|,
name|__func__
operator|,
name|inm
operator|,
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate the filter list changes using a separate function. 	 */
if|if
condition|(
name|is_filter_list_change
condition|)
return|return
operator|(
name|igmp_v3_enqueue_filter_change
argument_list|(
name|ifq
argument_list|,
name|inm
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|IGMP_DO_NOTHING
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: nothing to do for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If any sources are present, we must be able to fit at least 	 * one in the trailing space of the tail packet's mbuf, 	 * ideally more. 	 */
name|minrec0len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
expr_stmt|;
if|if
condition|(
name|record_has_sources
condition|)
name|minrec0len
operator|+=
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: queueing %s for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|igmp_rec_type_to_str
argument_list|(
name|type
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have a packet in the tail of the queue for this 	 * group into which the first group record for this group will fit. 	 * Otherwise allocate a new packet. 	 * Always allocate leading space for IP+RA_OPT+IGMP+REPORT. 	 * Note: Group records for G/GSR query responses MUST be sent 	 * in their own packet. 	 */
name|m0
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
operator|!
name|is_group_query
operator|&&
name|m0
operator|!=
name|NULL
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
literal|1
operator|<=
name|IGMP_V3_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|minrec0len
operator|)
operator|<
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|)
condition|)
block|{
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: use existing packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: outbound queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|NULL
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_state_change
operator|&&
operator|!
name|is_group_query
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|m_data
operator|+=
name|IGMP_LEADINGSPACE
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|IGMP_LEADINGSPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|igmp_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: allocated first packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Append group record. 	 * If we have sources, we don't know how many yet. 	 */
name|ig
operator|.
name|ig_type
operator|=
name|type
expr_stmt|;
name|ig
operator|.
name|ig_datalen
operator|=
literal|0
expr_stmt|;
name|ig
operator|.
name|ig_numsrc
operator|=
literal|0
expr_stmt|;
name|ig
operator|.
name|ig_group
operator|=
name|inm
operator|->
name|inm_addr
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ig
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
expr_stmt|;
comment|/* 	 * Append as many sources as will fit in the first packet. 	 * If we are appending to a new packet, the chain allocation 	 * may potentially use clusters; use m_getptr() in this case. 	 * If we are appending to an existing packet, we need to obtain 	 * a pointer to the group record after m_append(), in case a new 	 * mbuf was allocated. 	 * Only append sources which are in-mode at t1. If we are 	 * transitioning to MCAST_UNDEFINED state on the group, do not 	 * include source entries. 	 * Only report recorded sources in our filter set when responding 	 * to a group-source query. 	 */
if|if
condition|(
name|record_has_sources
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|m0
condition|)
block|{
name|md
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pig
operator|=
operator|(
expr|struct
name|igmp_grouprec
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|md
operator|->
name|m_len
operator|-
name|nbytes
operator|)
expr_stmt|;
block|}
else|else
block|{
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pig
operator|=
operator|(
expr|struct
name|igmp_grouprec
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
block|}
name|msrcs
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa_haddr
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|ims_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: node is %d"
argument_list|,
name|__func__
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|!=
name|mode
operator|)
operator|||
operator|(
name|now
operator|==
name|mode
operator|&&
name|mode
operator|==
name|MCAST_UNDEFINED
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|ims
operator|->
name|ims_stp
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip unrecorded node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: append node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|naddr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|naddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
operator|++
name|msrcs
expr_stmt|;
if|if
condition|(
name|msrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: msrcs is %d this packet"
argument_list|,
name|__func__
argument_list|,
name|msrcs
argument_list|)
expr_stmt|;
name|pig
operator|->
name|ig_numsrc
operator|=
name|htons
argument_list|(
name|msrcs
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
operator|(
name|msrcs
operator|*
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|msrcs
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: no recorded sources to report"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We are good to go with first packet. 	 */
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueueing first packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|1
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|++
expr_stmt|;
comment|/* 	 * No further work needed if no source list in packet(s). 	 */
if|if
condition|(
operator|!
name|record_has_sources
condition|)
return|return
operator|(
name|nbytes
operator|)
return|;
comment|/* 	 * Whilst sources remain to be announced, we need to allocate 	 * a new packet and fill out as many sources as will fit. 	 * Always try for a cluster first. 	 */
while|while
condition|(
name|nims
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: outbound queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|m_data
operator|+=
name|IGMP_LEADINGSPACE
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|IGMP_LEADINGSPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|igmp_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pig
operator|=
operator|(
expr|struct
name|igmp_grouprec
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: allocated next packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ig
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|1
expr_stmt|;
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
name|msrcs
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa_haddr
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|ims_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|!=
name|mode
operator|)
operator|||
operator|(
name|now
operator|==
name|mode
operator|&&
name|mode
operator|==
name|MCAST_UNDEFINED
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|ims
operator|->
name|ims_stp
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip unrecorded node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: append node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|naddr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|naddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
operator|++
name|msrcs
expr_stmt|;
if|if
condition|(
name|msrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
name|pig
operator|->
name|ig_numsrc
operator|=
name|htons
argument_list|(
name|msrcs
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
operator|(
name|msrcs
operator|*
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueueing next packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Type used to mark record pass completion.  * We exploit the fact we can cast to this easily from the  * current filter modes on each ip_msource node.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|REC_NONE
init|=
literal|0x00
block|,
comment|/* MCAST_UNDEFINED */
name|REC_ALLOW
init|=
literal|0x01
block|,
comment|/* MCAST_INCLUDE */
name|REC_BLOCK
init|=
literal|0x02
block|,
comment|/* MCAST_EXCLUDE */
name|REC_FULL
init|=
name|REC_ALLOW
operator||
name|REC_BLOCK
block|}
name|rectype_t
typedef|;
end_typedef

begin_comment
comment|/*  * Enqueue an IGMPv3 filter list change to the given output queue.  *  * Source list filter state is held in an RB-tree. When the filter list  * for a group is changed without changing its mode, we need to compute  * the deltas between T0 and T1 for each source in the filter set,  * and enqueue the appropriate ALLOW_NEW/BLOCK_OLD records.  *  * As we may potentially queue two record types, and the entire R-B tree  * needs to be walked at once, we break this out into its own function  * so we can generate a tightly packed queue of packets.  *  * XXX This could be written to only use one tree walk, although that makes  * serializing into the mbuf chains a bit harder. For now we do two walks  * which makes things easier on us, and it may or may not be harder on  * the L2 cache.  *  * If successful the size of all data appended to the queue is returned,  * otherwise an error code less than zero is returned, or zero if  * no record(s) were appended.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_v3_enqueue_filter_change
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|MINRECLEN
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|igmp_grouprec
name|ig
decl_stmt|;
name|struct
name|igmp_grouprec
modifier|*
name|pig
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|in_addr_t
name|naddr
decl_stmt|;
name|int
name|m0srcs
decl_stmt|,
name|nbytes
decl_stmt|,
name|npbytes
decl_stmt|,
name|off
decl_stmt|,
name|rsrcs
decl_stmt|,
name|schanged
decl_stmt|;
name|int
name|nallow
decl_stmt|,
name|nblock
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|now
decl_stmt|,
name|then
decl_stmt|;
name|rectype_t
name|crt
decl_stmt|,
name|drt
decl_stmt|,
name|nrt
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_nsrc
operator|==
literal|0
operator|||
operator|(
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifp
expr_stmt|;
comment|/* interface */
name|mode
operator|=
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
comment|/* filter mode at t1 */
name|crt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* current group record type */
name|drt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* mask of completed group record types */
name|nrt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* record type for current node */
name|m0srcs
operator|=
literal|0
expr_stmt|;
comment|/* # source which will fit in current mbuf chain */
name|nbytes
operator|=
literal|0
expr_stmt|;
comment|/* # of bytes appended to group's state-change queue */
name|npbytes
operator|=
literal|0
expr_stmt|;
comment|/* # of bytes appended this packet */
name|rsrcs
operator|=
literal|0
expr_stmt|;
comment|/* # sources encoded in current record */
name|schanged
operator|=
literal|0
expr_stmt|;
comment|/* # nodes encoded in overall filter change */
name|nallow
operator|=
literal|0
expr_stmt|;
comment|/* # of source entries in ALLOW_NEW */
name|nblock
operator|=
literal|0
expr_stmt|;
comment|/* # of source entries in BLOCK_OLD */
name|nims
operator|=
name|NULL
expr_stmt|;
comment|/* next tree node pointer */
comment|/* 	 * For each possible filter record mode. 	 * The first kind of source we encounter tells us which 	 * is the first kind of record we start appending. 	 * If a node transitioned to UNDEFINED at t1, its mode is treated 	 * as the inverse of the group's filter mode. 	 */
while|while
condition|(
name|drt
operator|!=
name|REC_FULL
condition|)
block|{
do|do
block|{
name|m0
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
literal|1
operator|<=
name|IGMP_V3_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|MINRECLEN
operator|)
operator|<
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|)
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: use previous packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|m_data
operator|+=
name|IGMP_LEADINGSPACE
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|IGMP_LEADINGSPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_get*() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|0
expr_stmt|;
name|igmp_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
expr_stmt|;
name|npbytes
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: allocated new packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Append the IGMP group record header to the 			 * current packet's data area. 			 * Recalculate pointer to free space for next 			 * group record, in case m_append() allocated 			 * a new mbuf or cluster. 			 */
name|memset
argument_list|(
operator|&
name|ig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ig
argument_list|)
argument_list|)
expr_stmt|;
name|ig
operator|.
name|ig_group
operator|=
name|inm
operator|->
name|inm_addr
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|ig
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ig
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|npbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
comment|/* new packet; offset in c hain */
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|npbytes
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pig
operator|=
operator|(
expr|struct
name|igmp_grouprec
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* current packet; offset from last append */
name|md
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pig
operator|=
operator|(
expr|struct
name|igmp_grouprec
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|md
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 			 * Begin walking the tree for this record type 			 * pass, or continue from where we left off 			 * previously if we had to allocate a new packet. 			 * Only report deltas in-mode at t1. 			 * We need not report included sources as allowed 			 * if we are in inclusive mode on the group, 			 * however the converse is not true. 			 */
name|rsrcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
name|nims
operator|=
name|RB_MIN
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|)
expr_stmt|;
name|RB_FOREACH_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa_haddr
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|ims_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|then
operator|=
name|ims_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: mode: t0 %d, t1 %d"
argument_list|,
name|__func__
argument_list|,
name|then
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|then
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip unchanged"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
operator|&&
name|now
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip IN src on EX group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nrt
operator|=
operator|(
name|rectype_t
operator|)
name|now
expr_stmt|;
if|if
condition|(
name|nrt
operator|==
name|REC_NONE
condition|)
name|nrt
operator|=
call|(
name|rectype_t
call|)
argument_list|(
operator|~
name|mode
operator|&
name|REC_FULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|schanged
operator|++
operator|==
literal|0
condition|)
block|{
name|crt
operator|=
name|nrt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crt
operator|!=
name|nrt
condition|)
continue|continue;
name|naddr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|naddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_append() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nallow
operator|+=
operator|!
operator|!
operator|(
name|crt
operator|==
name|REC_ALLOW
operator|)
expr_stmt|;
name|nblock
operator|+=
operator|!
operator|!
operator|(
name|crt
operator|==
name|REC_BLOCK
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|rsrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
comment|/* 			 * If we did not append any tree nodes on this 			 * pass, back out of allocations. 			 */
if|if
condition|(
name|rsrcs
operator|==
literal|0
condition|)
block|{
name|npbytes
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_free(m)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: m_adj(m, -ig)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_grouprec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|npbytes
operator|+=
operator|(
name|rsrcs
operator|*
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|crt
operator|==
name|REC_ALLOW
condition|)
name|pig
operator|->
name|ig_type
operator|=
name|IGMP_ALLOW_NEW_SOURCES
expr_stmt|;
elseif|else
if|if
condition|(
name|crt
operator|==
name|REC_BLOCK
condition|)
name|pig
operator|->
name|ig_type
operator|=
name|IGMP_BLOCK_OLD_SOURCES
expr_stmt|;
name|pig
operator|->
name|ig_numsrc
operator|=
name|htons
argument_list|(
name|rsrcs
argument_list|)
expr_stmt|;
comment|/* 			 * Count the new group record, and enqueue this 			 * packet if it wasn't already queued. 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|npbytes
expr_stmt|;
block|}
do|while
condition|(
name|nims
operator|!=
name|NULL
condition|)
do|;
name|drt
operator||=
name|crt
expr_stmt|;
name|crt
operator|=
operator|(
operator|~
name|crt
operator|&
name|REC_FULL
operator|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: queued %d ALLOW_NEW, %d BLOCK_OLD"
argument_list|,
name|__func__
argument_list|,
name|nallow
argument_list|,
name|nblock
argument_list|)
expr_stmt|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|igmp_v3_merge_state_changes
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|ifscq
parameter_list|)
block|{
name|struct
name|ifqueue
modifier|*
name|gq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* pending state-change */
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* copy of pending state-change */
name|struct
name|mbuf
modifier|*
name|mt
decl_stmt|;
comment|/* last state-change in packet */
name|int
name|docopy
decl_stmt|,
name|domerge
decl_stmt|;
name|u_int
name|recslen
decl_stmt|;
name|docopy
operator|=
literal|0
expr_stmt|;
name|domerge
operator|=
literal|0
expr_stmt|;
name|recslen
operator|=
literal|0
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * If there are further pending retransmissions, make a writable 	 * copy of each queued state-change message before merging. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_scrv
operator|>
literal|0
condition|)
name|docopy
operator|=
literal|1
expr_stmt|;
name|gq
operator|=
operator|&
name|inm
operator|->
name|inm_scq
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
if|if
condition|(
name|gq
operator|->
name|ifq_head
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: WARNING: queue for inm %p is empty"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|=
name|gq
operator|->
name|ifq_head
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only merge the report into the current packet if 		 * there is sufficient space to do so; an IGMPv3 report 		 * packet may only contain 65,535 group records. 		 * Always use a simple mbuf chain concatentation to do this, 		 * as large state changes for single groups may have 		 * allocated clusters. 		 */
name|domerge
operator|=
literal|0
expr_stmt|;
name|mt
operator|=
name|ifscq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
name|mt
operator|!=
name|NULL
condition|)
block|{
name|recslen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|<=
name|IGMP_V3_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|mt
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|recslen
operator|<=
operator|(
name|inm
operator|->
name|inm_ifp
operator|->
name|if_mtu
operator|-
name|IGMP_LEADINGSPACE
operator|)
operator|)
condition|)
name|domerge
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|domerge
operator|&&
name|_IF_QFULL
argument_list|(
name|gq
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: outbound queue full, skipping whole packet %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
operator|!
name|docopy
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|docopy
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dequeueing %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|_IF_DEQUEUE
argument_list|(
name|gq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: copying %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|domerge
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: queueing %p to ifscq %p)"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|ifscq
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifscq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|mtl
decl_stmt|;
comment|/* last mbuf of packet mt */
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merging %p with ifscq tail %p)"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|mt
argument_list|)
expr_stmt|;
name|mtl
operator|=
name|m_last
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|mt
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|recslen
expr_stmt|;
name|mt
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+=
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
expr_stmt|;
name|mtl
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Respond to a pending IGMPv3 General Query.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_v3_dispatch_general_query
parameter_list|(
name|struct
name|igmp_ifinfo
modifier|*
name|igi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|loop
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IGMP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|igi
operator|->
name|igi_version
operator|==
name|IGMP_VERSION_3
argument_list|,
operator|(
literal|"%s: called when version %d"
operator|,
name|__func__
operator|,
name|igi
operator|->
name|igi_version
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|igi
operator|->
name|igi_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|==
name|inm
operator|->
name|inm_ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|inm_state
condition|)
block|{
case|case
name|IGMP_NOT_MEMBER
case|:
case|case
name|IGMP_SILENT_MEMBER
case|:
break|break;
case|case
name|IGMP_REPORTING_MEMBER
case|:
case|case
name|IGMP_IDLE_MEMBER
case|:
case|case
name|IGMP_LAZY_MEMBER
case|:
case|case
name|IGMP_SLEEPING_MEMBER
case|:
case|case
name|IGMP_AWAKENING_MEMBER
case|:
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_REPORTING_MEMBER
expr_stmt|;
name|retval
operator|=
name|igmp_v3_enqueue_group_record
argument_list|(
operator|&
name|igi
operator|->
name|igi_gq
argument_list|,
name|inm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGMP_G_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|IGMP_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|loop
operator|=
operator|(
name|igi
operator|->
name|igi_flags
operator|&
name|IGIF_LOOPBACK
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|igmp_dispatch_queue
argument_list|(
operator|&
name|igi
operator|->
name|igi_gq
argument_list|,
name|IGMP_MAX_RESPONSE_BURST
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/* 	 * Slew transmission of bursts over 500ms intervals. 	 */
if|if
condition|(
name|igi
operator|->
name|igi_gq
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|igi
operator|->
name|igi_v3_timer
operator|=
literal|1
operator|+
name|IGMP_RANDOM_DELAY
argument_list|(
name|IGMP_RESPONSE_BURST_INTERVAL
argument_list|)
expr_stmt|;
name|V_interface_timers_running
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit the next pending IGMP message in the output queue.  *  * We get called from netisr_processqueue(). A mutex private to igmpoq  * will be acquired and released around this routine.  *  * VIMAGE: Needs to store/restore vnet pointer on a per-mbuf-chain basis.  * MRT: Nothing needs to be done, as IGMP traffic is always local to  * a link and uses a link-scope multicast address.  */
end_comment

begin_function
specifier|static
name|void
name|igmp_intr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip_moptions
name|imo
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ipopts
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|ifindex
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transmit %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Set VNET image pointer from enqueued mbuf chain 	 * before doing anything else. Whilst we use interface 	 * indexes to guard against interface detach, they are 	 * unique to each VIMAGE and must be retrieved. 	 */
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|ifindex
operator|=
name|igmp_restore_context
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the ifnet still exists. This limits the scope of 	 * any race in the absence of a global ifp lock for low cost 	 * (an array lookup). 	 */
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dropped %p as ifindex %u went away."
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_noroute
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ipopts
operator|=
name|V_igmp_sendra
condition|?
name|m_raopt
else|:
name|NULL
expr_stmt|;
name|imo
operator|.
name|imo_multicast_ttl
operator|=
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_loop
operator|=
operator|(
name|V_ip_mrouter
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* 	 * If the user requested that IGMP traffic be explicitly 	 * redirected to the loopback interface (e.g. they are running a 	 * MANET interface and the routing protocol needs to see the 	 * updates), handle this now. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IGMP_LOOP
condition|)
name|imo
operator|.
name|imo_multicast_ifp
operator|=
name|V_loif
expr_stmt|;
else|else
name|imo
operator|.
name|imo_multicast_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IGMPV2
condition|)
block|{
name|m0
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m0
operator|=
name|igmp_v3_encap_report
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dropped %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_odropped
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|igmp_scrub_context
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m_clrprotoflags
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|V_loif
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_netinet_igmp_send
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ip_output
argument_list|(
name|m0
argument_list|,
name|ipopts
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ip_output(%p) = %d"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|IGMPSTAT_INC
argument_list|(
name|igps_snd_reports
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * We must restore the existing vnet pointer before 	 * continuing as we are run from netisr context. 	 */
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an IGMPv3 report.  *  * The internal mbuf flag M_IGMPV3_HDR is used to indicate that the mbuf  * chain has already had its IP/IGMPv3 header prepended. In this case  * the function will not attempt to prepend; the lengths and checksums  * will however be re-computed.  *  * Returns a pointer to the new mbuf chain head, or NULL if the  * allocation failed.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|igmp_v3_encap_report
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|igmp_report
modifier|*
name|igmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|hdrlen
decl_stmt|,
name|igmpreclen
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
argument_list|,
operator|(
literal|"%s: mbuf chain %p is !M_PKTHDR"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|igmpreclen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_report
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IGMPV3_HDR
condition|)
block|{
name|igmpreclen
operator|-=
name|hdrlen
expr_stmt|;
block|}
else|else
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|->
name|m_flags
operator||=
name|M_IGMPV3_HDR
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: igmpreclen is %d"
argument_list|,
name|__func__
argument_list|,
name|igmpreclen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|igmp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|igmp_report
operator|*
argument_list|)
expr_stmt|;
name|igmp
operator|->
name|ir_type
operator|=
name|IGMP_v3_HOST_MEMBERSHIP_REPORT
expr_stmt|;
name|igmp
operator|->
name|ir_rsv1
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|ir_rsv2
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|ir_numgrps
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
argument_list|)
expr_stmt|;
name|igmp
operator|->
name|ir_cksum
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|ir_cksum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmp_report
argument_list|)
operator|+
name|igmpreclen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|IPTOS_PREC_INTERNETCONTROL
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|hdrlen
operator|+
name|igmpreclen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_IGMP
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IGMP_LOOP
condition|)
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|ip_src
operator|=
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
expr_stmt|;
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLRPTS_GROUP
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|igmp_rec_type_to_str
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IGMP_CHANGE_TO_EXCLUDE_MODE
case|:
return|return
literal|"TO_EX"
return|;
break|break;
case|case
name|IGMP_CHANGE_TO_INCLUDE_MODE
case|:
return|return
literal|"TO_IN"
return|;
break|break;
case|case
name|IGMP_MODE_IS_EXCLUDE
case|:
return|return
literal|"MODE_EX"
return|;
break|break;
case|case
name|IGMP_MODE_IS_INCLUDE
case|:
return|return
literal|"MODE_IN"
return|;
break|break;
case|case
name|IGMP_ALLOW_NEW_SOURCES
case|:
return|return
literal|"ALLOW_NEW"
return|;
break|break;
case|case
name|IGMP_BLOCK_OLD_SOURCES
case|:
return|return
literal|"BLOCK_OLD"
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|igmp_init
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: initializing"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IGMP_LOCK_INIT
argument_list|()
expr_stmt|;
name|m_raopt
operator|=
name|igmp_ra_alloc
argument_list|()
expr_stmt|;
name|netisr_register
argument_list|(
operator|&
name|igmp_nh
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|igmp_init
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|igmp_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|igmp_uninit
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: tearing down"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|netisr_unregister
argument_list|(
operator|&
name|igmp_nh
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m_raopt
argument_list|)
expr_stmt|;
name|m_raopt
operator|=
name|NULL
expr_stmt|;
name|IGMP_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|igmp_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|igmp_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_igmp_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: initializing"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_igi_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|vnet_igmp_init
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_igmp_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_igmp_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: tearing down"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|V_igi_head
argument_list|)
argument_list|,
operator|(
literal|"%s: igi list not empty; ifnets not detached?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|vnet_igmp_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_igmp_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|igmp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
case|case
name|MOD_UNLOAD
case|:
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|igmp_mod
init|=
block|{
literal|"igmp"
block|,
name|igmp_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|igmp
argument_list|,
name|igmp_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

