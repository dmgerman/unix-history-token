begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_cc_functions.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|sctp_set_initial_cc_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * We take the max of the burst limit times a MTU or the 	 * INITIAL_CWND. We then limit this to 4 MTU's of sending. 	 */
name|net
operator|->
name|cwnd
operator|=
name|min
argument_list|(
operator|(
name|net
operator|->
name|mtu
operator|*
literal|4
operator|)
argument_list|,
name|max
argument_list|(
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
argument_list|,
name|SCTP_INITIAL_CWND
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we always get at LEAST 2 MTU's */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|ssthresh
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
operator|(
name|SCTP_CWND_MONITOR_ENABLE
operator||
name|SCTP_CWND_LOGGING_ENABLE
operator|)
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_INITIALIZATION
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_fr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/*- 	 * CMT fast recovery code. Need to debug. ((sctp_cmt_on_off == 1)&& 	 * (net->fast_retran_loss_recovery == 0))) 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|==
literal|0
operator|)
operator|||
operator|(
name|sctp_cmt_on_off
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* out of a RFC2582 Fast recovery window? */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 				 * per section 7.2.3, are there any 				 * destinations that had a fast retransmit 				 * to them. If so what we need to do is 				 * adjust ssthresh and cwnd. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
block|}
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* Turn on fast recovery window */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * CMT fast recovery -- per destination 				 * recovery variable. 				 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * Disable Nonce Sum Checking and store the 				 * resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|fast_recovery_tsn
operator|+
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_32
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Mark a peg that we WOULD have done a cwnd 			 * reduction but RFC2582 prevented this action. 			 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fastretransinrtt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|accum_moved
parameter_list|,
name|int
name|reneged_all
parameter_list|,
name|int
name|will_exit
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/******************************/
comment|/* update cwnd and Early FR   */
comment|/******************************/
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code. Need to debug. 		 */
if|if
condition|(
name|net
operator|->
name|fast_retran_loss_recovery
operator|&&
name|net
operator|->
name|new_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|net
operator|->
name|pseudo_cumack
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|net
operator|->
name|pseudo_cumack
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
condition|)
block|{
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
comment|/* 			 * So, first of all do we need to have a Early FR 			 * timer running? 			 */
if|if
condition|(
operator|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|net
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
operator|)
operator|)
operator|||
operator|(
name|reneged_all
operator|)
condition|)
block|{
comment|/* 				 * yes, so in this case stop it if its 				 * running, and then restart it. Reneging 				 * all is a special case where we want to 				 * run the Early FR timer and then force the 				 * last few unacked to be sent, causing us 				 * to illicit a sack with gaps to force out 				 * the others. 				 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck2
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrid
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, stop it if its running */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck3
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if nothing was acked on this destination skip it */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Karn's rule applies to clearing error count, this 			 * is optional. 			 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RECEIVED_SACK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* now was it the primary? if so restore */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_WAS_PRIMARY
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * JRS 5/14/07 - If CMT PF is on and the destination 			 * is in PF state, set the destination to active 			 * state and set the cwnd to one or two MTU's based 			 * on whether PF1 or PF2 is being used. 			 *  			 * Should we stop any running T3 timer here? 			 */
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_pf
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|==
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
operator|*
name|sctp_cmt_pf
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Destination %p moved from PF to reachable with cwnd %d.\n"
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
argument_list|)
expr_stmt|;
comment|/* 				 * Since the cwnd value is explicitly set, 				 * skip the code that updates the cwnd 				 * value. 				 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code 		 */
comment|/* 		 * if (sctp_cmt_on_off == 1&& 		 * net->fast_retran_loss_recovery&& 		 * net->will_exit_fast_recovery == 0) { @@@ Do something } 		 * else if (sctp_cmt_on_off == 0&& 		 * asoc->fast_retran_loss_recovery&& will_exit == 0) { 		 */
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|will_exit
operator|==
literal|0
operator|&&
name|sctp_cmt_on_off
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we are in loss recovery we skip any cwnd 			 * update 			 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
comment|/* 		 * CMT: CUC algorithm. Update cwnd if pseudo-cumack has 		 * moved. 		 */
if|if
condition|(
name|accum_moved
operator|||
operator|(
name|sctp_cmt_on_off
operator|&&
name|net
operator|->
name|new_pseudo_cumack
operator|)
condition|)
block|{
comment|/* If the cumulative ack moved we can proceed */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|ssthresh
condition|)
block|{
comment|/* We are in slow start */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|+=
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We are in congestion avoidance */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* 					 * add to pba only if we had a 					 * cwnd's worth (or so) in flight OR 					 * the burst limit was applied. 					 */
name|net
operator|->
name|partial_bytes_acked
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
comment|/* 					 * Do we need to increase (if pba is 					 *> cwnd)? 					 */
if|if
condition|(
name|net
operator|->
name|partial_bytes_acked
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|partial_bytes_acked
condition|)
block|{
name|net
operator|->
name|partial_bytes_acked
operator|-=
name|net
operator|->
name|cwnd
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_CA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_NO_CUMACK
argument_list|)
expr_stmt|;
block|}
block|}
name|skip_cwnd_update
label|:
comment|/* 		 * NOW, according to Karn's rule do we need to restore the 		 * RTO timer back? Check our net_ack2. If not set then we 		 * have a ambiguity.. i.e. all data ack'd was sent to more 		 * than one place. 		 */
if|if
condition|(
name|net
operator|->
name|net_ack2
condition|)
block|{
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_timeout
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|<<
literal|1
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
operator|(
name|net
operator|->
name|mtu
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* floor of 1 mtu */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|mtu
condition|)
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
argument_list|,
name|SCTP_CWND_LOG_FROM_RTX
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|sctp_hs_raise_drop
block|{
name|int32_t
name|cwnd
decl_stmt|;
name|int32_t
name|increase
decl_stmt|;
name|int32_t
name|drop_percent
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SCTP_HS_TABLE_SIZE
value|73
end_define

begin_decl_stmt
name|struct
name|sctp_hs_raise_drop
name|sctp_cwnd_adjust
index|[
name|SCTP_HS_TABLE_SIZE
index|]
init|=
block|{
block|{
literal|38
block|,
literal|1
block|,
literal|50
block|}
block|,
comment|/* 0   */
block|{
literal|118
block|,
literal|2
block|,
literal|44
block|}
block|,
comment|/* 1   */
block|{
literal|221
block|,
literal|3
block|,
literal|41
block|}
block|,
comment|/* 2   */
block|{
literal|347
block|,
literal|4
block|,
literal|38
block|}
block|,
comment|/* 3   */
block|{
literal|495
block|,
literal|5
block|,
literal|37
block|}
block|,
comment|/* 4   */
block|{
literal|663
block|,
literal|6
block|,
literal|35
block|}
block|,
comment|/* 5   */
block|{
literal|851
block|,
literal|7
block|,
literal|34
block|}
block|,
comment|/* 6   */
block|{
literal|1058
block|,
literal|8
block|,
literal|33
block|}
block|,
comment|/* 7   */
block|{
literal|1284
block|,
literal|9
block|,
literal|32
block|}
block|,
comment|/* 8   */
block|{
literal|1529
block|,
literal|10
block|,
literal|31
block|}
block|,
comment|/* 9   */
block|{
literal|1793
block|,
literal|11
block|,
literal|30
block|}
block|,
comment|/* 10  */
block|{
literal|2076
block|,
literal|12
block|,
literal|29
block|}
block|,
comment|/* 11  */
block|{
literal|2378
block|,
literal|13
block|,
literal|28
block|}
block|,
comment|/* 12  */
block|{
literal|2699
block|,
literal|14
block|,
literal|28
block|}
block|,
comment|/* 13  */
block|{
literal|3039
block|,
literal|15
block|,
literal|27
block|}
block|,
comment|/* 14  */
block|{
literal|3399
block|,
literal|16
block|,
literal|27
block|}
block|,
comment|/* 15  */
block|{
literal|3778
block|,
literal|17
block|,
literal|26
block|}
block|,
comment|/* 16  */
block|{
literal|4177
block|,
literal|18
block|,
literal|26
block|}
block|,
comment|/* 17  */
block|{
literal|4596
block|,
literal|19
block|,
literal|25
block|}
block|,
comment|/* 18  */
block|{
literal|5036
block|,
literal|20
block|,
literal|25
block|}
block|,
comment|/* 19  */
block|{
literal|5497
block|,
literal|21
block|,
literal|24
block|}
block|,
comment|/* 20  */
block|{
literal|5979
block|,
literal|22
block|,
literal|24
block|}
block|,
comment|/* 21  */
block|{
literal|6483
block|,
literal|23
block|,
literal|23
block|}
block|,
comment|/* 22  */
block|{
literal|7009
block|,
literal|24
block|,
literal|23
block|}
block|,
comment|/* 23  */
block|{
literal|7558
block|,
literal|25
block|,
literal|22
block|}
block|,
comment|/* 24  */
block|{
literal|8130
block|,
literal|26
block|,
literal|22
block|}
block|,
comment|/* 25  */
block|{
literal|8726
block|,
literal|27
block|,
literal|22
block|}
block|,
comment|/* 26  */
block|{
literal|9346
block|,
literal|28
block|,
literal|21
block|}
block|,
comment|/* 27  */
block|{
literal|9991
block|,
literal|29
block|,
literal|21
block|}
block|,
comment|/* 28  */
block|{
literal|10661
block|,
literal|30
block|,
literal|21
block|}
block|,
comment|/* 29  */
block|{
literal|11358
block|,
literal|31
block|,
literal|20
block|}
block|,
comment|/* 30  */
block|{
literal|12082
block|,
literal|32
block|,
literal|20
block|}
block|,
comment|/* 31  */
block|{
literal|12834
block|,
literal|33
block|,
literal|20
block|}
block|,
comment|/* 32  */
block|{
literal|13614
block|,
literal|34
block|,
literal|19
block|}
block|,
comment|/* 33  */
block|{
literal|14424
block|,
literal|35
block|,
literal|19
block|}
block|,
comment|/* 34  */
block|{
literal|15265
block|,
literal|36
block|,
literal|19
block|}
block|,
comment|/* 35  */
block|{
literal|16137
block|,
literal|37
block|,
literal|19
block|}
block|,
comment|/* 36  */
block|{
literal|17042
block|,
literal|38
block|,
literal|18
block|}
block|,
comment|/* 37  */
block|{
literal|17981
block|,
literal|39
block|,
literal|18
block|}
block|,
comment|/* 38  */
block|{
literal|18955
block|,
literal|40
block|,
literal|18
block|}
block|,
comment|/* 39  */
block|{
literal|19965
block|,
literal|41
block|,
literal|17
block|}
block|,
comment|/* 40  */
block|{
literal|21013
block|,
literal|42
block|,
literal|17
block|}
block|,
comment|/* 41  */
block|{
literal|22101
block|,
literal|43
block|,
literal|17
block|}
block|,
comment|/* 42  */
block|{
literal|23230
block|,
literal|44
block|,
literal|17
block|}
block|,
comment|/* 43  */
block|{
literal|24402
block|,
literal|45
block|,
literal|16
block|}
block|,
comment|/* 44  */
block|{
literal|25618
block|,
literal|46
block|,
literal|16
block|}
block|,
comment|/* 45  */
block|{
literal|26881
block|,
literal|47
block|,
literal|16
block|}
block|,
comment|/* 46  */
block|{
literal|28193
block|,
literal|48
block|,
literal|16
block|}
block|,
comment|/* 47  */
block|{
literal|29557
block|,
literal|49
block|,
literal|15
block|}
block|,
comment|/* 48  */
block|{
literal|30975
block|,
literal|50
block|,
literal|15
block|}
block|,
comment|/* 49  */
block|{
literal|32450
block|,
literal|51
block|,
literal|15
block|}
block|,
comment|/* 50  */
block|{
literal|33986
block|,
literal|52
block|,
literal|15
block|}
block|,
comment|/* 51  */
block|{
literal|35586
block|,
literal|53
block|,
literal|14
block|}
block|,
comment|/* 52  */
block|{
literal|37253
block|,
literal|54
block|,
literal|14
block|}
block|,
comment|/* 53  */
block|{
literal|38992
block|,
literal|55
block|,
literal|14
block|}
block|,
comment|/* 54  */
block|{
literal|40808
block|,
literal|56
block|,
literal|14
block|}
block|,
comment|/* 55  */
block|{
literal|42707
block|,
literal|57
block|,
literal|13
block|}
block|,
comment|/* 56  */
block|{
literal|44694
block|,
literal|58
block|,
literal|13
block|}
block|,
comment|/* 57  */
block|{
literal|46776
block|,
literal|59
block|,
literal|13
block|}
block|,
comment|/* 58  */
block|{
literal|48961
block|,
literal|60
block|,
literal|13
block|}
block|,
comment|/* 59  */
block|{
literal|51258
block|,
literal|61
block|,
literal|13
block|}
block|,
comment|/* 60  */
block|{
literal|53677
block|,
literal|62
block|,
literal|12
block|}
block|,
comment|/* 61  */
block|{
literal|56230
block|,
literal|63
block|,
literal|12
block|}
block|,
comment|/* 62  */
block|{
literal|58932
block|,
literal|64
block|,
literal|12
block|}
block|,
comment|/* 63  */
block|{
literal|61799
block|,
literal|65
block|,
literal|12
block|}
block|,
comment|/* 64  */
block|{
literal|64851
block|,
literal|66
block|,
literal|11
block|}
block|,
comment|/* 65  */
block|{
literal|68113
block|,
literal|67
block|,
literal|11
block|}
block|,
comment|/* 66  */
block|{
literal|71617
block|,
literal|68
block|,
literal|11
block|}
block|,
comment|/* 67  */
block|{
literal|75401
block|,
literal|69
block|,
literal|10
block|}
block|,
comment|/* 68  */
block|{
literal|79517
block|,
literal|70
block|,
literal|10
block|}
block|,
comment|/* 69  */
block|{
literal|84035
block|,
literal|71
block|,
literal|10
block|}
block|,
comment|/* 70  */
block|{
literal|89053
block|,
literal|72
block|,
literal|10
block|}
block|,
comment|/* 71  */
block|{
literal|94717
block|,
literal|73
block|,
literal|9
block|}
comment|/* 72  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_hs_cwnd_increase
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|cur_val
decl_stmt|,
name|i
decl_stmt|,
name|indx
decl_stmt|,
name|incr
decl_stmt|;
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
name|indx
operator|=
name|SCTP_HS_TABLE_SIZE
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"HS CC CAlled.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* normal mode */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|net
operator|->
name|last_hs_used
init|;
name|i
operator|<
name|SCTP_HS_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
name|i
index|]
operator|.
name|cwnd
condition|)
block|{
name|indx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|net
operator|->
name|last_hs_used
operator|=
name|indx
expr_stmt|;
name|incr
operator|=
operator|(
operator|(
name|sctp_cwnd_adjust
index|[
name|indx
index|]
operator|.
name|increase
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|+=
name|incr
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|incr
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hs_cwnd_decrease
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|cur_val
decl_stmt|,
name|i
decl_stmt|,
name|indx
decl_stmt|;
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
name|indx
operator|=
name|net
operator|->
name|last_hs_used
expr_stmt|;
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* normal mode */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
block|}
else|else
block|{
comment|/* drop by the proper amount */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|net
operator|->
name|cwnd
operator|/
literal|100
operator|)
operator|*
name|sctp_cwnd_adjust
index|[
name|net
operator|->
name|last_hs_used
index|]
operator|.
name|drop_percent
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
comment|/* now where are we */
name|indx
operator|=
name|net
operator|->
name|last_hs_used
expr_stmt|;
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
comment|/* reset where we are in the table */
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* feel out of hs */
name|net
operator|->
name|last_hs_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|indx
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|cur_val
operator|>
name|sctp_cwnd_adjust
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cwnd
condition|)
block|{
break|break;
block|}
block|}
name|net
operator|->
name|last_hs_used
operator|=
name|indx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_hs_cwnd_update_after_fr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 	 * CMT fast recovery code. Need to debug. ((sctp_cmt_on_off == 1)&& 	 * (net->fast_retran_loss_recovery == 0))) 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|==
literal|0
operator|)
operator|||
operator|(
name|sctp_cmt_on_off
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* out of a RFC2582 Fast recovery window? */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 				 * per section 7.2.3, are there any 				 * destinations that had a fast retransmit 				 * to them. If so what we need to do is 				 * adjust ssthresh and cwnd. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|sctp_hs_cwnd_decrease
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* Turn on fast recovery window */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * CMT fast recovery -- per destination 				 * recovery variable. 				 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * Disable Nonce Sum Checking and store the 				 * resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|fast_recovery_tsn
operator|+
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_32
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Mark a peg that we WOULD have done a cwnd 			 * reduction but RFC2582 prevented this action. 			 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fastretransinrtt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_hs_cwnd_update_after_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|accum_moved
parameter_list|,
name|int
name|reneged_all
parameter_list|,
name|int
name|will_exit
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/******************************/
comment|/* update cwnd and Early FR   */
comment|/******************************/
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code. Need to debug. 		 */
if|if
condition|(
name|net
operator|->
name|fast_retran_loss_recovery
operator|&&
name|net
operator|->
name|new_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|net
operator|->
name|pseudo_cumack
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|net
operator|->
name|pseudo_cumack
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
condition|)
block|{
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
comment|/* 			 * So, first of all do we need to have a Early FR 			 * timer running? 			 */
if|if
condition|(
operator|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|net
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
operator|)
operator|)
operator|||
operator|(
name|reneged_all
operator|)
condition|)
block|{
comment|/* 				 * yes, so in this case stop it if its 				 * running, and then restart it. Reneging 				 * all is a special case where we want to 				 * run the Early FR timer and then force the 				 * last few unacked to be sent, causing us 				 * to illicit a sack with gaps to force out 				 * the others. 				 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck2
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrid
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, stop it if its running */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck3
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if nothing was acked on this destination skip it */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Karn's rule applies to clearing error count, this 			 * is optional. 			 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RECEIVED_SACK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* now was it the primary? if so restore */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_WAS_PRIMARY
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * JRS 5/14/07 - If CMT PF is on and the destination 			 * is in PF state, set the destination to active 			 * state and set the cwnd to one or two MTU's based 			 * on whether PF1 or PF2 is being used. 			 *  			 * Should we stop any running T3 timer here? 			 */
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_pf
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|==
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
operator|*
name|sctp_cmt_pf
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Destination %p moved from PF to reachable with cwnd %d.\n"
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
argument_list|)
expr_stmt|;
comment|/* 				 * Since the cwnd value is explicitly set, 				 * skip the code that updates the cwnd 				 * value. 				 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code 		 */
comment|/* 		 * if (sctp_cmt_on_off == 1&& 		 * net->fast_retran_loss_recovery&& 		 * net->will_exit_fast_recovery == 0) { @@@ Do something } 		 * else if (sctp_cmt_on_off == 0&& 		 * asoc->fast_retran_loss_recovery&& will_exit == 0) { 		 */
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|will_exit
operator|==
literal|0
operator|&&
name|sctp_cmt_on_off
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we are in loss recovery we skip any cwnd 			 * update 			 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
comment|/* 		 * CMT: CUC algorithm. Update cwnd if pseudo-cumack has 		 * moved. 		 */
if|if
condition|(
name|accum_moved
operator|||
operator|(
name|sctp_cmt_on_off
operator|&&
name|net
operator|->
name|new_pseudo_cumack
operator|)
condition|)
block|{
comment|/* If the cumulative ack moved we can proceed */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|ssthresh
condition|)
block|{
comment|/* We are in slow start */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
name|sctp_hs_cwnd_increase
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We are in congestion avoidance */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* 					 * add to pba only if we had a 					 * cwnd's worth (or so) in flight OR 					 * the burst limit was applied. 					 */
name|net
operator|->
name|partial_bytes_acked
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
comment|/* 					 * Do we need to increase (if pba is 					 *> cwnd)? 					 */
if|if
condition|(
name|net
operator|->
name|partial_bytes_acked
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|partial_bytes_acked
condition|)
block|{
name|net
operator|->
name|partial_bytes_acked
operator|-=
name|net
operator|->
name|cwnd
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_CA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_NO_CUMACK
argument_list|)
expr_stmt|;
block|}
block|}
name|skip_cwnd_update
label|:
comment|/* 		 * NOW, according to Karn's rule do we need to restore the 		 * RTO timer back? Check our net_ack2. If not set then we 		 * have a ambiguity.. i.e. all data ack'd was sent to more 		 * than one place. 		 */
if|if
condition|(
name|net
operator|->
name|net_ack2
condition|)
block|{
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_ecn_echo
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ecnereducedcwnd
argument_list|)
expr_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* here back off the timer as well, to slow us down */
name|net
operator|->
name|RTO
operator|<<=
literal|1
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_SAT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_packet_dropped
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_pktdrop_chunk
modifier|*
name|cp
parameter_list|,
name|uint32_t
modifier|*
name|bottle_bw
parameter_list|,
name|uint32_t
modifier|*
name|on_queue
parameter_list|)
block|{
name|uint32_t
name|bw_avail
decl_stmt|;
name|int
name|rtt
decl_stmt|,
name|incr
decl_stmt|;
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
comment|/* need real RTT for this calc */
name|rtt
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* get bottle neck bw */
operator|*
name|bottle_bw
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|bottle_bw
argument_list|)
expr_stmt|;
comment|/* and whats on queue */
operator|*
name|on_queue
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|current_onq
argument_list|)
expr_stmt|;
comment|/* 	 * adjust the on-queue if our flight is more it could be that the 	 * router has not yet gotten data "in-flight" to it 	 */
if|if
condition|(
operator|*
name|on_queue
operator|<
name|net
operator|->
name|flight_size
condition|)
operator|*
name|on_queue
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
comment|/* calculate the available space */
name|bw_avail
operator|=
operator|(
operator|*
name|bottle_bw
operator|*
name|rtt
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|bw_avail
operator|>
operator|*
name|bottle_bw
condition|)
block|{
comment|/* 		 * Cap the growth to no more than the bottle neck. This can 		 * happen as RTT slides up due to queues. It also means if 		 * you have more than a 1 second RTT with a empty queue you 		 * will be limited to the bottle_bw per second no matter if 		 * other points have 1/2 the RTT and you could get more 		 * out... 		 */
name|bw_avail
operator|=
operator|*
name|bottle_bw
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|on_queue
operator|>
name|bw_avail
condition|)
block|{
comment|/* 		 * No room for anything else don't allow anything else to be 		 * "added to the fire". 		 */
name|int
name|seg_inflight
decl_stmt|,
name|seg_onqueue
decl_stmt|,
name|my_portion
decl_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* how much are we over queue size? */
name|incr
operator|=
operator|*
name|on_queue
operator|-
name|bw_avail
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
condition|)
block|{
comment|/* 			 * undo any cwnd adjustment that the sack might have 			 * made 			 */
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|prev_cwnd
expr_stmt|;
block|}
comment|/* Now how much of that is mine? */
name|seg_inflight
operator|=
name|net
operator|->
name|flight_size
operator|/
name|net
operator|->
name|mtu
expr_stmt|;
name|seg_onqueue
operator|=
operator|*
name|on_queue
operator|/
name|net
operator|->
name|mtu
expr_stmt|;
name|my_portion
operator|=
operator|(
name|incr
operator|*
name|seg_inflight
operator|)
operator|/
name|seg_onqueue
expr_stmt|;
comment|/* Have I made an adjustment already */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|net
operator|->
name|flight_size
condition|)
block|{
comment|/* 			 * for this flight I made an adjustment we need to 			 * decrease the portion by a share our previous 			 * adjustment. 			 */
name|int
name|diff_adj
decl_stmt|;
name|diff_adj
operator|=
name|net
operator|->
name|cwnd
operator|-
name|net
operator|->
name|flight_size
expr_stmt|;
if|if
condition|(
name|diff_adj
operator|>
name|my_portion
condition|)
name|my_portion
operator|=
literal|0
expr_stmt|;
else|else
name|my_portion
operator|-=
name|diff_adj
expr_stmt|;
block|}
comment|/* 		 * back down to the previous cwnd (assume we have had a sack 		 * before this packet). minus what ever portion of the 		 * overage is my fault. 		 */
name|net
operator|->
name|cwnd
operator|-=
name|my_portion
expr_stmt|;
comment|/* we will NOT back down more than 1 MTU */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
comment|/* force into CA */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Take 1/4 of the space left or max burst up .. whichever 		 * is less. 		 */
name|incr
operator|=
name|min
argument_list|(
operator|(
name|bw_avail
operator|-
operator|*
name|on_queue
operator|)
operator|>>
literal|2
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_burst
operator|*
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|+=
name|incr
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|bw_avail
condition|)
block|{
comment|/* We can't exceed the pipe size */
name|net
operator|->
name|cwnd
operator|=
name|bw_avail
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|mtu
condition|)
block|{
comment|/* We always have 1 MTU */
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|!=
literal|0
condition|)
block|{
comment|/* log only changes */
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_SAT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_output
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|burst_limit
parameter_list|)
block|{
name|int
name|old_cwnd
decl_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
name|net
operator|->
name|cwnd
condition|)
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
operator|(
name|net
operator|->
name|flight_size
operator|+
operator|(
name|burst_limit
operator|*
name|net
operator|->
name|mtu
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_BRST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_cwnd_update_after_fr_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_EARLY_FR_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * make a small adjustment to cwnd and force to CA. 	 */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|net
operator|->
name|mtu
condition|)
comment|/* drop down one MTU after sending */
name|net
operator|->
name|cwnd
operator|-=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|ssthresh
condition|)
comment|/* still in SS move to CA */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|old_cwnd
operator|-
name|net
operator|->
name|cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * H-TCP congestion control. The algorithm is detailed in:  * R.N.Shorten, D.J.Leith:  *   "H-TCP: TCP for high-speed and long-distance networks"  *   Proc. PFLDnet, Argonne, 2004.  * http://www.hamilton.ie/net/htcp3.pdf  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_rtt_scaling
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_bandwidth_switch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|between
parameter_list|(
name|uint32_t
name|seq1
parameter_list|,
name|uint32_t
name|seq2
parameter_list|,
name|uint32_t
name|seq3
parameter_list|)
block|{
return|return
name|seq3
operator|-
name|seq2
operator|>=
name|seq1
operator|-
name|seq2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|htcp_cong_time
parameter_list|(
name|struct
name|htcp
modifier|*
name|ca
parameter_list|)
block|{
return|return
name|sctp_get_tick_count
argument_list|()
operator|-
name|ca
operator|->
name|last_cong
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|htcp_ccount
parameter_list|(
name|struct
name|htcp
modifier|*
name|ca
parameter_list|)
block|{
return|return
name|htcp_cong_time
argument_list|(
name|ca
argument_list|)
operator|/
name|ca
operator|->
name|minRTT
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|htcp_reset
parameter_list|(
name|struct
name|htcp
modifier|*
name|ca
parameter_list|)
block|{
name|ca
operator|->
name|undo_last_cong
operator|=
name|ca
operator|->
name|last_cong
expr_stmt|;
name|ca
operator|->
name|undo_maxRTT
operator|=
name|ca
operator|->
name|maxRTT
expr_stmt|;
name|ca
operator|->
name|undo_old_maxB
operator|=
name|ca
operator|->
name|old_maxB
expr_stmt|;
name|ca
operator|->
name|last_cong
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_NOT_USED
end_ifdef

begin_function
specifier|static
name|uint32_t
name|htcp_cwnd_undo
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|net
operator|->
name|htcp_ca
operator|.
name|last_cong
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|undo_last_cong
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|undo_maxRTT
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|old_maxB
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|undo_old_maxB
expr_stmt|;
return|return
name|max
argument_list|(
name|net
operator|->
name|cwnd
argument_list|,
operator|(
operator|(
name|net
operator|->
name|ssthresh
operator|/
name|net
operator|->
name|mtu
operator|<<
literal|7
operator|)
operator|/
name|net
operator|->
name|htcp_ca
operator|.
name|beta
operator|)
operator|*
name|net
operator|->
name|mtu
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|measure_rtt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|srtt
init|=
name|net
operator|->
name|lastsa
operator|>>
literal|3
decl_stmt|;
comment|/* keep track of minimum RTT seen so far, minRTT is zero at first */
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
operator|>
name|srtt
operator|||
operator|!
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
operator|=
name|srtt
expr_stmt|;
comment|/* max RTT */
if|if
condition|(
name|net
operator|->
name|fast_retran_ip
operator|==
literal|0
operator|&&
name|net
operator|->
name|ssthresh
operator|<
literal|0xFFFF
operator|&&
name|htcp_ccount
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|<
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|<
name|srtt
operator|&&
name|srtt
operator|<=
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|+
name|MSEC_TO_TICKS
argument_list|(
literal|20
argument_list|)
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|=
name|srtt
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|measure_achieved_throughput
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|now
init|=
name|sctp_get_tick_count
argument_list|()
decl_stmt|;
if|if
condition|(
name|net
operator|->
name|fast_retran_ip
operator|==
literal|0
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|bytes_acked
operator|=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
operator|!
name|use_bandwidth_switch
condition|)
return|return;
comment|/* achieved throughput calculations */
comment|/* JRS - not 100% sure of this statement */
if|if
condition|(
name|net
operator|->
name|fast_retran_ip
operator|==
literal|1
condition|)
block|{
name|net
operator|->
name|htcp_ca
operator|.
name|bytecount
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|lasttime
operator|=
name|now
expr_stmt|;
return|return;
block|}
name|net
operator|->
name|htcp_ca
operator|.
name|bytecount
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|bytecount
operator|>=
name|net
operator|->
name|cwnd
operator|-
operator|(
operator|(
name|net
operator|->
name|htcp_ca
operator|.
name|alpha
operator|>>
literal|7
condition|?
else|:
literal|1
operator|)
operator|*
name|net
operator|->
name|mtu
operator|)
operator|&&
name|now
operator|-
name|net
operator|->
name|htcp_ca
operator|.
name|lasttime
operator|>=
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
operator|&&
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|cur_Bi
init|=
name|net
operator|->
name|htcp_ca
operator|.
name|bytecount
operator|/
name|net
operator|->
name|mtu
operator|*
name|hz
operator|/
operator|(
name|now
operator|-
name|net
operator|->
name|htcp_ca
operator|.
name|lasttime
operator|)
decl_stmt|;
if|if
condition|(
name|htcp_ccount
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
operator|<=
literal|3
condition|)
block|{
comment|/* just after backoff */
name|net
operator|->
name|htcp_ca
operator|.
name|minB
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|maxB
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|Bi
operator|=
name|cur_Bi
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|htcp_ca
operator|.
name|Bi
operator|=
operator|(
literal|3
operator|*
name|net
operator|->
name|htcp_ca
operator|.
name|Bi
operator|+
name|cur_Bi
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|Bi
operator|>
name|net
operator|->
name|htcp_ca
operator|.
name|maxB
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|maxB
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|Bi
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|htcp_ca
operator|.
name|minB
operator|>
name|net
operator|->
name|htcp_ca
operator|.
name|maxB
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|minB
operator|=
name|net
operator|->
name|htcp_ca
operator|.
name|maxB
expr_stmt|;
block|}
name|net
operator|->
name|htcp_ca
operator|.
name|bytecount
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|lasttime
operator|=
name|now
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|htcp_beta_update
parameter_list|(
name|struct
name|htcp
modifier|*
name|ca
parameter_list|,
name|uint32_t
name|minRTT
parameter_list|,
name|uint32_t
name|maxRTT
parameter_list|)
block|{
if|if
condition|(
name|use_bandwidth_switch
condition|)
block|{
name|uint32_t
name|maxB
init|=
name|ca
operator|->
name|maxB
decl_stmt|;
name|uint32_t
name|old_maxB
init|=
name|ca
operator|->
name|old_maxB
decl_stmt|;
name|ca
operator|->
name|old_maxB
operator|=
name|ca
operator|->
name|maxB
expr_stmt|;
if|if
condition|(
operator|!
name|between
argument_list|(
literal|5
operator|*
name|maxB
argument_list|,
literal|4
operator|*
name|old_maxB
argument_list|,
literal|6
operator|*
name|old_maxB
argument_list|)
condition|)
block|{
name|ca
operator|->
name|beta
operator|=
name|BETA_MIN
expr_stmt|;
name|ca
operator|->
name|modeswitch
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ca
operator|->
name|modeswitch
operator|&&
name|minRTT
operator|>
operator|(
name|uint32_t
operator|)
name|MSEC_TO_TICKS
argument_list|(
literal|10
argument_list|)
operator|&&
name|maxRTT
condition|)
block|{
name|ca
operator|->
name|beta
operator|=
operator|(
name|minRTT
operator|<<
literal|7
operator|)
operator|/
name|maxRTT
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|beta
operator|<
name|BETA_MIN
condition|)
name|ca
operator|->
name|beta
operator|=
name|BETA_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|ca
operator|->
name|beta
operator|>
name|BETA_MAX
condition|)
name|ca
operator|->
name|beta
operator|=
name|BETA_MAX
expr_stmt|;
block|}
else|else
block|{
name|ca
operator|->
name|beta
operator|=
name|BETA_MIN
expr_stmt|;
name|ca
operator|->
name|modeswitch
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|htcp_alpha_update
parameter_list|(
name|struct
name|htcp
modifier|*
name|ca
parameter_list|)
block|{
name|uint32_t
name|minRTT
init|=
name|ca
operator|->
name|minRTT
decl_stmt|;
name|uint32_t
name|factor
init|=
literal|1
decl_stmt|;
name|uint32_t
name|diff
init|=
name|htcp_cong_time
argument_list|(
name|ca
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|>
operator|(
name|uint32_t
operator|)
name|hz
condition|)
block|{
name|diff
operator|-=
name|hz
expr_stmt|;
name|factor
operator|=
literal|1
operator|+
operator|(
literal|10
operator|*
name|diff
operator|+
operator|(
operator|(
name|diff
operator|/
literal|2
operator|)
operator|*
operator|(
name|diff
operator|/
literal|2
operator|)
operator|/
name|hz
operator|)
operator|)
operator|/
name|hz
expr_stmt|;
block|}
if|if
condition|(
name|use_rtt_scaling
operator|&&
name|minRTT
condition|)
block|{
name|uint32_t
name|scale
init|=
operator|(
name|hz
operator|<<
literal|3
operator|)
operator|/
operator|(
literal|10
operator|*
name|minRTT
operator|)
decl_stmt|;
name|scale
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|scale
argument_list|,
literal|1U
operator|<<
literal|2
argument_list|)
argument_list|,
literal|10U
operator|<<
literal|3
argument_list|)
expr_stmt|;
comment|/* clamping ratio to 								 * interval [0.5,10]<<3 */
name|factor
operator|=
operator|(
name|factor
operator|<<
literal|3
operator|)
operator|/
name|scale
expr_stmt|;
if|if
condition|(
operator|!
name|factor
condition|)
name|factor
operator|=
literal|1
expr_stmt|;
block|}
name|ca
operator|->
name|alpha
operator|=
literal|2
operator|*
name|factor
operator|*
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
name|ca
operator|->
name|beta
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ca
operator|->
name|alpha
condition|)
name|ca
operator|->
name|alpha
operator|=
name|ALPHA_BASE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After we have the rtt data to calculate beta, we'd still prefer to wait one  * rtt before we adjust our beta to ensure we are working from a consistent  * data.  *  * This function should be called when we hit a congestion event since only at  * that point do we really have a real sense of maxRTT (the queues en route  * were getting just too full now).  */
end_comment

begin_function
specifier|static
name|void
name|htcp_param_update
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|minRTT
init|=
name|net
operator|->
name|htcp_ca
operator|.
name|minRTT
decl_stmt|;
name|uint32_t
name|maxRTT
init|=
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
decl_stmt|;
name|htcp_beta_update
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|,
name|minRTT
argument_list|,
name|maxRTT
argument_list|)
expr_stmt|;
name|htcp_alpha_update
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
expr_stmt|;
comment|/* 	 * add slowly fading memory for maxRTT to accommodate routing 	 * changes etc 	 */
if|if
condition|(
name|minRTT
operator|>
literal|0
operator|&&
name|maxRTT
operator|>
name|minRTT
condition|)
name|net
operator|->
name|htcp_ca
operator|.
name|maxRTT
operator|=
name|minRTT
operator|+
operator|(
operator|(
name|maxRTT
operator|-
name|minRTT
operator|)
operator|*
literal|95
operator|)
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|htcp_recalc_ssthresh
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|htcp_param_update
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
name|max
argument_list|(
operator|(
operator|(
name|net
operator|->
name|cwnd
operator|/
name|net
operator|->
name|mtu
operator|*
name|net
operator|->
name|htcp_ca
operator|.
name|beta
operator|)
operator|>>
literal|7
operator|)
operator|*
name|net
operator|->
name|mtu
argument_list|,
literal|2U
operator|*
name|net
operator|->
name|mtu
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|htcp_cong_avoid
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/*- 	 * How to handle these functions?          *	if (!tcp_is_cwnd_limited(sk, in_flight)) RRS - good question. 	 *		return; 	 */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|ssthresh
condition|)
block|{
comment|/* We are in slow start */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|+=
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_SS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|measure_rtt
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 		 * In dangerous area, increase slowly. In theory this is 		 * net->cwnd += alpha / net->cwnd 		 */
comment|/* What is snd_cwnd_cnt?? */
if|if
condition|(
operator|(
operator|(
name|net
operator|->
name|partial_bytes_acked
operator|/
name|net
operator|->
name|mtu
operator|*
name|net
operator|->
name|htcp_ca
operator|.
name|alpha
operator|)
operator|>>
literal|7
operator|)
operator|*
name|net
operator|->
name|mtu
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/*- 			 * Does SCTP have a cwnd clamp? 			 * if (net->snd_cwnd< net->snd_cwnd_clamp) - Nope (RRS). 			 */
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
name|htcp_alpha_update
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_CA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|partial_bytes_acked
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|htcp_ca
operator|.
name|bytes_acked
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_NOT_USED
end_ifdef

begin_comment
comment|/* Lower bound on congestion window. */
end_comment

begin_function
specifier|static
name|uint32_t
name|htcp_min_cwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
return|return
name|net
operator|->
name|ssthresh
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|htcp_init
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htcp
argument_list|)
argument_list|)
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|alpha
operator|=
name|ALPHA_BASE
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|beta
operator|=
name|BETA_MIN
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|bytes_acked
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|last_cong
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_htcp_set_initial_cc_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * We take the max of the burst limit times a MTU or the 	 * INITIAL_CWND. We then limit this to 4 MTU's of sending. 	 */
name|net
operator|->
name|cwnd
operator|=
name|min
argument_list|(
operator|(
name|net
operator|->
name|mtu
operator|*
literal|4
operator|)
argument_list|,
name|max
argument_list|(
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
argument_list|,
name|SCTP_INITIAL_CWND
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we always get at LEAST 2 MTU's */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|ssthresh
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
name|htcp_init
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
operator|(
name|SCTP_CWND_MONITOR_ENABLE
operator||
name|SCTP_CWND_LOGGING_ENABLE
operator|)
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_INITIALIZATION
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_htcp_cwnd_update_after_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|accum_moved
parameter_list|,
name|int
name|reneged_all
parameter_list|,
name|int
name|will_exit
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/******************************/
comment|/* update cwnd and Early FR   */
comment|/******************************/
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code. Need to debug. 		 */
if|if
condition|(
name|net
operator|->
name|fast_retran_loss_recovery
operator|&&
name|net
operator|->
name|new_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|net
operator|->
name|pseudo_cumack
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|net
operator|->
name|pseudo_cumack
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
condition|)
block|{
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
comment|/* 			 * So, first of all do we need to have a Early FR 			 * timer running? 			 */
if|if
condition|(
operator|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|net
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
operator|)
operator|)
operator|||
operator|(
name|reneged_all
operator|)
condition|)
block|{
comment|/* 				 * yes, so in this case stop it if its 				 * running, and then restart it. Reneging 				 * all is a special case where we want to 				 * run the Early FR timer and then force the 				 * last few unacked to be sent, causing us 				 * to illicit a sack with gaps to force out 				 * the others. 				 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck2
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrid
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, stop it if its running */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck3
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if nothing was acked on this destination skip it */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Karn's rule applies to clearing error count, this 			 * is optional. 			 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RECEIVED_SACK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* now was it the primary? if so restore */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_WAS_PRIMARY
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * JRS 5/14/07 - If CMT PF is on and the destination 			 * is in PF state, set the destination to active 			 * state and set the cwnd to one or two MTU's based 			 * on whether PF1 or PF2 is being used. 			 *  			 * Should we stop any running T3 timer here? 			 */
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_pf
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|==
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
operator|*
name|sctp_cmt_pf
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Destination %p moved from PF to reachable with cwnd %d.\n"
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
argument_list|)
expr_stmt|;
comment|/* 				 * Since the cwnd value is explicitly set, 				 * skip the code that updates the cwnd 				 * value. 				 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|JANA_CMT_FAST_RECOVERY
comment|/* 		 * CMT fast recovery code 		 */
comment|/* 		 * if (sctp_cmt_on_off == 1&& 		 * net->fast_retran_loss_recovery&& 		 * net->will_exit_fast_recovery == 0) { @@@ Do something } 		 * else if (sctp_cmt_on_off == 0&& 		 * asoc->fast_retran_loss_recovery&& will_exit == 0) { 		 */
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|will_exit
operator|==
literal|0
operator|&&
name|sctp_cmt_on_off
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we are in loss recovery we skip any cwnd 			 * update 			 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
comment|/* 		 * CMT: CUC algorithm. Update cwnd if pseudo-cumack has 		 * moved. 		 */
if|if
condition|(
name|accum_moved
operator|||
operator|(
name|sctp_cmt_on_off
operator|&&
name|net
operator|->
name|new_pseudo_cumack
operator|)
condition|)
block|{
name|htcp_cong_avoid
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|measure_achieved_throughput
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_NO_CUMACK
argument_list|)
expr_stmt|;
block|}
block|}
name|skip_cwnd_update
label|:
comment|/* 		 * NOW, according to Karn's rule do we need to restore the 		 * RTO timer back? Check our net_ack2. If not set then we 		 * have a ambiguity.. i.e. all data ack'd was sent to more 		 * than one place. 		 */
if|if
condition|(
name|net
operator|->
name|net_ack2
condition|)
block|{
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_htcp_cwnd_update_after_fr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 	 * CMT fast recovery code. Need to debug. ((sctp_cmt_on_off == 1)&& 	 * (net->fast_retran_loss_recovery == 0))) 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|==
literal|0
operator|)
operator|||
operator|(
name|sctp_cmt_on_off
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* out of a RFC2582 Fast recovery window? */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 				 * per section 7.2.3, are there any 				 * destinations that had a fast retransmit 				 * to them. If so what we need to do is 				 * adjust ssthresh and cwnd. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
comment|/* JRS - reset as if state were changed */
name|htcp_reset
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
expr_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|htcp_recalc_ssthresh
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
block|}
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* Turn on fast recovery window */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * CMT fast recovery -- per destination 				 * recovery variable. 				 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * Disable Nonce Sum Checking and store the 				 * resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|fast_recovery_tsn
operator|+
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_32
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Mark a peg that we WOULD have done a cwnd 			 * reduction but RFC2582 prevented this action. 			 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fastretransinrtt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_htcp_cwnd_update_after_timeout
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
comment|/* JRS - reset as if the state were being changed to timeout */
name|htcp_reset
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
expr_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|htcp_recalc_ssthresh
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* floor of 1 mtu */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|mtu
condition|)
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
argument_list|,
name|SCTP_CWND_LOG_FROM_RTX
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_htcp_cwnd_update_after_fr_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_EARLY_FR_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|net
operator|->
name|htcp_ca
operator|.
name|last_cong
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
comment|/* 	 * make a small adjustment to cwnd and force to CA. 	 */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|net
operator|->
name|mtu
condition|)
comment|/* drop down one MTU after sending */
name|net
operator|->
name|cwnd
operator|-=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|ssthresh
condition|)
comment|/* still in SS move to CA */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|old_cwnd
operator|-
name|net
operator|->
name|cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_htcp_cwnd_update_after_ecn_echo
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
comment|/* JRS - reset hctp as if state changed */
name|htcp_reset
argument_list|(
operator|&
name|net
operator|->
name|htcp_ca
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ecnereducedcwnd
argument_list|)
expr_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|htcp_recalc_ssthresh
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* here back off the timer as well, to slow us down */
name|net
operator|->
name|RTO
operator|<<=
literal|1
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
if|if
condition|(
name|sctp_logging_level
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_SAT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

