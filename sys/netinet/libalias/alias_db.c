begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Charles Mott<cm@linktel.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*     Alias_db.c encapsulates all data structures used for storing     packet aliasing data.  Other parts of the aliasing software     access data through functions provided in this file.      Data storage is based on the notion of a "link", which is     established for ICMP echo/reply packets, UDP datagrams and     TCP stream connections.  A link stores the original source     and destination addresses.  For UDP and TCP, it also stores     source and destination port numbers, as well as an alias     port number.  Links are also used to store information about     fragments.      There is a facility for sweeping through and deleting old     links as new packets are sent through.  A simple timeout is     used for ICMP and UDP links.  TCP links are left alone unless     there is an incomplete connection, in which case the link     can be deleted after a certain amount of time.       Initial version: August, 1996  (cjm)      Version 1.4: September 16, 1996 (cjm) 	Facility for handling incoming links added.      Version 1.6: September 18, 1996 (cjm) 	ICMP data handling simplified.      Version 1.7: January 9, 1997 (cjm) 	Fragment handling simplified. 	Saves pointers for unresolved fragments. 	Permits links for unspecified remote ports 	  or unspecified remote addresses. 	Fixed bug which did not properly zero port 	  table entries after a link was deleted. 	Cleaned up some obsolete comments.      Version 1.8: January 14, 1997 (cjm) 	Fixed data type error in StartPoint(). 	(This error did not exist prior to v1.7 	and was discovered and fixed by Ari Suutari)      Version 1.9: February 1, 1997 	Optionally, connections initiated from packet aliasing host 	machine will will not have their port number aliased unless it 	conflicts with an aliasing port already being used. (cjm)  	All options earlier being #ifdef'ed are now available through 	a new interface, SetPacketAliasMode().  This allows run time 	control (which is now available in PPP+pktAlias through the 	'alias' keyword). (ee)  	Added ability to create an alias port without 	either destination address or port specified. 	port type = ALIAS_PORT_UNKNOWN_DEST_ALL (ee)  	Removed K&R style function headers 	and general cleanup. (ee)  	Added packetAliasMode to replace compiler #defines's (ee)  	Allocates sockets for partially specified 	ports if ALIAS_USE_SOCKETS defined. (cjm)      Version 2.0: March, 1997 	SetAliasAddress() will now clean up alias links 	if the aliasing address is changed. (cjm)  	PacketAliasPermanentLink() function added to support permanent 	links.  (J. Fortes suggested the need for this.) 	Examples:  	(192.168.0.1, port 23)<-> alias port 6002, unknown dest addr/port  	(192.168.0.2, port 21)<-> alias port 3604, known dest addr 						     unknown dest port  	These permanent links allow for incoming connections to 	machines on the local network.  They can be given with a 	user-chosen amount of specificity, with increasing specificity 	meaning more security. (cjm)  	Quite a bit of rework to the basic engine.  The portTable[] 	array, which kept track of which ports were in use was replaced 	by a table/linked list structure. (cjm)  	SetExpire() function added. (cjm)  	DeleteLink() no longer frees memory association with a pointer 	to a fragment (this bug was first recognized by E. Eklund in 	v1.9).      Version 2.1: May, 1997 (cjm) 	Packet aliasing engine reworked so that it can handle 	multiple external addresses rather than just a single 	host address.  	PacketAliasRedirectPort() and PacketAliasRedirectAddr() 	added to the API.  The first function is a more generalized 	version of PacketAliasPermanentLink().  The second function 	implements static network address translation.      Version 3.2: July, 2000 (salander and satoh) 	Added FindNewPortGroup to get contiguous range of port values.  	Added QueryUdpTcpIn and QueryUdpTcpOut to look for an aliasing 	link but not actually add one.  	Added FindRtspOut, which is closely derived from FindUdpTcpOut, 	except that the alias port (from FindNewPortGroup) is provided 	as input.      See HISTORY file for additional revisions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_mod.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_include
include|#
directive|include
file|"alias_mod.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|libalias
argument_list|)
name|instancehead
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|instancehead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    Constants (note: constants are also defined 	      near relevant functions or structs) */
end_comment

begin_comment
comment|/* Parameters used for cleanup of expired links */
end_comment

begin_comment
comment|/* NOTE: ALIAS_CLEANUP_INTERVAL_SECS must be less then LINK_TABLE_OUT_SIZE */
end_comment

begin_define
define|#
directive|define
name|ALIAS_CLEANUP_INTERVAL_SECS
value|64
end_define

begin_define
define|#
directive|define
name|ALIAS_CLEANUP_MAX_SPOKES
value|(LINK_TABLE_OUT_SIZE/5)
end_define

begin_comment
comment|/* Timeouts (in seconds) for different link types */
end_comment

begin_define
define|#
directive|define
name|ICMP_EXPIRE_TIME
value|60
end_define

begin_define
define|#
directive|define
name|UDP_EXPIRE_TIME
value|60
end_define

begin_define
define|#
directive|define
name|PROTO_EXPIRE_TIME
value|60
end_define

begin_define
define|#
directive|define
name|FRAGMENT_ID_EXPIRE_TIME
value|10
end_define

begin_define
define|#
directive|define
name|FRAGMENT_PTR_EXPIRE_TIME
value|30
end_define

begin_comment
comment|/* TCP link expire time for different cases */
end_comment

begin_comment
comment|/* When the link has been used and closed - minimal grace time to    allow ACKs and potential re-connect in FTP (XXX - is this allowed?)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCP_EXPIRE_DEAD
end_ifndef

begin_define
define|#
directive|define
name|TCP_EXPIRE_DEAD
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When the link has been used and closed on one side - the other side    is allowed to still send data */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCP_EXPIRE_SINGLEDEAD
end_ifndef

begin_define
define|#
directive|define
name|TCP_EXPIRE_SINGLEDEAD
value|90
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When the link isn't yet up */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCP_EXPIRE_INITIAL
end_ifndef

begin_define
define|#
directive|define
name|TCP_EXPIRE_INITIAL
value|300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When the link is up */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCP_EXPIRE_CONNECTED
end_ifndef

begin_define
define|#
directive|define
name|TCP_EXPIRE_CONNECTED
value|86400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dummy port number codes used for FindLinkIn/Out() and AddLink().    These constants can be anything except zero, which indicates an    unknown port number. */
end_comment

begin_define
define|#
directive|define
name|NO_DEST_PORT
value|1
end_define

begin_define
define|#
directive|define
name|NO_SRC_PORT
value|1
end_define

begin_comment
comment|/* Data Structures      The fundamental data structure used in this program is     "struct alias_link".  Whenever a TCP connection is made,     a UDP datagram is sent out, or an ICMP echo request is made,     a link record is made (if it has not already been created).     The link record is identified by the source address/port     and the destination address/port. In the case of an ICMP     echo request, the source port is treated as being equivalent     with the 16-bit ID number of the ICMP packet.      The link record also can store some auxiliary data.  For     TCP connections that have had sequence and acknowledgment     modifications, data space is available to track these changes.     A state field is used to keep track in changes to the TCP     connection state.  ID numbers of fragments can also be     stored in the auxiliary space.  Pointers to unresolved     fragments can also be stored.      The link records support two independent chainings.  Lookup     tables for input and out tables hold the initial pointers     the link chains.  On input, the lookup table indexes on alias     port and link type.  On output, the lookup table indexes on     source address, destination address, source port, destination     port and link type. */
end_comment

begin_struct
struct|struct
name|ack_data_record
block|{
comment|/* used to save changes to ACK/sequence 				 * numbers */
name|u_long
name|ack_old
decl_stmt|;
name|u_long
name|ack_new
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|int
name|active
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tcp_state
block|{
comment|/* Information about TCP connection        */
name|int
name|in
decl_stmt|;
comment|/* State for outside -> inside             */
name|int
name|out
decl_stmt|;
comment|/* State for inside  -> outside            */
name|int
name|index
decl_stmt|;
comment|/* Index to ACK data array                 */
name|int
name|ack_modified
decl_stmt|;
comment|/* Indicates whether ACK and 					 * sequence numbers */
comment|/* been modified                           */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|N_LINK_TCP_DATA
value|3
end_define

begin_comment
comment|/* Number of distinct ACK number changes 				 * saved for a modified TCP stream */
end_comment

begin_struct
struct|struct
name|tcp_dat
block|{
name|struct
name|tcp_state
name|state
decl_stmt|;
name|struct
name|ack_data_record
name|ack
index|[
name|N_LINK_TCP_DATA
index|]
decl_stmt|;
name|int
name|fwhole
decl_stmt|;
comment|/* Which firewall record is used for this 				 * hole? */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|server
block|{
comment|/* LSNAT server pool (circular list) */
name|struct
name|in_addr
name|addr
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|struct
name|server
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|alias_link
block|{
comment|/* Main data structure */
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|;
comment|/* Address and port information        */
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|struct
name|in_addr
name|proxy_addr
decl_stmt|;
name|u_short
name|src_port
decl_stmt|;
name|u_short
name|dst_port
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|;
name|u_short
name|proxy_port
decl_stmt|;
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|int
name|link_type
decl_stmt|;
comment|/* Type of link: TCP, UDP, ICMP, 					 * proto, frag */
comment|/* values for link_type */
define|#
directive|define
name|LINK_ICMP
value|IPPROTO_ICMP
define|#
directive|define
name|LINK_UDP
value|IPPROTO_UDP
define|#
directive|define
name|LINK_TCP
value|IPPROTO_TCP
define|#
directive|define
name|LINK_FRAGMENT_ID
value|(IPPROTO_MAX + 1)
define|#
directive|define
name|LINK_FRAGMENT_PTR
value|(IPPROTO_MAX + 2)
define|#
directive|define
name|LINK_ADDR
value|(IPPROTO_MAX + 3)
define|#
directive|define
name|LINK_PPTP
value|(IPPROTO_MAX + 4)
name|int
name|flags
decl_stmt|;
comment|/* indicates special characteristics   */
name|int
name|pflags
decl_stmt|;
comment|/* protocol-specific flags */
comment|/* flag bits */
define|#
directive|define
name|LINK_UNKNOWN_DEST_PORT
value|0x01
define|#
directive|define
name|LINK_UNKNOWN_DEST_ADDR
value|0x02
define|#
directive|define
name|LINK_PERMANENT
value|0x04
define|#
directive|define
name|LINK_PARTIALLY_SPECIFIED
value|0x03
comment|/* logical-or of first two bits */
define|#
directive|define
name|LINK_UNFIREWALLED
value|0x08
name|int
name|timestamp
decl_stmt|;
comment|/* Time link was last accessed         */
name|int
name|expire_time
decl_stmt|;
comment|/* Expire time for link                */
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
name|int
name|sockfd
decl_stmt|;
comment|/* socket descriptor                   */
endif|#
directive|endif
name|LIST_ENTRY
argument_list|(
argument|alias_link
argument_list|)
name|list_out
expr_stmt|;
comment|/* Linked list of 								 * pointers for     */
name|LIST_ENTRY
argument_list|(
argument|alias_link
argument_list|)
name|list_in
expr_stmt|;
comment|/* input and output 								 * lookup tables  */
union|union
block|{
comment|/* Auxiliary data                      */
name|char
modifier|*
name|frag_ptr
decl_stmt|;
name|struct
name|in_addr
name|frag_addr
decl_stmt|;
name|struct
name|tcp_dat
modifier|*
name|tcp
decl_stmt|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Clean up procedure. */
end_comment

begin_function_decl
specifier|static
name|void
name|finishoff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Kernel module definition. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ALIAS
argument_list|,
literal|"libalias"
argument_list|,
literal|"packet aliasing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|libalias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|alias_mod_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|handler_chain_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
case|case
name|MOD_UNLOAD
case|:
name|handler_chain_destroy
argument_list|()
expr_stmt|;
name|finishoff
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|alias_mod
init|=
block|{
literal|"alias"
block|,
name|alias_mod_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|alias
argument_list|,
name|alias_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal utility routines (used only in alias_db.c)  Lookup table starting points:     StartPointIn()           -- link table initial search point for 				incoming packets     StartPointOut()          -- link table initial search point for 				outgoing packets  Miscellaneous:     SeqDiff()                -- difference between two TCP sequences     ShowAliasStats()         -- send alias statistics to a monitor file */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|u_int
name|StartPointIn
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|StartPointOut
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SeqDiff
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
end_ifndef

begin_comment
comment|/* Firewall control */
end_comment

begin_function_decl
specifier|static
name|void
name|InitPunchFW
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|UninitPunchFW
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ClearFWHole
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Log file control */
end_comment

begin_function_decl
specifier|static
name|void
name|ShowAliasStats
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|InitPacketAliasLog
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|UninitPacketAliasLog
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|u_int
name|StartPointIn
parameter_list|(
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
name|alias_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|link_type
operator|!=
name|LINK_PPTP
condition|)
name|n
operator|+=
name|alias_port
expr_stmt|;
name|n
operator|+=
name|link_type
expr_stmt|;
return|return
operator|(
name|n
operator|%
name|LINK_TABLE_IN_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|StartPointOut
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
name|src_addr
operator|.
name|s_addr
expr_stmt|;
name|n
operator|+=
name|dst_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|link_type
operator|!=
name|LINK_PPTP
condition|)
block|{
name|n
operator|+=
name|src_port
expr_stmt|;
name|n
operator|+=
name|dst_port
expr_stmt|;
block|}
name|n
operator|+=
name|link_type
expr_stmt|;
return|return
operator|(
name|n
operator|%
name|LINK_TABLE_OUT_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SeqDiff
parameter_list|(
name|u_long
name|x
parameter_list|,
name|u_long
name|y
parameter_list|)
block|{
comment|/* Return the difference between two TCP sequence numbers */
comment|/*     This function is encapsulated in case there are any unusual     arithmetic conditions that need to be considered. */
return|return
operator|(
name|ntohl
argument_list|(
name|y
argument_list|)
operator|-
name|ntohl
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|AliasLog
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|LIBALIAS_BUF_SIZE
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|AliasLog
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ShowAliasStats
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Used for debugging */
if|if
condition|(
name|la
operator|->
name|logDesc
condition|)
block|{
name|int
name|tot
init|=
name|la
operator|->
name|icmpLinkCount
operator|+
name|la
operator|->
name|udpLinkCount
operator|+
name|la
operator|->
name|tcpLinkCount
operator|+
name|la
operator|->
name|pptpLinkCount
operator|+
name|la
operator|->
name|protoLinkCount
operator|+
name|la
operator|->
name|fragmentIdLinkCount
operator|+
name|la
operator|->
name|fragmentPtrLinkCount
decl_stmt|;
name|AliasLog
argument_list|(
name|la
operator|->
name|logDesc
argument_list|,
literal|"icmp=%u, udp=%u, tcp=%u, pptp=%u, proto=%u, frag_id=%u frag_ptr=%u / tot=%u"
argument_list|,
name|la
operator|->
name|icmpLinkCount
argument_list|,
name|la
operator|->
name|udpLinkCount
argument_list|,
name|la
operator|->
name|tcpLinkCount
argument_list|,
name|la
operator|->
name|pptpLinkCount
argument_list|,
name|la
operator|->
name|protoLinkCount
argument_list|,
name|la
operator|->
name|fragmentIdLinkCount
argument_list|,
name|la
operator|->
name|fragmentPtrLinkCount
argument_list|,
name|tot
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
name|AliasLog
argument_list|(
name|la
operator|->
name|logDesc
argument_list|,
literal|" (sock=%u)\n"
argument_list|,
name|la
operator|->
name|sockCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Internal routines for finding, deleting and adding links  Port Allocation:     GetNewPort()             -- find and reserve new alias port number     GetSocket()              -- try to allocate a socket for a given port  Link creation and deletion:     CleanupAliasData()      - remove all link chains from lookup table     IncrementalCleanup()    - look for stale links in a single chain     DeleteLink()            - remove link     AddLink()               - add link     ReLink()                - change link  Link search:     FindLinkOut()           - find link for outgoing packets     FindLinkIn()            - find link for incoming packets  Port search:     FindNewPortGroup()      - find an available group of ports */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|GetNewPort
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
end_ifndef

begin_function_decl
specifier|static
name|u_short
name|GetSocket
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|u_short
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|CleanupAliasData
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IncrementalCleanup
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DeleteLink
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|AddLink
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|ReLink
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ALIAS_PORT_BASE
value|0x08000
end_define

begin_define
define|#
directive|define
name|ALIAS_PORT_MASK
value|0x07fff
end_define

begin_define
define|#
directive|define
name|ALIAS_PORT_MASK_EVEN
value|0x07ffe
end_define

begin_define
define|#
directive|define
name|GET_NEW_PORT_MAX_ATTEMPTS
value|20
end_define

begin_define
define|#
directive|define
name|GET_ALIAS_PORT
value|-1
end_define

begin_define
define|#
directive|define
name|GET_ALIAS_ID
value|GET_ALIAS_PORT
end_define

begin_define
define|#
directive|define
name|FIND_EVEN_ALIAS_BASE
value|1
end_define

begin_comment
comment|/* GetNewPort() allocates port numbers.  Note that if a port number    is already in use, that does not mean that it cannot be used by    another link concurrently.  This is because GetNewPort() looks for    unused triplets: (dest addr, dest port, alias port). */
end_comment

begin_function
specifier|static
name|int
name|GetNewPort
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|alias_port_param
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max_trials
decl_stmt|;
name|u_short
name|port_sys
decl_stmt|;
name|u_short
name|port_net
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/*    Description of alias_port_param for GetNewPort().  When    this parameter is zero or positive, it precisely specifies    the port number.  GetNewPort() will return this number    without check that it is in use.     When this parameter is GET_ALIAS_PORT, it indicates to get a randomly    selected port number. */
if|if
condition|(
name|alias_port_param
operator|==
name|GET_ALIAS_PORT
condition|)
block|{
comment|/* 		 * The aliasing port is automatically selected by one of 		 * two methods below: 		 */
name|max_trials
operator|=
name|GET_NEW_PORT_MAX_ATTEMPTS
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_SAME_PORTS
condition|)
block|{
comment|/* 			 * When the PKT_ALIAS_SAME_PORTS option is chosen, 			 * the first try will be the actual source port. If 			 * this is already in use, the remainder of the 			 * trials will be random. 			 */
name|port_net
operator|=
name|lnk
operator|->
name|src_port
expr_stmt|;
name|port_sys
operator|=
name|ntohs
argument_list|(
name|port_net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First trial and all subsequent are random. */
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
name|port_net
operator|=
name|htons
argument_list|(
name|port_sys
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|alias_port_param
operator|>=
literal|0
operator|&&
name|alias_port_param
operator|<
literal|0x10000
condition|)
block|{
name|lnk
operator|->
name|alias_port
operator|=
operator|(
name|u_short
operator|)
name|alias_port_param
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetNewPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"input parameter error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Port number search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_trials
condition|;
name|i
operator|++
control|)
block|{
name|int
name|go_ahead
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|search_result
decl_stmt|;
name|search_result
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|lnk
operator|->
name|dst_addr
argument_list|,
name|lnk
operator|->
name|alias_addr
argument_list|,
name|lnk
operator|->
name|dst_port
argument_list|,
name|port_net
argument_list|,
name|lnk
operator|->
name|link_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_result
operator|==
name|NULL
condition|)
name|go_ahead
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|lnk
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
operator|&&
operator|(
name|search_result
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
condition|)
name|go_ahead
operator|=
literal|1
expr_stmt|;
else|else
name|go_ahead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go_ahead
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
if|if
condition|(
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_USE_SOCKETS
operator|)
operator|&&
operator|(
name|lnk
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
operator|&&
operator|(
operator|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_TCP
operator|)
operator|||
operator|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_UDP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GetSocket
argument_list|(
name|la
argument_list|,
name|port_net
argument_list|,
operator|&
name|lnk
operator|->
name|sockfd
argument_list|,
name|lnk
operator|->
name|link_type
argument_list|)
condition|)
block|{
name|lnk
operator|->
name|alias_port
operator|=
name|port_net
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
name|lnk
operator|->
name|alias_port
operator|=
name|port_net
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
block|}
endif|#
directive|endif
block|}
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
name|port_net
operator|=
name|htons
argument_list|(
name|port_sys
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetnewPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not find free port\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
end_ifndef

begin_function
specifier|static
name|u_short
name|GetSocket
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|u_short
name|port_net
parameter_list|,
name|int
modifier|*
name|sockfd
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_in
name|sock_addr
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_type
operator|==
name|LINK_TCP
condition|)
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|link_type
operator|==
name|LINK_UDP
condition|)
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetSocket(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"incorrect link type\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetSocket(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"socket() error %d\n"
argument_list|,
operator|*
name|sockfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sock_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sock_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|sock_addr
operator|.
name|sin_port
operator|=
name|port_net
expr_stmt|;
name|err
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sock_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sock_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|la
operator|->
name|sockCount
operator|++
expr_stmt|;
operator|*
name|sockfd
operator|=
name|sock
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FindNewPortGroup() returns a base port number for an available    range of contiguous port numbers. Note that if a port number    is already in use, that does not mean that it cannot be used by    another link concurrently.  This is because FindNewPortGroup()    looks for unused triplets: (dest addr, dest port, alias port). */
end_comment

begin_function
name|int
name|FindNewPortGroup
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|port_count
parameter_list|,
name|u_char
name|proto
parameter_list|,
name|u_char
name|align
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|max_trials
decl_stmt|;
name|u_short
name|port_sys
decl_stmt|;
name|int
name|link_type
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* 	 * Get link_type from protocol 	 */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
comment|/* 	 * The aliasing port is automatically selected by one of two 	 * methods below: 	 */
name|max_trials
operator|=
name|GET_NEW_PORT_MAX_ATTEMPTS
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_SAME_PORTS
condition|)
block|{
comment|/* 		 * When the ALIAS_SAME_PORTS option is chosen, the first 		 * try will be the actual source port. If this is already 		 * in use, the remainder of the trials will be random. 		 */
name|port_sys
operator|=
name|ntohs
argument_list|(
name|src_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First trial and all subsequent are random. */
if|if
condition|(
name|align
operator|==
name|FIND_EVEN_ALIAS_BASE
condition|)
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK_EVEN
expr_stmt|;
else|else
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
block|}
comment|/* Port number search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_trials
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|alias_link
modifier|*
name|search_result
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|port_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
literal|0
operator|!=
operator|(
name|search_result
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|dst_port
argument_list|,
name|htons
argument_list|(
name|port_sys
operator|+
name|j
argument_list|)
argument_list|,
name|link_type
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
break|break;
comment|/* Found a good range, return base */
if|if
condition|(
name|j
operator|==
name|port_count
condition|)
return|return
operator|(
name|htons
argument_list|(
name|port_sys
argument_list|)
operator|)
return|;
comment|/* Find a new base to try */
if|if
condition|(
name|align
operator|==
name|FIND_EVEN_ALIAS_BASE
condition|)
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK_EVEN
expr_stmt|;
else|else
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/FindNewPortGroup(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not find free port(s)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CleanupAliasData
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_OUT_SIZE
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|lnk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|la
operator|->
name|linkTableOut
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|DeleteLink
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
name|la
operator|->
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|IncrementalCleanup
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|,
modifier|*
name|lnk_tmp
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableOut[la->cleanupIndex++]
argument_list|,
argument|list_out
argument_list|,
argument|lnk_tmp
argument_list|)
block|{
if|if
condition|(
name|la
operator|->
name|timeStamp
operator|-
name|lnk
operator|->
name|timestamp
operator|>
name|lnk
operator|->
name|expire_time
condition|)
name|DeleteLink
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|la
operator|->
name|cleanupIndex
operator|==
name|LINK_TABLE_OUT_SIZE
condition|)
name|la
operator|->
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DeleteLink
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|struct
name|libalias
modifier|*
name|la
init|=
name|lnk
operator|->
name|la
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Don't do anything if the link is marked permanent */
if|if
condition|(
name|la
operator|->
name|deleteAllLinks
operator|==
literal|0
operator|&&
name|lnk
operator|->
name|flags
operator|&
name|LINK_PERMANENT
condition|)
return|return;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
comment|/* Delete associated firewall hole, if any */
name|ClearFWHole
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free memory allocated for LSNAT server pool */
if|if
condition|(
name|lnk
operator|->
name|server
operator|!=
name|NULL
condition|)
block|{
name|struct
name|server
modifier|*
name|head
decl_stmt|,
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|head
operator|=
name|curr
operator|=
name|lnk
operator|->
name|server
expr_stmt|;
do|do
block|{
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|curr
operator|=
name|next
operator|)
operator|!=
name|head
condition|)
do|;
block|}
comment|/* Adjust output table pointers */
name|LIST_REMOVE
argument_list|(
name|lnk
argument_list|,
name|list_out
argument_list|)
expr_stmt|;
comment|/* Adjust input table pointers */
name|LIST_REMOVE
argument_list|(
name|lnk
argument_list|,
name|list_in
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
comment|/* Close socket, if one has been allocated */
if|if
condition|(
name|lnk
operator|->
name|sockfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|la
operator|->
name|sockCount
operator|--
expr_stmt|;
name|close
argument_list|(
name|lnk
operator|->
name|sockfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Link-type dependent cleanup */
switch|switch
condition|(
name|lnk
operator|->
name|link_type
condition|)
block|{
case|case
name|LINK_ICMP
case|:
name|la
operator|->
name|icmpLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|la
operator|->
name|udpLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|la
operator|->
name|tcpLinkCount
operator|--
expr_stmt|;
name|free
argument_list|(
name|lnk
operator|->
name|data
operator|.
name|tcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINK_PPTP
case|:
name|la
operator|->
name|pptpLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|la
operator|->
name|fragmentIdLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|la
operator|->
name|fragmentPtrLinkCount
operator|--
expr_stmt|;
if|if
condition|(
name|lnk
operator|->
name|data
operator|.
name|frag_ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lnk
operator|->
name|data
operator|.
name|frag_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINK_ADDR
case|:
break|break;
default|default:
name|la
operator|->
name|protoLinkCount
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Free memory */
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Write statistics, if logging enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|ShowAliasStats
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|AddLink
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|alias_port_param
parameter_list|,
comment|/* if less than zero, alias   */
name|int
name|link_type
parameter_list|)
block|{
comment|/* port will be automatically */
comment|/* chosen. 				 * If greater than    */
name|u_int
name|start_point
decl_stmt|;
comment|/* zero, equal to alias port  */
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alias_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
comment|/* Basic initialization */
name|lnk
operator|->
name|la
operator|=
name|la
expr_stmt|;
name|lnk
operator|->
name|src_addr
operator|=
name|src_addr
expr_stmt|;
name|lnk
operator|->
name|dst_addr
operator|=
name|dst_addr
expr_stmt|;
name|lnk
operator|->
name|alias_addr
operator|=
name|alias_addr
expr_stmt|;
name|lnk
operator|->
name|proxy_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|lnk
operator|->
name|src_port
operator|=
name|src_port
expr_stmt|;
name|lnk
operator|->
name|dst_port
operator|=
name|dst_port
expr_stmt|;
name|lnk
operator|->
name|proxy_port
operator|=
literal|0
expr_stmt|;
name|lnk
operator|->
name|server
operator|=
name|NULL
expr_stmt|;
name|lnk
operator|->
name|link_type
operator|=
name|link_type
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
name|lnk
operator|->
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|lnk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|lnk
operator|->
name|pflags
operator|=
literal|0
expr_stmt|;
name|lnk
operator|->
name|timestamp
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
comment|/* Expiration time */
switch|switch
condition|(
name|link_type
condition|)
block|{
case|case
name|LINK_ICMP
case|:
name|lnk
operator|->
name|expire_time
operator|=
name|ICMP_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|lnk
operator|->
name|expire_time
operator|=
name|UDP_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_INITIAL
expr_stmt|;
break|break;
case|case
name|LINK_PPTP
case|:
name|lnk
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
comment|/* no timeout. */
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|lnk
operator|->
name|expire_time
operator|=
name|FRAGMENT_ID_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|lnk
operator|->
name|expire_time
operator|=
name|FRAGMENT_PTR_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_ADDR
case|:
break|break;
default|default:
name|lnk
operator|->
name|expire_time
operator|=
name|PROTO_EXPIRE_TIME
expr_stmt|;
break|break;
block|}
comment|/* Determine alias flags */
if|if
condition|(
name|dst_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|lnk
operator|->
name|flags
operator||=
name|LINK_UNKNOWN_DEST_ADDR
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
literal|0
condition|)
name|lnk
operator|->
name|flags
operator||=
name|LINK_UNKNOWN_DEST_PORT
expr_stmt|;
comment|/* Determine alias port */
if|if
condition|(
name|GetNewPort
argument_list|(
name|la
argument_list|,
name|lnk
argument_list|,
name|alias_port_param
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Link-type dependent initialization */
switch|switch
condition|(
name|link_type
condition|)
block|{
name|struct
name|tcp_dat
modifier|*
name|aux_tcp
decl_stmt|;
case|case
name|LINK_ICMP
case|:
name|la
operator|->
name|icmpLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|la
operator|->
name|udpLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|aux_tcp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcp_dat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_tcp
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|la
operator|->
name|tcpLinkCount
operator|++
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|in
operator|=
name|ALIAS_TCP_STATE_NOT_CONNECTED
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|out
operator|=
name|ALIAS_TCP_STATE_NOT_CONNECTED
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|ack_modified
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
name|aux_tcp
operator|->
name|ack
index|[
name|i
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
name|aux_tcp
operator|->
name|fwhole
operator|=
operator|-
literal|1
expr_stmt|;
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|=
name|aux_tcp
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/AddLink: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" cannot allocate auxiliary TCP data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|LINK_PPTP
case|:
name|la
operator|->
name|pptpLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|la
operator|->
name|fragmentIdLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|la
operator|->
name|fragmentPtrLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_ADDR
case|:
break|break;
default|default:
name|la
operator|->
name|protoLinkCount
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Set up pointers for output lookup table */
name|start_point
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|la
operator|->
name|linkTableOut
index|[
name|start_point
index|]
argument_list|,
name|lnk
argument_list|,
name|list_out
argument_list|)
expr_stmt|;
comment|/* Set up pointers for input lookup table */
name|start_point
operator|=
name|StartPointIn
argument_list|(
name|alias_addr
argument_list|,
name|lnk
operator|->
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|la
operator|->
name|linkTableIn
index|[
name|start_point
index|]
argument_list|,
name|lnk
argument_list|,
name|list_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/AddLink(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc() call failed.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|ShowAliasStats
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|ReLink
parameter_list|(
name|struct
name|alias_link
modifier|*
name|old_lnk
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|alias_port_param
parameter_list|,
comment|/* if less than zero, alias   */
name|int
name|link_type
parameter_list|)
block|{
comment|/* port will be automatically */
comment|/* chosen. 				 * If greater than    */
name|struct
name|alias_link
modifier|*
name|new_lnk
decl_stmt|;
comment|/* zero, equal to alias port  */
name|struct
name|libalias
modifier|*
name|la
init|=
name|old_lnk
operator|->
name|la
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|new_lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port_param
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
if|if
condition|(
name|new_lnk
operator|!=
name|NULL
operator|&&
name|old_lnk
operator|->
name|link_type
operator|==
name|LINK_TCP
operator|&&
name|old_lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|fwhole
operator|>
literal|0
condition|)
block|{
name|PunchFWHole
argument_list|(
name|new_lnk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DeleteLink
argument_list|(
name|old_lnk
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_lnk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|_FindLinkOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|link_type
parameter_list|,
name|int
name|replace_partial_links
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|i
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableOut[i]
argument_list|,
argument|list_out
argument_list|)
block|{
if|if
condition|(
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|src_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|src_port
operator|==
name|src_port
operator|&&
name|lnk
operator|->
name|dst_port
operator|==
name|dst_port
operator|&&
name|lnk
operator|->
name|link_type
operator|==
name|link_type
operator|&&
name|lnk
operator|->
name|server
operator|==
name|NULL
condition|)
block|{
name|lnk
operator|->
name|timestamp
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
break|break;
block|}
block|}
comment|/* Search for partially specified links. */
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
name|replace_partial_links
condition|)
block|{
if|if
condition|(
name|dst_port
operator|!=
literal|0
operator|&&
name|dst_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|lnk
operator|=
name|_FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
literal|0
argument_list|,
name|link_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
name|lnk
operator|=
name|_FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
operator|(
name|dst_port
operator|!=
literal|0
operator|||
name|dst_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
condition|)
block|{
name|lnk
operator|=
name|_FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|src_port
argument_list|,
literal|0
argument_list|,
name|link_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|lnk
operator|=
name|ReLink
argument_list|(
name|lnk
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|lnk
operator|->
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|lnk
operator|->
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|link_type
parameter_list|,
name|int
name|replace_partial_links
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|_FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|,
name|replace_partial_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The following allows permanent links to be specified as 		 * using the default source address (i.e. device interface 		 * address) without knowing in advance what that address 		 * is. 		 */
if|if
condition|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|src_addr
operator|.
name|s_addr
operator|==
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
condition|)
block|{
name|lnk
operator|=
name|_FindLinkOut
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|,
name|replace_partial_links
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|_FindLinkIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|int
name|link_type
parameter_list|,
name|int
name|replace_partial_links
parameter_list|)
block|{
name|int
name|flags_in
decl_stmt|;
name|u_int
name|start_point
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk_fully_specified
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk_unknown_all
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk_unknown_dst_addr
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk_unknown_dst_port
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Initialize pointers */
name|lnk_fully_specified
operator|=
name|NULL
expr_stmt|;
name|lnk_unknown_all
operator|=
name|NULL
expr_stmt|;
name|lnk_unknown_dst_addr
operator|=
name|NULL
expr_stmt|;
name|lnk_unknown_dst_port
operator|=
name|NULL
expr_stmt|;
comment|/* If either the dest addr or port is unknown, the search    loop will have to know about this. */
name|flags_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|flags_in
operator||=
name|LINK_UNKNOWN_DEST_ADDR
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
literal|0
condition|)
name|flags_in
operator||=
name|LINK_UNKNOWN_DEST_PORT
expr_stmt|;
comment|/* Search loop */
name|start_point
operator|=
name|StartPointIn
argument_list|(
name|alias_addr
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableIn[start_point]
argument_list|,
argument|list_in
argument_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|flags_in
operator||
name|lnk
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
condition|)
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|dst_port
operator|==
name|dst_port
operator|&&
name|lnk
operator|->
name|link_type
operator|==
name|link_type
condition|)
block|{
name|lnk_fully_specified
operator|=
name|lnk
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_ADDR
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_PORT
operator|)
condition|)
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|lnk
operator|->
name|link_type
operator|==
name|link_type
condition|)
block|{
if|if
condition|(
name|lnk_unknown_all
operator|==
name|NULL
condition|)
name|lnk_unknown_all
operator|=
name|lnk
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_ADDR
condition|)
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|lnk
operator|->
name|link_type
operator|==
name|link_type
operator|&&
name|lnk
operator|->
name|dst_port
operator|==
name|dst_port
condition|)
block|{
if|if
condition|(
name|lnk_unknown_dst_addr
operator|==
name|NULL
condition|)
name|lnk_unknown_dst_addr
operator|=
name|lnk
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_PORT
condition|)
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|lnk
operator|->
name|link_type
operator|==
name|link_type
operator|&&
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|lnk_unknown_dst_port
operator|==
name|NULL
condition|)
name|lnk_unknown_dst_port
operator|=
name|lnk
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lnk_fully_specified
operator|!=
name|NULL
condition|)
block|{
name|lnk_fully_specified
operator|->
name|timestamp
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
name|lnk
operator|=
name|lnk_fully_specified
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lnk_unknown_dst_port
operator|!=
name|NULL
condition|)
name|lnk
operator|=
name|lnk_unknown_dst_port
expr_stmt|;
elseif|else
if|if
condition|(
name|lnk_unknown_dst_addr
operator|!=
name|NULL
condition|)
name|lnk
operator|=
name|lnk_unknown_dst_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|lnk_unknown_all
operator|!=
name|NULL
condition|)
name|lnk
operator|=
name|lnk_unknown_all
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|replace_partial_links
operator|&&
operator|(
name|lnk
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|||
name|lnk
operator|->
name|server
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|u_short
name|src_port
decl_stmt|;
if|if
condition|(
name|lnk
operator|->
name|server
operator|!=
name|NULL
condition|)
block|{
comment|/* LSNAT link */
name|src_addr
operator|=
name|lnk
operator|->
name|server
operator|->
name|addr
expr_stmt|;
name|src_port
operator|=
name|lnk
operator|->
name|server
operator|->
name|port
expr_stmt|;
name|lnk
operator|->
name|server
operator|=
name|lnk
operator|->
name|server
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|lnk
operator|->
name|src_addr
expr_stmt|;
name|src_port
operator|=
name|lnk
operator|->
name|src_port
expr_stmt|;
block|}
name|lnk
operator|=
name|ReLink
argument_list|(
name|lnk
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|int
name|link_type
parameter_list|,
name|int
name|replace_partial_links
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|_FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|,
name|replace_partial_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The following allows permanent links to be specified as 		 * using the default aliasing address (i.e. device 		 * interface address) without knowing in advance what that 		 * address is. 		 */
if|if
condition|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|alias_addr
operator|.
name|s_addr
operator|==
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
condition|)
block|{
name|lnk
operator|=
name|_FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|,
name|replace_partial_links
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* External routines for finding/adding links  -- "external" means outside alias_db.c, but within alias*.c --      FindIcmpIn(), FindIcmpOut()     FindFragmentIn1(), FindFragmentIn2()     AddFragmentPtrLink(), FindFragmentPtr()     FindProtoIn(), FindProtoOut()     FindUdpTcpIn(), FindUdpTcpOut()     AddPptp(), FindPptpOutByCallId(), FindPptpInByCallId(),     FindPptpOutByPeerCallId(), FindPptpInByPeerCallId()     FindOriginalAddress(), FindAliasAddress()  (prototypes in alias_local.h) */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|FindIcmpIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|id_alias
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|id_alias
argument_list|,
name|LINK_ICMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
name|create
operator|&&
operator|!
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_DENY_INCOMING
operator|)
condition|)
block|{
name|struct
name|in_addr
name|target_addr
decl_stmt|;
name|target_addr
operator|=
name|FindOriginalAddress
argument_list|(
name|la
argument_list|,
name|alias_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|target_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|id_alias
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|id_alias
argument_list|,
name|LINK_ICMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindIcmpOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|id
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|id
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|LINK_ICMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|id
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|GET_ALIAS_ID
argument_list|,
name|LINK_ICMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentIn1
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentIn2
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
comment|/* Doesn't add a link if 								 * one */
name|struct
name|in_addr
name|alias_addr
parameter_list|,
comment|/* is not found.           */
name|u_short
name|ip_id
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|AddFragmentPtrLink
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
name|AddLink
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|dst_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_PTR
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentPtr
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_PTR
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindProtoIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_DENY_INCOMING
operator|)
condition|)
block|{
name|struct
name|in_addr
name|target_addr
decl_stmt|;
name|target_addr
operator|=
name|FindOriginalAddress
argument_list|(
name|la
argument_list|,
name|alias_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|target_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindProtoOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindUdpTcpIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|u_char
name|proto
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
name|create
operator|&&
operator|!
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_DENY_INCOMING
operator|)
condition|)
block|{
name|struct
name|in_addr
name|target_addr
decl_stmt|;
name|target_addr
operator|=
name|FindOriginalAddress
argument_list|(
name|la
argument_list|,
name|alias_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|target_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|alias_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindUdpTcpOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_char
name|proto
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
name|lnk
operator|=
name|FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|GET_ALIAS_PORT
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|AddPptp
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_int16_t
name|src_call_id
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_call_id
argument_list|,
literal|0
argument_list|,
name|GET_ALIAS_PORT
argument_list|,
name|LINK_PPTP
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindPptpOutByCallId
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_int16_t
name|src_call_id
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|i
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_PPTP
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableOut[i]
argument_list|,
argument|list_out
argument_list|)
if|if
condition|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_PPTP
operator|&&
name|lnk
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|src_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|src_port
operator|==
name|src_call_id
condition|)
break|break;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindPptpOutByPeerCallId
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_int16_t
name|dst_call_id
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|i
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_PPTP
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableOut[i]
argument_list|,
argument|list_out
argument_list|)
if|if
condition|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_PPTP
operator|&&
name|lnk
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|src_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|dst_port
operator|==
name|dst_call_id
condition|)
break|break;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindPptpInByCallId
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_int16_t
name|dst_call_id
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|i
operator|=
name|StartPointIn
argument_list|(
name|alias_addr
argument_list|,
literal|0
argument_list|,
name|LINK_PPTP
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lnk
argument_list|,
argument|&la->linkTableIn[i]
argument_list|,
argument|list_in
argument_list|)
if|if
condition|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_PPTP
operator|&&
name|lnk
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|lnk
operator|->
name|dst_port
operator|==
name|dst_call_id
condition|)
break|break;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindPptpInByPeerCallId
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_int16_t
name|alias_call_id
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
literal|0
comment|/* any */
argument_list|,
name|alias_call_id
argument_list|,
name|LINK_PPTP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindRtspOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
name|lnk
operator|=
name|FindLinkOut
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
literal|0
argument_list|,
name|link_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
literal|0
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|FindOriginalAddress
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkIn
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|alias_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
name|la
operator|->
name|newDefaultLink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|targetAddress
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
operator|(
name|alias_addr
operator|)
return|;
elseif|else
if|if
condition|(
name|la
operator|->
name|targetAddress
operator|.
name|s_addr
operator|==
name|INADDR_NONE
condition|)
return|return
operator|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
condition|?
name|la
operator|->
name|aliasAddress
else|:
name|alias_addr
return|;
else|else
return|return
operator|(
name|la
operator|->
name|targetAddress
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|lnk
operator|->
name|server
operator|!=
name|NULL
condition|)
block|{
comment|/* LSNAT link */
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|src_addr
operator|=
name|lnk
operator|->
name|server
operator|->
name|addr
expr_stmt|;
name|lnk
operator|->
name|server
operator|=
name|lnk
operator|->
name|server
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|src_addr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lnk
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
operator|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
condition|?
name|la
operator|->
name|aliasAddress
else|:
name|alias_addr
return|;
else|else
return|return
operator|(
name|lnk
operator|->
name|src_addr
operator|)
return|;
block|}
block|}
end_function

begin_function
name|struct
name|in_addr
name|FindAliasAddress
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|original_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindLinkOut
argument_list|(
name|la
argument_list|,
name|original_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
condition|?
name|la
operator|->
name|aliasAddress
else|:
name|original_addr
return|;
block|}
else|else
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
operator|(
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
condition|?
name|la
operator|->
name|aliasAddress
else|:
name|original_addr
return|;
else|else
return|return
operator|(
name|lnk
operator|->
name|alias_addr
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* External routines for getting or changing link data    (external to alias_db.c, but internal to alias*.c)      SetFragmentData(), GetFragmentData()     SetFragmentPtr(), GetFragmentPtr()     SetStateIn(), SetStateOut(), GetStateIn(), GetStateOut()     GetOriginalAddress(), GetDestAddress(), GetAliasAddress()     GetOriginalPort(), GetAliasPort()     SetAckModified(), GetAckModified()     GetDeltaAckIn(), GetDeltaSeqOut(), AddSeq()     SetProtocolFlags(), GetProtocolFlags()     SetDestCallId() */
end_comment

begin_function
name|void
name|SetFragmentAddr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|)
block|{
name|lnk
operator|->
name|data
operator|.
name|frag_addr
operator|=
name|src_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GetFragmentAddr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|in_addr
modifier|*
name|src_addr
parameter_list|)
block|{
operator|*
name|src_addr
operator|=
name|lnk
operator|->
name|data
operator|.
name|frag_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetFragmentPtr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|char
modifier|*
name|fptr
parameter_list|)
block|{
name|lnk
operator|->
name|data
operator|.
name|frag_ptr
operator|=
name|fptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GetFragmentPtr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|char
modifier|*
modifier|*
name|fptr
parameter_list|)
block|{
operator|*
name|fptr
operator|=
name|lnk
operator|->
name|data
operator|.
name|frag_ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetStateIn
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|state
parameter_list|)
block|{
comment|/* TCP input state */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ALIAS_TCP_STATE_DISCONNECTED
case|:
if|if
condition|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|out
operator|!=
name|ALIAS_TCP_STATE_CONNECTED
condition|)
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_DEAD
expr_stmt|;
else|else
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_SINGLEDEAD
expr_stmt|;
break|break;
case|case
name|ALIAS_TCP_STATE_CONNECTED
case|:
if|if
condition|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|out
operator|==
name|ALIAS_TCP_STATE_CONNECTED
condition|)
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_CONNECTED
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|_KERNEL
name|panic
argument_list|(
literal|"libalias:SetStateIn() unknown state"
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|in
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetStateOut
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|state
parameter_list|)
block|{
comment|/* TCP output state */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ALIAS_TCP_STATE_DISCONNECTED
case|:
if|if
condition|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|in
operator|!=
name|ALIAS_TCP_STATE_CONNECTED
condition|)
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_DEAD
expr_stmt|;
else|else
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_SINGLEDEAD
expr_stmt|;
break|break;
case|case
name|ALIAS_TCP_STATE_CONNECTED
case|:
if|if
condition|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|in
operator|==
name|ALIAS_TCP_STATE_CONNECTED
condition|)
name|lnk
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_CONNECTED
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|_KERNEL
name|panic
argument_list|(
literal|"libalias:SetStateOut() unknown state"
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|out
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|int
name|GetStateIn
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* TCP input state */
return|return
operator|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|in
operator|)
return|;
block|}
end_function

begin_function
name|int
name|GetStateOut
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* TCP output state */
return|return
operator|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|out
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetOriginalAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
if|if
condition|(
name|lnk
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
operator|(
name|lnk
operator|->
name|la
operator|->
name|aliasAddress
operator|)
return|;
else|else
return|return
operator|(
name|lnk
operator|->
name|src_addr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetDestAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|dst_addr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetAliasAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
if|if
condition|(
name|lnk
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
operator|(
name|lnk
operator|->
name|la
operator|->
name|aliasAddress
operator|)
return|;
else|else
return|return
operator|(
name|lnk
operator|->
name|alias_addr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetDefaultAliasAddress
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|la
operator|->
name|aliasAddress
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SetDefaultAliasAddress
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|aliasAddress
operator|=
name|alias_addr
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|GetOriginalPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|src_port
operator|)
return|;
block|}
end_function

begin_function
name|u_short
name|GetAliasPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|alias_port
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
end_ifndef

begin_function
specifier|static
name|u_short
name|GetDestPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|dst_port
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|SetAckModified
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* Indicate that ACK numbers have been modified in a TCP connection */
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|ack_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetProxyAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|proxy_addr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SetProxyAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|lnk
operator|->
name|proxy_addr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|GetProxyPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|proxy_port
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SetProxyPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|lnk
operator|->
name|proxy_port
operator|=
name|port
expr_stmt|;
block|}
end_function

begin_function
name|int
name|GetAckModified
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* See if ACK numbers have been modified */
return|return
operator|(
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|ack_modified
operator|)
return|;
block|}
end_function

begin_comment
comment|// XXX ip free
end_comment

begin_function
name|int
name|GetDeltaAckIn
parameter_list|(
name|u_long
name|ack
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* Find out how much the ACK number has been altered for an incoming TCP packet.  To do this, a circular list of ACK numbers where the TCP packet size was altered is searched. */
name|int
name|i
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|ack_diff_min
decl_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
name|ack_diff_min
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|x
operator|=
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|ack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|active
operator|==
literal|1
condition|)
block|{
name|int
name|ack_diff
decl_stmt|;
name|ack_diff
operator|=
name|SeqDiff
argument_list|(
name|x
operator|.
name|ack_new
argument_list|,
name|ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_diff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ack_diff_min
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ack_diff
operator|<
name|ack_diff_min
condition|)
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|ack_diff_min
operator|=
name|ack_diff
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|ack_diff_min
operator|=
name|ack_diff
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_comment
comment|// XXX ip free
end_comment

begin_function
name|int
name|GetDeltaSeqOut
parameter_list|(
name|u_long
name|seq
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* Find out how much the sequence number has been altered for an outgoing TCP packet.  To do this, a circular list of ACK numbers where the TCP packet size was altered is searched. */
name|int
name|i
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|seq_diff_min
decl_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
name|seq_diff_min
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|x
operator|=
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|ack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|active
operator|==
literal|1
condition|)
block|{
name|int
name|seq_diff
decl_stmt|;
name|seq_diff
operator|=
name|SeqDiff
argument_list|(
name|x
operator|.
name|ack_old
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_diff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seq_diff_min
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seq_diff
operator|<
name|seq_diff_min
condition|)
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|seq_diff_min
operator|=
name|seq_diff
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|seq_diff_min
operator|=
name|seq_diff
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_comment
comment|// XXX ip free
end_comment

begin_function
name|void
name|AddSeq
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|delta
parameter_list|,
name|u_int
name|ip_hl
parameter_list|,
name|u_short
name|ip_len
parameter_list|,
name|u_long
name|th_seq
parameter_list|,
name|u_int
name|th_off
parameter_list|)
block|{
comment|/* When a TCP packet has been altered in length, save this information in a circular list.  If enough packets have been altered, then this list will begin to overwrite itself. */
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hlen
operator|=
operator|(
name|ip_hl
operator|+
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
name|x
operator|.
name|ack_old
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th_seq
argument_list|)
operator|+
name|dlen
argument_list|)
expr_stmt|;
name|x
operator|.
name|ack_new
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th_seq
argument_list|)
operator|+
name|dlen
operator|+
name|delta
argument_list|)
expr_stmt|;
name|x
operator|.
name|delta
operator|=
name|delta
expr_stmt|;
name|x
operator|.
name|active
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|index
expr_stmt|;
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|ack
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|N_LINK_TCP_DATA
condition|)
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|index
operator|=
literal|0
expr_stmt|;
else|else
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|state
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetExpire
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|expire
parameter_list|)
block|{
if|if
condition|(
name|expire
operator|==
literal|0
condition|)
block|{
name|lnk
operator|->
name|flags
operator|&=
operator|~
name|LINK_PERMANENT
expr_stmt|;
name|DeleteLink
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expire
operator|==
operator|-
literal|1
condition|)
block|{
name|lnk
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expire
operator|>
literal|0
condition|)
block|{
name|lnk
operator|->
name|expire_time
operator|=
name|expire
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/SetExpire(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in expire parameter\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|ClearCheckNewLink
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|newDefaultLink
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetProtocolFlags
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|pflags
parameter_list|)
block|{
name|lnk
operator|->
name|pflags
operator|=
name|pflags
expr_stmt|;
empty_stmt|;
block|}
end_function

begin_function
name|int
name|GetProtocolFlags
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
return|return
operator|(
name|lnk
operator|->
name|pflags
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SetDestCallId
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|u_int16_t
name|cid
parameter_list|)
block|{
name|struct
name|libalias
modifier|*
name|la
init|=
name|lnk
operator|->
name|la
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|ReLink
argument_list|(
name|lnk
argument_list|,
name|lnk
operator|->
name|src_addr
argument_list|,
name|lnk
operator|->
name|dst_addr
argument_list|,
name|lnk
operator|->
name|alias_addr
argument_list|,
name|lnk
operator|->
name|src_port
argument_list|,
name|cid
argument_list|,
name|lnk
operator|->
name|alias_port
argument_list|,
name|lnk
operator|->
name|link_type
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Miscellaneous Functions      HouseKeeping()     InitPacketAliasLog()     UninitPacketAliasLog() */
end_comment

begin_comment
comment|/*     Whenever an outgoing or incoming packet is handled, HouseKeeping()     is called to find and remove timed-out aliasing links.  Logic exists     to sweep through the entire table and linked list structure     every 60 seconds.      (prototype in alias_local.h) */
end_comment

begin_function
name|void
name|HouseKeeping
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
endif|#
directive|endif
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* 	 * Save system time (seconds) in global variable timeStamp for use 	 * by other functions. This is done so as not to unnecessarily 	 * waste timeline by making system calls. 	 */
ifdef|#
directive|ifdef
name|_KERNEL
name|la
operator|->
name|timeStamp
operator|=
name|time_uptime
expr_stmt|;
else|#
directive|else
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|la
operator|->
name|timeStamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
comment|/* Compute number of spokes (output table link chains) to cover */
name|n
operator|=
name|LINK_TABLE_OUT_SIZE
operator|*
operator|(
name|la
operator|->
name|timeStamp
operator|-
name|la
operator|->
name|lastCleanupTime
operator|)
expr_stmt|;
name|n
operator|/=
name|ALIAS_CLEANUP_INTERVAL_SECS
expr_stmt|;
comment|/* Handle different cases */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|>
name|ALIAS_CLEANUP_MAX_SPOKES
condition|)
name|n
operator|=
name|ALIAS_CLEANUP_MAX_SPOKES
expr_stmt|;
name|la
operator|->
name|lastCleanupTime
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|IncrementalCleanup
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/HouseKeeping(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"something unexpected in time values\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|la
operator|->
name|lastCleanupTime
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Init the log file and enable logging */
end_comment

begin_function
specifier|static
name|int
name|InitPacketAliasLog
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|la
operator|->
name|logDesc
operator|=
name|malloc
argument_list|(
name|LIBALIAS_BUF_SIZE
argument_list|)
operator|)
condition|)
empty_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|la
operator|->
name|logDesc
operator|=
name|fopen
argument_list|(
literal|"/var/log/alias.log"
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|la
operator|->
name|logDesc
argument_list|,
literal|"PacketAlias/InitPacketAliasLog: Packet alias logging enabled.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* log initialization failed */
name|la
operator|->
name|packetAliasMode
operator||=
name|PKT_ALIAS_LOG
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the log-file and disable logging. */
end_comment

begin_function
specifier|static
name|void
name|UninitPacketAliasLog
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|logDesc
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|free
argument_list|(
name|la
operator|->
name|logDesc
argument_list|)
expr_stmt|;
else|#
directive|else
name|fclose
argument_list|(
name|la
operator|->
name|logDesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|la
operator|->
name|logDesc
operator|=
name|NULL
expr_stmt|;
block|}
name|la
operator|->
name|packetAliasMode
operator|&=
operator|~
name|PKT_ALIAS_LOG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Outside world interfaces  -- "outside world" means other than alias*.c routines --      PacketAliasRedirectPort()     PacketAliasAddServer()     PacketAliasRedirectProto()     PacketAliasRedirectAddr()     PacketAliasRedirectDynamic()     PacketAliasRedirectDelete()     PacketAliasSetAddress()     PacketAliasInit()     PacketAliasUninit()     PacketAliasSetMode()  (prototypes in alias.h) */
end_comment

begin_comment
comment|/* Redirection from a specific public addr:port to a    private addr:port */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|LibAliasRedirectPort
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"only TCP and UDP protocols allowed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lnk
operator|=
name|NULL
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|lnk
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectPort(): "
literal|"call to AddLink() failed\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|getout
label|:
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add server to the pool of servers */
end_comment

begin_function
name|int
name|LibAliasAddServer
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|in_addr
name|addr
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|la
expr_stmt|;
name|server
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|!=
name|NULL
condition|)
block|{
name|struct
name|server
modifier|*
name|head
decl_stmt|;
name|server
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|server
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|head
operator|=
name|lnk
operator|->
name|server
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|server
operator|->
name|next
operator|=
name|server
expr_stmt|;
else|else
block|{
name|struct
name|server
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|head
init|;
name|s
operator|->
name|next
operator|!=
name|head
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
empty_stmt|;
name|s
operator|->
name|next
operator|=
name|server
expr_stmt|;
name|server
operator|->
name|next
operator|=
name|head
expr_stmt|;
block|}
name|lnk
operator|->
name|server
operator|=
name|server
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Redirect packets of a given IP protocol from a specific    public address to a private address */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|LibAliasRedirectProto
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|lnk
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectProto(): "
literal|"call to AddLink() failed\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Static address translation */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|LibAliasRedirectAddr
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|AddLink
argument_list|(
name|la
argument_list|,
name|src_addr
argument_list|,
name|la
operator|->
name|nullAddress
argument_list|,
name|alias_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|lnk
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectAddr(): "
literal|"call to AddLink() failed\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the aliasing link dynamic */
end_comment

begin_function
name|int
name|LibAliasRedirectDynamic
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|la
expr_stmt|;
if|if
condition|(
name|lnk
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|lnk
operator|->
name|flags
operator|&=
operator|~
name|LINK_PERMANENT
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
name|LibAliasRedirectDelete
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
comment|/* This is a dangerous function to put in the API,    because an invalid pointer can crash the program. */
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|DeleteLink
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LibAliasSetAddress
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
operator|&&
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|addr
operator|.
name|s_addr
condition|)
name|CleanupAliasData
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|aliasAddress
operator|=
name|addr
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LibAliasSetTarget
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|target_addr
parameter_list|)
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|targetAddress
operator|=
name|target_addr
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finishoff
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|instancehead
argument_list|)
condition|)
name|LibAliasUninit
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|instancehead
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|libalias
modifier|*
name|LibAliasInit
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
block|{
name|la
operator|=
name|calloc
argument_list|(
sizeof|sizeof
expr|*
name|la
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
return|return
operator|(
name|la
operator|)
return|;
ifndef|#
directive|ifndef
name|_KERNEL
comment|/* kernel cleans up on module unload */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|instancehead
argument_list|)
condition|)
name|atexit
argument_list|(
name|finishoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|instancehead
argument_list|,
name|la
argument_list|,
name|instancelist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|la
operator|->
name|timeStamp
operator|=
name|time_uptime
expr_stmt|;
name|la
operator|->
name|lastCleanupTime
operator|=
name|time_uptime
expr_stmt|;
else|#
directive|else
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|la
operator|->
name|timeStamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|la
operator|->
name|lastCleanupTime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_OUT_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|la
operator|->
name|linkTableOut
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_IN_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|la
operator|->
name|linkTableIn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIBALIAS_LOCK_INIT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|CleanupAliasData
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
block|}
name|la
operator|->
name|aliasAddress
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|la
operator|->
name|targetAddress
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|la
operator|->
name|icmpLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|udpLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|tcpLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|pptpLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|protoLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|fragmentIdLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|fragmentPtrLinkCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|sockCount
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|packetAliasMode
operator|=
name|PKT_ALIAS_SAME_PORTS
ifndef|#
directive|ifndef
name|NO_USE_SOCKETS
operator||
name|PKT_ALIAS_USE_SOCKETS
endif|#
directive|endif
operator||
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
name|la
operator|->
name|fireWallFD
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|_KERNEL
name|LibAliasRefreshModules
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|la
operator|)
return|;
block|}
end_function

begin_function
name|void
name|LibAliasUninit
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|CleanupAliasData
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
name|UninitPacketAliasLog
argument_list|(
name|la
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
name|UninitPunchFW
argument_list|(
name|la
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_REMOVE
argument_list|(
name|la
argument_list|,
name|instancelist
argument_list|)
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|LIBALIAS_LOCK_DESTROY
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change mode for some operations */
end_comment

begin_function
name|unsigned
name|int
name|LibAliasSetMode
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
comment|/* Which state to bring flags to */
name|unsigned
name|int
name|mask
comment|/* Mask of which flags to affect (use 0 to 				 * do a probe for flag values) */
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Enable logging? */
if|if
condition|(
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
comment|/* Do the enable */
if|if
condition|(
name|InitPacketAliasLog
argument_list|(
name|la
argument_list|)
operator|==
name|ENOMEM
condition|)
goto|goto
name|getout
goto|;
block|}
elseif|else
comment|/* _Disable_ logging? */
if|if
condition|(
operator|~
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|UninitPacketAliasLog
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
comment|/* Start punching holes in the firewall? */
if|if
condition|(
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_PUNCH_FW
condition|)
block|{
name|InitPunchFW
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Stop punching holes in the firewall? */
if|if
condition|(
operator|~
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_PUNCH_FW
condition|)
block|{
name|UninitPunchFW
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Other flags can be set/cleared without special action */
name|la
operator|->
name|packetAliasMode
operator|=
operator|(
name|flags
operator|&
name|mask
operator|)
operator||
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
name|res
operator|=
name|la
operator|->
name|packetAliasMode
expr_stmt|;
name|getout
label|:
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|LibAliasCheckNewLink
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|res
operator|=
name|la
operator|->
name|newDefaultLink
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
end_ifndef

begin_comment
comment|/*****************   Code to support firewall punching.  This shouldn't really be in this   file, but making variables global is evil too.   ****************/
end_comment

begin_comment
comment|/* Firewall include files */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_comment
comment|/*  * helper function, updates the pointer to cmd with the length  * of the current command, and also cleans up the first word of  * the new command in case it has been clobbered before.  */
end_comment

begin_function
specifier|static
name|ipfw_insn
modifier|*
name|next_cmd
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|)
block|{
name|cmd
operator|+=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A function to fill simple commands of size 1.  * Existing flags are preserved.  */
end_comment

begin_function
specifier|static
name|ipfw_insn
modifier|*
name|fill_cmd
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|enum
name|ipfw_opcodes
name|opcode
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|u_int16_t
name|arg
parameter_list|)
block|{
name|cmd
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|cmd
operator|->
name|len
operator|=
operator|(
operator|(
name|cmd
operator|->
name|len
operator||
name|flags
operator|)
operator|&
operator|(
name|F_NOT
operator||
name|F_OR
operator|)
operator|)
operator||
operator|(
name|size
operator|&
name|F_LEN_MASK
operator|)
expr_stmt|;
name|cmd
operator|->
name|arg1
operator|=
name|arg
expr_stmt|;
return|return
name|next_cmd
argument_list|(
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ipfw_insn
modifier|*
name|fill_ip
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd1
parameter_list|,
name|enum
name|ipfw_opcodes
name|opcode
parameter_list|,
name|u_int32_t
name|addr
parameter_list|)
block|{
name|ipfw_insn_ip
modifier|*
name|cmd
init|=
operator|(
name|ipfw_insn_ip
operator|*
operator|)
name|cmd1
decl_stmt|;
name|cmd
operator|->
name|addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
return|return
name|fill_cmd
argument_list|(
name|cmd1
argument_list|,
name|opcode
argument_list|,
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ipfw_insn
modifier|*
name|fill_one_port
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd1
parameter_list|,
name|enum
name|ipfw_opcodes
name|opcode
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
block|{
name|ipfw_insn_u16
modifier|*
name|cmd
init|=
operator|(
name|ipfw_insn_u16
operator|*
operator|)
name|cmd1
decl_stmt|;
name|cmd
operator|->
name|ports
index|[
literal|0
index|]
operator|=
name|cmd
operator|->
name|ports
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
return|return
name|fill_cmd
argument_list|(
name|cmd1
argument_list|,
name|opcode
argument_list|,
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u16
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fill_rule
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|int
name|rulenum
parameter_list|,
name|enum
name|ipfw_opcodes
name|action
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|in_addr
name|sa
parameter_list|,
name|u_int16_t
name|sp
parameter_list|,
name|struct
name|in_addr
name|da
parameter_list|,
name|u_int16_t
name|dp
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
init|=
operator|(
expr|struct
name|ip_fw
operator|*
operator|)
name|buf
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
init|=
operator|(
name|ipfw_insn
operator|*
operator|)
name|rule
operator|->
name|cmd
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|rule
operator|->
name|rulenum
operator|=
name|rulenum
expr_stmt|;
name|cmd
operator|=
name|fill_cmd
argument_list|(
name|cmd
argument_list|,
name|O_PROTO
argument_list|,
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|fill_ip
argument_list|(
name|cmd
argument_list|,
name|O_IP_SRC
argument_list|,
name|sa
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|fill_one_port
argument_list|(
name|cmd
argument_list|,
name|O_IP_SRCPORT
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|fill_ip
argument_list|(
name|cmd
argument_list|,
name|O_IP_DST
argument_list|,
name|da
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|fill_one_port
argument_list|(
name|cmd
argument_list|,
name|O_IP_DSTPORT
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|rule
operator|->
name|act_ofs
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cmd
operator|-
operator|(
name|u_int32_t
operator|*
operator|)
name|rule
operator|->
name|cmd
expr_stmt|;
name|cmd
operator|=
name|fill_cmd
argument_list|(
name|cmd
argument_list|,
name|action
argument_list|,
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rule
operator|->
name|cmd_len
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cmd
operator|-
operator|(
name|u_int32_t
operator|*
operator|)
name|rule
operator|->
name|cmd
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|cmd
operator|-
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ClearAllFWHoles
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|fw_setfield
parameter_list|(
name|la
parameter_list|,
name|field
parameter_list|,
name|num
parameter_list|)
define|\
value|do {                                                    \     (field)[(num) - la->fireWallBaseNum] = 1;               \ }
comment|/*lint -save -e717 */
value|while(0)
end_define

begin_comment
comment|/* lint -restore */
end_comment

begin_define
define|#
directive|define
name|fw_clrfield
parameter_list|(
name|la
parameter_list|,
name|field
parameter_list|,
name|num
parameter_list|)
define|\
value|do {                                                    \     (field)[(num) - la->fireWallBaseNum] = 0;               \ }
comment|/*lint -save -e717 */
value|while(0)
end_define

begin_comment
comment|/* lint -restore */
end_comment

begin_define
define|#
directive|define
name|fw_tstfield
parameter_list|(
name|la
parameter_list|,
name|field
parameter_list|,
name|num
parameter_list|)
value|((field)[(num) - la->fireWallBaseNum])
end_define

begin_function
specifier|static
name|void
name|InitPunchFW
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|fireWallField
operator|=
name|malloc
argument_list|(
name|la
operator|->
name|fireWallNumNums
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|fireWallField
condition|)
block|{
name|memset
argument_list|(
name|la
operator|->
name|fireWallField
argument_list|,
literal|0
argument_list|,
name|la
operator|->
name|fireWallNumNums
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|fireWallFD
operator|<
literal|0
condition|)
block|{
name|la
operator|->
name|fireWallFD
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_RAW
argument_list|)
expr_stmt|;
block|}
name|ClearAllFWHoles
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|fireWallActiveNum
operator|=
name|la
operator|->
name|fireWallBaseNum
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|UninitPunchFW
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ClearAllFWHoles
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|fireWallFD
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|la
operator|->
name|fireWallFD
argument_list|)
expr_stmt|;
name|la
operator|->
name|fireWallFD
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|fireWallField
condition|)
name|free
argument_list|(
name|la
operator|->
name|fireWallField
argument_list|)
expr_stmt|;
name|la
operator|->
name|fireWallField
operator|=
name|NULL
expr_stmt|;
name|la
operator|->
name|packetAliasMode
operator|&=
operator|~
name|PKT_ALIAS_PUNCH_FW
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a certain link go through the firewall */
end_comment

begin_function
name|void
name|PunchFWHole
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Result code */
name|struct
name|ip_fw
name|rule
decl_stmt|;
comment|/* On-the-fly built rule */
name|int
name|fwhole
decl_stmt|;
comment|/* Where to punch hole */
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|=
name|lnk
operator|->
name|la
expr_stmt|;
comment|/* Don't do anything unless we are asked to */
if|if
condition|(
operator|!
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PUNCH_FW
operator|)
operator|||
name|la
operator|->
name|fireWallFD
operator|<
literal|0
operator|||
name|lnk
operator|->
name|link_type
operator|!=
name|LINK_TCP
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|rule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|rule
argument_list|)
expr_stmt|;
comment|/** Build rule **/
comment|/* Find empty slot */
for|for
control|(
name|fwhole
operator|=
name|la
operator|->
name|fireWallActiveNum
init|;
name|fwhole
operator|<
name|la
operator|->
name|fireWallBaseNum
operator|+
name|la
operator|->
name|fireWallNumNums
operator|&&
name|fw_tstfield
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|fireWallField
argument_list|,
name|fwhole
argument_list|)
condition|;
name|fwhole
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fwhole
operator|==
name|la
operator|->
name|fireWallBaseNum
operator|+
name|la
operator|->
name|fireWallNumNums
condition|)
block|{
for|for
control|(
name|fwhole
operator|=
name|la
operator|->
name|fireWallBaseNum
init|;
name|fwhole
operator|<
name|la
operator|->
name|fireWallActiveNum
operator|&&
name|fw_tstfield
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|fireWallField
argument_list|,
name|fwhole
argument_list|)
condition|;
name|fwhole
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fwhole
operator|==
name|la
operator|->
name|fireWallActiveNum
condition|)
block|{
comment|/* No rule point empty - we can't punch more holes. */
name|la
operator|->
name|fireWallActiveNum
operator|=
name|la
operator|->
name|fireWallBaseNum
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libalias: Unable to create firewall hole!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
comment|/* Start next search at next position */
name|la
operator|->
name|fireWallActiveNum
operator|=
name|fwhole
operator|+
literal|1
expr_stmt|;
comment|/* 	 * generate two rules of the form 	 * 	 * add fwhole accept tcp from OAddr OPort to DAddr DPort add fwhole 	 * accept tcp from DAddr DPort to OAddr OPort 	 */
if|if
condition|(
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
operator|!=
literal|0
operator|&&
name|GetDestPort
argument_list|(
name|lnk
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int32_t
name|rulebuf
index|[
literal|255
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fill_rule
argument_list|(
name|rulebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rulebuf
argument_list|)
argument_list|,
name|fwhole
argument_list|,
name|O_ACCEPT
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|,
name|GetDestAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|GetDestPort
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|setsockopt
argument_list|(
name|la
operator|->
name|fireWallFD
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FW_ADD
argument_list|,
name|rulebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"alias punch inbound(1) setsockopt(IP_FW_ADD)"
argument_list|)
expr_stmt|;
name|i
operator|=
name|fill_rule
argument_list|(
name|rulebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rulebuf
argument_list|)
argument_list|,
name|fwhole
argument_list|,
name|O_ACCEPT
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|GetDestAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|GetDestPort
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|,
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|setsockopt
argument_list|(
name|la
operator|->
name|fireWallFD
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FW_ADD
argument_list|,
name|rulebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"alias punch inbound(2) setsockopt(IP_FW_ADD)"
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate hole applied */
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|fwhole
operator|=
name|fwhole
expr_stmt|;
name|fw_setfield
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|fireWallField
argument_list|,
name|fwhole
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a hole in a firewall associated with a particular alias    lnk.  Calling this too often is harmless. */
end_comment

begin_function
specifier|static
name|void
name|ClearFWHole
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|=
name|lnk
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|lnk
operator|->
name|link_type
operator|==
name|LINK_TCP
condition|)
block|{
name|int
name|fwhole
init|=
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|fwhole
decl_stmt|;
comment|/* Where is the firewall 							 * hole? */
name|struct
name|ip_fw
name|rule
decl_stmt|;
if|if
condition|(
name|fwhole
operator|<
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|rule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|rule
argument_list|)
expr_stmt|;
comment|/* useless for ipfw2 */
while|while
condition|(
operator|!
name|setsockopt
argument_list|(
name|la
operator|->
name|fireWallFD
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FW_DEL
argument_list|,
operator|&
name|fwhole
argument_list|,
sizeof|sizeof
name|fwhole
argument_list|)
condition|)
empty_stmt|;
name|fw_clrfield
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|fireWallField
argument_list|,
name|fwhole
argument_list|)
expr_stmt|;
name|lnk
operator|->
name|data
operator|.
name|tcp
operator|->
name|fwhole
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out the entire range dedicated to firewall holes. */
end_comment

begin_function
specifier|static
name|void
name|ClearAllFWHoles
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|struct
name|ip_fw
name|rule
decl_stmt|;
comment|/* On-the-fly built rule */
name|int
name|i
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|fireWallFD
operator|<
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|rule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|rule
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|la
operator|->
name|fireWallBaseNum
init|;
name|i
operator|<
name|la
operator|->
name|fireWallBaseNum
operator|+
name|la
operator|->
name|fireWallNumNums
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|i
decl_stmt|;
while|while
condition|(
operator|!
name|setsockopt
argument_list|(
name|la
operator|->
name|fireWallFD
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FW_DEL
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
name|r
argument_list|)
condition|)
empty_stmt|;
block|}
comment|/* XXX: third arg correct here ? /phk */
name|memset
argument_list|(
name|la
operator|->
name|fireWallField
argument_list|,
literal|0
argument_list|,
name|la
operator|->
name|fireWallNumNums
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|LibAliasSetFWBase
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|unsigned
name|int
name|base
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
name|la
operator|->
name|fireWallBaseNum
operator|=
name|base
expr_stmt|;
name|la
operator|->
name|fireWallNumNums
operator|=
name|num
expr_stmt|;
endif|#
directive|endif
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LibAliasSetSkinnyPort
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|)
block|{
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|skinnyPort
operator|=
name|port
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

