begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Charles Mott<cm@linktel.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*     Alias_ftp.c performs special processing for FTP sessions under     TCP.  Specifically, when a PORT/EPRT command from the client     side or 227/229 reply from the server is sent, it is intercepted     and modified.  The address is changed to the gateway machine     and an aliasing port is used.      For this routine to work, the message must fit entirely into a     single TCP packet.  This is typically the case, but exceptions     can easily be envisioned under the actual specifications.      Probably the most troubling aspect of the approach taken here is     that the new message will typically be a different length, and     this causes a certain amount of bookkeeping to keep track of the     changes of sequence and acknowledgment numbers, since the client     machine is totally unaware of the modification to the TCP stream.       References: RFC 959, RFC 2428.      Initial version:  August, 1996  (cjm)      Version 1.6 	 Brian Somers and Martin Renters identified an IP checksum 	 error for modified IP packets.      Version 1.7:  January 9, 1996 (cjm) 	 Differential checksum computation for change 	 in IP packet length.      Version 2.1:  May, 1997 (cjm) 	 Very minor changes to conform with 	 local/global/function naming conventions 	 within the packet aliasing module.      Version 3.1:  May, 2000 (eds) 	 Add support for passive mode, alias the 227 replies.      See HISTORY file for record of revisions. */
end_comment

begin_comment
comment|/* Includes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_mod.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_include
include|#
directive|include
file|"alias_mod.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FTP_CONTROL_PORT_NUMBER
value|21
end_define

begin_function_decl
specifier|static
name|void
name|AliasHandleFtpOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|fingerprint
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_data
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|->
name|dport
operator|==
name|NULL
operator|||
name|ah
operator|->
name|sport
operator|==
name|NULL
operator|||
name|ah
operator|->
name|lnk
operator|==
name|NULL
operator|||
name|ah
operator|->
name|maxpktsize
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|dport
argument_list|)
operator|==
name|FTP_CONTROL_PORT_NUMBER
operator|||
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|sport
argument_list|)
operator|==
name|FTP_CONTROL_PORT_NUMBER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|protohandler
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_data
modifier|*
name|ah
parameter_list|)
block|{
name|AliasHandleFtpOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|ah
operator|->
name|lnk
argument_list|,
name|ah
operator|->
name|maxpktsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|proto_handler
name|handlers
index|[]
init|=
block|{
block|{
operator|.
name|pri
operator|=
literal|80
block|,
operator|.
name|dir
operator|=
name|OUT
block|,
operator|.
name|proto
operator|=
name|TCP
block|,
operator|.
name|fingerprint
operator|=
operator|&
name|fingerprint
block|,
operator|.
name|protohandler
operator|=
operator|&
name|protohandler
block|}
block|,
block|{
name|EOH
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mod_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|LibAliasAttachHandlers
argument_list|(
name|handlers
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|LibAliasDetachHandlers
argument_list|(
name|handlers
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
endif|#
directive|endif
name|moduledata_t
name|alias_mod
init|=
block|{
literal|"alias_ftp"
block|,
name|mod_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|alias_ftp
argument_list|,
name|alias_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|alias_ftp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|alias_ftp
argument_list|,
name|libalias
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FTP_CONTROL_PORT_NUMBER
value|21
end_define

begin_define
define|#
directive|define
name|MAX_MESSAGE_SIZE
value|128
end_define

begin_comment
comment|/* FTP protocol flags. */
end_comment

begin_define
define|#
directive|define
name|WAIT_CRLF
value|0x01
end_define

begin_enum
enum|enum
name|ftp_message_type
block|{
name|FTP_PORT_COMMAND
block|,
name|FTP_EPRT_COMMAND
block|,
name|FTP_227_REPLY
block|,
name|FTP_229_REPLY
block|,
name|FTP_UNKNOWN_MESSAGE
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|ParseFtpPortCommand
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseFtpEprtCommand
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseFtp227Reply
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseFtp229Reply
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NewFtpMessage
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|AliasHandleFtpOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
comment|/* IP packet to examine/patch */
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
comment|/* The link to go through (aliased port) */
name|int
name|maxpacketsize
comment|/* The maximum size this packet can grow to 	(including headers) */
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|,
name|pflags
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|int
name|ftp_message_type
decl_stmt|;
comment|/* Calculate data length of TCP packet */
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
comment|/* Place string pointer and beginning of data */
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
name|sptr
operator|+=
name|hlen
expr_stmt|;
comment|/*  * Check that data length is not too long and previous message was  * properly terminated with CRLF.  */
name|pflags
operator|=
name|GetProtocolFlags
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|MAX_MESSAGE_SIZE
operator|&&
operator|!
operator|(
name|pflags
operator|&
name|WAIT_CRLF
operator|)
condition|)
block|{
name|ftp_message_type
operator|=
name|FTP_UNKNOWN_MESSAGE
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|tc
operator|->
name|th_dport
argument_list|)
operator|==
name|FTP_CONTROL_PORT_NUMBER
condition|)
block|{
comment|/*  * When aliasing a client, check for the PORT/EPRT command.  */
if|if
condition|(
name|ParseFtpPortCommand
argument_list|(
name|la
argument_list|,
name|sptr
argument_list|,
name|dlen
argument_list|)
condition|)
name|ftp_message_type
operator|=
name|FTP_PORT_COMMAND
expr_stmt|;
elseif|else
if|if
condition|(
name|ParseFtpEprtCommand
argument_list|(
name|la
argument_list|,
name|sptr
argument_list|,
name|dlen
argument_list|)
condition|)
name|ftp_message_type
operator|=
name|FTP_EPRT_COMMAND
expr_stmt|;
block|}
else|else
block|{
comment|/*  * When aliasing a server, check for the 227/229 reply.  */
if|if
condition|(
name|ParseFtp227Reply
argument_list|(
name|la
argument_list|,
name|sptr
argument_list|,
name|dlen
argument_list|)
condition|)
name|ftp_message_type
operator|=
name|FTP_227_REPLY
expr_stmt|;
elseif|else
if|if
condition|(
name|ParseFtp229Reply
argument_list|(
name|la
argument_list|,
name|sptr
argument_list|,
name|dlen
argument_list|)
condition|)
block|{
name|ftp_message_type
operator|=
name|FTP_229_REPLY
expr_stmt|;
name|la
operator|->
name|true_addr
operator|.
name|s_addr
operator|=
name|pip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftp_message_type
operator|!=
name|FTP_UNKNOWN_MESSAGE
condition|)
name|NewFtpMessage
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|lnk
argument_list|,
name|maxpacketsize
argument_list|,
name|ftp_message_type
argument_list|)
expr_stmt|;
block|}
comment|/* Track the msgs which are CRLF term'd for PORT/PASV FW breach */
if|if
condition|(
name|dlen
condition|)
block|{
comment|/* only if there's data */
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
comment|/* start over at beginning */
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* recalc tlen, pkt may 						 * have grown */
if|if
condition|(
name|sptr
index|[
name|tlen
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|sptr
index|[
name|tlen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|pflags
operator|&=
operator|~
name|WAIT_CRLF
expr_stmt|;
else|else
name|pflags
operator||=
name|WAIT_CRLF
expr_stmt|;
name|SetProtocolFlags
argument_list|(
name|lnk
argument_list|,
name|pflags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ParseFtpPortCommand
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|sptr
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|u_int8_t
name|octet
decl_stmt|;
comment|/* Format: "PORT A,D,D,R,PO,RT". */
comment|/* Return if data length is too short. */
if|if
condition|(
name|dlen
operator|<
literal|18
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|addr
operator|=
name|port
operator|=
name|octet
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|sptr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|4
case|:
if|if
condition|(
name|ch
operator|==
literal|'P'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|3
case|:
if|if
condition|(
name|ch
operator|==
literal|'O'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|ch
operator|==
literal|'R'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'T'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
else|else
name|state
operator|++
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|5
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
case|case
literal|11
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|octet
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|8
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|octet
operator|=
literal|10
operator|*
name|octet
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
name|addr
operator|=
operator|(
name|addr
operator|<<
literal|8
operator|)
operator|+
name|octet
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|10
case|:
case|case
literal|12
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|octet
operator|=
literal|10
operator|*
name|octet
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
operator|||
name|state
operator|==
literal|12
condition|)
block|{
name|port
operator|=
operator|(
name|port
operator|<<
literal|8
operator|)
operator|+
name|octet
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|13
condition|)
block|{
name|la
operator|->
name|true_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|la
operator|->
name|true_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ParseFtpEprtCommand
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|sptr
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
name|delim
decl_stmt|;
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|u_int8_t
name|octet
decl_stmt|;
comment|/* Format: "EPRT |1|A.D.D.R|PORT|". */
comment|/* Return if data length is too short. */
if|if
condition|(
name|dlen
operator|<
literal|18
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|addr
operator|=
name|port
operator|=
name|octet
operator|=
literal|0
expr_stmt|;
name|delim
operator|=
literal|'|'
expr_stmt|;
comment|/* XXX gcc -Wuninitialized */
name|state
operator|=
operator|-
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|sptr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|4
case|:
if|if
condition|(
name|ch
operator|==
literal|'E'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|3
case|:
if|if
condition|(
name|ch
operator|==
literal|'P'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|ch
operator|==
literal|'R'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'T'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|delim
operator|=
name|ch
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'1'
condition|)
comment|/* IPv4 address */
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ch
operator|==
name|delim
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|3
case|:
case|case
literal|5
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|octet
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|8
case|:
case|case
literal|10
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|octet
operator|=
literal|10
operator|*
name|octet
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
operator|||
name|state
operator|==
literal|10
condition|)
block|{
name|addr
operator|=
operator|(
name|addr
operator|<<
literal|8
operator|)
operator|+
name|octet
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|port
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|12
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|port
operator|=
literal|10
operator|*
name|port
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|delim
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|13
condition|)
block|{
name|la
operator|->
name|true_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|la
operator|->
name|true_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ParseFtp227Reply
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|sptr
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|u_int8_t
name|octet
decl_stmt|;
comment|/* Format: "227 Entering Passive Mode (A,D,D,R,PO,RT)" */
comment|/* Return if data length is too short. */
if|if
condition|(
name|dlen
operator|<
literal|17
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|addr
operator|=
name|port
operator|=
name|octet
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|sptr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|3
case|:
if|if
condition|(
name|ch
operator|==
literal|'2'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|ch
operator|==
literal|'2'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'7'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ch
operator|==
literal|'('
condition|)
name|state
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|5
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
case|case
literal|11
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|octet
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|8
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|octet
operator|=
literal|10
operator|*
name|octet
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
name|addr
operator|=
operator|(
name|addr
operator|<<
literal|8
operator|)
operator|+
name|octet
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|10
case|:
case|case
literal|12
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|octet
operator|=
literal|10
operator|*
name|octet
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
operator|||
operator|(
name|state
operator|==
literal|12
operator|&&
name|ch
operator|==
literal|')'
operator|)
condition|)
block|{
name|port
operator|=
operator|(
name|port
operator|<<
literal|8
operator|)
operator|+
name|octet
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|13
condition|)
block|{
name|la
operator|->
name|true_port
operator|=
name|port
expr_stmt|;
name|la
operator|->
name|true_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ParseFtp229Reply
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|sptr
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
name|delim
decl_stmt|;
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|u_short
name|port
decl_stmt|;
comment|/* Format: "229 Entering Extended Passive Mode (|||PORT|)" */
comment|/* Return if data length is too short. */
if|if
condition|(
name|dlen
operator|<
literal|11
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|port
operator|=
literal|0
expr_stmt|;
name|delim
operator|=
literal|'|'
expr_stmt|;
comment|/* XXX gcc -Wuninitialized */
name|state
operator|=
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|sptr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|3
case|:
if|if
condition|(
name|ch
operator|==
literal|'2'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|ch
operator|==
literal|'2'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'9'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ch
operator|==
literal|'('
condition|)
name|state
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|delim
operator|=
name|ch
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
if|if
condition|(
name|ch
operator|==
name|delim
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|port
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|port
operator|=
literal|10
operator|*
name|port
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|delim
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|ch
operator|==
literal|')'
condition|)
name|state
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|7
condition|)
block|{
name|la
operator|->
name|true_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|NewFtpMessage
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|ftp_message_type
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|ftp_lnk
decl_stmt|;
comment|/* Security checks. */
if|if
condition|(
name|pip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|la
operator|->
name|true_addr
operator|.
name|s_addr
condition|)
return|return;
if|if
condition|(
name|la
operator|->
name|true_port
operator|<
name|IPPORT_RESERVED
condition|)
return|return;
comment|/* Establish link to address and port found in FTP control message. */
name|ftp_lnk
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|la
operator|->
name|true_addr
argument_list|,
name|GetDestAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|htons
argument_list|(
name|la
operator|->
name|true_port
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftp_lnk
operator|!=
name|NULL
condition|)
block|{
name|int
name|slen
decl_stmt|,
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
comment|/* Punch hole in firewall */
name|PunchFWHole
argument_list|(
name|ftp_lnk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate data length of TCP packet */
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
comment|/* Create new FTP message. */
block|{
name|char
name|stemp
index|[
name|MAX_MESSAGE_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|struct
name|in_addr
name|alias_address
decl_stmt|;
comment|/* Decompose alias address into quad format */
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|alias_address
operator|.
name|s_addr
expr_stmt|;
name|a1
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|a2
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|a3
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|a4
operator|=
operator|*
name|ptr
expr_stmt|;
name|alias_port
operator|=
name|GetAliasPort
argument_list|(
name|ftp_lnk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ftp_message_type
condition|)
block|{
case|case
name|FTP_PORT_COMMAND
case|:
case|case
name|FTP_227_REPLY
case|:
comment|/* Decompose alias port into pair format. */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|alias_port
expr_stmt|;
name|p1
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|p2
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|ftp_message_type
operator|==
name|FTP_PORT_COMMAND
condition|)
block|{
comment|/* Generate PORT command string. */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"PORT %d,%d,%d,%d,%d,%d\r\n"
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate 227 reply string. */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n"
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FTP_EPRT_COMMAND
case|:
comment|/* Generate EPRT command string. */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"EPRT |1|%d.%d.%d.%d|%d|\r\n"
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|ntohs
argument_list|(
name|alias_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTP_229_REPLY
case|:
comment|/* Generate 229 reply string. */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"229 Entering Extended Passive Mode (|||%d|)\r\n"
argument_list|,
name|ntohs
argument_list|(
name|alias_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Save string length for IP header modification */
name|slen
operator|=
name|strlen
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
comment|/* Copy modified buffer into IP packet. */
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
name|sptr
operator|+=
name|hlen
expr_stmt|;
name|strncpy
argument_list|(
name|sptr
argument_list|,
name|stemp
argument_list|,
name|maxpacketsize
operator|-
name|hlen
argument_list|)
expr_stmt|;
block|}
comment|/* Save information regarding modified seq and ack numbers */
block|{
name|int
name|delta
decl_stmt|;
name|SetAckModified
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|delta
operator|=
name|GetDeltaSeqOut
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
name|AddSeq
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|,
name|delta
operator|+
name|slen
operator|-
name|dlen
argument_list|)
expr_stmt|;
block|}
comment|/* Revise IP header */
block|{
name|u_short
name|new_len
decl_stmt|;
name|new_len
operator|=
name|htons
argument_list|(
name|hlen
operator|+
name|slen
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|new_len
argument_list|,
operator|&
name|pip
operator|->
name|ip_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|new_len
expr_stmt|;
block|}
comment|/* Compute TCP checksum for revised packet */
name|tc
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|tc
operator|->
name|th_x2
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|tc
operator|->
name|th_sum
operator|=
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/HandleFtpOut: Cannot allocate FTP data port\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

end_unit

