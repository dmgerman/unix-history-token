begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Charles Mott<cm@linktel.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*     Alias.c provides supervisory control for the functions of the     packet aliasing software.  It consists of routines to monitor     TCP connection state, protocol-specific aliasing routines,     fragment handling and the following outside world functional     interfaces: SaveFragmentPtr, GetFragmentPtr, FragmentAliasIn,     PacketAliasIn and PacketAliasOut.      The other C program files are briefly described. The data     structure framework which holds information needed to translate     packets is encapsulated in alias_db.c.  Data is accessed by     function calls, so other segments of the program need not know     about the underlying data structures.  Alias_ftp.c contains     special code for modifying the ftp PORT command used to establish     data connections, while alias_irc.c does the same for IRC     DCC. Alias_util.c contains a few utility routines.      Version 1.0 August, 1996  (cjm)      Version 1.1 August 20, 1996  (cjm) 	PPP host accepts incoming connections for ports 0 to 1023. 	(Gary Roberts pointed out the need to handle incoming 	 connections.)      Version 1.2 September 7, 1996 (cjm) 	Fragment handling error in alias_db.c corrected. 	(Tom Torrance helped fix this problem.)      Version 1.4 September 16, 1996 (cjm) 	- A more generalized method for handling incoming 	  connections, without the 0-1023 restriction, is 	  implemented in alias_db.c 	- Improved ICMP support in alias.c.  Traceroute 	  packet streams can now be correctly aliased. 	- TCP connection closing logic simplified in 	  alias.c and now allows for additional 1 minute 	  "grace period" after FIN or RST is observed.      Version 1.5 September 17, 1996 (cjm) 	Corrected error in handling incoming UDP packets with 0 checksum. 	(Tom Torrance helped fix this problem.)      Version 1.6 September 18, 1996 (cjm) 	Simplified ICMP aliasing scheme.  Should now support 	traceroute from Win95 as well as FreeBSD.      Version 1.7 January 9, 1997 (cjm) 	- Out-of-order fragment handling. 	- IP checksum error fixed for ftp transfers 	  from aliasing host. 	- Integer return codes added to all 	  aliasing/de-aliasing functions. 	- Some obsolete comments cleaned up. 	- Differential checksum computations for 	  IP header (TCP, UDP and ICMP were already 	  differential).      Version 2.1 May 1997 (cjm) 	- Added support for outgoing ICMP error 	  messages. 	- Added two functions PacketAliasIn2() 	  and PacketAliasOut2() for dynamic address 	  control (e.g. round-robin allocation of 	  incoming packets).      Version 2.2 July 1997 (cjm) 	- Rationalized API function names to begin 	  with "PacketAlias..." 	- Eliminated PacketAliasIn2() and 	  PacketAliasOut2() as poorly conceived.      Version 2.3 Dec 1998 (dillon) 	- Major bounds checking additions, see FreeBSD/CVS      Version 3.1 May, 2000 (salander) 	- Added hooks to handle PPTP.      Version 3.2 July, 2000 (salander and satoh) 	- Added PacketUnaliasOut routine. 	- Added hooks to handle RTSP/RTP.      See HISTORY file for additional revisions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_mod.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_include
include|#
directive|include
file|"alias_mod.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|int
name|twowords
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uint8_t
modifier|*
name|c
init|=
name|p
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|uint16_t
name|s1
init|=
operator|(
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|0
index|]
decl_stmt|;
name|uint16_t
name|s2
init|=
operator|(
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
name|uint16_t
name|s1
init|=
operator|(
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|1
index|]
decl_stmt|;
name|uint16_t
name|s2
init|=
operator|(
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|uint16_t
operator|)
name|c
index|[
literal|3
index|]
decl_stmt|;
endif|#
directive|endif
return|return
operator|(
name|s1
operator|+
name|s2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TCP Handling Routines      TcpMonitorIn()  -- These routines monitor TCP connections, and     TcpMonitorOut()    delete a link when a connection is closed.  These routines look for SYN, FIN and RST flags to determine when TCP connections open and close.  When a TCP connection closes, the data structure containing packet aliasing information is deleted after a timeout period. */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|TcpMonitorIn
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|TcpMonitorOut
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|TcpMonitorIn
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GetStateIn
argument_list|(
name|lnk
argument_list|)
condition|)
block|{
case|case
name|ALIAS_TCP_STATE_NOT_CONNECTED
case|:
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
name|SetStateIn
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_DISCONNECTED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
name|SetStateIn
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_CONNECTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALIAS_TCP_STATE_CONNECTED
case|:
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_RST
operator|)
condition|)
name|SetStateIn
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_DISCONNECTED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|TcpMonitorOut
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GetStateOut
argument_list|(
name|lnk
argument_list|)
condition|)
block|{
case|case
name|ALIAS_TCP_STATE_NOT_CONNECTED
case|:
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
name|SetStateOut
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_DISCONNECTED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
name|SetStateOut
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_CONNECTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALIAS_TCP_STATE_CONNECTED
case|:
if|if
condition|(
name|tc
operator|->
name|th_flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_RST
operator|)
condition|)
name|SetStateOut
argument_list|(
name|lnk
argument_list|,
name|ALIAS_TCP_STATE_DISCONNECTED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Protocol Specific Packet Aliasing Routines      IcmpAliasIn(), IcmpAliasIn1(), IcmpAliasIn2()     IcmpAliasOut(), IcmpAliasOut1(), IcmpAliasOut2()     ProtoAliasIn(), ProtoAliasOut()     UdpAliasIn(), UdpAliasOut()     TcpAliasIn(), TcpAliasOut()  These routines handle protocol specific details of packet aliasing. One may observe a certain amount of repetitive arithmetic in these functions, the purpose of which is to compute a revised checksum without actually summing over the entire data packet, which could be unnecessarily time consuming.  The purpose of the packet aliasing routines is to replace the source address of the outgoing packet and then correctly put it back for any incoming packets.  For TCP and UDP, ports are also re-mapped.  For ICMP echo/timestamp requests and replies, the following scheme is used: the ID number is replaced by an alias for the outgoing packet.  ICMP error messages are handled by looking at the IP fragment in the data section of the message.  For TCP and UDP protocols, a port number is chosen for an outgoing packet, and then incoming packets are identified by IP address and port numbers.  For TCP packets, there is additional logic in the event that sequence and ACK numbers have been altered (as in the case for FTP data port commands).  The port numbers used by the packet aliasing module are not true ports in the Unix sense.  No sockets are actually bound to ports. They are more correctly thought of as placeholders.  All packets go through the aliasing mechanism, whether they come from the gateway machine or other machines on a local area network. */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|IcmpAliasIn1
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IcmpAliasIn2
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IcmpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IcmpAliasOut1
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IcmpAliasOut2
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IcmpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ProtoAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ProtoAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|UdpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|UdpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TcpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TcpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|IcmpAliasIn1
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/*     De-alias incoming echo and timestamp replies.     Alias incoming echo and timestamp requests. */
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Get source address from ICMP data field and restore original data */
name|lnk
operator|=
name|FindIcmpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|ic
operator|->
name|icmp_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|original_id
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|original_id
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|ic
operator|->
name|icmp_id
expr_stmt|;
name|accumulate
operator|-=
name|original_id
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/* Put original sequence number back in */
name|ic
operator|->
name|icmp_id
operator|=
name|original_id
expr_stmt|;
comment|/* Put original address back into IP header */
block|{
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
block|}
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IcmpAliasIn2
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/*     Alias incoming ICMP error messages containing     IP header and first 64 bits of datagram. */
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|,
modifier|*
name|ic2
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|ud
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|ic
operator|->
name|icmp_ip
expr_stmt|;
name|ud
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ic2
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ud
operator|->
name|uh_dport
argument_list|,
name|ud
operator|->
name|uh_sport
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|tc
operator|->
name|th_dport
argument_list|,
name|tc
operator|->
name|th_sport
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
if|if
condition|(
name|ic2
operator|->
name|icmp_type
operator|==
name|ICMP_ECHO
operator|||
name|ic2
operator|->
name|icmp_type
operator|==
name|ICMP_TSTAMP
condition|)
name|lnk
operator|=
name|FindIcmpIn
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ic2
operator|->
name|icmp_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|lnk
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|lnk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
operator|||
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|int
name|accumulate
decl_stmt|,
name|accumulate2
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|u_short
name|original_port
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_port
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
name|accumulate
operator|+=
name|ud
operator|->
name|uh_sport
expr_stmt|;
name|accumulate
operator|-=
name|original_port
expr_stmt|;
name|accumulate2
operator|=
name|accumulate
expr_stmt|;
name|accumulate2
operator|+=
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
name|accumulate2
operator|-=
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate2
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/* Un-alias address in IP header */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
comment|/* Un-alias address and port number of original IP packet fragment contained in ICMP data section */
name|ip
operator|->
name|ip_src
operator|=
name|original_address
expr_stmt|;
name|ud
operator|->
name|uh_sport
operator|=
name|original_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|int
name|accumulate
decl_stmt|,
name|accumulate2
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|u_short
name|original_id
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_id
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
name|accumulate
operator|+=
name|ic2
operator|->
name|icmp_id
expr_stmt|;
name|accumulate
operator|-=
name|original_id
expr_stmt|;
name|accumulate2
operator|=
name|accumulate
expr_stmt|;
name|accumulate2
operator|+=
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
name|accumulate2
operator|-=
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate2
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/* Un-alias address in IP header */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
comment|/* Un-alias address of original IP packet and sequence number of    embedded ICMP datagram */
name|ip
operator|->
name|ip_src
operator|=
name|original_address
expr_stmt|;
name|ic2
operator|->
name|icmp_id
operator|=
name|original_id
expr_stmt|;
block|}
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IcmpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|int
name|iresult
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHOREPLY
case|:
case|case
name|ICMP_TSTAMPREPLY
case|:
if|if
condition|(
name|ic
operator|->
name|icmp_code
operator|==
literal|0
condition|)
block|{
name|iresult
operator|=
name|IcmpAliasIn1
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|iresult
operator|=
name|IcmpAliasIn2
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_TSTAMP
case|:
name|iresult
operator|=
name|IcmpAliasIn1
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IcmpAliasOut1
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|create
parameter_list|)
block|{
comment|/*     Alias outgoing echo and timestamp requests.     De-alias outgoing echo and timestamp replies. */
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Save overwritten data for when echo packet returns */
name|lnk
operator|=
name|FindIcmpOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|ic
operator|->
name|icmp_id
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|alias_id
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|alias_id
operator|=
name|GetAliasPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Since data field is being modified, adjust ICMP checksum */
name|accumulate
operator|=
name|ic
operator|->
name|icmp_id
expr_stmt|;
name|accumulate
operator|-=
name|alias_id
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/* Alias sequence number */
name|ic
operator|->
name|icmp_id
operator|=
name|alias_id
expr_stmt|;
comment|/* Change source address */
block|{
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
block|}
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IcmpAliasOut2
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
comment|/*     Alias outgoing ICMP error messages containing     IP header and first 64 bits of datagram. */
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|,
modifier|*
name|ic2
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|ud
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|ic
operator|->
name|icmp_ip
expr_stmt|;
name|ud
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ic2
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|lnk
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ud
operator|->
name|uh_dport
argument_list|,
name|ud
operator|->
name|uh_sport
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|lnk
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|tc
operator|->
name|th_dport
argument_list|,
name|tc
operator|->
name|th_sport
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
if|if
condition|(
name|ic2
operator|->
name|icmp_type
operator|==
name|ICMP_ECHO
operator|||
name|ic2
operator|->
name|icmp_type
operator|==
name|ICMP_TSTAMP
condition|)
name|lnk
operator|=
name|FindIcmpOut
argument_list|(
name|la
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ic2
operator|->
name|icmp_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|lnk
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|lnk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
operator|||
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_port
operator|=
name|GetAliasPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
name|accumulate
operator|+=
name|ud
operator|->
name|uh_dport
expr_stmt|;
name|accumulate
operator|-=
name|alias_port
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/*  * Alias address in IP header if it comes from the host  * the original TCP/UDP packet was destined for.  */
if|if
condition|(
name|pip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
block|{
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
block|}
comment|/* Alias address and port number of original IP packet fragment contained in ICMP data section */
name|ip
operator|->
name|ip_dst
operator|=
name|alias_address
expr_stmt|;
name|ud
operator|->
name|uh_dport
operator|=
name|alias_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|u_short
name|alias_id
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_id
operator|=
name|GetAliasPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
name|accumulate
operator|+=
name|ic2
operator|->
name|icmp_id
expr_stmt|;
name|accumulate
operator|-=
name|alias_id
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/*  * Alias address in IP header if it comes from the host  * the original ICMP message was destined for.  */
if|if
condition|(
name|pip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
block|{
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
block|}
comment|/* Alias address of original IP packet and sequence number of    embedded ICMP datagram */
name|ip
operator|->
name|ip_dst
operator|=
name|alias_address
expr_stmt|;
name|ic2
operator|->
name|icmp_id
operator|=
name|alias_id
expr_stmt|;
block|}
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IcmpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|iresult
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|create
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_TSTAMP
case|:
if|if
condition|(
name|ic
operator|->
name|icmp_code
operator|==
literal|0
condition|)
block|{
name|iresult
operator|=
name|IcmpAliasOut1
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|iresult
operator|=
name|IcmpAliasOut2
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_ECHOREPLY
case|:
case|case
name|ICMP_TSTAMPREPLY
case|:
name|iresult
operator|=
name|IcmpAliasOut1
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ProtoAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
comment|/*   Handle incoming IP packets. The   only thing which is done in this case is to alias   the dest IP address of the packet to our inside   machine. */
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|lnk
operator|=
name|FindProtoIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Restore original IP address */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ProtoAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|create
parameter_list|)
block|{
comment|/*   Handle outgoing IP packets. The   only thing which is done in this case is to alias   the source IP address of the packet. */
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|create
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|lnk
operator|=
name|FindProtoOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Change source address */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|UdpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
name|ud
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|ud
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|ud
operator|->
name|uh_sport
argument_list|,
name|ud
operator|->
name|uh_dport
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|lnk
block|,
operator|.
name|oaddr
operator|=
operator|&
name|original_address
block|,
operator|.
name|aaddr
operator|=
operator|&
name|alias_address
block|,
operator|.
name|aport
operator|=
operator|&
name|alias_port
block|,
operator|.
name|sport
operator|=
operator|&
name|ud
operator|->
name|uh_sport
block|,
operator|.
name|dport
operator|=
operator|&
name|ud
operator|->
name|uh_dport
block|,
operator|.
name|maxpktsize
operator|=
literal|0
block|}
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_port
operator|=
name|ud
operator|->
name|uh_dport
expr_stmt|;
name|ud
operator|->
name|uh_dport
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|IN
argument_list|,
name|UDP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
comment|/* If UDP checksum is not zero, then adjust since destination port */
comment|/* is being unaliased and destination address is being altered.    */
if|if
condition|(
name|ud
operator|->
name|uh_sum
operator|!=
literal|0
condition|)
block|{
name|accumulate
operator|=
name|alias_port
expr_stmt|;
name|accumulate
operator|-=
name|ud
operator|->
name|uh_dport
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ud
operator|->
name|uh_sum
argument_list|)
expr_stmt|;
block|}
comment|/* Restore original IP address */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
comment|/* 		 * If we cannot figure out the packet, ignore it. 		 */
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
else|else
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|UdpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|udphdr
modifier|*
name|ud
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Return if proxy-only mode is enabled */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
name|ud
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|ud
operator|->
name|uh_sport
argument_list|,
name|ud
operator|->
name|uh_dport
argument_list|,
name|IPPROTO_UDP
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|alias_port
decl_stmt|;
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|lnk
block|,
operator|.
name|oaddr
operator|=
name|NULL
block|,
operator|.
name|aaddr
operator|=
operator|&
name|alias_address
block|,
operator|.
name|aport
operator|=
operator|&
name|alias_port
block|,
operator|.
name|sport
operator|=
operator|&
name|ud
operator|->
name|uh_sport
block|,
operator|.
name|dport
operator|=
operator|&
name|ud
operator|->
name|uh_dport
block|,
operator|.
name|maxpktsize
operator|=
literal|0
block|}
decl_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_port
operator|=
name|GetAliasPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|OUT
argument_list|,
name|UDP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
comment|/* If UDP checksum is not zero, adjust since source port is */
comment|/* being aliased and source address is being altered        */
if|if
condition|(
name|ud
operator|->
name|uh_sum
operator|!=
literal|0
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|accumulate
operator|=
name|ud
operator|->
name|uh_sport
expr_stmt|;
name|accumulate
operator|-=
name|alias_port
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ud
operator|->
name|uh_sum
argument_list|)
expr_stmt|;
block|}
comment|/* Put alias port in UDP header */
name|ud
operator|->
name|uh_sport
operator|=
name|alias_port
expr_stmt|;
comment|/* Change source address */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TcpAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|tc
operator|->
name|th_sport
argument_list|,
name|tc
operator|->
name|th_dport
argument_list|,
name|IPPROTO_TCP
argument_list|,
operator|!
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|struct
name|in_addr
name|proxy_address
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|;
name|u_short
name|proxy_port
decl_stmt|;
name|int
name|accumulate
decl_stmt|,
name|error
decl_stmt|;
comment|/*  		 * The init of MANY vars is a bit below, but aliashandlepptpin  		 * seems to need the destination port that came within the 		 * packet and not the original one looks below [*]. 		 */
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|lnk
block|,
operator|.
name|oaddr
operator|=
name|NULL
block|,
operator|.
name|aaddr
operator|=
name|NULL
block|,
operator|.
name|aport
operator|=
name|NULL
block|,
operator|.
name|sport
operator|=
operator|&
name|tc
operator|->
name|th_sport
block|,
operator|.
name|dport
operator|=
operator|&
name|tc
operator|->
name|th_dport
block|,
operator|.
name|maxpktsize
operator|=
literal|0
block|}
decl_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|IN
argument_list|,
name|TCP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|proxy_address
operator|=
name|GetProxyAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_port
operator|=
name|tc
operator|->
name|th_dport
expr_stmt|;
name|tc
operator|->
name|th_dport
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|proxy_port
operator|=
name|GetProxyPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/*  		 * Look above, if anyone is going to add find_handler AFTER  		 * this aliashandlepptpin/point, please redo alias_data too. 		 * Uncommenting the piece here below should be enough. 		 */
if|#
directive|if
literal|0
block|struct alias_data ad = { 					.lnk = lnk, 					.oaddr =&original_address, 					.aaddr =&alias_address, 					.aport =&alias_port, 					.sport =&ud->uh_sport, 					.dport =&ud->uh_dport, 					.maxpktsize = 0 				};
comment|/* Walk out chain. */
block|error = find_handler(la, pip,&ad); 				if (error == EHDNOF) 					printf("Protocol handler not found\n");
endif|#
directive|endif
comment|/* Adjust TCP checksum since destination port is being unaliased */
comment|/* and destination port is being altered.                        */
name|accumulate
operator|=
name|alias_port
expr_stmt|;
name|accumulate
operator|-=
name|tc
operator|->
name|th_dport
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
comment|/* If this is a proxy, then modify the TCP source port and    checksum accumulation */
if|if
condition|(
name|proxy_port
operator|!=
literal|0
condition|)
block|{
name|accumulate
operator|+=
name|tc
operator|->
name|th_sport
expr_stmt|;
name|tc
operator|->
name|th_sport
operator|=
name|proxy_port
expr_stmt|;
name|accumulate
operator|-=
name|tc
operator|->
name|th_sport
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|proxy_address
argument_list|)
expr_stmt|;
block|}
comment|/* See if ACK number needs to be modified */
if|if
condition|(
name|GetAckModified
argument_list|(
name|lnk
argument_list|)
operator|==
literal|1
condition|)
block|{
name|int
name|delta
decl_stmt|;
name|delta
operator|=
name|GetDeltaAckIn
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|tc
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|tc
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|tc
operator|->
name|th_ack
argument_list|)
operator|-
name|delta
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|tc
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
block|}
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|tc
operator|->
name|th_sum
argument_list|)
expr_stmt|;
comment|/* Restore original IP address */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
comment|/* If this is a transparent proxy packet, then modify the source    address */
if|if
condition|(
name|proxy_address
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|proxy_address
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
block|}
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
comment|/* Monitor TCP connection state */
name|TcpMonitorIn
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TcpAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|proxy_type
decl_stmt|,
name|error
decl_stmt|;
name|u_short
name|dest_port
decl_stmt|;
name|u_short
name|proxy_server_port
decl_stmt|;
name|struct
name|in_addr
name|dest_address
decl_stmt|;
name|struct
name|in_addr
name|proxy_server_address
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
condition|)
name|proxy_type
operator|=
name|ProxyCheck
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|proxy_server_address
argument_list|,
operator|&
name|proxy_server_port
argument_list|)
expr_stmt|;
else|else
name|proxy_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proxy_type
operator|==
literal|0
operator|&&
operator|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
operator|)
condition|)
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
comment|/* If this is a transparent proxy, save original destination,    then alter the destination and adjust checksums */
name|dest_port
operator|=
name|tc
operator|->
name|th_dport
expr_stmt|;
name|dest_address
operator|=
name|pip
operator|->
name|ip_dst
expr_stmt|;
if|if
condition|(
name|proxy_type
operator|!=
literal|0
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|accumulate
operator|=
name|tc
operator|->
name|th_dport
expr_stmt|;
name|tc
operator|->
name|th_dport
operator|=
name|proxy_server_port
expr_stmt|;
name|accumulate
operator|-=
name|tc
operator|->
name|th_dport
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|proxy_server_address
argument_list|)
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|tc
operator|->
name|th_sum
argument_list|)
expr_stmt|;
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|proxy_server_address
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
block|}
name|lnk
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|tc
operator|->
name|th_sport
argument_list|,
name|tc
operator|->
name|th_dport
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|==
name|NULL
condition|)
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|alias_port
decl_stmt|;
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|lnk
block|,
operator|.
name|oaddr
operator|=
name|NULL
block|,
operator|.
name|aaddr
operator|=
operator|&
name|alias_address
block|,
operator|.
name|aport
operator|=
operator|&
name|alias_port
block|,
operator|.
name|sport
operator|=
operator|&
name|tc
operator|->
name|th_sport
block|,
operator|.
name|dport
operator|=
operator|&
name|tc
operator|->
name|th_dport
block|,
operator|.
name|maxpktsize
operator|=
name|maxpacketsize
block|}
decl_stmt|;
comment|/* Save original destination address, if this is a proxy packet.    Also modify packet to include destination encoding.  This may    change the size of IP header. */
if|if
condition|(
name|proxy_type
operator|!=
literal|0
condition|)
block|{
name|SetProxyPort
argument_list|(
name|lnk
argument_list|,
name|dest_port
argument_list|)
expr_stmt|;
name|SetProxyAddress
argument_list|(
name|lnk
argument_list|,
name|dest_address
argument_list|)
expr_stmt|;
name|ProxyModify
argument_list|(
name|la
argument_list|,
name|lnk
argument_list|,
name|pip
argument_list|,
name|maxpacketsize
argument_list|,
name|proxy_type
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
block|}
comment|/* Get alias address and port */
name|alias_port
operator|=
name|GetAliasPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|alias_address
operator|=
name|GetAliasAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Monitor TCP connection state */
name|TcpMonitorOut
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|OUT
argument_list|,
name|TCP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
comment|/* Adjust TCP checksum since source port is being aliased */
comment|/* and source address is being altered                    */
name|accumulate
operator|=
name|tc
operator|->
name|th_sport
expr_stmt|;
name|tc
operator|->
name|th_sport
operator|=
name|alias_port
expr_stmt|;
name|accumulate
operator|-=
name|tc
operator|->
name|th_sport
expr_stmt|;
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|alias_address
argument_list|)
expr_stmt|;
comment|/* Modify sequence number if necessary */
if|if
condition|(
name|GetAckModified
argument_list|(
name|lnk
argument_list|)
operator|==
literal|1
condition|)
block|{
name|int
name|delta
decl_stmt|;
name|delta
operator|=
name|GetDeltaSeqOut
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
name|accumulate
operator|+=
name|twowords
argument_list|(
operator|&
name|tc
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|tc
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|tc
operator|->
name|th_seq
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|tc
operator|->
name|th_seq
argument_list|)
expr_stmt|;
block|}
block|}
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|tc
operator|->
name|th_sum
argument_list|)
expr_stmt|;
comment|/* Change source address */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_IGNORED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fragment Handling      FragmentIn()     FragmentOut()  The packet aliasing module has a limited ability for handling IP fragments.  If the ICMP, TCP or UDP header is in the first fragment received, then the ID number of the IP packet is saved, and other fragments are identified according to their ID number and IP address they were sent from.  Pointers to unresolved fragments can also be saved and recalled when a header fragment is seen. */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|FragmentIn
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|FragmentOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|FragmentIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|lnk
operator|=
name|FindFragmentIn2
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|GetFragmentAddr
argument_list|(
name|lnk
argument_list|,
operator|&
name|original_address
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_dst
operator|=
name|original_address
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
return|return
operator|(
name|PKT_ALIAS_UNRESOLVED_FRAGMENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FragmentOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|)
block|{
name|struct
name|in_addr
name|alias_address
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|alias_address
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|alias_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_src
operator|=
name|alias_address
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Outside World Access  	PacketAliasSaveFragment() 	PacketAliasGetFragment() 	PacketAliasFragmentIn() 	PacketAliasIn() 	PacketAliasOut() 	PacketUnaliasOut()  (prototypes in alias.h) */
end_comment

begin_function
name|int
name|LibAliasSaveFragment
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|iresult
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
name|lnk
operator|=
name|AddFragmentPtrLink
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_ERROR
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|SetFragmentPtr
argument_list|(
name|lnk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_OK
expr_stmt|;
block|}
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|LibAliasGetFragment
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|char
modifier|*
name|fptr
decl_stmt|;
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
name|lnk
operator|=
name|FindFragmentPtr
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|GetFragmentPtr
argument_list|(
name|lnk
argument_list|,
operator|&
name|fptr
argument_list|)
expr_stmt|;
name|SetFragmentPtr
argument_list|(
name|lnk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SetExpire
argument_list|(
name|lnk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Deletes link */
block|}
else|else
name|fptr
operator|=
name|NULL
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|fptr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|LibAliasFragmentIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
comment|/* Points to correctly 							 * de-aliased header 							 * fragment */
name|char
modifier|*
name|ptr_fragment
comment|/* Points to fragment which must be 				 * de-aliased   */
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
name|struct
name|ip
modifier|*
name|fpip
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|la
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
name|fpip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr_fragment
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|fpip
operator|->
name|ip_sum
argument_list|,
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
operator|&
name|fpip
operator|->
name|ip_dst
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fpip
operator|->
name|ip_dst
operator|=
name|pip
operator|->
name|ip_dst
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|LibAliasOutLocked
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LibAliasInLocked
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|LibAliasIn
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|res
operator|=
name|LibAliasInLocked
argument_list|(
name|la
argument_list|,
name|ptr
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|LibAliasInLocked
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
name|int
name|iresult
decl_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_REVERSE
condition|)
block|{
name|la
operator|->
name|packetAliasMode
operator|&=
operator|~
name|PKT_ALIAS_REVERSE
expr_stmt|;
name|iresult
operator|=
name|LibAliasOutLocked
argument_list|(
name|la
argument_list|,
name|ptr
argument_list|,
name|maxpacketsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|la
operator|->
name|packetAliasMode
operator||=
name|PKT_ALIAS_REVERSE
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|HouseKeeping
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ClearCheckNewLink
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
name|alias_addr
operator|=
name|pip
operator|->
name|ip_dst
expr_stmt|;
comment|/* Defense against mangled packets */
if|if
condition|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|>
name|maxpacketsize
operator|||
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|maxpacketsize
condition|)
block|{
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|pip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_ICMP
case|:
name|iresult
operator|=
name|IcmpAliasIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|iresult
operator|=
name|UdpAliasIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|iresult
operator|=
name|TcpAliasIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
block|{
name|int
name|error
decl_stmt|;
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|NULL
block|,
operator|.
name|oaddr
operator|=
name|NULL
block|,
operator|.
name|aaddr
operator|=
name|NULL
block|,
operator|.
name|aport
operator|=
name|NULL
block|,
operator|.
name|sport
operator|=
name|NULL
block|,
operator|.
name|dport
operator|=
name|NULL
block|,
operator|.
name|maxpktsize
operator|=
literal|0
block|}
decl_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|IN
argument_list|,
name|IP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|iresult
operator|=
name|PKT_ALIAS_OK
expr_stmt|;
else|else
name|iresult
operator|=
name|ProtoAliasIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|iresult
operator|=
name|ProtoAliasIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_MF
condition|)
block|{
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|lnk
operator|=
name|FindFragmentIn1
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|alias_addr
argument_list|,
name|pip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
name|iresult
operator|=
name|PKT_ALIAS_FOUND_HEADER_FRAGMENT
expr_stmt|;
name|SetFragmentAddr
argument_list|(
name|lnk
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iresult
operator|=
name|PKT_ALIAS_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|iresult
operator|=
name|FragmentIn
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
name|getout
label|:
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Unregistered address ranges */
end_comment

begin_comment
comment|/* 10.0.0.0   ->   10.255.255.255 */
end_comment

begin_define
define|#
directive|define
name|UNREG_ADDR_A_LOWER
value|0x0a000000
end_define

begin_define
define|#
directive|define
name|UNREG_ADDR_A_UPPER
value|0x0affffff
end_define

begin_comment
comment|/* 172.16.0.0  ->  172.31.255.255 */
end_comment

begin_define
define|#
directive|define
name|UNREG_ADDR_B_LOWER
value|0xac100000
end_define

begin_define
define|#
directive|define
name|UNREG_ADDR_B_UPPER
value|0xac1fffff
end_define

begin_comment
comment|/* 192.168.0.0 -> 192.168.255.255 */
end_comment

begin_define
define|#
directive|define
name|UNREG_ADDR_C_LOWER
value|0xc0a80000
end_define

begin_define
define|#
directive|define
name|UNREG_ADDR_C_UPPER
value|0xc0a8ffff
end_define

begin_function
name|int
name|LibAliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|res
operator|=
name|LibAliasOutLocked
argument_list|(
name|la
argument_list|,
name|ptr
argument_list|,
name|maxpacketsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|LibAliasOutTry
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|res
operator|=
name|LibAliasOutLocked
argument_list|(
name|la
argument_list|,
name|ptr
argument_list|,
name|maxpacketsize
argument_list|,
name|create
argument_list|)
expr_stmt|;
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|LibAliasOutLocked
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
comment|/* valid IP packet */
name|int
name|maxpacketsize
parameter_list|,
comment|/* How much the packet data may grow (FTP 				 * and IRC inline changes) */
name|int
name|create
comment|/* Create new entries ? */
parameter_list|)
block|{
name|int
name|iresult
decl_stmt|;
name|struct
name|in_addr
name|addr_save
decl_stmt|;
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_REVERSE
condition|)
block|{
name|la
operator|->
name|packetAliasMode
operator|&=
operator|~
name|PKT_ALIAS_REVERSE
expr_stmt|;
name|iresult
operator|=
name|LibAliasInLocked
argument_list|(
name|la
argument_list|,
name|ptr
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
name|la
operator|->
name|packetAliasMode
operator||=
name|PKT_ALIAS_REVERSE
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|HouseKeeping
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ClearCheckNewLink
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* Defense against mangled packets */
if|if
condition|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|>
name|maxpacketsize
operator|||
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|maxpacketsize
condition|)
block|{
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|addr_save
operator|=
name|GetDefaultAliasAddress
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_UNREGISTERED_ONLY
condition|)
block|{
name|u_long
name|addr
decl_stmt|;
name|int
name|iclass
decl_stmt|;
name|iclass
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|pip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|UNREG_ADDR_C_LOWER
operator|&&
name|addr
operator|<=
name|UNREG_ADDR_C_UPPER
condition|)
name|iclass
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|>=
name|UNREG_ADDR_B_LOWER
operator|&&
name|addr
operator|<=
name|UNREG_ADDR_B_UPPER
condition|)
name|iclass
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|>=
name|UNREG_ADDR_A_LOWER
operator|&&
name|addr
operator|<=
name|UNREG_ADDR_A_UPPER
condition|)
name|iclass
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|iclass
operator|==
literal|0
condition|)
block|{
name|SetDefaultAliasAddress
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
block|{
name|SetDefaultAliasAddress
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
block|}
name|iresult
operator|=
name|PKT_ALIAS_IGNORED
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|pip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_ICMP
case|:
name|iresult
operator|=
name|IcmpAliasOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|iresult
operator|=
name|UdpAliasOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|iresult
operator|=
name|TcpAliasOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|maxpacketsize
argument_list|,
name|create
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
block|{
name|int
name|error
decl_stmt|;
name|struct
name|alias_data
name|ad
init|=
block|{
operator|.
name|lnk
operator|=
name|NULL
block|,
operator|.
name|oaddr
operator|=
name|NULL
block|,
operator|.
name|aaddr
operator|=
name|NULL
block|,
operator|.
name|aport
operator|=
name|NULL
block|,
operator|.
name|sport
operator|=
name|NULL
block|,
operator|.
name|dport
operator|=
name|NULL
block|,
operator|.
name|maxpktsize
operator|=
literal|0
block|}
decl_stmt|;
comment|/* Walk out chain. */
name|error
operator|=
name|find_handler
argument_list|(
name|OUT
argument_list|,
name|IP
argument_list|,
name|la
argument_list|,
name|pip
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|iresult
operator|=
name|PKT_ALIAS_OK
expr_stmt|;
else|else
name|iresult
operator|=
name|ProtoAliasOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|iresult
operator|=
name|ProtoAliasOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|create
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|iresult
operator|=
name|FragmentOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
name|SetDefaultAliasAddress
argument_list|(
name|la
argument_list|,
name|addr_save
argument_list|)
expr_stmt|;
name|getout
label|:
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_function
name|int
name|LibAliasUnaliasOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
comment|/* valid IP packet */
name|int
name|maxpacketsize
comment|/* for error checking */
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|pip
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|ud
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|lnk
decl_stmt|;
name|int
name|iresult
init|=
name|PKT_ALIAS_IGNORED
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|pip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* Defense against mangled packets */
if|if
condition|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|>
name|maxpacketsize
operator|||
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|maxpacketsize
condition|)
goto|goto
name|getout
goto|;
name|ud
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Find a link */
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|ud
operator|->
name|uh_dport
argument_list|,
name|ud
operator|->
name|uh_sport
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|lnk
operator|=
name|FindUdpTcpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|tc
operator|->
name|th_dport
argument_list|,
name|tc
operator|->
name|th_sport
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
name|lnk
operator|=
name|FindIcmpIn
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|ic
operator|->
name|icmp_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|lnk
operator|=
name|NULL
expr_stmt|;
comment|/* Change it from an aliased packet to an unaliased packet */
if|if
condition|(
name|lnk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
operator|||
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|u_short
name|original_port
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_port
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust TCP/UDP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|accumulate
operator|+=
name|ud
operator|->
name|uh_sport
expr_stmt|;
name|accumulate
operator|-=
name|original_port
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ud
operator|->
name|uh_sum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accumulate
operator|+=
name|tc
operator|->
name|th_sport
expr_stmt|;
name|accumulate
operator|-=
name|original_port
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|tc
operator|->
name|th_sum
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust IP checksum */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Un-alias source address and port number */
name|pip
operator|->
name|ip_src
operator|=
name|original_address
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|ud
operator|->
name|uh_sport
operator|=
name|original_port
expr_stmt|;
else|else
name|tc
operator|->
name|th_sport
operator|=
name|original_port
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|int
name|accumulate
decl_stmt|;
name|struct
name|in_addr
name|original_address
decl_stmt|;
name|u_short
name|original_id
decl_stmt|;
name|original_address
operator|=
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|original_id
operator|=
name|GetOriginalPort
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
comment|/* Adjust ICMP checksum */
name|accumulate
operator|=
name|twowords
argument_list|(
operator|&
name|pip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|twowords
argument_list|(
operator|&
name|original_address
argument_list|)
expr_stmt|;
name|accumulate
operator|+=
name|ic
operator|->
name|icmp_id
expr_stmt|;
name|accumulate
operator|-=
name|original_id
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|ic
operator|->
name|icmp_cksum
argument_list|)
expr_stmt|;
comment|/* Adjust IP checksum */
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|original_address
argument_list|,
operator|&
name|pip
operator|->
name|ip_src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Un-alias source address and port number */
name|pip
operator|->
name|ip_src
operator|=
name|original_address
expr_stmt|;
name|ic
operator|->
name|icmp_id
operator|=
name|original_id
expr_stmt|;
name|iresult
operator|=
name|PKT_ALIAS_OK
expr_stmt|;
block|}
block|}
name|getout
label|:
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|iresult
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|int
name|LibAliasRefreshModules
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|conf
index|[]
init|=
literal|"/etc/libalias.conf"
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|conf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fopen(%s)"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LibAliasUnLoadAllModule
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if feof
condition|(
name|fd
condition|)
break|break;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"Loading %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|LibAliasLoadModule
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|LibAliasLoadModule
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|dll
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|handle
decl_stmt|;
name|struct
name|proto_handler
modifier|*
name|m
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|moduledata_t
modifier|*
name|p
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|path
argument_list|,
name|RTLD_LAZY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"alias_mod"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dlerror
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dll
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|strncpy
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|DLL_LEN
argument_list|)
expr_stmt|;
name|t
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
if|if
condition|(
name|attach_dll
argument_list|(
name|t
argument_list|)
operator|==
name|EEXIST
condition|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dll conflict\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|m
operator|=
name|dlsym
argument_list|(
name|t
operator|->
name|handle
argument_list|,
literal|"handlers"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dlerror
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|LibAliasAttachHandlers
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|LibAliasUnLoadAllModule
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dll
modifier|*
name|t
decl_stmt|;
name|struct
name|proto_handler
modifier|*
name|p
decl_stmt|;
comment|/* Unload all modules then reload everything. */
while|while
condition|(
operator|(
name|p
operator|=
name|first_handler
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|detach_handler
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|t
operator|=
name|walk_dll_chain
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dlclose
argument_list|(
name|t
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * m_megapullup() - this function is a big hack.  * Thankfully, it's only used in ng_nat and ipfw+nat.  *  * It allocates an mbuf with cluster and copies the whole chain into cluster,  * so that it is all contiguous and the whole packet can be accessed via a  * plain (char *) pointer.  This is required, because libalias doesn't know  * how to handle mbuf chains.  *  * On success, m_megapullup returns an mbuf with cluster containing the input  * packet, on failure NULL.  In both cases, the input packet is consumed.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_megapullup
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mcl
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|mcl
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|cp
operator|=
name|mtod
argument_list|(
name|mcl
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|m_move_pkthdr
argument_list|(
name|mcl
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mcl
operator|->
name|m_len
operator|=
name|mcl
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|mcl
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

