begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Charles Mott<cm@linktel.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* file: alias_proxy.c      This file encapsulates special operations related to transparent     proxy redirection.  This is where packets with a particular destination,     usually tcp port 80, are redirected to a proxy server.      When packets are proxied, the destination address and port are     modified.  In certain cases, it is necessary to somehow encode     the original address/port info into the packet.  Two methods are     presently supported: addition of a [DEST addr port] string at the     beginning of a tcp stream, or inclusion of an optional field     in the IP header.      There is one public API function:  	PacketAliasProxyRule()    -- Adds and deletes proxy 				     rules.      Rules are stored in a linear linked list, so lookup efficiency     won't be too good for large lists.       Initial development: April, 1998 (cjm) */
end_comment

begin_comment
comment|/* System includes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_mod.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_comment
comment|/* Public API functions for libalias */
end_comment

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_comment
comment|/* Functions used by alias*.c */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*     Data structures  */
end_comment

begin_comment
comment|/*  * A linked list of arbitrary length, based on struct proxy_entry is  * used to store proxy rules.  */
end_comment

begin_struct
struct|struct
name|proxy_entry
block|{
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
define|#
directive|define
name|PROXY_TYPE_ENCODE_NONE
value|1
define|#
directive|define
name|PROXY_TYPE_ENCODE_TCPSTREAM
value|2
define|#
directive|define
name|PROXY_TYPE_ENCODE_IPHDR
value|3
name|int
name|rule_index
decl_stmt|;
name|int
name|proxy_type
decl_stmt|;
name|u_char
name|proto
decl_stmt|;
name|u_short
name|proxy_port
decl_stmt|;
name|u_short
name|server_port
decl_stmt|;
name|struct
name|in_addr
name|server_addr
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|struct
name|in_addr
name|src_mask
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
name|struct
name|in_addr
name|dst_mask
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|next
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*     File scope variables */
end_comment

begin_comment
comment|/* Local (static) functions:      IpMask()                 -- Utility function for creating IP 				masks from integer (1-32) specification.     IpAddr()                 -- Utility function for converting string 				to IP address     IpPort()                 -- Utility function for converting string 				to port number     RuleAdd()                -- Adds an element to the rule list.     RuleDelete()             -- Removes an element from the rule list.     RuleNumberDelete()       -- Removes all elements from the rule list 				having a certain rule number.     ProxyEncodeTcpStream()   -- Adds [DEST x.x.x.x xxxx] to the beginning 				of a TCP stream.     ProxyEncodeIpHeader()    -- Adds an IP option indicating the true 				destination of a proxied IP packet */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/* XXX: can it be moved to libkern? */
end_comment

begin_function_decl
specifier|static
name|int
name|inet_aton
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|IpMask
parameter_list|(
name|int
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IpAddr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IpPort
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RuleAdd
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|proxy_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RuleDelete
parameter_list|(
name|struct
name|proxy_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RuleNumberDelete
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ProxyEncodeTcpStream
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ProxyEncodeIpHeader
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|int
name|inet_aton
parameter_list|(
name|cp
parameter_list|,
name|addr
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
block|{
name|u_long
name|parts
index|[
literal|4
index|]
decl_stmt|;
name|in_addr_t
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|gotend
decl_stmt|,
name|n
decl_stmt|;
name|c
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Run through the string, grabbing numbers until 	 * the end of the string, or some error 	 */
name|gotend
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|gotend
condition|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
name|strtoul
argument_list|(
name|c
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|ULONG_MAX
operator|||
operator|(
name|l
operator|==
literal|0
operator|&&
name|endptr
operator|==
name|c
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
operator|(
name|in_addr_t
operator|)
name|l
expr_stmt|;
comment|/*  		 * If the whole string is invalid, endptr will equal 		 * c.. this way we can make sure someone hasn't 		 * gone '.12' or something which would get past 		 * the next check. 		 */
if|if
condition|(
name|endptr
operator|==
name|c
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|parts
index|[
name|n
index|]
operator|=
name|val
expr_stmt|;
name|c
operator|=
name|endptr
expr_stmt|;
comment|/* Check the next character past the previous number's end */
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Make sure we only do 3 dots .. */
if|if
condition|(
name|n
operator|==
literal|3
condition|)
comment|/* Whoops. Quit. */
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|gotend
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
argument_list|)
condition|)
block|{
name|gotend
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid character, so fail */
block|}
block|}
comment|/* 	 * Concoct the address according to 	 * the number of parts specified. 	 */
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* a -- 32 bits */
comment|/* 		 * Nothing is necessary here.  Overflow checking was 		 * already done in strtoul(). 		 */
break|break;
case|case
literal|1
case|:
comment|/* a.b -- 8.24 bits */
if|if
condition|(
name|val
operator|>
literal|0xffffff
operator|||
name|parts
index|[
literal|0
index|]
operator|>
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator||=
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* a.b.c -- 8.8.16 bits */
if|if
condition|(
name|val
operator|>
literal|0xffff
operator|||
name|parts
index|[
literal|0
index|]
operator|>
literal|0xff
operator|||
name|parts
index|[
literal|1
index|]
operator|>
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator||=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|parts
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* a.b.c.d -- 8.8.8.8 bits */
if|if
condition|(
name|val
operator|>
literal|0xff
operator|||
name|parts
index|[
literal|0
index|]
operator|>
literal|0xff
operator|||
name|parts
index|[
literal|1
index|]
operator|>
literal|0xff
operator|||
name|parts
index|[
literal|2
index|]
operator|>
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator||=
operator|(
name|parts
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|parts
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|parts
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
name|addr
operator|->
name|s_addr
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|IpMask
parameter_list|(
name|int
name|nbits
parameter_list|,
name|struct
name|in_addr
modifier|*
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|imask
decl_stmt|;
if|if
condition|(
name|nbits
operator|<
literal|0
operator|||
name|nbits
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|imask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbits
condition|;
name|i
operator|++
control|)
name|imask
operator|=
operator|(
name|imask
operator|>>
literal|1
operator|)
operator|+
literal|0x80000000
expr_stmt|;
name|mask
operator|->
name|s_addr
operator|=
name|htonl
argument_list|(
name|imask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IpAddr
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|inet_aton
argument_list|(
name|s
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IpPort
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
modifier|*
name|port
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
ifndef|#
directive|ifndef
name|_KERNEL
comment|/* XXX: we accept only numeric ports in kernel */
block|{
name|struct
name|servent
modifier|*
name|se
decl_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|se
operator|=
name|getservbyname
argument_list|(
name|s
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDP
condition|)
name|se
operator|=
name|getservbyname
argument_list|(
name|s
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|port
operator|=
operator|(
name|u_int
operator|)
name|ntohs
argument_list|(
name|se
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|RuleAdd
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|proxy_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|rule_index
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr_last
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|proxyList
operator|==
name|NULL
condition|)
block|{
name|la
operator|->
name|proxyList
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|entry
operator|->
name|la
operator|=
name|la
expr_stmt|;
name|rule_index
operator|=
name|entry
operator|->
name|rule_index
expr_stmt|;
name|ptr
operator|=
name|la
operator|->
name|proxyList
expr_stmt|;
name|ptr_last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rule_index
operator|>=
name|rule_index
condition|)
block|{
if|if
condition|(
name|ptr_last
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|next
operator|=
name|la
operator|->
name|proxyList
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|la
operator|->
name|proxyList
operator|->
name|last
operator|=
name|entry
expr_stmt|;
name|la
operator|->
name|proxyList
operator|=
name|entry
expr_stmt|;
return|return;
block|}
name|ptr_last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|ptr
operator|->
name|last
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|ptr
operator|->
name|last
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
return|return;
block|}
name|ptr_last
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|ptr_last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|ptr_last
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RuleDelete
parameter_list|(
name|struct
name|proxy_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
name|la
operator|=
name|entry
operator|->
name|la
expr_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|last
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|last
operator|->
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
else|else
name|la
operator|->
name|proxyList
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|next
operator|->
name|last
operator|=
name|entry
operator|->
name|last
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|RuleNumberDelete
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|rule_index
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|la
operator|->
name|proxyList
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|proxy_entry
modifier|*
name|ptr_next
decl_stmt|;
name|ptr_next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|rule_index
operator|==
name|rule_index
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|RuleDelete
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|ptr_next
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ProxyEncodeTcpStream
parameter_list|(
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
comment|/* Compute pointer to tcp header */
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Don't modify if once already modified */
if|if
condition|(
name|GetAckModified
argument_list|(
name|lnk
argument_list|)
condition|)
return|return;
comment|/* Translate destination address and port to string form */
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|2
argument_list|,
literal|"[DEST %s %d]"
argument_list|,
name|inet_ntoa
argument_list|(
name|GetProxyAddress
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|ntohs
argument_list|(
name|GetProxyPort
argument_list|(
name|lnk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pad string out to a multiple of two in length */
name|slen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|slen
operator|%
literal|2
condition|)
block|{
case|case
literal|0
case|:
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
name|slen
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|slen
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Check for packet overflow */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|>
name|maxpacketsize
condition|)
return|return;
comment|/* Shift existing TCP data and insert destination string */
block|{
name|int
name|dlen
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|dlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
expr_stmt|;
comment|/* Modify first packet that has data in it */
if|if
condition|(
name|dlen
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
name|p
operator|+=
name|hlen
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|slen
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
comment|/* Save information about modfied sequence number */
block|{
name|int
name|delta
decl_stmt|;
name|SetAckModified
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|delta
operator|=
name|GetDeltaSeqOut
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
name|AddSeq
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|,
name|delta
operator|+
name|slen
argument_list|)
expr_stmt|;
block|}
comment|/* Update IP header packet length and checksum */
block|{
name|int
name|accumulate
decl_stmt|;
name|accumulate
operator|=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|slen
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
block|}
comment|/* Update TCP checksum, Use TcpChecksum since so many things have    already changed. */
name|tc
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|tc
operator|->
name|th_x2
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|tc
operator|->
name|th_sum
operator|=
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ProxyEncodeIpHeader
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
define|#
directive|define
name|OPTION_LEN_BYTES
value|8
define|#
directive|define
name|OPTION_LEN_INT16
value|4
define|#
directive|define
name|OPTION_LEN_INT32
value|2
name|u_char
name|option
index|[
name|OPTION_LEN_BYTES
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ip cksum 1 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|IpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"tcp cksum 1 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|maxpacketsize
expr_stmt|;
comment|/* Check to see that there is room to add an IP option */
if|if
condition|(
name|pip
operator|->
name|ip_hl
operator|>
operator|(
literal|0x0f
operator|-
name|OPTION_LEN_INT32
operator|)
condition|)
return|return;
comment|/* Build option and copy into packet */
block|{
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pip
expr_stmt|;
name|ptr
operator|+=
literal|20
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|+
name|OPTION_LEN_BYTES
argument_list|,
name|ptr
argument_list|,
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|-
literal|20
argument_list|)
expr_stmt|;
name|option
index|[
literal|0
index|]
operator|=
literal|0x64
expr_stmt|;
comment|/* class: 3 (reserved), option 4 */
name|option
index|[
literal|1
index|]
operator|=
name|OPTION_LEN_BYTES
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|option
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|option
index|[
literal|6
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tc
operator|->
name|th_sport
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|option
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Update checksum, header length and packet length */
block|{
name|int
name|i
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|u_short
modifier|*
name|sptr
decl_stmt|;
name|sptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|option
expr_stmt|;
name|accumulate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_LEN_INT16
condition|;
name|i
operator|++
control|)
name|accumulate
operator|-=
operator|*
operator|(
name|sptr
operator|++
operator|)
expr_stmt|;
name|sptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|pip
expr_stmt|;
name|accumulate
operator|+=
operator|*
name|sptr
expr_stmt|;
name|pip
operator|->
name|ip_hl
operator|+=
name|OPTION_LEN_INT32
expr_stmt|;
name|accumulate
operator|-=
operator|*
name|sptr
expr_stmt|;
name|accumulate
operator|+=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|OPTION_LEN_BYTES
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|OPTION_LEN_BYTES
undef|#
directive|undef
name|OPTION_LEN_INT16
undef|#
directive|undef
name|OPTION_LEN_INT32
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ip cksum 2 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|IpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"tcp cksum 2 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Functions by other packet alias source files      ProxyCheck()         -- Checks whether an outgoing packet should 			    be proxied.     ProxyModify()        -- Encodes the original destination address/port 			    for a packet which is to be redirected to 			    a proxy server. */
end_comment

begin_function
name|int
name|ProxyCheck
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|in_addr
modifier|*
name|proxy_server_addr
parameter_list|,
name|u_short
modifier|*
name|proxy_server_port
parameter_list|)
block|{
name|u_short
name|dst_port
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|pip
operator|->
name|ip_src
expr_stmt|;
name|dst_addr
operator|=
name|pip
operator|->
name|ip_dst
expr_stmt|;
name|dst_port
operator|=
operator|(
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
operator|)
operator|->
name|th_dport
expr_stmt|;
name|ptr
operator|=
name|la
operator|->
name|proxyList
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|proxy_port
decl_stmt|;
name|proxy_port
operator|=
name|ptr
operator|->
name|proxy_port
expr_stmt|;
if|if
condition|(
operator|(
name|dst_port
operator|==
name|proxy_port
operator|||
name|proxy_port
operator|==
literal|0
operator|)
operator|&&
name|pip
operator|->
name|ip_p
operator|==
name|ptr
operator|->
name|proto
operator|&&
name|src_addr
operator|.
name|s_addr
operator|!=
name|ptr
operator|->
name|server_addr
operator|.
name|s_addr
condition|)
block|{
name|struct
name|in_addr
name|src_addr_masked
decl_stmt|;
name|struct
name|in_addr
name|dst_addr_masked
decl_stmt|;
name|src_addr_masked
operator|.
name|s_addr
operator|=
name|src_addr
operator|.
name|s_addr
operator|&
name|ptr
operator|->
name|src_mask
operator|.
name|s_addr
expr_stmt|;
name|dst_addr_masked
operator|.
name|s_addr
operator|=
name|dst_addr
operator|.
name|s_addr
operator|&
name|ptr
operator|->
name|dst_mask
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
operator|(
name|src_addr_masked
operator|.
name|s_addr
operator|==
name|ptr
operator|->
name|src_addr
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|dst_addr_masked
operator|.
name|s_addr
operator|==
name|ptr
operator|->
name|dst_addr
operator|.
name|s_addr
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|proxy_server_port
operator|=
name|ptr
operator|->
name|server_port
operator|)
operator|==
literal|0
condition|)
operator|*
name|proxy_server_port
operator|=
name|dst_port
expr_stmt|;
operator|*
name|proxy_server_addr
operator|=
name|ptr
operator|->
name|server_addr
expr_stmt|;
return|return
operator|(
name|ptr
operator|->
name|proxy_type
operator|)
return|;
block|}
block|}
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ProxyModify
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|proxy_type
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|la
expr_stmt|;
switch|switch
condition|(
name|proxy_type
condition|)
block|{
case|case
name|PROXY_TYPE_ENCODE_IPHDR
case|:
name|ProxyEncodeIpHeader
argument_list|(
name|pip
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROXY_TYPE_ENCODE_TCPSTREAM
case|:
name|ProxyEncodeTcpStream
argument_list|(
name|lnk
argument_list|,
name|pip
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*     Public API functions */
end_comment

begin_function
name|int
name|LibAliasProxyRule
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
comment|/*  * This function takes command strings of the form:  *  *   server<addr>[:<port>]  *   [port<port>]  *   [rule n]  *   [proto tcp|udp]  *   [src<addr>[/n]]  *   [dst<addr>[/n]]  *   [type encode_tcp_stream|encode_ip_hdr|no_encode]  *  *   delete<rule number>  *  * Subfields can be in arbitrary order.  Port numbers and addresses  * must be in either numeric or symbolic form. An optional rule number  * is used to control the order in which rules are searched.  If two  * rules have the same number, then search order cannot be guaranteed,  * and the rules should be disjoint.  If no rule number is specified,  * then 0 is used, and group 0 rules are always checked before any  * others.  */
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|cmd_len
decl_stmt|;
name|int
name|token_count
decl_stmt|;
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
name|str_port
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|char
name|str_server_port
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|res
init|=
name|buffer
decl_stmt|;
name|int
name|rule_index
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
name|proxy_type
decl_stmt|;
name|int
name|proxy_port
decl_stmt|;
name|int
name|server_port
decl_stmt|;
name|struct
name|in_addr
name|server_addr
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|,
name|src_mask
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|,
name|dst_mask
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|proxy_entry
decl_stmt|;
name|LIBALIAS_LOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Copy command line into a buffer */
name|cmd
operator|+=
name|strspn
argument_list|(
name|cmd
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|cmd_len
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Convert to lower case */
name|len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set default proxy type */
comment|/* Set up default values */
name|rule_index
operator|=
literal|0
expr_stmt|;
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_NONE
expr_stmt|;
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|proxy_port
operator|=
literal|0
expr_stmt|;
name|server_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|server_port
operator|=
literal|0
expr_stmt|;
name|src_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|IpMask
argument_list|(
literal|0
argument_list|,
operator|&
name|src_mask
argument_list|)
expr_stmt|;
name|dst_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|IpMask
argument_list|(
literal|0
argument_list|,
operator|&
name|dst_mask
argument_list|)
expr_stmt|;
name|str_port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|str_server_port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Parse command string with state machine */
define|#
directive|define
name|STATE_READ_KEYWORD
value|0
define|#
directive|define
name|STATE_READ_TYPE
value|1
define|#
directive|define
name|STATE_READ_PORT
value|2
define|#
directive|define
name|STATE_READ_SERVER
value|3
define|#
directive|define
name|STATE_READ_RULE
value|4
define|#
directive|define
name|STATE_READ_DELETE
value|5
define|#
directive|define
name|STATE_READ_PROTO
value|6
define|#
directive|define
name|STATE_READ_SRC
value|7
define|#
directive|define
name|STATE_READ_DST
value|8
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|res
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|token_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|token_count
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|STATE_READ_KEYWORD
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_PORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_SERVER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"rule"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_RULE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_DELETE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"proto"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_PROTO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"src"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_SRC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"dst"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_DST
expr_stmt|;
else|else
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
break|break;
case|case
name|STATE_READ_TYPE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"encode_ip_hdr"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_IPHDR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"encode_tcp_stream"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_TCPSTREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"no_encode"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_NONE
expr_stmt|;
else|else
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_PORT
case|:
name|strcpy
argument_list|(
name|str_port
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_SERVER
case|:
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|s
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|err
operator|=
name|IpAddr
argument_list|(
name|token
argument_list|,
operator|&
name|server_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%s %s"
argument_list|,
name|s
argument_list|,
name|str_server_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|err
operator|=
name|IpAddr
argument_list|(
name|s
argument_list|,
operator|&
name|server_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_RULE
case|:
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|rule_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
operator|||
name|rule_index
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_DELETE
case|:
block|{
name|int
name|err
decl_stmt|;
name|int
name|rule_to_delete
decl_stmt|;
if|if
condition|(
name|token_count
operator|!=
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|rule_to_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|err
operator|=
name|RuleNumberDelete
argument_list|(
name|la
argument_list|,
name|rule_to_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
case|case
name|STATE_READ_PROTO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
else|else
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_SRC
case|:
case|case
name|STATE_READ_DST
case|:
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|in_addr
name|mask
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
name|IpMask
argument_list|(
literal|32
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|err
operator|=
name|IpAddr
argument_list|(
name|token
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
else|else
block|{
name|int
name|nbits
decl_stmt|;
name|char
name|s
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%s %d"
argument_list|,
name|s
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|err
operator|=
name|IpAddr
argument_list|(
name|s
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|err
operator|=
name|IpMask
argument_list|(
name|nbits
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|STATE_READ_SRC
condition|)
block|{
name|src_addr
operator|=
name|addr
expr_stmt|;
name|src_mask
operator|=
name|mask
expr_stmt|;
block|}
else|else
block|{
name|dst_addr
operator|=
name|addr
expr_stmt|;
name|dst_mask
operator|=
name|mask
expr_stmt|;
block|}
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
break|break;
block|}
do|do
block|{
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|res
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|token
condition|)
do|;
block|}
undef|#
directive|undef
name|STATE_READ_KEYWORD
undef|#
directive|undef
name|STATE_READ_TYPE
undef|#
directive|undef
name|STATE_READ_PORT
undef|#
directive|undef
name|STATE_READ_SERVER
undef|#
directive|undef
name|STATE_READ_RULE
undef|#
directive|undef
name|STATE_READ_DELETE
undef|#
directive|undef
name|STATE_READ_PROTO
undef|#
directive|undef
name|STATE_READ_SRC
undef|#
directive|undef
name|STATE_READ_DST
comment|/* Convert port strings to numbers.  This needs to be done after    the string is parsed, because the prototype might not be designated    before the ports (which might be symbolic entries in /etc/services) */
if|if
condition|(
name|strlen
argument_list|(
name|str_port
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|IpPort
argument_list|(
name|str_port
argument_list|,
name|proto
argument_list|,
operator|&
name|proxy_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
else|else
block|{
name|proxy_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|str_server_port
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|IpPort
argument_list|(
name|str_server_port
argument_list|,
name|proto
argument_list|,
operator|&
name|server_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
block|}
else|else
block|{
name|server_port
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check that at least the server address has been defined */
if|if
condition|(
name|server_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
comment|/* Add to linked list */
name|proxy_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|proxy_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy_entry
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|proxy_entry
operator|->
name|proxy_type
operator|=
name|proxy_type
expr_stmt|;
name|proxy_entry
operator|->
name|rule_index
operator|=
name|rule_index
expr_stmt|;
name|proxy_entry
operator|->
name|proto
operator|=
name|proto
expr_stmt|;
name|proxy_entry
operator|->
name|proxy_port
operator|=
name|htons
argument_list|(
name|proxy_port
argument_list|)
expr_stmt|;
name|proxy_entry
operator|->
name|server_port
operator|=
name|htons
argument_list|(
name|server_port
argument_list|)
expr_stmt|;
name|proxy_entry
operator|->
name|server_addr
operator|=
name|server_addr
expr_stmt|;
name|proxy_entry
operator|->
name|src_addr
operator|.
name|s_addr
operator|=
name|src_addr
operator|.
name|s_addr
operator|&
name|src_mask
operator|.
name|s_addr
expr_stmt|;
name|proxy_entry
operator|->
name|dst_addr
operator|.
name|s_addr
operator|=
name|dst_addr
operator|.
name|s_addr
operator|&
name|dst_mask
operator|.
name|s_addr
expr_stmt|;
name|proxy_entry
operator|->
name|src_mask
operator|=
name|src_mask
expr_stmt|;
name|proxy_entry
operator|->
name|dst_mask
operator|=
name|dst_mask
expr_stmt|;
name|RuleAdd
argument_list|(
name|la
argument_list|,
name|proxy_entry
argument_list|)
expr_stmt|;
name|getout
label|:
name|LIBALIAS_UNLOCK
argument_list|(
name|la
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

