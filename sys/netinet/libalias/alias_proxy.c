begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* file: alias_proxy.c      This file encapsulates special operations related to transparent     proxy redirection.  This is where packets with a particular destination,     usually tcp port 80, are redirected to a proxy server.      When packets are proxied, the destination address and port are     modified.  In certain cases, it is necessary to somehow encode     the original address/port info into the packet.  Two methods are     presently supported: addition of a [DEST addr port] string at the     beginning a of tcp stream, or inclusion of an optional field     in the IP header.          There is one public API function:          PacketAliasProxyRule()    -- Adds and deletes proxy                                      rules.      Rules are stored in a linear linked list, so lookup efficiency     won't be too good for large lists.       Initial development: April, 1998 (cjm)      $FreeBSD$ */
end_comment

begin_comment
comment|/* System includes */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* BSD IPV4 includes */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_comment
comment|/* Functions used by alias*.c */
end_comment

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_comment
comment|/* Public API functions for libalias */
end_comment

begin_comment
comment|/*     Data structures  */
end_comment

begin_comment
comment|/*  * A linked list of arbitrary length, based on struct proxy_entry is  * used to store proxy rules.  */
end_comment

begin_struct
struct|struct
name|proxy_entry
block|{
define|#
directive|define
name|PROXY_TYPE_ENCODE_NONE
value|1
define|#
directive|define
name|PROXY_TYPE_ENCODE_TCPSTREAM
value|2
define|#
directive|define
name|PROXY_TYPE_ENCODE_IPHDR
value|3
name|int
name|rule_index
decl_stmt|;
name|int
name|proxy_type
decl_stmt|;
name|u_char
name|proto
decl_stmt|;
name|u_short
name|proxy_port
decl_stmt|;
name|u_short
name|server_port
decl_stmt|;
name|struct
name|in_addr
name|server_addr
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|struct
name|in_addr
name|src_mask
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
name|struct
name|in_addr
name|dst_mask
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|next
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*     File scope variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|proxy_entry
modifier|*
name|proxyList
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local (static) functions:      IpMask()                 -- Utility function for creating IP                                 masks from integer (1-32) specification.     IpAddr()                 -- Utility function for converting string                                 to IP address     IpPort()                 -- Utility function for converting string                                 to port number     RuleAdd()                -- Adds an element to the rule list.     RuleDelete()             -- Removes an element from the rule list.     RuleNumberDelete()       -- Removes all elements from the rule list                                 having a certain rule number.     ProxyEncodeTcpStream()   -- Adds [DEST x.x.x.x xxxx] to the beginning                                 of a TCP stream.     ProxyEncodeIpHeader()    -- Adds an IP option indicating the true                                 destination of a proxied IP packet */
end_comment

begin_function_decl
specifier|static
name|int
name|IpMask
parameter_list|(
name|int
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IpAddr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IpPort
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RuleAdd
parameter_list|(
name|struct
name|proxy_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RuleDelete
parameter_list|(
name|struct
name|proxy_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RuleNumberDelete
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ProxyEncodeTcpStream
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ProxyEncodeIpHeader
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|IpMask
parameter_list|(
name|int
name|nbits
parameter_list|,
name|struct
name|in_addr
modifier|*
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|imask
decl_stmt|;
if|if
condition|(
name|nbits
operator|<
literal|0
operator|||
name|nbits
operator|>
literal|32
condition|)
return|return
operator|-
literal|1
return|;
name|imask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbits
condition|;
name|i
operator|++
control|)
name|imask
operator|=
operator|(
name|imask
operator|>>
literal|1
operator|)
operator|+
literal|0x80000000
expr_stmt|;
name|mask
operator|->
name|s_addr
operator|=
name|htonl
argument_list|(
name|imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IpAddr
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|inet_aton
argument_list|(
name|s
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IpPort
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
modifier|*
name|port
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|struct
name|servent
modifier|*
name|se
decl_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|se
operator|=
name|getservbyname
argument_list|(
name|s
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDP
condition|)
name|se
operator|=
name|getservbyname
argument_list|(
name|s
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|port
operator|=
operator|(
name|u_int
operator|)
name|ntohs
argument_list|(
name|se
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|RuleAdd
parameter_list|(
name|struct
name|proxy_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|rule_index
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr_last
decl_stmt|;
if|if
condition|(
name|proxyList
operator|==
name|NULL
condition|)
block|{
name|proxyList
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|rule_index
operator|=
name|entry
operator|->
name|rule_index
expr_stmt|;
name|ptr
operator|=
name|proxyList
expr_stmt|;
name|ptr_last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rule_index
operator|>=
name|rule_index
condition|)
block|{
if|if
condition|(
name|ptr_last
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|next
operator|=
name|proxyList
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|proxyList
operator|->
name|last
operator|=
name|entry
expr_stmt|;
name|proxyList
operator|=
name|entry
expr_stmt|;
return|return;
block|}
name|ptr_last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|ptr
operator|->
name|last
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|ptr
operator|->
name|last
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
return|return;
block|}
name|ptr_last
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|ptr_last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|last
operator|=
name|ptr_last
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RuleDelete
parameter_list|(
name|struct
name|proxy_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|last
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|last
operator|->
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
else|else
name|proxyList
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|next
operator|->
name|last
operator|=
name|entry
operator|->
name|last
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|RuleNumberDelete
parameter_list|(
name|int
name|rule_index
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|proxyList
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|proxy_entry
modifier|*
name|ptr_next
decl_stmt|;
name|ptr_next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|rule_index
operator|==
name|rule_index
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|RuleDelete
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|ptr_next
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ProxyEncodeTcpStream
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
comment|/* Compute pointer to tcp header */
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* Don't modify if once already modified */
if|if
condition|(
name|GetAckModified
argument_list|(
name|link
argument_list|)
condition|)
return|return;
comment|/* Translate destination address and port to string form */
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|2
argument_list|,
literal|"[DEST %s %d]"
argument_list|,
name|inet_ntoa
argument_list|(
name|GetProxyAddress
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|ntohs
argument_list|(
name|GetProxyPort
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pad string out to a multiple of two in length */
name|slen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|slen
operator|%
literal|2
condition|)
block|{
case|case
literal|0
case|:
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
name|slen
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|slen
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Check for packet overflow */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
name|maxpacketsize
condition|)
return|return;
comment|/* Shift existing TCP data and insert destination string */
block|{
name|int
name|dlen
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|dlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
expr_stmt|;
comment|/* Modify first packet that has data in it */
if|if
condition|(
name|dlen
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
name|p
operator|+=
name|hlen
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|slen
argument_list|,
name|p
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
comment|/* Save information about modfied sequence number */
block|{
name|int
name|delta
decl_stmt|;
name|SetAckModified
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|delta
operator|=
name|GetDeltaSeqOut
argument_list|(
name|pip
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|AddSeq
argument_list|(
name|pip
argument_list|,
name|link
argument_list|,
name|delta
operator|+
name|slen
argument_list|)
expr_stmt|;
block|}
comment|/* Update IP header packet length and checksum */
block|{
name|int
name|accumulate
decl_stmt|;
name|accumulate
operator|=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|slen
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
block|}
comment|/* Update TCP checksum, Use TcpChecksum since so many things have    already changed. */
name|tc
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|th_sum
operator|=
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ProxyEncodeIpHeader
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
define|#
directive|define
name|OPTION_LEN_BYTES
value|8
define|#
directive|define
name|OPTION_LEN_INT16
value|4
define|#
directive|define
name|OPTION_LEN_INT32
value|2
name|u_char
name|option
index|[
name|OPTION_LEN_BYTES
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ip cksum 1 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|IpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"tcp cksum 1 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check to see that there is room to add an IP option */
if|if
condition|(
name|pip
operator|->
name|ip_hl
operator|>
operator|(
literal|0x0f
operator|-
name|OPTION_LEN_INT32
operator|)
condition|)
return|return;
comment|/* Build option and copy into packet */
block|{
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pip
expr_stmt|;
name|ptr
operator|+=
literal|20
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|+
name|OPTION_LEN_BYTES
argument_list|,
name|ptr
argument_list|,
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|-
literal|20
argument_list|)
expr_stmt|;
name|option
index|[
literal|0
index|]
operator|=
literal|0x64
expr_stmt|;
comment|/* class: 3 (reserved), option 4 */
name|option
index|[
literal|1
index|]
operator|=
name|OPTION_LEN_BYTES
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|option
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pip
operator|->
name|ip_dst
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|option
index|[
literal|6
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tc
operator|->
name|th_sport
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|option
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Update checksum, header length and packet length */
block|{
name|int
name|i
decl_stmt|;
name|int
name|accumulate
decl_stmt|;
name|u_short
modifier|*
name|sptr
decl_stmt|;
name|sptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|option
expr_stmt|;
name|accumulate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_LEN_INT16
condition|;
name|i
operator|++
control|)
name|accumulate
operator|-=
operator|*
operator|(
name|sptr
operator|++
operator|)
expr_stmt|;
name|sptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|pip
expr_stmt|;
name|accumulate
operator|+=
operator|*
name|sptr
expr_stmt|;
name|pip
operator|->
name|ip_hl
operator|+=
name|OPTION_LEN_INT32
expr_stmt|;
name|accumulate
operator|-=
operator|*
name|sptr
expr_stmt|;
name|accumulate
operator|+=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|+
name|OPTION_LEN_BYTES
argument_list|)
expr_stmt|;
name|accumulate
operator|-=
name|pip
operator|->
name|ip_len
expr_stmt|;
name|ADJUST_CHECKSUM
argument_list|(
name|accumulate
argument_list|,
name|pip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|OPTION_LEN_BYTES
undef|#
directive|undef
name|OPTION_LEN_INT16
undef|#
directive|undef
name|OPTION_LEN_INT32
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ip cksum 2 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|IpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"tcp cksum 2 = %x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Functions by other packet alias source files      ProxyCheck()         -- Checks whether an outgoing packet should                             be proxied.     ProxyModify()        -- Encodes the original destination address/port                             for a packet which is to be redirected to                             a proxy server. */
end_comment

begin_function
name|int
name|ProxyCheck
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|in_addr
modifier|*
name|proxy_server_addr
parameter_list|,
name|u_short
modifier|*
name|proxy_server_port
parameter_list|)
block|{
name|u_short
name|dst_port
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|ptr
decl_stmt|;
name|src_addr
operator|=
name|pip
operator|->
name|ip_src
expr_stmt|;
name|dst_addr
operator|=
name|pip
operator|->
name|ip_dst
expr_stmt|;
name|dst_port
operator|=
operator|(
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
operator|)
operator|->
name|th_dport
expr_stmt|;
name|ptr
operator|=
name|proxyList
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|u_short
name|proxy_port
decl_stmt|;
name|proxy_port
operator|=
name|ptr
operator|->
name|proxy_port
expr_stmt|;
if|if
condition|(
operator|(
name|dst_port
operator|==
name|proxy_port
operator|||
name|proxy_port
operator|==
literal|0
operator|)
operator|&&
name|pip
operator|->
name|ip_p
operator|==
name|ptr
operator|->
name|proto
operator|&&
name|src_addr
operator|.
name|s_addr
operator|!=
name|ptr
operator|->
name|server_addr
operator|.
name|s_addr
condition|)
block|{
name|struct
name|in_addr
name|src_addr_masked
decl_stmt|;
name|struct
name|in_addr
name|dst_addr_masked
decl_stmt|;
name|src_addr_masked
operator|.
name|s_addr
operator|=
name|src_addr
operator|.
name|s_addr
operator|&
name|ptr
operator|->
name|src_mask
operator|.
name|s_addr
expr_stmt|;
name|dst_addr_masked
operator|.
name|s_addr
operator|=
name|dst_addr
operator|.
name|s_addr
operator|&
name|ptr
operator|->
name|dst_mask
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
operator|(
name|src_addr_masked
operator|.
name|s_addr
operator|==
name|ptr
operator|->
name|src_addr
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|dst_addr_masked
operator|.
name|s_addr
operator|==
name|ptr
operator|->
name|dst_addr
operator|.
name|s_addr
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|proxy_server_port
operator|=
name|ptr
operator|->
name|server_port
operator|)
operator|==
literal|0
condition|)
operator|*
name|proxy_server_port
operator|=
name|dst_port
expr_stmt|;
operator|*
name|proxy_server_addr
operator|=
name|ptr
operator|->
name|server_addr
expr_stmt|;
return|return
name|ptr
operator|->
name|proxy_type
return|;
block|}
block|}
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ProxyModify
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|maxpacketsize
parameter_list|,
name|int
name|proxy_type
parameter_list|)
block|{
switch|switch
condition|(
name|proxy_type
condition|)
block|{
case|case
name|PROXY_TYPE_ENCODE_IPHDR
case|:
name|ProxyEncodeIpHeader
argument_list|(
name|pip
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROXY_TYPE_ENCODE_TCPSTREAM
case|:
name|ProxyEncodeTcpStream
argument_list|(
name|link
argument_list|,
name|pip
argument_list|,
name|maxpacketsize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*     Public API functions */
end_comment

begin_function
name|int
name|PacketAliasProxyRule
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
comment|/*  * This function takes command strings of the form:  *  *   server<addr>[:<port>]  *   [port<port>]  *   [rule n]  *   [proto tcp|udp]  *   [src<addr>[/n]]  *   [dst<addr>[/n]]  *   [type encode_tcp_stream|encode_ip_hdr|no_encode]  *  *   delete<rule number>  *  * Subfields can be in arbitrary order.  Port numbers and addresses  * must be in either numeric or symbolic form. An optional rule number  * is used to control the order in which rules are searched.  If two  * rules have the same number, then search order cannot be guaranteed,  * and the rules should be disjoint.  If no rule number is specified,  * then 0 is used, and group 0 rules are always checked before any  * others.  */
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|len
decl_stmt|;
name|int
name|cmd_len
decl_stmt|;
name|int
name|token_count
decl_stmt|;
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
name|str_port
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|char
name|str_server_port
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|res
init|=
name|buffer
decl_stmt|;
name|int
name|rule_index
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
name|proxy_type
decl_stmt|;
name|int
name|proxy_port
decl_stmt|;
name|int
name|server_port
decl_stmt|;
name|struct
name|in_addr
name|server_addr
decl_stmt|;
name|struct
name|in_addr
name|src_addr
decl_stmt|,
name|src_mask
decl_stmt|;
name|struct
name|in_addr
name|dst_addr
decl_stmt|,
name|dst_mask
decl_stmt|;
name|struct
name|proxy_entry
modifier|*
name|proxy_entry
decl_stmt|;
comment|/* Copy command line into a buffer */
name|cmd
operator|+=
name|strspn
argument_list|(
name|cmd
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|cmd_len
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Convert to lower case */
name|len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set default proxy type */
comment|/* Set up default values */
name|rule_index
operator|=
literal|0
expr_stmt|;
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_NONE
expr_stmt|;
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|proxy_port
operator|=
literal|0
expr_stmt|;
name|server_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|server_port
operator|=
literal|0
expr_stmt|;
name|src_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|IpMask
argument_list|(
literal|0
argument_list|,
operator|&
name|src_mask
argument_list|)
expr_stmt|;
name|dst_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|IpMask
argument_list|(
literal|0
argument_list|,
operator|&
name|dst_mask
argument_list|)
expr_stmt|;
name|str_port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|str_server_port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Parse command string with state machine */
define|#
directive|define
name|STATE_READ_KEYWORD
value|0
define|#
directive|define
name|STATE_READ_TYPE
value|1
define|#
directive|define
name|STATE_READ_PORT
value|2
define|#
directive|define
name|STATE_READ_SERVER
value|3
define|#
directive|define
name|STATE_READ_RULE
value|4
define|#
directive|define
name|STATE_READ_DELETE
value|5
define|#
directive|define
name|STATE_READ_PROTO
value|6
define|#
directive|define
name|STATE_READ_SRC
value|7
define|#
directive|define
name|STATE_READ_DST
value|8
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|res
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|token_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|token_count
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|STATE_READ_KEYWORD
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_PORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_SERVER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"rule"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_RULE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_DELETE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"proto"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_PROTO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"src"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_SRC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"dst"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|STATE_READ_DST
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|STATE_READ_TYPE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"encode_ip_hdr"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_IPHDR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"encode_tcp_stream"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_TCPSTREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"no_encode"
argument_list|)
operator|==
literal|0
condition|)
name|proxy_type
operator|=
name|PROXY_TYPE_ENCODE_NONE
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_PORT
case|:
name|strcpy
argument_list|(
name|str_port
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_SERVER
case|:
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|s
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|err
operator|=
name|IpAddr
argument_list|(
name|token
argument_list|,
operator|&
name|server_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%s %s"
argument_list|,
name|s
argument_list|,
name|str_server_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|err
operator|=
name|IpAddr
argument_list|(
name|s
argument_list|,
operator|&
name|server_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_RULE
case|:
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|rule_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
operator|||
name|rule_index
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_DELETE
case|:
block|{
name|int
name|err
decl_stmt|;
name|int
name|rule_to_delete
decl_stmt|;
if|if
condition|(
name|token_count
operator|!=
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|rule_to_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|err
operator|=
name|RuleNumberDelete
argument_list|(
name|rule_to_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|STATE_READ_PROTO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
case|case
name|STATE_READ_SRC
case|:
case|case
name|STATE_READ_DST
case|:
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|in_addr
name|mask
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
name|IpMask
argument_list|(
literal|32
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|err
operator|=
name|IpAddr
argument_list|(
name|token
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|int
name|n
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|char
name|s
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
index|]
decl_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%s %d"
argument_list|,
name|s
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|err
operator|=
name|IpAddr
argument_list|(
name|s
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
name|err
operator|=
name|IpMask
argument_list|(
name|nbits
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|state
operator|==
name|STATE_READ_SRC
condition|)
block|{
name|src_addr
operator|=
name|addr
expr_stmt|;
name|src_mask
operator|=
name|mask
expr_stmt|;
block|}
else|else
block|{
name|dst_addr
operator|=
name|addr
expr_stmt|;
name|dst_mask
operator|=
name|mask
expr_stmt|;
block|}
block|}
name|state
operator|=
name|STATE_READ_KEYWORD
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
break|break;
block|}
do|do
block|{
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|res
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|token
condition|)
do|;
block|}
undef|#
directive|undef
name|STATE_READ_KEYWORD
undef|#
directive|undef
name|STATE_READ_TYPE
undef|#
directive|undef
name|STATE_READ_PORT
undef|#
directive|undef
name|STATE_READ_SERVER
undef|#
directive|undef
name|STATE_READ_RULE
undef|#
directive|undef
name|STATE_READ_DELETE
undef|#
directive|undef
name|STATE_READ_PROTO
undef|#
directive|undef
name|STATE_READ_SRC
undef|#
directive|undef
name|STATE_READ_DST
comment|/* Convert port strings to numbers.  This needs to be done after    the string is parsed, because the prototype might not be designated    before the ports (which might be symbolic entries in /etc/services) */
if|if
condition|(
name|strlen
argument_list|(
name|str_port
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|IpPort
argument_list|(
name|str_port
argument_list|,
name|proto
argument_list|,
operator|&
name|proxy_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|proxy_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|str_server_port
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|IpPort
argument_list|(
name|str_server_port
argument_list|,
name|proto
argument_list|,
operator|&
name|server_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|server_port
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check that at least the server address has been defined */
if|if
condition|(
name|server_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Add to linked list */
name|proxy_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|proxy_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy_entry
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|proxy_entry
operator|->
name|proxy_type
operator|=
name|proxy_type
expr_stmt|;
name|proxy_entry
operator|->
name|rule_index
operator|=
name|rule_index
expr_stmt|;
name|proxy_entry
operator|->
name|proto
operator|=
name|proto
expr_stmt|;
name|proxy_entry
operator|->
name|proxy_port
operator|=
name|htons
argument_list|(
name|proxy_port
argument_list|)
expr_stmt|;
name|proxy_entry
operator|->
name|server_port
operator|=
name|htons
argument_list|(
name|server_port
argument_list|)
expr_stmt|;
name|proxy_entry
operator|->
name|server_addr
operator|=
name|server_addr
expr_stmt|;
name|proxy_entry
operator|->
name|src_addr
operator|.
name|s_addr
operator|=
name|src_addr
operator|.
name|s_addr
operator|&
name|src_mask
operator|.
name|s_addr
expr_stmt|;
name|proxy_entry
operator|->
name|dst_addr
operator|.
name|s_addr
operator|=
name|dst_addr
operator|.
name|s_addr
operator|&
name|dst_mask
operator|.
name|s_addr
expr_stmt|;
name|proxy_entry
operator|->
name|src_mask
operator|=
name|src_mask
expr_stmt|;
name|proxy_entry
operator|->
name|dst_mask
operator|=
name|dst_mask
expr_stmt|;
name|RuleAdd
argument_list|(
name|proxy_entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

