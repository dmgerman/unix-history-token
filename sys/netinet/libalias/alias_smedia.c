begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * alias_smedia.c  *  * Copyright (c) 2000 Whistle Communications, Inc.  * All rights reserved.  *  * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *  * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Copyright (c) 2000  Junichi SATOH<junichi@astec.co.jp>  *<junichi@junichi.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Authors: Erik Salander<erik@whistle.com>  *          Junichi SATOH<junichi@astec.co.jp>  *<junichi@junichi.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    Alias_smedia.c is meant to contain the aliasing code for streaming media    protocols.  It performs special processing for RSTP sessions under TCP.    Specifically, when a SETUP request is sent by a client, or a 200 reply    is sent by a server, it is intercepted and modified.  The address is    changed to the gateway machine and an aliasing port is used.     More specifically, the "client_port" configuration parameter is    parsed for SETUP requests.  The "server_port" configuration parameter is    parsed for 200 replies eminating from a server.  This is intended to handle    the unicast case.     RTSP also allows a redirection of a stream to another client by using the    "destination" configuration parameter.  The destination config parm would    indicate a different IP address.  This function is NOT supported by the    RTSP translation code below.     The RTSP multicast functions without any address translation intervention.     For this routine to work, the SETUP/200 must fit entirely    into a single TCP packet.  This is typically the case, but exceptions    can easily be envisioned under the actual specifications.     Probably the most troubling aspect of the approach taken here is    that the new SETUP/200 will typically be a different length, and    this causes a certain amount of bookkeeping to keep track of the    changes of sequence and acknowledgment numbers, since the client    machine is totally unaware of the modification to the TCP stream.     Initial version:  May, 2000 (eds) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_mod.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_include
include|#
directive|include
file|"alias_mod.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RTSP_CONTROL_PORT_NUMBER_1
value|554
end_define

begin_define
define|#
directive|define
name|RTSP_CONTROL_PORT_NUMBER_2
value|7070
end_define

begin_define
define|#
directive|define
name|TFTP_PORT_NUMBER
value|69
end_define

begin_function_decl
specifier|static
name|void
name|AliasHandleRtspOut
parameter_list|(
name|struct
name|libalias
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|alias_link
modifier|*
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|fingerprint
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_data
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|->
name|dport
operator|==
name|NULL
operator|||
name|ah
operator|->
name|sport
operator|==
name|NULL
operator|||
name|ah
operator|->
name|lnk
operator|==
name|NULL
operator|||
name|ah
operator|->
name|maxpktsize
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|dport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_1
operator|||
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|sport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_1
operator|||
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|dport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_2
operator|||
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|sport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_2
operator|||
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|dport
argument_list|)
operator|==
name|TFTP_PORT_NUMBER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|protohandler
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_data
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
operator|*
name|ah
operator|->
name|dport
argument_list|)
operator|==
name|TFTP_PORT_NUMBER
condition|)
name|FindRtspOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
operator|*
name|ah
operator|->
name|sport
argument_list|,
operator|*
name|ah
operator|->
name|aport
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
else|else
name|AliasHandleRtspOut
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|ah
operator|->
name|lnk
argument_list|,
name|ah
operator|->
name|maxpktsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|proto_handler
name|handlers
index|[]
init|=
block|{
block|{
operator|.
name|pri
operator|=
literal|100
block|,
operator|.
name|dir
operator|=
name|OUT
block|,
operator|.
name|proto
operator|=
name|TCP
operator||
name|UDP
block|,
operator|.
name|fingerprint
operator|=
operator|&
name|fingerprint
block|,
operator|.
name|protohandler
operator|=
operator|&
name|protohandler
block|}
block|,
block|{
name|EOH
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mod_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|LibAliasAttachHandlers
argument_list|(
name|handlers
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|LibAliasDetachHandlers
argument_list|(
name|handlers
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
endif|#
directive|endif
name|moduledata_t
name|alias_mod
init|=
block|{
literal|"alias_smedia"
block|,
name|mod_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|alias_smedia
argument_list|,
name|alias_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|alias_smedia
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|alias_smedia
argument_list|,
name|libalias
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RTSP_CONTROL_PORT_NUMBER_1
value|554
end_define

begin_define
define|#
directive|define
name|RTSP_CONTROL_PORT_NUMBER_2
value|7070
end_define

begin_define
define|#
directive|define
name|RTSP_PORT_GROUP
value|2
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|a
parameter_list|)
value|(((a)>= '0')&& ((a)<= '9'))
end_define

begin_function
specifier|static
name|int
name|search_string
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|,
specifier|const
name|char
modifier|*
name|search_str
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|search_str_len
decl_stmt|;
name|search_str_len
operator|=
name|strlen
argument_list|(
name|search_str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
operator|-
name|search_str_len
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|dlen
operator|-
name|search_str_len
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|j
index|]
operator|!=
name|search_str
index|[
name|k
index|]
operator|&&
name|data
index|[
name|j
index|]
operator|!=
name|search_str
index|[
name|k
index|]
operator|-
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|k
operator|==
name|search_str_len
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|j
operator|+
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alias_rtsp_out
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|port_str
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|,
name|state
decl_stmt|,
name|port_dlen
decl_stmt|,
name|new_dlen
decl_stmt|,
name|delta
decl_stmt|;
name|u_short
name|p
index|[
literal|2
index|]
decl_stmt|,
name|new_len
decl_stmt|;
name|u_short
name|sport
decl_stmt|,
name|eport
decl_stmt|,
name|base_port
decl_stmt|;
name|u_short
name|salias
init|=
literal|0
decl_stmt|,
name|ealias
init|=
literal|0
decl_stmt|,
name|base_alias
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|transport_str
init|=
literal|"transport:"
decl_stmt|;
name|char
name|newdata
index|[
literal|2048
index|]
decl_stmt|,
modifier|*
name|port_data
decl_stmt|,
modifier|*
name|port_newdata
decl_stmt|,
name|stemp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|links_created
init|=
literal|0
decl_stmt|,
name|pkt_updated
init|=
literal|0
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|rtsp_lnk
init|=
name|NULL
decl_stmt|;
name|struct
name|in_addr
name|null_addr
decl_stmt|;
comment|/* Calculate data length of TCP packet */
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
comment|/* Find keyword, "Transport: " */
name|pos
operator|=
name|search_string
argument_list|(
name|data
argument_list|,
name|dlen
argument_list|,
name|transport_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|port_data
operator|=
name|data
operator|+
name|pos
expr_stmt|;
name|port_dlen
operator|=
name|dlen
operator|-
name|pos
expr_stmt|;
name|memcpy
argument_list|(
name|newdata
argument_list|,
name|data
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|port_newdata
operator|=
name|newdata
operator|+
name|pos
expr_stmt|;
while|while
condition|(
name|port_dlen
operator|>
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|port_str
argument_list|)
condition|)
block|{
comment|/* Find keyword, appropriate port string */
name|pos
operator|=
name|search_string
argument_list|(
name|port_data
argument_list|,
name|port_dlen
argument_list|,
name|port_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|memcpy
argument_list|(
name|port_newdata
argument_list|,
name|port_data
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|port_newdata
operator|+=
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sport
operator|=
name|eport
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pos
init|;
name|i
operator|<
name|port_dlen
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|port_data
index|[
name|i
index|]
operator|==
literal|'='
condition|)
block|{
name|state
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
name|port_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
operator|*
literal|10
operator|+
name|port_data
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|port_data
index|[
name|i
index|]
operator|==
literal|';'
condition|)
block|{
name|state
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|port_data
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|state
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
name|port_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|p
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|*
literal|10
operator|+
name|port_data
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|state
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|base_port
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|sport
operator|=
name|htons
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|eport
operator|=
name|htons
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|links_created
condition|)
block|{
name|links_created
operator|=
literal|1
expr_stmt|;
comment|/* 					 * Find an even numbered port 					 * number base that satisfies the 					 * contiguous number of ports we 					 * need 					 */
name|null_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|salias
operator|=
name|FindNewPortGroup
argument_list|(
name|la
argument_list|,
name|null_addr
argument_list|,
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|)
argument_list|,
name|sport
argument_list|,
literal|0
argument_list|,
name|RTSP_PORT_GROUP
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/RTSP: Cannot find contiguous RTSP data ports\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|base_alias
operator|=
name|ntohs
argument_list|(
name|salias
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RTSP_PORT_GROUP
condition|;
name|j
operator|++
control|)
block|{
comment|/* 							 * Establish link 							 * to port found in 							 * RTSP packet 							 */
name|rtsp_lnk
operator|=
name|FindRtspOut
argument_list|(
name|la
argument_list|,
name|GetOriginalAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|null_addr
argument_list|,
name|htons
argument_list|(
name|base_port
operator|+
name|j
argument_list|)
argument_list|,
name|htons
argument_list|(
name|base_alias
operator|+
name|j
argument_list|)
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtsp_lnk
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
comment|/* 								 * Punch 								 * hole in 								 * firewall 								 */
name|PunchFWHole
argument_list|(
name|rtsp_lnk
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBALIAS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/RTSP: Cannot allocate RTSP data ports\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
name|ealias
operator|=
name|htons
argument_list|(
name|base_alias
operator|+
operator|(
name|RTSP_PORT_GROUP
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|salias
operator|&&
name|rtsp_lnk
condition|)
block|{
name|pkt_updated
operator|=
literal|1
expr_stmt|;
comment|/* Copy into IP packet */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|salias
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|port_newdata
argument_list|,
name|stemp
argument_list|,
name|strlen
argument_list|(
name|stemp
argument_list|)
argument_list|)
expr_stmt|;
name|port_newdata
operator|+=
name|strlen
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eport
operator|!=
literal|0
condition|)
block|{
operator|*
name|port_newdata
operator|=
literal|'-'
expr_stmt|;
name|port_newdata
operator|++
expr_stmt|;
comment|/* Copy into IP packet */
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|ealias
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|port_newdata
argument_list|,
name|stemp
argument_list|,
name|strlen
argument_list|(
name|stemp
argument_list|)
argument_list|)
expr_stmt|;
name|port_newdata
operator|+=
name|strlen
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
block|}
operator|*
name|port_newdata
operator|=
literal|';'
expr_stmt|;
name|port_newdata
operator|++
expr_stmt|;
block|}
name|state
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|>
literal|3
condition|)
block|{
break|break;
block|}
block|}
name|port_data
operator|+=
name|i
expr_stmt|;
name|port_dlen
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pkt_updated
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|port_newdata
argument_list|,
name|port_data
argument_list|,
name|port_dlen
argument_list|)
expr_stmt|;
name|port_newdata
operator|+=
name|port_dlen
expr_stmt|;
operator|*
name|port_newdata
operator|=
literal|'\0'
expr_stmt|;
comment|/* Create new packet */
name|new_dlen
operator|=
name|port_newdata
operator|-
name|newdata
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|newdata
argument_list|,
name|new_dlen
argument_list|)
expr_stmt|;
name|SetAckModified
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|delta
operator|=
name|GetDeltaSeqOut
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|)
expr_stmt|;
name|AddSeq
argument_list|(
name|pip
argument_list|,
name|lnk
argument_list|,
name|delta
operator|+
name|new_dlen
operator|-
name|dlen
argument_list|)
expr_stmt|;
name|new_len
operator|=
name|htons
argument_list|(
name|hlen
operator|+
name|new_dlen
argument_list|)
expr_stmt|;
name|DifferentialChecksum
argument_list|(
operator|&
name|pip
operator|->
name|ip_sum
argument_list|,
operator|&
name|new_len
argument_list|,
operator|&
name|pip
operator|->
name|ip_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pip
operator|->
name|ip_len
operator|=
name|new_len
expr_stmt|;
name|tc
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|tc
operator|->
name|th_x2
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|tc
operator|->
name|th_sum
operator|=
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Support the protocol used by early versions of RealPlayer */
end_comment

begin_function
specifier|static
name|int
name|alias_pna_out
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|dlen
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|pna_links
decl_stmt|;
name|u_short
name|msg_id
decl_stmt|,
name|msg_len
decl_stmt|;
name|char
modifier|*
name|work
decl_stmt|;
name|u_short
name|alias_port
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|work
operator|=
name|data
expr_stmt|;
name|work
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|work
operator|+
literal|4
operator|<
name|data
operator|+
name|dlen
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|msg_id
argument_list|,
name|work
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|work
operator|+=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg_len
argument_list|,
name|work
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|work
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|msg_id
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* end of options */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|msg_id
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|msg_id
argument_list|)
operator|==
literal|7
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|port
argument_list|,
name|work
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pna_links
operator|=
name|FindUdpTcpOut
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|GetDestAddress
argument_list|(
name|lnk
argument_list|)
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|IPPROTO_UDP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pna_links
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_FW_PUNCH
comment|/* Punch hole in firewall */
name|PunchFWHole
argument_list|(
name|pna_links
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|alias_port
operator|=
name|GetAliasPort
argument_list|(
name|pna_links
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
argument_list|,
operator|&
name|alias_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Compute TCP checksum for revised packet */
name|tc
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|tc
operator|->
name|th_x2
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|tc
operator|->
name|th_sum
operator|=
name|TcpChecksum
argument_list|(
name|pip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|work
operator|+=
name|ntohs
argument_list|(
name|msg_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|AliasHandleRtspOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|lnk
parameter_list|,
name|int
name|maxpacketsize
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|setup
init|=
literal|"SETUP"
decl_stmt|,
modifier|*
name|pna
init|=
literal|"PNA"
decl_stmt|,
modifier|*
name|str200
init|=
literal|"200"
decl_stmt|;
specifier|const
name|char
modifier|*
name|okstr
init|=
literal|"OK"
decl_stmt|,
modifier|*
name|client_port_str
init|=
literal|"client_port"
decl_stmt|;
specifier|const
name|char
modifier|*
name|server_port_str
init|=
literal|"server_port"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|parseOk
decl_stmt|;
operator|(
name|void
operator|)
name|maxpacketsize
expr_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|pip
expr_stmt|;
name|data
operator|+=
name|hlen
expr_stmt|;
comment|/* When aliasing a client, check for the SETUP request */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|tc
operator|->
name|th_dport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_1
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|tc
operator|->
name|th_dport
argument_list|)
operator|==
name|RTSP_CONTROL_PORT_NUMBER_2
operator|)
condition|)
block|{
if|if
condition|(
name|dlen
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|setup
argument_list|)
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
name|setup
argument_list|,
name|strlen
argument_list|(
name|setup
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alias_rtsp_out
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|lnk
argument_list|,
name|data
argument_list|,
name|client_port_str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dlen
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|pna
argument_list|)
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
name|pna
argument_list|,
name|strlen
argument_list|(
name|pna
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alias_pna_out
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|lnk
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * When aliasing a server, check for the 200 reply 		 * Accomodate varying number of blanks between 200& OK 		 */
if|if
condition|(
name|dlen
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str200
argument_list|)
condition|)
block|{
for|for
control|(
name|parseOk
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dlen
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str200
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|data
index|[
name|i
index|]
argument_list|,
name|str200
argument_list|,
name|strlen
argument_list|(
name|str200
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parseOk
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|parseOk
condition|)
block|{
name|i
operator|+=
name|strlen
argument_list|(
name|str200
argument_list|)
expr_stmt|;
comment|/* skip string found */
while|while
condition|(
name|data
index|[
name|i
index|]
operator|==
literal|' '
condition|)
comment|/* skip blank(s) */
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dlen
operator|-
name|i
operator|)
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|okstr
argument_list|)
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|data
index|[
name|i
index|]
argument_list|,
name|okstr
argument_list|,
name|strlen
argument_list|(
name|okstr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|alias_rtsp_out
argument_list|(
name|la
argument_list|,
name|pip
argument_list|,
name|lnk
argument_list|,
name|data
argument_list|,
name|server_port_str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

