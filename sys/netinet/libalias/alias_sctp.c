begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * @file alias_sctp.c  * Copyright (c) 2008, Centre for Advanced Internet Architectures  * Swinburne University of Technology, Melbourne, Australia  * (CRICOS number 00111D).  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The names of the authors, the "Centre for Advanced Internet Architectures"  *     and "Swinburne University of Technology" may not be used to endorse  *     or promote products derived from this software without specific  *     prior written permission.  *   *  THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS "AS IS" AND  *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *  SUCH DAMAGE.  *  * Alias_sctp forms part of the libalias kernel module to handle   * Network Address Translation (NAT) for the SCTP protocol.  *  *  This software was developed by David A. Hayes and Jason But  *  * The design is outlined in CAIA technical report number  080618A  * (D. Hayes and J. But, "Alias_sctp Version 0.1: SCTP NAT implementation in IPFW")  *  * Development is part of the CAIA SONATA project,  * proposed by Jason But and Grenville Armitage:  * http://caia.swin.edu.au/urp/sonata/  *  *   * This project has been made possible in part by a grant from  * the Cisco University Research Program Fund at Community  * Foundation Silicon Valley.  *  */
end_comment

begin_comment
comment|/** @mainpage   * Alias_sctp is part of the SONATA (http://caia.swin.edu.au/urp/sonata) project  * to develop and release a BSD licensed implementation of a Network Address  * Translation (NAT) module that supports the Stream Control Transmission  * Protocol (SCTP).  *  * Traditional address and port number look ups are inadequate for SCTP's  * operation due to both processing requirements and issues with multi-homing.  * Alias_sctp integrates with FreeBSD's ipfw/libalias NAT system.  *  * Version 0.2 features include:  * - Support for global multi-homing  * - Support for ASCONF modification from Internet Draft  *   (draft-stewart-behave-sctpnat-04, R. Stewart and M. Tuexen, "Stream control  *   transmission protocol (SCTP) network address translation," Jul. 2008) to  *   provide support for multi-homed privately addressed hosts  * - Support for forwarding of T-flagged packets  * - Generation and delivery of AbortM/ErrorM packets upon detection of NAT  *   collisions  * - Per-port forwarding rules  * - Dynamically controllable logging and statistics  * - Dynamic management of timers  * - Dynamic control of hash-table size  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias.h>
end_include

begin_include
include|#
directive|include
file|<netinet/libalias/alias_local.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"alias_sctp.h"
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//#ifdef _KERNEL
end_comment

begin_comment
comment|/* ----------------------------------------------------------------------  *                          FUNCTION PROTOTYPES  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Packet Parsing Functions */
end_comment

begin_function_decl
specifier|static
name|int
name|sctp_PktParser
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
modifier|*
name|passoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GetAsconfVtags
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|uint32_t
modifier|*
name|l_vtag
parameter_list|,
name|uint32_t
modifier|*
name|g_vtag
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IsASCONFack
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AddGlobalIPAddresses
parameter_list|(
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|Add_Global_Address_to_List
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RmGlobalIPAddresses
parameter_list|(
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IsADDorDEL
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* State Machine Functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ProcessSctpMsg
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|, \
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ID_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|INi_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|INa_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|UP_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CL_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|TxAbortErrorM
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,\
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|sndrply
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash Table Functions */
end_comment

begin_function_decl
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|l_addr
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|l_vtag
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|uint16_t
name|g_port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|g_vtag
parameter_list|,
name|uint16_t
name|g_port
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|int
modifier|*
name|partial_match
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobalClash
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|Cassoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpLocalT
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|l_vtag
parameter_list|,
name|uint16_t
name|g_port
parameter_list|,
name|uint16_t
name|l_port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobalT
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|g_vtag
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|uint16_t
name|g_port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AddSctpAssocLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AddSctpAssocGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RmSctpAssoc
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freeGlobalAddressList
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Timer Queue Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|sctp_AddTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sctp_RmTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sctp_ResetTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|newexp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sctp_CheckTimers
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Logging Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|logsctperror
parameter_list|(
name|char
modifier|*
name|errormsg
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logsctpparse
parameter_list|(
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logsctpassoc
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logTimerQ
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logSctpGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logSctpLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function_decl
specifier|static
name|void
name|SctpAliasLog
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** @defgroup external External code changes and modifications  *  * Some changes have been made to files external to alias_sctp.(c|h). These  * changes are primarily due to code needing to call static functions within  * those files or to perform extra functionality that can only be performed  * within these files.  */
end_comment

begin_comment
comment|/** @ingroup external  * @brief Log current statistics for the libalias instance  *  * This function is defined in alias_db.c, since it calls static functions in  * this file  *  * Calls the higher level ShowAliasStats() in alias_db.c which logs all current  * statistics about the libalias instance - including SCTP statistics  *   * @param la Pointer to the libalias instance  */
end_comment

begin_function_decl
name|void
name|SctpShowAliasStats
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SCTPNAT
argument_list|,
literal|"sctpnat"
argument_list|,
literal|"sctp nat dbs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Use kernel allocator. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_SYS_MALLOC_H_
end_ifdef

begin_define
define|#
directive|define
name|sn_malloc
parameter_list|(
name|x
parameter_list|)
value|malloc(x, M_SCTPNAT, M_NOWAIT|M_ZERO)
end_define

begin_define
define|#
directive|define
name|sn_calloc
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|sn_malloc(x * n)
end_define

begin_define
define|#
directive|define
name|sn_free
parameter_list|(
name|x
parameter_list|)
value|free(x, M_SCTPNAT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// #ifdef _SYS_MALLOC_H_
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|//#ifdef	_KERNEL
end_comment

begin_define
define|#
directive|define
name|sn_malloc
parameter_list|(
name|x
parameter_list|)
value|malloc(x)
end_define

begin_define
define|#
directive|define
name|sn_calloc
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|calloc(n, x)
end_define

begin_define
define|#
directive|define
name|sn_free
parameter_list|(
name|x
parameter_list|)
value|free(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//#ifdef	_KERNEL
end_comment

begin_comment
comment|/** @defgroup packet_parser SCTP Packet Parsing  *  * Macros to:  * - Return pointers to the first and next SCTP chunks within an SCTP Packet  * - Define possible return values of the packet parsing process  * - SCTP message types for storing in the sctp_nat_msg structure @{  */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_FIRSTCHUNK
parameter_list|(
name|sctphead
parameter_list|)
value|(struct sctp_chunkhdr *)(((char *)sctphead) + sizeof(struct sctphdr))
end_define

begin_comment
comment|/**< Returns a pointer to the first chunk in an SCTP packet given a pointer to the SCTP header */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_NEXTCHUNK
parameter_list|(
name|chunkhead
parameter_list|)
value|(struct sctp_chunkhdr *)(((char *)chunkhead) + SCTP_SIZE32(ntohs(chunkhead->chunk_length)))
end_define

begin_comment
comment|/**< Returns a pointer to the next chunk in an SCTP packet given a pointer to the current chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_NEXTPARAM
parameter_list|(
name|param
parameter_list|)
value|(struct sctp_paramhdr *)(((char *)param) + SCTP_SIZE32(ntohs(param->param_length)))
end_define

begin_comment
comment|/**< Returns a pointer to the next parameter in an SCTP packet given a pointer to the current parameter */
end_comment

begin_define
define|#
directive|define
name|SN_MIN_CHUNK_SIZE
value|4
end_define

begin_comment
comment|/**< Smallest possible SCTP chunk size in bytes */
end_comment

begin_define
define|#
directive|define
name|SN_MIN_PARAM_SIZE
value|4
end_define

begin_comment
comment|/**< Smallest possible SCTP param size in bytes */
end_comment

begin_define
define|#
directive|define
name|SN_VTAG_PARAM_SIZE
value|12
end_define

begin_comment
comment|/**< Size of  SCTP ASCONF vtag param in bytes */
end_comment

begin_define
define|#
directive|define
name|SN_ASCONFACK_PARAM_SIZE
value|8
end_define

begin_comment
comment|/**< Size of  SCTP ASCONF ACK param in bytes */
end_comment

begin_comment
comment|/* Packet parsing return codes */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_OK
value|0
end_define

begin_comment
comment|/**< Packet parsed for SCTP messages */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_IPSHL
value|1
end_define

begin_comment
comment|/**< Packet parsing error - IP and SCTP common header len */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_AS_MALLOC
value|2
end_define

begin_comment
comment|/**< Packet parsing error - assoc malloc */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_CHHL
value|3
end_define

begin_comment
comment|/**< Packet parsing error - Chunk header len */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_DIR
value|4
end_define

begin_comment
comment|/**< Packet parsing error - Direction */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_VTAG
value|5
end_define

begin_comment
comment|/**< Packet parsing error - Vtag */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_CHUNK
value|6
end_define

begin_comment
comment|/**< Packet parsing error - Chunk */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_PORT
value|7
end_define

begin_comment
comment|/**< Packet parsing error - Port=0 */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_LOOKUP
value|8
end_define

begin_comment
comment|/**< Packet parsing error - Lookup */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_PARTIALLOOKUP
value|9
end_define

begin_comment
comment|/**< Packet parsing error - partial lookup only found */
end_comment

begin_define
define|#
directive|define
name|SN_PARSE_ERROR_LOOKUP_ABORT
value|10
end_define

begin_comment
comment|/**< Packet parsing error - Lookup - but abort packet */
end_comment

begin_comment
comment|/* Alias_sctp performs its processing based on a number of key messages */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_ABORT
value|0x0000
end_define

begin_comment
comment|/**< a packet containing an ABORT chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_INIT
value|0x0001
end_define

begin_comment
comment|/**< a packet containing an INIT chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_INITACK
value|0x0002
end_define

begin_comment
comment|/**< a packet containing an INIT-ACK chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_SHUTCOMP
value|0x0010
end_define

begin_comment
comment|/**< a packet containing a SHUTDOWN-COMPLETE chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_SHUTACK
value|0x0020
end_define

begin_comment
comment|/**< a packet containing a SHUTDOWN-ACK chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_ASCONF
value|0x0100
end_define

begin_comment
comment|/**< a packet containing an ASCONF chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_ASCONFACK
value|0x0200
end_define

begin_comment
comment|/**< a packet containing an ASCONF-ACK chunk */
end_comment

begin_define
define|#
directive|define
name|SN_SCTP_OTHER
value|0xFFFF
end_define

begin_comment
comment|/**< a packet containing a chunk that is not of interest */
end_comment

begin_comment
comment|/** @}  * @defgroup state_machine SCTP NAT State Machine  *  * Defines the various states an association can be within the NAT @{  */
end_comment

begin_define
define|#
directive|define
name|SN_ID
value|0x0000
end_define

begin_comment
comment|/**< Idle state */
end_comment

begin_define
define|#
directive|define
name|SN_INi
value|0x0010
end_define

begin_comment
comment|/**< Initialising, waiting for InitAck state */
end_comment

begin_define
define|#
directive|define
name|SN_INa
value|0x0020
end_define

begin_comment
comment|/**< Initialising, waiting for AddIpAck state */
end_comment

begin_define
define|#
directive|define
name|SN_UP
value|0x0100
end_define

begin_comment
comment|/**< Association in UP state */
end_comment

begin_define
define|#
directive|define
name|SN_CL
value|0x1000
end_define

begin_comment
comment|/**< Closing state */
end_comment

begin_define
define|#
directive|define
name|SN_RM
value|0x2000
end_define

begin_comment
comment|/**< Removing state */
end_comment

begin_comment
comment|/** @}  * @defgroup Logging Logging Functionality  *  * Define various log levels and a macro to call specified log functions only if  * the current log level (sysctl_log_level) matches the specified level @{  */
end_comment

begin_define
define|#
directive|define
name|SN_LOG_LOW
value|0
end_define

begin_define
define|#
directive|define
name|SN_LOG_EVENT
value|1
end_define

begin_define
define|#
directive|define
name|SN_LOG_INFO
value|2
end_define

begin_define
define|#
directive|define
name|SN_LOG_DETAIL
value|3
end_define

begin_define
define|#
directive|define
name|SN_LOG_DEBUG
value|4
end_define

begin_define
define|#
directive|define
name|SN_LOG_DEBUG_MAX
value|5
end_define

begin_define
define|#
directive|define
name|SN_LOG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
value|if (sysctl_log_level>= level) { action; }
end_define

begin_comment
comment|/**< Perform log action ONLY if the current log level meets the specified log level */
end_comment

begin_comment
comment|/** @}  * @defgroup Hash Hash Table Macros and Functions  *  * Defines minimum/maximum/default values for the hash table size @{  */
end_comment

begin_define
define|#
directive|define
name|SN_MIN_HASH_SIZE
value|101
end_define

begin_comment
comment|/**< Minimum hash table size (set to stop users choosing stupid values) */
end_comment

begin_define
define|#
directive|define
name|SN_MAX_HASH_SIZE
value|1000001
end_define

begin_comment
comment|/**< Maximum hash table size (NB must be less than max int) */
end_comment

begin_define
define|#
directive|define
name|SN_DEFAULT_HASH_SIZE
value|2003
end_define

begin_comment
comment|/**< A reasonable default size for the hash tables */
end_comment

begin_define
define|#
directive|define
name|SN_LOCAL_TBL
value|0x01
end_define

begin_comment
comment|/**< assoc in local table */
end_comment

begin_define
define|#
directive|define
name|SN_GLOBAL_TBL
value|0x02
end_define

begin_comment
comment|/**< assoc in global table */
end_comment

begin_define
define|#
directive|define
name|SN_BOTH_TBL
value|0x03
end_define

begin_comment
comment|/**< assoc in both tables */
end_comment

begin_define
define|#
directive|define
name|SN_WAIT_TOLOCAL
value|0x10
end_define

begin_comment
comment|/**< assoc waiting for TOLOCAL asconf ACK*/
end_comment

begin_define
define|#
directive|define
name|SN_WAIT_TOGLOBAL
value|0x20
end_define

begin_comment
comment|/**< assoc waiting for TOLOCAL asconf ACK*/
end_comment

begin_define
define|#
directive|define
name|SN_NULL_TBL
value|0x00
end_define

begin_comment
comment|/**< assoc in No table */
end_comment

begin_define
define|#
directive|define
name|SN_MAX_GLOBAL_ADDRESSES
value|100
end_define

begin_comment
comment|/**< absolute maximum global address count*/
end_comment

begin_define
define|#
directive|define
name|SN_ADD_OK
value|0
end_define

begin_comment
comment|/**< Association added to the table */
end_comment

begin_define
define|#
directive|define
name|SN_ADD_CLASH
value|1
end_define

begin_comment
comment|/**< Clash when trying to add the assoc. info to the table */
end_comment

begin_define
define|#
directive|define
name|SN_TABLE_HASH
parameter_list|(
name|vtag
parameter_list|,
name|port
parameter_list|,
name|size
parameter_list|)
value|(((u_int) vtag + (u_int) port) % (u_int) size)
end_define

begin_comment
comment|/**< Calculate the hash table lookup position */
end_comment

begin_comment
comment|/** @}  * @defgroup Timer Timer Queue Macros and Functions  *  * Timer macros set minimum/maximum timeout values and calculate timer expiry  * times for the provided libalias instance @{  */
end_comment

begin_define
define|#
directive|define
name|SN_MIN_TIMER
value|1
end_define

begin_define
define|#
directive|define
name|SN_MAX_TIMER
value|600
end_define

begin_define
define|#
directive|define
name|SN_TIMER_QUEUE_SIZE
value|SN_MAX_TIMER+2
end_define

begin_define
define|#
directive|define
name|SN_I_T
parameter_list|(
name|la
parameter_list|)
value|(la->timeStamp + sysctl_init_timer)
end_define

begin_comment
comment|/**< INIT State expiration time in seconds */
end_comment

begin_define
define|#
directive|define
name|SN_U_T
parameter_list|(
name|la
parameter_list|)
value|(la->timeStamp + sysctl_up_timer)
end_define

begin_comment
comment|/**< UP State expiration time in seconds */
end_comment

begin_define
define|#
directive|define
name|SN_C_T
parameter_list|(
name|la
parameter_list|)
value|(la->timeStamp + sysctl_shutdown_timer)
end_define

begin_comment
comment|/**< CL State expiration time in seconds */
end_comment

begin_define
define|#
directive|define
name|SN_X_T
parameter_list|(
name|la
parameter_list|)
value|(la->timeStamp + sysctl_holddown_timer)
end_define

begin_comment
comment|/**< Wait after a shutdown complete in seconds */
end_comment

begin_comment
comment|/** @}  * @defgroup sysctl SysCtl Variable and callback function declarations  *  * Sysctl variables to modify NAT functionality in real-time along with associated functions  * to manage modifications to the sysctl variables @{  */
end_comment

begin_comment
comment|/* Callbacks */
end_comment

begin_function_decl
name|int
name|sysctl_chg_loglevel
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_timer
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_hashtable_size
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_error_on_ootb
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_accept_global_ootb_addip
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_initialising_chunk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_chunk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_param_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sysctl_chg_track_global_addresses
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctl variables */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.log_level */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_log_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Stores the current level of logging */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.init_timer */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_init_timer
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Seconds to hold an association in the table waiting for an INIT-ACK or AddIP-ACK */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.up_timer */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_up_timer
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Seconds to hold an association in the table while no packets are transmitted */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.shutdown_timer */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_shutdown_timer
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Seconds to hold an association in the table waiting for a SHUTDOWN-COMPLETE */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.holddown_timer */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_holddown_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Seconds to hold an association in the table after it has been shutdown (to allow for lost SHUTDOWN-COMPLETEs) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.hashtable_size */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_hashtable_size
init|=
name|SN_DEFAULT_HASH_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Sets the hash table size for any NEW NAT instances (existing instances retain their existing Hash Table */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.error_on_ootb */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_error_on_ootb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< NAT response  to receipt of OOTB packet 					  (0 - No response, 1 - NAT will send ErrorM only to local side, 					  2 -  NAT will send local ErrorM and global ErrorM if there was a partial association match 					  3 - NAT will send ErrorM to both local and global) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.accept_global_ootb_addip */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_accept_global_ootb_addip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**<NAT responset to receipt of global OOTB AddIP (0 - No response, 1 - NAT will accept OOTB global AddIP messages for processing (Security risk)) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.initialising_chunk_proc_limit */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_initialising_chunk_proc_limit
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< A limit on the number of chunks that should be searched if there is no matching association (DoS prevention) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.param_proc_limit */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_chunk_proc_limit
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< A limit on the number of chunks that should be searched (DoS prevention) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.param_proc_limit */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_param_proc_limit
init|=
literal|25
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< A limit on the number of parameters (in chunks) that should be searched (DoS prevention) */
end_comment

begin_comment
comment|/** @brief net.inet.ip.alias.sctp.track_global_addresses */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sysctl_track_global_addresses
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Configures the global address tracking option within the NAT (0 - Global tracking is disabled,> 0 - enables tracking but limits the number of global IP addresses to this value) 						   If set to>=1 the NAT will track that many global IP addresses. This may reduce look up table conflicts, but increases processing */
end_comment

begin_define
define|#
directive|define
name|SN_NO_ERROR_ON_OOTB
value|0
end_define

begin_comment
comment|/**< Send no errorM on out of the blue packets */
end_comment

begin_define
define|#
directive|define
name|SN_LOCAL_ERROR_ON_OOTB
value|1
end_define

begin_comment
comment|/**< Send only local errorM on out of the blue packets */
end_comment

begin_define
define|#
directive|define
name|SN_LOCALandPARTIAL_ERROR_ON_OOTB
value|2
end_define

begin_comment
comment|/**< Send local errorM and global errorM for out of the blue packets only if partial match found */
end_comment

begin_define
define|#
directive|define
name|SN_ERROR_ON_OOTB
value|3
end_define

begin_comment
comment|/**< Send errorM on out of the blue packets */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_NODE
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip_alias
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip_alias
argument_list|,
name|OID_AUTO
argument_list|,
name|sctp
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"SCTP NAT"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|log_level
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_log_level
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_loglevel
argument_list|,
literal|"IU"
argument_list|,
literal|"Level of detail (0 - default, 1 - event, 2 - info, 3 - detail, 4 - debug, 5 - max debug)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|init_timer
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_init_timer
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_timer
argument_list|,
literal|"IU"
argument_list|,
literal|"Timeout value (s) while waiting for (INIT-ACK|AddIP-ACK)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|up_timer
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_up_timer
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_timer
argument_list|,
literal|"IU"
argument_list|,
literal|"Timeout value (s) to keep an association up with no traffic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|shutdown_timer
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_shutdown_timer
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_timer
argument_list|,
literal|"IU"
argument_list|,
literal|"Timeout value (s) while waiting for SHUTDOWN-COMPLETE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|holddown_timer
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_holddown_timer
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_timer
argument_list|,
literal|"IU"
argument_list|,
literal|"Hold association in table for this many seconds after receiving a SHUTDOWN-COMPLETE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|hashtable_size
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_hashtable_size
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_hashtable_size
argument_list|,
literal|"IU"
argument_list|,
literal|"Size of hash tables used for NAT lookups (100< prime_number> 1000001)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|error_on_ootb
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_error_on_ootb
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_error_on_ootb
argument_list|,
literal|"IU"
argument_list|,
literal|"ErrorM sent on receipt of ootb packet:\n\t0 - none,\n\t1 - to local only,\n\t2 - to local and global if a partial association match,\n\t3 - to local and global (DoS risk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|accept_global_ootb_addip
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_accept_global_ootb_addip
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_accept_global_ootb_addip
argument_list|,
literal|"IU"
argument_list|,
literal|"NAT response to receipt of global OOTB AddIP:\n\t0 - No response,\n\t1 - NAT will accept OOTB global AddIP messages for processing (Security risk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|initialising_chunk_proc_limit
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_initialising_chunk_proc_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_initialising_chunk_proc_limit
argument_list|,
literal|"IU"
argument_list|,
literal|"Number of chunks that should be processed if there is no current association found:\n\t> 0 (A high value is a DoS risk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|chunk_proc_limit
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_chunk_proc_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_chunk_proc_limit
argument_list|,
literal|"IU"
argument_list|,
literal|"Number of chunks that should be processed to find key chunk:\n\t>= initialising_chunk_proc_limit (A high value is a DoS risk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|param_proc_limit
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_param_proc_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_param_proc_limit
argument_list|,
literal|"IU"
argument_list|,
literal|"Number of parameters (in a chunk) that should be processed to find key parameters:\n\t> 1 (A high value is a DoS risk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_alias_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|track_global_addresses
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sysctl_track_global_addresses
argument_list|,
literal|0
argument_list|,
name|sysctl_chg_track_global_addresses
argument_list|,
literal|"IU"
argument_list|,
literal|"Configures the global address tracking option within the NAT:\n\t0 - Global tracking is disabled,\n\t> 0 - enables tracking but limits the number of global IP addresses to this value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSCTL_NODE */
end_comment

begin_comment
comment|/** @}  * @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.fw.sctp.log_level  *  * Updates the variable sysctl_log_level to the provided value and ensures  * it is in the valid range (SN_LOG_LOW -> SN_LOG_DEBUG)  */
end_comment

begin_function
name|int
name|sysctl_chg_loglevel
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|level
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|level
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_log_level
operator|=
operator|(
name|level
operator|>
name|SN_LOG_DEBUG_MAX
operator|)
condition|?
operator|(
name|SN_LOG_DEBUG_MAX
operator|)
else|:
operator|(
name|level
operator|)
expr_stmt|;
name|sysctl_log_level
operator|=
operator|(
name|level
operator|<
name|SN_LOG_LOW
operator|)
condition|?
operator|(
name|SN_LOG_LOW
operator|)
else|:
operator|(
name|level
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.fw.sctp.(init_timer|up_timer|shutdown_timer)  *  * Updates the timer-based sysctl variables. The new values are sanity-checked  * to make sure that they are within the range SN_MIN_TIMER-SN_MAX_TIMER. The  * holddown timer is allowed to be 0  */
end_comment

begin_function
name|int
name|sysctl_chg_timer
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|timer
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|timer
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|timer
operator|=
operator|(
name|timer
operator|>
name|SN_MAX_TIMER
operator|)
condition|?
operator|(
name|SN_MAX_TIMER
operator|)
else|:
operator|(
name|timer
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_int
operator|*
operator|)
name|arg1
operator|)
operator|!=
operator|&
name|sysctl_holddown_timer
condition|)
block|{
name|timer
operator|=
operator|(
name|timer
operator|<
name|SN_MIN_TIMER
operator|)
condition|?
operator|(
name|SN_MIN_TIMER
operator|)
else|:
operator|(
name|timer
operator|)
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
operator|=
name|timer
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.hashtable_size  *  * Updates the hashtable_size sysctl variable. The new value should be a prime  * number.  We sanity check to ensure that the size is within the range  * SN_MIN_HASH_SIZE-SN_MAX_HASH_SIZE. We then check the provided number to see  * if it is prime. We approximate by checking that (2,3,5,7,11) are not factors,  * incrementing the user provided value until we find a suitable number.  */
end_comment

begin_function
name|int
name|sysctl_chg_hashtable_size
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|size
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|size
operator|=
operator|(
name|size
operator|<
name|SN_MIN_HASH_SIZE
operator|)
condition|?
operator|(
name|SN_MIN_HASH_SIZE
operator|)
else|:
operator|(
operator|(
name|size
operator|>
name|SN_MAX_HASH_SIZE
operator|)
condition|?
operator|(
name|SN_MAX_HASH_SIZE
operator|)
else|:
operator|(
name|size
operator|)
operator|)
expr_stmt|;
name|size
operator||=
literal|0x00000001
expr_stmt|;
comment|/* make odd */
for|for
control|(
init|;
operator|(
operator|(
operator|(
name|size
operator|%
literal|3
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|size
operator|%
literal|5
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|size
operator|%
literal|7
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|size
operator|%
literal|11
operator|)
operator|==
literal|0
operator|)
operator|)
condition|;
name|size
operator|+=
literal|2
control|)
empty_stmt|;
name|sysctl_hashtable_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.error_on_ootb  *  * Updates the error_on_clash sysctl variable.   * If set to 0, no ErrorM will be sent if there is a look up table clash  * If set to 1, an ErrorM is sent only to the local side  * If set to 2, an ErrorM is sent to the local side and global side if there is  *                                                  a partial association match  * If set to 3, an ErrorM is sent to both local and global sides (DoS) risk.  */
end_comment

begin_function
name|int
name|sysctl_chg_error_on_ootb
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|flag
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|flag
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_error_on_ootb
operator|=
operator|(
name|flag
operator|>
name|SN_ERROR_ON_OOTB
operator|)
condition|?
name|SN_ERROR_ON_OOTB
else|:
name|flag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.accept_global_ootb_addip  *  * If set to 1 the NAT will accept ootb global addip messages for processing (Security risk)  * Default is 0, only responding to local ootb AddIP messages  */
end_comment

begin_function
name|int
name|sysctl_chg_accept_global_ootb_addip
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|flag
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|flag
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_accept_global_ootb_addip
operator|=
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.initialising_chunk_proc_limit  *  * Updates the initialising_chunk_proc_limit sysctl variable.  Number of chunks  * that should be processed if there is no current association found:> 0 (A  * high value is a DoS risk)  */
end_comment

begin_function
name|int
name|sysctl_chg_initialising_chunk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|proclimit
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|proclimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_initialising_chunk_proc_limit
operator|=
operator|(
name|proclimit
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|proclimit
expr_stmt|;
name|sysctl_chunk_proc_limit
operator|=
operator|(
name|sysctl_chunk_proc_limit
operator|<
name|sysctl_initialising_chunk_proc_limit
operator|)
condition|?
name|sysctl_initialising_chunk_proc_limit
else|:
name|sysctl_chunk_proc_limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.chunk_proc_limit  *  * Updates the chunk_proc_limit sysctl variable.   * Number of chunks that should be processed to find key chunk:  *>= initialising_chunk_proc_limit (A high value is a DoS risk)  */
end_comment

begin_function
name|int
name|sysctl_chg_chunk_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|proclimit
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|proclimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_chunk_proc_limit
operator|=
operator|(
name|proclimit
operator|<
name|sysctl_initialising_chunk_proc_limit
operator|)
condition|?
name|sysctl_initialising_chunk_proc_limit
else|:
name|proclimit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.param_proc_limit  *  * Updates the param_proc_limit sysctl variable.   * Number of parameters that should be processed to find key parameters:  *> 1 (A high value is a DoS risk)  */
end_comment

begin_function
name|int
name|sysctl_chg_param_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|proclimit
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|proclimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_param_proc_limit
operator|=
operator|(
name|proclimit
operator|<
literal|2
operator|)
condition|?
literal|2
else|:
name|proclimit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup sysctl  * @brief sysctl callback for changing net.inet.ip.alias.sctp.track_global_addresses  *  *Configures the global address tracking option within the NAT (0 - Global  *tracking is disabled,> 0 - enables tracking but limits the number of global  *IP addresses to this value)  */
end_comment

begin_function
name|int
name|sysctl_chg_track_global_addresses
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|num_to_track
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|num_to_track
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sysctl_track_global_addresses
operator|=
operator|(
name|num_to_track
operator|>
name|SN_MAX_GLOBAL_ADDRESSES
operator|)
condition|?
name|SN_MAX_GLOBAL_ADDRESSES
else|:
name|num_to_track
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                            CODE BEGINS HERE  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/**   * @brief Initialises the SCTP NAT Implementation  *   * Creates the look-up tables and the timer queue and initialises all state  * variables  *  * @param la Pointer to the relevant libalias instance  */
end_comment

begin_function
name|void
name|AliasSctpInit
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
comment|/* Initialise association tables*/
name|int
name|i
decl_stmt|;
name|la
operator|->
name|sctpNatTableSize
operator|=
name|sysctl_hashtable_size
expr_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|SctpAliasLog
argument_list|(
literal|"Initialising SCTP NAT Instance (hash_table_size:%d)\n"
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|->
name|sctpTableLocal
operator|=
name|sn_calloc
argument_list|(
name|la
operator|->
name|sctpNatTableSize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctpNatTableL
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|->
name|sctpTableGlobal
operator|=
name|sn_calloc
argument_list|(
name|la
operator|->
name|sctpNatTableSize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctpNatTableG
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
operator|=
name|sn_calloc
argument_list|(
name|SN_TIMER_QUEUE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctpTimerQ
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialise hash table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|la
operator|->
name|sctpNatTableSize
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|la
operator|->
name|sctpTableLocal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|la
operator|->
name|sctpTableGlobal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise circular timer Q*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SN_TIMER_QUEUE_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|la
operator|->
name|sctpNatTimer
operator|.
name|loc_time
operator|=
name|time_uptime
expr_stmt|;
comment|/* la->timeStamp is not set yet */
else|#
directive|else
name|la
operator|->
name|sctpNatTimer
operator|.
name|loc_time
operator|=
name|la
operator|->
name|timeStamp
expr_stmt|;
endif|#
directive|endif
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|sctpLinkCount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * @brief Cleans-up the SCTP NAT Implementation prior to unloading  *  * Removes all entries from the timer queue, freeing associations as it goes.  * We then free memory allocated to the look-up tables and the time queue  *  * NOTE: We do not need to traverse the look-up tables as each association  *       will always have an entry in the timer queue, freeing this memory  *       once will free all memory allocated to entries in the look-up tables  *  * @param la Pointer to the relevant libalias instance  */
end_comment

begin_function
name|void
name|AliasSctpTerm
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc1
decl_stmt|,
modifier|*
name|assoc2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|SctpAliasLog
argument_list|(
literal|"Removing SCTP NAT Instance\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SN_TIMER_QUEUE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|assoc1
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|assoc1
operator|!=
name|NULL
condition|)
block|{
name|freeGlobalAddressList
argument_list|(
name|assoc1
argument_list|)
expr_stmt|;
name|assoc2
operator|=
name|LIST_NEXT
argument_list|(
name|assoc1
argument_list|,
name|timer_Q
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|assoc1
argument_list|)
expr_stmt|;
name|assoc1
operator|=
name|assoc2
expr_stmt|;
block|}
block|}
name|sn_free
argument_list|(
name|la
operator|->
name|sctpTableLocal
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|la
operator|->
name|sctpTableGlobal
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief Handles SCTP packets passed from libalias  *  * This function needs to actually NAT/drop packets and possibly create and  * send AbortM or ErrorM packets in response. The process involves:  * - Validating the direction parameter passed by the caller  * - Checking and handling any expired timers for the NAT  * - Calling sctp_PktParser() to parse the packet  * - Call ProcessSctpMsg() to decide the appropriate outcome and to update  *   the NAT tables  * - Based on the return code either:  *   - NAT the packet  *   - Construct and send an ErrorM|AbortM packet  *   - Mark the association for removal from the tables  * - Potentially remove the association from all lookup tables  * - Return the appropriate result to libalias  *  * @param la Pointer to the relevant libalias instance  * @param pip Pointer to IP packet to process  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL  *   * @return  PKT_ALIAS_OK | PKT_ALIAS_IGNORE | PKT_ALIAS_ERROR  */
end_comment

begin_function
name|int
name|SctpAlias
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|rtnval
decl_stmt|;
name|struct
name|sctp_nat_msg
name|msg
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|direction
operator|!=
name|SN_TO_LOCAL
operator|)
operator|&&
operator|(
name|direction
operator|!=
name|SN_TO_GLOBAL
operator|)
condition|)
block|{
name|SctpAliasLog
argument_list|(
literal|"ERROR: Invalid direction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_ERROR
operator|)
return|;
block|}
name|sctp_CheckTimers
argument_list|(
name|la
argument_list|)
expr_stmt|;
comment|/* Check timers */
comment|/* Parse the packet */
name|rtnval
operator|=
name|sctp_PktParser
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|pip
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|assoc
argument_list|)
expr_stmt|;
comment|//using *char (change to mbuf when get code from paolo)
switch|switch
condition|(
name|rtnval
condition|)
block|{
case|case
name|SN_PARSE_OK
case|:
break|break;
case|case
name|SN_PARSE_ERROR_CHHL
case|:
comment|/* Not an error if there is a chunk length parsing error and this is a fragmented packet */
if|if
condition|(
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_MF
condition|)
block|{
name|rtnval
operator|=
name|SN_PARSE_OK
expr_stmt|;
break|break;
block|}
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"SN_PARSE_ERROR"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_ERROR
operator|)
return|;
case|case
name|SN_PARSE_ERROR_PARTIALLOOKUP
case|:
if|if
condition|(
name|sysctl_error_on_ootb
operator|>
name|SN_LOCALandPARTIAL_ERROR_ON_OOTB
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"SN_PARSE_ERROR"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_ERROR
operator|)
return|;
block|}
case|case
name|SN_PARSE_ERROR_LOOKUP
case|:
if|if
condition|(
name|sysctl_error_on_ootb
operator|==
name|SN_ERROR_ON_OOTB
operator|||
operator|(
name|sysctl_error_on_ootb
operator|==
name|SN_LOCALandPARTIAL_ERROR_ON_OOTB
operator|&&
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
operator|||
operator|(
name|sysctl_error_on_ootb
operator|==
name|SN_LOCAL_ERROR_ON_OOTB
operator|&&
name|direction
operator|==
name|SN_TO_GLOBAL
operator|)
condition|)
block|{
name|TxAbortErrorM
argument_list|(
name|la
argument_list|,
operator|&
name|msg
argument_list|,
name|assoc
argument_list|,
name|SN_REFLECT_ERROR
argument_list|,
name|direction
argument_list|)
expr_stmt|;
comment|/*NB assoc=NULL */
return|return
operator|(
name|PKT_ALIAS_RESPOND
operator|)
return|;
block|}
default|default:
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"SN_PARSE_ERROR"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PKT_ALIAS_ERROR
operator|)
return|;
block|}
name|SN_LOG
argument_list|(
argument|SN_LOG_DETAIL
argument_list|,
argument|logsctpassoc(assoc,
literal|"*"
argument|); 	    logsctpparse(direction,&msg);
argument_list|)
empty_stmt|;
comment|/* Process the SCTP message */
name|rtnval
operator|=
name|ProcessSctpMsg
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
operator|&
name|msg
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
name|SN_LOG
argument_list|(
argument|SN_LOG_DEBUG_MAX
argument_list|,
argument|logsctpassoc(assoc,
literal|"-"
argument|); 	    logSctpLocal(la); 	    logSctpGlobal(la);
argument_list|)
empty_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_DEBUG
argument_list|,
name|logTimerQ
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rtnval
condition|)
block|{
case|case
name|SN_NAT_PKT
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_LOCAL
case|:
name|DifferentialChecksum
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_sum
operator|)
argument_list|,
operator|&
operator|(
name|assoc
operator|->
name|l_addr
operator|)
argument_list|,
operator|&
operator|(
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_dst
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_dst
operator|=
name|assoc
operator|->
name|l_addr
expr_stmt|;
comment|/* change dst address to local address*/
break|break;
case|case
name|SN_TO_GLOBAL
case|:
name|DifferentialChecksum
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_sum
operator|)
argument_list|,
operator|&
operator|(
name|assoc
operator|->
name|a_addr
operator|)
argument_list|,
operator|&
operator|(
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_src
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msg
operator|.
name|ip_hdr
operator|->
name|ip_src
operator|=
name|assoc
operator|->
name|a_addr
expr_stmt|;
comment|/* change src to alias addr*/
break|break;
default|default:
name|rtnval
operator|=
name|SN_DROP_PKT
expr_stmt|;
comment|/* shouldn't get here, but if it does drop packet */
name|SN_LOG
argument_list|(
name|SN_LOG_LOW
argument_list|,
name|logsctperror
argument_list|(
literal|"ERROR: Invalid direction"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SN_DROP_PKT
case|:
name|SN_LOG
argument_list|(
name|SN_LOG_DETAIL
argument_list|,
name|logsctperror
argument_list|(
literal|"SN_DROP_PKT"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SN_REPLY_ABORT
case|:
case|case
name|SN_REPLY_ERROR
case|:
case|case
name|SN_SEND_ABORT
case|:
name|TxAbortErrorM
argument_list|(
name|la
argument_list|,
operator|&
name|msg
argument_list|,
name|assoc
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// big error, remove association and go to idle and write log messages
name|SN_LOG
argument_list|(
name|SN_LOG_LOW
argument_list|,
name|logsctperror
argument_list|(
literal|"SN_PROCESSING_ERROR"
argument_list|,
name|msg
operator|.
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|rtnval
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
break|break;
block|}
comment|/* Remove association if tagged for removal */
if|if
condition|(
name|assoc
operator|->
name|state
operator|==
name|SN_RM
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|TableRegister
condition|)
block|{
name|sctp_RmTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
name|RmSctpAssoc
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
block|}
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|freeGlobalAddressList
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rtnval
condition|)
block|{
case|case
name|SN_NAT_PKT
case|:
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
case|case
name|SN_SEND_ABORT
case|:
return|return
operator|(
name|PKT_ALIAS_OK
operator|)
return|;
case|case
name|SN_REPLY_ABORT
case|:
case|case
name|SN_REPLY_ERROR
case|:
case|case
name|SN_REFLECT_ERROR
case|:
return|return
operator|(
name|PKT_ALIAS_RESPOND
operator|)
return|;
case|case
name|SN_DROP_PKT
case|:
default|default:
return|return
operator|(
name|PKT_ALIAS_ERROR
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**   * @brief Send an AbortM or ErrorM  *  * We construct the new SCTP packet to send in place of the existing packet we  * have been asked to NAT. This function can only be called if the original  * packet was successfully parsed as a valid SCTP packet.  *  * An AbortM (without cause) packet is the smallest SCTP packet available and as  * such there is always space in the existing packet buffer to fit the AbortM  * packet. An ErrorM packet is 4 bytes longer than the (the error cause is not  * optional). An ErrorM is sent in response to an AddIP when the Vtag/address  * combination, if added, will produce a conflict in the association look up  * tables. It may also be used for an unexpected packet - a packet with no  * matching association in the NAT table and we are requesting an AddIP so we  * can add it.  The smallest valid SCTP packet while the association is in an  * up-state is a Heartbeat packet, which is big enough to be transformed to an  * ErrorM.  *  * We create a temporary character array to store the packet as we are constructing  * it. We then populate the array with appropriate values based on:  * - Packet type (AbortM | ErrorM)  * - Initial packet direction (SN_TO_LOCAL | SN_TO_GLOBAL)  * - NAT response (Send packet | Reply packet)  *  * Once complete, we copy the contents of the temporary packet over the original  * SCTP packet we were asked to NAT  *  * @param la Pointer to the relevant libalias instance  * @param sm Pointer to sctp message information  * @param assoc Pointer to current association details  * @param sndrply SN_SEND_ABORT | SN_REPLY_ABORT | SN_REPLY_ERROR  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL  */
end_comment

begin_function
specifier|static
name|void
name|TxAbortErrorM
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|sndrply
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|sctp_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
decl_stmt|;
name|int
name|ip_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|sctp_size
decl_stmt|;
name|int
name|include_error_cause
init|=
literal|1
decl_stmt|;
name|char
name|tmp_ip
index|[
name|ip_size
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_len
argument_list|)
operator|<
name|ip_size
condition|)
block|{
comment|/* short packet, cannot send error cause */
name|include_error_cause
operator|=
literal|0
expr_stmt|;
name|ip_size
operator|=
name|ip_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
expr_stmt|;
name|sctp_size
operator|=
name|sctp_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
expr_stmt|;
block|}
comment|/* Assign header pointers packet */
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tmp_ip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sctp_hdr
init|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|chunk_hdr
init|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sctp_hdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sctp_hdr
argument_list|)
operator|)
decl_stmt|;
name|struct
name|sctp_error_cause
modifier|*
name|error_cause
init|=
operator|(
expr|struct
name|sctp_error_cause
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk_hdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|chunk_hdr
argument_list|)
operator|)
decl_stmt|;
comment|/* construct ip header */
name|ip
operator|->
name|ip_v
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_v
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
literal|5
expr_stmt|;
comment|/* 5*32 bit words */
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip_size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_id
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
literal|255
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
comment|/* 	  The definitions below should be removed when they make it into the SCTP stack 	*/
define|#
directive|define
name|SCTP_MIDDLEBOX_FLAG
value|0x02
define|#
directive|define
name|SCTP_NAT_TABLE_COLLISION
value|0x00b0
define|#
directive|define
name|SCTP_MISSING_NAT
value|0x00b1
name|chunk_hdr
operator|->
name|chunk_type
operator|=
operator|(
name|sndrply
operator|&
name|SN_TX_ABORT
operator|)
condition|?
name|SCTP_ABORT_ASSOCIATION
else|:
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|chunk_hdr
operator|->
name|chunk_flags
operator|=
name|SCTP_MIDDLEBOX_FLAG
expr_stmt|;
if|if
condition|(
name|include_error_cause
condition|)
block|{
name|error_cause
operator|->
name|code
operator|=
name|htons
argument_list|(
operator|(
name|sndrply
operator|&
name|SN_REFLECT_ERROR
operator|)
condition|?
name|SCTP_MISSING_NAT
else|:
name|SCTP_NAT_TABLE_COLLISION
argument_list|)
expr_stmt|;
name|error_cause
operator|->
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
argument_list|)
expr_stmt|;
name|chunk_hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|chunk_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk_hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|chunk_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set specific values */
switch|switch
condition|(
name|sndrply
condition|)
block|{
case|case
name|SN_REFLECT_ERROR
case|:
name|chunk_hdr
operator|->
name|chunk_flags
operator||=
name|SCTP_HAD_NO_TCB
expr_stmt|;
comment|/* set Tbit */
name|sctp_hdr
operator|->
name|v_tag
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
expr_stmt|;
break|break;
case|case
name|SN_REPLY_ERROR
case|:
name|sctp_hdr
operator|->
name|v_tag
operator|=
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
condition|?
name|assoc
operator|->
name|g_vtag
else|:
name|assoc
operator|->
name|l_vtag
expr_stmt|;
break|break;
case|case
name|SN_SEND_ABORT
case|:
name|sctp_hdr
operator|->
name|v_tag
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
expr_stmt|;
break|break;
case|case
name|SN_REPLY_ABORT
case|:
name|sctp_hdr
operator|->
name|v_tag
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|->
name|initiate_tag
expr_stmt|;
break|break;
block|}
comment|/* Set send/reply values */
if|if
condition|(
name|sndrply
operator|==
name|SN_SEND_ABORT
condition|)
block|{
comment|/*pass through NAT */
name|ip
operator|->
name|ip_src
operator|=
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
condition|?
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
else|:
name|assoc
operator|->
name|a_addr
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
condition|?
name|assoc
operator|->
name|l_addr
else|:
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
expr_stmt|;
name|sctp_hdr
operator|->
name|src_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|src_port
expr_stmt|;
name|sctp_hdr
operator|->
name|dest_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|dest_port
expr_stmt|;
block|}
else|else
block|{
comment|/* reply and reflect */
name|ip
operator|->
name|ip_src
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
expr_stmt|;
name|sctp_hdr
operator|->
name|src_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|dest_port
expr_stmt|;
name|sctp_hdr
operator|->
name|dest_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|src_port
expr_stmt|;
block|}
comment|/* Calculate IP header checksum */
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* calculate SCTP header CRC32 */
name|sctp_hdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|sctp_hdr
operator|->
name|checksum
operator|=
name|sctp_finalize_crc32
argument_list|(
name|update_crc32
argument_list|(
literal|0xffffffff
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sctp_hdr
argument_list|,
name|sctp_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|ip_hdr
argument_list|,
name|ip
argument_list|,
name|ip_size
argument_list|)
expr_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|SctpAliasLog
argument_list|(
literal|"%s %s 0x%x (->%s:%u vtag=0x%x crc=0x%x)\n"
argument_list|,
operator|(
operator|(
name|sndrply
operator|==
name|SN_SEND_ABORT
operator|)
condition|?
literal|"Sending"
else|:
literal|"Replying"
operator|)
argument_list|,
operator|(
operator|(
name|sndrply
operator|&
name|SN_TX_ERROR
operator|)
condition|?
literal|"ErrorM"
else|:
literal|"AbortM"
operator|)
argument_list|,
operator|(
name|include_error_cause
condition|?
name|ntohs
argument_list|(
name|error_cause
operator|->
name|code
argument_list|)
else|:
literal|0
operator|)
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sctp_hdr
operator|->
name|dest_port
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|sctp_hdr
operator|->
name|v_tag
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|sctp_hdr
operator|->
name|checksum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                           PACKET PARSER CODE  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/** @addtogroup packet_parser  *  * These functions parse the SCTP packet and fill a sctp_nat_msg structure  * with the parsed contents.  */
end_comment

begin_comment
comment|/** @ingroup packet_parser  * @brief Parses SCTP packets for the key SCTP chunk that will be processed  *   * This module parses SCTP packets for the key SCTP chunk that will be processed  * The module completes the sctp_nat_msg structure and either retrieves the  * relevant (existing) stored association from the Hash Tables or creates a new  * association entity with state SN_ID  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param pip   * @param sm Pointer to sctp message information  * @param passoc Pointer to the association this SCTP Message belongs to  *   * @return SN_PARSE_OK | SN_PARSE_ERROR_*  */
end_comment

begin_function
specifier|static
name|int
name|sctp_PktParser
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
modifier|*
name|passoc
parameter_list|)
comment|//sctp_PktParser(int direction, struct mbuf *ipak, int ip_hdr_len,struct sctp_nat_msg *sm, struct sctp_nat_assoc *assoc)
block|{
name|struct
name|sctphdr
modifier|*
name|sctp_hdr
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|chunk_hdr
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|param_hdr
decl_stmt|;
name|struct
name|in_addr
name|ipv4addr
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
comment|/* bytes left in ip packet */
name|int
name|chunk_length
decl_stmt|;
name|int
name|chunk_count
decl_stmt|;
name|int
name|partial_match
init|=
literal|0
decl_stmt|;
comment|//  mbuf *mp;
comment|//  int mlen;
comment|//  mlen = SCTP_HEADER_LEN(i_pak);
comment|//  mp = SCTP_HEADER_TO_CHAIN(i_pak); /* does nothing in bsd since header and chain not separate */
comment|/* 	 * Note, that if the VTag is zero, it must be an INIT 	 * Also, I am only interested in the content of INIT and ADDIP chunks 	 */
comment|// no mbuf stuff from Paolo yet so ...
name|sm
operator|->
name|ip_hdr
operator|=
name|pip
expr_stmt|;
comment|/* remove ip header length from the bytes_left */
name|bytes_left
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
operator|-
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Check SCTP header length and move to first chunk */
if|if
condition|(
name|bytes_left
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
condition|)
block|{
name|sm
operator|->
name|sctp_hdr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SN_PARSE_ERROR_IPSHL
operator|)
return|;
comment|/* packet not long enough*/
block|}
name|sm
operator|->
name|sctp_hdr
operator|=
name|sctp_hdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
name|ip_next
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|bytes_left
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
comment|/* Check for valid ports (zero valued ports would find partially initialised associations */
if|if
condition|(
name|sctp_hdr
operator|->
name|src_port
operator|==
literal|0
operator|||
name|sctp_hdr
operator|->
name|dest_port
operator|==
literal|0
condition|)
return|return
operator|(
name|SN_PARSE_ERROR_PORT
operator|)
return|;
comment|/* Check length of first chunk */
if|if
condition|(
name|bytes_left
operator|<
name|SN_MIN_CHUNK_SIZE
condition|)
comment|/* malformed chunk - could cause endless loop*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
comment|/* packet not long enough for this chunk */
comment|/* First chunk */
name|chunk_hdr
operator|=
name|SN_SCTP_FIRSTCHUNK
argument_list|(
name|sctp_hdr
argument_list|)
expr_stmt|;
name|chunk_length
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|chunk_hdr
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_length
operator|<
name|SN_MIN_CHUNK_SIZE
operator|)
operator|||
operator|(
name|chunk_length
operator|>
name|bytes_left
operator|)
condition|)
comment|/* malformed chunk - could cause endless loop*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
if|if
condition|(
operator|(
name|chunk_hdr
operator|->
name|chunk_flags
operator|&
name|SCTP_HAD_NO_TCB
operator|)
operator|&&
operator|(
operator|(
name|chunk_hdr
operator|->
name|chunk_type
operator|==
name|SCTP_ABORT_ASSOCIATION
operator|)
operator|||
operator|(
name|chunk_hdr
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
operator|)
operator|)
condition|)
block|{
comment|/* T-Bit set */
if|if
condition|(
name|direction
operator|==
name|SN_TO_LOCAL
condition|)
operator|*
name|passoc
operator|=
name|FindSctpGlobalT
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sctp_hdr
operator|->
name|dest_port
argument_list|,
name|sctp_hdr
operator|->
name|src_port
argument_list|)
expr_stmt|;
else|else
operator|*
name|passoc
operator|=
name|FindSctpLocalT
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sctp_hdr
operator|->
name|dest_port
argument_list|,
name|sctp_hdr
operator|->
name|src_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Proper v_tag settings */
if|if
condition|(
name|direction
operator|==
name|SN_TO_LOCAL
condition|)
operator|*
name|passoc
operator|=
name|FindSctpGlobal
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sctp_hdr
operator|->
name|src_port
argument_list|,
name|sctp_hdr
operator|->
name|dest_port
argument_list|,
operator|&
name|partial_match
argument_list|)
expr_stmt|;
else|else
operator|*
name|passoc
operator|=
name|FindSctpLocal
argument_list|(
name|la
argument_list|,
name|pip
operator|->
name|ip_src
argument_list|,
name|pip
operator|->
name|ip_dst
argument_list|,
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sctp_hdr
operator|->
name|src_port
argument_list|,
name|sctp_hdr
operator|->
name|dest_port
argument_list|)
expr_stmt|;
block|}
name|chunk_count
operator|=
literal|1
expr_stmt|;
comment|/* Real packet parsing occurs below */
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_OTHER
expr_stmt|;
comment|/* Initialise to largest value*/
name|sm
operator|->
name|chunk_length
operator|=
literal|0
expr_stmt|;
comment|/* only care about length for key chunks */
while|while
condition|(
name|IS_SCTP_CONTROL
argument_list|(
name|chunk_hdr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|chunk_hdr
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
if|if
condition|(
name|chunk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_INIT
expr_stmt|;
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|=
operator|(
expr|struct
name|sctp_init
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
expr_stmt|;
comment|/* if no existing association, create a new one */
if|if
condition|(
operator|*
name|passoc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sctp_hdr
operator|->
name|v_tag
operator|==
literal|0
condition|)
block|{
comment|//Init requires vtag=0
operator|*
name|passoc
operator|=
operator|(
expr|struct
name|sctp_nat_assoc
operator|*
operator|)
name|sn_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nat_assoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|passoc
operator|==
name|NULL
condition|)
block|{
comment|/* out of resources */
return|return
operator|(
name|SN_PARSE_ERROR_AS_MALLOC
operator|)
return|;
block|}
comment|/* Initialise association - malloc initialises memory to zeros */
operator|(
operator|*
name|passoc
operator|)
operator|->
name|state
operator|=
name|SN_ID
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|passoc
operator|)
operator|->
name|Gaddr
operator|)
argument_list|)
expr_stmt|;
comment|/* always initialise to avoid memory problems */
operator|(
operator|*
name|passoc
operator|)
operator|->
name|TableRegister
operator|=
name|SN_NULL_TBL
expr_stmt|;
return|return
operator|(
name|SN_PARSE_OK
operator|)
return|;
block|}
return|return
operator|(
name|SN_PARSE_ERROR_VTAG
operator|)
return|;
block|}
return|return
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
return|;
case|case
name|SCTP_INITIATION_ACK
case|:
if|if
condition|(
name|chunk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_INITACK
expr_stmt|;
name|sm
operator|->
name|sctpchnk
operator|.
name|InitAck
operator|=
operator|(
expr|struct
name|sctp_init_ack
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
condition|?
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
else|:
operator|(
name|SN_PARSE_OK
operator|)
operator|)
return|;
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
comment|/* access only minimum sized chunk */
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_ABORT
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
condition|?
operator|(
name|SN_PARSE_ERROR_LOOKUP_ABORT
operator|)
else|:
operator|(
name|SN_PARSE_OK
operator|)
operator|)
return|;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
if|if
condition|(
name|chunk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_ack_chunk
argument_list|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
if|if
condition|(
name|sm
operator|->
name|msg
operator|>
name|SN_SCTP_SHUTACK
condition|)
block|{
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_SHUTACK
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
comment|/* minimum sized chunk */
if|if
condition|(
name|sm
operator|->
name|msg
operator|>
name|SN_SCTP_SHUTCOMP
condition|)
block|{
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_SHUTCOMP
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
condition|?
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
else|:
operator|(
name|SN_PARSE_OK
operator|)
operator|)
return|;
case|case
name|SCTP_ASCONF
case|:
if|if
condition|(
name|sm
operator|->
name|msg
operator|>
name|SN_SCTP_ASCONF
condition|)
block|{
if|if
condition|(
name|chunk_length
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
comment|//leave parameter searching to later, if required
name|param_hdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
operator|)
expr_stmt|;
comment|/*compulsory IP parameter*/
if|if
condition|(
name|ntohs
argument_list|(
name|param_hdr
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
condition|)
block|{
comment|/* AddIP with no association */
comment|/* try look up with the ASCONF packet's alternative address */
name|ipv4addr
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|param_hdr
operator|)
operator|->
name|addr
expr_stmt|;
operator|*
name|passoc
operator|=
name|FindSctpGlobal
argument_list|(
name|la
argument_list|,
name|ipv4addr
argument_list|,
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sctp_hdr
operator|->
name|src_port
argument_list|,
name|sctp_hdr
operator|->
name|dest_port
argument_list|,
operator|&
name|partial_match
argument_list|)
expr_stmt|;
block|}
name|param_hdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|param_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
expr_stmt|;
comment|/*asconf's compulsory address parameter */
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
comment|/* rest of chunk */
block|}
else|else
block|{
if|if
condition|(
name|chunk_length
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
name|param_hdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|param_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
expr_stmt|;
comment|/*asconf's compulsory address parameter */
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
comment|/* rest of chunk */
block|}
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_ASCONF
expr_stmt|;
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
operator|=
name|param_hdr
expr_stmt|;
if|if
condition|(
operator|*
name|passoc
operator|==
name|NULL
condition|)
block|{
comment|/* AddIP with no association */
operator|*
name|passoc
operator|=
operator|(
expr|struct
name|sctp_nat_assoc
operator|*
operator|)
name|sn_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nat_assoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|passoc
operator|==
name|NULL
condition|)
block|{
comment|/* out of resources */
return|return
operator|(
name|SN_PARSE_ERROR_AS_MALLOC
operator|)
return|;
block|}
comment|/* Initialise association  - malloc initialises memory to zeros */
operator|(
operator|*
name|passoc
operator|)
operator|->
name|state
operator|=
name|SN_ID
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|passoc
operator|)
operator|->
name|Gaddr
operator|)
argument_list|)
expr_stmt|;
comment|/* always initialise to avoid memory problems */
operator|(
operator|*
name|passoc
operator|)
operator|->
name|TableRegister
operator|=
name|SN_NULL_TBL
expr_stmt|;
return|return
operator|(
name|SN_PARSE_OK
operator|)
return|;
block|}
block|}
break|break;
case|case
name|SCTP_ASCONF_ACK
case|:
if|if
condition|(
name|sm
operator|->
name|msg
operator|>
name|SN_SCTP_ASCONFACK
condition|)
block|{
if|if
condition|(
name|chunk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
condition|)
comment|/* malformed chunk*/
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
comment|//leave parameter searching to later, if required
name|param_hdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk_hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
operator|)
expr_stmt|;
name|sm
operator|->
name|msg
operator|=
name|SN_SCTP_ASCONFACK
expr_stmt|;
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
operator|=
name|param_hdr
expr_stmt|;
name|sm
operator|->
name|chunk_length
operator|=
name|chunk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
comment|/* do nothing*/
block|}
comment|/* if no association is found exit - we need to find an Init or AddIP within sysctl_initialising_chunk_proc_limit */
if|if
condition|(
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|chunk_count
operator|>=
name|sysctl_initialising_chunk_proc_limit
operator|)
condition|)
return|return
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
return|;
comment|/* finished with this chunk, on to the next chunk*/
name|bytes_left
operator|-=
name|chunk_length
expr_stmt|;
comment|/* Is this the end of the packet ? */
if|if
condition|(
name|bytes_left
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
name|passoc
operator|==
name|NULL
operator|)
condition|?
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
else|:
operator|(
name|SN_PARSE_OK
operator|)
return|;
comment|/* Are there enough bytes in packet to at least retrieve length of next chunk ? */
if|if
condition|(
name|bytes_left
operator|<
name|SN_MIN_CHUNK_SIZE
condition|)
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
name|chunk_hdr
operator|=
name|SN_SCTP_NEXTCHUNK
argument_list|(
name|chunk_hdr
argument_list|)
expr_stmt|;
comment|/* Is the chunk long enough to not cause endless look and are there enough bytes in packet to read the chunk ? */
name|chunk_length
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|chunk_hdr
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_length
operator|<
name|SN_MIN_CHUNK_SIZE
operator|)
operator|||
operator|(
name|chunk_length
operator|>
name|bytes_left
operator|)
condition|)
return|return
operator|(
name|SN_PARSE_ERROR_CHHL
operator|)
return|;
if|if
condition|(
operator|++
name|chunk_count
operator|>
name|sysctl_chunk_proc_limit
condition|)
return|return
operator|(
name|SN_PARSE_OK
operator|)
return|;
comment|/* limit for processing chunks, take what we get */
block|}
if|if
condition|(
operator|*
name|passoc
operator|==
name|NULL
condition|)
return|return
operator|(
name|partial_match
operator|)
condition|?
operator|(
name|SN_PARSE_ERROR_PARTIALLOOKUP
operator|)
else|:
operator|(
name|SN_PARSE_ERROR_LOOKUP
operator|)
return|;
else|else
return|return
operator|(
name|SN_PARSE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup packet_parser  * @brief Extract Vtags from Asconf Chunk  *  * GetAsconfVtags scans an Asconf Chunk for the vtags parameter, and then  * extracts the vtags.  *   * GetAsconfVtags is not called from within sctp_PktParser. It is called only  * from within ID_process when an AddIP has been received.  *  * @param la Pointer to the relevant libalias instance  * @param sm Pointer to sctp message information  * @param l_vtag Pointer to the local vtag in the association this SCTP Message belongs to  * @param g_vtag Pointer to the local vtag in the association this SCTP Message belongs to  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   *   * @return 1 - success | 0 - fail   */
end_comment

begin_function
specifier|static
name|int
name|GetAsconfVtags
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|uint32_t
modifier|*
name|l_vtag
parameter_list|,
name|uint32_t
modifier|*
name|g_vtag
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
comment|/* To be removed when information is in the sctp headers */
define|#
directive|define
name|SCTP_VTAG_PARAM
value|0xC007
struct|struct
name|sctp_vtag_param
block|{
name|struct
name|sctp_paramhdr
name|ph
decl_stmt|;
comment|/* type=SCTP_VTAG_PARAM */
name|uint32_t
name|local_vtag
decl_stmt|;
name|uint32_t
name|remote_vtag
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
name|struct
name|sctp_vtag_param
modifier|*
name|vtag_param
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|param
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|int
name|param_size
decl_stmt|;
name|int
name|param_count
decl_stmt|;
name|param_count
operator|=
literal|1
expr_stmt|;
name|param
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
expr_stmt|;
comment|/* step through Asconf parameters */
while|while
condition|(
operator|(
name|bytes_left
operator|>=
name|param_size
operator|)
operator|&&
operator|(
name|bytes_left
operator|>=
name|SN_VTAG_PARAM_SIZE
operator|)
condition|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_VTAG_PARAM
condition|)
block|{
name|vtag_param
operator|=
operator|(
expr|struct
name|sctp_vtag_param
operator|*
operator|)
name|param
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
comment|/* The Internet draft is a little ambigious as to order of these vtags. 				   We think it is this way around. If we are wrong, the order will need 				   to be changed. */
case|case
name|SN_TO_GLOBAL
case|:
operator|*
name|g_vtag
operator|=
name|vtag_param
operator|->
name|local_vtag
expr_stmt|;
operator|*
name|l_vtag
operator|=
name|vtag_param
operator|->
name|remote_vtag
expr_stmt|;
break|break;
case|case
name|SN_TO_LOCAL
case|:
operator|*
name|g_vtag
operator|=
name|vtag_param
operator|->
name|remote_vtag
expr_stmt|;
operator|*
name|l_vtag
operator|=
name|vtag_param
operator|->
name|local_vtag
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* found */
block|}
name|bytes_left
operator|-=
name|param_size
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|SN_MIN_PARAM_SIZE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|param
operator|=
name|SN_SCTP_NEXTPARAM
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|param_count
operator|>
name|sysctl_param_proc_limit
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"Parameter parse limit exceeded (GetAsconfVtags)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_param_proc_limit
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found limit exceeded*/
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/** @ingroup packet_parser  * @brief AddGlobalIPAddresses from Init,InitAck,or AddIP packets  *   * AddGlobalIPAddresses scans an SCTP chunk (in sm) for Global IP addresses, and  * adds them.  *  * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   *   */
end_comment

begin_function
specifier|static
name|void
name|AddGlobalIPAddresses
parameter_list|(
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|ipv4_param
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|param
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
decl_stmt|;
name|struct
name|in_addr
name|g_addr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|bytes_left
init|=
literal|0
decl_stmt|;
name|int
name|param_size
decl_stmt|;
name|int
name|param_count
decl_stmt|,
name|addr_param_count
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_GLOBAL
case|:
comment|/* does not contain global addresses */
name|g_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
expr_stmt|;
name|bytes_left
operator|=
literal|0
expr_stmt|;
comment|/* force exit */
break|break;
case|case
name|SN_TO_LOCAL
case|:
name|g_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
expr_stmt|;
name|param_count
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_INIT
case|:
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|param
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|SN_SCTP_INITACK
case|:
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
expr_stmt|;
name|param
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sm
operator|->
name|sctpchnk
operator|.
name|InitAck
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|SN_SCTP_ASCONF
case|:
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
expr_stmt|;
name|param
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bytes_left
operator|>=
name|SN_MIN_PARAM_SIZE
condition|)
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|param_size
operator|=
name|bytes_left
operator|+
literal|1
expr_stmt|;
comment|/* force skip loop */
if|if
condition|(
operator|(
name|assoc
operator|->
name|state
operator|==
name|SN_ID
operator|)
operator|&&
operator|(
operator|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
operator|)
operator|||
operator|(
name|bytes_left
operator|<
name|SN_MIN_PARAM_SIZE
operator|)
operator|)
condition|)
block|{
comment|/* add pkt address */
name|G_Addr
operator|=
operator|(
expr|struct
name|sctp_GlobalAddress
operator|*
operator|)
name|sn_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_GlobalAddress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_Addr
operator|==
name|NULL
condition|)
block|{
comment|/* out of resources */
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: No resources for adding global address - revert to no tracking"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
literal|0
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|num_Gaddr
operator|=
literal|0
expr_stmt|;
comment|/* don't track any more for this assoc*/
name|sysctl_track_global_addresses
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|G_Addr
operator|->
name|g_addr
operator|=
name|g_addr
expr_stmt|;
if|if
condition|(
operator|!
name|Add_Global_Address_to_List
argument_list|(
name|assoc
argument_list|,
name|G_Addr
argument_list|)
condition|)
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: Address already in list"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* step through parameters */
while|while
condition|(
operator|(
name|bytes_left
operator|>=
name|param_size
operator|)
operator|&&
operator|(
name|bytes_left
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
operator|>=
name|sysctl_track_global_addresses
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: Maximum Number of addresses reached"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_track_global_addresses
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
comment|/* skip to address parameter - leave param_size so bytes left will be calculated properly*/
name|param
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sctp_asconf_addrv4_param
operator|*
operator|)
name|param
operator|)
operator|->
name|addrp
expr_stmt|;
case|case
name|SCTP_IPV4_ADDRESS
case|:
name|ipv4_param
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|param
expr_stmt|;
comment|/* add addresses to association */
name|G_Addr
operator|=
operator|(
expr|struct
name|sctp_GlobalAddress
operator|*
operator|)
name|sn_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_GlobalAddress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_Addr
operator|==
name|NULL
condition|)
block|{
comment|/* out of resources */
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: No resources for adding global address - revert to no tracking"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
literal|0
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|num_Gaddr
operator|=
literal|0
expr_stmt|;
comment|/* don't track any more for this assoc*/
name|sysctl_track_global_addresses
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* add address */
name|addr_param_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_ASCONF
operator|)
operator|&&
operator|(
name|ipv4_param
operator|->
name|addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
comment|/* use packet address */
name|G_Addr
operator|->
name|g_addr
operator|=
name|g_addr
expr_stmt|;
if|if
condition|(
operator|!
name|Add_Global_Address_to_List
argument_list|(
name|assoc
argument_list|,
name|G_Addr
argument_list|)
condition|)
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: Address already in list"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/*shouldn't be any other addresses if the zero address is given*/
block|}
else|else
block|{
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|=
name|ipv4_param
operator|->
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|Add_Global_Address_to_List
argument_list|(
name|assoc
argument_list|,
name|G_Addr
argument_list|)
condition|)
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: Address already in list"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bytes_left
operator|-=
name|param_size
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|SN_MIN_PARAM_SIZE
condition|)
break|break;
name|param
operator|=
name|SN_SCTP_NEXTPARAM
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|param_count
operator|>
name|sysctl_param_proc_limit
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"Parameter parse limit exceeded (AddGlobalIPAddress)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_param_proc_limit
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* limit exceeded*/
block|}
block|}
if|if
condition|(
name|addr_param_count
operator|==
literal|0
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_DETAIL
argument_list|,
name|logsctperror
argument_list|(
literal|"AddGlobalIPAddress: no address parameters to add"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**   * @brief Add_Global_Address_to_List  *  * Adds a global IP address to an associations address list, if it is not  * already there.  The first address added us usually the packet's address, and  * is most likely to be used, so it is added at the beginning. Subsequent  * addresses are added after this one.  *   * @param assoc Pointer to the association this SCTP Message belongs to  * @param G_addr Pointer to the global address to add  *  * @return 1 - success | 0 - fail   */
end_comment

begin_function
specifier|static
name|int
name|Add_Global_Address_to_List
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_addr
parameter_list|)
block|{
name|struct
name|sctp_GlobalAddress
modifier|*
name|iter_G_Addr
init|=
name|NULL
decl_stmt|,
modifier|*
name|first_G_Addr
init|=
name|NULL
decl_stmt|;
name|first_G_Addr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|assoc
operator|->
name|Gaddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_G_Addr
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|assoc
operator|->
name|Gaddr
operator|)
argument_list|,
name|G_addr
argument_list|,
name|list_Gaddr
argument_list|)
expr_stmt|;
comment|/* add new address to beginning of list*/
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|iter_G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|iter_G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already exists, so don't add */
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|first_G_Addr
argument_list|,
name|G_addr
argument_list|,
name|list_Gaddr
argument_list|)
expr_stmt|;
comment|/* add address to end of list*/
block|}
name|assoc
operator|->
name|num_Gaddr
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/** @ingroup packet_parser  * @brief RmGlobalIPAddresses from DelIP packets  *  * RmGlobalIPAddresses scans an ASCONF chunk for DelIP parameters to remove the  * given Global IP addresses from the association. It will not delete the  * the address if it is a list of one address.  *  *  * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   *   */
end_comment

begin_function
specifier|static
name|void
name|RmGlobalIPAddresses
parameter_list|(
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|struct
name|sctp_asconf_addrv4_param
modifier|*
name|asconf_ipv4_param
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|param
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
decl_stmt|,
modifier|*
name|G_Addr_tmp
decl_stmt|;
name|struct
name|in_addr
name|g_addr
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|int
name|param_size
decl_stmt|;
name|int
name|param_count
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|SN_TO_GLOBAL
condition|)
name|g_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
expr_stmt|;
else|else
name|g_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
expr_stmt|;
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
expr_stmt|;
name|param_count
operator|=
literal|1
expr_stmt|;
name|param
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|>=
name|SN_MIN_PARAM_SIZE
condition|)
block|{
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"RmGlobalIPAddress: truncated packet - cannot remove IP addresses"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_track_global_addresses
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* step through Asconf parameters */
while|while
condition|(
operator|(
name|bytes_left
operator|>=
name|param_size
operator|)
operator|&&
operator|(
name|bytes_left
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|asconf_ipv4_param
operator|=
operator|(
expr|struct
name|sctp_asconf_addrv4_param
operator|*
operator|)
name|param
expr_stmt|;
if|if
condition|(
name|asconf_ipv4_param
operator|->
name|addrp
operator|.
name|addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* remove all bar pkt address */
name|LIST_FOREACH_SAFE
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|,
argument|G_Addr_tmp
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|!=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
operator|>
literal|1
condition|)
block|{
comment|/* only delete if more than one */
name|LIST_REMOVE
argument_list|(
name|G_Addr
argument_list|,
name|list_Gaddr
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|G_Addr
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|num_Gaddr
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"RmGlobalIPAddress: Request to remove last IP address (didn't)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
comment|/*shouldn't be any other addresses if the zero address is given*/
block|}
else|else
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|,
argument|G_Addr_tmp
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|asconf_ipv4_param
operator|->
name|addrp
operator|.
name|addr
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
operator|>
literal|1
condition|)
block|{
comment|/* only delete if more than one */
name|LIST_REMOVE
argument_list|(
name|G_Addr
argument_list|,
name|list_Gaddr
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|G_Addr
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|num_Gaddr
operator|--
expr_stmt|;
break|break;
comment|/* Since add only adds new addresses, there should be no double entries */
block|}
else|else
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"RmGlobalIPAddress: Request to remove last IP address (didn't)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|assoc
operator|->
name|num_Gaddr
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|bytes_left
operator|-=
name|param_size
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|bytes_left
operator|<
name|SN_MIN_PARAM_SIZE
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"RmGlobalIPAddress: truncated packet - may not have removed all IP addresses"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_track_global_addresses
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|param
operator|=
name|SN_SCTP_NEXTPARAM
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|param_count
operator|>
name|sysctl_param_proc_limit
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"Parameter parse limit exceeded (RmGlobalIPAddress)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_param_proc_limit
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* limit exceeded*/
block|}
block|}
block|}
end_function

begin_comment
comment|/**  @ingroup packet_parser  * @brief Check that ASCONF was successful  *  * Each ASCONF configuration parameter carries a correlation ID which should be  * matched with an ASCONFack. This is difficult for a NAT, since every  * association could potentially have a number of outstanding ASCONF  * configuration parameters, which should only be activated on receipt of the  * ACK.  *  * Currently we only look for an ACK when the NAT is setting up a new  * association (ie AddIP for a connection that the NAT does not know about  * because the original Init went through a public interface or another NAT)  * Since there is currently no connection on this path, there should be no other  * ASCONF configuration parameters outstanding, so we presume that if there is  * an ACK that it is responding to the AddIP and activate the new association.  *   * @param la Pointer to the relevant libalias instance  * @param sm Pointer to sctp message information  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   *   * @return 1 - success | 0 - fail  */
end_comment

begin_function
specifier|static
name|int
name|IsASCONFack
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|param
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|int
name|param_size
decl_stmt|;
name|int
name|param_count
decl_stmt|;
name|param_count
operator|=
literal|1
expr_stmt|;
name|param
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_size
operator|==
literal|8
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*success - default acknowledgement of everything */
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|param_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found */
comment|/* step through Asconf parameters */
while|while
condition|(
name|bytes_left
operator|>=
name|SN_ASCONFACK_PARAM_SIZE
condition|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_SUCCESS_REPORT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* success - but can't match correlation IDs - should only be one */
comment|/* check others just in case */
name|bytes_left
operator|-=
name|param_size
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|>=
name|SN_MIN_PARAM_SIZE
condition|)
block|{
name|param
operator|=
name|SN_SCTP_NEXTPARAM
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|param_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|++
name|param_count
operator|>
name|sysctl_param_proc_limit
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"Parameter parse limit exceeded (IsASCONFack)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_param_proc_limit
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found limit exceeded*/
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not success */
block|}
end_function

begin_comment
comment|/**  @ingroup packet_parser  * @brief Check to see if ASCONF contains an Add IP or Del IP parameter   *   * IsADDorDEL scans an ASCONF packet to see if it contains an AddIP or DelIP  * parameter  *  * @param la Pointer to the relevant libalias instance  * @param sm Pointer to sctp message information  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   *   * @return SCTP_ADD_IP_ADDRESS | SCTP_DEL_IP_ADDRESS | 0 - fail  */
end_comment

begin_function
specifier|static
name|int
name|IsADDorDEL
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|param
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|int
name|param_size
decl_stmt|;
name|int
name|param_count
decl_stmt|;
name|param_count
operator|=
literal|1
expr_stmt|;
name|param
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Asconf
expr_stmt|;
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_left
operator|=
name|sm
operator|->
name|chunk_length
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|param_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found */
comment|/* step through Asconf parameters */
while|while
condition|(
name|bytes_left
operator|>=
name|SN_ASCONFACK_PARAM_SIZE
condition|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
return|return
operator|(
name|SCTP_ADD_IP_ADDRESS
operator|)
return|;
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_type
argument_list|)
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
return|return
operator|(
name|SCTP_DEL_IP_ADDRESS
operator|)
return|;
comment|/* check others just in case */
name|bytes_left
operator|-=
name|param_size
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|>=
name|SN_MIN_PARAM_SIZE
condition|)
block|{
name|param
operator|=
name|SN_SCTP_NEXTPARAM
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Neither found */
block|}
name|param_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|param
operator|->
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|param_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|++
name|param_count
operator|>
name|sysctl_param_proc_limit
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_EVENT
argument_list|,
name|logsctperror
argument_list|(
literal|"Parameter parse limit exceeded IsADDorDEL)"
argument_list|,
name|sm
operator|->
name|sctp_hdr
operator|->
name|v_tag
argument_list|,
name|sysctl_param_proc_limit
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found limit exceeded*/
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Neither found */
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                            STATE MACHINE CODE  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/** @addtogroup state_machine  *  * The SCTP NAT State Machine functions will:  * - Process an already parsed packet  * - Use the existing NAT Hash Tables  * - Determine the next state for the association  * - Update the NAT Hash Tables and Timer Queues  * - Return the appropriate action to take with the packet  */
end_comment

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP message  *  * This function is the base state machine. It calls the processing engine for  * each state.  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *  * @return SN_DROP_PKT | SN_NAT_PKT | SN_REPLY_ABORT | SN_REPLY_ERROR | SN_PROCESSING_ERROR  */
end_comment

begin_function
specifier|static
name|int
name|ProcessSctpMsg
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
name|int
name|rtnval
decl_stmt|;
switch|switch
condition|(
name|assoc
operator|->
name|state
condition|)
block|{
case|case
name|SN_ID
case|:
comment|/* Idle */
name|rtnval
operator|=
name|ID_process
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|assoc
argument_list|,
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|!=
name|SN_NAT_PKT
condition|)
block|{
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
case|case
name|SN_INi
case|:
comment|/* Initialising - Init */
return|return
operator|(
name|INi_process
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|assoc
argument_list|,
name|sm
argument_list|)
operator|)
return|;
case|case
name|SN_INa
case|:
comment|/* Initialising - AddIP */
return|return
operator|(
name|INa_process
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|assoc
argument_list|,
name|sm
argument_list|)
operator|)
return|;
case|case
name|SN_UP
case|:
comment|/* Association UP */
return|return
operator|(
name|UP_process
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|assoc
argument_list|,
name|sm
argument_list|)
operator|)
return|;
case|case
name|SN_CL
case|:
comment|/* Association Closing */
return|return
operator|(
name|CL_process
argument_list|(
name|la
argument_list|,
name|direction
argument_list|,
name|assoc
argument_list|,
name|sm
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|SN_PROCESSING_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP message while in the Idle state  *  * This function looks for an Incoming INIT or AddIP message.  *  * All other SCTP messages are invalid when in SN_ID, and are dropped.  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL  * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *  * @return SN_NAT_PKT | SN_DROP_PKT | SN_REPLY_ABORT | SN_REPLY_ERROR  */
end_comment

begin_function
specifier|static
name|int
name|ID_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_ASCONF
case|:
comment|/* a packet containing an ASCONF chunk with ADDIP */
if|if
condition|(
operator|!
name|sysctl_accept_global_ootb_addip
operator|&&
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
condition|)
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* if this Asconf packet does not contain the Vtag parameters it is of no use in Idle state */
if|if
condition|(
operator|!
name|GetAsconfVtags
argument_list|(
name|la
argument_list|,
name|sm
argument_list|,
operator|&
operator|(
name|assoc
operator|->
name|l_vtag
operator|)
argument_list|,
operator|&
operator|(
name|assoc
operator|->
name|g_vtag
operator|)
argument_list|,
name|direction
argument_list|)
condition|)
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
case|case
name|SN_SCTP_INIT
case|:
comment|/* a packet containing an INIT chunk or an ASCONF AddIP */
if|if
condition|(
name|sysctl_track_global_addresses
condition|)
name|AddGlobalIPAddresses
argument_list|(
name|sm
argument_list|,
name|assoc
argument_list|,
name|direction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_GLOBAL
case|:
name|assoc
operator|->
name|l_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
expr_stmt|;
name|assoc
operator|->
name|a_addr
operator|=
name|FindAliasAddress
argument_list|(
name|la
argument_list|,
name|assoc
operator|->
name|l_addr
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|l_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|src_port
expr_stmt|;
name|assoc
operator|->
name|g_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|dest_port
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
condition|)
name|assoc
operator|->
name|g_vtag
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|->
name|initiate_tag
expr_stmt|;
if|if
condition|(
name|AddSctpAssocGlobal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
condition|)
comment|/* DB clash */
comment|//**** need to add dst address
return|return
operator|(
operator|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
operator|)
condition|?
name|SN_REPLY_ABORT
else|:
name|SN_REPLY_ERROR
operator|)
return|;
if|if
condition|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_ASCONF
condition|)
block|{
if|if
condition|(
name|AddSctpAssocLocal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
argument_list|)
condition|)
comment|/* DB clash */
return|return
operator|(
name|SN_REPLY_ERROR
operator|)
return|;
name|assoc
operator|->
name|TableRegister
operator||=
name|SN_WAIT_TOLOCAL
expr_stmt|;
comment|/* wait for tolocal ack */
block|}
break|break;
case|case
name|SN_TO_LOCAL
case|:
name|assoc
operator|->
name|l_addr
operator|=
name|FindSctpRedirectAddress
argument_list|(
name|la
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|a_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_dst
expr_stmt|;
name|assoc
operator|->
name|l_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|dest_port
expr_stmt|;
name|assoc
operator|->
name|g_port
operator|=
name|sm
operator|->
name|sctp_hdr
operator|->
name|src_port
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
condition|)
name|assoc
operator|->
name|l_vtag
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|->
name|initiate_tag
expr_stmt|;
if|if
condition|(
name|AddSctpAssocLocal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
argument_list|)
condition|)
comment|/* DB clash */
return|return
operator|(
operator|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
operator|)
condition|?
name|SN_REPLY_ABORT
else|:
name|SN_REPLY_ERROR
operator|)
return|;
if|if
condition|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_ASCONF
condition|)
block|{
if|if
condition|(
name|AddSctpAssocGlobal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
condition|)
comment|/* DB clash */
comment|//**** need to add src address
return|return
operator|(
name|SN_REPLY_ERROR
operator|)
return|;
name|assoc
operator|->
name|TableRegister
operator||=
name|SN_WAIT_TOGLOBAL
expr_stmt|;
comment|/* wait for toglobal ack */
block|}
break|break;
block|}
name|assoc
operator|->
name|state
operator|=
operator|(
name|sm
operator|->
name|msg
operator|==
name|SN_SCTP_INIT
operator|)
condition|?
name|SN_INi
else|:
name|SN_INa
expr_stmt|;
name|assoc
operator|->
name|exp
operator|=
name|SN_I_T
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|sctp_AddTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
default|default:
comment|/* Any other type of SCTP message is not valid in Idle */
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
block|}
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* shouldn't get here very bad: log, drop and hope for the best */
block|}
end_function

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP message while waiting for an INIT-ACK message  *  * Only an INIT-ACK, resent INIT, or an ABORT SCTP packet are valid in this  * state, all other packets are dropped.  *   * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *   * @return SN_NAT_PKT | SN_DROP_PKT | SN_REPLY_ABORT   */
end_comment

begin_function
specifier|static
name|int
name|INi_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_INIT
case|:
comment|/* a packet containing a retransmitted INIT chunk */
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_I_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_INITACK
case|:
comment|/* a packet containing an INIT-ACK chunk */
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_LOCAL
case|:
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
comment|/*If tracking global addresses for this association */
name|AddGlobalIPAddresses
argument_list|(
name|sm
argument_list|,
name|assoc
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|l_vtag
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|->
name|initiate_tag
expr_stmt|;
if|if
condition|(
name|AddSctpAssocLocal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
argument_list|)
condition|)
block|{
comment|/* DB clash */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_SEND_ABORT
operator|)
return|;
block|}
break|break;
case|case
name|SN_TO_GLOBAL
case|:
name|assoc
operator|->
name|l_addr
operator|=
name|sm
operator|->
name|ip_hdr
operator|->
name|ip_src
expr_stmt|;
comment|// Only if not set in Init! *
name|assoc
operator|->
name|g_vtag
operator|=
name|sm
operator|->
name|sctpchnk
operator|.
name|Init
operator|->
name|initiate_tag
expr_stmt|;
if|if
condition|(
name|AddSctpAssocGlobal
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
condition|)
block|{
comment|/* DB clash */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_SEND_ABORT
operator|)
return|;
block|}
break|break;
block|}
name|assoc
operator|->
name|state
operator|=
name|SN_UP
expr_stmt|;
comment|/* association established for NAT */
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_U_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_ABORT
case|:
comment|/* a packet containing an ABORT chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
default|default:
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
block|}
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* shouldn't get here very bad: log, drop and hope for the best */
block|}
end_function

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP message while waiting for an AddIp-ACK message  *   * Only an AddIP-ACK, resent AddIP, or an ABORT message are valid, all other  * SCTP packets are dropped  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *   * @return SN_NAT_PKT | SN_DROP_PKT   */
end_comment

begin_function
specifier|static
name|int
name|INa_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_ASCONF
case|:
comment|/* a packet containing an ASCONF chunk*/
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_I_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_ASCONFACK
case|:
comment|/* a packet containing an ASCONF chunk with a ADDIP-ACK */
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_LOCAL
case|:
if|if
condition|(
operator|!
operator|(
name|assoc
operator|->
name|TableRegister
operator|&
name|SN_WAIT_TOLOCAL
operator|)
condition|)
comment|/* wrong direction */
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
break|break;
case|case
name|SN_TO_GLOBAL
case|:
if|if
condition|(
operator|!
operator|(
name|assoc
operator|->
name|TableRegister
operator|&
name|SN_WAIT_TOGLOBAL
operator|)
condition|)
comment|/* wrong direction */
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
block|}
if|if
condition|(
name|IsASCONFack
argument_list|(
name|la
argument_list|,
name|sm
argument_list|,
name|direction
argument_list|)
condition|)
block|{
name|assoc
operator|->
name|TableRegister
operator|&=
name|SN_BOTH_TBL
expr_stmt|;
comment|/* remove wait flags */
name|assoc
operator|->
name|state
operator|=
name|SN_UP
expr_stmt|;
comment|/* association established for NAT */
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_U_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
block|}
else|else
block|{
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
block|}
case|case
name|SN_SCTP_ABORT
case|:
comment|/* a packet containing an ABORT chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
default|default:
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
block|}
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* shouldn't get here very bad: log, drop and hope for the best */
block|}
end_function

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP messages while association is UP redirecting packets  *   * While in the SN_UP state, all packets for the particular association  * are passed. Only a SHUT-ACK or an ABORT will cause a change of state.  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *   * @return SN_NAT_PKT | SN_DROP_PKT   */
end_comment

begin_function
specifier|static
name|int
name|UP_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_SHUTACK
case|:
comment|/* a packet containing a SHUTDOWN-ACK chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_CL
expr_stmt|;
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_C_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_ABORT
case|:
comment|/* a packet containing an ABORT chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_ASCONF
case|:
comment|/* a packet containing an ASCONF chunk*/
if|if
condition|(
operator|(
name|direction
operator|==
name|SN_TO_LOCAL
operator|)
operator|&&
name|assoc
operator|->
name|num_Gaddr
condition|)
comment|/*If tracking global addresses for this association& from global side */
switch|switch
condition|(
name|IsADDorDEL
argument_list|(
name|la
argument_list|,
name|sm
argument_list|,
name|direction
argument_list|)
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
name|AddGlobalIPAddresses
argument_list|(
name|sm
argument_list|,
name|assoc
argument_list|,
name|direction
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|RmGlobalIPAddresses
argument_list|(
name|sm
argument_list|,
name|assoc
argument_list|,
name|direction
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through to default */
default|default:
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_U_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
comment|/* forward packet */
block|}
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* shouldn't get here very bad: log, drop and hope for the best */
block|}
end_function

begin_comment
comment|/** @ingroup state_machine  * @brief Process SCTP message while association is in the process of closing  *  * This function waits for a SHUT-COMP to close the association. Depending on  * the the setting of sysctl_holddown_timer it may not remove the association  * immediately, but leave it up until SN_X_T(la). Only SHUT-COMP, SHUT-ACK, and  * ABORT packets are permitted in this state. All other packets are dropped.  *  * @param la Pointer to the relevant libalias instance  * @param direction SN_TO_LOCAL | SN_TO_GLOBAL   * @param sm Pointer to sctp message information  * @param assoc Pointer to the association this SCTP Message belongs to  *   * @return SN_NAT_PKT | SN_DROP_PKT   */
end_comment

begin_function
specifier|static
name|int
name|CL_process
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_SHUTCOMP
case|:
comment|/* a packet containing a SHUTDOWN-COMPLETE chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_CL
expr_stmt|;
comment|/* Stay in Close state until timeout */
if|if
condition|(
name|sysctl_holddown_timer
operator|>
literal|0
condition|)
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_X_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allow to stay open for Tbit packets*/
else|else
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_SHUTACK
case|:
comment|/* a packet containing a SHUTDOWN-ACK chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_CL
expr_stmt|;
comment|/* Stay in Close state until timeout */
name|sctp_ResetTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|,
name|SN_C_T
argument_list|(
name|la
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
case|case
name|SN_SCTP_ABORT
case|:
comment|/* a packet containing an ABORT chunk */
name|assoc
operator|->
name|state
operator|=
name|SN_RM
expr_stmt|;
comment|/* Mark for removal*/
return|return
operator|(
name|SN_NAT_PKT
operator|)
return|;
default|default:
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
block|}
return|return
operator|(
name|SN_DROP_PKT
operator|)
return|;
comment|/* shouldn't get here very bad: log, drop and hope for the best */
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                           HASH TABLE CODE  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/** @addtogroup Hash  *  * The Hash functions facilitate searching the NAT Hash Tables for associations  * as well as adding/removing associations from the table(s).  */
end_comment

begin_comment
comment|/** @ingroup Hash  * @brief Find the SCTP association given the local address, port and vtag  *   * Searches the local look-up table for the association entry matching the  * provided local<address:ports:vtag> tuple  *  * @param la Pointer to the relevant libalias instance  * @param l_addr local address  * @param g_addr global address  * @param l_vtag local Vtag  * @param l_port local Port  * @param g_port global Port  *   * @return pointer to association or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|l_addr
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|l_vtag
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|uint16_t
name|g_port
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|l_vtag
operator|!=
literal|0
condition|)
block|{
comment|/* an init packet, vtag==0 */
name|i
operator|=
name|SN_TABLE_HASH
argument_list|(
name|l_vtag
argument_list|,
name|l_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableLocal[i]
argument_list|,
argument|list_L
argument_list|)
block|{
if|if
condition|(
operator|(
name|assoc
operator|->
name|l_vtag
operator|==
name|l_vtag
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|l_port
operator|==
name|l_port
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|g_port
operator|==
name|g_port
operator|)
expr|\
operator|&&
operator|(
name|assoc
operator|->
name|l_addr
operator|.
name|s_addr
operator|==
name|l_addr
operator|.
name|s_addr
operator|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief Check for Global Clash  *   * Searches the global look-up table for the association entry matching the  * provided global<(addresses):ports:vtag> tuple  *  * @param la Pointer to the relevant libalias instance  * @param Cassoc association being checked for a clash  *   * @return pointer to association or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobalClash
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|Cassoc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_AddrC
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|Cassoc
operator|->
name|g_vtag
operator|!=
literal|0
condition|)
block|{
comment|/* an init packet, vtag==0 */
name|i
operator|=
name|SN_TABLE_HASH
argument_list|(
name|Cassoc
operator|->
name|g_vtag
argument_list|,
name|Cassoc
operator|->
name|g_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableGlobal[i]
argument_list|,
argument|list_G
argument_list|)
block|{
if|if
condition|(
operator|(
name|assoc
operator|->
name|g_vtag
operator|==
name|Cassoc
operator|->
name|g_vtag
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|g_port
operator|==
name|Cassoc
operator|->
name|g_port
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|l_port
operator|==
name|Cassoc
operator|->
name|l_port
operator|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_AddrC
argument_list|,
argument|&(Cassoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|G_AddrC
operator|->
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief Find the SCTP association given the global port and vtag  *   * Searches the global look-up table for the association entry matching the  * provided global<address:ports:vtag> tuple  *  * If all but the global address match it sets partial_match to 1 to indicate a  * partial match. If the NAT is tracking global IP addresses for this  * association, the NAT may respond with an ERRORM to request the missing  * address to be added.  *  * @param la Pointer to the relevant libalias instance  * @param g_addr global address  * @param g_vtag global vtag  * @param g_port global port  * @param l_port local port  *   * @return pointer to association or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|g_vtag
parameter_list|,
name|uint16_t
name|g_port
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|int
modifier|*
name|partial_match
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
operator|*
name|partial_match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g_vtag
operator|!=
literal|0
condition|)
block|{
comment|/* an init packet, vtag==0 */
name|i
operator|=
name|SN_TABLE_HASH
argument_list|(
name|g_vtag
argument_list|,
name|g_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableGlobal[i]
argument_list|,
argument|list_G
argument_list|)
block|{
if|if
condition|(
operator|(
name|assoc
operator|->
name|g_vtag
operator|==
name|g_vtag
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|g_port
operator|==
name|g_port
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|l_port
operator|==
name|l_port
operator|)
condition|)
block|{
operator|*
name|partial_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief Find the SCTP association for a T-Flag message (given the global port and local vtag)  *   * Searches the local look-up table for a unique association entry matching the  * provided global port and local vtag information  *  * @param la Pointer to the relevant libalias instance  * @param g_addr global address  * @param l_vtag local Vtag  * @param g_port global Port  * @param l_port local Port  *   * @return pointer to association or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpLocalT
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|l_vtag
parameter_list|,
name|uint16_t
name|g_port
parameter_list|,
name|uint16_t
name|l_port
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|,
modifier|*
name|lastmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l_vtag
operator|!=
literal|0
condition|)
block|{
comment|/* an init packet, vtag==0 */
name|i
operator|=
name|SN_TABLE_HASH
argument_list|(
name|l_vtag
argument_list|,
name|g_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableGlobal[i]
argument_list|,
argument|list_G
argument_list|)
block|{
if|if
condition|(
operator|(
name|assoc
operator|->
name|g_vtag
operator|==
name|l_vtag
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|g_port
operator|==
name|g_port
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|l_port
operator|==
name|l_port
operator|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|assoc
operator|)
return|;
comment|/* full match */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|++
name|cnt
operator|>
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lastmatch
operator|=
name|assoc
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If there is more than one match we do not know which local address to send to */
return|return
operator|(
name|cnt
condition|?
name|lastmatch
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief Find the SCTP association for a T-Flag message (given the local port and global vtag)  *   * Searches the global look-up table for a unique association entry matching the  * provided local port and global vtag information  *  * @param la Pointer to the relevant libalias instance  * @param g_addr global address  * @param g_vtag global vtag  * @param l_port local port  * @param g_port global port  *   * @return pointer to association or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_nat_assoc
modifier|*
name|FindSctpGlobalT
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|,
name|uint32_t
name|g_vtag
parameter_list|,
name|uint16_t
name|l_port
parameter_list|,
name|uint16_t
name|g_port
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|g_vtag
operator|!=
literal|0
condition|)
block|{
comment|/* an init packet, vtag==0 */
name|i
operator|=
name|SN_TABLE_HASH
argument_list|(
name|g_vtag
argument_list|,
name|l_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableLocal[i]
argument_list|,
argument|list_L
argument_list|)
block|{
if|if
condition|(
operator|(
name|assoc
operator|->
name|l_vtag
operator|==
name|g_vtag
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|l_port
operator|==
name|l_port
operator|)
operator|&&
operator|(
name|assoc
operator|->
name|g_port
operator|==
name|g_port
operator|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|->
name|num_Gaddr
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
if|if
condition|(
name|G_Addr
operator|->
name|g_addr
operator|.
name|s_addr
operator|==
name|g_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|assoc
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief  Add the sctp association information to the local look up table  *   * Searches the local look-up table for an existing association with the same  * details. If a match exists and is ONLY in the local look-up table then this  * is a repeated INIT packet, we need to remove this association from the  * look-up table and add the new association  *  * The new association is added to the head of the list and state is updated  *  * @param la Pointer to the relevant libalias instance  * @param assoc pointer to sctp association  * @param g_addr global address  *   * @return SN_ADD_OK | SN_ADD_CLASH  */
end_comment

begin_function
specifier|static
name|int
name|AddSctpAssocLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|struct
name|in_addr
name|g_addr
parameter_list|)
block|{
name|struct
name|sctp_nat_assoc
modifier|*
name|found
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|found
operator|=
name|FindSctpLocal
argument_list|(
name|la
argument_list|,
name|assoc
operator|->
name|l_addr
argument_list|,
name|g_addr
argument_list|,
name|assoc
operator|->
name|l_vtag
argument_list|,
name|assoc
operator|->
name|l_port
argument_list|,
name|assoc
operator|->
name|g_port
argument_list|)
expr_stmt|;
comment|/* 	 * Note that if a different global address initiated this Init, 	 * ie it wasn't resent as presumed: 	 *  - the local receiver if receiving it for the first time will establish 	 *    an association with the new global host 	 *  - if receiving an init from a different global address after sending a 	 *    lost initack it will send an initack to the new global host, the first 	 *    association attempt will then be blocked if retried. 	 */
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|->
name|TableRegister
operator|==
name|SN_LOCAL_TBL
operator|)
operator|&&
operator|(
name|found
operator|->
name|g_port
operator|==
name|assoc
operator|->
name|g_port
operator|)
condition|)
block|{
comment|/* resent message */
name|RmSctpAssoc
argument_list|(
name|la
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|sctp_RmTimeOut
argument_list|(
name|la
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|freeGlobalAddressList
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|SN_ADD_CLASH
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|la
operator|->
name|sctpTableLocal
index|[
name|SN_TABLE_HASH
argument_list|(
name|assoc
operator|->
name|l_vtag
argument_list|,
name|assoc
operator|->
name|l_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
index|]
argument_list|,
name|assoc
argument_list|,
name|list_L
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|TableRegister
operator||=
name|SN_LOCAL_TBL
expr_stmt|;
name|la
operator|->
name|sctpLinkCount
operator|++
expr_stmt|;
comment|//increment link count
if|if
condition|(
name|assoc
operator|->
name|TableRegister
operator|==
name|SN_BOTH_TBL
condition|)
block|{
comment|/* libalias log -- controlled by libalias */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
name|SctpShowAliasStats
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_INFO
argument_list|,
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
literal|"^"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SN_ADD_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief  Add the sctp association information to the global look up table  *  * Searches the global look-up table for an existing association with the same  * details. If a match exists and is ONLY in the global look-up table then this  * is a repeated INIT packet, we need to remove this association from the  * look-up table and add the new association  *  * The new association is added to the head of the list and state is updated  *  * @param la Pointer to the relevant libalias instance  * @param assoc pointer to sctp association  *  * @return SN_ADD_OK | SN_ADD_CLASH  */
end_comment

begin_function
specifier|static
name|int
name|AddSctpAssocGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
name|struct
name|sctp_nat_assoc
modifier|*
name|found
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|found
operator|=
name|FindSctpGlobalClash
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|->
name|TableRegister
operator|==
name|SN_GLOBAL_TBL
operator|)
operator|&&
expr|\
operator|(
name|found
operator|->
name|l_addr
operator|.
name|s_addr
operator|==
name|assoc
operator|->
name|l_addr
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|found
operator|->
name|l_port
operator|==
name|assoc
operator|->
name|l_port
operator|)
condition|)
block|{
comment|/* resent message */
name|RmSctpAssoc
argument_list|(
name|la
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|sctp_RmTimeOut
argument_list|(
name|la
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|freeGlobalAddressList
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|SN_ADD_CLASH
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|la
operator|->
name|sctpTableGlobal
index|[
name|SN_TABLE_HASH
argument_list|(
name|assoc
operator|->
name|g_vtag
argument_list|,
name|assoc
operator|->
name|g_port
argument_list|,
name|la
operator|->
name|sctpNatTableSize
argument_list|)
index|]
argument_list|,
name|assoc
argument_list|,
name|list_G
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|TableRegister
operator||=
name|SN_GLOBAL_TBL
expr_stmt|;
name|la
operator|->
name|sctpLinkCount
operator|++
expr_stmt|;
comment|//increment link count
if|if
condition|(
name|assoc
operator|->
name|TableRegister
operator|==
name|SN_BOTH_TBL
condition|)
block|{
comment|/* libalias log -- controlled by libalias */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
name|SctpShowAliasStats
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|SN_LOG
argument_list|(
name|SN_LOG_INFO
argument_list|,
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
literal|"^"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SN_ADD_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @ingroup Hash  * @brief Remove the sctp association information from the look up table  *   * For each of the two (local/global) look-up tables, remove the association  * from that table IF it has been registered in that table.  *  * NOTE: The calling code is responsible for freeing memory allocated to the  *       association structure itself  *  * NOTE: The association is NOT removed from the timer queue  *  * @param la Pointer to the relevant libalias instance  * @param assoc pointer to sctp association  */
end_comment

begin_function
specifier|static
name|void
name|RmSctpAssoc
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
comment|//  struct sctp_nat_assoc *found;
if|if
condition|(
name|assoc
operator|==
name|NULL
condition|)
block|{
comment|/* very bad, log and die*/
name|SN_LOG
argument_list|(
name|SN_LOG_LOW
argument_list|,
name|logsctperror
argument_list|(
literal|"ERROR: alias_sctp:RmSctpAssoc(NULL)\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SN_TO_NODIR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* log if association is fully up and now closing */
if|if
condition|(
name|assoc
operator|->
name|TableRegister
operator|==
name|SN_BOTH_TBL
condition|)
block|{
name|SN_LOG
argument_list|(
name|SN_LOG_INFO
argument_list|,
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
literal|"$"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|->
name|TableRegister
operator|&
name|SN_LOCAL_TBL
condition|)
block|{
name|assoc
operator|->
name|TableRegister
operator|^=
name|SN_LOCAL_TBL
expr_stmt|;
name|la
operator|->
name|sctpLinkCount
operator|--
expr_stmt|;
comment|//decrement link count
name|LIST_REMOVE
argument_list|(
name|assoc
argument_list|,
name|list_L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assoc
operator|->
name|TableRegister
operator|&
name|SN_GLOBAL_TBL
condition|)
block|{
name|assoc
operator|->
name|TableRegister
operator|^=
name|SN_GLOBAL_TBL
expr_stmt|;
name|la
operator|->
name|sctpLinkCount
operator|--
expr_stmt|;
comment|//decrement link count
name|LIST_REMOVE
argument_list|(
name|assoc
argument_list|,
name|list_G
argument_list|)
expr_stmt|;
block|}
comment|//  sn_free(assoc); //Don't remove now, remove if needed later
comment|/* libalias logging -- controlled by libalias log definition */
if|if
condition|(
name|la
operator|->
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
name|SctpShowAliasStats
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * @ingroup Hash  * @brief  free the Global Address List memory  *   * freeGlobalAddressList deletes all global IP addresses in an associations  * global IP address list.  *  * @param assoc   */
end_comment

begin_function
specifier|static
name|void
name|freeGlobalAddressList
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
name|struct
name|sctp_GlobalAddress
modifier|*
name|gaddr1
init|=
name|NULL
decl_stmt|,
modifier|*
name|gaddr2
init|=
name|NULL
decl_stmt|;
comment|/*free global address list*/
name|gaddr1
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|assoc
operator|->
name|Gaddr
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|gaddr1
operator|!=
name|NULL
condition|)
block|{
name|gaddr2
operator|=
name|LIST_NEXT
argument_list|(
name|gaddr1
argument_list|,
name|list_Gaddr
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|gaddr1
argument_list|)
expr_stmt|;
name|gaddr1
operator|=
name|gaddr2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                            TIMER QUEUE CODE  * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/** @addtogroup Timer  *  * The timer queue management functions are designed to operate efficiently with  * a minimum of interaction with the queues.  *  * Once a timeout is set in the queue it will not be altered in the queue unless  * it has to be changed to a shorter time (usually only for aborts and closing).  * On a queue timeout, the real expiry time is checked, and if not leq than the  * timeout it is requeued (O(1)) at its later time. This is especially important  * for normal packets sent during an association. When a timer expires, it is  * updated to its new expiration time if necessary, or processed as a  * timeout. This means that while in UP state, the timing queue is only altered  * every U_T (every few minutes) for a particular association.  */
end_comment

begin_comment
comment|/** @ingroup Timer  * @brief Add an association timeout to the timer queue  *  * Determine the location in the queue to add the timeout and insert the  * association into the list at that queue position  *  * @param la   * @param assoc   */
end_comment

begin_function
specifier|static
name|void
name|sctp_AddTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
name|int
name|add_loc
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|add_loc
operator|=
name|assoc
operator|->
name|exp
operator|-
name|la
operator|->
name|sctpNatTimer
operator|.
name|loc_time
operator|+
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
expr_stmt|;
if|if
condition|(
name|add_loc
operator|>=
name|SN_TIMER_QUEUE_SIZE
condition|)
name|add_loc
operator|-=
name|SN_TIMER_QUEUE_SIZE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
index|[
name|add_loc
index|]
argument_list|,
name|assoc
argument_list|,
name|timer_Q
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|exp_loc
operator|=
name|add_loc
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @ingroup Timer  * @brief Remove an association from timer queue  *  * This is an O(1) operation to remove the association pointer from its  * current position in the timer queue  *  * @param la Pointer to the relevant libalias instance  * @param assoc pointer to sctp association  */
end_comment

begin_function
specifier|static
name|void
name|sctp_RmTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|)
block|{
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|assoc
argument_list|,
name|timer_Q
argument_list|)
expr_stmt|;
comment|/* Note this is O(1) */
block|}
end_function

begin_comment
comment|/** @ingroup Timer  * @brief Reset timer in timer queue  *  * Reset the actual timeout for the specified association. If it is earlier than  * the existing timeout, then remove and re-install the association into the  * queue  *  * @param la Pointer to the relevant libalias instance  * @param assoc pointer to sctp association  * @param newexp New expiration time  */
end_comment

begin_function
specifier|static
name|void
name|sctp_ResetTimeOut
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|,
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|int
name|newexp
parameter_list|)
block|{
if|if
condition|(
name|newexp
operator|<
name|assoc
operator|->
name|exp
condition|)
block|{
name|sctp_RmTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|exp
operator|=
name|newexp
expr_stmt|;
name|sctp_AddTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assoc
operator|->
name|exp
operator|=
name|newexp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** @ingroup Timer  * @brief Check timer Q against current time  *   * Loop through each entry in the timer queue since the last time we processed  * the timer queue until now (the current time). For each association in the  * event list, we remove it from that position in the timer queue and check if  * it has really expired. If so we:  * - Log the timer expiry  * - Remove the association from the NAT tables  * - Release the memory used by the association  *  * If the timer hasn't really expired we place the association into its new  * correct position in the timer queue.  *   * @param la  Pointer to the relevant libalias instance  */
end_comment

begin_function
name|void
name|sctp_CheckTimers
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
decl_stmt|;
name|LIBALIAS_LOCK_ASSERT
argument_list|(
name|la
argument_list|)
expr_stmt|;
while|while
condition|(
name|la
operator|->
name|timeStamp
operator|>=
name|la
operator|->
name|sctpNatTimer
operator|.
name|loc_time
condition|)
block|{
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
index|[
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
index|]
argument_list|)
condition|)
block|{
name|assoc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|la
operator|->
name|sctpNatTimer
operator|.
name|TimerQ
index|[
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
index|]
argument_list|)
expr_stmt|;
comment|//SLIST_REMOVE_HEAD(&la->sctpNatTimer.TimerQ[la->sctpNatTimer.cur_loc], timer_Q);
name|LIST_REMOVE
argument_list|(
name|assoc
argument_list|,
name|timer_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|timeStamp
operator|>=
name|assoc
operator|->
name|exp
condition|)
block|{
comment|/* state expired */
name|SN_LOG
argument_list|(
operator|(
operator|(
name|assoc
operator|->
name|state
operator|==
name|SN_CL
operator|)
condition|?
operator|(
name|SN_LOG_DEBUG
operator|)
else|:
operator|(
name|SN_LOG_INFO
operator|)
operator|)
argument_list|,
name|logsctperror
argument_list|(
literal|"Timer Expired"
argument_list|,
name|assoc
operator|->
name|g_vtag
argument_list|,
name|assoc
operator|->
name|state
argument_list|,
name|SN_TO_NODIR
argument_list|)
argument_list|)
expr_stmt|;
name|RmSctpAssoc
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
name|freeGlobalAddressList
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
name|sn_free
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* state not expired, reschedule timer*/
name|sctp_AddTimeOut
argument_list|(
name|la
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Goto next location in the timer queue*/
operator|++
name|la
operator|->
name|sctpNatTimer
operator|.
name|loc_time
expr_stmt|;
if|if
condition|(
operator|++
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
operator|>=
name|SN_TIMER_QUEUE_SIZE
condition|)
name|la
operator|->
name|sctpNatTimer
operator|.
name|cur_loc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  *                              LOGGING CODE   * ----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/** @addtogroup Logging  *  * The logging functions provide logging of different items ranging from logging  * a simple message, through logging an association details to logging the  * current state of the NAT tables  */
end_comment

begin_comment
comment|/** @ingroup Logging  * @brief Log sctp nat errors  *   * @param errormsg Error message to be logged  * @param vtag Current Vtag  * @param error Error number  * @param direction Direction of packet  */
end_comment

begin_function
specifier|static
name|void
name|logsctperror
parameter_list|(
name|char
modifier|*
name|errormsg
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|char
name|dir
decl_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_LOCAL
case|:
name|dir
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|SN_TO_GLOBAL
case|:
name|dir
operator|=
literal|'G'
expr_stmt|;
break|break;
default|default:
name|dir
operator|=
literal|'*'
expr_stmt|;
break|break;
block|}
name|SctpAliasLog
argument_list|(
literal|"->%c %s (vt=%u) %d\n"
argument_list|,
name|dir
argument_list|,
name|errormsg
argument_list|,
name|ntohl
argument_list|(
name|vtag
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @ingroup Logging  * @brief Log what the parser parsed  *   * @param direction Direction of packet  * @param sm Pointer to sctp message information  */
end_comment

begin_function
specifier|static
name|void
name|logsctpparse
parameter_list|(
name|int
name|direction
parameter_list|,
name|struct
name|sctp_nat_msg
modifier|*
name|sm
parameter_list|)
block|{
name|char
modifier|*
name|ploc
decl_stmt|,
modifier|*
name|pstate
decl_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|SN_TO_LOCAL
case|:
name|ploc
operator|=
literal|"TO_LOCAL -"
expr_stmt|;
break|break;
case|case
name|SN_TO_GLOBAL
case|:
name|ploc
operator|=
literal|"TO_GLOBAL -"
expr_stmt|;
break|break;
default|default:
name|ploc
operator|=
literal|""
expr_stmt|;
block|}
switch|switch
condition|(
name|sm
operator|->
name|msg
condition|)
block|{
case|case
name|SN_SCTP_INIT
case|:
name|pstate
operator|=
literal|"Init"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_INITACK
case|:
name|pstate
operator|=
literal|"InitAck"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_ABORT
case|:
name|pstate
operator|=
literal|"Abort"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_SHUTACK
case|:
name|pstate
operator|=
literal|"ShutAck"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_SHUTCOMP
case|:
name|pstate
operator|=
literal|"ShutComp"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_ASCONF
case|:
name|pstate
operator|=
literal|"Asconf"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_ASCONFACK
case|:
name|pstate
operator|=
literal|"AsconfAck"
expr_stmt|;
break|break;
case|case
name|SN_SCTP_OTHER
case|:
name|pstate
operator|=
literal|"Other"
expr_stmt|;
break|break;
default|default:
name|pstate
operator|=
literal|"***ERROR***"
expr_stmt|;
break|break;
block|}
name|SctpAliasLog
argument_list|(
literal|"Parsed: %s %s\n"
argument_list|,
name|ploc
argument_list|,
name|pstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @ingroup Logging  * @brief Log an SCTP association's details  *   * @param assoc pointer to sctp association  * @param s Character that indicates the state of processing for this packet  */
end_comment

begin_function
specifier|static
name|void
name|logsctpassoc
parameter_list|(
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|sctp_GlobalAddress
modifier|*
name|G_Addr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
switch|switch
condition|(
name|assoc
operator|->
name|state
condition|)
block|{
case|case
name|SN_ID
case|:
name|sp
operator|=
literal|"ID "
expr_stmt|;
break|break;
case|case
name|SN_INi
case|:
name|sp
operator|=
literal|"INi "
expr_stmt|;
break|break;
case|case
name|SN_INa
case|:
name|sp
operator|=
literal|"INa "
expr_stmt|;
break|break;
case|case
name|SN_UP
case|:
name|sp
operator|=
literal|"UP "
expr_stmt|;
break|break;
case|case
name|SN_CL
case|:
name|sp
operator|=
literal|"CL "
expr_stmt|;
break|break;
case|case
name|SN_RM
case|:
name|sp
operator|=
literal|"RM "
expr_stmt|;
break|break;
default|default:
name|sp
operator|=
literal|"***ERROR***"
expr_stmt|;
break|break;
block|}
name|SctpAliasLog
argument_list|(
literal|"%sAssoc: %s exp=%u la=%s lv=%u lp=%u gv=%u gp=%u tbl=%d\n"
argument_list|,
name|s
argument_list|,
name|sp
argument_list|,
name|assoc
operator|->
name|exp
argument_list|,
name|inet_ntoa
argument_list|(
name|assoc
operator|->
name|l_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|assoc
operator|->
name|l_vtag
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|assoc
operator|->
name|l_port
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|assoc
operator|->
name|g_vtag
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|assoc
operator|->
name|g_port
argument_list|)
argument_list|,
name|assoc
operator|->
name|TableRegister
argument_list|)
expr_stmt|;
comment|/* list global addresses */
name|LIST_FOREACH
argument_list|(
argument|G_Addr
argument_list|,
argument|&(assoc->Gaddr)
argument_list|,
argument|list_Gaddr
argument_list|)
block|{
name|SctpAliasLog
argument_list|(
literal|"\t\tga=%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|G_Addr
operator|->
name|g_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** @ingroup Logging  * @brief Output Global table to log   *   * @param la Pointer to the relevant libalias instance  */
end_comment

begin_function
specifier|static
name|void
name|logSctpGlobal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|SctpAliasLog
argument_list|(
literal|"G->\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|la
operator|->
name|sctpNatTableSize
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableGlobal[i]
argument_list|,
argument|list_G
argument_list|)
block|{
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** @ingroup Logging  * @brief  Output Local table to log   *   * @param la Pointer to the relevant libalias instance  */
end_comment

begin_function
specifier|static
name|void
name|logSctpLocal
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|SctpAliasLog
argument_list|(
literal|"L->\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|la
operator|->
name|sctpNatTableSize
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpTableLocal[i]
argument_list|,
argument|list_L
argument_list|)
block|{
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** @ingroup Logging  * @brief Output timer queue to log  *   * @param la Pointer to the relevant libalias instance  */
end_comment

begin_function
specifier|static
name|void
name|logTimerQ
parameter_list|(
name|struct
name|libalias
modifier|*
name|la
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|sctp_nat_assoc
modifier|*
name|assoc
init|=
name|NULL
decl_stmt|;
name|SctpAliasLog
argument_list|(
literal|"t->\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SN_TIMER_QUEUE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|assoc
argument_list|,
argument|&la->sctpNatTimer.TimerQ[i]
argument_list|,
argument|timer_Q
argument_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|50
argument_list|,
literal|" l=%u "
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|//SctpAliasLog(la->logDesc," l=%d ",i);
name|logsctpassoc
argument_list|(
name|assoc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** @ingroup Logging   * @brief Sctp NAT logging function  *   * This function is based on a similar function in alias_db.c  *  * @param str/stream logging descriptor    * @param format printf type string  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|SctpAliasLog
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LIBALIAS_BUF_SIZE
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
name|LIBALIAS_BUF_SIZE
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_SECURITY
operator||
name|LOG_INFO
argument_list|,
literal|"alias_sctp: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|SctpAliasLog
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

