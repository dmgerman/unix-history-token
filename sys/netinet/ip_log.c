begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1997 by Darren Reed.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and due credit is given  * to the original author and the contributors.  *  * $Id: ip_log.c,v 1.1.1.2 1998/03/21 10:11:54 peter Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SOLARIS
end_ifndef

begin_define
define|#
directive|define
name|SOLARIS
value|(defined(sun)&& (defined(__svr4__) || defined(__SVR4)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_define
define|#
directive|define
name|__FreeBSD_version
value|300000
end_define

begin_comment
comment|/* this will do as a hack */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_if
if|#
directive|if
operator|!
name|SOLARIS
end_if

begin_if
if|#
directive|if
operator|(
name|NetBSD
operator|>
literal|199609
operator|)
operator|||
operator|(
name|OpenBSD
operator|>
literal|199603
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|linux
end_ifndef

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/ksynch.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|linux
end_ifndef

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|300000
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__sgi
end_ifdef

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IFF_DRVRLOCK
end_ifdef

begin_comment
comment|/* IRIX6 */
end_comment

begin_include
include|#
directive|include
file|<sys/hashing.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IFF_DRVRLOCK
argument_list|)
operator|)
end_if

begin_comment
comment|/*IRIX<6*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|linux
end_ifndef

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_proxy.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_auth.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SOLARIS
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|kmutex_t
name|ipl_mutex
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SOLARIS
end_if

begin_decl_stmt
specifier|extern
name|kcondvar_t
name|iplwait
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|iplog_t
modifier|*
modifier|*
name|iplh
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|iplt
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iplused
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|iplcrc
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|iplcrcinit
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|wait_queue
modifier|*
name|iplwait
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialise log buffers& pointers.  Also iniialised the CRC to a local  * secret for use in calculating the "last log checksum".  */
end_comment

begin_function
name|void
name|ipflog_init
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|iplt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|iplh
index|[
name|i
index|]
operator|=
operator|&
name|iplt
index|[
name|i
index|]
expr_stmt|;
name|iplused
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|BSD
operator|>=
literal|199306
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
else|#
directive|else
name|uniqtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iplcrcinit
operator|=
name|tv
operator|.
name|tv_sec
operator|^
operator|(
name|tv
operator|.
name|tv_usec
operator|<<
literal|8
operator|)
operator|^
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipflog  * Create a log record for a packet given that it has been triggered by a  * rule (or the default setting).  Calculate the transport protocol header  * size using predetermined size of a couple of popular protocols and thus  * how much data to copy into the log, including part of the data body if  * requested.  */
end_comment

begin_function
name|int
name|ipflog
parameter_list|(
name|flags
parameter_list|,
name|ip
parameter_list|,
name|fin
parameter_list|,
name|m
parameter_list|)
name|u_int
name|flags
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
block|{
name|ipflog_t
name|ipfl
decl_stmt|;
specifier|register
name|int
name|mlen
decl_stmt|,
name|hlen
decl_stmt|;
name|u_long
name|crc
decl_stmt|;
name|size_t
name|sizes
index|[
literal|2
index|]
decl_stmt|;
name|void
modifier|*
name|ptrs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|types
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
name|SOLARIS
name|ill_t
modifier|*
name|ifp
init|=
name|fin
operator|->
name|fin_ifp
decl_stmt|;
else|#
directive|else
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|fin
operator|->
name|fin_ifp
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * calculate header size. 	 */
name|hlen
operator|=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|struct
name|icmp
modifier|*
name|icmp
init|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
decl_stmt|;
comment|/* 		 * For ICMP, if the packet is an error packet, also include 		 * the information about the packet which caused the error. 		 */
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_REDIRECT
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|+
literal|8
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
default|default :
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Get the interface number and name to which this packet is 	 * currently associated. 	 */
if|#
directive|if
name|SOLARIS
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_char
operator|)
name|ifp
operator|->
name|ill_ppa
expr_stmt|;
name|bcopy
argument_list|(
name|ifp
operator|->
name|ill_name
argument_list|,
name|ipfl
operator|.
name|fl_ifname
argument_list|,
name|MIN
argument_list|(
name|ifp
operator|->
name|ill_name_length
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mlen
operator|=
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
condition|?
name|MIN
argument_list|(
name|msgdsize
argument_list|(
name|m
argument_list|)
operator|-
name|hlen
argument_list|,
literal|128
argument_list|)
else|:
literal|0
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|<=
literal|1991011
operator|)
operator|&&
operator|(
name|NetBSD
operator|>=
literal|199603
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|OpenBSD
argument_list|)
operator|&&
operator|(
name|OpenBSD
operator|>=
literal|199603
operator|)
operator|)
name|strncpy
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|linux
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_char
operator|)
name|ifp
operator|->
name|if_unit
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|0
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|0
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|1
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|1
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|2
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|2
index|]
operator|)
condition|)
name|ipfl
operator|.
name|fl_ifname
index|[
literal|3
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|3
index|]
expr_stmt|;
endif|#
directive|endif
name|mlen
operator|=
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
condition|?
name|MIN
argument_list|(
name|ip
operator|->
name|ip_len
operator|-
name|hlen
argument_list|,
literal|128
argument_list|)
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|ipfl
operator|.
name|fl_plen
operator|=
operator|(
name|u_char
operator|)
name|mlen
expr_stmt|;
name|ipfl
operator|.
name|fl_hlen
operator|=
operator|(
name|u_char
operator|)
name|hlen
expr_stmt|;
name|ipfl
operator|.
name|fl_rule
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
name|ipfl
operator|.
name|fl_group
operator|=
name|fin
operator|->
name|fin_group
expr_stmt|;
name|ipfl
operator|.
name|fl_flags
operator|=
name|flags
expr_stmt|;
name|ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ipfl
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ipfl
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SOLARIS
comment|/* 	 * Are we copied from the mblk or an aligned array ? 	 */
if|if
condition|(
name|ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|m
operator|->
name|b_rptr
condition|)
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|ip
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|crc
operator|=
operator|(
name|ipf_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|fin
argument_list|,
name|FI_CSIZE
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|iplcrcinit
expr_stmt|;
return|return
name|ipllog
argument_list|(
name|IPL_LOGIPF
argument_list|,
name|crc
argument_list|,
name|ptrs
argument_list|,
name|sizes
argument_list|,
name|types
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipllog  */
end_comment

begin_function
name|int
name|ipllog
parameter_list|(
name|dev
parameter_list|,
name|crc
parameter_list|,
name|items
parameter_list|,
name|itemsz
parameter_list|,
name|types
parameter_list|,
name|cnt
parameter_list|)
name|int
name|dev
decl_stmt|;
name|u_long
name|crc
decl_stmt|;
name|void
modifier|*
modifier|*
name|items
decl_stmt|;
name|size_t
modifier|*
name|itemsz
decl_stmt|;
name|int
modifier|*
name|types
decl_stmt|,
name|cnt
decl_stmt|;
block|{
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|,
name|s
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Check to see if this log record has a CRC which matches the last 	 * record logged.  If it does, just up the count on the previous one 	 * rather than create a new one. 	 */
if|if
condition|(
name|crc
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iplcrc
index|[
name|dev
index|]
operator|==
name|crc
operator|)
operator|&&
operator|*
name|iplh
index|[
name|dev
index|]
condition|)
block|{
operator|(
operator|*
name|iplh
index|[
name|dev
index|]
operator|)
operator|->
name|ipl_count
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|iplcrc
index|[
name|dev
index|]
operator|=
name|crc
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the total amount of data to be logged. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|=
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * check that we have space to record this information and can 	 * allocate that much. 	 */
name|KMALLOC
argument_list|(
name|buf
argument_list|,
name|caddr_t
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
literal|0
return|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iplused
index|[
name|dev
index|]
operator|+
name|len
operator|)
operator|>
name|IPLLOGSIZE
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iplused
index|[
name|dev
index|]
operator|+=
name|len
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * advance the log pointer to the next empty record and deduct the 	 * amount of space we're going to use. 	 */
name|ipl
operator|=
operator|(
name|iplog_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ipl
operator|->
name|ipl_magic
operator|=
name|IPL_MAGIC
expr_stmt|;
name|ipl
operator|->
name|ipl_count
operator|=
literal|1
expr_stmt|;
name|ipl
operator|->
name|ipl_next
operator|=
name|NULL
expr_stmt|;
name|ipl
operator|->
name|ipl_dsize
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|SOLARIS
operator|||
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
name|uniqtime
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|ipl
operator|->
name|ipl_sec
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|BSD
operator|>=
literal|199306
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
name|microtime
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|ipl
operator|->
name|ipl_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Loop through all the items to be logged, copying each one to the 	 * buffer.  Use bcopy for normal data or the mb_t copyout routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ipl
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|bcopy
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
name|s
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
if|#
directive|if
name|SOLARIS
name|copyout_mblk
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|m_copydata
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|s
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
block|}
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
operator|*
name|iplh
index|[
name|dev
index|]
operator|=
name|ipl
expr_stmt|;
name|iplh
index|[
name|dev
index|]
operator|=
operator|&
name|ipl
operator|->
name|ipl_next
expr_stmt|;
if|#
directive|if
name|SOLARIS
name|cv_signal
argument_list|(
operator|&
name|iplwait
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
name|wake_up_interruptible
argument_list|(
operator|&
name|iplwait
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|&
name|iplh
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ipflog_read
parameter_list|(
name|unit
parameter_list|,
name|uio
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|dlen
decl_stmt|,
name|copied
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|SOLARIS
name|int
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Sanity checks.  Make sure the minor # is valid and we're copying 	 * a valid chunk of data. 	 */
if|if
condition|(
operator|(
name|IPL_LOGMAX
operator|<
name|unit
operator|)
operator|||
operator|(
name|unit
operator|<
literal|0
operator|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
name|uio
operator|->
name|uio_resid
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|IPLLOGSIZE
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Lock the log so we can snapshot the variables.  Wait for a signal 	 * if the log is empty. 	 */
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|iplused
index|[
name|unit
index|]
operator|||
operator|!
name|iplt
index|[
name|unit
index|]
condition|)
block|{
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|cv_wait_sig
argument_list|(
operator|&
name|iplwait
argument_list|,
operator|&
name|ipl_mutex
argument_list|)
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|linux
name|interruptible_sleep_on
argument_list|(
operator|&
name|iplwait
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|signal
operator|&
operator|~
name|current
operator|->
name|blocked
condition|)
return|return
operator|-
name|EINTR
return|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|SLEEP
argument_list|(
operator|&
name|iplh
index|[
name|unit
index|]
argument_list|,
literal|"ipl sleep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
endif|#
directive|endif
comment|/* SOLARIS */
block|}
if|#
directive|if
name|BSD
operator|>=
literal|199306
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|copied
operator|=
literal|0
init|;
operator|(
name|ipl
operator|=
name|iplt
index|[
name|unit
index|]
operator|)
condition|;
name|copied
operator|+=
name|dlen
control|)
block|{
name|dlen
operator|=
name|ipl
operator|->
name|ipl_dsize
expr_stmt|;
if|if
condition|(
name|dlen
operator|+
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
operator|>
name|uio
operator|->
name|uio_resid
condition|)
break|break;
comment|/* 		 * Don't hold the mutex over the uiomove call. 		 */
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|ipl
operator|->
name|ipl_dsize
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|ipl
operator|->
name|ipl_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|iplused
index|[
name|unit
index|]
operator|-=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ipl
condition|)
block|{
name|iplused
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|iplt
index|[
name|unit
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|linux
if|if
condition|(
operator|!
name|error
condition|)
return|return
name|copied
return|;
return|return
operator|-
name|error
return|;
else|#
directive|else
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|ipflog_clear
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|int
name|used
decl_stmt|;
while|while
condition|(
operator|(
name|ipl
operator|=
name|iplt
index|[
name|unit
index|]
operator|)
condition|)
block|{
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|ipl
operator|->
name|ipl_dsize
argument_list|)
expr_stmt|;
block|}
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|used
operator|=
name|iplused
index|[
name|unit
index|]
expr_stmt|;
name|iplused
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|iplcrc
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

end_unit

