begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015  *	Jonathan Looney. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_pcap.h>
end_include

begin_define
define|#
directive|define
name|M_LEADINGSPACE_NOWRITE
parameter_list|(
name|m
parameter_list|)
define|\
value|((m)->m_data - M_START(m))
end_define

begin_decl_stmt
specifier|static
name|int
name|tcp_pcap_clusters_referenced_cur
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_pcap_clusters_referenced_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_clusters_referenced_cur
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
literal|0
argument_list|,
literal|"Number of clusters currently referenced on TCP PCAP queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_clusters_referenced_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tcp_pcap_clusters_referenced_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of clusters allowed to be referenced on TCP PCAP "
literal|"queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_pcap_alloc_reuse_ext
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_pcap_alloc_reuse_mbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_pcap_alloc_new_mbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_alloc_reuse_ext
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tcp_pcap_alloc_reuse_ext
argument_list|,
literal|0
argument_list|,
literal|"Number of mbufs with external storage reused for the TCP PCAP "
literal|"functionality"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_alloc_reuse_mbuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tcp_pcap_alloc_reuse_mbuf
argument_list|,
literal|0
argument_list|,
literal|"Number of mbufs with internal storage reused for the TCP PCAP "
literal|"functionality"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_alloc_new_mbuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tcp_pcap_alloc_new_mbuf
argument_list|,
literal|0
argument_list|,
literal|"Number of new mbufs allocated for the TCP PCAP functionality"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_pcap_packets
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_pcap_packets
value|VNET(tcp_pcap_packets)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_pcap_packets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_pcap_packets
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default number of packets saved per direction per TCPCB"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initialize the values. */
end_comment

begin_function
specifier|static
name|void
name|tcp_pcap_max_set
parameter_list|(
name|void
parameter_list|)
block|{
name|tcp_pcap_clusters_referenced_max
operator|=
name|nmbclusters
operator|/
literal|4
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_pcap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|tcp_pcap_max_set
argument_list|()
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|nmbclusters_change
argument_list|,
name|tcp_pcap_max_set
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If we are below the maximum allowed cluster references,  * increment the reference count and return TRUE. Otherwise,  * leave the reference count alone and return FALSE.  */
end_comment

begin_function
specifier|static
name|__inline
name|bool
name|tcp_pcap_take_cluster_reference
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
literal|1
argument_list|)
operator|>=
name|tcp_pcap_clusters_referenced_max
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * For all the external entries in m, apply the given adjustment.  * This can be used to adjust the counter when an mbuf chain is  * copied or freed.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|tcp_pcap_adj_cluster_reference
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|adj
parameter_list|)
block|{
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
name|adj
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free all mbufs in a chain, decrementing the reference count as  * necessary.  *  * Functions in this file should use this instead of m_freem() when  * they are freeing mbuf chains that may contain clusters that were  * already included in tcp_pcap_clusters_referenced_cur.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_pcap_m_freem
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
while|while
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mb
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|atomic_subtract_int
argument_list|(
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mb
operator|=
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy data from m to n, where n cannot fit all the data we might  * want from m.  *  * Prioritize data like this:  * 1. TCP header  * 2. IP header  * 3. Data  */
end_comment

begin_function
specifier|static
name|void
name|tcp_pcap_copy_bestfit
parameter_list|(
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_cur
init|=
name|m
decl_stmt|;
name|int
name|bytes_to_copy
init|=
literal|0
decl_stmt|,
name|trailing_data
decl_stmt|,
name|skip
init|=
literal|0
decl_stmt|,
name|tcp_off
decl_stmt|;
comment|/* Below, we assume these will be non-NULL. */
name|KASSERT
argument_list|(
name|th
argument_list|,
operator|(
literal|"%s: called with th == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"%s: called with m == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|n
argument_list|,
operator|(
literal|"%s: called with n == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* We assume this initialization occurred elsewhere. */
name|KASSERT
argument_list|(
name|n
operator|->
name|m_len
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: called with n->m_len=%d (expected 0)"
operator|,
name|__func__
operator|,
name|n
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|n
operator|->
name|m_data
operator|==
name|M_START
argument_list|(
name|n
argument_list|)
argument_list|,
operator|(
literal|"%s: called with n->m_data != M_START(n)"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the TCP header. We use this often 	 * enough that it is worth just calculating at the start. 	 */
name|tcp_off
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* Trim off leading empty mbufs. */
while|while
condition|(
name|m
operator|&&
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|m_cur
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No data? Highly unusual. We would expect to at 		 * least see a TCP header in the mbuf. 		 * As we have a pointer to the TCP header, I guess 		 * we should just copy that. (???) 		 */
name|fallback
label|:
name|bytes_to_copy
operator|=
name|tcp_off
expr_stmt|;
if|if
condition|(
name|bytes_to_copy
operator|>
name|M_SIZE
argument_list|(
name|n
argument_list|)
condition|)
name|bytes_to_copy
operator|=
name|M_SIZE
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|th
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|bytes_to_copy
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find TCP header. Record the total number of bytes up to, 	 * and including, the TCP header. 	 */
while|while
condition|(
name|m_cur
condition|)
block|{
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|th
operator|>=
operator|(
name|caddr_t
operator|)
name|m_cur
operator|->
name|m_data
operator|&&
operator|(
name|caddr_t
operator|)
name|th
operator|<
call|(
name|caddr_t
call|)
argument_list|(
name|m_cur
operator|->
name|m_data
operator|+
name|m_cur
operator|->
name|m_len
argument_list|)
condition|)
break|break;
name|bytes_to_copy
operator|+=
name|m_cur
operator|->
name|m_len
expr_stmt|;
name|m_cur
operator|=
name|m_cur
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m_cur
condition|)
name|bytes_to_copy
operator|+=
operator|(
name|caddr_t
operator|)
name|th
operator|-
operator|(
name|caddr_t
operator|)
name|m_cur
operator|->
name|m_data
expr_stmt|;
else|else
goto|goto
name|fallback
goto|;
name|bytes_to_copy
operator|+=
name|tcp_off
expr_stmt|;
comment|/* 	 * If we already want to copy more bytes than we can hold 	 * in the destination mbuf, skip leading bytes and copy 	 * what we can. 	 * 	 * Otherwise, consider trailing data. 	 */
if|if
condition|(
name|bytes_to_copy
operator|>
name|M_SIZE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|skip
operator|=
name|bytes_to_copy
operator|-
name|M_SIZE
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bytes_to_copy
operator|=
name|M_SIZE
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Determine how much trailing data is in the chain. 		 * We start with the length of this mbuf (the one 		 * containing th) and subtract the size of the TCP 		 * header (tcp_off) and the size of the data prior 		 * to th (th - m_cur->m_data). 		 * 		 * This *should not* be negative, as the TCP code 		 * should put the whole TCP header in a single 		 * mbuf. But, it isn't a problem if it is. We will 		 * simple work off our negative balance as we look 		 * at subsequent mbufs. 		 */
name|trailing_data
operator|=
name|m_cur
operator|->
name|m_len
operator|-
name|tcp_off
expr_stmt|;
name|trailing_data
operator|-=
operator|(
name|caddr_t
operator|)
name|th
operator|-
operator|(
name|caddr_t
operator|)
name|m_cur
operator|->
name|m_data
expr_stmt|;
name|m_cur
operator|=
name|m_cur
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|m_cur
condition|)
block|{
name|trailing_data
operator|+=
name|m_cur
operator|->
name|m_len
expr_stmt|;
name|m_cur
operator|=
name|m_cur
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bytes_to_copy
operator|+
name|trailing_data
operator|)
operator|>
name|M_SIZE
argument_list|(
name|n
argument_list|)
condition|)
name|bytes_to_copy
operator|=
name|M_SIZE
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|bytes_to_copy
operator|+=
name|trailing_data
expr_stmt|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
name|bytes_to_copy
argument_list|,
name|n
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|bytes_to_copy
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_pcap_add
parameter_list|(
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbufq
modifier|*
name|queue
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|NULL
decl_stmt|,
modifier|*
name|mhead
decl_stmt|;
name|KASSERT
argument_list|(
name|th
argument_list|,
operator|(
literal|"%s: called with th == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"%s: called with m == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|queue
argument_list|,
operator|(
literal|"%s: called with queue == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* We only care about data packets. */
while|while
condition|(
name|m
operator|&&
name|m
operator|->
name|m_type
operator|!=
name|MT_DATA
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* We only need to do something if we still have an mbuf. */
if|if
condition|(
operator|!
name|m
condition|)
return|return;
comment|/* If we are not saving mbufs, return now. */
if|if
condition|(
name|queue
operator|->
name|mq_maxlen
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Check to see if we will need to recycle mbufs. 	 * 	 * If we need to get rid of mbufs to stay below 	 * our packet count, try to reuse the mbuf. Once 	 * we already have a new mbuf (n), then we can 	 * simply free subsequent mbufs. 	 * 	 * Note that most of the logic in here is to deal 	 * with the reuse. If we are fine with constant 	 * mbuf allocs/deallocs, we could ditch this logic. 	 * But, it only seems to make sense to reuse 	 * mbufs we already have. 	 */
while|while
condition|(
name|mbufq_full
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|mhead
operator|=
name|mbufq_dequeue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|tcp_pcap_m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this held an external cluster, try to 			 * detach the cluster. But, if we held the 			 * last reference, go through the normal 			 * free-ing process. 			 */
if|if
condition|(
name|mhead
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
switch|switch
condition|(
name|mhead
operator|->
name|m_ext
operator|.
name|ext_type
condition|)
block|{
case|case
name|EXT_SFBUF
case|:
comment|/* Don't mess around with these. */
name|tcp_pcap_m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
name|mhead
operator|->
name|m_ext
operator|.
name|ext_cnt
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 						 * We held the last reference 						 * on this cluster. Restore 						 * the reference count and put 						 * it back in the pool. 				 		 */
operator|*
operator|(
name|mhead
operator|->
name|m_ext
operator|.
name|ext_cnt
operator|)
operator|=
literal|1
expr_stmt|;
name|tcp_pcap_m_freem
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 					 * We were able to cleanly free the 					 * reference. 				 	 */
name|atomic_subtract_int
argument_list|(
operator|&
name|tcp_pcap_clusters_referenced_cur
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tcp_pcap_alloc_reuse_ext
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tcp_pcap_alloc_reuse_mbuf
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|mhead
expr_stmt|;
name|tcp_pcap_m_freem
argument_list|(
name|n
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m_init
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check to see if we need to get a new mbuf. */
if|if
condition|(
operator|!
name|n
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
condition|)
return|return;
name|tcp_pcap_alloc_new_mbuf
operator|++
expr_stmt|;
block|}
comment|/* 	 * What are we dealing with? If a cluster, attach it. Otherwise, 	 * try to copy the data from the beginning of the mbuf to the 	 * end of data. (There may be data between the start of the data 	 * area and the current data pointer. We want to get this, because 	 * it may contain header information that is useful.) 	 * In cases where that isn't possible, settle for what we can 	 * get. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
name|tcp_pcap_take_cluster_reference
argument_list|()
condition|)
block|{
name|n
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|mb_dupcl
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|m
operator|->
name|m_data
operator|+
name|m
operator|->
name|m_len
operator|)
operator|-
name|M_START
argument_list|(
name|m
argument_list|)
operator|)
operator|<=
name|M_SIZE
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|/* 		 * At this point, n is guaranteed to be a normal mbuf 		 * with no cluster and no packet header. Because the 		 * logic in this code block requires this, the assert 		 * is here to catch any instances where someone 		 * changes the logic to invalidate that assumption. 		 */
name|KASSERT
argument_list|(
operator|(
name|n
operator|->
name|m_flags
operator|&
operator|(
name|M_EXT
operator||
name|M_PKTHDR
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Unexpected flags (%#x) for mbuf"
operator|,
name|__func__
operator|,
name|n
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|=
name|n
operator|->
name|m_dat
operator|+
name|M_LEADINGSPACE_NOWRITE
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|M_START
argument_list|(
name|m
argument_list|)
argument_list|,
name|n
operator|->
name|m_dat
argument_list|,
name|m
operator|->
name|m_len
operator|+
name|M_LEADINGSPACE_NOWRITE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is the case where we need to "settle for what 		 * we can get". The most probable way to this code 		 * path is that we've already taken references to the 		 * maximum number of mbuf clusters we can, and the data 		 * is too long to fit in an mbuf's internal storage. 		 * Try for a "best fit". 		 */
name|tcp_pcap_copy_bestfit
argument_list|(
name|th
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Don't try to get additional data. */
goto|goto
name|add_to_queue
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|n
operator|->
name|m_next
operator|=
name|m_copym
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|tcp_pcap_adj_cluster_reference
argument_list|(
name|n
operator|->
name|m_next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_to_queue
label|:
comment|/* Add the new mbuf to the list. */
if|if
condition|(
name|mbufq_enqueue
argument_list|(
name|queue
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* This shouldn't happen. If INVARIANTS is defined, panic. */
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: mbufq was unexpectedly full!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|tcp_pcap_m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcp_pcap_drain
parameter_list|(
name|struct
name|mbufq
modifier|*
name|queue
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
name|queue
argument_list|)
operator|)
condition|)
name|tcp_pcap_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_pcap_tcpcb_init
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|mbufq_init
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|t_inpkts
operator|)
argument_list|,
name|V_tcp_pcap_packets
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|t_outpkts
operator|)
argument_list|,
name|V_tcp_pcap_packets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_pcap_set_sock_max
parameter_list|(
name|struct
name|mbufq
modifier|*
name|queue
parameter_list|,
name|int
name|newval
parameter_list|)
block|{
name|queue
operator|->
name|mq_maxlen
operator|=
name|newval
expr_stmt|;
while|while
condition|(
name|queue
operator|->
name|mq_len
operator|>
name|queue
operator|->
name|mq_maxlen
condition|)
name|tcp_pcap_m_freem
argument_list|(
name|mbufq_dequeue
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tcp_pcap_get_sock_max
parameter_list|(
name|struct
name|mbufq
modifier|*
name|queue
parameter_list|)
block|{
return|return
name|queue
operator|->
name|mq_maxlen
return|;
block|}
end_function

end_unit

